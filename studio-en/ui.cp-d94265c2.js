System.register(['./__rootModule___commonjs-entry-039abf1b.js', './loading-indicator.cp-668e5ddc.js', './index-0250cb25.js', './index-d0172adc.js', './index-d97f22af.js', './list.cp-50d496c7.js', './client-fb647a5a.js', './editor-modes-0f820fa8.js', './search-cf1a5c4c.js', './shell-interface-e2437883.js', './index-009b6510.js'], (function (exports, module) {
  var __contextModule__ = typeof module !== 'undefined' ? module : arguments[1];
;
  var _asyncToGenerator, resource, _slicedToArray, _toConsumableArray$1, _createForOfIteratorHelper, groupByKey, compact, waitFor, pluck, _typeof$1, initializeClass, Path, isString$3, dissoc, createFiles, sortByKey, inspect$1, indent, range, sortBy, equals, print, isPrimitive, isArray$2, roundTo, keys$1, select, last$2, newUUID, signal, connect, capitalize, _defineProperty, Color, pt, morph, debounceNamed, MorphicEnv, Rectangle, formatFromArray, Morph, once$1, delay, easings, component, Label, rect, Icon, part, SystemTooltip, ViewModel, ShadowObject, TilingLayout, HTMLMorph, LinearGradient, add, without, uniq, RadialGradient, materialDesignColors, noUpdate, withoutAll, guardNamed, clamp, flatDesignColors, webSafeColors, KeyHandler, Polygon, Point, min, remove, ExpressionSerializer, invoke, Ellipse, genN, zip, truncate, config$2, arr, Range, disconnect, reMatches, lines, swap$1, sum, levenshtein, printTable, groupBy, max, without$1, dropWhile, chain, Text, ConstraintLayout, EventEmitter, toJsIdentifier, incName, compose, availableFonts, pushIfNotIncluded, ensureFolder, camelize, joinPath, string, uniqBy, _wrapRegExp, isFunction$2, values, moduleOfId, classNameOfId, intersect, referencesOfId, isReference, removeUnreachableObjects, createMorphSnapshot, serializeMorph, throttleNamed, p, format$2, waitFor$1, deferred, addOrChangeLinkedCSS, _createClass, _classCallCheck, IFrameMorph, printTree, takeWhile, Icons, serializeSpec, isBoolean$1, toDegrees, serializeNestedProp, extract, applyChange, create, subscribe, isObject$2, serialize$1, isRegExp$2, allPlugins, camelCaseString, findAndGet, first, notYetImplemented, mapTree, isEmpty, getDefaultValueFor, isFoldableProp, PolicyApplicator, decamelize, applyChanges, withAllViewModelsDo, adoptObject, evalAsSpec, ComponentDescriptor, hashCode, objectReplacementChar, filter, tokens, toRadians, epiConnect, DEFAULT_FONTS, fontWeightToString, rainbow, fontWeightNameToNumeric, sanitizeFont, interactiveCommands, forEachOwn, disconnectAll, interpose, detent, rotate, GridLayout, Path$1, isUUID, count, isNumber$2, precision, Spinner, ButtonDefault, ButtonModel, SystemButton, DarkButton, open$1, runFn, TreeData, Tree, InputLine, FilterableList, List, AbstractPromptModel, LightPrompt, InputLineDefault, GreenButton, RedButton, HorizontalResizer, LabeledCheckboxOnDark, LabeledCheckboxLight, Menu, LabeledCheckbox, DropDownSelector, DropDownListModel, SearchField, wrapInFunction, topLevelDeclsAndRefs, declarationsOfScope, parse$2, fuzzyParse, custom, findNodeAfter, nodesAt$1, findDeclarationClosestToIndex, scopeAtIndex, findReferencesAndDeclsInScope, nodesAtIndex, parseFunction, parser, knownGlobals, ReplaceVisitor, stringify, member, literal, objectSpreadTransform, exports$$, recursive, base, imports, scopes, queryNodes, findGlobalVarRefs, id, findDecls, module$1, runEval$1, classToFunctionTransform, printSystemConfig, defaultSystem, getPackages, getPackageOfModule, isModuleLoaded, ExportLookup, getPackage, getCompletions, registerPackage, importPackage, removePackage, reloadPackage, applyPackageConfig, HttpEvalStrategy, L2LEvalStrategy, es5Transpilation, PackageRegistry, stringifyFunctionWithoutToplevelRecorder, detectModuleFormat, GlobalInjector, insertCapturesForExportedImports, insertCapturesForFunctionDeclarations, replaceExportedNamespaces, rewriteToCaptureTopLevelVariables, ensureComponentDescriptors, replaceExportedVarDeclarations, replaceImportedNamespaces, packagesConfig, ImportInjector, ImportRemover, module$2, modules, syncEval, DefaultList, DarkList, DarkDropDownList$1, DropDownList, L2LClient, tokenizeDocument, visitDocumentTokens, getMode, modeInfo, defineMode, passIndent, registerHelper, defineMIME, mimeModes, copyState, startState, innerMode, TextSearcher, runCommand, defaultDirectory, currentUsername, isUserLoggedIn;
  return {
    setters: [function (module) {
      _asyncToGenerator = module._;
      resource = module.ac;
      _slicedToArray = module.o;
      _toConsumableArray$1 = module.r;
      _createForOfIteratorHelper = module.a6;
      groupByKey = module.by;
      compact = module.aT;
      waitFor = module.aE;
      pluck = module.c9;
      _typeof$1 = module.a5;
      initializeClass = module.i;
      Path = module.bw;
      isString$3 = module.bv;
      dissoc = module.y;
      createFiles = module.ci;
      sortByKey = module.cj;
      inspect$1 = module.aA;
      indent = module.ck;
      range = module.aO;
      sortBy = module.aP;
      equals = module.af;
      print = module.c3;
      isPrimitive = module.a_;
      isArray$2 = module.bh;
      roundTo = module.bY;
      keys$1 = module.bX;
      select = module.aW;
      last$2 = module.q;
      newUUID = module.cl;
      signal = module.s;
      connect = module.a;
      capitalize = module.bo;
      _defineProperty = module.ah;
      Color = module.C;
      pt = module.b;
      morph = module.aZ;
      debounceNamed = module.z;
      MorphicEnv = module.cm;
      Rectangle = module.R;
      formatFromArray = module.aB;
      Morph = module.M;
      once$1 = module.aF;
      delay = module.l;
      easings = module.az;
      component = module.c;
      Label = module.L;
      rect = module.ap;
      Icon = module.h;
      part = module.p;
      SystemTooltip = module.bg;
      ViewModel = module.V;
      ShadowObject = module.ao;
      TilingLayout = module.T;
      HTMLMorph = module.al;
      LinearGradient = module.au;
      add = module.ar;
      without = module.as;
      uniq = module.u;
      RadialGradient = module.cn;
      materialDesignColors = module.aG;
      noUpdate = module.b5;
      withoutAll = module.x;
      guardNamed = module.k;
      clamp = module.bF;
      flatDesignColors = module.co;
      webSafeColors = module.cp;
      KeyHandler = module.aS;
      Polygon = module.bf;
      Point = module.bu;
      min = module.b1;
      remove = module.w;
      ExpressionSerializer = module.br;
      invoke = module.cq;
      Ellipse = module.aC;
      genN = module.bS;
      zip = module.D;
      truncate = module.aj;
      config$2 = module.v;
      arr = module.ba;
      Range = module.bO;
      disconnect = module.n;
      reMatches = module.cr;
      lines = module.a$;
      swap$1 = module.cs;
      sum = module.b7;
      levenshtein = module.b8;
      printTable = module.ct;
      groupBy = module.be;
      max = module.av;
      without$1 = module.aQ;
      dropWhile = module.cu;
      chain = module.cv;
      Text = module.j;
      ConstraintLayout = module.at;
      EventEmitter = module.cw;
      toJsIdentifier = module.cx;
      incName = module.bq;
      compose = module.cy;
      availableFonts = module.cz;
      pushIfNotIncluded = module.bP;
      ensureFolder = module.cA;
      camelize = module.cB;
      joinPath = module.b9;
      string = module.cC;
      uniqBy = module.ae;
      _wrapRegExp = module.cD;
      isFunction$2 = module.cE;
      values = module.bj;
      moduleOfId = module.cF;
      classNameOfId = module.cG;
      intersect = module.cH;
      referencesOfId = module.cI;
      isReference = module.cJ;
      removeUnreachableObjects = module.cK;
      createMorphSnapshot = module.aV;
      serializeMorph = module.cL;
      throttleNamed = module.cM;
      p = module.cN;
      format$2 = module.cO;
      waitFor$1 = module.cP;
      deferred = module.a9;
      addOrChangeLinkedCSS = module.cQ;
      _createClass = module.g;
      _classCallCheck = module.f;
      IFrameMorph = module.cR;
      printTree = module.bW;
      takeWhile = module.ca;
      Icons = module.cS;
      serializeSpec = module.cT;
      isBoolean$1 = module.cU;
      toDegrees = module.bm;
      serializeNestedProp = module.cV;
      extract = module.cW;
      applyChange = module.cX;
      create = module.cY;
      subscribe = module.bb;
      isObject$2 = module.c4;
      serialize$1 = module.bx;
      isRegExp$2 = module.cZ;
      allPlugins = module.c_;
      camelCaseString = module.bn;
      findAndGet = module.b0;
      first = module.bK;
      notYetImplemented = module.bl;
      mapTree = module.c$;
      isEmpty = module.bp;
      getDefaultValueFor = module.d0;
      isFoldableProp = module.d1;
      PolicyApplicator = module.aJ;
      decamelize = module.b3;
      applyChanges = module.d2;
      withAllViewModelsDo = module.b4;
      adoptObject = module.bc;
      evalAsSpec = module.d3;
      ComponentDescriptor = module.d4;
      hashCode = module.cd;
      objectReplacementChar = module.d5;
      filter = module.d6;
      tokens = module.d7;
      toRadians = module.aI;
      epiConnect = module.aL;
      DEFAULT_FONTS = module.d8;
      fontWeightToString = module.d9;
      rainbow = module.da;
      fontWeightNameToNumeric = module.db;
      sanitizeFont = module.dc;
      interactiveCommands = module.dd;
      forEachOwn = module.bZ;
      disconnectAll = module.de;
      interpose = module.df;
      detent = module.dg;
      rotate = module.dh;
      GridLayout = module.G;
      Path$1 = module.aq;
      isUUID = module.di;
      count = module.dj;
      isNumber$2 = module.dk;
      precision = module.dl;
    }, function (module) {
      Spinner = module.S;
      ButtonDefault = module.d;
      ButtonModel = module.c;
      SystemButton = module.a;
      DarkButton = module.D;
      open$1 = module.o;
      runFn = module.r;
    }, function (module) {
      TreeData = module.T;
      Tree = module.r;
      InputLine = module.I;
      FilterableList = module.F;
      List = module.s;
      AbstractPromptModel = module.A;
      LightPrompt = module.L;
      InputLineDefault = module.d;
      GreenButton = module.G;
      RedButton = module.R;
      HorizontalResizer = module.H;
      LabeledCheckboxOnDark = module.t;
      LabeledCheckboxLight = module.c;
      Menu = module.m;
      LabeledCheckbox = module.f;
      DropDownSelector = module.u;
      DropDownListModel = module.p;
      SearchField = module.S;
    }, function (module) {
      wrapInFunction = module.J;
      topLevelDeclsAndRefs = module.t;
      declarationsOfScope = module.K;
      parse$2 = module.p;
      fuzzyParse = module.C;
      custom = module.L;
      findNodeAfter = module.M;
      nodesAt$1 = module.N;
      findDeclarationClosestToIndex = module.O;
      scopeAtIndex = module.P;
      findReferencesAndDeclsInScope = module.S;
      nodesAtIndex = module.H;
      parseFunction = module.r;
      parser = module.T;
      knownGlobals = module.E;
      ReplaceVisitor = module.R;
      stringify = module.s;
      member = module.m;
      literal = module.l;
      objectSpreadTransform = module.y;
      exports$$ = module.U;
      recursive = module.W;
      base = module.X;
      imports = module.F;
      scopes = module.B;
      queryNodes = module.u;
      findGlobalVarRefs = module.D;
      id = module.i;
      findDecls = module.Y;
    }, function (module) {
      module$1 = module.a;
      runEval$1 = module.b;
      classToFunctionTransform = module.c;
      printSystemConfig = module.p;
      defaultSystem = module.d;
      getPackages = module.e;
      getPackageOfModule = module.f;
      isModuleLoaded = module.i;
      ExportLookup = module.E;
      getPackage = module.h;
      getCompletions = module.g;
      registerPackage = module.k;
      importPackage = module.l;
      removePackage = module.n;
      reloadPackage = module.o;
      applyPackageConfig = module.q;
      HttpEvalStrategy = module.H;
      L2LEvalStrategy = module.L;
      es5Transpilation = module.s;
      PackageRegistry = module.P;
      stringifyFunctionWithoutToplevelRecorder = module.t;
      detectModuleFormat = module.u;
      GlobalInjector = module.G;
      insertCapturesForExportedImports = module.v;
      insertCapturesForFunctionDeclarations = module.w;
      replaceExportedNamespaces = module.x;
      rewriteToCaptureTopLevelVariables = module.y;
      ensureComponentDescriptors = module.z;
      replaceExportedVarDeclarations = module.A;
      replaceImportedNamespaces = module.C;
      packagesConfig = module.D;
      ImportInjector = module.I;
      ImportRemover = module.F;
      module$2 = module.J;
      modules = module.m;
      syncEval = module.K;
    }, function (module) {
      DefaultList = module.b;
      DarkList = module.c;
      DarkDropDownList$1 = module.a;
      DropDownList = module.D;
    }, function (module) {
      L2LClient = module["default"];
    }, function (module) {
      tokenizeDocument = module.tokenizeDocument;
      visitDocumentTokens = module.visitDocumentTokens;
      getMode = module.getMode;
      modeInfo = module.modeInfo;
      defineMode = module.defineMode;
      passIndent = module.passIndent;
      registerHelper = module.registerHelper;
      defineMIME = module.defineMIME;
      mimeModes = module.mimeModes;
      copyState = module.copyState;
      startState = module.startState;
      innerMode = module.innerMode;
    }, function (module) {
      TextSearcher = module.TextSearcher;
    }, function (module) {
      runCommand = module.runCommand;
      defaultDirectory = module.defaultDirectory;
    }, function (module) {
      currentUsername = module.currentUsername;
      isUserLoggedIn = module.isUserLoggedIn;
    }],
    execute: (function () {

      var _missingExportShim = void 0;

      var __varRecorder__$1m = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively-system-interface/commands/packages.js", __contextModule__);
      var __moduleMeta__$C = {
        pathInPackage: function pathInPackage() {
          return "./commands/packages.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively-system-interface",
            version: "0.2.1"
          };
        }
      };

      var loadPackage = exports('a', __varRecorder__$1m["lively-system-interface/commands/packages.js__define__"]("loadPackage", "function", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(system, spec) {
          var mochaEs6;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return system.importPackage(spec.address + "/");

                case 2:
                  if (!spec.main) {
                    _context.next = 5;
                    break;
                  }

                  _context.next = 5;
                  return system.importModule(spec.main.toString());

                case 5:
                  if (!spec.test) {
                    _context.next = 19;
                    break;
                  }

                  _context.prev = 6;
                  _context.next = 9;
                  return system.importPackage("mocha-es6");

                case 9:
                  mochaEs6 = _context.sent;
                  _context.next = 12;
                  return mochaEs6.installSystemInstantiateHook();

                case 12:
                  _context.next = 14;
                  return system.importModule(spec.test.toString());

                case 14:
                  _context.next = 19;
                  break;

                case 16:
                  _context.prev = 16;
                  _context.t0 = _context["catch"](6);
                  console.warn("Cannot load test of new package: ".concat(_context.t0));

                case 19:
                  return _context.abrupt("return", system.getPackage(spec.address));

                case 20:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[6, 16]]);
        }));

        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }(), __moduleMeta__$C));

      __varRecorder__$1m.loadPackage = loadPackage;

      var interactivelyCreatePackage = __varRecorder__$1m["lively-system-interface/commands/packages.js__define__"]("interactivelyCreatePackage", "function", /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(system, requester) {
          var world, name, guessedAddress, res, baseURL, maybePackageDir, loc, url, address;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  world = requester.world();
                  _context2.next = 3;
                  return world.prompt("Enter package name", {
                    requester: requester,
                    input: "",
                    historyId: "lively.vm-editor-add-package-name",
                    useLastInput: true
                  });

                case 3:
                  name = _context2.sent;

                  if (name) {
                    _context2.next = 6;
                    break;
                  }

                  throw "Canceled";

                case 6:
                  _context2.prev = 6;
                  res = resource(name);
                  name = res.name();
                  guessedAddress = res.url;
                  _context2.next = 21;
                  break;

                case 12:
                  _context2.prev = 12;
                  _context2.t0 = _context2["catch"](6);
                  _context2.next = 16;
                  return system.getConfig();

                case 16:
                  baseURL = _context2.sent.baseURL;
                  maybePackageDir = resource(baseURL).join(name).asDirectory().url;
                  _context2.next = 20;
                  return system.normalize(maybePackageDir);

                case 20:
                  guessedAddress = _context2.sent.replace(/\/\.js$/, "/");

                case 21:
                  _context2.next = 23;
                  return world.prompt("Confirm or change package location", {
                    requester: requester,
                    input: guessedAddress,
                    historyId: "lively.vm-editor-add-package-address"
                  });

                case 23:
                  loc = _context2.sent;

                  if (loc) {
                    _context2.next = 26;
                    break;
                  }

                  throw "Canceled";

                case 26:
                  url = resource(loc).asDirectory();
                  address = url.asFile().url;
                  _context2.next = 30;
                  return system.removePackage(address);

                case 30:
                  _context2.next = 32;
                  return system.resourceCreateFiles(address, {
                    "index.js": "'format esm';\n",
                    "package.json": "{\n  \"name\": \"".concat(name, "\",\n  \"version\": \"0.1.0\"\n}"),
                    ".gitignore": "node_modules/",
                    "README.md": "# ".concat(name, "\n\nNo description for package ").concat(name, " yet.\n"),
                    tests: {
                      "test.js": "import { expect } from \"mocha-es6\";\ndescribe(\"".concat(name, "\", () => {\n  it(\"works\", () => {\n    expect(1 + 2).equals(3);\n  });\n});")
                    }
                  });

                case 32:
                  return _context2.abrupt("return", __varRecorder__$1m.loadPackage(system, {
                    name: name,
                    address: address,
                    configFile: url.join("package.json").url,
                    main: url.join("index.js").url,
                    test: url.join("tests/test.js").url,
                    type: "package"
                  }));

                case 33:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[6, 12]]);
        }));

        return function (_x3, _x4) {
          return _ref2.apply(this, arguments);
        };
      }(), __moduleMeta__$C);

      __varRecorder__$1m.interactivelyCreatePackage = interactivelyCreatePackage;

      var interactivelyLoadPackage = __varRecorder__$1m["lively-system-interface/commands/packages.js__define__"]("interactivelyLoadPackage", "function", /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(system, requester) {
          var relatedPackageAddress,
              relatedPackage,
              spec,
              config,
              packageCandidates,
              _yield$requester$worl,
              dir,
              _args3 = arguments;

          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  relatedPackageAddress = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : null;
                  spec = {
                    name: "",
                    address: "",
                    type: "package"
                  };
                  _context3.next = 4;
                  return system.getConfig();

                case 4:
                  config = _context3.sent;

                  if (!relatedPackageAddress) {
                    _context3.next = 14;
                    break;
                  }

                  _context3.next = 8;
                  return system.getPackage(relatedPackageAddress);

                case 8:
                  _context3.t0 = _context3.sent;

                  if (_context3.t0) {
                    _context3.next = 13;
                    break;
                  }

                  _context3.next = 12;
                  return system.getPackageForModule(relatedPackageAddress);

                case 12:
                  _context3.t0 = _context3.sent;

                case 13:
                  relatedPackage = _context3.t0;

                case 14:
                  _context3.next = 16;
                  return resource(config.baseURL).dirList(2, {
                    exclude: function exclude(dir) {
                      return dir.isFile() && !dir.name().endsWith("package.json");
                    }
                  });

                case 16:
                  packageCandidates = _context3.sent;
                  packageCandidates = packageCandidates.filter(function (dir) {
                    return dir.name().endsWith("package.json");
                  }).map(function (f) {
                    return f.parent();
                  }).filter(function (p) {
                    return !config.packages[p.asFile().url];
                  });
                  _context3.t1 = _slicedToArray;
                  _context3.next = 21;
                  return requester.world().filterableListPrompt("Select package directory", [{
                    isListItem: true,
                    label: "Enter custom package...",
                    value: "custom"
                  }].concat(_toConsumableArray$1(packageCandidates.map(function (m) {
                    return m.url;
                  }))), {
                    multiSelect: false,
                    requester: requester
                  });

                case 21:
                  _context3.t2 = _context3.sent.selected;
                  _yield$requester$worl = (0, _context3.t1)(_context3.t2, 1);
                  dir = _yield$requester$worl[0];

                  if (!(dir === "custom")) {
                    _context3.next = 28;
                    break;
                  }

                  _context3.next = 27;
                  return requester.world().prompt("What is the package directory?", {
                    requester: requester,
                    input: relatedPackage ? relatedPackage.address : config.baseURL,
                    historyId: "lively.vm-editor-package-load-history",
                    useLastInput: false
                  });

                case 27:
                  dir = _context3.sent;

                case 28:
                  if (dir) {
                    _context3.next = 30;
                    break;
                  }

                  throw "Canceled";

                case 30:
                  spec.address = dir.replace(/\/$/, "");
                  spec.url = new URL(spec.address + "/");
                  spec.configFile = resource(spec.url).join("package.json").url;
                  _context3.prev = 33;
                  _context3.t3 = JSON;
                  _context3.next = 37;
                  return system.moduleRead(spec.configFile);

                case 37:
                  _context3.t4 = _context3.sent;
                  _context3.t3.parse.call(_context3.t3, _context3.t4).name;
                  _context3.next = 45;
                  break;

                case 41:
                  _context3.prev = 41;
                  _context3.t5 = _context3["catch"](33);
                  spec.name = String(spec.url).replace(/\/$/, "");
                  system.resourceEnsureExistance(spec.configFile, "{\n  \"name\": \"".concat(spec.name, "\",\n  \"version\": \"0.1.0\"\n}"));

                case 45:
                  return _context3.abrupt("return", __varRecorder__$1m.loadPackage(system, spec));

                case 46:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, null, [[33, 41]]);
        }));

        return function (_x5, _x6) {
          return _ref3.apply(this, arguments);
        };
      }(), __moduleMeta__$C);

      __varRecorder__$1m.interactivelyLoadPackage = interactivelyLoadPackage;

      var interactivelyReloadPackage = __varRecorder__$1m["lively-system-interface/commands/packages.js__define__"]("interactivelyReloadPackage", "function", /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(system, vmEditor, packageURL) {
          var name, p;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  name = resource(packageURL).asFile().url;
                  _context4.next = 3;
                  return system.getPackage(name);

                case 3:
                  _context4.t0 = _context4.sent;

                  if (_context4.t0) {
                    _context4.next = 8;
                    break;
                  }

                  _context4.next = 7;
                  return system.getPackageForModule(name);

                case 7:
                  _context4.t0 = _context4.sent;

                case 8:
                  p = _context4.t0;

                  if (p) {
                    _context4.next = 11;
                    break;
                  }

                  throw new Error("Cannot find package for " + name);

                case 11:
                  _context4.next = 13;
                  return system.reloadPackage(name);

                case 13:
                  if (!vmEditor) {
                    _context4.next = 19;
                    break;
                  }

                  _context4.next = 16;
                  return vmEditor.updateModuleList();

                case 16:
                  _context4.next = 18;
                  return vmEditor.uiSelect(name, false);

                case 18:
                  return _context4.abrupt("return", _context4.sent);

                case 19:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        return function (_x7, _x8, _x9) {
          return _ref4.apply(this, arguments);
        };
      }(), __moduleMeta__$C);

      __varRecorder__$1m.interactivelyReloadPackage = interactivelyReloadPackage;

      var interactivelyUnloadPackage = __varRecorder__$1m["lively-system-interface/commands/packages.js__define__"]("interactivelyUnloadPackage", "function", /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(system, vmEditor, packageURL, world) {
          var p, really;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return system.getPackage(packageURL);

                case 2:
                  p = _context5.sent;
                  _context5.next = 5;
                  return (world || $world).confirm("Unload package ".concat(p.name, "?"), {
                    requester: vmEditor
                  });

                case 5:
                  really = _context5.sent;

                  if (really) {
                    _context5.next = 8;
                    break;
                  }

                  throw "Canceled";

                case 8:
                  _context5.next = 10;
                  return system.removePackage(packageURL);

                case 10:
                  if (!vmEditor) {
                    _context5.next = 15;
                    break;
                  }

                  _context5.next = 13;
                  return vmEditor.updateModuleList();

                case 13:
                  _context5.next = 15;
                  return vmEditor.uiSelect(null);

                case 15:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        return function (_x10, _x11, _x12, _x13) {
          return _ref5.apply(this, arguments);
        };
      }(), __moduleMeta__$C);

      __varRecorder__$1m.interactivelyUnloadPackage = interactivelyUnloadPackage;

      var interactivelyRemovePackage = __varRecorder__$1m["lively-system-interface/commands/packages.js__define__"]("interactivelyRemovePackage", "function", /*#__PURE__*/function () {
        var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(system, requester, packageURL) {
          var world, p, really, really2, really3;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  world = requester.world();
                  _context6.next = 3;
                  return system.getPackage(packageURL);

                case 3:
                  p = _context6.sent;

                  if (p) {
                    _context6.next = 7;
                    break;
                  }

                  $world.inform("No package \"".concat(packageURL, "\" found!"), {
                    requester: requester
                  });
                  return _context6.abrupt("return");

                case 7:
                  _context6.next = 9;
                  return world.confirm("Really remove package ".concat(p.name, "?"), {
                    requester: requester
                  });

                case 9:
                  really = _context6.sent;

                  if (really) {
                    _context6.next = 12;
                    break;
                  }

                  throw "Canceled";

                case 12:
                  system.removePackage(packageURL);
                  _context6.next = 15;
                  return world.confirm("Also remove directory ".concat(p.name, " including ").concat(p.modules.length, " modules?"));

                case 15:
                  really2 = _context6.sent;

                  if (!really2) {
                    _context6.next = 23;
                    break;
                  }

                  _context6.next = 19;
                  return world.confirm("REALLY *remove* directory ".concat(p.name, "? No undo possible..."));

                case 19:
                  really3 = _context6.sent;

                  if (!really3) {
                    _context6.next = 23;
                    break;
                  }

                  _context6.next = 23;
                  return system.resourceRemove(p.address);

                case 23:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        return function (_x14, _x15, _x16) {
          return _ref6.apply(this, arguments);
        };
      }(), __moduleMeta__$C);

      __varRecorder__$1m.interactivelyRemovePackage = interactivelyRemovePackage;

      var showExportsAndImportsOf = __varRecorder__$1m["lively-system-interface/commands/packages.js__define__"]("showExportsAndImportsOf", "function", /*#__PURE__*/function () {
        var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(system, packageAddress) {
          var world,
              p,
              importsExports,
              reports,
              _iterator,
              _step,
              mod,
              report,
              _args7 = arguments;

          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  world = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : $world;
                  _context7.next = 3;
                  return system.getPackage(packageAddress);

                case 3:
                  p = _context7.sent;

                  if (p) {
                    _context7.next = 6;
                    break;
                  }

                  throw new Error("Cannot find package " + packageAddress);

                case 6:
                  reports = [];
                  _iterator = _createForOfIteratorHelper(p.modules);
                  _context7.prev = 8;

                  _iterator.s();

                case 10:
                  if ((_step = _iterator.n()).done) {
                    _context7.next = 38;
                    break;
                  }

                  mod = _step.value;

                  if (mod.name.match(/\.js$/)) {
                    _context7.next = 14;
                    break;
                  }

                  return _context7.abrupt("continue", 36);

                case 14:
                  _context7.prev = 14;
                  _context7.t0 = system;
                  _context7.t1 = mod.name;
                  _context7.next = 19;
                  return system.moduleRead(mod.name);

                case 19:
                  _context7.t2 = _context7.sent;
                  _context7.next = 22;
                  return _context7.t0.importsAndExportsOf.call(_context7.t0, _context7.t1, _context7.t2);

                case 22:
                  importsExports = _context7.sent;
                  _context7.next = 29;
                  break;

                case 25:
                  _context7.prev = 25;
                  _context7.t3 = _context7["catch"](14);
                  world.logError(new Error("Error when getting imports/exports from module ".concat(mod.name, ":\n").concat(_context7.t3.stack)));
                  return _context7.abrupt("continue", 36);

                case 29:
                  report = "".concat(mod.name);

                  if (!(!importsExports.imports.length && !importsExports.exports.length)) {
                    _context7.next = 33;
                    break;
                  }

                  report += "\n  does not import / export anything";
                  return _context7.abrupt("continue", 36);

                case 33:
                  if (importsExports.imports.length) {
                    report += "\n  imports:\n";
                    report += groupByKey(importsExports.imports, "fromModule").mapGroups(function (from, imports) {
                      return "from ".concat(from, ": ") + imports.map(function (ea) {
                        return !ea.local && !ea.imported ? "nothing imported" : !ea.imported || ea.imported === ea.local ? ea.local : "".concat(ea.imported, " as ").concat(ea.local);
                      }).join(", ");
                    }).toArray().join("\n").split("\n").map(function (ea) {
                      return ea = "    " + ea;
                    }).join("\n");
                  }

                  if (importsExports.exports.length) {
                    report += "\n  exports:\n";
                    report += importsExports.exports.map(function (ea) {
                      return !ea.local ? "".concat(ea.exported, " from ").concat(ea.fromModule) : !ea.local || ea.local === ea.exported ? ea.exported : "".concat(ea.local, " as ").concat(ea.exported);
                    }).join(", ").split("\n").map(function (ea) {
                      return ea = "    " + ea;
                    }).join("\n");
                  }

                  reports.push(report);

                case 36:
                  _context7.next = 10;
                  break;

                case 38:
                  _context7.next = 43;
                  break;

                case 40:
                  _context7.prev = 40;
                  _context7.t4 = _context7["catch"](8);

                  _iterator.e(_context7.t4);

                case 43:
                  _context7.prev = 43;

                  _iterator.f();

                  return _context7.finish(43);

                case 46:
                  _context7.next = 48;
                  return world.execCommand("open text window", {
                    title: "imports and exports of " + packageAddress,
                    content: reports.join("\n\n")
                  });

                case 48:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, null, [[8, 40, 43, 46], [14, 25]]);
        }));

        return function (_x17, _x18) {
          return _ref7.apply(this, arguments);
        };
      }(), __moduleMeta__$C);

      __varRecorder__$1m.showExportsAndImportsOf = showExportsAndImportsOf;
      __varRecorder__$1m.loadPackage = loadPackage;
      __varRecorder__$1m.interactivelyCreatePackage = interactivelyCreatePackage;
      __varRecorder__$1m.interactivelyLoadPackage = interactivelyLoadPackage;
      __varRecorder__$1m.interactivelyReloadPackage = interactivelyReloadPackage;
      __varRecorder__$1m.interactivelyUnloadPackage = interactivelyUnloadPackage;
      __varRecorder__$1m.interactivelyRemovePackage = interactivelyRemovePackage;
      __varRecorder__$1m.showExportsAndImportsOf = showExportsAndImportsOf;

      var __varRecorder__$1l = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively-system-interface/commands/modules.js", __contextModule__);
      var __moduleMeta__$B = {
        pathInPackage: function pathInPackage() {
          return "./commands/modules.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively-system-interface",
            version: "0.2.1"
          };
        }
      };

      var isTestModule = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("isTestModule", "function", function (source) {
        try {
          var isTest = source.match(/import.*['"]mocha(-es6)?['"]/) && source.match(/it\(['"]/);
          return isTest;
        } catch (err) {
          return false;
        }
      }, __moduleMeta__$B);

      __varRecorder__$1l.isTestModule = isTestModule;

      var shortModuleName = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("shortModuleName", "function", function (system, moduleId, itsPackage) {
        var packageAddress = itsPackage && itsPackage.address;
        var shortName = packageAddress && moduleId.indexOf(packageAddress) === 0 ? moduleId.slice(packageAddress.length).replace(/^\//, "") : relative(moduleId);
        return shortName;

        function relative(name) {
          var conf = system.getConfig();
          if (conf && conf.constructor === Promise) return name;

          try {
            return String(new URL(name).relativePathFrom(new URL(system.getConfig().baseURL)));
          } catch (e) {}

          return name;
        }
      }, __moduleMeta__$B);

      __varRecorder__$1l.shortModuleName = shortModuleName;

      var interactivelyChangeModule = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("interactivelyChangeModule", "function", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(system, moduleName, newSource, options) {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  options = Object.assign({
                    targetModule: moduleName
                  }, options);
                  _context.next = 3;
                  return system.normalize(moduleName);

                case 3:
                  moduleName = _context.sent;
                  _context.next = 6;
                  return system.moduleSourceChange(moduleName, newSource, options);

                case 6:
                  return _context.abrupt("return", moduleName);

                case 7:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x, _x2, _x3, _x4) {
          return _ref.apply(this, arguments);
        };
      }(), __moduleMeta__$B);

      __varRecorder__$1l.interactivelyChangeModule = interactivelyChangeModule;

      var interactivelyReloadModule = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("interactivelyReloadModule", "function", /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(system, vmEditor, moduleName) {
          var reloadDeps,
              resetEnv,
              _args2 = arguments;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  reloadDeps = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : false;
                  resetEnv = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : false;
                  vmEditor && vmEditor.setStatusMessage("Reloading " + moduleName);
                  _context2.prev = 3;
                  _context2.next = 6;
                  return system.reloadModule(moduleName, {
                    reloadDeps: reloadDeps,
                    resetEnv: resetEnv
                  });

                case 6:
                  _context2.t0 = vmEditor;

                  if (!_context2.t0) {
                    _context2.next = 10;
                    break;
                  }

                  _context2.next = 10;
                  return vmEditor.updateModuleList();

                case 10:
                  vmEditor && vmEditor.setStatusMessage("Reloded " + moduleName);
                  _context2.next = 26;
                  break;

                case 13:
                  _context2.prev = 13;
                  _context2.t1 = _context2["catch"](3);
                  _context2.prev = 15;
                  _context2.t2 = vmEditor;

                  if (!_context2.t2) {
                    _context2.next = 20;
                    break;
                  }

                  _context2.next = 20;
                  return vmEditor.updateEditorWithSourceOf(moduleName);

                case 20:
                  _context2.next = 24;
                  break;

                case 22:
                  _context2.prev = 22;
                  _context2.t3 = _context2["catch"](15);

                case 24:
                  vmEditor && vmEditor.showError(_context2.t1);
                  throw _context2.t1;

                case 26:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[3, 13], [15, 22]]);
        }));

        return function (_x5, _x6, _x7) {
          return _ref2.apply(this, arguments);
        };
      }(), __moduleMeta__$B);

      __varRecorder__$1l.interactivelyReloadModule = interactivelyReloadModule;

      var interactivelyUnloadModule = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("interactivelyUnloadModule", "function", /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(system, vmEditor, moduleName) {
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return system.forgetModule(moduleName, {
                    forgetEnv: true,
                    forgetDeps: true
                  });

                case 2:
                  _context3.t0 = vmEditor;

                  if (!_context3.t0) {
                    _context3.next = 6;
                    break;
                  }

                  _context3.next = 6;
                  return vmEditor.updateModuleList();

                case 6:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function (_x8, _x9, _x10) {
          return _ref3.apply(this, arguments);
        };
      }(), __moduleMeta__$B);

      __varRecorder__$1l.interactivelyUnloadModule = interactivelyUnloadModule;

      var interactivelyRemoveModule = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("interactivelyRemoveModule", "function", /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(system, requester, moduleName) {
          var fullname, really, p;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return system.normalize(moduleName);

                case 2:
                  fullname = _context4.sent;
                  _context4.next = 5;
                  return requester.world().confirm(["Really remove file:\n", {}, fullname, {
                    fontStyle: "italic",
                    fontWeight: "bold"
                  }, " ?", {}], {
                    requester: requester,
                    lineWrapping: "no-wrap"
                  });

                case 5:
                  really = _context4.sent;

                  if (really) {
                    _context4.next = 8;
                    break;
                  }

                  throw "Canceled";

                case 8:
                  _context4.next = 10;
                  return system.forgetModule(fullname);

                case 10:
                  _context4.next = 12;
                  return system.resourceRemove(fullname);

                case 12:
                  _context4.next = 14;
                  return system.getPackageForModule(fullname);

                case 14:
                  p = _context4.sent;
                  return _context4.abrupt("return", p);

                case 16:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        return function (_x11, _x12, _x13) {
          return _ref4.apply(this, arguments);
        };
      }(), __moduleMeta__$B);

      __varRecorder__$1l.interactivelyRemoveModule = interactivelyRemoveModule;

      var addModule = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("addModule", "function", /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(system, moduleName) {
          var namesAndErrors, errors, hasError;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return __varRecorder__$1l._createAndLoadModules(system, [moduleName]);

                case 2:
                  namesAndErrors = _context5.sent;
                  errors = compact(namesAndErrors.map(function (ea) {
                    return ea.error;
                  }));
                  hasError = !!errors.length;
                  return _context5.abrupt("return", hasError);

                case 6:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        return function (_x14, _x15) {
          return _ref5.apply(this, arguments);
        };
      }(), __moduleMeta__$B);

      __varRecorder__$1l.addModule = addModule;

      var interactivelyAddModule = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("interactivelyAddModule", "function", /*#__PURE__*/function () {
        var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(system, requester, relatedPackageOrModuleName) {
          var root, world, p, candidates, fullname;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.t0 = URL;
                  _context6.next = 3;
                  return system.getConfig();

                case 3:
                  _context6.t1 = _context6.sent.baseURL;
                  root = new _context6.t0(_context6.t1);
                  world = requester.world();

                  if (!relatedPackageOrModuleName) {
                    _context6.next = 16;
                    break;
                  }

                  _context6.next = 9;
                  return system.getPackage(relatedPackageOrModuleName);

                case 9:
                  _context6.t2 = _context6.sent;

                  if (_context6.t2) {
                    _context6.next = 14;
                    break;
                  }

                  _context6.next = 13;
                  return system.getPackageForModule(relatedPackageOrModuleName);

                case 13:
                  _context6.t2 = _context6.sent;

                case 14:
                  p = _context6.t2;
                  if (p) root = new URL(p.address);

                case 16:
                  _context6.next = 18;
                  return __varRecorder__$1l._searchForExistingFiles(requester, String(root), p);

                case 18:
                  candidates = _context6.sent;

                  if (!candidates.includes("[create new module]")) {
                    _context6.next = 24;
                    break;
                  }

                  _context6.next = 22;
                  return __varRecorder__$1l._askForModuleName(system, relatedPackageOrModuleName || String(root), world);

                case 22:
                  fullname = _context6.sent;
                  candidates = [fullname];

                case 24:
                  _context6.next = 26;
                  return __varRecorder__$1l._createAndLoadModules(system, candidates);

                case 26:
                  return _context6.abrupt("return", _context6.sent);

                case 27:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        return function (_x16, _x17, _x18) {
          return _ref6.apply(this, arguments);
        };
      }(), __moduleMeta__$B);

      __varRecorder__$1l.interactivelyAddModule = interactivelyAddModule;

      var _askForModuleName = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("_askForModuleName", "function", /*#__PURE__*/function () {
        var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(system, input, world) {
          var fullname, really;
          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.next = 2;
                  return world.prompt("Enter module name", {
                    input: input,
                    historyId: "lively.vm-editor-add-module-name"
                  });

                case 2:
                  input = _context7.sent;

                  if (input) {
                    _context7.next = 5;
                    break;
                  }

                  throw "Canceled";

                case 5:
                  _context7.next = 7;
                  return system.normalize(input);

                case 7:
                  fullname = _context7.sent;
                  _context7.next = 10;
                  return world.confirm(["Create module \n", {}, fullname, {
                    fontStyle: "italic"
                  }, " ?", {}], {
                    lineWrapping: "no-wrap"
                  });

                case 10:
                  really = _context7.sent;

                  if (really) {
                    _context7.next = 13;
                    break;
                  }

                  throw "Canceled";

                case 13:
                  return _context7.abrupt("return", fullname);

                case 14:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7);
        }));

        return function (_x19, _x20, _x21) {
          return _ref7.apply(this, arguments);
        };
      }(), __moduleMeta__$B);

      __varRecorder__$1l._askForModuleName = _askForModuleName;

      var _searchForExistingFiles = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("_searchForExistingFiles", "function", /*#__PURE__*/function () {
        var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(requester, rootURL, p) {
          return regeneratorRuntime.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  if (!String(rootURL).match(/^http/)) {
                    _context8.next = 4;
                    break;
                  }

                  return _context8.abrupt("return", __varRecorder__$1l._searchForExistingFilesWeb(requester, rootURL, p));

                case 4:
                  return _context8.abrupt("return", __varRecorder__$1l._searchForExistingFilesManually(requester, rootURL, p));

                case 5:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8);
        }));

        return function (_x22, _x23, _x24) {
          return _ref8.apply(this, arguments);
        };
      }(), __moduleMeta__$B);

      __varRecorder__$1l._searchForExistingFiles = _searchForExistingFiles;

      var _searchForExistingFilesManually = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("_searchForExistingFilesManually", "function", /*#__PURE__*/function () {
        var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(requester, rootURL, p) {
          var choice, result;
          return regeneratorRuntime.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  _context9.next = 2;
                  return requester.world().multipleChoicePrompt("Add Module", {
                    requester: requester,
                    choices: ["Create New Module", "Load Existing Module"]
                  });

                case 2:
                  choice = _context9.sent;

                  if (!(choice === "Create New Module")) {
                    _context9.next = 5;
                    break;
                  }

                  return _context9.abrupt("return", "[create new module]");

                case 5:
                  if (!(choice === "Load Existing Module")) {
                    _context9.next = 11;
                    break;
                  }

                  _context9.next = 8;
                  return requester.world().prompt("URL of module?", {
                    input: rootURL,
                    requester: requester,
                    historyId: "lively.vm._searchForExistingFilesManually.url-of-module"
                  });

                case 8:
                  result = _context9.sent;

                  if (!result) {
                    _context9.next = 11;
                    break;
                  }

                  return _context9.abrupt("return", [result]);

                case 11:
                  throw "Canceled";

                case 12:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9);
        }));

        return function (_x25, _x26, _x27) {
          return _ref9.apply(this, arguments);
        };
      }(), __moduleMeta__$B);

      __varRecorder__$1l._searchForExistingFilesManually = _searchForExistingFilesManually;

      var _searchForExistingFilesWeb = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("_searchForExistingFilesWeb", "function", /*#__PURE__*/function () {
        var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(requester, rootURL, p) {
          var world, loadingIndicator, exclude, found, candidates, answer, result;
          return regeneratorRuntime.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  exclude = function _exclude(resource) {
                    resource.name();

                    if ([".git", "node_modules", ".optimized-loading-cache", ".module_cache"].includes(resource.name())) {
                      return true;
                    }

                    if (p) {
                      var modules = pluck(p.modules, "name");
                      if (modules.includes(resource.url)) return true;
                    }

                    return false;
                  };

                  world = requester.world();

                  if (world) {
                    loadingIndicator = world.showLoadingIndicatorFor(requester, "Loading existing modules...");
                  }

                  _context10.next = 5;
                  return resource(rootURL).dirList(5, {
                    exclude: exclude
                  });

                case 5:
                  _context10.t0 = function (ea) {
                    return ea.url;
                  };

                  _context10.next = 8;
                  return _context10.sent.map(_context10.t0);

                case 8:
                  found = _context10.sent;
                  candidates = [{
                    isListItem: true,
                    string: "[create new module]",
                    value: "[create new module]"
                  }].concat(found.filter(function (ea) {
                    return ea.endsWith(".js");
                  }).map(function (name) {
                    var shortName = name;
                    shortName = p && name.indexOf(p.address) == 0 ? p.name + name.slice(p.address.length) : name;
                    return {
                      isListItem: true,
                      string: shortName,
                      value: name
                    };
                  }));
                  _context10.next = 12;
                  return Promise.resolve(loadingIndicator && loadingIndicator.remove()).then(function () {
                    return requester.world().filterableListPrompt("What module to load?", candidates, Object.assign({
                      filterLabel: "filter: ",
                      multiselect: true,
                      requester: requester
                    }, requester ? {
                      extent: requester.bounds().extent().withY(400).subXY(50, 0)
                    } : {}));
                  });

                case 12:
                  answer = _context10.sent;

                  if (!(!answer || answer.status === "canceled" || !answer.selected.length)) {
                    _context10.next = 15;
                    break;
                  }

                  throw "Canceled";

                case 15:
                  result = answer.selected || answer;
                  if (!Array.isArray(result)) result = [result];
                  return _context10.abrupt("return", result);

                case 18:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10);
        }));

        return function (_x28, _x29, _x30) {
          return _ref10.apply(this, arguments);
        };
      }(), __moduleMeta__$B);

      __varRecorder__$1l._searchForExistingFilesWeb = _searchForExistingFilesWeb;

      var _createAndLoadModules = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("_createAndLoadModules", "function", /*#__PURE__*/function () {
        var _ref11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(system, fullnames) {
          var results, _iterator, _step, fullname, res;

          return regeneratorRuntime.wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  if (!Array.isArray(fullnames)) fullnames = [fullnames];
                  results = [];
                  _iterator = _createForOfIteratorHelper(fullnames);
                  _context11.prev = 3;

                  _iterator.s();

                case 5:
                  if ((_step = _iterator.n()).done) {
                    _context11.next = 34;
                    break;
                  }

                  fullname = _step.value;
                  _context11.next = 9;
                  return system.forgetModule(fullname, {
                    forgetDeps: false,
                    forgetEnv: false
                  });

                case 9:
                  _context11.next = 11;
                  return system.resourceEnsureExistance(fullname, "\"format esm\";\n");

                case 11:
                  res = _context11.sent;
                  _context11.t0 = __varRecorder__$1l;
                  _context11.next = 16;
                  return res.read();

                case 16:
                  _context11.t1 = _context11.sent;

                  if (!_context11.t0.isTestModule.call(_context11.t0, _context11.t1)) {
                    _context11.next = 23;
                    break;
                  }

                  if (!(!System.global.Mocha || !System.global.chai)) {
                    _context11.next = 23;
                    break;
                  }

                  _context11.next = 21;
                  return module.import('./mocha-es6-5c28146c.js');

                case 21:
                  _context11.next = 23;
                  return waitFor(function () {
                    return !!System.global.Mocha && !!System.global.chai;
                  });

                case 23:
                  _context11.prev = 23;
                  _context11.next = 26;
                  return system.importModule(fullname);

                case 26:
                  results.push({
                    name: fullname
                  });
                  _context11.next = 32;
                  break;

                case 29:
                  _context11.prev = 29;
                  _context11.t2 = _context11["catch"](23);
                  results.push({
                    name: fullname,
                    error: _context11.t2
                  });

                case 32:
                  _context11.next = 5;
                  break;

                case 34:
                  _context11.next = 39;
                  break;

                case 36:
                  _context11.prev = 36;
                  _context11.t3 = _context11["catch"](3);

                  _iterator.e(_context11.t3);

                case 39:
                  _context11.prev = 39;

                  _iterator.f();

                  return _context11.finish(39);

                case 42:
                  return _context11.abrupt("return", results);

                case 43:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11, null, [[3, 36, 39, 42], [23, 29]]);
        }));

        return function (_x31, _x32) {
          return _ref11.apply(this, arguments);
        };
      }(), __moduleMeta__$B);

      __varRecorder__$1l._createAndLoadModules = _createAndLoadModules;

      var modulesInPackage_defaultExclude = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("modulesInPackage_defaultExclude", "function", function (res) {
        if ([".git", "node_modules", ".optimized-loading-cache", ".module_cache"].includes(res.name())) {
          return true;
        }

        return false;
      }, __moduleMeta__$B);

      __varRecorder__$1l.modulesInPackage_defaultExclude = modulesInPackage_defaultExclude;

      var modulesInPackage = __varRecorder__$1l["lively-system-interface/commands/modules.js__define__"]("modulesInPackage", "function", /*#__PURE__*/function () {
        var _ref12 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(system, packageName) {
          var p, res, found, _iterator2, _step2, url;

          return regeneratorRuntime.wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  _context12.next = 2;
                  return system.getPackage(packageName);

                case 2:
                  p = _context12.sent;

                  if (!(!p || !p.address.match(/^http/))) {
                    _context12.next = 5;
                    break;
                  }

                  throw new Error("Cannot load package ".concat(packageName));

                case 5:
                  res = resource(p.address);
                  found = [];
                  _context12.t0 = _createForOfIteratorHelper;
                  _context12.next = 10;
                  return res.dirList(5, {
                    exclude: __varRecorder__$1l.modulesInPackage_defaultExclude
                  });

                case 10:
                  _context12.t1 = _context12.sent;
                  _iterator2 = (0, _context12.t0)(_context12.t1);

                  try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                      url = _step2.value.url;

                      if (url.match(/\.js$/) && system.isModuleLoaded(url, true)) {
                        found.push(system.getModule(url));
                      }
                    }
                  } catch (err) {
                    _iterator2.e(err);
                  } finally {
                    _iterator2.f();
                  }

                  return _context12.abrupt("return", found);

                case 14:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12);
        }));

        return function (_x33, _x34) {
          return _ref12.apply(this, arguments);
        };
      }(), __moduleMeta__$B);

      __varRecorder__$1l.modulesInPackage = modulesInPackage;
      __varRecorder__$1l.isTestModule = isTestModule;
      __varRecorder__$1l.shortModuleName = shortModuleName;
      __varRecorder__$1l.interactivelyChangeModule = interactivelyChangeModule;
      __varRecorder__$1l.interactivelyReloadModule = interactivelyReloadModule;
      __varRecorder__$1l.interactivelyUnloadModule = interactivelyUnloadModule;
      __varRecorder__$1l.interactivelyRemoveModule = interactivelyRemoveModule;
      __varRecorder__$1l.addModule = addModule;
      __varRecorder__$1l.interactivelyAddModule = interactivelyAddModule;
      __varRecorder__$1l.modulesInPackage = modulesInPackage;

      var __varRecorder__$1k = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively-system-interface/helpers.js", __contextModule__);
      var __moduleMeta__$A = {
        pathInPackage: function pathInPackage() {
          return "./helpers.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively-system-interface",
            version: "0.2.1"
          };
        }
      };

      var parseJsonLikeObj = __varRecorder__$1k["lively-system-interface/helpers.js__define__"]("parseJsonLikeObj", "function", function (source) {
        try {
          var obj = eval("(".concat(wrapInFunction("var _; _ = (".concat(source, ")")), ")()"));
        } catch (e) {
          return JSON.parse(source);
        }

        return _typeof$1(obj) !== "object" ? null : obj;
      }, __moduleMeta__$A);

      __varRecorder__$1k.parseJsonLikeObj = parseJsonLikeObj;
      __varRecorder__$1k.parseJsonLikeObj = parseJsonLikeObj;

      var __varRecorder__$1j = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively-system-interface/interfaces/interface.js", __contextModule__);
      var __moduleMeta__$z = {
        pathInPackage: function pathInPackage() {
          return "./interfaces/interface.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively-system-interface",
            version: "0.2.1"
          };
        }
      };

      var todo = __varRecorder__$1j["lively-system-interface/interfaces/interface.js__define__"]("todo", "function", function (methodName) {
        throw new Error("".concat(methodName, " is not yet implemented!"));
      }, __moduleMeta__$z);

      __varRecorder__$1j.todo = todo;
      var AbstractCoreInterface = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively-system-interface/interfaces/interface.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("AbstractCoreInterface") && typeof __lively_classholder__.AbstractCoreInterface === "function" ? __lively_classholder__.AbstractCoreInterface : __lively_classholder__.AbstractCoreInterface = function AbstractCoreInterface(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "dynamicCompletionsForPrefix",
          value: function () {
            var _AbstractCoreInterface_dynamicCompletionsForPrefix_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(moduleName, prefix, options) {
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      __varRecorder__$1j.todo("dynamicCompletionsForPrefix");

                    case 1:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));

            function AbstractCoreInterface_dynamicCompletionsForPrefix_(_x, _x2, _x3) {
              return _AbstractCoreInterface_dynamicCompletionsForPrefix_.apply(this, arguments);
            }

            return AbstractCoreInterface_dynamicCompletionsForPrefix_;
          }()
        }, {
          key: "runEval",
          value: function AbstractCoreInterface_runEval_(source, options) {
            __varRecorder__$1j.todo("runEval");
          }
        }, {
          key: "resourceExists",
          value: function AbstractCoreInterface_resourceExists_(url) {
            __varRecorder__$1j.todo("resourceExists");
          }
        }, {
          key: "resourceEnsureExistance",
          value: function AbstractCoreInterface_resourceEnsureExistance_(url, optContent) {
            __varRecorder__$1j.todo("resourceEnsureExistance");
          }
        }, {
          key: "resourceMkdir",
          value: function AbstractCoreInterface_resourceMkdir_(url) {
            __varRecorder__$1j.todo("resourceMkdir");
          }
        }, {
          key: "resourceRead",
          value: function AbstractCoreInterface_resourceRead_(url) {
            __varRecorder__$1j.todo("resourceRead");
          }
        }, {
          key: "resourceRemove",
          value: function AbstractCoreInterface_resourceRemove_(url) {
            __varRecorder__$1j.todo("resourceRemove");
          }
        }, {
          key: "resourceWrite",
          value: function AbstractCoreInterface_resourceWrite_(url, source) {
            __varRecorder__$1j.todo("resourceWrite");
          }
        }, {
          key: "resourceCreateFiles",
          value: function AbstractCoreInterface_resourceCreateFiles_(baseDir, spec) {
            __varRecorder__$1j.todo("resourceCreateFiles");
          }
        }, {
          key: "resourceDirList",
          value: function AbstractCoreInterface_resourceDirList_(baseDir, depth, opts) {
            __varRecorder__$1j.todo("resourceDirList");
          }
        }, {
          key: "normalizeSync",
          value: function AbstractCoreInterface_normalizeSync_(name, parentName, isPlugin) {
            __varRecorder__$1j.todo("normalizeSync");
          }
        }, {
          key: "normalize",
          value: function AbstractCoreInterface_normalize_(name, parent, parentAddress) {
            __varRecorder__$1j.todo("normalize");
          }
        }, {
          key: "printSystemConfig",
          value: function AbstractCoreInterface_printSystemConfig_() {
            __varRecorder__$1j.todo("printSystemConfig");
          }
        }, {
          key: "getConfig",
          value: function AbstractCoreInterface_getConfig_() {
            __varRecorder__$1j.todo("getConfig");
          }
        }, {
          key: "setConfig",
          value: function AbstractCoreInterface_setConfig_(conf) {
            __varRecorder__$1j.todo("setConfig");
          }
        }, {
          key: "getPackages",
          value: function AbstractCoreInterface_getPackages_(options) {
            __varRecorder__$1j.todo("getPackages");
          }
        }, {
          key: "isModuleLoaded",
          value: function AbstractCoreInterface_isModuleLoaded_(name, isNormalized) {
            __varRecorder__$1j.todo("isModuleLoaded");
          }
        }, {
          key: "doesModuleExist",
          value: function AbstractCoreInterface_doesModuleExist_(name, isNormalized) {
            __varRecorder__$1j.todo("doesModuleExist");
          }
        }, {
          key: "getModules",
          value: function () {
            var _AbstractCoreInterface_getModules_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return this.getPackages();

                    case 2:
                      _context2.t0 = function (ea) {
                        return ea.modules;
                      };

                      return _context2.abrupt("return", _context2.sent.flatMap(_context2.t0));

                    case 4:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function AbstractCoreInterface_getModules_() {
              return _AbstractCoreInterface_getModules_.apply(this, arguments);
            }

            return AbstractCoreInterface_getModules_;
          }()
        }, {
          key: "getModule",
          value: function () {
            var _AbstractCoreInterface_getModule_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(name) {
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return this.getModules();

                    case 2:
                      _context3.t0 = function (ea) {
                        return ea.name === name;
                      };

                      return _context3.abrupt("return", _context3.sent.find(_context3.t0));

                    case 4:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function AbstractCoreInterface_getModule_(_x4) {
              return _AbstractCoreInterface_getModule_.apply(this, arguments);
            }

            return AbstractCoreInterface_getModule_;
          }()
        }, {
          key: "getPackage",
          value: function () {
            var _AbstractCoreInterface_getPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(name) {
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      name = name.replace(/\/+$/, "");
                      _context4.next = 3;
                      return this.getPackages();

                    case 3:
                      _context4.t0 = function (ea) {
                        return ea.address === name || ea.name === name;
                      };

                      return _context4.abrupt("return", _context4.sent.find(_context4.t0));

                    case 5:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function AbstractCoreInterface_getPackage_(_x5) {
              return _AbstractCoreInterface_getPackage_.apply(this, arguments);
            }

            return AbstractCoreInterface_getPackage_;
          }()
        }, {
          key: "getPackageForModule",
          value: function () {
            var _AbstractCoreInterface_getPackageForModule_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(name) {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      __varRecorder__$1j.todo("getPackageForModule");

                    case 1:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5);
            }));

            function AbstractCoreInterface_getPackageForModule_(_x6) {
              return _AbstractCoreInterface_getPackageForModule_.apply(this, arguments);
            }

            return AbstractCoreInterface_getPackageForModule_;
          }()
        }, {
          key: "systemConfChange",
          value: function AbstractCoreInterface_systemConfChange_(source) {
            var jso = parseJsonLikeObj(source);
            var exceptions = ["baseURL"];
            exceptions.forEach(function (ea) {
              return delete jso[ea];
            });
            return this.setConfig(jso);
          }
        }, {
          key: "resourcesOfPackage",
          value: function () {
            var _AbstractCoreInterface_resourcesOfPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(packageOrAddress, exclude) {
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      __varRecorder__$1j.todo("resourcesOfPackage");

                    case 1:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6);
            }));

            function AbstractCoreInterface_resourcesOfPackage_(_x7, _x8) {
              return _AbstractCoreInterface_resourcesOfPackage_.apply(this, arguments);
            }

            return AbstractCoreInterface_resourcesOfPackage_;
          }()
        }, {
          key: "registerPackage",
          value: function () {
            var _AbstractCoreInterface_registerPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(packageURL) {
              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      __varRecorder__$1j.todo("registerPackage");

                    case 1:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7);
            }));

            function AbstractCoreInterface_registerPackage_(_x9) {
              return _AbstractCoreInterface_registerPackage_.apply(this, arguments);
            }

            return AbstractCoreInterface_registerPackage_;
          }()
        }, {
          key: "importPackage",
          value: function () {
            var _AbstractCoreInterface_importPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(packageURL) {
              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      __varRecorder__$1j.todo("importPackage");

                    case 1:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8);
            }));

            function AbstractCoreInterface_importPackage_(_x10) {
              return _AbstractCoreInterface_importPackage_.apply(this, arguments);
            }

            return AbstractCoreInterface_importPackage_;
          }()
        }, {
          key: "removePackage",
          value: function () {
            var _AbstractCoreInterface_removePackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(packageURL) {
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      __varRecorder__$1j.todo("removePackage");

                    case 1:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9);
            }));

            function AbstractCoreInterface_removePackage_(_x11) {
              return _AbstractCoreInterface_removePackage_.apply(this, arguments);
            }

            return AbstractCoreInterface_removePackage_;
          }()
        }, {
          key: "reloadPackage",
          value: function () {
            var _AbstractCoreInterface_reloadPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(packageURL) {
              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      __varRecorder__$1j.todo("reloadPackage");

                    case 1:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10);
            }));

            function AbstractCoreInterface_reloadPackage_(_x12) {
              return _AbstractCoreInterface_reloadPackage_.apply(this, arguments);
            }

            return AbstractCoreInterface_reloadPackage_;
          }()
        }, {
          key: "packageConfChange",
          value: function () {
            var _AbstractCoreInterface_packageConfChange_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(source, confFile) {
              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      __varRecorder__$1j.todo("packageConfChange");

                    case 1:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11);
            }));

            function AbstractCoreInterface_packageConfChange_(_x13, _x14) {
              return _AbstractCoreInterface_packageConfChange_.apply(this, arguments);
            }

            return AbstractCoreInterface_packageConfChange_;
          }()
        }, {
          key: "importModule",
          value: function AbstractCoreInterface_importModule_(name) {
            __varRecorder__$1j.todo("importModule");
          }
        }, {
          key: "forgetModule",
          value: function AbstractCoreInterface_forgetModule_(name, opts) {
            __varRecorder__$1j.todo("forgetModule");
          }
        }, {
          key: "reloadModule",
          value: function AbstractCoreInterface_reloadModule_(name, opts) {
            __varRecorder__$1j.todo("reloadModule");
          }
        }, {
          key: "moduleFormat",
          value: function AbstractCoreInterface_moduleFormat_(moduleName) {
            __varRecorder__$1j.todo("moduleFormat");
          }
        }, {
          key: "moduleRead",
          value: function AbstractCoreInterface_moduleRead_(moduleName) {
            __varRecorder__$1j.todo("moduleRead");
          }
        }, {
          key: "moduleSourceChange",
          value: function AbstractCoreInterface_moduleSourceChange_(moduleName, newSource, options) {
            __varRecorder__$1j.todo("moduleSourceChange");
          }
        }, {
          key: "importsAndExportsOf",
          value: function AbstractCoreInterface_importsAndExportsOf_(modId, sourceOrAst) {
            __varRecorder__$1j.todo("importsAndExportsOf");
          }
        }, {
          key: "keyValueListOfVariablesInModule",
          value: function AbstractCoreInterface_keyValueListOfVariablesInModule_(moduleName, sourceOrAst) {
            __varRecorder__$1j.todo("keyValueListOfVariablesInModule");
          }
        }, {
          key: "moduleWrite",
          value: function AbstractCoreInterface_moduleWrite_(moduleName, newSource) {
            return this.moduleSourceChange(moduleName, newSource);
          }
        }, {
          key: "getLoadedModules",
          value: function () {
            var _AbstractCoreInterface_getLoadedModules_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(ignoredPackages) {
              var pkgs, items, _iterator, _step, p, excluded, _iterator2, _step2, _loop, _ret;

              return regeneratorRuntime.wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      _context12.next = 2;
                      return this.getPackages();

                    case 2:
                      pkgs = _context12.sent;
                      items = [];
                      _iterator = _createForOfIteratorHelper(pkgs);
                      _context12.prev = 5;

                      _iterator.s();

                    case 7:
                      if ((_step = _iterator.n()).done) {
                        _context12.next = 31;
                        break;
                      }

                      p = _step.value;
                      excluded = Path("lively.ide.exclude").get(p) || [];
                      excluded = excluded.map(function (ea) {
                        return ea.includes("*") ? new RegExp(ea.replace(/\*/g, ".*")) : ea;
                      });
                      _iterator2 = _createForOfIteratorHelper(p.modules);
                      _context12.prev = 12;

                      _loop = function _loop() {
                        var m = _step2.value;
                        if (excluded.some(function (ex) {
                          return ex instanceof RegExp ? ex.test(m.name) : m.name.includes(ex);
                        })) return "continue";
                        items.push({
                          "package": p,
                          module: m
                        });
                      };

                      _iterator2.s();

                    case 15:
                      if ((_step2 = _iterator2.n()).done) {
                        _context12.next = 21;
                        break;
                      }

                      _ret = _loop();

                      if (!(_ret === "continue")) {
                        _context12.next = 19;
                        break;
                      }

                      return _context12.abrupt("continue", 19);

                    case 19:
                      _context12.next = 15;
                      break;

                    case 21:
                      _context12.next = 26;
                      break;

                    case 23:
                      _context12.prev = 23;
                      _context12.t0 = _context12["catch"](12);

                      _iterator2.e(_context12.t0);

                    case 26:
                      _context12.prev = 26;

                      _iterator2.f();

                      return _context12.finish(26);

                    case 29:
                      _context12.next = 7;
                      break;

                    case 31:
                      _context12.next = 36;
                      break;

                    case 33:
                      _context12.prev = 33;
                      _context12.t1 = _context12["catch"](5);

                      _iterator.e(_context12.t1);

                    case 36:
                      _context12.prev = 36;

                      _iterator.f();

                      return _context12.finish(36);

                    case 39:
                      return _context12.abrupt("return", items);

                    case 40:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12, this, [[5, 33, 36, 39], [12, 23, 26, 29]]);
            }));

            function AbstractCoreInterface_getLoadedModules_(_x15) {
              return _AbstractCoreInterface_getLoadedModules_.apply(this, arguments);
            }

            return AbstractCoreInterface_getLoadedModules_;
          }()
        }, {
          key: "getResourcesOfLoadedPackages",
          value: function () {
            var _AbstractCoreInterface_getResourcesOfLoadedPackages_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(ignoredPackages) {
              var _this2 = this;

              var pkgs, items, _iterator3, _step3, _loop2;

              return regeneratorRuntime.wrap(function _callee13$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      _context14.next = 2;
                      return this.getPackages({
                        excluded: ignoredPackages
                      });

                    case 2:
                      pkgs = _context14.sent;
                      items = [];
                      _iterator3 = _createForOfIteratorHelper(pkgs);
                      _context14.prev = 5;
                      _loop2 = /*#__PURE__*/regeneratorRuntime.mark(function _loop2() {
                        var p, excluded;
                        return regeneratorRuntime.wrap(function _loop2$(_context13) {
                          while (1) {
                            switch (_context13.prev = _context13.next) {
                              case 0:
                                p = _step3.value;
                                excluded = (Path("lively.ide.exclude").get(p) || []).map(function (ea) {
                                  return ea.includes("*") ? new RegExp(ea.replace(/\*/g, ".*")) : ea;
                                });
                                excluded.push(".git", "node_modules", ".module_cache");
                                _context13.t0 = items.push;
                                _context13.t1 = items;
                                _context13.t2 = _toConsumableArray$1;
                                _context13.next = 8;
                                return _this2.resourcesOfPackage(p, excluded);

                              case 8:
                                _context13.t3 = function (_ref) {
                                  var url = _ref.url;
                                  return !url.endsWith("/") && !excluded.some(function (ex) {
                                    return ex instanceof RegExp ? ex.test(url) : url.includes(ex);
                                  });
                                };

                                _context13.t4 = function (a, b) {
                                  if (a.isLoaded && !b.isLoaded) return -1;
                                  if (!a.isLoaded && b.isLoaded) return 1;
                                  if (a.nameInPackage.toLowerCase() < b.nameInPackage.toLowerCase()) return -1;
                                  if (a.nameInPackage.toLowerCase() === b.nameInPackage.toLowerCase()) return 0;
                                  return 1;
                                };

                                _context13.t5 = function (resource) {
                                  return {
                                    "package": p,
                                    resource: resource
                                  };
                                };

                                _context13.t6 = _context13.sent.filter(_context13.t3).sort(_context13.t4).map(_context13.t5);
                                _context13.t7 = (0, _context13.t2)(_context13.t6);

                                _context13.t0.apply.call(_context13.t0, _context13.t1, _context13.t7);

                              case 14:
                              case "end":
                                return _context13.stop();
                            }
                          }
                        }, _loop2);
                      });

                      _iterator3.s();

                    case 8:
                      if ((_step3 = _iterator3.n()).done) {
                        _context14.next = 12;
                        break;
                      }

                      return _context14.delegateYield(_loop2(), "t0", 10);

                    case 10:
                      _context14.next = 8;
                      break;

                    case 12:
                      _context14.next = 17;
                      break;

                    case 14:
                      _context14.prev = 14;
                      _context14.t1 = _context14["catch"](5);

                      _iterator3.e(_context14.t1);

                    case 17:
                      _context14.prev = 17;

                      _iterator3.f();

                      return _context14.finish(17);

                    case 20:
                      return _context14.abrupt("return", items);

                    case 21:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee13, this, [[5, 14, 17, 20]]);
            }));

            function AbstractCoreInterface_getResourcesOfLoadedPackages_(_x16) {
              return _AbstractCoreInterface_getResourcesOfLoadedPackages_.apply(this, arguments);
            }

            return AbstractCoreInterface_getResourcesOfLoadedPackages_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "AbstractCoreInterface";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./interfaces/interface.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively-system-interface",
              version: "0.2.1"
            };
          }
        }, {
          start: 275,
          end: 5442
        });
      }(undefined);
      __varRecorder__$1j.AbstractCoreInterface = AbstractCoreInterface;
      __varRecorder__$1j.AbstractCoreInterface = AbstractCoreInterface;
      var RemoteCoreInterface = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively-system-interface/interfaces/interface.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("RemoteCoreInterface") && typeof __lively_classholder__.RemoteCoreInterface === "function" ? __lively_classholder__.RemoteCoreInterface : __lively_classholder__.RemoteCoreInterface = function RemoteCoreInterface(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function RemoteCoreInterface_initialize_() {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this);
            this.currentEval = null;
            return _this;
          }
        }, {
          key: "runEval",
          value: function RemoteCoreInterface_runEval_(source, options) {
            throw new Error("Not yet implemented");
          }
        }, {
          key: "runEvalAndStringify",
          value: function RemoteCoreInterface_runEvalAndStringify_(source, opts) {
            var _this3 = this;

            if (this.currentEval) {
              return this.currentEval.then(function () {
                return _this3.runEvalAndStringify(source, opts);
              });
            }

            return this.currentEval = Promise.resolve().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
              var result, val, parsedResult;
              return regeneratorRuntime.wrap(function _callee14$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      _context15.next = 2;
                      return _this3.runEval("\n        Promise.resolve((async ".concat(wrapInFunction(source), ")())\n          .then(function(result) { return JSON.stringify(result); })\n          .catch(function(err) { return {isError: true, value: err}; })\n          .then(function(result) {\n            if (!result || typeof result === \"string\") return result;\n            return JSON.stringify(result.isError ?\n              {isError: true, value: (result.value + \"\\n\" + result.value.stack) || String(result.value)} :\n              result)\n          });"), Object.assign({
                        targetModule: "lively://remote-lively-system/runEvalAndStringify",
                        promiseTimeout: 30 * 1000,
                        waitForPromise: true
                      }, opts));

                    case 2:
                      result = _context15.sent;

                      if (!(result && result.isError)) {
                        _context15.next = 5;
                        break;
                      }

                      throw new Error(String(result.value || result.error));

                    case 5:
                      if (!(!result || !result.value)) {
                        _context15.next = 7;
                        break;
                      }

                      return _context15.abrupt("return", null);

                    case 7:
                      _context15.t0 = result.promisedValue;

                      if (_context15.t0) {
                        _context15.next = 12;
                        break;
                      }

                      _context15.next = 11;
                      return result.value;

                    case 11:
                      _context15.t0 = _context15.sent;

                    case 12:
                      val = _context15.t0;

                      if (val) {
                        _context15.next = 15;
                        break;
                      }

                      return _context15.abrupt("return");

                    case 15:
                      if (!(val === "undefined")) {
                        _context15.next = 17;
                        break;
                      }

                      return _context15.abrupt("return", undefined);

                    case 17:
                      if (!(val === "null")) {
                        _context15.next = 19;
                        break;
                      }

                      return _context15.abrupt("return", null);

                    case 19:
                      if (!(val === "true")) {
                        _context15.next = 21;
                        break;
                      }

                      return _context15.abrupt("return", true);

                    case 21:
                      if (!(val === "false")) {
                        _context15.next = 23;
                        break;
                      }

                      return _context15.abrupt("return", false);

                    case 23:
                      _context15.prev = 23;
                      parsedResult = JSON.parse(val);
                      _context15.next = 30;
                      break;

                    case 27:
                      _context15.prev = 27;
                      _context15.t1 = _context15["catch"](23);
                      return _context15.abrupt("return", val);

                    case 30:
                      if (!(parsedResult && parsedResult.isError)) {
                        _context15.next = 32;
                        break;
                      }

                      throw new Error(String(parsedResult.value));

                    case 32:
                      return _context15.abrupt("return", parsedResult);

                    case 33:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee14, null, [[23, 27]]);
            }))).then(function (result) {
              delete _this3.currentEval;
              return result;
            }, function (err) {
              delete _this3.currentEval;
              return Promise.reject(err);
            });
          }
        }, {
          key: "dynamicCompletionsForPrefix",
          value: function () {
            var _RemoteCoreInterface_dynamicCompletionsForPrefix_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(moduleName, prefix, options) {
              var contextFetch, src;
              return regeneratorRuntime.wrap(function _callee15$(_context16) {
                while (1) {
                  switch (_context16.prev = _context16.next) {
                    case 0:
                      contextFetch = isString$3(options.context) ? options.context : false;
                      options = dissoc(options, ["systemInterface", "System", "context"]);
                      src = "\n      var prefix = ".concat(JSON.stringify(prefix), ",\n          opts = ").concat(JSON.stringify(options), ";\n      opts.context = ").concat(contextFetch, ";\n      opts.classTransform = (await System.import(\"lively.classes\")).classToFunctionTransform;\n      var { runEval, completions } = await System.import(\"lively.vm\");\n      var evalFn = code => runEval(code, opts);\n      if (typeof System === \"undefined\") delete opts.targetModule;\n      completions.getCompletions(evalFn, prefix).then(function(result) {\n        if (result.isError) throw result.value;\n        return {\n          completions: result.completions,\n          prefix: result.startLetters\n        }\n      });");
                      return _context16.abrupt("return", this.runEvalAndStringify(src));

                    case 4:
                    case "end":
                      return _context16.stop();
                  }
                }
              }, _callee15, this);
            }));

            function RemoteCoreInterface_dynamicCompletionsForPrefix_(_x17, _x18, _x19) {
              return _RemoteCoreInterface_dynamicCompletionsForPrefix_.apply(this, arguments);
            }

            return RemoteCoreInterface_dynamicCompletionsForPrefix_;
          }()
        }, {
          key: "evalWithResource",
          value: function RemoteCoreInterface_evalWithResource_(url, method, arg) {
            return this.runEvalAndStringify("\n      var {resource} = (typeof lively !== \"undefined\" && lively.resources)\n                    || await System.import(\"lively.resources\");\n      await resource(\"".concat(url, "\").").concat(method, "(").concat(arg ? JSON.stringify(arg) : "", ");\n    "));
          }
        }, {
          key: "resourceExists",
          value: function RemoteCoreInterface_resourceExists_(url) {
            return this.evalWithResource(url, "exists");
          }
        }, {
          key: "resourceEnsureExistance",
          value: function RemoteCoreInterface_resourceEnsureExistance_(url, optContent) {
            return this.evalWithResource(url, "ensureExistance", optContent);
          }
        }, {
          key: "resourceMkdir",
          value: function RemoteCoreInterface_resourceMkdir_(url) {
            return this.evalWithResource(url, "mkdir");
          }
        }, {
          key: "resourceRead",
          value: function RemoteCoreInterface_resourceRead_(url) {
            return this.evalWithResource(url, "read");
          }
        }, {
          key: "resourceRemove",
          value: function RemoteCoreInterface_resourceRemove_(url) {
            return this.evalWithResource(url, "remove");
          }
        }, {
          key: "resourceWrite",
          value: function RemoteCoreInterface_resourceWrite_(url, source) {
            return this.evalWithResource(url, "write", source);
          }
        }, {
          key: "resourceCreateFiles",
          value: function RemoteCoreInterface_resourceCreateFiles_(baseDir, spec) {
            return this.runEvalAndStringify("var {createFiles} = await System.import(\"lively.resources\"); await createFiles(\"".concat(baseDir, "\", ").concat(JSON.stringify(spec), ")"));
          }
        }, {
          key: "resourceDirList",
          value: function RemoteCoreInterface_resourceDirList_(url, depth, opts) {
            return this.runEvalAndStringify("\n      var {resource} = await System.import(\"lively.resources\");\n      (await resource(\"".concat(url, "\").dirList(").concat(JSON.stringify(depth), ", ").concat(JSON.stringify(opts), "))\n        .map(({url}) => ({url}))"));
          }
        }, {
          key: "livelySystemAccessor",
          value: function RemoteCoreInterface_livelySystemAccessor_() {
            var varName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "livelySystem";
            return "".concat(this.livelyModulesAccessor(), ";\n      var ").concat(varName, " = (typeof lively !== \"undefined\" && lively.systemInterface)\n      || System.get(System.decanonicalize(\"lively-system-interface\"))\n      || (await modules.importPackage(\"lively-system-interface\"));\n    if (!").concat(varName, ") throw new Error(\"lively-system-interface not available!\");");
          }
        }, {
          key: "livelyModulesAccessor",
          value: function RemoteCoreInterface_livelyModulesAccessor_() {
            var varName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "modules";
            return "".concat(varName, " = System.get(System.decanonicalize(\"lively.modules\"))");
          }
        }, {
          key: "normalizeSync",
          value: function RemoteCoreInterface_normalizeSync_(name, parentName, isPlugin) {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.System.decanonicalize(").concat(JSON.stringify(name), ", ").concat(JSON.stringify(parentName), ", ").concat(isPlugin, ")"));
          }
        }, {
          key: "normalize",
          value: function RemoteCoreInterface_normalize_(name, parent, parentAddress) {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.System.normalize(").concat(JSON.stringify(name), ", ").concat(JSON.stringify(parent), ", ").concat(JSON.stringify(parentAddress), ")"));
          }
        }, {
          key: "printSystemConfig",
          value: function RemoteCoreInterface_printSystemConfig_() {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.printSystemConfig()"));
          }
        }, {
          key: "getConfig",
          value: function RemoteCoreInterface_getConfig_() {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), "; var c = Object.assign({}, modules.System.getConfig()); for (var name in c) if (name.indexOf(\"__lively.modules__\") === 0 || name.indexOf(\"loads\") === 0) delete c[name]; c"));
          }
        }, {
          key: "setConfig",
          value: function RemoteCoreInterface_setConfig_(conf) {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.System.config(").concat(JSON.stringify(conf), ")"));
          }
        }, {
          key: "getPackages",
          value: function RemoteCoreInterface_getPackages_(options) {
            options = Object.assign({
              excluded: []
            }, options);
            options.excluded = options.excluded.map(String);
            return this.runEvalAndStringify("\n      ".concat(this.livelySystemAccessor(), ";\n      var options = ").concat(JSON.stringify(options), ";\n      var { syncEval } = await System.import('lively.vm');\n      options.excluded = options.excluded.map(ea => {\n        let evaled = syncEval(ea).value;\n        return typeof evaled === \"function\" ? evaled : ea;\n      });\n      await livelySystem.localInterface.getPackages(options)\n        .map(ea => Object.assign({}, ea, {System: null}));"));
          }
        }, {
          key: "getPackageForModule",
          value: function RemoteCoreInterface_getPackageForModule_(moduleId) {
            return this.runEvalAndStringify("\n      ".concat(this.livelySystemAccessor(), ";\n      await livelySystem.localInterface.getPackageForModule(").concat(JSON.stringify(moduleId), ")"));
          }
        }, {
          key: "isModuleLoaded",
          value: function RemoteCoreInterface_isModuleLoaded_(name, isNormalized) {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.isModuleLoaded(\"").concat(name, "\", ").concat(isNormalized, ")"));
          }
        }, {
          key: "doesModuleExist",
          value: function RemoteCoreInterface_doesModuleExist_(name, isNormalized) {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.doesModuleExist(\"").concat(name, "\", ").concat(isNormalized, ")"));
          }
        }, {
          key: "registerPackage",
          value: function () {
            var _RemoteCoreInterface_registerPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(packageURL) {
              return regeneratorRuntime.wrap(function _callee16$(_context17) {
                while (1) {
                  switch (_context17.prev = _context17.next) {
                    case 0:
                      return _context17.abrupt("return", this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.registerPackage(").concat(JSON.stringify(packageURL), ")")));

                    case 1:
                    case "end":
                      return _context17.stop();
                  }
                }
              }, _callee16, this);
            }));

            function RemoteCoreInterface_registerPackage_(_x20) {
              return _RemoteCoreInterface_registerPackage_.apply(this, arguments);
            }

            return RemoteCoreInterface_registerPackage_;
          }()
        }, {
          key: "importPackage",
          value: function () {
            var _RemoteCoreInterface_importPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(packageURL) {
              return regeneratorRuntime.wrap(function _callee17$(_context18) {
                while (1) {
                  switch (_context18.prev = _context18.next) {
                    case 0:
                      return _context18.abrupt("return", this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.importPackage(").concat(JSON.stringify(packageURL), ")")));

                    case 1:
                    case "end":
                      return _context18.stop();
                  }
                }
              }, _callee17, this);
            }));

            function RemoteCoreInterface_importPackage_(_x21) {
              return _RemoteCoreInterface_importPackage_.apply(this, arguments);
            }

            return RemoteCoreInterface_importPackage_;
          }()
        }, {
          key: "removePackage",
          value: function () {
            var _RemoteCoreInterface_removePackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(packageURL) {
              return regeneratorRuntime.wrap(function _callee18$(_context19) {
                while (1) {
                  switch (_context19.prev = _context19.next) {
                    case 0:
                      return _context19.abrupt("return", this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.removePackage(").concat(JSON.stringify(packageURL), ")")));

                    case 1:
                    case "end":
                      return _context19.stop();
                  }
                }
              }, _callee18, this);
            }));

            function RemoteCoreInterface_removePackage_(_x22) {
              return _RemoteCoreInterface_removePackage_.apply(this, arguments);
            }

            return RemoteCoreInterface_removePackage_;
          }()
        }, {
          key: "reloadPackage",
          value: function () {
            var _RemoteCoreInterface_reloadPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(packageURL, opts) {
              return regeneratorRuntime.wrap(function _callee19$(_context20) {
                while (1) {
                  switch (_context20.prev = _context20.next) {
                    case 0:
                      return _context20.abrupt("return", this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.reloadPackage(").concat(JSON.stringify(packageURL), ", ").concat(JSON.stringify(opts), ")")));

                    case 1:
                    case "end":
                      return _context20.stop();
                  }
                }
              }, _callee19, this);
            }));

            function RemoteCoreInterface_reloadPackage_(_x23, _x24) {
              return _RemoteCoreInterface_reloadPackage_.apply(this, arguments);
            }

            return RemoteCoreInterface_reloadPackage_;
          }()
        }, {
          key: "packageConfChange",
          value: function RemoteCoreInterface_packageConfChange_(source, confFile) {
            return this.runEvalAndStringify("\n      ".concat(this.livelySystemAccessor(), ";\n      await livelySystem.localInterface.packageConfChange(").concat(JSON.stringify(source), ", ").concat(JSON.stringify(confFile), ")"));
          }
        }, {
          key: "resourcesOfPackage",
          value: function () {
            var _RemoteCoreInterface_resourcesOfPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(packageOrAddress) {
              var exclude,
                  _args21 = arguments;
              return regeneratorRuntime.wrap(function _callee20$(_context21) {
                while (1) {
                  switch (_context21.prev = _context21.next) {
                    case 0:
                      exclude = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : [".git", "node_modules", ".module_cache", "lively.next-node_modules"];
                      if (packageOrAddress.address) packageOrAddress = packageOrAddress.address;
                      return _context21.abrupt("return", this.runEvalAndStringify("\n      ".concat(this.livelySystemAccessor(), ";\n      await livelySystem.localInterface.resourcesOfPackage(").concat(JSON.stringify(packageOrAddress), ", ").concat(JSON.stringify(exclude), ");")));

                    case 3:
                    case "end":
                      return _context21.stop();
                  }
                }
              }, _callee20, this);
            }));

            function RemoteCoreInterface_resourcesOfPackage_(_x25) {
              return _RemoteCoreInterface_resourcesOfPackage_.apply(this, arguments);
            }

            return RemoteCoreInterface_resourcesOfPackage_;
          }()
        }, {
          key: "getModule",
          value: function () {
            var _RemoteCoreInterface_getModule_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(name) {
              var spec;
              return regeneratorRuntime.wrap(function _callee21$(_context22) {
                while (1) {
                  switch (_context22.prev = _context22.next) {
                    case 0:
                      _context22.next = 2;
                      return this.getModules();

                    case 2:
                      _context22.t0 = function (ea) {
                        return ea.name === name;
                      };

                      spec = _context22.sent.find(_context22.t0);
                      return _context22.abrupt("return", spec ? module$1(spec.name) : null);

                    case 5:
                    case "end":
                      return _context22.stop();
                  }
                }
              }, _callee21, this);
            }));

            function RemoteCoreInterface_getModule_(_x26) {
              return _RemoteCoreInterface_getModule_.apply(this, arguments);
            }

            return RemoteCoreInterface_getModule_;
          }()
        }, {
          key: "importModule",
          value: function RemoteCoreInterface_importModule_(name) {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.System.import(").concat(JSON.stringify(name), ")"));
          }
        }, {
          key: "forgetModule",
          value: function RemoteCoreInterface_forgetModule_(name, opts) {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.module(").concat(JSON.stringify(name), ").unload(").concat(JSON.stringify(opts), ")"));
          }
        }, {
          key: "reloadModule",
          value: function RemoteCoreInterface_reloadModule_(name, opts) {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.module(").concat(JSON.stringify(name), ").reload(").concat(JSON.stringify(opts), ")"));
          }
        }, {
          key: "moduleFormat",
          value: function RemoteCoreInterface_moduleFormat_(moduleName) {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.module(").concat(JSON.stringify(moduleName), ").format();"));
          }
        }, {
          key: "setModuleFormat",
          value: function RemoteCoreInterface_setModuleFormat_(moduleName, format) {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.module(").concat(JSON.stringify(moduleName), ").setFormat(").concat(JSON.stringify(format), ");"));
          }
        }, {
          key: "moduleRead",
          value: function RemoteCoreInterface_moduleRead_(moduleName) {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.module(").concat(JSON.stringify(moduleName), ").source()"));
          }
        }, {
          key: "moduleSourceChange",
          value: function RemoteCoreInterface_moduleSourceChange_(moduleName, newSource, options) {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", modules.module(").concat(JSON.stringify(moduleName), ").changeSource(").concat(JSON.stringify(newSource), ", ").concat(JSON.stringify(options), ")"));
          }
        }, {
          key: "keyValueListOfVariablesInModule",
          value: function RemoteCoreInterface_keyValueListOfVariablesInModule_(moduleName, sourceOrAst) {
            return this.runEvalAndStringify("\n      ".concat(this.livelySystemAccessor(), ";\n      await livelySystem.localInterface.keyValueListOfVariablesInModule(").concat(JSON.stringify(moduleName), ", ").concat(JSON.stringify(sourceOrAst), ")"));
          }
        }, {
          key: "importsAndExportsOf",
          value: function RemoteCoreInterface_importsAndExportsOf_(modId, sourceOrAst) {
            return this.runEvalAndStringify("".concat(this.livelyModulesAccessor(), ", ({\n      imports: await modules.module(").concat(JSON.stringify(modId), ").imports(),\n      exports: await modules.module(").concat(JSON.stringify(modId), ").exports()})"));
          }
        }, {
          key: "exportsOfModules",
          value: function RemoteCoreInterface_exportsOfModules_(options) {
            return this.runEvalAndStringify("\n      ".concat(this.livelySystemAccessor(), "\n      const options = ").concat(JSON.stringify(options), ";\n      options.excludedPackages = [").concat(options.excludedPackages.map(function (k) {
              return typeof k === "function" ? k.toString() : JSON.stringify(k);
            }).join(","), "]\n      await livelySystem.localInterface.exportsOfModules(options)"));
          }
        }, {
          key: "searchInPackage",
          value: function RemoteCoreInterface_searchInPackage_(packageURL, searchString, options) {
            return this.runEvalAndStringify("\n      ".concat(this.livelySystemAccessor(), ";\n      await livelySystem.localInterface.searchInPackage(").concat(JSON.stringify(packageURL), ", ").concat(JSON.stringify(searchString), ", ").concat(JSON.stringify(options), ")"));
          }
        }, {
          key: "loadMochaTestFile",
          value: function () {
            var _RemoteCoreInterface_loadMochaTestFile_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(file) {
              var testsByFile,
                  _args23 = arguments;
              return regeneratorRuntime.wrap(function _callee22$(_context23) {
                while (1) {
                  switch (_context23.prev = _context23.next) {
                    case 0:
                      testsByFile = _args23.length > 1 && _args23[1] !== undefined ? _args23[1] : [];
                      return _context23.abrupt("return", this.runEvalAndStringify("\n      ".concat(this.livelySystemAccessor(), ";\n      var {testsByFile} = await livelySystem.localInterface.loadMochaTestFile(").concat(JSON.stringify(file), ", ").concat(JSON.stringify(testsByFile), "), result;\n      result = {testsByFile}")));

                    case 2:
                    case "end":
                      return _context23.stop();
                  }
                }
              }, _callee22, this);
            }));

            function RemoteCoreInterface_loadMochaTestFile_(_x27) {
              return _RemoteCoreInterface_loadMochaTestFile_.apply(this, arguments);
            }

            return RemoteCoreInterface_loadMochaTestFile_;
          }()
        }, {
          key: "runMochaTests",
          value: function () {
            var _RemoteCoreInterface_runMochaTests_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(grep, testsByFile, onChange, onError) {
              return regeneratorRuntime.wrap(function _callee23$(_context24) {
                while (1) {
                  switch (_context24.prev = _context24.next) {
                    case 0:
                      if (grep && grep instanceof RegExp) {
                        grep = {
                          isRegExp: true,
                          value: String(grep).replace(/^\/|\/$/g, "")
                        };
                      }

                      return _context24.abrupt("return", this.runEvalAndStringify("\n      var grep = ".concat(JSON.stringify(grep), ";\n      if (grep && grep.isRegExp) grep = new RegExp(grep.value);\n      ").concat(this.livelySystemAccessor(), ";\n      var {testsByFile, isError, value: error} = await livelySystem.localInterface.runMochaTests(grep, ").concat(JSON.stringify(testsByFile || []), "), result;\n      error = error ? String(error.stack || error) : null;\n      if (testsByFile) {\n        testsByFile.forEach(ea =>\n          ea.tests.forEach(ea => {\n            if (!ea.error) return;\n            var {message, stack, actual, expected} = ea.error;\n            ea.error = {\n              message: message || String(ea.error),\n              stack: stack,\n              actual, exected\n            }\n          }));\n      }\n      result = {testsByFile, isError, error};")));

                    case 2:
                    case "end":
                      return _context24.stop();
                  }
                }
              }, _callee23, this);
            }));

            function RemoteCoreInterface_runMochaTests_(_x28, _x29, _x30, _x31) {
              return _RemoteCoreInterface_runMochaTests_.apply(this, arguments);
            }

            return RemoteCoreInterface_runMochaTests_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "RemoteCoreInterface";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./interfaces/interface.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively-system-interface",
              version: "0.2.1"
            };
          }
        }, {
          start: 5451,
          end: 18625
        });
      }(__varRecorder__$1j.AbstractCoreInterface);
      __varRecorder__$1j.RemoteCoreInterface = RemoteCoreInterface;
      __varRecorder__$1j.RemoteCoreInterface = RemoteCoreInterface;

      var _interface = /*#__PURE__*/Object.freeze({
        __proto__: null,
        AbstractCoreInterface: AbstractCoreInterface,
        RemoteCoreInterface: RemoteCoreInterface
      });

      var __varRecorder__$1i = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively-system-interface/interfaces/local-system.js", __contextModule__);
      var LocalCoreInterface = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively-system-interface/interfaces/local-system.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("LocalCoreInterface") && typeof __lively_classholder__.LocalCoreInterface === "function" ? __lively_classholder__.LocalCoreInterface : __lively_classholder__.LocalCoreInterface = function LocalCoreInterface(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "name",
          get: function get() {
            return "local";
          }
        }, {
          key: "dynamicCompletionsForPrefix",
          value: function () {
            var _LocalCoreInterface_dynamicCompletionsForPrefix_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(moduleName, prefix, options) {
              var result;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return getCompletions(function (code) {
                        return runEval$1(code.replace("return ", ""), Object.assign({
                          targetModule: moduleName,
                          classTransform: classToFunctionTransform
                        }, options));
                      }, prefix);

                    case 2:
                      result = _context.sent;

                      if (!result.isError) {
                        _context.next = 5;
                        break;
                      }

                      throw result.value;

                    case 5:
                      return _context.abrupt("return", {
                        completions: result.completions,
                        prefix: result.startLetters
                      });

                    case 6:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));

            function LocalCoreInterface_dynamicCompletionsForPrefix_(_x, _x2, _x3) {
              return _LocalCoreInterface_dynamicCompletionsForPrefix_.apply(this, arguments);
            }

            return LocalCoreInterface_dynamicCompletionsForPrefix_;
          }()
        }, {
          key: "runEval",
          value: function LocalCoreInterface_runEval_(source, options) {
            return runEval$1(source, Object.assign({
              classTransform: classToFunctionTransform
            }, options));
          }
        }, {
          key: "resourceExists",
          value: function LocalCoreInterface_resourceExists_(url) {
            return resource(url).exists();
          }
        }, {
          key: "resourceEnsureExistance",
          value: function LocalCoreInterface_resourceEnsureExistance_(url, optContent) {
            return resource(url).ensureExistance(optContent);
          }
        }, {
          key: "resourceMkdir",
          value: function LocalCoreInterface_resourceMkdir_(url) {
            return resource(url).mkdir();
          }
        }, {
          key: "resourceRead",
          value: function LocalCoreInterface_resourceRead_(url) {
            return resource(url).read();
          }
        }, {
          key: "resourceRemove",
          value: function LocalCoreInterface_resourceRemove_(url) {
            return resource(url).remove();
          }
        }, {
          key: "resourceWrite",
          value: function LocalCoreInterface_resourceWrite_(url, source) {
            return resource(url).write(source);
          }
        }, {
          key: "resourceCreateFiles",
          value: function LocalCoreInterface_resourceCreateFiles_(baseDir, spec) {
            return createFiles(baseDir, spec);
          }
        }, {
          key: "resourceDirList",
          value: function LocalCoreInterface_resourceDirList_(url, depth, opts) {
            return resource(url).dirList(depth, opts);
          }
        }, {
          key: "normalizeSync",
          value: function LocalCoreInterface_normalizeSync_(name, parentName, isPlugin) {
            return System.decanonicalize(name, parentName, isPlugin);
          }
        }, {
          key: "normalize",
          value: function LocalCoreInterface_normalize_(name, parent, parentAddress) {
            return System.normalize(name, parent, parentAddress);
          }
        }, {
          key: "printSystemConfig",
          value: function LocalCoreInterface_printSystemConfig_() {
            return printSystemConfig();
          }
        }, {
          key: "getConfig",
          value: function LocalCoreInterface_getConfig_() {
            return System.getConfig();
          }
        }, {
          key: "setConfig",
          value: function LocalCoreInterface_setConfig_(conf) {
            defaultSystem.config(conf);
          }
        }, {
          key: "getPackages",
          value: function LocalCoreInterface_getPackages_(options) {
            var _Object$assign = Object.assign({}, options),
                _Object$assign$exclud = _Object$assign.excluded,
                excluded = _Object$assign$exclud === void 0 ? [] : _Object$assign$exclud;

            var excludedURLs = excluded.filter(function (ea) {
              return typeof ea === "string";
            });
            var excludeFns = excluded.filter(function (ea) {
              return typeof ea === "function";
            });
            excludedURLs = excludedURLs.concat(excludedURLs.map(function (url) {
              return System.decanonicalize(url.replace(/\/?$/, "/")).replace(/\/$/, "");
            }));
            return getPackages().filter(function (p) {
              return !excludedURLs.includes(p.url) && !excludeFns.some(function (fn) {
                return fn(p.url);
              });
            });
          }
        }, {
          key: "registerPackage",
          value: function () {
            var _LocalCoreInterface_registerPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(packageURL) {
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      return _context2.abrupt("return", registerPackage(packageURL));

                    case 1:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }));

            function LocalCoreInterface_registerPackage_(_x4) {
              return _LocalCoreInterface_registerPackage_.apply(this, arguments);
            }

            return LocalCoreInterface_registerPackage_;
          }()
        }, {
          key: "importPackage",
          value: function () {
            var _LocalCoreInterface_importPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(packageURL) {
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      return _context3.abrupt("return", importPackage(packageURL));

                    case 1:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3);
            }));

            function LocalCoreInterface_importPackage_(_x5) {
              return _LocalCoreInterface_importPackage_.apply(this, arguments);
            }

            return LocalCoreInterface_importPackage_;
          }()
        }, {
          key: "removePackage",
          value: function () {
            var _LocalCoreInterface_removePackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(packageURL) {
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      return _context4.abrupt("return", removePackage(packageURL));

                    case 1:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            }));

            function LocalCoreInterface_removePackage_(_x6) {
              return _LocalCoreInterface_removePackage_.apply(this, arguments);
            }

            return LocalCoreInterface_removePackage_;
          }()
        }, {
          key: "reloadPackage",
          value: function () {
            var _LocalCoreInterface_reloadPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(packageURL, opts) {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      return _context5.abrupt("return", reloadPackage(packageURL, opts));

                    case 1:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5);
            }));

            function LocalCoreInterface_reloadPackage_(_x7, _x8) {
              return _LocalCoreInterface_reloadPackage_.apply(this, arguments);
            }

            return LocalCoreInterface_reloadPackage_;
          }()
        }, {
          key: "packageConfChange",
          value: function () {
            var _LocalCoreInterface_packageConfChange_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(source, confFile) {
              var S, config, newSource, p;
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      S = defaultSystem;
                      config = parseJsonLikeObj(source);
                      newSource = JSON.stringify(config, null, 2);
                      _context6.next = 5;
                      return module$1(confFile).changeSource(newSource, {
                        doEval: false
                      });

                    case 5:
                      S.set(confFile, S.newModule(config));
                      _context6.next = 8;
                      return this.getPackageForModule(confFile);

                    case 8:
                      p = _context6.sent;
                      if (p) applyPackageConfig(config, p.address);

                    case 10:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function LocalCoreInterface_packageConfChange_(_x9, _x10) {
              return _LocalCoreInterface_packageConfChange_.apply(this, arguments);
            }

            return LocalCoreInterface_packageConfChange_;
          }()
        }, {
          key: "resourcesOfPackage",
          value: function () {
            var _LocalCoreInterface_resourcesOfPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(packageOrAddress) {
              var exclude,
                  _p$lively,
                  _p$lively$ide,
                  url,
                  p,
                  _args7 = arguments;

              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      exclude = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : [".git", "node_modules", ".module_cache"];
                      _context7.prev = 1;
                      url = packageOrAddress.address ? packageOrAddress.address : packageOrAddress;
                      p = getPackage(url);
                      _context7.next = 6;
                      return p.resources(undefined, [].concat(_toConsumableArray$1(exclude), _toConsumableArray$1(((_p$lively = p.lively) === null || _p$lively === void 0 ? void 0 : (_p$lively$ide = _p$lively.ide) === null || _p$lively$ide === void 0 ? void 0 : _p$lively$ide.exclude) || [])));

                    case 6:
                      _context7.t0 = function (ea) {
                        return Object.assign(ea, {
                          "package": ea["package"].url
                        });
                      };

                      return _context7.abrupt("return", _context7.sent.map(_context7.t0));

                    case 10:
                      _context7.prev = 10;
                      _context7.t1 = _context7["catch"](1);
                      console.warn("resourcesOfPackage error for ".concat(packageOrAddress, ": ").concat(_context7.t1));
                      return _context7.abrupt("return", []);

                    case 14:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7, null, [[1, 10]]);
            }));

            function LocalCoreInterface_resourcesOfPackage_(_x11) {
              return _LocalCoreInterface_resourcesOfPackage_.apply(this, arguments);
            }

            return LocalCoreInterface_resourcesOfPackage_;
          }()
        }, {
          key: "getPackageForModule",
          value: function LocalCoreInterface_getPackageForModule_(moduleId) {
            var p = getPackageOfModule(moduleId);
            return p ? p.asSpec() : p;
          }
        }, {
          key: "isModuleLoaded",
          value: function LocalCoreInterface_isModuleLoaded_(name, isNormalized) {
            return isModuleLoaded(name, isNormalized);
          }
        }, {
          key: "doesModuleExist",
          value: function LocalCoreInterface_doesModuleExist_(name, isNormalized) {
            return isModuleLoaded(name, isNormalized);
          }
        }, {
          key: "getModule",
          value: function LocalCoreInterface_getModule_(name) {
            return module$1(name);
          }
        }, {
          key: "importModule",
          value: function LocalCoreInterface_importModule_(name) {
            return defaultSystem["import"](name);
          }
        }, {
          key: "forgetModule",
          value: function LocalCoreInterface_forgetModule_(name, opts) {
            return module$1(name).unload(opts);
          }
        }, {
          key: "reloadModule",
          value: function LocalCoreInterface_reloadModule_(name, opts) {
            return module$1(name).reload(opts);
          }
        }, {
          key: "moduleFormat",
          value: function LocalCoreInterface_moduleFormat_(moduleName) {
            return module$1(moduleName).format();
          }
        }, {
          key: "setModuleFormat",
          value: function LocalCoreInterface_setModuleFormat_(moduleName, format) {
            module$1(moduleName).setFormat(format);
          }
        }, {
          key: "moduleRead",
          value: function LocalCoreInterface_moduleRead_(moduleName) {
            return module$1(moduleName).source();
          }
        }, {
          key: "moduleSourceChange",
          value: function LocalCoreInterface_moduleSourceChange_(moduleName, newSource, options) {
            return module$1(moduleName).changeSource(newSource, options);
          }
        }, {
          key: "keyValueListOfVariablesInModule",
          value: function () {
            var _LocalCoreInterface_keyValueListOfVariablesInModule_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(moduleName, sourceOrAstOrNothing) {
              var parsed, id, scope, importsExports, toplevel, decls, imports, col1Width;
              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      if (sourceOrAstOrNothing) {
                        _context8.next = 4;
                        break;
                      }

                      _context8.next = 3;
                      return this.resourceRead(moduleName);

                    case 3:
                      sourceOrAstOrNothing = _context8.sent;

                    case 4:
                      parsed = typeof sourceOrAstOrNothing === "string" ? parse$2(sourceOrAstOrNothing) : sourceOrAstOrNothing;
                      id = this.normalizeSync(moduleName);
                      scope = module$1(id).env().recorder;
                      _context8.next = 9;
                      return this.importsAndExportsOf(id, parsed);

                    case 9:
                      importsExports = _context8.sent;
                      toplevel = topLevelDeclsAndRefs(parsed);
                      decls = sortByKey(declarationsOfScope(toplevel.scope, true), "start");
                      imports = pluck(toplevel.scope.importSpecifiers, "name");
                      col1Width = 0;
                      return _context8.abrupt("return", decls.map(function (v) {
                        var nameLength = v.name.length;
                        var isExport = importsExports.exports.find(function (ea) {
                          return ea.local === v.name;
                        });
                        var isImport = imports.includes(v.name);
                        if (isExport) nameLength += " [export]".length;
                        if (isImport) nameLength += " [import]".length;
                        col1Width = Math.max(col1Width, nameLength);
                        return {
                          isExport: isExport,
                          isImport: isImport,
                          name: v.name,
                          value: scope[v.name],
                          node: v,
                          printedName: v.name + (isExport ? " [export]" : "") + (isImport ? " [import]" : ""),
                          printedValue: inspect$1(scope[v.name], {
                            maxDepth: 1
                          }).replace(/\n/g, "")
                        };
                      }).map(function (val) {
                        return {
                          isListItem: true,
                          value: val,
                          string: val.printedName + indent(" = " + val.printedValue, " ", col1Width - val.printedName.length)
                        };
                      }));

                    case 15:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, this);
            }));

            function LocalCoreInterface_keyValueListOfVariablesInModule_(_x12, _x13) {
              return _LocalCoreInterface_keyValueListOfVariablesInModule_.apply(this, arguments);
            }

            return LocalCoreInterface_keyValueListOfVariablesInModule_;
          }()
        }, {
          key: "importsAndExportsOf",
          value: function () {
            var _LocalCoreInterface_importsAndExportsOf_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(modId, sourceOrAst) {
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      _context9.next = 2;
                      return module$1(modId).imports(sourceOrAst);

                    case 2:
                      _context9.t0 = _context9.sent;
                      _context9.next = 5;
                      return module$1(modId).exports(sourceOrAst);

                    case 5:
                      _context9.t1 = _context9.sent;
                      return _context9.abrupt("return", {
                        imports: _context9.t0,
                        exports: _context9.t1
                      });

                    case 7:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9);
            }));

            function LocalCoreInterface_importsAndExportsOf_(_x14, _x15) {
              return _LocalCoreInterface_importsAndExportsOf_.apply(this, arguments);
            }

            return LocalCoreInterface_importsAndExportsOf_;
          }()
        }, {
          key: "exportsOfModules",
          value: function LocalCoreInterface_exportsOfModules_(options) {
            return ExportLookup.run(System, options);
          }
        }, {
          key: "searchInPackage",
          value: function LocalCoreInterface_searchInPackage_(packageURL, searchString, options) {
            return getPackage(packageURL).search(searchString, options);
          }
        }, {
          key: "runMochaTests",
          value: function () {
            var _LocalCoreInterface_runMochaTests_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(grep, testsByFile, onChange, onError) {
              var _yield$import, runMochaTests;

              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      _context10.next = 2;
                      return module.import('./mocha-tests-a6c460d6.js');

                    case 2:
                      _yield$import = _context10.sent;
                      runMochaTests = _yield$import.runMochaTests;
                      return _context10.abrupt("return", runMochaTests(grep, testsByFile, onChange, onError));

                    case 5:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10);
            }));

            function LocalCoreInterface_runMochaTests_(_x16, _x17, _x18, _x19) {
              return _LocalCoreInterface_runMochaTests_.apply(this, arguments);
            }

            return LocalCoreInterface_runMochaTests_;
          }()
        }, {
          key: "loadMochaTestFile",
          value: function () {
            var _LocalCoreInterface_loadMochaTestFile_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(file, testsByFile) {
              var _yield$import2, loadMochaTestFile;

              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      _context11.next = 2;
                      return module.import('./mocha-tests-a6c460d6.js');

                    case 2:
                      _yield$import2 = _context11.sent;
                      loadMochaTestFile = _yield$import2.loadMochaTestFile;
                      return _context11.abrupt("return", loadMochaTestFile(file, testsByFile));

                    case 5:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11);
            }));

            function LocalCoreInterface_loadMochaTestFile_(_x20, _x21) {
              return _LocalCoreInterface_loadMochaTestFile_.apply(this, arguments);
            }

            return LocalCoreInterface_loadMochaTestFile_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "LocalCoreInterface";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./interfaces/local-system.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively-system-interface",
              version: "0.2.1"
            };
          }
        }, {
          start: 411,
          end: 8326
        });
      }({
        referencedAs: "AbstractCoreInterface",
        value: AbstractCoreInterface
      });
      __varRecorder__$1i.LocalCoreInterface = LocalCoreInterface;
      __varRecorder__$1i.LocalCoreInterface = LocalCoreInterface;

      var __varRecorder__$1h = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively-system-interface/interfaces/http-interface.js", __contextModule__);
      var HTTPCoreInterface = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively-system-interface/interfaces/http-interface.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("HTTPCoreInterface") && typeof __lively_classholder__.HTTPCoreInterface === "function" ? __lively_classholder__.HTTPCoreInterface : __lively_classholder__.HTTPCoreInterface = function HTTPCoreInterface(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function HTTPCoreInterface_initialize_(url) {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this);
            this.currentEval = null;
            this.url = url;
            this.server = new HttpEvalStrategy(url);
            return _this;
          }
        }, {
          key: "name",
          get: function get() {
            return this.url;
          }
        }, {
          key: "description",
          get: function get() {
            return this.url.replace(/^https?:\/\//, "");
          }
        }, {
          key: "runEval",
          value: function HTTPCoreInterface_runEval_(source, options) {
            return this.server.runEval(source, options);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "HTTPCoreInterface";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./interfaces/http-interface.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively-system-interface",
              version: "0.2.1"
            };
          }
        }, {
          start: 106,
          end: 512
        });
      }({
        referencedAs: "RemoteCoreInterface",
        value: RemoteCoreInterface
      });
      __varRecorder__$1h.HTTPCoreInterface = HTTPCoreInterface;
      __varRecorder__$1h.HTTPCoreInterface = HTTPCoreInterface;

      var __varRecorder__$1g = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively-system-interface/interfaces/l2l-interface.js", __contextModule__);
      var L2LCoreInterface = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively-system-interface/interfaces/l2l-interface.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("L2LCoreInterface") && typeof __lively_classholder__.L2LCoreInterface === "function" ? __lively_classholder__.L2LCoreInterface : __lively_classholder__.L2LCoreInterface = function L2LCoreInterface(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function L2LCoreInterface_initialize_(targetId, peer) {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this);
            this.targetId = targetId;
            this.peer = peer;
            return _this;
          }
        }, {
          key: "name",
          get: function get() {
            return "l2l ".concat(this.targetId);
          }
        }, {
          key: "description",
          get: function get() {
            var targetId = this.targetId,
                peer = this.peer;
            var id = targetId.slice(0, 5);
            var name = "l2l ".concat(id);

            if (peer) {
              var location = peer.location,
                  type = peer.type,
                  user = peer.user,
                  world = peer.world;
              if (type) name += ", ".concat(type);

              if (location) {
                name += ", ".concat(location.replace(/^https?:\/\//, "")).concat(world ? "/" + world : "");
              }

              if (user) name += ", ".concat(user.name);
            }

            return name;
          }
        }, {
          key: "client",
          get: function get() {
            var _ref = lively.modules.module("lively.2lively/client.js").get() || {
              "default": lively.l2l.L2LClient
            },
                L2LClient = _ref["default"];

            return L2LClient["default"]();
          }
        }, {
          key: "isConnected",
          value: function () {
            var _L2LCoreInterface_isConnected_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var client, targetId, _yield$client$sendToA, clients;

              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      client = this.client, targetId = this.targetId;
                      _context.next = 3;
                      return client.sendToAndWait(client.trackerId, "getClients", {});

                    case 3:
                      _yield$client$sendToA = _context.sent;
                      clients = _yield$client$sendToA.data;
                      return _context.abrupt("return", clients.some(function (_ref2) {
                        var _ref3 = _slicedToArray(_ref2, 1),
                            id = _ref3[0];

                        return targetId === id;
                      }));

                    case 6:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function L2LCoreInterface_isConnected_() {
              return _L2LCoreInterface_isConnected_.apply(this, arguments);
            }

            return L2LCoreInterface_isConnected_;
          }()
        }, {
          key: "runEval",
          value: function () {
            var _L2LCoreInterface_runEval_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(source, options) {
              var l2lClient, l2lEval;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      l2lClient = this.client;

                      if (l2lClient) {
                        _context2.next = 3;
                        break;
                      }

                      throw new Error("No lively.2lively default client available!");

                    case 3:
                      l2lEval = new L2LEvalStrategy(l2lClient, this.targetId);
                      return _context2.abrupt("return", l2lEval.runEval(source, options));

                    case 5:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function L2LCoreInterface_runEval_(_x, _x2) {
              return _L2LCoreInterface_runEval_.apply(this, arguments);
            }

            return L2LCoreInterface_runEval_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "L2LCoreInterface";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./interfaces/l2l-interface.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively-system-interface",
              version: "0.2.1"
            };
          }
        }, {
          start: 106,
          end: 1449
        });
      }({
        referencedAs: "RemoteCoreInterface",
        value: RemoteCoreInterface
      });
      __varRecorder__$1g.L2LCoreInterface = L2LCoreInterface;
      __varRecorder__$1g.L2LCoreInterface = L2LCoreInterface;

      var __varRecorder__$1f = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively-system-interface/index.js", __contextModule__);
      var __moduleMeta__$y = {
        pathInPackage: function pathInPackage() {
          return "./index.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively-system-interface",
            version: "0.2.1"
          };
        }
      };

      var systemInterfaceNamed = __varRecorder__$1f["lively-system-interface/index.js__define__"]("systemInterfaceNamed", "function", function (interfaceSpec) {
        if (!interfaceSpec) interfaceSpec = "local";
        var systemInterface;

        if (interfaceSpec.isSystemInterface) {
          systemInterface = interfaceSpec;
        } else {
          if (typeof interfaceSpec === "string" && interfaceSpec.startsWith("l2l ")) {
            interfaceSpec = {
              type: "l2l",
              id: interfaceSpec.split(" ")[1]
            };
          }

          if (typeof interfaceSpec !== "string") {
            if (interfaceSpec.type === "l2l") {
              systemInterface = __varRecorder__$1f.l2lInterfaceFor(interfaceSpec.id, interfaceSpec.info);
            }
          }

          if (typeof interfaceSpec !== "string") {
            $world.setStatusMessage("Unknown system interface ".concat(interfaceSpec));
            interfaceSpec = "local";
          }

          if (!systemInterface) {
            systemInterface = !interfaceSpec || interfaceSpec === "local" ? __varRecorder__$1f.localInterface : __varRecorder__$1f.serverInterfaceFor(interfaceSpec);
          }
        }

        return systemInterface;
      }, __moduleMeta__$y);

      __varRecorder__$1f.systemInterfaceNamed = systemInterfaceNamed;
      var Interface = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively-system-interface/index.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("Interface") && typeof __lively_classholder__.Interface === "function" ? __lively_classholder__.Interface : __lively_classholder__.Interface = function Interface(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function Interface_initialize_(coreInterface) {
            this.coreInterface = coreInterface;
          }
        }, {
          key: "isSystemInterface",
          get: function get() {
            return true;
          }
        }, {
          key: "name",
          get: function get() {
            return this.coreInterface.name;
          }
        }, {
          key: "dynamicCompletionsForPrefix",
          value: function Interface_dynamicCompletionsForPrefix_(mod, prefix, opts) {
            return this.coreInterface.dynamicCompletionsForPrefix(mod, prefix, opts);
          }
        }, {
          key: "runEval",
          value: function Interface_runEval_(source, options) {
            return this.coreInterface.runEval(source, options);
          }
        }, {
          key: "printSystemConfig",
          value: function Interface_printSystemConfig_(a, b, c) {
            return this.coreInterface.printSystemConfig(a, b, c);
          }
        }, {
          key: "getConfig",
          value: function Interface_getConfig_(a, b, c) {
            return this.coreInterface.getConfig(a, b, c);
          }
        }, {
          key: "getPackages",
          value: function Interface_getPackages_(options) {
            return this.coreInterface.getPackages(options);
          }
        }, {
          key: "getModules",
          value: function Interface_getModules_(a, b, c) {
            return this.coreInterface.getModules(a, b, c);
          }
        }, {
          key: "getModule",
          value: function Interface_getModule_(a, b, c) {
            return this.coreInterface.getModule(a, b, c);
          }
        }, {
          key: "getPackage",
          value: function Interface_getPackage_(a, b, c) {
            return this.coreInterface.getPackage(a, b, c);
          }
        }, {
          key: "getPackageForModule",
          value: function Interface_getPackageForModule_(a, b, c) {
            return this.coreInterface.getPackageForModule(a, b, c);
          }
        }, {
          key: "resourcesOfPackage",
          value: function Interface_resourcesOfPackage_(packageAddress, excludes) {
            return this.coreInterface.resourcesOfPackage(packageAddress, excludes);
          }
        }, {
          key: "systemConfChange",
          value: function Interface_systemConfChange_(a, b, c) {
            return this.coreInterface.systemConfChange(a, b, c);
          }
        }, {
          key: "registerPackage",
          value: function Interface_registerPackage_(packageURL) {
            return this.coreInterface.registerPackage(packageURL);
          }
        }, {
          key: "importPackage",
          value: function Interface_importPackage_(packageURL) {
            return this.coreInterface.importPackage(packageURL);
          }
        }, {
          key: "removePackage",
          value: function Interface_removePackage_(packageURL) {
            return this.coreInterface.removePackage(packageURL);
          }
        }, {
          key: "reloadPackage",
          value: function Interface_reloadPackage_(packageURL) {
            return this.coreInterface.reloadPackage(packageURL);
          }
        }, {
          key: "packageConfChange",
          value: function Interface_packageConfChange_(source, confFile) {
            return this.coreInterface.packageConfChange(source, confFile);
          }
        }, {
          key: "keyValueListOfVariablesInModule",
          value: function Interface_keyValueListOfVariablesInModule_(moduleName, sourceOrAst) {
            return this.coreInterface.keyValueListOfVariablesInModule(moduleName, sourceOrAst);
          }
        }, {
          key: "interactivelyCreatePackage",
          value: function Interface_interactivelyCreatePackage_(requester) {
            return interactivelyCreatePackage(this.coreInterface, requester);
          }
        }, {
          key: "interactivelyLoadPackage",
          value: function Interface_interactivelyLoadPackage_(a, b) {
            return interactivelyLoadPackage(this.coreInterface, a, b);
          }
        }, {
          key: "interactivelyReloadPackage",
          value: function Interface_interactivelyReloadPackage_(a, b) {
            return interactivelyReloadPackage(this.coreInterface, a, b);
          }
        }, {
          key: "interactivelyUnloadPackage",
          value: function Interface_interactivelyUnloadPackage_(vmEditor, packageURL, world) {
            return interactivelyUnloadPackage(this.coreInterface, vmEditor, packageURL, world);
          }
        }, {
          key: "interactivelyRemovePackage",
          value: function Interface_interactivelyRemovePackage_(requester, pkgURL) {
            return interactivelyRemovePackage(this.coreInterface, requester, pkgURL);
          }
        }, {
          key: "isModuleLoaded",
          value: function Interface_isModuleLoaded_(name, isNormalized) {
            return this.coreInterface.isModuleLoaded(name, isNormalized);
          }
        }, {
          key: "doesModuleExist",
          value: function Interface_doesModuleExist_(name, isNormalized) {
            return this.coreInterface.doesModuleExist(name, isNormalized);
          }
        }, {
          key: "createModule",
          value: function Interface_createModule_(name) {
            return addModule(this.coreInterface, name);
          }
        }, {
          key: "importModule",
          value: function Interface_importModule_(name) {
            return this.coreInterface.importModule(name);
          }
        }, {
          key: "forgetModule",
          value: function Interface_forgetModule_(name, opts) {
            return this.coreInterface.forgetModule(name, opts);
          }
        }, {
          key: "reloadModule",
          value: function Interface_reloadModule_(name, opts) {
            return this.coreInterface.reloadModule(name, opts);
          }
        }, {
          key: "moduleFormat",
          value: function Interface_moduleFormat_(name) {
            return this.coreInterface.moduleFormat(name);
          }
        }, {
          key: "setModuleFormat",
          value: function Interface_setModuleFormat_(name, format) {
            return this.coreInterface.setModuleFormat(name, format);
          }
        }, {
          key: "moduleRead",
          value: function Interface_moduleRead_(name) {
            return name.endsWith("js") ? this.coreInterface.moduleRead(name) : this.coreInterface.resourceRead(name);
          }
        }, {
          key: "moduleWrite",
          value: function Interface_moduleWrite_(name, content) {
            return this.coreInterface.moduleWrite(name, content);
          }
        }, {
          key: "getModulesInPackage",
          value: function Interface_getModulesInPackage_(name) {
            return modulesInPackage(this.coreInterface, name);
          }
        }, {
          key: "shortModuleName",
          value: function Interface_shortModuleName_(moduleId, itsPackage) {
            return shortModuleName(this.coreInterface, moduleId, itsPackage);
          }
        }, {
          key: "interactivelyChangeModule",
          value: function Interface_interactivelyChangeModule_(moduleName, newSource, options) {
            return interactivelyChangeModule(this.coreInterface, moduleName, newSource, options);
          }
        }, {
          key: "interactivelyReloadModule",
          value: function Interface_interactivelyReloadModule_(vmEditor, moduleName) {
            return interactivelyReloadModule(this.coreInterface, vmEditor, moduleName);
          }
        }, {
          key: "interactivelyUnloadModule",
          value: function Interface_interactivelyUnloadModule_(vmEditor, moduleName) {
            return interactivelyUnloadModule(this.coreInterface, vmEditor, moduleName);
          }
        }, {
          key: "interactivelyRemoveModule",
          value: function Interface_interactivelyRemoveModule_(requester, moduleName) {
            return interactivelyRemoveModule(this.coreInterface, requester, moduleName);
          }
        }, {
          key: "interactivelyAddModule",
          value: function Interface_interactivelyAddModule_(requester, relatedPackageOrModule) {
            return interactivelyAddModule(this.coreInterface, requester, relatedPackageOrModule);
          }
        }, {
          key: "showExportsAndImportsOf",
          value: function Interface_showExportsAndImportsOf_(packageAddress, world) {
            return showExportsAndImportsOf(this.coreInterface, packageAddress, world);
          }
        }, {
          key: "exportsOfModules",
          value: function Interface_exportsOfModules_(options) {
            return this.coreInterface.exportsOfModules(options);
          }
        }, {
          key: "searchInPackage",
          value: function Interface_searchInPackage_(packageURL, searchTerm, options) {
            return this.coreInterface.searchInPackage(packageURL, searchTerm, options);
          }
        }, {
          key: "searchInAllPackages",
          value: function () {
            var _Interface_searchInAllPackages_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(searchTerm) {
              var options,
                  pm,
                  packages,
                  results,
                  i,
                  url,
                  packageResults,
                  _args = arguments;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                      pm = options.progress;
                      pm && pm.step("Fetching Packages...", 0);
                      _context.next = 5;
                      return this.coreInterface.getPackages({
                        excluded: options.excludedPackages
                      });

                    case 5:
                      packages = _context.sent;
                      results = [];
                      pm && pm.step("Fetching Packages...", 0.1);
                      i = 0;

                    case 9:
                      if (!(i < packages.length)) {
                        _context.next = 27;
                        break;
                      }

                      url = packages[i].url;

                      if (!(!url || url === "no group")) {
                        _context.next = 13;
                        break;
                      }

                      return _context.abrupt("continue", 24);

                    case 13:
                      pm && pm.step(url.replace(System.baseURL, "").slice(0, 20), 0.1 + 0.9 * (i / packages.length));
                      _context.prev = 14;
                      _context.next = 17;
                      return this.coreInterface.searchInPackage(url, searchTerm, options);

                    case 17:
                      packageResults = _context.sent;
                      results = results.concat(packageResults);
                      _context.next = 24;
                      break;

                    case 21:
                      _context.prev = 21;
                      _context.t0 = _context["catch"](14);
                      console.error("Error searching in package ".concat(url, ":\n").concat(_context.t0.stack));

                    case 24:
                      i++;
                      _context.next = 9;
                      break;

                    case 27:
                      return _context.abrupt("return", results);

                    case 28:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this, [[14, 21]]);
            }));

            function Interface_searchInAllPackages_(_x) {
              return _Interface_searchInAllPackages_.apply(this, arguments);
            }

            return Interface_searchInAllPackages_;
          }()
        }, {
          key: "loadMochaTestFile",
          value: function Interface_loadMochaTestFile_(file, testsByFile) {
            return this.coreInterface.loadMochaTestFile(file, testsByFile);
          }
        }, {
          key: "runMochaTests",
          value: function Interface_runMochaTests_(grep, testsByFile, onChange, onError) {
            return this.coreInterface.runMochaTests(grep, testsByFile, onChange, onError);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "Interface";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./index.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively-system-interface",
              version: "0.2.1"
            };
          }
        }, {
          start: 679,
          end: 6344
        });
      }(undefined);
      __varRecorder__$1f.Interface = Interface;
      __varRecorder__$1f.Interface = Interface;
      __varRecorder__$1f.systemInterfaceNamed = systemInterfaceNamed;
      __varRecorder__$1f.localInterface = new __varRecorder__$1f.Interface(new LocalCoreInterface());
      var localInterface = exports('l', __varRecorder__$1f.localInterface);
      __varRecorder__$1f.localInterface = localInterface;
      __varRecorder__$1f.httpInterfaces = {};

      __varRecorder__$1f.serverInterfaceFor = function (url) {
        return __varRecorder__$1f.httpInterfaces[url] || (__varRecorder__$1f.httpInterfaces[url] = new __varRecorder__$1f.Interface(new HTTPCoreInterface(url)));
      };

      var serverInterfaceFor = __varRecorder__$1f.serverInterfaceFor;
      __varRecorder__$1f.serverInterfaceFor = serverInterfaceFor;
      __varRecorder__$1f.l2lInterfaces = {};

      __varRecorder__$1f.l2lInterfaceFor = function (targetId, peer) {
        return __varRecorder__$1f.l2lInterfaces[targetId] || (__varRecorder__$1f.l2lInterfaces[targetId] = new __varRecorder__$1f.Interface(new L2LCoreInterface(targetId, peer)));
      };

      var l2lInterfaceFor = exports('a1', __varRecorder__$1f.l2lInterfaceFor);
      __varRecorder__$1f.l2lInterfaceFor = l2lInterfaceFor;

      var index$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Interface: Interface,
        systemInterfaceNamed: systemInterfaceNamed,
        localInterface: localInterface,
        serverInterfaceFor: serverInterfaceFor,
        l2lInterfaceFor: l2lInterfaceFor
      });
      exports('aa', index$2);

      var __varRecorder__$1e = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/context.js", __contextModule__);
      var __moduleMeta__$x = {
        pathInPackage: function pathInPackage() {
          return "./js/inspector/context.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var defaultSort = __varRecorder__$1e["lively.ide/js/inspector/context.js__define__"]("defaultSort", "function", function (a, b) {
        if (a.hasOwnProperty("priority") || b.hasOwnProperty("priority")) {
          var aP = a.priority || 0;
          var bP = b.priority || 0;
          if (aP < bP) return -1;
          if (aP > bP) return 1;
        }

        var aK = (a.keyString || a.key).toLowerCase();
        var bK = (b.keyString || b.key).toLowerCase();
        return aK < bK ? -1 : aK === bK ? 0 : 1;
      }, __moduleMeta__$x);

      __varRecorder__$1e.defaultSort = defaultSort;

      var printSymbol = __varRecorder__$1e["lively.ide/js/inspector/context.js__define__"]("printSymbol", "function", function (sym) {
        if (Symbol.keyFor(sym)) return "Symbol.for(\"".concat(Symbol.keyFor(sym), "\")");
        if (__varRecorder__$1e.knownSymbols.get(sym)) return __varRecorder__$1e.knownSymbols.get(sym);
        return String(sym);
      }, __moduleMeta__$x);

      __varRecorder__$1e.printSymbol = printSymbol;

      var safeToString = __varRecorder__$1e["lively.ide/js/inspector/context.js__define__"]("safeToString", "function", function (value) {
        if (!value) return String(value);
        if (Array.isArray(value)) return "[".concat(value.map(safeToString).join(","), "]");
        if (_typeof$1(value) === "symbol") return __varRecorder__$1e.printSymbol(value);

        try {
          return String(value);
        } catch (e) {
          return "Cannot print object: ".concat(e);
        }
      }, __moduleMeta__$x);

      __varRecorder__$1e.safeToString = safeToString;

      var propertyNamesOf = __varRecorder__$1e["lively.ide/js/inspector/context.js__define__"]("propertyNamesOf", "function", function (obj, partition) {
        if (!obj) return [];

        if (Array.isArray(obj)) {
          var len = partition ? partition.partitionSize : obj.length - 1;
          var offset = partition ? partition.offset : 0;
          return range(offset, offset + len);
        }

        return sortBy(Object.keys(obj), function (p) {
          return p.toLowerCase();
        });
      }, __moduleMeta__$x);

      __varRecorder__$1e.propertyNamesOf = propertyNamesOf;

      var isMultiValue = __varRecorder__$1e["lively.ide/js/inspector/context.js__define__"]("isMultiValue", "function", function (foldableValue, propNames) {
        return !propNames.map(function (p) {
          return foldableValue[p];
        }).every(function (v) {
          return equals(v, foldableValue && foldableValue.valueOf());
        });
      }, __moduleMeta__$x);

      __varRecorder__$1e.isMultiValue = isMultiValue;

      var safePrint = __varRecorder__$1e["lively.ide/js/inspector/context.js__define__"]("safePrint", "function", function (value) {
        var result;

        try {
          result = print(value);
        } catch (err) {}

        try {
          if (!result) {
            result = JSON.stringify(value);
          }
        } catch (err) {}

        if (!result) return "[CANNOT BE DISPLAYED]";
        return result;
      }, __moduleMeta__$x);

      __varRecorder__$1e.safePrint = safePrint;

      var printValue = __varRecorder__$1e["lively.ide/js/inspector/context.js__define__"]("printValue", "function", function (value) {
        var result;
        if (isPrimitive(value)) result = __varRecorder__$1e.safePrint(value);else if (Array.isArray(value)) {
          var tooLong = value.length > 3;
          if (tooLong) value = value.slice(0, 3);

          var printed = __varRecorder__$1e.safePrint(value);

          if (tooLong) printed = printed.slice(0, -1) + ", ...]";
          result = printed;
        } else {
          result = __varRecorder__$1e.safePrint(value);
        }
        result = result.replace(/\n/g, "");
        if (result.length > 500) result = result.slice(0, 20) + "...[".concat(result.length - 20, " CHARS]\"");
        return result;
      }, __moduleMeta__$x);

      __varRecorder__$1e.printValue = printValue;

      var partitionedChildren = __varRecorder__$1e["lively.ide/js/inspector/context.js__define__"]("partitionedChildren", "function", function (arrayOrDict) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref$originalValue = _ref.originalValue,
            originalValue = _ref$originalValue === void 0 ? arrayOrDict : _ref$originalValue,
            _ref$offset = _ref.offset,
            offset = _ref$offset === void 0 ? 0 : _ref$offset,
            _ref$partitionSize = _ref.partitionSize,
            partitionSize = _ref$partitionSize === void 0 ? arrayOrDict.length || Object.values(arrayOrDict).length : _ref$partitionSize;

        if (isArray$2(arrayOrDict)) {
          var newPartitionSize = roundTo(Math.max(__varRecorder__$1e.MIN_PARTITION_SIZE, partitionSize / 50), 0.1);
          var numPartitions = partitionSize / newPartitionSize;
          var partitions = [];

          for (var i = 0; i < numPartitions; i++) {
            var keyString = "[".concat(offset + i * newPartitionSize, "-").concat(offset + (i + 1) * newPartitionSize, "]");
            partitions.push({
              partition: {
                originalValue: originalValue,
                offset: offset + i * newPartitionSize,
                partitionSize: newPartitionSize
              },
              value: [],
              key: keyString,
              keyString: keyString,
              valueString: "...",
              isCollapsed: true
            });
          }

          return partitions;
        } else {
          var _newPartitionSize = roundTo(Math.max(__varRecorder__$1e.MIN_PARTITION_SIZE, partitionSize / 50), 0.1);

          var _numPartitions = partitionSize / _newPartitionSize;

          var _partitions = [];
          var keys = keys$1(originalValue).sort();

          for (var _i = 0; _i < _numPartitions; _i++) {
            var start = offset + _i * _newPartitionSize;
            var end = offset + (_i + 1) * _newPartitionSize;
            var subObj = select(originalValue, keys.slice(start, end));

            var _keyString = "[".concat(keys[start].slice(0, 4), "-").concat((keys[end] || last$2(keys)).slice(0, 4), "]");

            _partitions.push({
              partition: {
                originalValue: subObj,
                offset: offset + _i * _newPartitionSize,
                partitionSize: _newPartitionSize
              },
              value: [],
              key: _keyString,
              keyString: _keyString,
              valueString: "...",
              isCollapsed: true
            });
          }

          return _partitions;
        }
      }, __moduleMeta__$x);

      __varRecorder__$1e.partitionedChildren = partitionedChildren;

      var propertiesOf = __varRecorder__$1e["lively.ide/js/inspector/context.js__define__"]("propertiesOf", "function", function (node) {
        var target = node.partition ? node.target : node.value;
        if (!target) return [];
        var seen = {
          _rev: true
        };
        var props = [];
        var isCollapsed = true;
        var customProps = typeof target.livelyCustomInspect === "function" ? target.livelyCustomInspect() : {};
        var options = Object.assign({}, __varRecorder__$1e.defaultPropertyOptions, {}, customProps);

        if (customProps.properties) {
          var _iterator = _createForOfIteratorHelper(customProps.properties),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _step.value,
                  key = _step$value.key,
                  hidden = _step$value.hidden,
                  priority = _step$value.priority,
                  keyString = _step$value.keyString,
                  value = _step$value.value,
                  valueString = _step$value.valueString;
              seen[key] = true;
              if (hidden) continue;
              props.push(node.getSubNode({
                priority: priority,
                key: key,
                keyString: keyString || __varRecorder__$1e.safeToString(key),
                value: value,
                valueString: valueString,
                isCollapsed: isCollapsed
              }));
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        if (options.includeDefault) {
          var defaultProps = __varRecorder__$1e.propertyNamesOf(target, node.partition);

          if (defaultProps.length > __varRecorder__$1e.MAX_NODE_THRESHOLD) {
            var _iterator2 = _createForOfIteratorHelper(__varRecorder__$1e.partitionedChildren(target, node.partition)),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var nodeArgs = _step2.value;
                props.push(node.getSubNode(nodeArgs));
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          } else {
            var _iterator3 = _createForOfIteratorHelper(defaultProps),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var _key = _step3.value;
                if (_key in seen) continue;
                var _value = target[_key];

                var _valueString = __varRecorder__$1e.printValue(_value);

                var _nodeArgs = {
                  keyString: _key,
                  key: _key,
                  value: _value,
                  valueString: _valueString,
                  isCollapsed: isCollapsed
                };
                props.push(node.getSubNode(_nodeArgs));
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }

          if (options.includeSymbols) {
            var _iterator4 = _createForOfIteratorHelper(Object.getOwnPropertySymbols(target)),
                _step4;

            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var _key2 = _step4.value;

                var _keyString2 = __varRecorder__$1e.safeToString(_key2);

                var _value2 = target[_key2];

                var _valueString2 = __varRecorder__$1e.printValue(_value2);

                var _nodeArgs2 = {
                  key: _key2,
                  keyString: _keyString2,
                  value: _value2,
                  valueString: _valueString2,
                  isCollapsed: isCollapsed
                };
                props.push(node.getSubNode(_nodeArgs2));
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }
        }

        if (options.sort) props = options.sortFunction(target, props);
        return props;
      }, __moduleMeta__$x);

      __varRecorder__$1e.propertiesOf = propertiesOf;
      __varRecorder__$1e.MAX_NODE_THRESHOLD = 1000;
      __varRecorder__$1e.MIN_PARTITION_SIZE = 250;
      __varRecorder__$1e.defaultPropertyOptions = {
        includeDefault: true,
        includeSymbols: true,
        sort: true,
        sortFunction: function sortFunction(target, props) {
          return Array.isArray(target) ? props : props.sort(__varRecorder__$1e.defaultSort);
        }
      };

      __varRecorder__$1e.knownSymbols = function () {
        return Object.getOwnPropertyNames(Symbol).filter(function (ea) {
          return _typeof$1(Symbol[ea]) === "symbol";
        }).reduce(function (map, ea) {
          return map.set(Symbol[ea], "Symbol." + ea);
        }, new Map());
      }();
      __varRecorder__$1e.isMultiValue = isMultiValue;
      __varRecorder__$1e.printValue = printValue;
      var InspectionTree = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/context.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("InspectionTree") && typeof __lively_classholder__.InspectionTree === "function" ? __lively_classholder__.InspectionTree : __lively_classholder__.InspectionTree = function InspectionTree(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function InspectionTree_initialize_(args) {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this, args);
            this.inspector = args.inspector;

            if (!this.root.isInspectionNode) {
              this.root = __varRecorder__$1e.InspectionNode["for"](this.root, this);
            }

            return _this;
          }
        }, {
          key: "__only_serialize__",
          get: function get() {
            return ["root"];
          }
        }, {
          key: "asListWithIndexAndDepth",
          value: function InspectionTree_asListWithIndexAndDepth_() {
            var filtered = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            return initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "asListWithIndexAndDepth", this).call(this, function (_ref2) {
              var node = _ref2.node;
              return filtered ? node.visible : true;
            });
          }
        }, {
          key: "getContextFor",
          value: function InspectionTree_getContextFor_(node) {
            if (node === this.root) return this.root.value.inspectee;
            return node.value;
          }
        }, {
          key: "dispose",
          value: function InspectionTree_dispose_() {}
        }, {
          key: "filter",
          value: function () {
            var _InspectionTree_filter_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref3) {
              var _this2 = this;

              var _ref3$maxDepth, maxDepth, iterator, showUnknown, showInternal;

              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _ref3$maxDepth = _ref3.maxDepth, maxDepth = _ref3$maxDepth === void 0 ? 1 : _ref3$maxDepth, iterator = _ref3.iterator, showUnknown = _ref3.showUnknown, showInternal = _ref3.showInternal;
                      _context.next = 3;
                      return this.uncollapseAll(function (node, depth) {
                        return maxDepth > depth && (node === _this2.root || node.value.submorphs);
                      });

                    case 3:
                      this.asListWithIndexAndDepth(false).forEach(function (_ref4) {
                        var node = _ref4.node,
                            depth = _ref4.depth;
                        if (depth === 0) return node.visible = true;
                        if (!showUnknown && node.keyString && node.keyString.includes("UNKNOWN PROPERTY")) return node.visible = false;
                        if (!showInternal && node.keyString && node.keyString.includes("internal")) return node.visible = false;
                        if (node.value && node.value.submorphs) return node.visible = true;
                        return node.visible = iterator(node);
                      });

                    case 4:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function InspectionTree_filter_(_x) {
              return _InspectionTree_filter_.apply(this, arguments);
            }

            return InspectionTree_filter_;
          }()
        }, {
          key: "getChildren",
          value: function InspectionTree_getChildren_(node) {
            return node.children;
          }
        }, {
          key: "display",
          value: function InspectionTree_display_(node) {
            return node.display(this.inspector);
          }
        }, {
          key: "isCollapsed",
          value: function InspectionTree_isCollapsed_(node) {
            return node.isCollapsed;
          }
        }, {
          key: "isLeaf",
          value: function InspectionTree_isLeaf_(node) {
            return isPrimitive(node.value);
          }
        }, {
          key: "collapse",
          value: function InspectionTree_collapse_(node, bool) {
            var _this3 = this;

            node.isCollapsed = bool;
            if (bool || this.isLeaf(node)) return;

            if (!node.children.length) {
              node.children = __varRecorder__$1e.propertiesOf(node).map(function (n) {
                _this3.parentMap.set(n, node);

                return n;
              });
            }
          }
        }, {
          key: "retrieveForRemoteProxy",
          value: function InspectionTree_retrieveForRemoteProxy_(node) {
            if (!node.uuid) {
              node.uuid = newUUID();
              this.idToNodeMap[node.uuid] = node;
            }

            return {
              uuid: node.uuid,
              value: this.isLeaf(node) ? node.value : {},
              keyString: node.keyString,
              key: node.keyString,
              valueString: __varRecorder__$1e.safeToString(node.value),
              isCollapsed: true,
              children: []
            };
          }
        }, {
          key: "systemInterface",
          get: function get() {
            return localInterface;
          }
        }, {
          key: "getNodeViaId",
          value: function InspectionTree_getNodeViaId_(uuid) {
            return this.idToNodeMap[uuid];
          }
        }, {
          key: "asRemoteDelegate",
          value: function InspectionTree_asRemoteDelegate_(sessionId) {
            this.idToNodeMap = {};
            this.isRemoteDelegate = true;

            if (!System.get("@lively-env").remoteInspectionContext) {
              System.get("@lively-env").remoteInspectionContext = {};
            }

            System.get("@lively-env").remoteInspectionContext[sessionId] = this;
            return this.retrieveForRemoteProxy(this.root);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "InspectionTree";
          }
        }, {
          key: "forObject",
          value: function InspectionTree_forObject_(obj, inspector) {
            return new this({
              key: "inspectee",
              value: {
                inspectee: obj
              },
              isCollapsed: true,
              inspector: inspector
            });
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/inspector/context.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 7948,
          end: 10701
        });
      }({
        referencedAs: "TreeData",
        value: TreeData
      });
      __varRecorder__$1e.InspectionTree = InspectionTree;
      __varRecorder__$1e.InspectionTree = InspectionTree;
      var RemoteInspectionTree = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/context.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("RemoteInspectionTree") && typeof __lively_classholder__.RemoteInspectionTree === "function" ? __lively_classholder__.RemoteInspectionTree : __lively_classholder__.RemoteInspectionTree = function RemoteInspectionTree(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "systemInterface",
          get: function get() {
            return this.evalEnvironment.systemInterface;
          }
        }, {
          key: Symbol["for"]("lively-instance-initialize"),
          value: function RemoteInspectionTree_initialize_(args) {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this, args);
            this.parentMap = new WeakMap();
            this.root = args.proxy;
            this.evalEnvironment = args.evalEnvironment;
            this.inspector = args.inspector;
            this.delegateId = args.delegateId;
            return _this;
          }
        }, {
          key: "getContextFor",
          value: function RemoteInspectionTree_getContextFor_(node) {
            return "System.get('@lively-env').remoteInspectionContext[\"".concat(this.delegateId, "\"].getNodeViaId(\"").concat(node.uuid, "\").value");
          }
        }, {
          key: "dispose",
          value: function () {
            var _RemoteInspectionTree_dispose_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return this.evalEnvironment.systemInterface.runEval("\n      delete System.get('@lively-env').remoteInspectionContext['".concat(this.delegateId, "']\n    "), this.evalEnvironment);

                    case 2:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function RemoteInspectionTree_dispose_() {
              return _RemoteInspectionTree_dispose_.apply(this, arguments);
            }

            return RemoteInspectionTree_dispose_;
          }()
        }, {
          key: "display",
          value: function RemoteInspectionTree_display_(node) {
            return "".concat(node.keyString, ": ").concat(node.valueString);
          }
        }, {
          key: "collapse",
          value: function () {
            var _RemoteInspectionTree_collapse_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(node, bool) {
              var res;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      node.isCollapsed = bool;

                      if (!(bool || this.isLeaf(node))) {
                        _context3.next = 3;
                        break;
                      }

                      return _context3.abrupt("return");

                    case 3:
                      if (node.children.length) {
                        _context3.next = 8;
                        break;
                      }

                      _context3.next = 6;
                      return this.evalEnvironment.systemInterface.runEval("\n         const node = this.getNodeViaId(\"".concat(node.uuid, "\");\n         try {\n           this.collapse(node, false);\n         } catch (e) {\n\n         }\n         node.children.map(n => this.retrieveForRemoteProxy(n));\n      "), {
                        targetModule: "/lively.ide/js/inspector/context.js",
                        context: "System.get('@lively-env').remoteInspectionContext[\"".concat(this.delegateId, "\"]")
                      });

                    case 6:
                      res = _context3.sent;
                      node.children = res.isError ? [] : res.value;

                    case 8:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function RemoteInspectionTree_collapse_(_x2, _x3) {
              return _RemoteInspectionTree_collapse_.apply(this, arguments);
            }

            return RemoteInspectionTree_collapse_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "RemoteInspectionTree";
          }
        }, {
          key: "forObject",
          value: function () {
            var _RemoteInspectionTree_forObject_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(target, inspector) {
              var _yield$this$createRem, proxy, delegateId, evalEnvironment;

              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      _context4.next = 2;
                      return this.createRemoteContext(target, inspector);

                    case 2:
                      _yield$this$createRem = _context4.sent;
                      proxy = _yield$this$createRem.proxy;
                      delegateId = _yield$this$createRem.delegateId;
                      evalEnvironment = _yield$this$createRem.evalEnvironment;
                      return _context4.abrupt("return", new this({
                        key: "inspectee",
                        proxy: proxy,
                        delegateId: delegateId,
                        evalEnvironment: evalEnvironment,
                        inspector: inspector
                      }));

                    case 7:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function RemoteInspectionTree_forObject_(_x4, _x5) {
              return _RemoteInspectionTree_forObject_.apply(this, arguments);
            }

            return RemoteInspectionTree_forObject_;
          }()
        }, {
          key: "createRemoteContext",
          value: function () {
            var _RemoteInspectionTree_createRemoteContext_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref5, inspector) {
              var code, evalEnvironment, delegateId, _yield$evalEnvironmen, proxy;

              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      code = _ref5.code, evalEnvironment = _ref5.evalEnvironment, delegateId = _ref5.delegateId;

                      delegateId = "lively://inspector-".concat(inspector.id);
                      _context5.next = 5;
                      return evalEnvironment.systemInterface.runEval("\n       const { InspectionTree } = await System.import(\"lively.ide/js/inspector/context.js\");\n       const t = (() => ".concat(code, ")();\n       const tree = InspectionTree.forObject(t);\n       tree.asRemoteDelegate(\"").concat(delegateId, "\");\n    "), evalEnvironment);

                    case 5:
                      _yield$evalEnvironmen = _context5.sent;
                      proxy = _yield$evalEnvironmen.value;
                      return _context5.abrupt("return", {
                        delegateId: delegateId,
                        evalEnvironment: evalEnvironment,
                        proxy: proxy
                      });

                    case 8:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5);
            }));

            function RemoteInspectionTree_createRemoteContext_(_x6, _x7) {
              return _RemoteInspectionTree_createRemoteContext_.apply(this, arguments);
            }

            return RemoteInspectionTree_createRemoteContext_;
          }()
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/inspector/context.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 10710,
          end: 13080
        });
      }(__varRecorder__$1e.InspectionTree);
      __varRecorder__$1e.RemoteInspectionTree = RemoteInspectionTree;
      __varRecorder__$1e.RemoteInspectionTree = RemoteInspectionTree;

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/context.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("InspectionNode") && typeof __lively_classholder__.InspectionNode === "function" ? __lively_classholder__.InspectionNode : __lively_classholder__.InspectionNode = function InspectionNode(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function InspectionNode_initialize_(_ref6) {
            var root = _ref6.root,
                priority = _ref6.priority,
                key = _ref6.key,
                keyString = _ref6.keyString,
                value = _ref6.value,
                valueString = _ref6.valueString,
                isCollapsed = _ref6.isCollapsed,
                _ref6$children = _ref6.children,
                children = _ref6$children === void 0 ? [] : _ref6$children,
                _ref6$isSelected = _ref6.isSelected,
                isSelected = _ref6$isSelected === void 0 ? false : _ref6$isSelected,
                _ref6$visible = _ref6.visible,
                visible = _ref6$visible === void 0 ? true : _ref6$visible,
                partition = _ref6.partition;
            this.partition = partition;
            this.priority = priority;
            this.key = key;
            this.keyString = String(keyString || key);
            this.value = value;
            this.valueString = valueString || __varRecorder__$1e.printValue(value);
            this.isCollapsed = isCollapsed;
            this.children = children;
            this.isSelected = isSelected;
            this.visible = visible;
            this.root = root;
          }
        }, {
          key: "__only_serialize__",
          get: function get() {
            return [];
          }
        }, {
          key: "isInspectionNode",
          get: function get() {
            return true;
          }
        }, {
          key: "getSubNode",
          value: function InspectionNode_getSubNode_(node) {
            if (node.value && node.value.isMorph) {
              return new __varRecorder__$1e.MorphNode(Object.assign({
                root: this.root
              }, node));
            }

            var key = node.key,
                keyString = node.keyString;
            var target = this.value;
            var partition = node.partition;

            if (partition) {
              target = partition.originalValue;
              keyString = key;
            }

            return new __varRecorder__$1e.PropertyNode(Object.assign({}, node, {
              keyString: keyString,
              key: key,
              target: target,
              partition: partition,
              root: this.root,
              spec: {}
            }));
          }
        }, {
          key: "display",
          value: function InspectionNode_display_(inspector) {
            var keyString = this.keyString,
                valueString = this.valueString;
            if (keyString === "owner") keyString = "  owner";
            if (!this.interactive) return "".concat(keyString, ": ").concat(valueString);

            if (!this._propertyWidget) {
              this._propertyWidget = inspector.renderDraggableTreeLabel({
                value: "".concat(keyString, ": ").concat(valueString)
              });
            }

            this._propertyWidget.isSelected = this.isSelected;
            return this._propertyWidget;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "InspectionNode";
          }
        }, {
          key: "for",
          value: function InspectionNode_for_(node) {
            var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            if (node.value && node.value.isMorph) return new __varRecorder__$1e.MorphNode(Object.assign({
              root: root
            }, node));
            return new __varRecorder__$1e.InspectionNode(Object.assign({
              root: root
            }, node));
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/inspector/context.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 13082,
          end: 15764
        });
      })(undefined);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/context.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("MorphNode") && typeof __lively_classholder__.MorphNode === "function" ? __lively_classholder__.MorphNode : __lively_classholder__.MorphNode = function MorphNode(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function MorphNode_initialize_(args) {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this, args);
            this.target = this.value;
            this.propertyInfo = this.target.propertiesAndPropertySettings().properties;
            return _this;
          }
        }, {
          key: "getSubNode",
          value: function MorphNode_getSubNode_(nodeArgs) {
            var spec = this.propertyInfo[nodeArgs.key] || {};

            if (nodeArgs.value && nodeArgs.value.isMorph) {
              return new __varRecorder__$1e.MorphNode(Object.assign({}, nodeArgs, {
                root: this.root
              }));
            }

            return new __varRecorder__$1e.PropertyNode(Object.assign({}, nodeArgs, {
              root: this.root,
              target: this.target,
              spec: spec
            }));
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "MorphNode";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/inspector/context.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 15766,
          end: 17003
        });
      })(__varRecorder__$1e.InspectionNode);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/context.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PropertyNode") && typeof __lively_classholder__.PropertyNode === "function" ? __lively_classholder__.PropertyNode : __lively_classholder__.PropertyNode = function PropertyNode(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function PropertyNode_initialize_(args) {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this, args);
            var partition = args.partition,
                spec = args.spec,
                target = args.target;
            this.partition = partition;
            this.target = target;
            this.spec = spec;
            this.foldedNodes = {};
            return _this;
          }
        }, {
          key: "__deserialize__",
          value: function PropertyNode___deserialize___() {
            this.spec = {};
          }
        }, {
          key: "interactive",
          get: function get() {
            return this._interactive;
          }
        }, {
          key: "interactive",
          set: function set(b) {
            this._interactive = b;
          }
        }, {
          key: "isFoldable",
          get: function get() {
            return !!this.spec.foldable;
          }
        }, {
          key: "isInternalProperty",
          get: function get() {
            return this.keyString === "id" || this.keyString.includes("internal");
          }
        }, {
          key: "getSubNode",
          value: function PropertyNode_getSubNode_(nodeArgs) {
            if (this.isFoldable) {
              return this.getFoldedContext(nodeArgs);
            }

            return initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "getSubNode", this).call(this, nodeArgs);
          }
        }, {
          key: "getFoldedContext",
          value: function PropertyNode_getFoldedContext_(node) {
            return this.foldedNodes[node.key] = new __varRecorder__$1e.FoldedNode(Object.assign({}, node, {
              root: this.root,
              target: this.target,
              foldableNode: this,
              spec: dissoc(this.spec, ["foldable"])
            }));
          }
        }, {
          key: "rerender",
          value: function PropertyNode_rerender_() {
            this.root.inspector.refreshSelectedLine();
          }
        }, {
          key: "refreshProperty",
          value: function PropertyNode_refreshProperty_(v) {
            var updateTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            if (updateTarget) this.target[this.key] = v;
            this.value = this.target[this.key];
            this.valueString = __varRecorder__$1e.printValue(this.value);

            if (this.interactive) {
              if (!updateTarget) {
                this._propertyWidget.highlight();
              }
            }

            if (this.isFoldable) {
              for (var m in this.foldedNodes) {
                this.foldedNodes[m].value = this.value[m];
                this.foldedNodes[m].valueString = __varRecorder__$1e.printValue(this.value[m]);
                this.foldedNodes[m]._propertyWidget && signal(this.foldedNodes[m]._propertyWidget, "update", this.value[m]);
              }
            }
          }
        }, {
          key: "display",
          value: function PropertyNode_display_(inspector) {
            var w = this._propertyWidget,
                keyString = this.keyString,
                valueString = this.valueString,
                target = this.target,
                value = this.value,
                spec = this.spec;

            if (!this.interactive && !(spec.foldable && __varRecorder__$1e.isMultiValue(value, spec.foldable))) {
              return inspector.renderPropertyControl({
                target: target,
                keyString: keyString,
                valueString: valueString,
                tree: inspector.ui.propertyTree,
                value: value,
                spec: spec,
                node: this,
                fastRender: true
              });
            }

            if (w) {
              w.keyString = keyString;
              w.valueString = valueString;
              w.isSelected = this.isSelected;
              w.control && (w.control.isSelected = this.isSelected);
              return w;
            }

            w = this._propertyWidget = inspector.renderPropertyControl({
              target: target,
              keyString: keyString,
              valueString: valueString,
              value: value,
              spec: spec,
              node: this,
              isSelected: this.isSelected,
              fontColor: inspector.ui.propertyTree.fontColor
            });

            if (!this.isInternalProperty && !spec.readOnly) {
              connect(w, "propertyValue", this, "refreshProperty", {
                updater: function updater($upd, val) {
                  return $upd(val, true);
                }
              });
            }

            return w;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PropertyNode";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/inspector/context.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 17005,
          end: 20391
        });
      })(__varRecorder__$1e.InspectionNode);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/context.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("FoldedNode") && typeof __lively_classholder__.FoldedNode === "function" ? __lively_classholder__.FoldedNode : __lively_classholder__.FoldedNode = function FoldedNode(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function FoldedNode_initialize_(args) {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this, args);
            var foldableNode = args.foldableNode;
            this.foldableNode = foldableNode;
            this.foldedProp = foldableNode.key + capitalize(this.key);
            return _this;
          }
        }, {
          key: "refreshProperty",
          value: function FoldedNode_refreshProperty_(v) {
            var updateTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            this.foldableNode.refreshProperty(Object.assign({}, this.target[this.foldableNode.key], _defineProperty({}, this.key, v)), updateTarget);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "FoldedNode";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/inspector/context.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 20393,
          end: 21075
        });
      })(__varRecorder__$1e.PropertyNode);

      var PropertyTree = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/context.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PropertyTree") && typeof __lively_classholder__.PropertyTree === "function" ? __lively_classholder__.PropertyTree : __lively_classholder__.PropertyTree = function PropertyTree(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onDrag",
          value: function PropertyTree_onDrag_(evt) {
            if (this._onDragHandler) this._onDragHandler(evt);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PropertyTree";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/inspector/context.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 21084,
          end: 21195
        });
      }({
        referencedAs: "Tree",
        value: Tree
      });
      __varRecorder__$1e.PropertyTree = PropertyTree;
      __varRecorder__$1e.PropertyTree = PropertyTree;

      var __varRecorder__$1d = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/themes/dark.js", __contextModule__);

      var DarkTheme = exports('a7', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/themes/dark.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DarkTheme") && typeof __lively_classholder__.DarkTheme === "function" ? __lively_classholder__.DarkTheme : __lively_classholder__.DarkTheme = function DarkTheme(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "background",
          get: function get() {
            return Color.rgb(44, 62, 80);
          }
        }, {
          key: "cursorColor",
          get: function get() {
            return Color.gray;
          }
        }, {
          key: "default",
          get: function get() {
            return {
              fontColor: "#abb2bf"
            };
          }
        }, {
          key: "header",
          get: function get() {
            return {
              fontSize: "110%",
              fontColor: "#6b94ee"
            };
          }
        }, {
          key: "header-1",
          get: function get() {
            return {
              fontSize: "135%",
              fontColor: "#6b94ee"
            };
          }
        }, {
          key: "header-2",
          get: function get() {
            return {
              fontSize: "125%",
              fontColor: "#6b94be"
            };
          }
        }, {
          key: "header-3",
          get: function get() {
            return {
              fontSize: "120%",
              fontColor: "#6b94be"
            };
          }
        }, {
          key: "quote",
          get: function get() {
            return {
              fontColor: "#090"
            };
          }
        }, {
          key: "negative",
          get: function get() {
            return {
              fontColor: "#d44"
            };
          }
        }, {
          key: "positive",
          get: function get() {
            return {
              fontColor: "#292"
            };
          }
        }, {
          key: "strong",
          get: function get() {
            return {
              fontWeight: "bold"
            };
          }
        }, {
          key: "em",
          get: function get() {
            return {
              fontStyle: "italic"
            };
          }
        }, {
          key: "strikethrough",
          get: function get() {
            return {
              textDecoration: "line-through"
            };
          }
        }, {
          key: "hr",
          get: function get() {
            return {
              fontColor: "#999"
            };
          }
        }, {
          key: "link",
          get: function get() {
            return {
              textDecoration: "underline",
              fontColor: "#2c2cff"
            };
          }
        }, {
          key: "url",
          get: function get() {
            return {
              textDecoration: "underline",
              fontColor: "#2c2cff"
            };
          }
        }, {
          key: "keyword",
          get: function get() {
            return {
              fontColor: Color.rgb(204, 109, 243)
            };
          }
        }, {
          key: "atom",
          get: function get() {
            return {
              fontColor: "#d19a66"
            };
          }
        }, {
          key: "number",
          get: function get() {
            return {
              fontColor: Color.orange
            };
          }
        }, {
          key: "def",
          get: function get() {
            return {
              fontColor: "#e5c07b"
            };
          }
        }, {
          key: "variable",
          get: function get() {
            return {
              fontColor: "#d19a66"
            };
          }
        }, {
          key: "punctuation",
          get: function get() {
            return {
              fontColor: "#05a"
            };
          }
        }, {
          key: "property",
          get: function get() {
            return {
              fontColor: Color.rgb(33, 150, 243)
            };
          }
        }, {
          key: "operator",
          get: function get() {
            return {
              fontColor: "#abb2bf"
            };
          }
        }, {
          key: "variable-2",
          get: function get() {
            return {
              fontColor: "#e06c75"
            };
          }
        }, {
          key: "variable-3",
          get: function get() {
            return {
              fontColor: "#085"
            };
          }
        }, {
          key: "comment",
          get: function get() {
            return {
              fontColor: "#7F848E"
            };
          }
        }, {
          key: "commentHighlight",
          get: function get() {
            return {
              backgroundColor: "#FFFF00",
              fontColor: "#7F848E"
            };
          }
        }, {
          key: "string",
          get: function get() {
            return {
              fontColor: "#98c378"
            };
          }
        }, {
          key: "string-2",
          get: function get() {
            return {
              fontColor: "#98c378"
            };
          }
        }, {
          key: "meta",
          get: function get() {
            return {
              fontColor: "#555"
            };
          }
        }, {
          key: "qualifier",
          get: function get() {
            return {
              fontColor: "#d19a66"
            };
          }
        }, {
          key: "builtin",
          get: function get() {
            return {
              fontColor: "#30a"
            };
          }
        }, {
          key: "bracket",
          get: function get() {
            return {
              fontColor: "#515a6b"
            };
          }
        }, {
          key: "brace",
          get: function get() {
            return {
              fontColor: "#abb2bf"
            };
          }
        }, {
          key: "tag",
          get: function get() {
            return {
              fontColor: "#170"
            };
          }
        }, {
          key: "attribute",
          get: function get() {
            return {
              fontColor: "#d19a66"
            };
          }
        }, {
          key: "error",
          get: function get() {
            return {
              backgroundColor: Color.rgba(255, 76, 76, 0.8)
            };
          }
        }, {
          key: "invalidchar",
          get: function get() {
            return {
              backgroundColor: "#ff4c4c"
            };
          }
        }, {
          key: "warning",
          get: function get() {
            return {
              "border-bottom": "2px dotted orange"
            };
          }
        }, {
          key: "diff-file-header",
          get: function get() {
            return {
              fontColor: Color.white,
              fontWeight: "bold",
              backgroundColor: Color.rgba(136, 136, 136, 0.7)
            };
          }
        }, {
          key: "diff-hunk-header",
          get: function get() {
            return {
              backgroundColor: Color.rgba(204, 204, 204, 0.4),
              fontWeight: "bold"
            };
          }
        }, {
          key: "coord",
          get: function get() {
            return {
              backgroundColor: Color.rgba(204, 204, 204, 0.4),
              fontWeight: "bold"
            };
          }
        }, {
          key: "inserted",
          get: function get() {
            return {
              backgroundColor: "rgba(108,255,108, .3)"
            };
          }
        }, {
          key: "deleted",
          get: function get() {
            return {
              backgroundColor: "rgba(255,108,108, .3)"
            };
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DarkTheme";
          }
        }, {
          key: "instance",
          get: function get() {
            return this._instance || (this._instance = new this());
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./themes/dark.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 42,
          end: 3156
        });
      }(undefined));
      __varRecorder__$1d["default"] = DarkTheme;

      var __varRecorder__$1c = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/themes/default.js", __contextModule__);

      var DefaultTheme = exports('a6', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/themes/default.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DefaultTheme") && typeof __lively_classholder__.DefaultTheme === "function" ? __lively_classholder__.DefaultTheme : __lively_classholder__.DefaultTheme = function DefaultTheme(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "background",
          get: function get() {
            return Color.white;
          }
        }, {
          key: "default",
          get: function get() {
            return {
              fontColor: "#333"
            };
          }
        }, {
          key: "header",
          get: function get() {
            return {
              fontSize: "110%",
              fontColor: "#6b94ee"
            };
          }
        }, {
          key: "header-1",
          get: function get() {
            return {
              fontSize: "135%",
              fontColor: "#6b94ee"
            };
          }
        }, {
          key: "header-2",
          get: function get() {
            return {
              fontSize: "125%",
              fontColor: "#6b94be"
            };
          }
        }, {
          key: "header-3",
          get: function get() {
            return {
              fontSize: "120%",
              fontColor: "#6b94be"
            };
          }
        }, {
          key: "quote",
          get: function get() {
            return {
              fontColor: "#090"
            };
          }
        }, {
          key: "negative",
          get: function get() {
            return {
              fontColor: "#d44"
            };
          }
        }, {
          key: "positive",
          get: function get() {
            return {
              fontColor: "#292"
            };
          }
        }, {
          key: "strong",
          get: function get() {
            return {
              fontWeight: "bold"
            };
          }
        }, {
          key: "em",
          get: function get() {
            return {
              fontStyle: "italic"
            };
          }
        }, {
          key: "strikethrough",
          get: function get() {
            return {
              textDecoration: "line-through"
            };
          }
        }, {
          key: "hr",
          get: function get() {
            return {
              fontColor: "#999"
            };
          }
        }, {
          key: "link",
          get: function get() {
            return {
              textDecoration: "underline",
              fontColor: "#2c2cff"
            };
          }
        }, {
          key: "url",
          get: function get() {
            return {
              textDecoration: "underline",
              fontColor: "#2c2cff"
            };
          }
        }, {
          key: "keyword",
          get: function get() {
            return {
              fontColor: "#708"
            };
          }
        }, {
          key: "atom",
          get: function get() {
            return {
              fontColor: "#219"
            };
          }
        }, {
          key: "number",
          get: function get() {
            return {
              fontColor: "#174"
            };
          }
        }, {
          key: "def",
          get: function get() {
            return {
              fontColor: "#22c"
            };
          }
        }, {
          key: "variable",
          get: function get() {
            return {
              fontColor: "#05a"
            };
          }
        }, {
          key: "punctuation",
          get: function get() {
            return {
              fontColor: "#05a"
            };
          }
        }, {
          key: "property",
          get: function get() {
            return {
              fontColor: "#222"
            };
          }
        }, {
          key: "operator",
          get: function get() {
            return {
              fontColor: "#05a"
            };
          }
        }, {
          key: "variable-2",
          get: function get() {
            return {
              fontColor: "#05a"
            };
          }
        }, {
          key: "variable-3",
          get: function get() {
            return {
              fontColor: "#085"
            };
          }
        }, {
          key: "comment",
          get: function get() {
            return {
              fontColor: "#666"
            };
          }
        }, {
          key: "commentHighlight",
          get: function get() {
            return {
              backgroundColor: "#FFFF00",
              fontColor: "#666"
            };
          }
        }, {
          key: "string",
          get: function get() {
            return {
              fontColor: "#181"
            };
          }
        }, {
          key: "string-2",
          get: function get() {
            return {
              fontColor: "#0B2"
            };
          }
        }, {
          key: "meta",
          get: function get() {
            return {
              fontColor: "#555"
            };
          }
        }, {
          key: "qualifier",
          get: function get() {
            return {
              fontColor: "#555"
            };
          }
        }, {
          key: "builtin",
          get: function get() {
            return {
              fontColor: "#30a"
            };
          }
        }, {
          key: "bracket",
          get: function get() {
            return {
              fontColor: "#997"
            };
          }
        }, {
          key: "tag",
          get: function get() {
            return {
              fontColor: "#170"
            };
          }
        }, {
          key: "attribute",
          get: function get() {
            return {
              fontColor: "#333"
            };
          }
        }, {
          key: "error",
          get: function get() {
            return {
              backgroundColor: Color.rgba(255, 76, 76, 0.53)
            };
          }
        }, {
          key: "invalidchar",
          get: function get() {
            return {
              backgroundColor: Color.rgba(255, 76, 76, 0.53)
            };
          }
        }, {
          key: "warning",
          get: function get() {
            return {
              "border-bottom": "2px dotted orange"
            };
          }
        }, {
          key: "diff-file-header",
          get: function get() {
            return {
              fontColor: Color.white,
              fontWeight: "bold",
              backgroundColor: Color.rgba(136, 136, 136, 0.7)
            };
          }
        }, {
          key: "diff-hunk-header",
          get: function get() {
            return {
              backgroundColor: Color.rgba(204, 204, 204, 0.4),
              fontWeight: "bold"
            };
          }
        }, {
          key: "coord",
          get: function get() {
            return {
              backgroundColor: Color.rgba(204, 204, 204, 0.4),
              fontWeight: "bold"
            };
          }
        }, {
          key: "inserted",
          get: function get() {
            return {
              backgroundColor: "rgba(108,255,108, .3)"
            };
          }
        }, {
          key: "deleted",
          get: function get() {
            return {
              backgroundColor: "rgba(255,108,108, .3)"
            };
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DefaultTheme";
          }
        }, {
          key: "instance",
          get: function get() {
            return this._instance || (this._instance = new this());
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./themes/default.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 42,
          end: 2993
        });
      }(undefined));
      __varRecorder__$1c["default"] = DefaultTheme;

      var __varRecorder__$1b = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/drag-guides.js", __contextModule__);
      var __moduleMeta__$w = {
        pathInPackage: function pathInPackage() {
          return "./drag-guides.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.halos",
            version: "0.1.0"
          };
        }
      };

      var removeSnapToGuidesOf = exports('r', __varRecorder__$1b["lively.halos/drag-guides.js__define__"]("removeSnapToGuidesOf", "function", function (target) {
        var dragGuides = __varRecorder__$1b.cachedGuideLines.get(target);

        if (!dragGuides) return;
        dragGuides.forEach(function (ea) {
          return ea.remove();
        });
      }, __moduleMeta__$w));

      __varRecorder__$1b.removeSnapToGuidesOf = removeSnapToGuidesOf;

      var computeRefPoints = __varRecorder__$1b["lively.halos/drag-guides.js__define__"]("computeRefPoints", "function", function (bounds) {
        var left = bounds.x,
            top = bounds.y,
            width = bounds.width,
            height = bounds.height;
        var hCenter = left + width / 2;
        var vCenter = top + height / 2;
        var right = left + width;
        var bottom = top + height;
        return {
          left: left,
          top: top,
          hCenter: hCenter,
          vCenter: vCenter,
          right: right,
          bottom: bottom,
          width: width,
          height: height
        };
      }, __moduleMeta__$w);

      __varRecorder__$1b.computeRefPoints = computeRefPoints;

      var closest = __varRecorder__$1b["lively.halos/drag-guides.js__define__"]("closest", "function", function (i, morphs, refPoints, lefts, rights, tops, bottoms) {
        var overlappingProjected = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;
        var l = lefts[i];
        var r = rights[i];
        var t = tops[i];
        var b = bottoms[i];
        var closestL;
        var closestR;
        var closestT;
        var closestB;

        for (var j = 0; j < rights.length; j++) {
          if (i === j || l < rights[j] || closestL && rights[closestL.index] >= rights[j]) continue;
          if (overlappingProjected && bottoms[i] < tops[j] || tops[i] > bottoms[j]) continue;
          closestL = {
            index: j,
            dist: l - rights[j],
            refPointsA: refPoints[i],
            refPointsB: refPoints[j]
          };
        }

        for (var _j = 0; _j < lefts.length; _j++) {
          if (i === _j || r > lefts[_j] || closestR && lefts[closestR.index] <= lefts[_j]) continue;
          if (overlappingProjected && bottoms[i] < tops[_j] || tops[i] > bottoms[_j]) continue;
          closestR = {
            index: _j,
            dist: lefts[_j] - r,
            refPointsA: refPoints[i],
            refPointsB: refPoints[_j]
          };
        }

        for (var _j2 = 0; _j2 < bottoms.length; _j2++) {
          if (i === _j2 || t < bottoms[_j2] || closestT && bottoms[closestT.index] >= bottoms[_j2]) continue;
          if (overlappingProjected && lefts[i] > rights[_j2] || rights[i] < lefts[_j2]) continue;
          closestT = {
            index: _j2,
            dist: t - bottoms[_j2],
            refPointsA: refPoints[i],
            refPointsB: refPoints[_j2]
          };
        }

        for (var _j3 = 0; _j3 < tops.length; _j3++) {
          if (i === _j3 || b > tops[_j3] || closestB && tops[closestB.index] <= tops[_j3]) continue;
          if (overlappingProjected && lefts[i] > rights[_j3] || rights[i] < lefts[_j3]) continue;
          closestB = {
            index: _j3,
            dist: tops[_j3] - b,
            refPointsA: refPoints[i],
            refPointsB: refPoints[_j3]
          };
        }

        return {
          l: closestL,
          r: closestR,
          t: closestT,
          b: closestB
        };
      }, __moduleMeta__$w);

      __varRecorder__$1b.closest = closest;

      var computeClosestMorphs = __varRecorder__$1b["lively.halos/drag-guides.js__define__"]("computeClosestMorphs", "function", function (morphs) {
        var lefts = [];
        var rights = [];
        var tops = [];
        var bottoms = [];
        var refPoints = [];
        var result = [];

        for (var i = 0; i < morphs.length; i++) {
          var m = morphs[i];

          var rps = __varRecorder__$1b.computeRefPoints(m.bounds());

          refPoints.push(rps);
          var left = rps.left,
              right = rps.right,
              top = rps.top,
              bottom = rps.bottom;
          lefts.push(left);
          rights.push(right);
          tops.push(top);
          bottoms.push(bottom);
        }

        for (var _i = 0; _i < morphs.length; _i++) {
          result.push(__varRecorder__$1b.closest(_i, morphs, refPoints, lefts, rights, tops, bottoms));
        }

        return result;
      }, __moduleMeta__$w);

      __varRecorder__$1b.computeClosestMorphs = computeClosestMorphs;

      var findEdgesInAlignment = __varRecorder__$1b["lively.halos/drag-guides.js__define__"]("findEdgesInAlignment", "function", function (refPointsA, refPointsB) {
        var eps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 15;
        var fromEdges = arguments.length > 3 ? arguments[3] : undefined;
        var toEdges = arguments.length > 4 ? arguments[4] : undefined;
        var distLeft = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        var distTop = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
        var distRight = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
        var distBottom = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
        var maxDist = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
        var vertical = [];
        var horizontal = [];

        for (var i = 0; i < __varRecorder__$1b.edges.length; i++) {
          var _varRecorder__$edges = _slicedToArray(__varRecorder__$1b.edges[i], 3),
              type = _varRecorder__$edges[0],
              edgeA = _varRecorder__$edges[1],
              edgeB = _varRecorder__$edges[2];

          var edgeAVal = refPointsA[edgeA];
          var edgeBVal = refPointsB[edgeB];
          var delta = Math.max(edgeAVal, edgeBVal) - Math.min(edgeAVal, edgeBVal);
          if (delta > eps) continue;
          if (fromEdges && !fromEdges.includes(edgeA)) continue;
          if (toEdges && !toEdges.includes(edgeB)) continue;
          var result = type === "vertical" ? vertical : horizontal;
          result.push({
            delta: delta,
            edgeA: edgeA,
            edgeB: edgeB,
            edgeAVal: edgeAVal,
            edgeBVal: edgeBVal,
            refPointsA: refPointsA,
            refPointsB: refPointsB,
            distLeft: distLeft,
            distTop: distTop,
            distRight: distRight,
            distBottom: distBottom,
            maxDist: maxDist
          });
        }

        return vertical.length || horizontal.length ? {
          vertical: vertical,
          horizontal: horizontal
        } : null;
      }, __moduleMeta__$w);

      __varRecorder__$1b.findEdgesInAlignment = findEdgesInAlignment;

      var findAlignedMorphs = __varRecorder__$1b["lively.halos/drag-guides.js__define__"]("findAlignedMorphs", "function", function (refMorph, submorphs) {
        var eps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 15;
        var distCutoff = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;
        var fromEdges = arguments.length > 4 ? arguments[4] : undefined;
        var toEdges = arguments.length > 5 ? arguments[5] : undefined;
        var result;

        var refPoints = __varRecorder__$1b.computeRefPoints(refMorph.bounds());

        for (var i = 0; i < submorphs.length; i++) {
          var m = submorphs[i];
          if (m === refMorph) continue;

          var refPointsM = __varRecorder__$1b.computeRefPoints(m.bounds());

          var distLeft = Math.max(0, refPoints.left - refPointsM.right);
          var distRight = Math.max(0, refPointsM.left - refPoints.right);
          var distTop = Math.max(0, refPoints.top - refPointsM.bottom);
          var distBottom = Math.max(0, refPointsM.top - refPoints.bottom);
          var maxDist = Math.max(distBottom, distTop, distRight, distLeft);
          if (Math.max(distBottom, distTop, distRight, distLeft) > distCutoff) continue;

          var found = __varRecorder__$1b.findEdgesInAlignment(refPoints, refPointsM, eps, fromEdges, toEdges, distLeft, distTop, distRight, distBottom, maxDist);

          if (!found) continue;
          if (!result) result = new Map();
          result.set(m, found);
        }

        {
          var owner = refMorph.owner;

          var refPointsO = __varRecorder__$1b.computeRefPoints(owner.innerBounds());

          var _found = __varRecorder__$1b.findEdgesInAlignment(refPoints, refPointsO, eps);

          if (_found) {
            if (!result) result = new Map();
            result.set(owner, _found);
          }
        }
        return result;
      }, __moduleMeta__$w);

      __varRecorder__$1b.findAlignedMorphs = findAlignedMorphs;

      var showAndSnapToGuides = exports('d', __varRecorder__$1b["lively.halos/drag-guides.js__define__"]("showAndSnapToGuides", "function", function (target) {
        var showGuides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var snap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var eps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
        var maxDist = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 100;
        if (!showGuides && !snap || !target.owner) return;
        var owner = target.owner;
        var world = owner.world();
        var tfm = owner.getGlobalTransform();
        var morphsForGuides = target.owner.submorphs.filter(function (ea) {
          return ea !== target && !ea.isEpiMorph && ea.visible && ea.reactsToPointer;
        });
        var fromEdges = ["left", "top", "right", "bottom", "hCenter", "vCenter"];
        var toEdges = ["left", "top", "right", "bottom", "hCenter", "vCenter"];

        var aligned = __varRecorder__$1b.findAlignedMorphs(target, morphsForGuides, eps, maxDist, fromEdges, toEdges);

        var guideSpecs = [];
        var maxHPriority = 0;
        var maxVPriority = 0;
        var dragOffsetX = 0;
        var dragOffsetY = 0;
        tfm.e -= world.scroll.x;
        tfm.f -= world.scroll.y;

        if (aligned) {
          var _iterator = _createForOfIteratorHelper(aligned),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray(_step.value, 2),
                  _ = _step$value[0],
                  _step$value$ = _step$value[1],
                  horizontal = _step$value$.horizontal,
                  vertical = _step$value$.vertical;

              var _iterator2 = _createForOfIteratorHelper(horizontal),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var _step2$value = _step2.value,
                      delta = _step2$value.delta,
                      edgeAVal = _step2$value.edgeAVal,
                      refPointsA = _step2$value.refPointsA,
                      refPointsB = _step2$value.refPointsB,
                      edgeBVal = _step2$value.edgeBVal,
                      _maxDist = _step2$value.maxDist;
                  var priority = Math.ceil(eps - delta);
                  var top = Math.min(refPointsA.top, refPointsB.top);
                  var bottom = Math.max(refPointsA.bottom, refPointsB.bottom);
                  if (_maxDist > eps) priority -= eps / 2;

                  if (maxHPriority < priority) {
                    maxHPriority = priority;
                    dragOffsetX = edgeBVal - edgeAVal;
                  }

                  guideSpecs.push({
                    type: "line",
                    epiMorph: true,
                    hasFixedPosition: true,
                    height: __varRecorder__$1b.guideWidth,
                    start: tfm.transformPoint(pt(edgeBVal, top)),
                    end: tfm.transformPoint(pt(edgeBVal, bottom)),
                    fill: __varRecorder__$1b.guideColor,
                    guideType: "h",
                    priority: priority
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }

              var _iterator3 = _createForOfIteratorHelper(vertical),
                  _step3;

              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var _step3$value = _step3.value,
                      _delta = _step3$value.delta,
                      _edgeAVal = _step3$value.edgeAVal,
                      _refPointsA = _step3$value.refPointsA,
                      _refPointsB = _step3$value.refPointsB,
                      _edgeBVal = _step3$value.edgeBVal,
                      _maxDist2 = _step3$value.maxDist;

                  var _priority = Math.ceil(eps - _delta);

                  var left = Math.min(_refPointsA.left, _refPointsB.left);
                  var right = Math.max(_refPointsA.right, _refPointsB.right);
                  if (_maxDist2 > eps) _priority -= eps / 2;

                  if (maxVPriority < _priority && Math.abs(_edgeBVal - _edgeAVal) <= eps) {
                    maxVPriority = _priority;
                    dragOffsetY = _edgeBVal - _edgeAVal;
                  }

                  guideSpecs.push({
                    type: "line",
                    epiMorph: true,
                    hasFixedPosition: true,
                    height: __varRecorder__$1b.guideWidth,
                    start: tfm.transformPoint(pt(left, _edgeBVal)),
                    end: tfm.transformPoint(pt(right, _edgeBVal)),
                    fill: __varRecorder__$1b.guideColor,
                    guideType: "v",
                    priority: _priority
                  });
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        if (!maxHPriority || !maxVPriority) {
          var morphs = [target].concat(_toConsumableArray$1(morphsForGuides));

          var _closest = __varRecorder__$1b.computeClosestMorphs(morphs);

          var targetRefPoints;
          var _closest$ = _closest[0],
              targetL = _closest$.l,
              targetR = _closest$.r,
              targetT = _closest$.t,
              targetB = _closest$.b;
          var foundSimilarDist;

          if (targetL || targetR || targetT || targetB) {
            targetRefPoints = (targetL || targetR || targetT || targetB).refPointsA;

            for (var i = 1; i < _closest.length; i++) {
              var _closest$i = _closest[i],
                  l = _closest$i.l,
                  r = _closest$i.r,
                  t = _closest$i.t,
                  b = _closest$i.b;

              if (!maxHPriority) {
                if (targetL && l && targetL.index !== l.index && Math.abs(l.dist - targetL.dist) <= eps) foundSimilarDist = Object.assign({
                  neighbor: i,
                  direction: "left"
                }, l);else if (targetR && r && targetR !== r.index && Math.abs(r.dist - targetR.dist) <= eps) foundSimilarDist = Object.assign({
                  neighbor: i,
                  direction: "right"
                }, r);
              }

              if (!maxVPriority) {
                if (targetT && t && targetT.index !== t.index && Math.abs(t.dist - targetT.dist) <= eps) foundSimilarDist = Object.assign({
                  neighbor: i,
                  direction: "top"
                }, t);else if (targetB && b && targetB.index !== b.index && Math.abs(b.dist - targetB.dist) <= eps) foundSimilarDist = Object.assign({
                  neighbor: i,
                  direction: "bottom"
                }, b);
              }

              if (foundSimilarDist) break;
            }
          }

          if (foundSimilarDist) {
            var _foundSimilarDist = foundSimilarDist,
                dir = _foundSimilarDist.direction,
                _refPointsA2 = _foundSimilarDist.refPointsA,
                _refPointsB2 = _foundSimilarDist.refPointsB,
                dist = _foundSimilarDist.dist;
            var _targetRefPoints = targetRefPoints,
                tl = _targetRefPoints.left,
                tt = _targetRefPoints.top,
                tb = _targetRefPoints.bottom,
                tr = _targetRefPoints.right,
                tw = _targetRefPoints.width,
                th = _targetRefPoints.height;
            var al = _refPointsA2.left,
                at = _refPointsA2.top,
                ab = _refPointsA2.bottom,
                ar = _refPointsA2.right,
                aw = _refPointsA2.width,
                ah = _refPointsA2.height;
            var bl = _refPointsB2.left,
                bt = _refPointsB2.top,
                bb = _refPointsB2.bottom,
                br = _refPointsB2.right;
            var startXa = dir === "left" ? tl : dir === "right" ? tr : tl + tw / 2;
            var startYa = dir === "bottom" ? tb : dir === "top" ? tt : tt + th / 2;
            var endXa = dir === "left" ? startXa - dist : dir === "right" ? startXa + dist : tl + tw / 2;
            var endYa = dir === "bottom" ? startYa + dist : dir === "top" ? startYa - dist : tt + th / 2;
            var startXb = dir === "left" ? al : dir === "right" ? ar : al + aw / 2;
            var startYb = dir === "bottom" ? ab : dir === "top" ? at : at + ah / 2;
            var endXb = dir === "left" ? br : dir === "right" ? bl : al + aw / 2;
            var endYb = dir === "bottom" ? bt : dir === "top" ? bb : at + ah / 2;

            if (snap && !maxHPriority && (dir === "right" || dir === "left")) {
              maxHPriority = 10;
              var sign = dir === "right" ? -1 : 1;
              dragOffsetX = (foundSimilarDist.dist - (targetR || targetL).dist) * sign;
              startXa += dragOffsetX;
              endXa += dragOffsetX;
            }

            if (snap && !maxVPriority && (dir === "top" || dir === "bottom")) {
              maxVPriority = 10;

              var _sign = dir === "top" ? -1 : 1;

              dragOffsetY = ((targetT || targetB).dist - foundSimilarDist.dist) * _sign;
              startYa += dragOffsetY;
              endYa += dragOffsetY;
            }

            guideSpecs.push({
              type: "line",
              epiMorph: true,
              hasFixedPosition: true,
              start: tfm.transformPoint(pt(startXb, startYb)),
              end: tfm.transformPoint(pt(endXb, endYb)),
              fill: Color.orange,
              height: __varRecorder__$1b.guideWidth,
              guideType: dir,
              priority: 10
            }, {
              type: "line",
              epiMorph: true,
              hasFixedPosition: true,
              start: tfm.transformPoint(pt(startXa, startYa)),
              end: tfm.transformPoint(pt(endXa, endYa)),
              fill: Color.orange,
              height: __varRecorder__$1b.guideWidth,
              guideType: dir,
              priority: 10
            });
          }
        }

        if (snap && (dragOffsetX || dragOffsetY)) {
          target.moveBy(pt(dragOffsetX, dragOffsetY));
        }

        if (showGuides) {
          guideSpecs = guideSpecs.filter(function (_ref) {
            var guideType = _ref.guideType,
                priority = _ref.priority;
            return guideType === "h" ? priority === maxHPriority : guideType === "v" ? priority === maxVPriority : true;
          });

          var dragGuides = __varRecorder__$1b.cachedGuideLines.get(target);

          if (!dragGuides) __varRecorder__$1b.cachedGuideLines.set(target, dragGuides = []);
          var _i2 = 0;

          for (; _i2 < guideSpecs.length; _i2++) {
            var guide = void 0;
            if (dragGuides[_i2]) guide = Object.assign(dragGuides[_i2], guideSpecs[_i2]);else {
              guide = morph(guideSpecs[_i2]);
              dragGuides.push(guide);
            }
            if (!guide.owner) world.addMorph(guide);
          }

          dragGuides.slice(_i2).forEach(function (ea) {
            return ea.remove();
          });
          debounceNamed(target.id + "-drag-guides-cleanup", 1300, function () {
            var dragGuides = __varRecorder__$1b.cachedGuideLines.get(target);

            if (!dragGuides) return;
            dragGuides.forEach(function (ea) {
              return ea.remove();
            });
          })();
        }
      }, __moduleMeta__$w));

      __varRecorder__$1b.showAndSnapToGuides = showAndSnapToGuides;

      var findMorphsWithSimilarWidthOrHeight = __varRecorder__$1b["lively.halos/drag-guides.js__define__"]("findMorphsWithSimilarWidthOrHeight", "function", function (refMorph, axis, others) {
        var eps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 15;
        var distCutoff = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;
        var result;

        var refPoints = __varRecorder__$1b.computeRefPoints(refMorph.bounds());

        for (var i = 0; i < others.length; i++) {
          var m = others[i];
          if (m === refMorph) continue;

          var refPointsM = __varRecorder__$1b.computeRefPoints(m.bounds());

          var distLeft = Math.max(0, refPoints.left - refPointsM.right);
          var distRight = Math.max(0, refPointsM.left - refPoints.right);
          var distTop = Math.max(0, refPoints.top - refPointsM.bottom);
          var distBottom = Math.max(0, refPointsM.top - refPoints.bottom);
          var minDist = Math.min(distBottom, distTop, distRight, distLeft);
          var maxDist = Math.max(distBottom, distTop, distRight, distLeft);
          if (Math.max(distBottom, distTop, distRight, distLeft) > distCutoff) continue;
          var widthA = refPoints.width,
              heightA = refPoints.height;
          var widthB = refPointsM.width,
              heightB = refPointsM.height;
          var widthDelta = widthB - widthA;
          var heightDelta = heightB - heightA;

          if ((axis === "x" || axis === "xy") && Math.abs(widthDelta) <= eps) {
            if (!result) result = new Map();
            result.set(m, {
              similarIn: "width",
              minDist: minDist,
              maxDist: maxDist,
              refPointsA: refPoints,
              refPointsB: refPointsM,
              valA: widthA,
              valB: widthB,
              delta: widthDelta
            });
          }

          if ((axis === "y" || axis === "xy") && Math.abs(heightDelta) <= eps) {
            if (!result) result = new Map();
            result.set(m, {
              similarIn: "height",
              minDist: minDist,
              maxDist: maxDist,
              refPointsA: refPoints,
              refPointsB: refPointsM,
              valA: heightA,
              valB: heightB,
              delta: heightDelta
            });
          }
        }

        return result;
      }, __moduleMeta__$w);

      __varRecorder__$1b.findMorphsWithSimilarWidthOrHeight = findMorphsWithSimilarWidthOrHeight;

      var showAndSnapToResizeGuides = __varRecorder__$1b["lively.halos/drag-guides.js__define__"]("showAndSnapToResizeGuides", "function", function (target, sides) {
        var showGuides = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var snap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var eps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 5;
        var maxDist = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;
        if (!showGuides && !snap) return;
        var owner = target.owner;
        var world = owner.world();
        var tfm = owner.getGlobalTransform();
        var morphsForGuides = target.owner.submorphs.filter(function (ea) {
          return ea !== target && !ea.isEpiMorph && ea.visible && ea.reactsToPointer;
        });
        var axis = (sides.includes("left") || sides.includes("right") ? "x" : "") + (sides.includes("top") || sides.includes("bottom") ? "y" : "");

        var similarExtents = __varRecorder__$1b.findMorphsWithSimilarWidthOrHeight(target, axis, morphsForGuides, eps, maxDist);

        var widthPriority = -Infinity;
        var heightPriority = -Infinity;
        var offsetRight = 0;
        var offsetLeft = 0;
        var offsetTop = 0;
        var offsetBottom = 0;
        var maxHPriority = 0;
        var maxVPriority = 0;
        var guideSpecs = [];
        tfm.e -= world.scroll.x;
        tfm.f -= world.scroll.y;

        if (similarExtents) {
          var _iterator4 = _createForOfIteratorHelper(similarExtents),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _step4$value = _slicedToArray(_step4.value, 2),
                  _ = _step4$value[0],
                  _step4$value$ = _step4$value[1],
                  similarIn = _step4$value$.similarIn,
                  delta = _step4$value$.delta,
                  refPointsA = _step4$value$.refPointsA,
                  refPointsB = _step4$value$.refPointsB,
                  minDist = _step4$value$.minDist;

              var priority = eps - delta + (maxDist - minDist);

              if (similarIn === "width") {
                if (widthPriority < priority) {
                  widthPriority = priority;
                  if (sides.includes("left")) offsetLeft = -delta;
                  if (sides.includes("right")) offsetRight = delta;
                }
              } else {
                if (heightPriority < priority) {
                  heightPriority = priority;
                  if (sides.includes("top")) offsetTop = -delta;
                  if (sides.includes("bottom")) offsetBottom = delta;
                }
              }

              var specA = {
                type: "line",
                epiMorph: true,
                hasFixedPosition: true,
                height: __varRecorder__$1b.guideWidth,
                fill: __varRecorder__$1b.guideColor,
                guideType: similarIn,
                priority: priority,
                start: tfm.transformPoint(similarIn === "width" ? pt(refPointsA.left, refPointsA.top + refPointsA.height / 2) : pt(refPointsA.left + refPointsA.width / 2, refPointsA.top)),
                end: tfm.transformPoint(similarIn === "width" ? pt(refPointsA.right, refPointsA.top + refPointsA.height / 2) : pt(refPointsA.left + refPointsA.width / 2, refPointsA.bottom))
              };
              var specB = Object.assign({}, specA, {
                start: tfm.transformPoint(similarIn === "width" ? pt(refPointsB.left, refPointsB.top + refPointsB.height / 2) : pt(refPointsB.left + refPointsB.width / 2, refPointsB.top)),
                end: tfm.transformPoint(similarIn === "width" ? pt(refPointsB.right, refPointsB.top + refPointsB.height / 2) : pt(refPointsB.left + refPointsB.width / 2, refPointsB.bottom))
              });
              guideSpecs.push(specA, specB);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }

        var fromEdges = sides;
        var toEdges;

        var aligned = __varRecorder__$1b.findAlignedMorphs(target, morphsForGuides, eps, maxDist, fromEdges, toEdges);

        if (aligned) {
          var _iterator5 = _createForOfIteratorHelper(aligned),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var _step5$value = _slicedToArray(_step5.value, 2),
                  _2 = _step5$value[0],
                  _step5$value$ = _step5$value[1],
                  horizontal = _step5$value$.horizontal,
                  vertical = _step5$value$.vertical;

              var _iterator6 = _createForOfIteratorHelper(horizontal),
                  _step6;

              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  var _step6$value = _step6.value,
                      _delta2 = _step6$value.delta,
                      edgeAVal = _step6$value.edgeAVal,
                      _refPointsA3 = _step6$value.refPointsA,
                      _refPointsB3 = _step6$value.refPointsB,
                      edgeBVal = _step6$value.edgeBVal,
                      _maxDist3 = _step6$value.maxDist;

                  var _priority2 = Math.ceil(eps - _delta2);

                  var top = Math.min(_refPointsA3.top, _refPointsB3.top);
                  var bottom = Math.max(_refPointsA3.bottom, _refPointsB3.bottom);
                  if (_maxDist3 > eps) _priority2 -= eps / 2;

                  if (maxHPriority < _priority2) {
                    maxHPriority = _priority2;
                    if (sides.includes("left")) offsetLeft = -(edgeBVal - edgeAVal);
                    if (sides.includes("right")) offsetRight = +(edgeBVal - edgeAVal);
                  }

                  guideSpecs.push({
                    type: "line",
                    epiMorph: true,
                    hasFixedPosition: true,
                    height: __varRecorder__$1b.guideWidth,
                    start: tfm.transformPoint(pt(edgeBVal, top)),
                    end: tfm.transformPoint(pt(edgeBVal, bottom)),
                    fill: __varRecorder__$1b.guideColor,
                    guideType: "h",
                    priority: _priority2
                  });
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }

              var _iterator7 = _createForOfIteratorHelper(vertical),
                  _step7;

              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  var _step7$value = _step7.value,
                      _delta3 = _step7$value.delta,
                      _edgeAVal2 = _step7$value.edgeAVal,
                      _refPointsA4 = _step7$value.refPointsA,
                      _refPointsB4 = _step7$value.refPointsB,
                      _edgeBVal2 = _step7$value.edgeBVal,
                      _maxDist4 = _step7$value.maxDist;

                  var _priority3 = Math.ceil(eps - _delta3);

                  var left = Math.min(_refPointsA4.left, _refPointsB4.left);
                  var right = Math.max(_refPointsA4.right, _refPointsB4.right);
                  if (_maxDist4 > eps) _priority3 -= eps / 2;

                  if (maxVPriority < _priority3 && Math.abs(_edgeBVal2 - _edgeAVal2) <= eps) {
                    maxVPriority = _priority3;
                    if (sides.includes("top")) offsetTop = _edgeBVal2 - _edgeAVal2;
                    if (sides.includes("bottom")) offsetBottom = _edgeBVal2 - _edgeAVal2;
                  }

                  guideSpecs.push({
                    type: "line",
                    epiMorph: true,
                    hasFixedPosition: true,
                    height: __varRecorder__$1b.guideWidth,
                    start: tfm.transformPoint(pt(left, _edgeBVal2)),
                    end: tfm.transformPoint(pt(right, _edgeBVal2)),
                    fill: __varRecorder__$1b.guideColor,
                    guideType: "v",
                    priority: _priority3
                  });
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }

        if (snap) {
          if (offsetLeft) {
            target.left += offsetLeft;
            target.right -= offsetLeft;
          }

          if (offsetTop) {
            target.top += offsetTop;
            target.bottom -= offsetTop;
          }

          if (offsetRight) target.width += offsetRight;
          if (offsetBottom) target.height += offsetBottom;
        }

        if (showGuides) {
          guideSpecs = guideSpecs.filter(function (_ref2) {
            var guideType = _ref2.guideType,
                priority = _ref2.priority;
            return guideType === "width" ? priority === widthPriority : guideType === "height" ? priority === heightPriority : guideType === "v" ? priority === maxVPriority : guideType === "h" ? priority === maxHPriority : false;
          });

          var dragGuides = __varRecorder__$1b.cachedGuideLines.get(target);

          if (!dragGuides) __varRecorder__$1b.cachedGuideLines.set(target, dragGuides = []);
          var i = 0;

          for (; i < guideSpecs.length; i++) {
            var guide = void 0;
            if (dragGuides[i]) guide = Object.assign(dragGuides[i], guideSpecs[i]);else {
              guide = morph(guideSpecs[i]);
              dragGuides.push(guide);
            }
            if (!guide.owner) world.addMorph(guide);
          }

          dragGuides.slice(i).forEach(function (ea) {
            return ea.remove();
          });
          debounceNamed(target.id + "-drag-guides-cleanup", 1300, function () {
            var dragGuides = __varRecorder__$1b.cachedGuideLines.get(target);

            if (!dragGuides) return;
            dragGuides.forEach(function (ea) {
              return ea.remove();
            });
          })();
        }
      }, __moduleMeta__$w);

      __varRecorder__$1b.showAndSnapToResizeGuides = showAndSnapToResizeGuides;
      __varRecorder__$1b.cachedGuideLines = new WeakMap();
      __varRecorder__$1b.guideWidth = 1;
      __varRecorder__$1b.guideColor = Color.orange.lighter();
      __varRecorder__$1b.edges = [["vertical", "top", "top"], ["vertical", "vCenter", "top"], ["vertical", "bottom", "top"], ["vertical", "top", "vCenter"], ["vertical", "vCenter", "vCenter"], ["vertical", "bottom", "vCenter"], ["vertical", "top", "bottom"], ["vertical", "vCenter", "bottom"], ["vertical", "bottom", "bottom"], ["horizontal", "left", "left"], ["horizontal", "hCenter", "left"], ["horizontal", "right", "left"], ["horizontal", "left", "hCenter"], ["horizontal", "hCenter", "hCenter"], ["horizontal", "right", "hCenter"], ["horizontal", "left", "right"], ["horizontal", "hCenter", "right"], ["horizontal", "right", "right"]];
      __varRecorder__$1b.removeSnapToGuidesOf = removeSnapToGuidesOf;
      __varRecorder__$1b.showAndSnapToGuides = showAndSnapToGuides;
      __varRecorder__$1b.showAndSnapToResizeGuides = showAndSnapToResizeGuides;

      var __varRecorder__$1a = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/markers.js", __contextModule__);
      var __moduleMeta__$v = {
        pathInPackage: function pathInPackage() {
          return "./markers.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.halos",
            version: "0.1.0"
          };
        }
      };

      var showThenHide = __varRecorder__$1a["lively.halos/markers.js__define__"]("showThenHide", "function", function (world, morphOrMorphs) {
        var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
        if (!world) return;
        var morphs = Array.isArray(morphOrMorphs) ? morphOrMorphs : [morphOrMorphs];
        morphs.forEach(function (ea) {
          return world.addMorph(ea);
        });

        if (duration) {
          setTimeout(function () {
            return morphs.forEach(function (ea) {
              return ea.fadeOut(2000);
            });
          }, duration * 1000);
        }

        return morphOrMorphs;
      }, __moduleMeta__$v);

      __varRecorder__$1a.showThenHide = showThenHide;

      var showInLoop = __varRecorder__$1a["lively.halos/markers.js__define__"]("showInLoop", "function", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(world, marker, rect) {
          var requestRemove;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  __varRecorder__$1a.showThenHide(world, marker, false);

                  _context.next = 3;
                  return delay(300);

                case 3:
                  requestRemove = false;
                  once$1(world, "onMouseDown", function () {
                    return requestRemove = true;
                  });
                  once$1(world, "hideMarkers", function () {
                    return requestRemove = true;
                  });

                case 6:
                  if (requestRemove) {
                    _context.next = 11;
                    break;
                  }

                  _context.next = 9;
                  return marker.retract(rect);

                case 9:
                  _context.next = 6;
                  break;

                case 11:
                  marker.fadeOut(2000);

                case 12:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x, _x2, _x3) {
          return _ref.apply(this, arguments);
        };
      }(), __moduleMeta__$v);

      __varRecorder__$1a.showInLoop = showInLoop;

      var showRect = __varRecorder__$1a["lively.halos/markers.js__define__"]("showRect", "function", function (world, rect, loop, color) {
        var marker = __varRecorder__$1a.BoundsMarker.highlightBounds(rect, color);

        if (loop) return __varRecorder__$1a.showInLoop(world, marker, rect);
        return __varRecorder__$1a.showThenHide(world, marker);
      }, __moduleMeta__$v);

      __varRecorder__$1a.showRect = showRect;

      var showLine = __varRecorder__$1a["lively.halos/markers.js__define__"]("showLine", "function", function (world, line) {
        var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3000;
        var start = line.start,
            end = line.end;
        var vec = end.subPt(start);
        var path = world.addMorph({
          position: start,
          rotation: vec.theta(),
          border: {
            width: 1,
            color: Color.red
          },
          width: vec.fastR(),
          height: 0
        });
        if (delay) setTimeout(function () {
          return path.fadeOut();
        }, delay);
        return path;
      }, __moduleMeta__$v);

      __varRecorder__$1a.showLine = showLine;

      var show = exports('s', __varRecorder__$1a["lively.halos/markers.js__define__"]("show", "function", function (target) {
        var loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Color.red;
        var world = MorphicEnv["default"]().world;
        if (target === null || target === undefined) target = String(target);
        if (target.isMorph) return __varRecorder__$1a.showRect(target.world(), target.globalBounds().translatedBy(world.scroll.negated()), loop, color);
        if (target.isPoint) return __varRecorder__$1a.showRect(world, new Rectangle(target.x - 5, target.y - 5, 10, 10), color);
        if (target.isLine) return __varRecorder__$1a.showLine(world, target);
        if (target.isRectangle) return __varRecorder__$1a.showRect(world, target, color);

        if (typeof Element !== "undefined" && target instanceof Element) {
          return __varRecorder__$1a.showRect(world, Rectangle.fromElement(target));
        }

        if (typeof target === "number" || _typeof$1(target) === "symbol" || typeof target === "boolean" || typeof Node !== "undefined" && target instanceof Node || target instanceof RegExp) target = String(target);
        if (_typeof$1(target) === "object") target = inspect$1(target, {
          maxDepth: 1
        });
        if (typeof target === "string" && arguments.length === 1) return world.setStatusMessage(target);
        return world.setStatusMessage(formatFromArray(Array.from(arguments)));
      }, __moduleMeta__$v));

      __varRecorder__$1a.show = show;

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/markers.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("BoundsMarker") && typeof __lively_classholder__.BoundsMarker === "function" ? __lively_classholder__.BoundsMarker : __lively_classholder__.BoundsMarker = function BoundsMarker(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function BoundsMarker_initialize_() {
            var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Color.red;

            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this, {
              borderWidth: 0,
              fill: Color.transparent,
              markerColor: color,
              reactsToPointer: false,
              hasFixedPosition: true
            });
            return _this;
          }
        }, {
          key: "isEpiMorph",
          get: function get() {
            return true;
          }
        }, {
          key: "markerLength",
          value: function BoundsMarker_markerLength_(forBounds) {
            forBounds = forBounds.insetBy(-2);
            var length = Math.min(forBounds.width, forBounds.height);
            return Math.max(4, Math.floor(length / 10 < 10 ? length / 2 - 5 : length / 10));
          }
        }, {
          key: "createMarkerEdge",
          value: function BoundsMarker_createMarkerEdge_() {
            var b = morph({
              fill: this.markerColor,
              reactsToPointer: false,
              borderRadius: 10
            });
            return b;
          }
        }, {
          key: "ensureMarkerCorners",
          value: function BoundsMarker_ensureMarkerCorners_() {
            var topLeftH = this.topLeftH || (this.topLeftH = this.addMorph(this.createMarkerEdge()));
            var topLeftV = this.topLeftV || (this.topLeftV = this.addMorph(this.createMarkerEdge()));
            var topRightH = this.topRightH || (this.topRightH = this.addMorph(this.createMarkerEdge()));
            var topRightV = this.topRightV || (this.topRightV = this.addMorph(this.createMarkerEdge()));
            var bottomRightH = this.bottomRightH || (this.bottomRightH = this.addMorph(this.createMarkerEdge()));
            var bottomRightV = this.bottomRightV || (this.bottomRightV = this.addMorph(this.createMarkerEdge()));
            var bottomLeftH = this.bottomLeftH || (this.bottomLeftH = this.addMorph(this.createMarkerEdge()));
            var bottomLeftV = this.bottomLeftV || (this.bottomLeftV = this.addMorph(this.createMarkerEdge()));
            return [topLeftH, topLeftV, topRightH, topRightV, bottomRightH, bottomRightV, bottomLeftH, bottomLeftV];
          }
        }, {
          key: "alignWithMorph",
          value: function BoundsMarker_alignWithMorph_(otherMorph) {
            return this.alignWithBounds(otherMorph.globalBounds().translatedBy($world.scroll.negated()));
          }
        }, {
          key: "alignWithBounds",
          value: function BoundsMarker_alignWithBounds_(bounds) {
            this.alignWithRect(bounds.insetBy(-20));
            return this.alignWithRect(bounds, true);
          }
        }, {
          key: "alignWithRect",
          value: function BoundsMarker_alignWithRect_(r, animated) {
            var markerWidth = 5;
            var corners = this.ensureMarkerCorners();
            var markerLength = this.markerLength(r);
            var boundsForMarkers = [r.topLeft().addXY(0, 0).extent(pt(markerLength, markerWidth)), r.topLeft().addXY(0, 0).extent(pt(markerWidth, markerLength)), r.topRight().addXY(-markerLength, 0).extent(pt(markerLength, markerWidth)), r.topRight().addXY(-markerWidth, 0).extent(pt(markerWidth, markerLength)), r.bottomRight().addXY(-markerWidth, -markerLength).extent(pt(markerWidth, markerLength)), r.bottomRight().addXY(-markerLength, -markerWidth).extent(pt(markerLength, markerWidth)), r.bottomLeft().addXY(0, -markerWidth).extent(pt(markerLength, markerWidth)), r.bottomLeft().addXY(0, -markerLength).extent(pt(markerWidth, markerLength))];
            corners.forEach(function (corner, i) {
              return corner.setBounds(boundsForMarkers[i]);
            });

            if (animated) {
              this.adjustOrigin(r.center());
              this.opacity = 0, this.scale = 1.5;
              this.animate({
                opacity: 1,
                scale: 1,
                duration: 300
              });
            }

            return this;
          }
        }, {
          key: "retract",
          value: function () {
            var _BoundsMarker_retract_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(r) {
              var center;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return this.animate({
                        scale: Math.max(30 / r.width, 1.05)
                      });

                    case 2:
                      center = this.center;
                      _context2.next = 5;
                      return this.animate({
                        center: center,
                        scale: 1,
                        duration: 300,
                        easing: easings.inOutExpo
                      });

                    case 5:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function BoundsMarker_retract_(_x4) {
              return _BoundsMarker_retract_.apply(this, arguments);
            }

            return BoundsMarker_retract_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "BoundsMarker";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              markerColor: {
                defaultValue: Color.red
              }
            };
          }
        }, {
          key: "highlightMorph",
          value: function BoundsMarker_highlightMorph_(morph) {
            var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Color.red;
            return new this(color).alignWithMorph(morph);
          }
        }, {
          key: "highlightBounds",
          value: function BoundsMarker_highlightBounds_(bounds) {
            var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Color.red;
            return new this(color).alignWithBounds(bounds);
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./markers.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 252,
          end: 4034
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$1a.show = show;

      var __varRecorder__$19 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/value-widgets.cp.js", __contextModule__);
      __varRecorder__$19.CaretButton = component["for"](function () {
        return component({
          name: "caret button",
          borderColor: Color.rgb(23, 160, 251),
          clipMode: "hidden",
          extent: pt(20, 12),
          fill: Color.rgba(0, 0, 0, 0),
          nativeCursor: "pointer",
          submorphs: [{
            type: Label,
            name: "icon",
            borderColor: Color.rgba(0, 0, 0, 0),
            borderWidth: 1,
            fontColor: Color.rgb(127, 140, 141),
            nativeCursor: "pointer",
            padding: rect(5, 0, -1, -1),
            reactsToPointer: false,
            textAndAttributes: Icon.textAttribute("sort-up")
          }]
        });
      }, {
        module: "lively.ide/value-widgets.cp.js",
        "export": "CaretButton",
        range: {
          start: 305,
          end: 801
        }
      }, System, __varRecorder__$19, "CaretButton");
      var NumberWidgetModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/value-widgets.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("NumberWidgetModel") && typeof __lively_classholder__.NumberWidgetModel === "function" ? __lively_classholder__.NumberWidgetModel : __lively_classholder__.NumberWidgetModel = function NumberWidgetModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "increment",
          value: function NumberWidgetModel_increment_() {
            if (this.max !== undefined && this.number >= this.max) return;
            this.number += 1 / this.scaleFactor;
          }
        }, {
          key: "decrement",
          value: function NumberWidgetModel_decrement_() {
            if (this.min !== undefined && this.number <= this.min) return;
            this.number -= 1 / this.scaleFactor;
          }
        }, {
          key: "setMixed",
          value: function NumberWidgetModel_setMixed_() {
            this.ui.value.textString = "Mix";
          }
        }, {
          key: "isMixed",
          get: function get() {
            return this.ui.value.textString === "Mix";
          }
        }, {
          key: "getCurrentValue",
          value: function NumberWidgetModel_getCurrentValue_(delta, s) {
            var v = this.scrubbedValue + (this.floatingPoint ? delta * s : Math.round(delta * s));
            v /= this.scaleFactor;
            return Math.max(this.min, Math.min(this.max, v));
          }
        }, {
          key: "getScaleAndOffset",
          value: function NumberWidgetModel_getScaleAndOffset_(evt) {
            var _evt$position$subPt = evt.position.subPt(this.initPos),
                x = _evt$position$subPt.x,
                y = _evt$position$subPt.y;

            var scale = roundTo(Math.exp(-y / $world.height * 4), 0.01) * this.baseFactor;
            return {
              offset: x,
              scale: scale
            };
          }
        }, {
          key: "interactivelyEdit",
          value: function NumberWidgetModel_interactivelyEdit_() {
            this.ui.value.readOnly = false;
            this.ui.value.focus();
          }
        }, {
          key: "onInput",
          value: function NumberWidgetModel_onInput_(evt) {
            if (evt.keyCombo === "Enter") {
              var _this$ui$value$textSt = this.ui.value.textString.replace("\n", "").split(" "),
                  _this$ui$value$textSt2 = _slicedToArray(_this$ui$value$textSt, 1),
                  v = _this$ui$value$textSt2[0];

              if (typeof v === "string") {
                this.number = parseFloat(v) / this.scaleFactor;
              }

              this.ui.value.readOnly = true;
              evt.stop();
            }
          }
        }, {
          key: "onScrubStart",
          value: function NumberWidgetModel_onScrubStart_(evt) {
            this.view.execCommand("toggle active mark");
            this.initPos = evt.position;
            this.scrubbedValue = this.floatingPoint ? this.number * this.scaleFactor : roundTo(this.number * this.scaleFactor, 1);
            this.factorLabel = part(SystemTooltip, {
              description: "1x"
            }).openInWorld(evt.hand.position.addXY(10, 10));
            evt.hand.extent = pt(30, 30);
            evt.hand.nativeCursor = "ew-resize";
            evt.hand.fill = Color.transparent;
            evt.hand.reactsToPointer = true;
          }
        }, {
          key: "onScrub",
          value: function NumberWidgetModel_onScrub_(evt) {
            var _this$getScaleAndOffs = this.getScaleAndOffset(evt),
                scale = _this$getScaleAndOffs.scale,
                offset = _this$getScaleAndOffs.offset;

            this.number = this.getCurrentValue(offset, scale);
            this.factorLabel.description = scale.toFixed(this.precision) + "x";
            this.factorLabel.position = evt.hand.position.addXY(10, 10);
            evt.hand.moveBy(pt(-5, -5));
          }
        }, {
          key: "onScrubEnd",
          value: function NumberWidgetModel_onScrubEnd_(evt) {
            var _this$getScaleAndOffs2 = this.getScaleAndOffset(evt),
                offset = _this$getScaleAndOffs2.offset,
                scale = _this$getScaleAndOffs2.scale;

            this.scrubbedValue = this.getCurrentValue(offset, scale) * this.scaleFactor;
            this.factorLabel.softRemove();
            evt.hand.extent = pt(1, 1);
            evt.hand.reactsToPointer = false;
          }
        }, {
          key: "updateDisplayedValue",
          value: function NumberWidgetModel_updateDisplayedValue_(v) {
            v = Math.max(this.min, Math.min(this.max, v));

            if (!this.isBeingDragged) {
              this.scrubbedValue = v;
            }

            this.renderValue(v);
          }
        }, {
          key: "renderValue",
          value: function NumberWidgetModel_renderValue_(v) {
            v *= this.scaleFactor;
            var valueString = this.floatingPoint ? v.toFixed(this.precision) : v.toFixed(0);
            if (this.unit) valueString += " " + this.unit;
            var value = this.ui.value;
            value.textString = valueString;

            if (this.autofit && valueString.length > 0) {
              if (!this._digitWidth) {
                value.textString = "0";
                value.env.forceUpdate(value);
                this._digitWidth = value.textBounds().width - (value.padding.left() - value.padding.right()) * 0.5;
                value.textString = valueString;
              }

              var p = Math.min(this.spaceToDisplay / (valueString.length * this._digitWidth), 1);
              value.scale = p;
            } else {
              if (value.scale < 1) value.scale = 1;
            }
          }
        }, {
          key: "viewDidLoad",
          value: function NumberWidgetModel_viewDidLoad_() {
            this.onRefresh("number");
          }
        }, {
          key: "onRefresh",
          value: function NumberWidgetModel_onRefresh_(prop) {
            if (prop == "number") this.renderValue(this.number);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "NumberWidgetModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              unit: {
                type: "Enum",
                values: ["px", "%", "pt", ""]
              },
              autofit: {
                defaultValue: false
              },
              number: {
                defaultValue: 0,
                after: ["unit", "autofit"],
                set: function set(v) {
                  this.setProperty("number", v);
                  signal(this.view, "number", v);
                  signal(this.view, "numberChanged", v);
                }
              },
              precision: {
                defaultValue: 0
              },
              min: {
                defaultValue: -Infinity,
                set: function set(v) {
                  if (isNaN(v)) {
                    return;
                  }

                  this.setProperty("min", v);
                }
              },
              max: {
                defaultValue: Infinity,
                set: function set(v) {
                  if (isNaN(v)) {
                    return;
                  }

                  this.setProperty("max", v);
                }
              },
              floatingPoint: {
                after: ["number"],
                defaultValue: false,
                get: function get() {
                  if (typeof this.getProperty("floatingPoint") !== "undefined") {
                    return this.getProperty("floatingPoint");
                  }

                  var m = /[+-]?([0-9]*[.])?[0-9]+/.exec(this.number);
                  return this.scaleFactor === 1 && m && !!m[1];
                }
              },
              scaleFactor: {
                defaultValue: 1
              },
              baseFactor: {
                defaultValue: 1
              },
              isSelected: {
                set: function set(selected) {
                  if (this.getProperty("isSelected") !== selected) {
                    var view = this.view;

                    if (selected) {
                      view.addStyleClass("selected");
                      view.removeStyleClass("unselected");
                    } else {
                      view.removeStyleClass("selected");
                      view.addStyleClass("unselected");
                    }

                    this.setProperty("isSelected", selected);
                  }
                }
              },
              spaceToDisplay: {
                get: function get() {
                  if (this.ui.buttonHolder) return this.view.width - this.ui.buttonHolder.width - 10;
                  return this.view.width;
                }
              },
              showStepControls: {
                derived: true,
                get: function get() {
                  var _this$ui = this.ui,
                      up = _this$ui.up,
                      down = _this$ui.down;
                  return up && up.visible && down && down.visible;
                },
                set: function set(active) {
                  this.ui.up.visible = this.ui.down.visible = active;
                  this.clipMode = active ? "visible" : "hidden";
                }
              },
              expose: {
                get: function get() {
                  return ["number", "increment", "decrement", "isMixed", "setMixed", "max", "min", "scaleFactor"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "value",
                    signal: "onDragStart",
                    handler: "onScrubStart"
                  }, {
                    target: "value",
                    signal: "onDrag",
                    handler: "onScrub"
                  }, {
                    target: "value",
                    signal: "onDragEnd",
                    handler: "onScrubEnd"
                  }, {
                    target: "value",
                    signal: "onKeyDown",
                    handler: "onInput"
                  }, {
                    target: "value",
                    signal: "onMouseUp",
                    handler: "interactivelyEdit"
                  }, {
                    target: "up",
                    signal: "onMouseDown",
                    handler: "increment"
                  }, {
                    target: "down",
                    signal: "onMouseDown",
                    handler: "decrement"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./value-widgets.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 811,
          end: 8071
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$19.NumberWidgetModel = NumberWidgetModel;
      __varRecorder__$19.NumberWidgetModel = NumberWidgetModel;
      __varRecorder__$19.DefaultNumberWidget = component["for"](function () {
        return component({
          defaultViewModel: __varRecorder__$19.NumberWidgetModel,
          name: "default number widget",
          borderColor: Color.rgb(149, 165, 166),
          borderRadius: 4,
          dropShadow: new ShadowObject({
            color: Color.rgba(0, 0, 0, 0.26)
          }),
          extent: pt(72.5, 25.7),
          fill: Color.rgb(253, 254, 254),
          clipMode: "hidden",
          layout: new TilingLayout({
            axisAlign: "center",
            justifySubmorphs: "spaced",
            resizePolicies: [["value", {
              height: "fixed",
              width: "fixed"
            }]]
          }),
          submorphs: [{
            type: "text",
            name: "value",
            fill: Color.transparent,
            extent: pt(53.6, 24),
            fixedWidth: false,
            selectable: true,
            readOnly: true,
            fontColor: Color.rgb(40, 116, 166),
            fontFamily: "IBM Plex Sans",
            fontSize: 16,
            padding: rect(6, 2, -6, -2),
            scaleToBounds: true,
            draggable: true,
            textAndAttributes: ["0", null]
          }, {
            name: "button holder",
            fill: Color.transparent,
            layout: new TilingLayout({
              axis: "column"
            }),
            submorphs: [part(__varRecorder__$19.CaretButton, {
              name: "up",
              submorphs: [{
                name: "icon",
                padding: rect(6, 0, -2, -1),
                textAndAttributes: Icon.textAttribute("sort-up")
              }]
            }), part(__varRecorder__$19.CaretButton, {
              name: "down",
              rotation: Math.PI
            })]
          }]
        });
      }, {
        module: "lively.ide/value-widgets.cp.js",
        "export": "DefaultNumberWidget",
        range: {
          start: 8079,
          end: 9446
        }
      }, System, __varRecorder__$19, "DefaultNumberWidget");
      __varRecorder__$19.DarkNumberWidget = component["for"](function () {
        return component(__varRecorder__$19.DefaultNumberWidget, {
          name: "dark number widget",
          fill: Color.rgb(66, 73, 73),
          submorphs: [{
            name: "value",
            fontColor: Color.rgb(178, 235, 242),
            cursorColor: Color.rgba(178, 235, 242, 0.5)
          }]
        });
      }, {
        module: "lively.ide/value-widgets.cp.js",
        "export": "DarkNumberWidget",
        range: {
          start: 9455,
          end: 9699
        }
      }, System, __varRecorder__$19, "DarkNumberWidget");
      var DefaultNumberWidget = __varRecorder__$19.DefaultNumberWidget;
      var DarkNumberWidget = __varRecorder__$19.DarkNumberWidget;
      __varRecorder__$19.DefaultNumberWidget = DefaultNumberWidget;
      __varRecorder__$19.DarkNumberWidget = DarkNumberWidget;

      var __varRecorder__$18 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/shared.cp.js", __contextModule__);
      __varRecorder__$18.CloseButtonDefault = component["for"](function () {
        return component({
          type: Label,
          name: "close button default",
          borderRadius: 3,
          fill: Color.rgba(229, 231, 233, 0),
          fontColor: Color.rgb(66, 73, 73),
          fontFamily: "Material Icons",
          fontSize: 25,
          nativeCursor: "pointer",
          padding: rect(4, 4, 0, 0),
          tooltip: "Close Window",
          lineHeight: 1,
          textAndAttributes: ["\uE5CD", {}]
        });
      }, {
        module: "lively.ide/styling/shared.cp.js",
        "export": "CloseButtonDefault",
        range: {
          start: 230,
          end: 585
        }
      }, System, __varRecorder__$18, "CloseButtonDefault");
      __varRecorder__$18.CloseButtonHovered = component["for"](function () {
        return component(__varRecorder__$18.CloseButtonDefault, {
          name: "close button hovered",
          fill: Color.gray
        });
      }, {
        module: "lively.ide/styling/shared.cp.js",
        "export": "CloseButtonHovered",
        range: {
          start: 594,
          end: 698
        }
      }, System, __varRecorder__$18, "CloseButtonHovered");
      __varRecorder__$18.CloseButton = component["for"](function () {
        return component(__varRecorder__$18.CloseButtonDefault, {
          name: "close button",
          master: {
            hover: __varRecorder__$18.CloseButtonHovered
          }
        });
      }, {
        module: "lively.ide/styling/shared.cp.js",
        "export": "CloseButton",
        range: {
          start: 707,
          end: 819
        }
      }, System, __varRecorder__$18, "CloseButton");
      __varRecorder__$18.DarkCloseButtonHovered = component["for"](function () {
        return component(__varRecorder__$18.CloseButtonDefault, {
          name: "close button hovered",
          fill: Color.rgb(66, 73, 73)
        });
      }, {
        module: "lively.ide/styling/shared.cp.js",
        "export": "DarkCloseButtonHovered",
        range: {
          start: 828,
          end: 949
        }
      }, System, __varRecorder__$18, "DarkCloseButtonHovered");
      __varRecorder__$18.DarkCloseButton = component["for"](function () {
        return component(__varRecorder__$18.CloseButtonDefault, {
          name: "close button",
          master: {
            hover: __varRecorder__$18.DarkCloseButtonHovered
          }
        });
      }, {
        module: "lively.ide/styling/shared.cp.js",
        "export": "DarkCloseButton",
        range: {
          start: 958,
          end: 1078
        }
      }, System, __varRecorder__$18, "DarkCloseButton");
      __varRecorder__$18.CheckerPattern = component["for"](function () {
        return component({
          type: HTMLMorph,
          name: "checker pattern",
          borderColor: Color.rgb(203, 203, 203),
          clipMode: "hidden",
          cssDeclaration: ".checkerboard {\n  width: 100%;\n  height: 100%;\n  background-image: linear-gradient(45deg, #bdc3c7 25%, transparent 25%), linear-gradient(-45deg, #bdc3c7 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #bdc3c7 75%), linear-gradient(-45deg, transparent 75%, #bdc3c7 75%);\n  background-size: 6px 6px;\n  background-position: 0 0, 0 3px, 3px -3px, -3px 0px;\n}",
          fill: Color.rgba(0, 0, 0, 0),
          html: "<div class=\"checkerboard\"></div>",
          reactsToPointer: false
        });
      }, {
        module: "lively.ide/styling/shared.cp.js",
        "export": "CheckerPattern",
        range: {
          start: 1087,
          end: 1738
        }
      }, System, __varRecorder__$18, "CheckerPattern");
      __varRecorder__$18.PopupWindow = component["for"](function () {
        return component({
          name: "popup window",
          borderColor: Color.rgb(149, 165, 166),
          borderRadius: 3,
          borderWidth: 1,
          clipMode: "hidden",
          draggable: true,
          dropShadow: new ShadowObject({
            rotation: 34,
            color: Color.rgba(0, 0, 0, 0.16),
            blur: 12
          }),
          epiMorph: true,
          extent: pt(241, 547),
          fill: Color.white,
          hasFixedPosition: true,
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "center",
            orderByIndex: true,
            hugContentsVertically: true,
            hugContentsHorizontally: true
          }),
          nativeCursor: "grab",
          styleClasses: ["Popups"],
          submorphs: [{
            name: "header menu",
            borderWidth: {
              top: 0,
              left: 0,
              right: 0,
              bottom: 1
            },
            borderColor: Color.rgb(215, 219, 221),
            extent: pt(241, 40.5),
            fill: Color.rgba(0, 0, 0, 0),
            layout: new TilingLayout({
              axisAlign: "center",
              align: "right",
              orderByIndex: true,
              padding: rect(5, 0, 0, 0),
              justifySubmorphs: "spaced"
            }),
            reactsToPointer: false,
            submorphs: [{
              type: Label,
              name: "title",
              padding: rect(10, 0, -10, 0),
              fontWeight: "bold",
              textString: "Window title"
            }, part(__varRecorder__$18.CloseButton, {
              name: "close button"
            })]
          }]
        });
      }, {
        module: "lively.ide/styling/shared.cp.js",
        "export": "PopupWindow",
        range: {
          start: 1747,
          end: 2976
        }
      }, System, __varRecorder__$18, "PopupWindow");
      __varRecorder__$18.SystemList = component["for"](function () {
        return component(DefaultList, {
          name: "system list",
          borderColor: Color.rgb(149, 165, 166),
          borderRadius: 3,
          dropShadow: new ShadowObject({
            distance: 1,
            color: Color.rgba(0, 0, 0, 0.26)
          }),
          fill: Color.rgba(255, 255, 255, 0.9),
          itemHeight: 20,
          itemPadding: rect(3, 2, -2, -1),
          manualItemHeight: true,
          padding: rect(2, 2, 0, 0),
          position: pt(1811.5, 370.6),
          itemBorderRadius: 2,
          selectionColor: new LinearGradient({
            stops: [{
              offset: 0,
              color: Color.rgb(66, 165, 245)
            }, {
              offset: 1,
              color: Color.rgb(41, 121, 255)
            }],
            vector: rect(0, 0, 0, 1)
          })
        });
      }, {
        module: "lively.ide/styling/shared.cp.js",
        "export": "SystemList",
        range: {
          start: 2985,
          end: 3563
        }
      }, System, __varRecorder__$18, "SystemList");
      var CheckerPattern = __varRecorder__$18.CheckerPattern;
      var SystemList = exports('b', __varRecorder__$18.SystemList);
      var PopupWindow = exports('P', __varRecorder__$18.PopupWindow);
      var CloseButton = __varRecorder__$18.CloseButton;
      var DarkCloseButton$1 = __varRecorder__$18.DarkCloseButton;
      var CloseButtonDefault = __varRecorder__$18.CloseButtonDefault;
      var CloseButtonHovered = __varRecorder__$18.CloseButtonHovered;
      __varRecorder__$18.CheckerPattern = CheckerPattern;
      __varRecorder__$18.SystemList = SystemList;
      __varRecorder__$18.PopupWindow = PopupWindow;
      __varRecorder__$18.CloseButton = CloseButton;
      __varRecorder__$18.DarkCloseButton = DarkCloseButton$1;
      __varRecorder__$18.CloseButtonDefault = CloseButtonDefault;
      __varRecorder__$18.CloseButtonHovered = CloseButtonHovered;

      var __varRecorder__$17 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/shared.cp.js", __contextModule__);
      __varRecorder__$17.DarkThemeList = component["for"](function () {
        return component(DarkList, {
          name: "sidebar list",
          selectionColor: Color.rgb(178, 235, 242),
          fill: Color.black.withA(0.8),
          submorphs: [{
            name: "scroller",
            submorphs: [{
              name: "scrollbar",
              opacity: 0
            }]
          }]
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "DarkThemeList",
        range: {
          start: 592,
          end: 824
        }
      }, System, __varRecorder__$17, "DarkThemeList");
      __varRecorder__$17.PropertyLabel = component["for"](function () {
        return component({
          type: Label,
          name: "property label",
          borderRadius: 3,
          fill: Color.rgba(229, 231, 233, 0),
          fontColor: Color.rgb(255, 255, 255),
          fontFamily: "Material Icons",
          nativeCursor: "pointer",
          padding: rect(6, 6, 0, 0),
          textAndAttributes: ["\uE430", {
            fontSize: 18,
            fontFamily: "Material Icons"
          }]
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "PropertyLabel",
        range: {
          start: 833,
          end: 1173
        }
      }, System, __varRecorder__$17, "PropertyLabel");
      __varRecorder__$17.PropertyLabelDisabled = component["for"](function () {
        return component(__varRecorder__$17.PropertyLabel, {
          nativeCursor: "not-allowed",
          opacity: 0.5
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "PropertyLabelDisabled",
        range: {
          start: 1189,
          end: 1288
        }
      }, System, __varRecorder__$17, "PropertyLabelDisabled");
      var PropertyLabelDisabled = exports('N', __varRecorder__$17.PropertyLabelDisabled);
      __varRecorder__$17.PropertyLabelDisabled = PropertyLabelDisabled;
      __varRecorder__$17.PropertyLabelLight = component["for"](function () {
        return component(__varRecorder__$17.PropertyLabel, {
          fontColor: Color.darkGray
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "PropertyLabelLight",
        range: {
          start: 1297,
          end: 1375
        }
      }, System, __varRecorder__$17, "PropertyLabelLight");
      __varRecorder__$17.PropertyLabelHovered = component["for"](function () {
        return component(__varRecorder__$17.PropertyLabel, {
          name: "property label hovered",
          fill: Color.rgb(66, 73, 73)
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "PropertyLabelHovered",
        range: {
          start: 1384,
          end: 1500
        }
      }, System, __varRecorder__$17, "PropertyLabelHovered");
      __varRecorder__$17.PropertyLabelHoveredLight = component["for"](function () {
        return component(__varRecorder__$17.PropertyLabel, {
          name: "property label hovered",
          fill: Color.rgba(192, 192, 192, 0.7829)
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "PropertyLabelHoveredLight",
        range: {
          start: 1509,
          end: 1642
        }
      }, System, __varRecorder__$17, "PropertyLabelHoveredLight");
      __varRecorder__$17.PropertyLabelActive = component["for"](function () {
        return component(__varRecorder__$17.PropertyLabel, {
          name: "property label active",
          fill: Color.rgb(178, 235, 242),
          fontColor: Color.rgb(65, 65, 65)
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "PropertyLabelActive",
        range: {
          start: 1651,
          end: 1804
        }
      }, System, __varRecorder__$17, "PropertyLabelActive");
      __varRecorder__$17.PropertyLabelActiveLight = component["for"](function () {
        return component(__varRecorder__$17.PropertyLabel, {
          fontColor: Color.white,
          fill: Color.rgb(3, 169, 244)
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "PropertyLabelActiveLight",
        range: {
          start: 1813,
          end: 1926
        }
      }, System, __varRecorder__$17, "PropertyLabelActiveLight");
      __varRecorder__$17.AddButtonAuto = component["for"](function () {
        return component({
          type: Label,
          name: "add button",
          borderRadius: 3,
          fill: Color.rgba(229, 231, 233, 0),
          fontColor: Color.rgb(255, 255, 255),
          fontFamily: "Material Icons",
          nativeCursor: "pointer",
          padding: rect(6, 6, 0, 0),
          lineHeight: 1,
          textAndAttributes: ["\uE145", {
            fontSize: 18,
            fontFamily: "Material Icons"
          }]
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "AddButtonAuto",
        range: {
          start: 1935,
          end: 2288
        }
      }, System, __varRecorder__$17, "AddButtonAuto");
      __varRecorder__$17.AddButtonHovered = component["for"](function () {
        return component(__varRecorder__$17.AddButtonAuto, {
          fill: Color.rgba(229, 231, 233, 0.35)
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "AddButtonHovered",
        range: {
          start: 2297,
          end: 2385
        }
      }, System, __varRecorder__$17, "AddButtonHovered");
      __varRecorder__$17.AddButton = component["for"](function () {
        return component(__varRecorder__$17.AddButtonAuto, {
          master: {
            hover: __varRecorder__$17.AddButtonHovered
          }
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "AddButton",
        range: {
          start: 2394,
          end: 2473
        }
      }, System, __varRecorder__$17, "AddButton");
      __varRecorder__$17.RemoveButton = component["for"](function () {
        return component(__varRecorder__$17.AddButton, {
          name: "remove button",
          textAndAttributes: ["\uE15B", {
            fontSize: 18,
            fontFamily: "Material Icons"
          }]
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "RemoveButton",
        range: {
          start: 2482,
          end: 2637
        }
      }, System, __varRecorder__$17, "RemoveButton");
      __varRecorder__$17.EnumSelectorDefault = component["for"](function () {
        return component(DarkDropDownList$1, {
          name: "enum selector/default",
          layout: new TilingLayout({
            align: "center",
            axisAlign: "center",
            orderByIndex: true,
            justifySubmorphs: "spaced",
            padding: Rectangle.inset(5, 0, 10)
          }),
          fill: Color.rgb(66, 73, 73),
          borderWidth: 0,
          borderRadius: 2,
          extent: pt(145.7, 23.3),
          nativeCursor: "pointer"
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "EnumSelectorDefault",
        range: {
          start: 2646,
          end: 3030
        }
      }, System, __varRecorder__$17, "EnumSelectorDefault");
      __varRecorder__$17.EnumSelectorClicked = component["for"](function () {
        return component(__varRecorder__$17.EnumSelectorDefault, {
          name: "enum selector/clicked",
          fill: Color.rgba(54, 61, 61, 1)
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "EnumSelectorClicked",
        range: {
          start: 3039,
          end: 3163
        }
      }, System, __varRecorder__$17, "EnumSelectorClicked");
      __varRecorder__$17.EnumSelector = component["for"](function () {
        return component(__varRecorder__$17.EnumSelectorDefault, {
          name: "enum selector",
          master: {
            click: __varRecorder__$17.EnumSelectorClicked
          }
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "EnumSelector",
        range: {
          start: 3172,
          end: 3288
        }
      }, System, __varRecorder__$17, "EnumSelector");
      __varRecorder__$17.HeadlineLabel = component["for"](function () {
        return component({
          type: Label,
          name: "headline label",
          padding: rect(10, 0, -10, 0),
          fontColor: Color.rgb(255, 255, 255),
          fontWeight: "bold",
          textAndAttributes: ["A Headling Label", null]
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "HeadlineLabel",
        range: {
          start: 3297,
          end: 3509
        }
      }, System, __varRecorder__$17, "HeadlineLabel");
      __varRecorder__$17.PropLabel = component["for"](function () {
        return component(__varRecorder__$17.HeadlineLabel, {
          name: "prop label",
          textAndAttributes: ["Property", null],
          fontWeight: "normal"
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "PropLabel",
        range: {
          start: 3518,
          end: 3645
        }
      }, System, __varRecorder__$17, "PropLabel");

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/shared.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DarkNumberIconWidgetModel") && typeof __lively_classholder__.DarkNumberIconWidgetModel === "function" ? __lively_classholder__.DarkNumberIconWidgetModel : __lively_classholder__.DarkNumberIconWidgetModel = function DarkNumberIconWidgetModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "expose",
          get: function get() {
            return ["enable", "disable"].concat(initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "expose", this));
          }
        }, {
          key: "disable",
          value: function DarkNumberIconWidgetModel_disable_() {
            this.view.nativeCursor = "not-allowed";
            this.ui.value.reactsToPointer = false;
            this.ui.interactiveLabel.reactsToPointer = false;
            this.ui.value.opacity = 0.3;
          }
        }, {
          key: "enable",
          value: function DarkNumberIconWidgetModel_enable_() {
            this.view.nativeCursor = "auto";
            this.ui.value.reactsToPointer = true;
            this.ui.interactiveLabel.reactsToPointer = true;
            this.ui.value.opacity = 1;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DarkNumberIconWidgetModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              spaceToDisplay: {
                get: function get() {
                  var _this$ui$interactiveL;

                  return this.view.width - (((_this$ui$interactiveL = this.ui.interactiveLabel) === null || _this$ui$interactiveL === void 0 ? void 0 : _this$ui$interactiveL.right) || 0);
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/shared.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 3648,
          end: 4354
        });
      })({
        referencedAs: "NumberWidgetModel",
        value: NumberWidgetModel
      });

      __varRecorder__$17.DarkNumberIconWidget = component["for"](function () {
        return component(DarkNumberWidget, {
          name: "number input",
          defaultViewModel: __varRecorder__$17.DarkNumberIconWidgetModel,
          layout: new TilingLayout({
            align: "right",
            axisAlign: "center",
            justifySubmorphs: "spaced",
            padding: rect(0, 0, 5, 0)
          }),
          borderRadius: 2,
          dropShadow: false,
          extent: pt(72, 22),
          viewModel: {
            floatingPoint: false
          },
          submorphs: [add({
            type: Label,
            name: "interactive label",
            padding: rect(6, 0, -6, 0),
            borderRadius: 3,
            fill: Color.rgba(229, 231, 233, 0),
            fontColor: Color.rgba(178, 235, 242, 0.4965358231707328),
            fontFamily: "Material Icons",
            nativeCursor: "ew-resize",
            textAndAttributes: ["\uEAAB", {
              fontFamily: "Material Icons",
              fontSize: 16
            }]
          }, "value"), without("button holder")]
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "DarkNumberIconWidget",
        range: {
          start: 4362,
          end: 5164
        }
      }, System, __varRecorder__$17, "DarkNumberIconWidget");
      __varRecorder__$17.TextInput = component["for"](function () {
        return component({
          name: "text input",
          type: InputLine,
          borderRadius: 2,
          fill: Color.rgb(66, 73, 73),
          fontColor: Color.rgb(178, 235, 242),
          fontFamily: "IBM Plex Sans"
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "TextInput",
        range: {
          start: 5173,
          end: 5359
        }
      }, System, __varRecorder__$17, "TextInput");
      __varRecorder__$17.DarkCloseButton = component["for"](function () {
        return component(CloseButton, {
          name: "dark close button",
          fontColor: Color.rgb(255, 255, 255)
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "DarkCloseButton",
        range: {
          start: 5368,
          end: 5480
        }
      }, System, __varRecorder__$17, "DarkCloseButton");
      __varRecorder__$17.DarkCloseButtonHovered = component["for"](function () {
        return component(CloseButtonHovered, {
          name: "dark close button hovered",
          fontColor: Color.rgb(255, 255, 255),
          fill: Color.gray.withA(0.2)
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "DarkCloseButtonHovered",
        range: {
          start: 5489,
          end: 5654
        }
      }, System, __varRecorder__$17, "DarkCloseButtonHovered");
      __varRecorder__$17.BoundsContainerInactive = component["for"](function () {
        return component({
          fill: Color.transparent,
          borderColor: Color.transparent,
          borderWidth: 1
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "BoundsContainerInactive",
        range: {
          start: 5663,
          end: 5781
        }
      }, System, __varRecorder__$17, "BoundsContainerInactive");
      __varRecorder__$17.BoundsContainerHovered = component["for"](function () {
        return component({
          fill: Color.transparent,
          borderColor: Color.rgb(66, 73, 73),
          borderWidth: 1,
          borderRadius: 2,
          clipMode: "hidden"
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "BoundsContainerHovered",
        range: {
          start: 5790,
          end: 5952
        }
      }, System, __varRecorder__$17, "BoundsContainerHovered");
      __varRecorder__$17.DarkPopupWindow = component["for"](function () {
        return component(PopupWindow, {
          name: "dark popup window",
          borderColor: Color.rgba(112, 123, 124, 1),
          fill: Color.rgb(32, 32, 32),
          hasFixedPosition: true,
          submorphs: [{
            name: "header menu",
            borderColor: Color.rgbHex("616A6B"),
            reactsToPointer: false,
            submorphs: [{
              name: "title",
              fontColor: Color.rgb(255, 255, 255)
            }, {
              name: "close button",
              master: {
                auto: __varRecorder__$17.DarkCloseButton,
                hover: __varRecorder__$17.DarkCloseButtonHovered
              }
            }]
          }]
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "DarkPopupWindow",
        range: {
          start: 5961,
          end: 6448
        }
      }, System, __varRecorder__$17, "DarkPopupWindow");
      __varRecorder__$17.DarkFlap = component["for"](function () {
        return component(__varRecorder__$17.DarkPopupWindow, {
          name: "dark flap",
          submorphs: [without("header menu")]
        });
      }, {
        module: "lively.ide/studio/shared.cp.js",
        "export": "DarkFlap",
        range: {
          start: 6457,
          end: 6566
        }
      }, System, __varRecorder__$17, "DarkFlap");
      var AddButton = exports('A', __varRecorder__$17.AddButton);
      var RemoveButton = exports('L', __varRecorder__$17.RemoveButton);
      var HeadlineLabel = __varRecorder__$17.HeadlineLabel;
      var PropLabel = exports('t', __varRecorder__$17.PropLabel);
      var DarkNumberIconWidget = exports('k', __varRecorder__$17.DarkNumberIconWidget);
      var TextInput = exports('T', __varRecorder__$17.TextInput);
      var EnumSelector = exports('c', __varRecorder__$17.EnumSelector);
      var PropertyLabel = exports('K', __varRecorder__$17.PropertyLabel);
      var PropertyLabelLight = __varRecorder__$17.PropertyLabelLight;
      var PropertyLabelHovered = exports('q', __varRecorder__$17.PropertyLabelHovered);
      var PropertyLabelHoveredLight = __varRecorder__$17.PropertyLabelHoveredLight;
      var PropertyLabelActive = exports('m', __varRecorder__$17.PropertyLabelActive);
      var PropertyLabelActiveLight = __varRecorder__$17.PropertyLabelActiveLight;
      var DarkThemeList = exports('n', __varRecorder__$17.DarkThemeList);
      var DarkFlap = exports('u', __varRecorder__$17.DarkFlap);
      var DarkPopupWindow = exports('D', __varRecorder__$17.DarkPopupWindow);
      var DarkCloseButton = __varRecorder__$17.DarkCloseButton;
      var DarkCloseButtonHovered = __varRecorder__$17.DarkCloseButtonHovered;
      var BoundsContainerInactive = __varRecorder__$17.BoundsContainerInactive;
      var BoundsContainerHovered = __varRecorder__$17.BoundsContainerHovered;
      __varRecorder__$17.AddButton = AddButton;
      __varRecorder__$17.RemoveButton = RemoveButton;
      __varRecorder__$17.HeadlineLabel = HeadlineLabel;
      __varRecorder__$17.PropLabel = PropLabel;
      __varRecorder__$17.DarkNumberIconWidget = DarkNumberIconWidget;
      __varRecorder__$17.TextInput = TextInput;
      __varRecorder__$17.EnumSelector = EnumSelector;
      __varRecorder__$17.PropertyLabel = PropertyLabel;
      __varRecorder__$17.PropertyLabelLight = PropertyLabelLight;
      __varRecorder__$17.PropertyLabelHovered = PropertyLabelHovered;
      __varRecorder__$17.PropertyLabelHoveredLight = PropertyLabelHoveredLight;
      __varRecorder__$17.PropertyLabelActive = PropertyLabelActive;
      __varRecorder__$17.PropertyLabelActiveLight = PropertyLabelActiveLight;
      __varRecorder__$17.DarkThemeList = DarkThemeList;
      __varRecorder__$17.DarkFlap = DarkFlap;
      __varRecorder__$17.DarkPopupWindow = DarkPopupWindow;
      __varRecorder__$17.DarkCloseButton = DarkCloseButton;
      __varRecorder__$17.DarkCloseButtonHovered = DarkCloseButtonHovered;
      __varRecorder__$17.BoundsContainerInactive = BoundsContainerInactive;
      __varRecorder__$17.BoundsContainerHovered = BoundsContainerHovered;
      __varRecorder__$17.Spinner = Spinner;

      var __varRecorder__$16 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/color-picker.js", __contextModule__);
      __varRecorder__$16.WHEEL_URL = "/lively.ide/assets/color-wheel.png";
      var ColorInputModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/color-picker.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ColorInputModel") && typeof __lively_classholder__.ColorInputModel === "function" ? __lively_classholder__.ColorInputModel : __lively_classholder__.ColorInputModel = function ColorInputModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "__additionally_serialize__",
          value: function ColorInputModel___additionally_serialize___(snapshot, ref, pool, addFn) {
            if (this.colorPickerComponent) {
              var expr = this.colorPickerComponent[Symbol["for"]("lively-module-meta")];
              addFn("colorPickerComponent", pool.expressionSerializer.exprStringEncode({
                __expr__: expr["export"],
                bindings: _defineProperty({}, expr.module, expr["export"])
              }));
            }
          }
        }, {
          key: "isMixed",
          get: function get() {
            var _this$ui = this.ui,
                hexInput = _this$ui.hexInput,
                opacityInput = _this$ui.opacityInput;
            return opacityInput.isMixed || hexInput.input === "Mix";
          }
        }, {
          key: "setMixed",
          value: function ColorInputModel_setMixed_(colors) {
            var _this$ui2 = this.ui,
                hexInput = _this$ui2.hexInput,
                opacityInput = _this$ui2.opacityInput,
                gradient = _this$ui2.gradient;
            if (uniq(colors.map(function (c) {
              return c.a;
            })).length > 1) opacityInput.setMixed();

            if (uniq(colors.map(function (c) {
              return c.toHexString();
            })).length > 1) {
              hexInput.value = "Mix";
              gradient.visible = true;
              gradient.fill = new LinearGradient({
                stops: colors.map(function (color, i) {
                  return {
                    offset: i / colors.length,
                    color: color
                  };
                })
              });
            }

            this.colorValue = colors[0];
          }
        }, {
          key: "setColor",
          value: function ColorInputModel_setColor_(color) {
            this.colorValue = color;
            this.update();
            this.confirm();
          }
        }, {
          key: "attach",
          value: function ColorInputModel_attach_(view) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "attach", this).call(this, view);

            this.update();
          }
        }, {
          key: "update",
          value: function ColorInputModel_update_(control) {
            var color = this.colorValue;
            var _this$ui3 = this.ui,
                hexInput = _this$ui3.hexInput,
                opacityInput = _this$ui3.opacityInput,
                gradientName = _this$ui3.gradientName,
                opaque = _this$ui3.opaque,
                transparent = _this$ui3.transparent,
                gradient = _this$ui3.gradient;
            gradient.visible = !!color.isGradient;
            opacityInput.visible = hexInput.visible = !color.isGradient;
            gradientName.visible = !!color.isGradient;

            if (!color.isGradient) {
              if (hexInput !== control) hexInput.input = color.toHexString().toUpperCase();
              if (opacityInput !== control) opacityInput.number = color.a;
              opaque.fill = color.withA(1);
              transparent.fill = color;
            } else {
              gradient.fill = color;
              if (color.type === "radialGradient") gradient.fill = new RadialGradient(Object.assign({}, color, {
                bounds: color.bounds.scaleRectTo(rect(0, 0, 22, 22))
              }));
              gradientName.textString = capitalize(color.type.replace("Gradient", ""));
            }
          }
        }, {
          key: "closeColorPicker",
          value: function ColorInputModel_closeColorPicker_() {
            if (this.picker) {
              this.picker.remove();
              this.picker = null;
              this.onPickerClosed();
            }
          }
        }, {
          key: "openColorPicker",
          value: function () {
            var _ColorInputModel_openColorPicker_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var ColorPicker, p, color;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      ColorPicker = this.colorPickerComponent;

                      if (ColorPicker) {
                        _context.next = 7;
                        break;
                      }

                      _context.next = 4;
                      return Promise.resolve().then(function () { return colorPicker_cp; });

                    case 4:
                      __varRecorder__$16.__inter0__ = _context.sent;
                      ColorPicker = __varRecorder__$16.__inter0__.ColorPicker;
                      __varRecorder__$16.__inter0__;

                    case 7:
                      p = part(ColorPicker);
                      color = this.colorValue;
                      p.solidOnly = !this.gradientEnabled;
                      p.hasFixedPosition = true;
                      if (this.targetMorph) p.focusOnMorph(this.targetMorph, color);else p.withColor(color);
                      p.toggleHalos(false);
                      p.position = pt(0, -p.height / 2);
                      p.switchMode(color.isGradient ? color.type : "Solid");
                      connect(p, "value", this, "setColor");
                      connect(p, "close", this, "onPickerClosed");
                      connect(p, "closeWithClick", this, "onPickerClosedWithClick");
                      this.view.fill = this.activeColor;
                      this.picker = p.openInWorld();
                      this.picker.topRight = this.view.globalBounds().topLeft();
                      this.picker.topLeft = this.world().visibleBounds().insetBy(10).translateForInclusion(this.picker.globalBounds()).topLeft();

                    case 22:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function ColorInputModel_openColorPicker_() {
              return _ColorInputModel_openColorPicker_.apply(this, arguments);
            }

            return ColorInputModel_openColorPicker_;
          }()
        }, {
          key: "onPickerClosedWithClick",
          value: function ColorInputModel_onPickerClosedWithClick_() {
            signal(this.view, "onPickerClosedWithClick");
            this.onPickerClosed();
          }
        }, {
          key: "onPickerClosed",
          value: function ColorInputModel_onPickerClosed_() {
            this.view.fill = Color.transparent;
          }
        }, {
          key: "onHexChanged",
          value: function ColorInputModel_onHexChanged_() {
            this.confirm();
            this.update(this.ui.hexInput);
          }
        }, {
          key: "onOpacityChanged",
          value: function ColorInputModel_onOpacityChanged_() {
            this.confirm();
            this.update(this.ui.opacityInput);
          }
        }, {
          key: "confirm",
          value: function ColorInputModel_confirm_() {
            var _this$ui4 = this.ui,
                hexInput = _this$ui4.hexInput,
                opacityInput = _this$ui4.opacityInput,
                gradientName = _this$ui4.gradientName;
            var currentColor = this.isMixed ? this.colorValue : Color.rgbHex(hexInput.input);
            if (!gradientName.visible) this.colorValue = currentColor.withA(opacityInput.number);
            signal(this.view, "color", this.colorValue);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ColorInputModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              targetMorph: {},
              colorPickerComponent: {
                isComponent: true
              },
              gradientEnabled: {
                defaultValue: false,
                after: ["colorValue"]
              },
              activeColor: {
                isStyleProp: true,
                defaultValue: Color.gray.withA(0.5)
              },
              colorValue: {
                set: function set(v) {
                  if (!(v && (v.isColor || v.isGradient))) {
                    v = Color.blue;
                  }

                  this.setProperty("colorValue", v);
                },
                get: function get() {
                  return this.getProperty("colorValue") || Color.white;
                }
              },
              expose: {
                get: function get() {
                  return ["setColor", "colorValue", "setMixed"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "hex input",
                    signal: "inputAccepted",
                    handler: "onHexChanged"
                  }, {
                    target: "opacity input",
                    signal: "number",
                    handler: "onOpacityChanged"
                  }, {
                    target: "color cell",
                    signal: "onMouseDown",
                    handler: "openColorPicker"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./styling/color-picker.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 479,
          end: 5602
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$16.ColorInputModel = ColorInputModel;
      __varRecorder__$16.ColorInputModel = ColorInputModel;
      var ColorPaletteView = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/color-picker.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ColorPaletteView") && typeof __lively_classholder__.ColorPaletteView === "function" ? __lively_classholder__.ColorPaletteView : __lively_classholder__.ColorPaletteView = function ColorPaletteView(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "test",
          value: function ColorPaletteView_test_() {
            this.showPalette(materialDesignColors.map(function (c) {
              return Color.rgbHex(c);
            }));
          }
        }, {
          key: "selectPalette",
          value: function ColorPaletteView_selectPalette_(paletteName) {
            var nameToPalette = {
              "Flat Design": flatDesignColors,
              Material: materialDesignColors,
              "Web Safe": webSafeColors
            };
            nameToPalette[paletteName] && this.showPalette(nameToPalette[paletteName].map(function (c) {
              return Color.rgbHex(c);
            }));
          }
        }, {
          key: "onMouseDown",
          value: function ColorPaletteView_onMouseDown_(evt) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onMouseDown", this).call(this, evt);

            var color = evt.domEvt.target.dataset.color;
            if (!color) return;
            signal(this, "colorSelected", Color.fromString(color));
          }
        }, {
          key: "showPalette",
          value: function ColorPaletteView_showPalette_(colors) {
            var _this = this;

            this.withMetaDo({
              metaInteraction: true
            }, function () {
              _this.html = "<div class=\"palette-container\">\n      ".concat(colors.map(function (c) {
                return "<div class=\"color-cell\" data-color=\"".concat(c, "\" style=\"background: ").concat(c, "\"></div>");
              }).join("\n"), "\n    </div>");
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ColorPaletteView";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./styling/color-picker.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 5611,
          end: 6580
        });
      }({
        referencedAs: "HTMLMorph",
        value: HTMLMorph
      });
      __varRecorder__$16.ColorPaletteView = ColorPaletteView;
      __varRecorder__$16.ColorPaletteView = ColorPaletteView;
      var ColorPickerModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/color-picker.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ColorPickerModel") && typeof __lively_classholder__.ColorPickerModel === "function" ? __lively_classholder__.ColorPickerModel : __lively_classholder__.ColorPickerModel = function ColorPickerModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "isPropertiesPanelPopup",
          get: function get() {
            return true;
          }
        }, {
          key: "isColorPicker",
          get: function get() {
            return true;
          }
        }, {
          key: "triggerEyeDropper",
          value: function () {
            var _ColorPickerModel_triggerEyeDropper_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
              var chosenColor;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return new window.EyeDropper().open();

                    case 2:
                      chosenColor = _context2.sent;
                      this.adjustColor(Color.fromString(chosenColor.sRGBHex));

                    case 4:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function ColorPickerModel_triggerEyeDropper_() {
              return _ColorPickerModel_triggerEyeDropper_.apply(this, arguments);
            }

            return ColorPickerModel_triggerEyeDropper_;
          }()
        }, {
          key: "toggleHalos",
          value: function ColorPickerModel_toggleHalos_(active) {
            this.view.withAllSubmorphsDo(function (m) {
              return m.halosEnabled = active;
            });
          }
        }, {
          key: "withColor",
          value: function ColorPickerModel_withColor_(color) {
            if (color.isGradient) {
              this.models.gradientControl.setGradient(color, this);
              this.models.colorTypeSelector.selection = color.type;
            } else {
              this.color = color;
              this.ui.colorTypeSelector.selection = "Solid";
            }

            this.switchPalette("Material");
            this.update();
          }
        }, {
          key: "focusOnMorph",
          value: function ColorPickerModel_focusOnMorph_(aMorph, color) {
            this._target = aMorph;
            var context = this.context;

            if (context) {
              if (!color.isColor) noUpdate(function () {
                return context.halos().forEach(function (m) {
                  return m.remove();
                });
              });
              context.withTopBarDo(function (topBar) {
                topBar.setEditMode("Hand", true, true);
              });
            }

            this.withColor(color);
          }
        }, {
          key: "close",
          value: function ColorPickerModel_close_() {
            if (this.embedded) return;
            this.view.remove();
            var context = this.context;
            if (context) context.withTopBarDo(function (topBar) {
              return topBar.setEditMode(topBar.view.recoverMode, true);
            });
            this.ui.gradientControl.toggle(false, this);
          }
        }, {
          key: "closeWithClick",
          value: function ColorPickerModel_closeWithClick_() {
            var _this2 = this;

            signal(this.view, "closeWithClick");
            noUpdate(function () {
              return _this2.close();
            });
          }
        }, {
          key: "confirm",
          value: function ColorPickerModel_confirm_() {
            switch (this.colorMode) {
              case "linearGradient":
              case "radialGradient":
                signal(this, "value", this.gradientValue);
                signal(this.view, "value", this.gradientValue);
                break;

              case "Solid":
                signal(this, "value", this.color);
                signal(this.view, "value", this.color);
            }
          }
        }, {
          key: "switchPalette",
          value: function ColorPickerModel_switchPalette_(palette) {
            this.ui.colorPaletteView.selectPalette(palette);
          }
        }, {
          key: "switchMode",
          value: function ColorPickerModel_switchMode_(newMode) {
            var _this3 = this;

            var isGradient = ["linearGradient", "radialGradient"].includes(newMode);
            if (isGradient) noUpdate(function () {
              return _this3.context.halos().forEach(function (m) {
                return m.remove();
              });
            });else {
              if (!this.embedded && this._target) {
                noUpdate(function () {
                  return $world.showHaloFor(_this3._target);
                });
              }
            }
            this.ui.gradientControl.toggle(isGradient, this);
            this.colorMode = newMode;
            this.update();
            this.confirm();
          }
        }, {
          key: "enterColor",
          value: function ColorPickerModel_enterColor_(hsb) {
            this.hsb = hsb;
            this.update(this.models.colorEncoding);
            this.confirm();
          }
        }, {
          key: "adjustColor",
          value: function ColorPickerModel_adjustColor_(c) {
            this.color = c;
            this.update();
            this.confirm();
          }
        }, {
          key: "adjustOpacity",
          value: function ColorPickerModel_adjustOpacity_(a) {
            this.hsb = [].concat(_toConsumableArray$1(this.hsb.slice(0, 3)), [a]);
            this.update(this.models.opacityPicker);
            this.confirm();
          }
        }, {
          key: "adjustHue",
          value: function ColorPickerModel_adjustHue_(hue) {
            this.hsb = [hue].concat(_toConsumableArray$1(this.hsb.slice(1)));
            this.update(this.models.huePicker);
            this.confirm();
          }
        }, {
          key: "adjustShade",
          value: function ColorPickerModel_adjustShade_(_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                brt = _ref2[0],
                sat = _ref2[1];

            this.hsb = [this.hsb[0], sat, brt, this.hsb[3]];
            this.update(this.models.shadePicker);
            this.confirm();
          }
        }, {
          key: "adjustGradient",
          value: function ColorPickerModel_adjustGradient_(gradientValue) {
            this.confirm();
          }
        }, {
          key: "update",
          value: function ColorPickerModel_update_() {
            var _this4 = this;

            for (var _len = arguments.length, toSkip = new Array(_len), _key = 0; _key < _len; _key++) {
              toSkip[_key] = arguments[_key];
            }

            withoutAll(this.allControls, [].concat(toSkip)).forEach(function (m) {
              return m.update(_this4);
            });
          }
        }, {
          key: "viewDidLoad",
          value: function ColorPickerModel_viewDidLoad_() {
            var eyeDropperButton = this.ui.eyeDropperButton;
            if (!window.EyeDropper) eyeDropperButton.visible = eyeDropperButton.isLayoutable = false;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ColorPickerModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              isHaloItem: {
                defaultValue: true
              },
              embedded: {
                defaultValue: false
              },
              colorMode: {},
              context: {
                serialize: false,
                get: function get() {
                  return this._target && (this._target._context || this._target.world());
                }
              },
              hsb: {
                initialize: function initialize() {
                  this.hsb = [].concat(_toConsumableArray$1(Color.red.toHSB()), [1]);
                }
              },
              gradientValue: {
                derived: true,
                get: function get() {
                  var gc = this.models.gradientControl;
                  return gc.deref(gc.gradientValue);
                },
                set: function set(v) {
                  this.models.gradientControl.gradientValue = v;
                }
              },
              color: {
                derived: true,
                get: function get() {
                  return Color.hsb.apply(Color, _toConsumableArray$1(this.hsb.slice(0, 3))).withA(this.hsb[3]);
                },
                set: function set(c) {
                  this.hsb = [].concat(_toConsumableArray$1(c.toHSB()), [c.a]);
                }
              },
              solidOnly: {
                derived: true,
                set: function set(active) {
                  var _this$ui5 = this.ui,
                      colorTypeSelector = _this$ui5.colorTypeSelector,
                      title = _this$ui5.title;
                  if (active) colorTypeSelector.selection = "Solid";
                  colorTypeSelector.visible = !active;

                  if (active) {
                    title.visible = true;
                    title.textString = "Color";
                  }
                }
              },
              allControls: {
                derived: true,
                get: function get() {
                  var _this$models = this.models,
                      colorEncoding = _this$models.colorEncoding,
                      opacityPicker = _this$models.opacityPicker,
                      shadePicker = _this$models.shadePicker,
                      huePicker = _this$models.huePicker,
                      gradientControl = _this$models.gradientControl;
                  return [colorEncoding, opacityPicker, shadePicker, huePicker, gradientControl];
                }
              },
              expose: {
                get: function get() {
                  return ["solidOnly", "focusOnMorph", "toggleHalos", "isHaloItem", "close", "isPropertiesPanelPopup", "isColorPicker", "withColor", "switchMode", "value", "closeWithClick"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "color type selector",
                    signal: "selection",
                    handler: "switchMode"
                  }, {
                    target: "color palette selector",
                    signal: "selection",
                    handler: "switchPalette"
                  }, {
                    target: "color palette view",
                    signal: "colorSelected",
                    handler: "adjustColor"
                  }, {
                    target: "gradient control",
                    signal: "gradientChanged",
                    handler: "adjustGradient"
                  }, {
                    target: "gradient control",
                    signal: "switchColor",
                    handler: "adjustColor"
                  }, {
                    target: "color encoding",
                    signal: "colorEntered",
                    handler: "enterColor"
                  }, {
                    target: "hue picker",
                    signal: "hueChanged",
                    handler: "adjustHue"
                  }, {
                    target: "opacity picker",
                    signal: "opacityChanged",
                    handler: "adjustOpacity"
                  }, {
                    target: "shade picker",
                    signal: "shadeChanged",
                    handler: "adjustShade"
                  }, {
                    target: "close button",
                    signal: "onMouseUp",
                    handler: "closeWithClick"
                  }, {
                    target: "eye dropper button",
                    signal: "onMouseDown",
                    handler: "triggerEyeDropper"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./styling/color-picker.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 6648,
          end: 13440
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$16.ColorPickerModel = ColorPickerModel;
      __varRecorder__$16.ColorPickerModel = ColorPickerModel;
      var ColorEncoderModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/color-picker.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ColorEncoderModel") && typeof __lively_classholder__.ColorEncoderModel === "function" ? __lively_classholder__.ColorEncoderModel : __lively_classholder__.ColorEncoderModel = function ColorEncoderModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "copyColor",
          value: function ColorEncoderModel_copyColor_() {
            var _this5 = this;

            guardNamed("copying", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
              var originalFontColor, currentColor;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      originalFontColor = _this5.ui.colorCopier.fontColor;
                      currentColor = Color.hsb(_this5.currentColor[0], _this5.currentColor[1], _this5.currentColor[2]).withA(_this5.currentColor[3]);
                      navigator.clipboard.writeText(currentColor.__serialize__().__expr__);
                      _context3.next = 5;
                      return _this5.ui.colorCopier.animate({
                        fontColor: Color.green,
                        duration: 500
                      }).then(function () {
                        return delay(2000);
                      }).then(function () {
                        return _this5.ui.colorCopier.animate({
                          fontColor: originalFontColor,
                          duration: 500
                        });
                      });

                    case 5:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3);
            })))();
          }
        }, {
          key: "update",
          value: function ColorEncoderModel_update_(colorPicker) {
            this.currentColor = colorPicker.hsb;
            this.refresh();
          }
        }, {
          key: "refresh",
          value: function ColorEncoderModel_refresh_() {
            var _this6 = this;

            var color = this.currentColor;
            noUpdate(function () {
              ({
                HEX: function HEX() {
                  return _this6.updateHex(color);
                },
                RGB: function RGB() {
                  return _this6.updateRGB(color);
                },
                HSL: function HSL() {
                  return _this6.updateHSL(color);
                },
                HSB: function HSB() {
                  return _this6.updateHSB(color);
                },
                CSS: function CSS() {
                  return _this6.updateCSS(color);
                }
              })[_this6.encodingMode]();
            });
          }
        }, {
          key: "updateHex",
          value: function ColorEncoderModel_updateHex_(color) {
            color = Color.hsb.apply(Color, _toConsumableArray$1(color)).withA(roundTo(color[3], 0.01));
            var hexInput = this.ui.hexInput;
            var hexOpacity = this.ui.hexOpacityControl;
            hexInput.input = color.toHexString().toUpperCase();
            hexOpacity.number = color.a;
          }
        }, {
          key: "updateRGB",
          value: function ColorEncoderModel_updateRGB_(color) {
            var rInput = this.ui.firstValue;
            var gInput = this.ui.secondValue;
            var bInput = this.ui.thirdValue;
            var aInput = this.ui.opacityControl;

            var _Color$hsb$toTuple = Color.hsb.apply(Color, _toConsumableArray$1(color)).toTuple(),
                _Color$hsb$toTuple2 = _slicedToArray(_Color$hsb$toTuple, 3),
                r = _Color$hsb$toTuple2[0],
                g = _Color$hsb$toTuple2[1],
                b = _Color$hsb$toTuple2[2];

            var a = color[3];
            rInput.number = r * 255;
            gInput.number = g * 255;
            bInput.number = b * 255;
            aInput.number = a;
          }
        }, {
          key: "updateHSL",
          value: function ColorEncoderModel_updateHSL_(color) {
            var hsl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var hInput = this.ui.firstValue;
            var sInput = this.ui.secondValue;
            var lInput = this.ui.thirdValue;
            var aInput = this.ui.opacityControl;

            var _color = _slicedToArray(color, 3),
                h = _color[0],
                s = _color[1],
                b = _color[2];

            if (hsl) lInput.number = 1 - b;else lInput.number = b;
            hInput.number = h;
            sInput.number = s;
            aInput.number = color[3];
          }
        }, {
          key: "updateHSB",
          value: function ColorEncoderModel_updateHSB_(color) {
            this.updateHSL(color, false);
          }
        }, {
          key: "updateCSS",
          value: function ColorEncoderModel_updateCSS_(color) {
            var cssInput = this.ui.cssInput;
            color = Color.hsb.apply(Color, _toConsumableArray$1(color)).withA(roundTo(color[3], 0.01));
            cssInput.input = color.toCSSString();
          }
        }, {
          key: "confirm",
          value: function ColorEncoderModel_confirm_() {
            var _this7 = this;

            ({
              HEX: function HEX() {
                return _this7.confirmHex();
              },
              RGB: function RGB() {
                return _this7.confirmRGB();
              },
              HSL: function HSL() {
                return _this7.confirmHSL();
              },
              HSB: function HSB() {
                return _this7.confirmHSB();
              },
              CSS: function CSS() {
                return _this7.confirmCSS();
              }
            })[this.encodingMode]();
          }
        }, {
          key: "confirmHex",
          value: function ColorEncoderModel_confirmHex_() {
            var hexInput = this.ui.hexInput;
            var hexOpacity = this.ui.hexOpacityControl;
            var c = Color.rgbHex(hexInput.input).withA(hexOpacity.number);
            this.currentColor = [].concat(_toConsumableArray$1(c.toHSB()), [c.a]);
            signal(this.view, "colorEntered", this.currentColor);
          }
        }, {
          key: "confirmRGB",
          value: function ColorEncoderModel_confirmRGB_() {
            var rInput = this.ui.firstValue;
            var gInput = this.ui.secondValue;
            var bInput = this.ui.thirdValue;
            var aInput = this.ui.opacityControl;
            var c = Color.rgba(rInput.number, gInput.number, bInput.number, aInput.number);
            this.currentColor = [].concat(_toConsumableArray$1(c.toHSB()), [c.a]);
            signal(this.view, "colorEntered", this.currentColor);
          }
        }, {
          key: "confirmHSL",
          value: function ColorEncoderModel_confirmHSL_() {
            var hInput = this.ui.firstValue;
            var sInput = this.ui.secondValue;
            var lInput = this.ui.thirdValue;
            var aInput = this.ui.opacityControl;
            this.currentColor = [hInput.number, sInput.number, 1 - lInput.number, aInput.number];
            signal(this.view, "colorEntered", this.currentColor);
          }
        }, {
          key: "confirmHSB",
          value: function ColorEncoderModel_confirmHSB_() {
            var hInput = this.ui.firstValue;
            var sInput = this.ui.secondValue;
            var bInput = this.ui.thirdValue;
            var aInput = this.ui.opacityControl;
            this.currentColor = [hInput.number, sInput.number, bInput.number, aInput.number];
            signal(this.view, "colorEntered", this.currentColor);
          }
        }, {
          key: "confirmCSS",
          value: function ColorEncoderModel_confirmCSS_() {
            var cssInput = this.ui.cssInput;
            var c = Color.fromString(cssInput.input);
            this.currentColor = [].concat(_toConsumableArray$1(c.toHSB()), [c.a]);
            signal(this.view, "colorEntered", this.currentColor);
          }
        }, {
          key: "selectEncoding",
          value: function ColorEncoderModel_selectEncoding_(encodingName) {
            var nameToUI = {
              HEX: "hexEncoding",
              RGB: "3ValEncoding",
              HSL: "3ValEncoding",
              HSB: "3ValEncoding",
              CSS: "cssEncoding"
            };
            this.encodingMode = encodingName;
            this.ui.controls.submorphs.map(function (m) {
              return m.visible = m.isLayoutable = false;
            });
            var control = this.ui[nameToUI[encodingName]];
            control.visible = control.isLayoutable = true;

            if (encodingName === "RGB") {
              [control.getSubmorphNamed("first value"), control.getSubmorphNamed("second value"), control.getSubmorphNamed("third value")].forEach(function (aNumberInput) {
                Object.assign(aNumberInput, {
                  min: 0,
                  max: 255,
                  scaleFactor: 1
                });
              });
            }

            if (["HSL", "HSB"].includes(encodingName)) {
              Object.assign(control.getSubmorphNamed("first value"), {
                min: 0,
                max: 360,
                scaleFactor: 1
              });
              [control.getSubmorphNamed("second value"), control.getSubmorphNamed("third value")].forEach(function (aNumberInput) {
                Object.assign(aNumberInput, {
                  min: 0,
                  max: 1,
                  scaleFactor: 100
                });
              });
            }

            this.refresh();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ColorEncoderModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              encodingMode: {
                type: "Enum",
                defaultValue: "HEX",
                values: ["HEX", "RGB", "HSL", "HSB", "CSS"]
              },
              currentColor: {
                defaultValue: [].concat(_toConsumableArray$1(Color.white.toHSB()), [1])
              },
              bindings: {
                get: function get() {
                  var numberWidgets = ["opacity control", "first value", "second value", "third value", "hex opacity control"];
                  return [{
                    target: "color code selector",
                    signal: "selection",
                    handler: "selectEncoding"
                  }, {
                    target: "hex input",
                    signal: "inputAccepted",
                    handler: "confirm"
                  }, {
                    target: "css input",
                    signal: "inputAccepted",
                    handler: "confirm"
                  }].concat(_toConsumableArray$1(numberWidgets.map(function (target) {
                    return {
                      target: target,
                      signal: "number",
                      handler: "confirm"
                    };
                  })), [{
                    target: "color copier",
                    signal: "onMouseDown",
                    handler: "copyColor"
                  }]);
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./styling/color-picker.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 13449,
          end: 19795
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$16.ColorEncoderModel = ColorEncoderModel;
      __varRecorder__$16.ColorEncoderModel = ColorEncoderModel;
      var FieldPickerModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/color-picker.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("FieldPickerModel") && typeof __lively_classholder__.FieldPickerModel === "function" ? __lively_classholder__.FieldPickerModel : __lively_classholder__.FieldPickerModel = function FieldPickerModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onRefresh",
          value: function FieldPickerModel_onRefresh_(changedProp) {
            this.ui.picker.center = this.pickerPosition;
          }
        }, {
          key: "relayout",
          value: function FieldPickerModel_relayout_() {
            var _this$ui6 = this.ui,
                hue = _this$ui6.hue,
                shade = _this$ui6.shade,
                light = _this$ui6.light;
            var bounds = this.view.innerBounds();
            hue.setBounds(bounds);
            shade.setBounds(bounds);
            light.setBounds(bounds);
          }
        }, {
          key: "confirm",
          value: function FieldPickerModel_confirm_() {
            signal(this.view, "shadeChanged", [this.brightness, this.saturation]);
          }
        }, {
          key: "update",
          value: function FieldPickerModel_update_(colorPicker) {
            var _colorPicker$hsb = _slicedToArray(colorPicker.hsb, 3),
                hue = _colorPicker$hsb[0],
                srt = _colorPicker$hsb[1],
                brt = _colorPicker$hsb[2];

            this.ui.hue.fill = Color.hsb(hue, 1, 1);
            this.brightness = brt;
            this.saturation = srt;
          }
        }, {
          key: "onMouseDown",
          value: function FieldPickerModel_onMouseDown_($onMouseDown, evt) {
            this.pickerPosition = evt.positionIn(this.view);
            this.confirm();
          }
        }, {
          key: "onDrag",
          value: function FieldPickerModel_onDrag_($onDrag, evt) {
            this.pickerPosition = evt.positionIn(this.view);
            this.confirm();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "FieldPickerModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              saturation: {
                defaultValue: 0
              },
              brightness: {
                defaultValue: 0
              },
              pickerPosition: {
                derived: true,
                after: ["brightness", "saturation"],
                get: function get() {
                  var _this$view = this.view,
                      width = _this$view.width,
                      height = _this$view.height;
                  var s = this.saturation;
                  var b = this.brightness;
                  if (s === undefined || b === undefined) return pt(0, 0);
                  return pt(width * s, height * (1 - b));
                },
                set: function set(_ref4) {
                  var light = _ref4.x,
                      dark = _ref4.y;
                  var _this$view2 = this.view,
                      width = _this$view2.width,
                      height = _this$view2.height;
                  this.saturation = clamp(light / width, 0, 1);
                  this.brightness = clamp(1 - dark / height, 0, 1);
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    signal: "extent",
                    handler: "relayout"
                  }, {
                    signal: "onDrag",
                    handler: "onDrag",
                    override: true
                  }, {
                    signal: "onMouseDown",
                    handler: "onMouseDown",
                    override: true
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./styling/color-picker.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 19804,
          end: 21710
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$16.FieldPickerModel = FieldPickerModel;
      __varRecorder__$16.FieldPickerModel = FieldPickerModel;

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/color-picker.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("AbstractSlider") && typeof __lively_classholder__.AbstractSlider === "function" ? __lively_classholder__.AbstractSlider : __lively_classholder__.AbstractSlider = function AbstractSlider(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "confirm",
          value: function AbstractSlider_confirm_() {}
        }, {
          key: "onMouseDown",
          value: function AbstractSlider_onMouseDown_($onMouseDown, evt) {
            var sliderWidth = this.ui.slider.width;
            var maxX = this.view.width - sliderWidth / 2;
            this.sliderPosition = pt(clamp(evt.positionIn(this.view).x - sliderWidth / 2, 0, maxX), 0);
            this.confirm();
          }
        }, {
          key: "onDrag",
          value: function AbstractSlider_onDrag_($onDrag, evt) {
            var sliderWidth = this.ui.slider.width;
            var maxX = this.view.width - sliderWidth / 2;
            this.sliderPosition = pt(clamp(evt.positionIn(this.view).x - sliderWidth / 2, 0, maxX), 0);
            this.confirm();
          }
        }, {
          key: "update",
          value: function AbstractSlider_update_(colorPicker) {}
        }, {
          key: "onRefresh",
          value: function AbstractSlider_onRefresh_(prop) {
            this.ui.slider.center = this.sliderPosition;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "AbstractSlider";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              alpha: {
                defaultValue: 1
              },
              sliderPosition: {},
              bindings: {
                get: function get() {
                  return [{
                    signal: "onMouseDown",
                    handler: "onMouseDown",
                    override: true
                  }, {
                    signal: "onDrag",
                    handler: "onDrag",
                    override: true
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./styling/color-picker.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 21712,
          end: 22877
        });
      })({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      var OpacityPickerModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/color-picker.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("OpacityPickerModel") && typeof __lively_classholder__.OpacityPickerModel === "function" ? __lively_classholder__.OpacityPickerModel : __lively_classholder__.OpacityPickerModel = function OpacityPickerModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "confirm",
          value: function OpacityPickerModel_confirm_() {
            signal(this.view, "opacityChanged", this.alpha);
          }
        }, {
          key: "update",
          value: function OpacityPickerModel_update_(colorPicker) {
            this.ui.opacityGradient.fill = new LinearGradient({
              vector: "eastwest",
              stops: [{
                offset: 0,
                color: colorPicker.color.withA(0)
              }, {
                offset: 1,
                color: colorPicker.color.withA(1)
              }]
            });
            this.alpha = colorPicker.color.a;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "OpacityPickerModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              alpha: {
                defaultValue: 1
              },
              sliderPosition: {
                derived: true,
                get: function get() {
                  var view = this.view;
                  var sliderWidth = this.ui.slider.width;
                  var w = view.width - sliderWidth;
                  return pt(sliderWidth / 2 + w * this.alpha, view.height / 2);
                },
                set: function set(pos) {
                  if (!this.view) return;
                  var view = this.view;
                  var sliderWidth = this.ui.slider.width;
                  var w = view.width - sliderWidth / 2;
                  this.alpha = clamp(pos.x / w, 0, 1);
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./styling/color-picker.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 22886,
          end: 23967
        });
      }(__varRecorder__$16.AbstractSlider);
      __varRecorder__$16.OpacityPickerModel = OpacityPickerModel;
      __varRecorder__$16.OpacityPickerModel = OpacityPickerModel;
      var HuePickerModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/color-picker.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("HuePickerModel") && typeof __lively_classholder__.HuePickerModel === "function" ? __lively_classholder__.HuePickerModel : __lively_classholder__.HuePickerModel = function HuePickerModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "confirm",
          value: function HuePickerModel_confirm_() {
            signal(this.view, "hueChanged", this.hue);
          }
        }, {
          key: "update",
          value: function HuePickerModel_update_(colorPicker) {
            this.hue = colorPicker.hsb[0];
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "HuePickerModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              hue: {
                defaultValue: 0
              },
              sliderPosition: {
                derived: true,
                get: function get() {
                  var view = this.view;
                  var sliderWidth = this.ui.slider.width;
                  var w = view.width - sliderWidth;
                  return pt(sliderWidth / 2 + w * (this.hue / 360), view.height / 2);
                },
                set: function set(pos) {
                  if (!this.view) return;
                  var view = this.view;
                  var sliderWidth = this.ui.slider.width;
                  var w = view.width - sliderWidth / 2;
                  this.hue = Math.max(0, Math.min(pos.x / w * 360, 359));
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./styling/color-picker.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 23976,
          end: 24801
        });
      }(__varRecorder__$16.AbstractSlider);
      __varRecorder__$16.HuePickerModel = HuePickerModel;
      __varRecorder__$16.HuePickerModel = HuePickerModel;

      var __varRecorder__$15 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/color-stops.cp.js", __contextModule__);
      var ColorStopControl = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/color-stops.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ColorStopControl") && typeof __lively_classholder__.ColorStopControl === "function" ? __lively_classholder__.ColorStopControl : __lively_classholder__.ColorStopControl = function ColorStopControl(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onDragStart",
          value: function ColorStopControl_onDragStart_(evt) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onDragStart", this).call(this, evt);

            this.bringToFront();
          }
        }, {
          key: "onDrag",
          value: function ColorStopControl_onDrag_(evt) {
            var delta = this.getGlobalTransform().inverse().transformDirection(evt.state.dragDelta);
            signal(this, "moveColorStop", [this.stop, delta.x]);
          }
        }, {
          key: "forStop",
          value: function ColorStopControl_forStop_(stop) {
            this.stop = stop;
            this.refresh();
            return this;
          }
        }, {
          key: "refresh",
          value: function ColorStopControl_refresh_(changedProp) {
            if (this.stop) {
              this.ui.transparent.fill = this.stop.color;
              this.ui.opaque.fill = this.stop.color.withA(1);
            }

            if (changedProp === "isSelected") {
              this.master.setState(this.isSelected ? "selected" : null);
            }
          }
        }, {
          key: "positionIn",
          value: function ColorStopControl_positionIn_(gradientEditor) {
            this.bottomCenter = gradientEditor.getPositionFor(this.stop);
          }
        }, {
          key: "onKeyDown",
          value: function ColorStopControl_onKeyDown_(evt) {
            if (evt.keyCombo === "Delete") {
              this.editor.removeStop(this);
            }
          }
        }, {
          key: "onMouseDown",
          value: function ColorStopControl_onMouseDown_(evt) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onMouseDown", this).call(this, evt);

            this.select(this);
          }
        }, {
          key: "select",
          value: function ColorStopControl_select_() {
            this.isSelected = true;
            this.refresh("isSelected");
          }
        }, {
          key: "deselect",
          value: function ColorStopControl_deselect_() {
            this.isSelected = false;
            this.refresh("isSelected");
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ColorStopControl";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              editor: {},
              stop: {},
              isSelected: {},
              isColorStop: {
                readOnly: true,
                get: function get() {
                  return true;
                }
              },
              tooltip: {
                derived: true,
                get: function get() {
                  var _this$editor, _this$editor$gradient;

                  return ((_this$editor = this.editor) === null || _this$editor === void 0 ? void 0 : (_this$editor$gradient = _this$editor.gradientValue) === null || _this$editor$gradient === void 0 ? void 0 : _this$editor$gradient.stops.length) > 2 ? "Press " + KeyHandler.prettyCombo("Delete") + " to remove this color stop from the gradient." : "";
                }
              },
              ui: {
                get: function get() {
                  return {
                    transparent: this.getSubmorphNamed("transparent"),
                    opaque: this.getSubmorphNamed("opaque")
                  };
                }
              },
              expose: {
                get: function get() {
                  return ["tooltip"];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./styling/color-stops.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 265,
          end: 2098
        });
      }({
        referencedAs: "Polygon",
        value: Polygon
      });
      __varRecorder__$15.ColorStopControl = ColorStopControl;
      __varRecorder__$15.ColorStopControl = ColorStopControl;
      __varRecorder__$15.ColorCell = component["for"](function () {
        return component({
          name: "color cell",
          borderRadius: 1,
          borderWidth: 2,
          clipMode: "hidden",
          extent: pt(20, 20),
          submorphs: [part(CheckerPattern, {
            name: "checker pattern",
            extent: pt(25.3, 25.3)
          }), {
            name: "opaque",
            borderColor: Color.rgb(23, 160, 251),
            extent: pt(9, 18),
            fill: Color.rgb(255, 0, 0),
            position: pt(1.2, 1.2)
          }, {
            name: "transparent",
            borderColor: Color.rgb(23, 160, 251),
            extent: pt(9, 18),
            position: pt(9.6, 1),
            fill: Color.rgba(255, 0, 0, 0.38)
          }]
        });
      }, {
        module: "lively.ide/styling/color-stops.cp.js",
        "export": "ColorCell",
        range: {
          start: 2106,
          end: 2669
        }
      }, System, __varRecorder__$15, "ColorCell");
      __varRecorder__$15.ColorStop = component["for"](function () {
        return component({
          type: __varRecorder__$15.ColorStopControl,
          name: "color stop",
          borderColor: Color.rgb(127, 140, 141),
          borderWidth: 1,
          draggable: true,
          extent: pt(24, 28.7),
          tooltip: "Color stop of this gradient.\nDrag to move its relative\nposition within the gradient.",
          submorphs: [part(__varRecorder__$15.ColorCell, {
            name: "color cell",
            position: pt(2, 2)
          })],
          vertices: [{
            position: pt(15.900091422187336, 24.046753447613565),
            isSmooth: false,
            controlPoints: {
              next: pt(0, 0),
              previous: pt(0, 0)
            }
          }, {
            position: pt(12.388537571189591, 28.736349637681194),
            isSmooth: false,
            controlPoints: {
              next: pt(0, 0),
              previous: pt(0, 0)
            }
          }, {
            position: pt(9.05093221433844, 24.003533970295216),
            isSmooth: false,
            controlPoints: {
              next: pt(0, 0),
              previous: pt(0, 0)
            }
          }, {
            position: pt(1.9148586677257027, 24.02187830995731),
            isSmooth: false,
            controlPoints: {
              next: pt(0, 0),
              previous: pt(0, 0)
            }
          }, {
            position: pt(0, 22.053582048279853),
            isSmooth: false,
            controlPoints: {
              next: pt(0, 0),
              previous: pt(0, 0)
            }
          }, {
            position: pt(0.05972529570411431, 1.4675981539758662),
            isSmooth: false,
            controlPoints: {
              next: pt(0, 0),
              previous: pt(0, 0)
            }
          }, {
            position: pt(1.8326500131114984, 0),
            isSmooth: false,
            controlPoints: {
              next: pt(0, 0),
              previous: pt(0, 0)
            }
          }, {
            position: pt(22.327151653198584, 0.06612585476395774),
            isSmooth: false,
            controlPoints: {
              next: pt(0, 0),
              previous: pt(0, 0)
            }
          }, {
            position: pt(23.96388479762493, 1.7146839330382813),
            isSmooth: false,
            controlPoints: {
              next: pt(0, 0),
              previous: pt(0, 0)
            }
          }, {
            position: pt(23.937061469131315, 22.31992067473174),
            isSmooth: false,
            controlPoints: {
              next: pt(0, 0),
              previous: pt(0, 0)
            }
          }, {
            position: pt(22.024226083928863, 24.061687615284562),
            isSmooth: false,
            controlPoints: {
              next: pt(0, 0),
              previous: pt(0, 0)
            }
          }, {
            position: pt(15.926023108578342, 24.053142413825835),
            isSmooth: false,
            controlPoints: {
              next: pt(0, 0),
              previous: pt(0, 0)
            }
          }]
        });
      }, {
        module: "lively.ide/styling/color-stops.cp.js",
        "export": "ColorStop",
        range: {
          start: 2678,
          end: 4601
        }
      }, System, __varRecorder__$15, "ColorStop");
      __varRecorder__$15.SelectedColorStop = component["for"](function () {
        return component(__varRecorder__$15.ColorStop, {
          name: "selected color stop",
          fill: Color.rgb(33, 150, 243),
          borderWidth: 0
        });
      }, {
        module: "lively.ide/styling/color-stops.cp.js",
        "export": "SelectedColorStop",
        range: {
          start: 4610,
          end: 4736
        }
      }, System, __varRecorder__$15, "SelectedColorStop");
      var SelectedColorStop = __varRecorder__$15.SelectedColorStop;
      var ColorStop = __varRecorder__$15.ColorStop;
      var ColorCell = __varRecorder__$15.ColorCell;
      __varRecorder__$15.SelectedColorStop = SelectedColorStop;
      __varRecorder__$15.ColorStop = ColorStop;
      __varRecorder__$15.ColorCell = ColorCell;

      var __varRecorder__$14 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/gradient-editor.cp.js", __contextModule__);
      var GradientHaloModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/gradient-editor.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GradientHaloModel") && typeof __lively_classholder__.GradientHaloModel === "function" ? __lively_classholder__.GradientHaloModel : __lively_classholder__.GradientHaloModel = function GradientHaloModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "reset",
          value: function GradientHaloModel_reset_() {
            this.stopControls.forEach(function (m) {
              return m.remove();
            });
          }
        }, {
          key: "initFromPicker",
          value: function GradientHaloModel_initFromPicker_(picker) {
            this.onActivate();
            var gradient = picker.gradientValue;
            this.picker = picker;

            if (gradient.type === "linearGradient") {
              this.initFromLinearGradient(this.targetMorph, gradient);
            }

            if (gradient.type === "radialGradient") {
              this.initFromRadialGradient(this.targetMorph, gradient);
            }

            this.alignWithTarget();
          }
        }, {
          key: "initFromLinearGradient",
          value: function GradientHaloModel_initFromLinearGradient_(target, linearGradient) {
            var _this$ui = this.ui,
                orthogonalHandle = _this$ui.orthogonalHandle,
                originHandle = _this$ui.originHandle,
                directionHandle = _this$ui.directionHandle;
            var targetBounds = target.innerBounds();
            var theta = linearGradient.vectorAsAngle();
            var c = targetBounds.center();
            var d = Math.max(targetBounds.height, targetBounds.width);
            var br = c.addPt(Point.polar(d, theta));
            var tl = c.subPt(Point.polar(d, theta));

            var _targetBounds$lineInt = targetBounds.lineIntersection(tl.lineTo(br)),
                _targetBounds$lineInt2 = _slicedToArray(_targetBounds$lineInt, 2),
                p1 = _targetBounds$lineInt2[0],
                p2 = _targetBounds$lineInt2[1];

            var directionPoint = min([p1, p2], function (p) {
              return p.dist(br);
            });
            this.originPoint = directionPoint === p1 ? p2 : p1;
            this.directionPoint = directionPoint;
            this.orthogonalDist = min(targetBounds.edges(), function (edge) {
              return edge.distanceFromLine(p2);
            }).length() / 2;
            orthogonalHandle.visible = false;
            originHandle.tooltip = "Drag to adjust the orientation of the linear gradient.";
            directionHandle.tooltip = "Drag to adjust the orientation of the linear gradient.";
            this.alignWithTarget();
          }
        }, {
          key: "initFromRadialGradient",
          value: function GradientHaloModel_initFromRadialGradient_(target, radialGradient) {
            var _this$ui2 = this.ui,
                orthogonalHandle = _this$ui2.orthogonalHandle,
                originHandle = _this$ui2.originHandle,
                directionHandle = _this$ui2.directionHandle;
            var targetBounds = target.innerBounds();
            var originPoint = targetBounds.relativeToAbsPoint(radialGradient.focus);
            var _radialGradient$bound = radialGradient.bounds,
                gradientHeight = _radialGradient$bound.height,
                gradientWidth = _radialGradient$bound.width;
            this.originPoint = originPoint;
            this.directionPoint = originPoint.addXY(0, gradientHeight / 2);
            this.orthogonalDist = gradientWidth / 2;
            orthogonalHandle.visible = true;
            orthogonalHandle.tooltip = "Drag to adjust the horizontal dimension fo the radial gradient.";
            originHandle.tooltip = "Drag to adjust the center of the radial gradient.";
            directionHandle.tooltip = "Drag to adjust the vertical dimension of the radial gradient.";
            this.alignWithTarget();
          }
        }, {
          key: "alignWithTarget",
          value: function GradientHaloModel_alignWithTarget_() {
            var _this$ui3 = this.ui,
                originHandle = _this$ui3.originHandle,
                directionHandle = _this$ui3.directionHandle,
                orthogonalHandle = _this$ui3.orthogonalHandle,
                colorStopWrapper = _this$ui3.colorStopWrapper;
            var view = this.view;
            originHandle.center = pt(0);
            directionHandle.center = pt(view.width, 0);
            view.width = this.originPoint.dist(this.directionPoint);
            colorStopWrapper.width = view.width;
            colorStopWrapper.origin = colorStopWrapper.innerBounds().center();
            directionHandle.center = pt(view.width, 0);
            orthogonalHandle.center = pt(0, this.orthogonalDist);

            if (this.orthogonalDist > 0) {
              colorStopWrapper.tilted = 1;
              colorStopWrapper.position = pt(view.width / 2, view.height / 4 - 1);
            } else {
              colorStopWrapper.tilted = 0;
              colorStopWrapper.position = pt(view.width / 2, -view.height / 4 + 1);
            }

            view.globalPosition = this.targetMorph.worldPoint(this.originPoint).subPt($world.scroll);
            view.rotation = this.angle;
          }
        }, {
          key: "relayout",
          value: function GradientHaloModel_relayout_() {
            this.alignWithTarget();
          }
        }, {
          key: "confirm",
          value: function GradientHaloModel_confirm_() {
            var gradientControl = this.picker.models.gradientControl;

            if (gradientControl.gradientValue.type === "linearGradient") {
              gradientControl.gradientValue.vector = this.angle;
            }

            if (gradientControl.gradientValue.type === "radialGradient") {
              var v = gradientControl.gradientValue;
              var width = Math.abs(this.orthogonalDist) * 2;
              var height = this.originPoint.dist(this.directionPoint) * 2;
              v.focus = this.originPoint.scaleByPt(this.targetMorph.extent.inverted());
              v.bounds = pt(0, 0).extent(pt(width, height));
              v.angle = this.angle;
            }

            gradientControl.confirm();
            this.refresh(gradientControl, this.targetMorph);
            this.alignWithTarget();
          }
        }, {
          key: "normalize",
          value: function GradientHaloModel_normalize_(delta) {
            return this.view.getGlobalTransform().transformDirection(delta);
          }
        }, {
          key: "moveOriginHandle",
          value: function GradientHaloModel_moveOriginHandle_(evt) {
            var delta = this.normalize(evt.state.dragDelta);
            this.originPoint = this.originPoint.addPt(delta);
            this.confirm();
          }
        }, {
          key: "moveDirectionHandle",
          value: function GradientHaloModel_moveDirectionHandle_(evt) {
            var delta = this.normalize(evt.state.dragDelta);
            this.directionPoint = this.directionPoint.addPt(delta);
            this.confirm();
          }
        }, {
          key: "moveOrthogonalHandle",
          value: function GradientHaloModel_moveOrthogonalHandle_(evt) {
            var delta = this.normalize(evt.state.dragDelta);
            this.orthogonalDist -= delta.dotProduct(Point.polar(1, this.angle - Math.PI / 2));
            this.confirm();
          }
        }, {
          key: "moveStop",
          value: function GradientHaloModel_moveStop_(_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                aStop = _ref2[0],
                dx = _ref2[1];

            this.picker.models.gradientControl.adjustStop(aStop, dx / this.ui.colorStopWrapper.width);
          }
        }, {
          key: "refresh",
          value: function GradientHaloModel_refresh_(gradientControl) {
            var _this = this;

            var gradientValue = gradientControl.gradientValue;
            this.alignWithTarget();
            guardNamed("updateGradient", function () {
              gradientControl.updateStopControls(gradientValue.stops, _this);
            })();
          }
        }, {
          key: "placeStop",
          value: function GradientHaloModel_placeStop_(aStopControl) {
            this.ui.colorStopWrapper.addMorph(aStopControl);
          }
        }, {
          key: "selectStop",
          value: function GradientHaloModel_selectStop_(aStopControl) {
            this.picker.models.gradientControl.selectStop(aStopControl);
          }
        }, {
          key: "getPositionFor",
          value: function GradientHaloModel_getPositionFor_(aStop) {
            var wrapper = this.ui.colorStopWrapper;

            var _wrapper$innerBounds$ = wrapper.innerBounds().bottomEdge(),
                start = _wrapper$innerBounds$.start,
                end = _wrapper$innerBounds$.end;

            return start.interpolate(aStop.offset, end).subXY(0, 5).subPt(wrapper.origin);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GradientHaloModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              picker: {},
              targetMorph: {
                derived: true,
                get: function get() {
                  return this.picker._target;
                }
              },
              stopControls: {
                get: function get() {
                  return this.ui.colorStopWrapper.submorphs.filter(function (m) {
                    return m.isColorStop;
                  });
                }
              },
              angle: {
                derived: true,
                get: function get() {
                  return this.directionPoint.subPt(this.originPoint).theta();
                }
              },
              expose: {
                get: function get() {
                  return ["reset", "initFromPicker", "confirm", "refresh", "relayout", "stopControls"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "origin handle",
                    signal: "onDrag",
                    handler: "moveOriginHandle"
                  }, {
                    target: "direction handle",
                    signal: "onDrag",
                    handler: "moveDirectionHandle"
                  }, {
                    target: "orthogonal handle",
                    signal: "onDrag",
                    handler: "moveOrthogonalHandle"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./styling/gradient-editor.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 456,
          end: 7061
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$14.GradientHaloModel = GradientHaloModel;
      __varRecorder__$14.GradientHaloModel = GradientHaloModel;
      __varRecorder__$14.GradientHalo = component["for"](function () {
        return component({
          defaultViewModel: __varRecorder__$14.GradientHaloModel,
          name: "gradient halo",
          borderColor: Color.rgb(23, 160, 251),
          dropShadow: new ShadowObject({
            rotation: 34,
            color: Color.rgba(0, 0, 0, 0.5),
            blur: 12,
            fast: false
          }),
          extent: pt(113.5, 70),
          fill: Color.rgba(0, 0, 0, 0),
          hasFixedPosition: true,
          origin: pt(0, 35),
          submorphs: [{
            name: "color stop wrapper",
            position: pt(56.5, 0.2),
            dropShadow: false,
            extent: pt(113.5, 35.1),
            fill: Color.rgba(0, 0, 0, 0),
            origin: pt(56.7, 17.5),
            tilted: 1
          }, {
            name: "origin handle",
            borderColor: Color.rgb(23, 160, 251),
            borderRadius: 5,
            draggable: true,
            extent: pt(10, 10),
            nativeCursor: "all-scroll"
          }, {
            name: "direction handle",
            borderColor: Color.rgb(23, 160, 251),
            borderRadius: 10,
            draggable: true,
            extent: pt(10, 10),
            nativeCursor: "all-scroll"
          }, {
            name: "orthogonal handle",
            borderColor: Color.rgb(23, 160, 251),
            borderRadius: 10,
            draggable: true,
            extent: pt(10, 10),
            nativeCursor: "all-scroll"
          }]
        });
      }, {
        module: "lively.ide/styling/gradient-editor.cp.js",
        "export": "GradientHalo",
        range: {
          start: 7069,
          end: 8156
        }
      }, System, __varRecorder__$14, "GradientHalo");
      var GradientControlModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/gradient-editor.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GradientControlModel") && typeof __lively_classholder__.GradientControlModel === "function" ? __lively_classholder__.GradientControlModel : __lively_classholder__.GradientControlModel = function GradientControlModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onKeyDown",
          value: function GradientControlModel_onKeyDown_(evt) {
            if (evt.keyCombo === "Delete") {
              this.removeStop(this.selectedStopControl);
            }
          }
        }, {
          key: "onMouseDown",
          value: function GradientControlModel_onMouseDown_(evt) {
            if (evt.targetMorph.name === "gradient preview") {
              var offset = evt.positionIn(evt.targetMorph).x / evt.targetMorph.width;
              this.addStopAt(offset);
            }
          }
        }, {
          key: "removeStop",
          value: function GradientControlModel_removeStop_(aStopControl) {
            if (this.gradientValue.stops.length < 3) return;
            remove(this.gradientValue.stops, aStopControl.stop);
            this.refresh();
            this.confirm();
          }
        }, {
          key: "addStopAt",
          value: function GradientControlModel_addStopAt_(offset) {
            var stops = _toConsumableArray$1(this.gradientValue.stops);

            var _arr$sortBy = sortBy(sortBy(stops, function (stop) {
              return Math.abs(stop.offset - offset);
            }).slice(0, 2), function (stop) {
              return stop.offset;
            }),
                _arr$sortBy2 = _slicedToArray(_arr$sortBy, 2),
                before = _arr$sortBy2[0],
                after = _arr$sortBy2[1];

            var p = (offset - before.offset) / (after.offset - before.offset);
            stops.push({
              color: before.color.interpolate(p, after.color),
              offset: offset
            });
            this.gradientValue.stops = sortBy(stops, function (stop) {
              return stop.offset;
            });
            this.refresh();
            this.confirm();
          }
        }, {
          key: "toggle",
          value: function GradientControlModel_toggle_(active) {
            var view = this.view;
            view.isLayoutable = view.visible = active;

            if (active) {
              this.gradientHalo.openInWorld();
            } else {
              this.gradientHalo.remove();
              this.reset();
            }
          }
        }, {
          key: "reset",
          value: function GradientControlModel_reset_() {
            this.gradientValue = null;
            this.stopControls.forEach(function (m) {
              return m.remove();
            });
            this.gradientHalo.reset();
          }
        }, {
          key: "initLinearGradient",
          value: function GradientControlModel_initLinearGradient_(color) {
            if (color.isGradient) this.gradientValue = new LinearGradient({
              stops: color.stops.map(function (s) {
                return Object.assign({}, s);
              })
            });else {
              this.gradientValue = new LinearGradient({
                stops: [{
                  color: color,
                  offset: 0
                }, {
                  color: Color.transparent,
                  offset: 1
                }]
              });
            }
          }
        }, {
          key: "initRadialGradient",
          value: function GradientControlModel_initRadialGradient_(color, target) {
            var bounds = target.innerBounds();
            if (color.isGradient) this.gradientValue = new RadialGradient({
              bounds: bounds,
              stops: color.stops.map(function (s) {
                return Object.assign({}, s);
              })
            });else {
              this.gradientValue = new RadialGradient({
                bounds: bounds,
                stops: [{
                  color: color,
                  offset: 0
                }, {
                  color: Color.transparent,
                  offset: 1
                }]
              });
            }
          }
        }, {
          key: "deref",
          value: function GradientControlModel_deref_(gradient) {
            return this.serializer.deserializeExprObj(gradient.__serialize__());
          }
        }, {
          key: "setGradient",
          value: function GradientControlModel_setGradient_(color, colorPicker) {
            this.gradientValue = this.deref(color);
            this.gradientHalo.initFromPicker(colorPicker);
          }
        }, {
          key: "update",
          value: function GradientControlModel_update_(colorPicker) {
            if (this.isDisabled) return;
            var selectedStopControl = this.selectedStopControl;

            if (!this.gradientValue || this.gradientValue.type !== colorPicker.colorMode) {
              if (colorPicker.colorMode === "linearGradient") this.initLinearGradient(this.gradientValue || colorPicker.color);
              if (colorPicker.colorMode === "radialGradient") this.initRadialGradient(this.gradientValue || colorPicker.color, colorPicker._target);
              this.gradientHalo.initFromPicker(colorPicker);
              this.gradientHalo.confirm();
            }

            if (selectedStopControl) {
              var stopToChange = this.gradientValue.stops.find(function (aStop) {
                return selectedStopControl.stop === aStop;
              });
              if (stopToChange) stopToChange.color = colorPicker.color;
              this.confirm();
            }

            this.refresh();
          }
        }, {
          key: "getPositionFor",
          value: function GradientControlModel_getPositionFor_(aStop) {
            var _this$ui$gradientPrev = this.ui.gradientPreview.bounds().topEdge(),
                start = _this$ui$gradientPrev.start,
                end = _this$ui$gradientPrev.end;

            return start.interpolate(aStop.offset, end).subXY(0, 5);
          }
        }, {
          key: "confirm",
          value: function GradientControlModel_confirm_() {
            signal(this.view, "gradientChanged", this.deref(this.gradientValue));
          }
        }, {
          key: "refresh",
          value: function GradientControlModel_refresh_() {
            var _this2 = this;

            if (!this.gradientValue) return;
            var gradient = this.ui.gradient;
            var stops = this.gradientValue.stops.map(function (stop) {
              return Object.assign({}, stop);
            });
            gradient.fill = new LinearGradient({
              vector: rect(0),
              stops: stops
            });
            guardNamed("updateGradient", function () {
              _this2.updateStopControls(_this2.gradientValue.stops);
            })();
            this.gradientHalo.refresh(this);
          }
        }, {
          key: "moveStop",
          value: function GradientControlModel_moveStop_(_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2),
                aStop = _ref4[0],
                dx = _ref4[1];

            var relativeDelta = dx / this.ui.gradientPreview.width;
            this.adjustStop(aStop, relativeDelta);
          }
        }, {
          key: "adjustStop",
          value: function GradientControlModel_adjustStop_(aStop, relativeDelta) {
            aStop.offset = clamp(aStop.offset + relativeDelta, 0, 1);
            this.refresh();
            this.confirm();
          }
        }, {
          key: "placeStop",
          value: function GradientControlModel_placeStop_(aStopControl) {
            this.view.addMorph(aStopControl);
          }
        }, {
          key: "getControlFor",
          value: function GradientControlModel_getControlFor_(aStop) {
            var haloOrEditor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
            var s = part(ColorStop, {
              master: {
                states: {
                  selected: SelectedColorStop
                }
              },
              editor: this
            });
            s.withAllSubmorphsDo(function (m) {
              return m.halosEnabled = false;
            });
            haloOrEditor.placeStop(s);
            connect(s, "select", haloOrEditor, "selectStop");
            connect(s, "moveColorStop", haloOrEditor, "moveStop");
            return s.forStop(aStop);
          }
        }, {
          key: "selectStop",
          value: function GradientControlModel_selectStop_(aStopControl) {
            this.deselectAllStopsExcept(aStopControl, this);
            this.deselectAllStopsExcept(aStopControl, this.gradientHalo);
            signal(this.view, "switchColor", aStopControl.stop.color);
          }
        }, {
          key: "deselectAllStopsExcept",
          value: function GradientControlModel_deselectAllStopsExcept_(aStopControl, haloOrEditor) {
            noUpdate(function () {
              haloOrEditor.stopControls.forEach(function (each) {
                if (each.stop !== aStopControl.stop) {
                  each.deselect();
                } else {
                  each.select();
                }
              });
            });
          }
        }, {
          key: "selectFirstStop",
          value: function GradientControlModel_selectFirstStop_() {
            this.selectStop(this.stopControls[0]);
          }
        }, {
          key: "updateStopControls",
          value: function () {
            var _GradientControlModel_updateStopControls_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(stops) {
              var _this3 = this;

              var haloOrEditor,
                  stopControls,
                  _iterator,
                  _step,
                  _loop,
                  _args2 = arguments;

              return regeneratorRuntime.wrap(function _callee$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      haloOrEditor = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : this;
                      stopControls = haloOrEditor.stopControls;
                      _iterator = _createForOfIteratorHelper(stops);
                      _context2.prev = 3;
                      _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {
                        var stop, control;
                        return regeneratorRuntime.wrap(function _loop$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                stop = _step.value;
                                control = stopControls.find(function (s) {
                                  return s.stop === stop;
                                });

                                if (!control) {
                                  _context.next = 7;
                                  break;
                                }

                                control.forStop(stop);
                                remove(stopControls, control);
                                _context.next = 9;
                                break;

                              case 7:
                                _context.next = 9;
                                return _this3.getControlFor(stop, haloOrEditor);

                              case 9:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _loop);
                      });

                      _iterator.s();

                    case 6:
                      if ((_step = _iterator.n()).done) {
                        _context2.next = 10;
                        break;
                      }

                      return _context2.delegateYield(_loop(), "t0", 8);

                    case 8:
                      _context2.next = 6;
                      break;

                    case 10:
                      _context2.next = 15;
                      break;

                    case 12:
                      _context2.prev = 12;
                      _context2.t1 = _context2["catch"](3);

                      _iterator.e(_context2.t1);

                    case 15:
                      _context2.prev = 15;

                      _iterator.f();

                      return _context2.finish(15);

                    case 18:
                      invoke(stopControls, "remove");
                      haloOrEditor.stopControls.forEach(function (stopControl) {
                        stopControl.positionIn(haloOrEditor);
                      });
                      if (this.hasNoSelectedStop(haloOrEditor)) this.selectFirstStop();

                    case 21:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee, this, [[3, 12, 15, 18]]);
            }));

            function GradientControlModel_updateStopControls_(_x) {
              return _GradientControlModel_updateStopControls_.apply(this, arguments);
            }

            return GradientControlModel_updateStopControls_;
          }()
        }, {
          key: "hasNoSelectedStop",
          value: function GradientControlModel_hasNoSelectedStop_(haloOrEditor) {
            return !haloOrEditor.stopControls.find(function (stop) {
              return stop.isSelected;
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GradientControlModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              gradientValue: {},
              gradientHalo: {
                initialize: function initialize() {
                  this.gradientHalo = part(__varRecorder__$14.GradientHalo);
                }
              },
              serializer: {
                serialize: false,
                get: function get() {
                  return this._serializer || (this._serializer = new ExpressionSerializer());
                }
              },
              isDisabled: {
                get: function get() {
                  return this.view && !this.view.visible;
                }
              },
              stopControls: {
                derived: true,
                get: function get() {
                  return this.view.submorphs.filter(function (m) {
                    return m.isColorStop;
                  });
                }
              },
              selectedStopControl: {
                derived: true,
                get: function get() {
                  return this.stopControls.find(function (each) {
                    return each.isSelected;
                  });
                }
              },
              expose: {
                get: function get() {
                  return ["toggle", "gradientHalo"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    signal: "onKeyDown",
                    handler: "onKeyDown"
                  }, {
                    signal: "onMouseDown",
                    handler: "onMouseDown"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./styling/gradient-editor.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 8166,
          end: 15454
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$14.GradientControlModel = GradientControlModel;
      __varRecorder__$14.GradientControlModel = GradientControlModel;
      __varRecorder__$14.GradientControl = component["for"](function () {
        return component({
          viewModelClass: __varRecorder__$14.GradientControlModel,
          name: "gradient control",
          borderWidth: 0,
          borderColor: Color.rgb(215, 219, 221),
          extent: pt(241, 74.3),
          fill: Color.rgba(0, 0, 0, 0),
          isDisabled: true,
          isLayoutable: false,
          submorphs: [{
            name: "gradient preview",
            position: pt(24.1, 42.9),
            borderWidth: 0,
            borderColor: Color.rgb(127, 140, 141),
            borderRadius: 3,
            clipMode: "hidden",
            extent: pt(195.4, 15),
            fill: Color.rgba(0, 0, 0, 0),
            tooltip: "Click to add a new color stop for the gradient.",
            submorphs: [part(CheckerPattern, {
              name: "checkerboard pattern gradient",
              extent: pt(218.4, 38.8)
            }), {
              name: "gradient",
              borderColor: Color.rgb(23, 160, 251),
              extent: pt(196.3, 37),
              fill: new LinearGradient({
                stops: [{
                  offset: 0,
                  color: Color.rgba(71, 181, 65, 0.9877472914564251)
                }, {
                  offset: 1,
                  color: Color.transparent
                }],
                vector: rect(0, 0, 0, 0)
              }),
              reactsToPointer: false
            }]
          }]
        });
      }, {
        module: "lively.ide/styling/gradient-editor.cp.js",
        "export": "GradientControl",
        range: {
          start: 15462,
          end: 16471
        }
      }, System, __varRecorder__$14, "GradientControl");
      var GradientHalo = __varRecorder__$14.GradientHalo;
      var GradientControl = __varRecorder__$14.GradientControl;
      __varRecorder__$14.GradientHalo = GradientHalo;
      __varRecorder__$14.GradientControl = GradientControl;

      var __varRecorder__$13 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/styling/color-picker.cp.js", __contextModule__);
      __varRecorder__$13.ColorInput = component["for"](function () {
        var _part;

        return component({
          defaultViewModel: ColorInputModel,
          name: "color input",
          extent: pt(250, 27),
          layout: new TilingLayout({
            axisAlign: "center",
            orderByIndex: true,
            padding: rect(20, 2, -10, 0),
            resizePolicies: [["hex input", {
              height: "fill",
              width: "fixed"
            }], ["opacity input", {
              height: "fill",
              width: "fixed"
            }]],
            spacing: 10
          }),
          fill: Color.rgba(255, 255, 255, 0),
          submorphs: [part(ColorCell, {
            name: "color cell",
            tooltip: "Open Color Picker",
            borderWidth: 0,
            nativeCursor: "pointer",
            extent: pt(22, 22),
            submorphs: [{
              name: "opaque",
              reactsToPointer: false,
              borderColor: Color.rgb(23, 160, 251),
              extent: pt(11, 22),
              position: pt(0),
              fill: Color.rgb(255, 0, 0)
            }, {
              name: "transparent",
              reactsToPointer: false,
              borderColor: Color.rgb(23, 160, 251),
              extent: pt(11, 22),
              fill: Color.rgba(255, 0, 0, 0.38),
              position: pt(11, 0)
            }, add({
              name: "gradient",
              reactsToPointer: false,
              visible: false,
              fill: Color.blue,
              extent: pt(22, 22)
            })]
          }), part(TextInput, (_part = {
            type: InputLine,
            fill: Color.transparent,
            name: "hex input",
            tooltip: "HEX Color Value",
            extent: pt(72.1, 23)
          }, _defineProperty(_part, "fill", Color.rgb(66, 73, 73)), _defineProperty(_part, "fontSize", 14), _defineProperty(_part, "padding", rect(4, 3, 6, 2)), _defineProperty(_part, "textAndAttributes", ["DDDDDD", null]), _part)), part(DarkNumberIconWidget, {
            name: "opacity input",
            tooltip: "Opacity",
            extent: pt(78.8, 23),
            viewModel: {
              unit: "%",
              max: 1,
              min: 0,
              scaleFactor: 100
            },
            submorphs: [{
              name: "interactive label",
              lineHeight: 1,
              textAndAttributes: ["\uE91C", {
                fontFamily: "Material Icons",
                fontSize: 14
              }]
            }, without("button holder")]
          }), part(PropLabel, {
            name: "gradient name",
            visible: false,
            textAndAttributes: ["Linear", null]
          })]
        });
      }, {
        module: "lively.ide/styling/color-picker.cp.js",
        "export": "ColorInput",
        range: {
          start: 907,
          end: 2861
        }
      }, System, __varRecorder__$13, "ColorInput");
      __varRecorder__$13.DefaultInputLine = component["for"](function () {
        return component({
          type: InputLine,
          name: "default input line",
          borderColor: Color.rgb(204, 204, 204),
          fill: Color.transparent,
          extent: pt(97, 23),
          fontFamily: "IBM Plex Sans",
          fontSize: 14,
          haloShadow: new ShadowObject({
            distance: 0,
            color: Color.rgb(52, 152, 219)
          }),
          highlightWhenFocused: true,
          padding: rect(10, 3, -10, 0),
          nativeCursor: "text",
          submorphs: [{
            type: Label,
            name: "placeholder",
            fontColor: Color.rgb(204, 204, 204),
            fontFamily: "IBM Plex Sans",
            fontSize: 14,
            padding: rect(10, 3, -10, 0),
            reactsToPointer: false,
            textAndAttributes: ["Hex Code", null]
          }]
        });
      }, {
        module: "lively.ide/styling/color-picker.cp.js",
        "export": "DefaultInputLine",
        range: {
          start: 2870,
          end: 3515
        }
      }, System, __varRecorder__$13, "DefaultInputLine");
      __varRecorder__$13.HexEncoder = component["for"](function () {
        return component({
          name: "hex encoder",
          borderColor: Color.rgb(23, 160, 251),
          extent: pt(140, 25),
          fill: Color.rgb(189, 195, 199),
          layout: new TilingLayout({
            align: "center",
            axisAlign: "center",
            padding: rect(1, 1, 0, 0),
            resizePolicies: [["hex input", {
              height: "fixed",
              width: "fill"
            }]],
            spacing: 1
          }),
          submorphs: [part(DefaultNumberWidget, {
            name: "hex opacity control",
            layout: new TilingLayout({
              axisAlign: "center",
              justifySubmorphs: "spaced",
              padding: rect(0, 0, 0, 2),
              resizePolicies: [["value", {
                height: "fixed",
                width: "fixed"
              }]]
            }),
            dropShadow: false,
            extent: pt(45, 23),
            borderRadius: 0,
            viewModel: {
              floatingPoint: false,
              max: 1,
              min: 0,
              scaleFactor: 100,
              unit: "%",
              autofit: false
            },
            submorphs: [{
              name: "value",
              fontSize: 12
            }, without("button holder")]
          }), part(__varRecorder__$13.DefaultInputLine, {
            placeholder: "Hex Code",
            fill: Color.white,
            name: "hex input",
            fontColor: Color.rgb(40, 116, 166)
          })]
        });
      }, {
        module: "lively.ide/styling/color-picker.cp.js",
        "export": "HexEncoder",
        range: {
          start: 3524,
          end: 4717
        }
      }, System, __varRecorder__$13, "HexEncoder");
      __varRecorder__$13.ThreeValEncoder = component["for"](function () {
        return component({
          name: "three val encoder",
          borderColor: Color.rgb(23, 160, 251),
          extent: pt(140, 25),
          fill: Color.rgb(189, 195, 199),
          layout: new TilingLayout({
            align: "center",
            axisAlign: "center",
            padding: rect(1, 1, 0, 0),
            resizePolicies: [["opacity control", {
              height: "fill",
              width: "fixed"
            }], ["first value", {
              height: "fill",
              width: "fixed"
            }], ["second value", {
              height: "fill",
              width: "fixed"
            }], ["third value", {
              height: "fill",
              width: "fixed"
            }]],
            spacing: 1
          }),
          submorphs: [part(DefaultNumberWidget, {
            name: "opacity control",
            width: 45,
            borderRadius: 0,
            dropShadow: false,
            viewModel: {
              max: 1,
              min: 0,
              floatingPoint: false,
              scaleFactor: 100,
              borderRadius: 0,
              unit: "%",
              autofit: true
            },
            submorphs: [{
              name: "value",
              fontSize: 12
            }, without("button holder")]
          }), part(DefaultNumberWidget, {
            name: "first value",
            dropShadow: false,
            extent: pt(30, 22),
            borderRadius: 0,
            viewModel: {
              max: 255,
              min: 0,
              floatingPoint: false,
              unit: "",
              autofit: true
            },
            submorphs: [{
              name: "value",
              fontSize: 12
            }, without("button holder")]
          }), part(DefaultNumberWidget, {
            name: "second value",
            borderRadius: 0,
            dropShadow: false,
            extent: pt(30, 22),
            viewModel: {
              floatingPoint: false,
              max: 255,
              min: 0,
              unit: "",
              autofit: true
            },
            submorphs: [{
              name: "value",
              fontSize: 12
            }, without("button holder")]
          }), part(DefaultNumberWidget, {
            name: "third value",
            borderRadius: 0,
            dropShadow: false,
            extent: pt(30, 22),
            viewModel: {
              floatingPoint: false,
              max: 255,
              min: 0,
              unit: "",
              autofit: true
            },
            submorphs: [{
              name: "value",
              fontSize: 12
            }, without("button holder")]
          })]
        });
      }, {
        module: "lively.ide/styling/color-picker.cp.js",
        "export": "ThreeValEncoder",
        range: {
          start: 4726,
          end: 6863
        }
      }, System, __varRecorder__$13, "ThreeValEncoder");
      __varRecorder__$13.CssEncoder = component["for"](function () {
        return component({
          name: "css encoder",
          borderColor: Color.rgb(23, 160, 251),
          extent: pt(140, 25),
          fill: Color.rgb(189, 195, 199),
          isLayoutable: false,
          layout: new TilingLayout({
            align: "center",
            orderByIndex: true,
            padding: {
              height: 0,
              width: 0,
              x: 1,
              y: 1
            },
            reactToSubmorphAnimations: false,
            renderViaCSS: true,
            resizeSubmorphs: false,
            spacing: 1
          }),
          submorphs: [part(__varRecorder__$13.DefaultInputLine, {
            name: "css input",
            placeholder: "CSS color string",
            extent: pt(138, 23),
            padding: rect(5, 3, -5, -3),
            fontColor: Color.rgb(40, 116, 166),
            fill: Color.white
          })]
        });
      }, {
        module: "lively.ide/styling/color-picker.cp.js",
        "export": "CssEncoder",
        range: {
          start: 6872,
          end: 7530
        }
      }, System, __varRecorder__$13, "CssEncoder");
      __varRecorder__$13.ColorEncoder = component["for"](function () {
        return component({
          defaultViewModel: ColorEncoderModel,
          name: "color encoder",
          extent: pt(219.6, 25),
          fill: Color.transparent,
          layout: new TilingLayout({
            justifySubmorphs: "spaced",
            spacing: 5
          }),
          submorphs: [part(DropDownList, {
            name: "color code selector",
            extent: pt(54, 25),
            viewModel: {
              listMaster: SystemList,
              items: ["HEX", "RGB", "HSL", "HSB", "CSS"],
              openListInWorld: true
            }
          }), {
            name: "controls",
            borderColor: Color.rgb(23, 160, 251),
            clipMode: "visible",
            encodingMode: "HEX",
            extent: pt(162.5, 30.8),
            fill: Color.transparent,
            layout: new TilingLayout({
              axis: "column",
              hugContentsVertically: true,
              hugContentsHorizontally: true,
              wrapSubmorphs: true
            }),
            submorphs: [part(__varRecorder__$13.HexEncoder, {
              name: "hex encoding"
            }), part(__varRecorder__$13.ThreeValEncoder, {
              name: "3 val encoding",
              visible: false
            }), part(__varRecorder__$13.CssEncoder, {
              name: "css encoding",
              visible: false
            })]
          }, {
            type: Label,
            name: "color copier",
            nativeCursor: "pointer",
            fontSize: 20,
            lineHeight: 1.1,
            fontColor: Color.rgb(102, 102, 102),
            fill: Color.transparent,
            padding: 3,
            textAndAttributes: Icon.textAttribute("copy")
          }]
        });
      }, {
        module: "lively.ide/styling/color-picker.cp.js",
        "export": "ColorEncoder",
        range: {
          start: 7539,
          end: 8906
        }
      }, System, __varRecorder__$13, "ColorEncoder");
      __varRecorder__$13.DefaultSlider = component["for"](function () {
        return component({
          name: "default slider",
          borderColor: Color.rgb(189, 195, 199),
          borderRadius: 9,
          borderWidth: 1,
          draggable: true,
          extent: pt(215, 10),
          submorphs: [{
            name: "slider",
            position: pt(0, -2),
            borderRadius: 10,
            borderWidth: 3,
            dropShadow: new ShadowObject({
              distance: 0,
              color: Color.rgba(7, 7, 7, 0.5),
              blur: 4,
              fast: false
            }),
            extent: pt(15, 15),
            fill: Color.rgba(0, 0, 0, 0),
            nativeCursor: "ns-resize",
            reactsToPointer: false
          }]
        });
      }, {
        module: "lively.ide/styling/color-picker.cp.js",
        "export": "DefaultSlider",
        range: {
          start: 8915,
          end: 9449
        }
      }, System, __varRecorder__$13, "DefaultSlider");
      __varRecorder__$13.OpacitySlider = component["for"](function () {
        return component(__varRecorder__$13.DefaultSlider, {
          defaultViewModel: OpacityPickerModel,
          name: "opacity slider",
          submorphs: [add(part(CheckerPattern, {
            name: "checkerboard pattern",
            extent: pt(215, 10),
            borderColor: Color.rgb(203, 203, 203),
            borderRadius: 10,
            borderWidth: 1
          }), "slider"), add({
            name: "opacity gradient",
            borderColor: Color.rgb(23, 160, 251),
            borderRadius: 5,
            extent: pt(215, 10),
            fill: new LinearGradient({
              stops: [{
                offset: 0,
                color: Color.transparent
              }, {
                offset: 1,
                color: Color.black
              }],
              vector: "eastwest"
            }),
            reactsToPointer: false
          }, "slider")]
        });
      }, {
        module: "lively.ide/styling/color-picker.cp.js",
        "export": "OpacitySlider",
        range: {
          start: 9458,
          end: 10166
        }
      }, System, __varRecorder__$13, "OpacitySlider");
      __varRecorder__$13.HueSlider = component["for"](function () {
        return component(__varRecorder__$13.DefaultSlider, {
          defaultViewModel: HuePickerModel,
          name: "hue slider",
          fill: new LinearGradient({
            stops: [{
              color: Color.rgb(255, 0, 0),
              offset: 0
            }, {
              color: Color.rgb(255, 255, 0),
              offset: 0.17
            }, {
              color: Color.limeGreen,
              offset: 0.33
            }, {
              color: Color.cyan,
              offset: 0.5
            }, {
              color: Color.blue,
              offset: 0.66
            }, {
              color: Color.magenta,
              offset: 0.83
            }, {
              color: Color.rgb(255, 0, 0),
              offset: 1
            }],
            vector: "eastwest"
          })
        });
      }, {
        module: "lively.ide/styling/color-picker.cp.js",
        "export": "HueSlider",
        range: {
          start: 10175,
          end: 10673
        }
      }, System, __varRecorder__$13, "HueSlider");
      __varRecorder__$13.FieldPicker = component["for"](function () {
        return component({
          defaultViewModel: FieldPickerModel,
          name: "field picker",
          borderColor: Color.rgb(162, 162, 162),
          borderWidth: 1,
          draggable: true,
          clipMode: "hidden",
          extent: pt(241, 240.8),
          submorphs: [{
            name: "hue",
            extent: pt(241, 240.8),
            fill: Color.rgb(255, 0, 0),
            reactsToPointer: false
          }, {
            name: "shade",
            extent: pt(241, 240.8),
            reactsToPointer: false,
            fill: new LinearGradient({
              stops: [{
                offset: 0,
                color: Color.white
              }, {
                offset: 1,
                color: Color.transparent
              }],
              vector: rect(0, 0, 1, 0)
            })
          }, {
            name: "light",
            extent: pt(241, 240.8),
            reactsToPointer: false,
            fill: new LinearGradient({
              stops: [{
                offset: 0,
                color: Color.black
              }, {
                offset: 1,
                color: Color.transparent
              }],
              vector: rect(0, 1, 0, -1)
            })
          }, {
            type: Ellipse,
            name: "picker",
            borderColor: Color.rgb(0, 0, 0),
            borderWidth: 3,
            extent: pt(16, 16),
            fill: Color.rgba(0, 0, 0, 0),
            reactsToPointer: false,
            submorphs: [{
              type: Ellipse,
              name: "inside picker",
              borderWidth: 3,
              position: pt(2, 2),
              extent: pt(12, 12),
              fill: Color.rgba(0, 0, 0, 0),
              reactsToPointer: false
            }]
          }]
        });
      }, {
        module: "lively.ide/styling/color-picker.cp.js",
        "export": "FieldPicker",
        range: {
          start: 10682,
          end: 11911
        }
      }, System, __varRecorder__$13, "FieldPicker");
      __varRecorder__$13.ColorPicker = component["for"](function () {
        return component(PopupWindow, {
          name: "color picker",
          defaultViewModel: ColorPickerModel,
          layout: new TilingLayout({
            axis: "column",
            hugContentsVertically: true,
            resizePolicies: [["color controls", {
              height: "fixed",
              width: "fill"
            }]]
          }),
          submorphs: [{
            name: "header menu",
            submorphs: [add(part(DropDownList, {
              name: "color type selector",
              extent: pt(102, 27),
              viewModel: {
                listMaster: SystemList,
                openListInWorld: true,
                items: [{
                  isListItem: true,
                  string: "Solid",
                  value: "Solid"
                }, {
                  isListItem: true,
                  string: "Linear",
                  value: "linearGradient"
                }, {
                  isListItem: true,
                  string: "Radial",
                  value: "radialGradient"
                }]
              }
            }), "close button"), {
              name: "title",
              visible: false
            }]
          }, add(part(GradientControl, {
            name: "gradient control",
            visible: false
          })), add(part(__varRecorder__$13.FieldPicker, {
            name: "shade picker"
          })), add({
            name: "color controls",
            borderWidth: {
              top: 0,
              left: 0,
              right: 0,
              bottom: 1
            },
            layout: new TilingLayout({
              orderByIndex: true,
              padding: Rectangle.inset(5, 15, 5, 15),
              spacing: 10,
              axis: "column",
              axisAlign: "center",
              justifySubmorphs: "spaced"
            }),
            borderColor: Color.rgb(215, 219, 221),
            extent: pt(0, 140),
            fill: Color.rgba(0, 0, 0, 0),
            submorphs: [part(__varRecorder__$13.HueSlider, {
              name: "hue picker"
            }), part(__varRecorder__$13.OpacitySlider, {
              name: "opacity picker"
            }), part(__varRecorder__$13.ColorEncoder, {
              name: "color encoding"
            }), part(ButtonDefault, {
              name: "eye dropper button",
              width: 225,
              submorphs: [{
                name: "label",
                textAndAttributes: Icon.textAttribute("ti-color-picker").concat([" Pick a Color", null])
              }]
            })]
          }), add({
            name: "color palettes",
            borderColor: Color.rgb(23, 160, 251),
            extent: pt(241, 157.2),
            fill: Color.rgba(0, 0, 0, 0),
            submorphs: [part(DropDownList, {
              name: "color palette selector",
              position: pt(9.7, 9.2),
              viewModel: {
                listMaster: SystemList,
                items: ["Material", "Flat Design", "Web Safe"],
                openListInWorld: true
              },
              extent: pt(97, 25),
              tooltip: "Select a color palette"
            }), {
              type: ColorPaletteView,
              name: "color palette view",
              cssDeclaration: ".palette-container {\n  height: 100%;\n  display: flex;\n  padding-left: 6px;\n  flex-wrap: wrap;\n  justify-content: left;\n  overflow: auto;\n  margin-right: 1px;\n}\n\n.color-cell {\n  height: 15px;\n  width: 15px;\n  margin: 4px;\n  border-width: .5px;\n  border-style: solid;\n  border-color: lightgray;\n  border-radius: 1px;\n  cursor: pointer;\n}",
              position: pt(-0.1, 41),
              borderColor: Color.rgb(23, 160, 251),
              clipMode: "hidden",
              extent: pt(241.3, 116.8),
              fill: Color.rgba(0, 0, 0, 0)
            }]
          })]
        });
      }, {
        module: "lively.ide/styling/color-picker.cp.js",
        "export": "ColorPicker",
        range: {
          start: 11920,
          end: 15013
        }
      }, System, __varRecorder__$13, "ColorPicker");
      var ColorEncoder = __varRecorder__$13.ColorEncoder;
      var DefaultSlider = __varRecorder__$13.DefaultSlider;
      var OpacitySlider = __varRecorder__$13.OpacitySlider;
      var HueSlider = __varRecorder__$13.HueSlider;
      var ColorPicker = exports('Y', __varRecorder__$13.ColorPicker);
      var HexEncoder = __varRecorder__$13.HexEncoder;
      var ColorInput = exports('w', __varRecorder__$13.ColorInput);
      __varRecorder__$13.ColorEncoder = ColorEncoder;
      __varRecorder__$13.DefaultSlider = DefaultSlider;
      __varRecorder__$13.OpacitySlider = OpacitySlider;
      __varRecorder__$13.HueSlider = HueSlider;
      __varRecorder__$13.ColorPicker = ColorPicker;
      __varRecorder__$13.HexEncoder = HexEncoder;
      __varRecorder__$13.ColorInput = ColorInput;

      var colorPicker_cp = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ColorEncoder: ColorEncoder,
        DefaultSlider: DefaultSlider,
        OpacitySlider: OpacitySlider,
        HueSlider: HueSlider,
        ColorPicker: ColorPicker,
        HexEncoder: HexEncoder,
        ColorInput: ColorInput
      });

      var __varRecorder__$12 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/controls/section.cp.js", __contextModule__);
      var PropertySectionModel = exports('o', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/controls/section.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PropertySectionModel") && typeof __lively_classholder__.PropertySectionModel === "function" ? __lively_classholder__.PropertySectionModel : __lively_classholder__.PropertySectionModel = function PropertySectionModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "activate",
          value: function PropertySectionModel_activate_() {
            this.ui.removeButton.visible = true;
            this.ui.addButton.visible = false;
            this.view.master.setState(null);
          }
        }, {
          key: "deactivate",
          value: function PropertySectionModel_deactivate_() {
            this.ui.addButton.visible = true;
            this.ui.removeButton.visible = false;
            this.view.master.setState("inactive");
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PropertySectionModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              bindings: {
                get: function get() {
                  return [{
                    target: "add button",
                    signal: "onMouseDown",
                    handler: "activate"
                  }, {
                    target: "remove button",
                    signal: "onMouseDown",
                    handler: "deactivate"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/controls/section.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 235,
          end: 873
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      }));
      __varRecorder__$12.PropertySectionModel = PropertySectionModel;
      __varRecorder__$12.PropertySectionModel = PropertySectionModel;
      __varRecorder__$12.PropertySectionActive = component["for"](function () {
        return component({
          name: "property section",
          borderColor: Color.rgba(97, 106, 107, 1),
          layout: new TilingLayout({
            spacing: 10,
            padding: Rectangle.inset(0, 10, 0, 10),
            resizePolicies: [["h floater", {
              width: "fill",
              height: "fixed"
            }]],
            axis: "column",
            hugContentsVertically: true
          }),
          clipMode: "hidden",
          fill: Color.transparent,
          borderWidth: {
            top: 0,
            left: 0,
            right: 0,
            bottom: 1
          },
          extent: pt(195.1, 51),
          submorphs: [{
            name: "h floater",
            opacity: 1,
            layout: new TilingLayout({
              padding: Rectangle.inset(10, 0, 10, 0),
              justifySubmorphs: "spaced",
              axisAlign: "center"
            }),
            borderColor: Color.rgb(23, 160, 251),
            borderWidth: 0,
            extent: pt(180.6, 31),
            fill: Color.rgba(0, 0, 0, 0),
            position: pt(14.9, 5.5),
            submorphs: [part(HeadlineLabel, {
              name: "section headline",
              textAndAttributes: ["Property Section", null]
            }), part(AddButton, {
              master: {
                auto: AddButton,
                hover: PropertyLabelHovered
              },
              name: "add button",
              tooltip: "Add Effect"
            }), part(RemoveButton, {
              master: {
                auto: AddButton,
                hover: PropertyLabelHovered
              },
              name: "remove button",
              tooltip: "Remove Effect",
              visible: false
            })]
          }]
        });
      }, {
        module: "lively.ide/studio/controls/section.cp.js",
        "export": "PropertySectionActive",
        range: {
          start: 881,
          end: 2161
        }
      }, System, __varRecorder__$12, "PropertySectionActive");
      __varRecorder__$12.PropertySectionInactive = component["for"](function () {
        return component(__varRecorder__$12.PropertySectionActive, {
          name: "property section inactive",
          master: __varRecorder__$12.PropertySectionInactive,
          submorphs: [{
            name: "h floater",
            opacity: 0.5
          }]
        });
      }, {
        module: "lively.ide/studio/controls/section.cp.js",
        "export": "PropertySectionInactive",
        range: {
          start: 2170,
          end: 2366
        }
      }, System, __varRecorder__$12, "PropertySectionInactive");
      __varRecorder__$12.PropertySectionDisabled = component["for"](function () {
        return component(__varRecorder__$12.PropertySectionInactive, {
          master: {
            hover: __varRecorder__$12.PropertySectionActive
          }
        });
      }, {
        module: "lively.ide/studio/controls/section.cp.js",
        "export": "PropertySectionDisabled",
        range: {
          start: 2375,
          end: 2483
        }
      }, System, __varRecorder__$12, "PropertySectionDisabled");
      __varRecorder__$12.PropertySection = component["for"](function () {
        return component(__varRecorder__$12.PropertySectionActive, {
          master: {
            states: {
              inactive: __varRecorder__$12.PropertySectionDisabled
            }
          }
        });
      }, {
        module: "lively.ide/studio/controls/section.cp.js",
        "export": "PropertySection",
        range: {
          start: 2492,
          end: 2607
        }
      }, System, __varRecorder__$12, "PropertySection");
      var PropertySection = exports('p', __varRecorder__$12.PropertySection);
      var PropertySectionInactive = __varRecorder__$12.PropertySectionInactive;
      __varRecorder__$12.PropertySection = PropertySection;
      __varRecorder__$12.PropertySectionInactive = PropertySectionInactive;

      var __varRecorder__$11 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.components/muller-columns.cp.js", __contextModule__);
      __varRecorder__$11.ColumnListDefault = component["for"](function () {
        return component(DefaultList, {
          name: "column list default",
          styleClasses: ["clipped"],
          borderWidthRight: 1,
          borderColor: Color.rgb(213, 216, 220),
          extent: pt(230, 93.5),
          fill: Color.rgba(255, 255, 255, 0),
          itemBorderRadius: 3,
          itemPadding: rect(5, 3, 0, -2),
          padding: rect(5, 5, 5, 0)
        });
      }, {
        module: "lively.components/muller-columns.cp.js",
        "export": "ColumnListDefault",
        range: {
          start: 278,
          end: 597
        }
      }, System, __varRecorder__$11, "ColumnListDefault");
      __varRecorder__$11.ColumnListDark = component["for"](function () {
        return component(__varRecorder__$11.ColumnListDefault, {
          name: "column list dark",
          borderColor: Color.rgb(133, 146, 158),
          fill: Color.rgba(44, 62, 80, 0),
          nonSelectionFontColor: Color.rgb(252, 252, 252),
          selectionColor: Color.rgbHex("64FFDA").withA(0.6),
          selectionFontColor: Color.rgb(53, 53, 53)
        });
      }, {
        module: "lively.components/muller-columns.cp.js",
        "export": "ColumnListDark",
        range: {
          start: 606,
          end: 907
        }
      }, System, __varRecorder__$11, "ColumnListDark");
      var MullerColumnViewModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.components/muller-columns.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("MullerColumnViewModel") && typeof __lively_classholder__.MullerColumnViewModel === "function" ? __lively_classholder__.MullerColumnViewModel : __lively_classholder__.MullerColumnViewModel = function MullerColumnViewModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "focusActiveList",
          value: function MullerColumnViewModel_focusActiveList_() {
            last$2(this.lists.filter(function (m) {
              return !!m.selection;
            })).focus();
          }
        }, {
          key: "listNavigationProhibited",
          get: function get() {
            return this.treeData.listNavigationProhibited;
          }
        }, {
          key: "truncateNameIfNeeded",
          value: function MullerColumnViewModel_truncateNameIfNeeded_(displayedName) {
            return displayedName;
          }
        }, {
          key: "isSelected",
          value: function MullerColumnViewModel_isSelected_(node) {
            return !node.isCollapsed;
          }
        }, {
          key: "setTreeData",
          value: function () {
            var _MullerColumnViewModel_setTreeData_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(treeData) {
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      this.treeData = treeData;
                      _context.next = 3;
                      return treeData.collapse(treeData.root, false);

                    case 3:
                      _context.next = 5;
                      return this.refresh(false);

                    case 5:
                      if (this.lists[0].selection) this.lists[0].selection = null;

                    case 6:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function MullerColumnViewModel_setTreeData_(_x) {
              return _MullerColumnViewModel_setTreeData_.apply(this, arguments);
            }

            return MullerColumnViewModel_setTreeData_;
          }()
        }, {
          key: "reset",
          value: function MullerColumnViewModel_reset_() {
            this.lists = [];
          }
        }, {
          key: "selectNode",
          value: function () {
            var _MullerColumnViewModel_selectNode_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(aNode) {
              var _this = this;

              var animated,
                  parent,
                  _args2 = arguments;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      animated = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : true;
                      this._selectedNode = aNode;
                      parent = this.treeData.parentNode(aNode);
                      _context2.next = 5;
                      return Promise.all(this.treeData.getChildren(parent).map(function (child) {
                        if (child !== aNode && !_this.treeData.isCollapsed(child)) {
                          return _this.treeData.collapse(child, true);
                        }

                        if (child === aNode) return _this.treeData.collapse(child, false);
                      }));

                    case 5:
                      _context2.next = 7;
                      return this.refresh(animated);

                    case 7:
                      signal(this.view, "selectionChange", this.getExpandedPath());

                    case 8:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function MullerColumnViewModel_selectNode_(_x2) {
              return _MullerColumnViewModel_selectNode_.apply(this, arguments);
            }

            return MullerColumnViewModel_selectNode_;
          }()
        }, {
          key: "getExpandedPath",
          value: function MullerColumnViewModel_getExpandedPath_() {
            var td = this.treeData;
            if (!td) return [];
            var currentChildren = td.getChildren(td.root);
            var nextNode;
            var expandedPath = [td.root];

            while (nextNode = currentChildren && currentChildren.find(function (aChild) {
              return !td.isCollapsed(aChild);
            })) {
              expandedPath.push(nextNode);
              currentChildren = td.getChildren(nextNode);
            }

            return expandedPath;
          }
        }, {
          key: "setExpandedPath",
          value: function () {
            var _MullerColumnViewModel_setExpandedPath_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
              var matchingNodes,
                  until,
                  animated,
                  td,
                  p,
                  currentPath,
                  _args3 = arguments;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      matchingNodes = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : function (n) {
                        return n === this.treeData.root;
                      }.bind(this);
                      until = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : this.treeData.root;
                      animated = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : true;
                      td = this.treeData;
                      p = this.getExpandedPath();
                      currentPath = p.slice(p.indexOf(until));
                      _context3.next = 8;
                      return Promise.all(currentPath.map(function (node) {
                        return td.collapse(node, true);
                      }));

                    case 8:
                      _context3.next = 10;
                      return td.uncollapseAll(matchingNodes, 0, until);

                    case 10:
                      _context3.next = 12;
                      return this.refresh(animated);

                    case 12:
                      this.lists.forEach(function (list) {
                        return list.scrollSelectionIntoView();
                      });

                    case 13:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function MullerColumnViewModel_setExpandedPath_() {
              return _MullerColumnViewModel_setExpandedPath_.apply(this, arguments);
            }

            return MullerColumnViewModel_setExpandedPath_;
          }()
        }, {
          key: "newList",
          value: function MullerColumnViewModel_newList_() {
            var list = part(this.listMaster, {
              acceptsDrops: false,
              width: 200
            });
            connect(list, "selection", this, "selectNode");
            return list;
          }
        }, {
          key: "ensureLists",
          value: function () {
            var _MullerColumnViewModel_ensureLists_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(numberOfLists) {
              var _this2 = this;

              var animated,
                  newLists,
                  scroll,
                  view,
                  lenDiff,
                  _args4 = arguments;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      animated = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : true;
                      newLists = this.lists;
                      view = this.view;
                      lenDiff = numberOfLists - newLists.length;

                      if (!(lenDiff >= 0)) {
                        _context4.next = 11;
                        break;
                      }

                      newLists = [].concat(_toConsumableArray$1(newLists), _toConsumableArray$1(genN(lenDiff, function () {
                        return _this2.newList();
                      })));
                      this.lists = newLists;
                      scroll = pt(view.scrollExtent.x - view.width);

                      if (animated) {
                        view.animate({
                          scroll: scroll,
                          duration: 200
                        });
                      } else {
                        view.scroll = scroll;
                        view.env.forceUpdate();
                      }

                      _context4.next = 22;
                      break;

                    case 11:
                      if (!(lenDiff < 0)) {
                        _context4.next = 22;
                        break;
                      }

                      newLists = newLists.slice(0, lenDiff);
                      scroll = pt(last$2(newLists).right - view.width);

                      if (!animated) {
                        _context4.next = 19;
                        break;
                      }

                      _context4.next = 17;
                      return view.animate({
                        scroll: scroll,
                        duration: 200
                      });

                    case 17:
                      _context4.next = 21;
                      break;

                    case 19:
                      view.scroll = scroll;
                      view.env.forceUpdate();

                    case 21:
                      this.lists = newLists;

                    case 22:
                      newLists.forEach(function (list) {
                        if (list.scroller) list.scroller.visible = true;
                      });
                      return _context4.abrupt("return", newLists);

                    case 24:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function MullerColumnViewModel_ensureLists_(_x3) {
              return _MullerColumnViewModel_ensureLists_.apply(this, arguments);
            }

            return MullerColumnViewModel_ensureLists_;
          }()
        }, {
          key: "relayout",
          value: function MullerColumnViewModel_relayout_() {
            var scrollBarHeight = 0;
            var view = this.view;

            if (view.scrollExtent.x > view.width + view.scrollbarOffset.x) {
              scrollBarHeight = view.scrollbarOffset.y;
            }

            this.lists.forEach(function (list) {
              list.height = view.height - scrollBarHeight - 1;
              var control = list._managedNode && list._managedNode.listControl;

              if (control) {
                control.bottomRight = list.innerBounds().bottomRight().subXY(5, 0);
              }
            });
          }
        }, {
          key: "onHoverOut",
          value: function MullerColumnViewModel_onHoverOut_(evt) {
            this.lists.forEach(function (list) {
              var control = list._managedNode && list._managedNode.listControl;
              if (control) control.visible = false;
            });
          }
        }, {
          key: "onKeyDown",
          value: function () {
            var _MullerColumnViewModel_onKeyDown_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(evt) {
              var _this3 = this;

              var window, hoveredList, input, lookUpIndex, newItems, _iterator, _step, item, stringIndex, array, fakeEvent;

              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      window = this.view.getWindow();

                      if (!(!window || !window.isActive() || window.isFaderActive())) {
                        _context5.next = 3;
                        break;
                      }

                      return _context5.abrupt("return");

                    case 3:
                      _context5.next = 5;
                      return this.refresh(false);

                    case 5:
                      hoveredList = this.lists.find(function (list) {
                        return list.fullContainsWorldPoint($world.firstHand.position);
                      });

                      if (hoveredList) {
                        _context5.next = 8;
                        break;
                      }

                      return _context5.abrupt("return");

                    case 8:
                      hoveredList.items.forEach(function (item) {
                        if (item.originalLabel) item.label = item.originalLabel.filter(function (elem) {
                          return true;
                        });
                      });

                      if (!evt.hasCharacterPressed) {
                        _context5.next = 13;
                        break;
                      }

                      input = evt.key;
                      _context5.next = 29;
                      break;

                    case 13:
                      if (!(evt.key === "Space")) {
                        _context5.next = 17;
                        break;
                      }

                      input = " ";
                      _context5.next = 29;
                      break;

                    case 17:
                      if (!(evt.key === "Backspace")) {
                        _context5.next = 22;
                        break;
                      }

                      input = "";
                      this.searchString = this.searchString.slice(0, -1);
                      _context5.next = 29;
                      break;

                    case 22:
                      if (!(evt.key === "Enter")) {
                        _context5.next = 26;
                        break;
                      }

                      input = "";
                      _context5.next = 29;
                      break;

                    case 26:
                      this.lists.forEach(function (list) {
                        return list.scrollSelectionIntoView();
                      });
                      this.searchString = "";
                      return _context5.abrupt("return");

                    case 29:
                      if (!this.searchString) this.searchString = "";
                      this.searchString = this.searchString + input.toLowerCase();
                      hoveredList.items.forEach(function (item, index) {
                        item.normalizedIndex = index;
                      });
                      newItems = hoveredList.items.filter(function (item) {
                        var itemStringToSearch = item.string.toLowerCase().split("\t")[0];
                        return itemStringToSearch.includes(_this3.searchString);
                      });
                      _iterator = _createForOfIteratorHelper(newItems);

                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                          item = _step.value;
                          lookUpIndex = item.label.length > 2 ? 2 : 0;
                          stringIndex = item.label[lookUpIndex].toLowerCase().indexOf(this.searchString);
                          array = item.label;
                          item.originalLabel = item.label.filter(function (elem) {
                            return true;
                          });
                          array.splice(lookUpIndex, 1, item.label[lookUpIndex].slice(0, stringIndex), item.label[lookUpIndex + 1], item.label[lookUpIndex].slice(stringIndex, stringIndex + this.searchString.length), {
                            fontStyle: item.label[lookUpIndex + 1] ? item.label[lookUpIndex + 1].fontStyle : "normal",
                            backgroundColor: Color.orange
                          }, item.label[lookUpIndex].slice(stringIndex + this.searchString.length));
                          item.label = array;
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }

                      hoveredList.items = newItems;

                      if (!(evt.key === "Enter")) {
                        _context5.next = 41;
                        break;
                      }

                      if (!(hoveredList.items.length > 1)) {
                        _context5.next = 39;
                        break;
                      }

                      return _context5.abrupt("return");

                    case 39:
                      fakeEvent = {
                        targetMorph: hoveredList.withAllSubmorphsSelect(function (m) {
                          return m.isListItemMorph;
                        })[0]
                      };
                      this.clickOnItem(fakeEvent);

                    case 41:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function MullerColumnViewModel_onKeyDown_(_x4) {
              return _MullerColumnViewModel_onKeyDown_.apply(this, arguments);
            }

            return MullerColumnViewModel_onKeyDown_;
          }()
        }, {
          key: "onMouseMove",
          value: function MullerColumnViewModel_onMouseMove_(evt) {
            var hoveredList = this.lists.find(function (list) {
              return list.fullContainsWorldPoint(evt.position);
            });

            if (hoveredList) {
              var win = this.view.getWindow();
              if (!$world.focusedMorph.isText || (win === null || win === void 0 ? void 0 : win.isActive())) hoveredList.focus();
              this.lists.forEach(function (list) {
                var control = list._managedNode && list._managedNode.listControl;

                if (control) {
                  control.visible = list === hoveredList;
                }
              });
            }
          }
        }, {
          key: "onMouseDown",
          value: function MullerColumnViewModel_onMouseDown_(evt) {
            if (evt.targetMorph.isListItemMorph) this.clickOnItem(evt);
          }
        }, {
          key: "clickOnItem",
          value: function MullerColumnViewModel_clickOnItem_(evt) {
            var _this4 = this;

            if (this.searchString) {
              var clickedList = evt.targetMorph.owner.owner;
              var clickedItem = clickedList.items.find(function (item) {
                return item.string === evt.targetMorph.textString;
              });
              this.refresh().then(function () {
                clickedList.selectedIndex = clickedItem.normalizedIndex;
                clickedList.items.forEach(function (item) {
                  return item.normalizedIndex = null;
                });
                _this4.searchString = null;
                clickedList.scrollSelectionIntoView();
              });
            }
          }
        }, {
          key: "keybindings",
          get: function get() {
            return [{
              keys: "Left",
              command: "select previous entry of last list"
            }, {
              keys: "Right",
              command: "select first entry of next list"
            }];
          }
        }, {
          key: "commands",
          get: function get() {
            var _this5 = this;

            return [{
              name: "select previous entry of last list",
              exec: function exec() {
                if (_this5.listNavigationProhibited) return;

                var nextNode = _this5.treeData.parentNode(_this5._selectedNode);

                _this5.selectNode(nextNode);
              }
            }, {
              name: "select first entry of next list",
              exec: function exec() {
                if (_this5.listNavigationProhibited) return;
                var current = _this5._selectedNode;
                var nextNode = current.subNodes && current.subNodes[0];

                if (nextNode) {
                  _this5.selectNode(nextNode);
                }
              }
            }];
          }
        }, {
          key: "refresh",
          value: function () {
            var _MullerColumnViewModel_refresh_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
              var _this6 = this;

              var animated,
                  td,
                  expandedPath,
                  selectedFile,
                  last,
                  lists,
                  currentList,
                  _args6 = arguments;
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      animated = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : true;
                      td = this.treeData;

                      if (td) {
                        _context6.next = 4;
                        break;
                      }

                      return _context6.abrupt("return");

                    case 4:
                      expandedPath = this.getExpandedPath();
                      last = last$2(expandedPath);

                      if (td.isLeaf(last) && last !== td.root) {
                        selectedFile = last$2(expandedPath);
                        expandedPath = expandedPath.slice(0, -1);
                      }

                      _context6.next = 9;
                      return this.ensureLists(expandedPath.length, animated);

                    case 9:
                      lists = _context6.sent;
                      expandedPath.forEach(function (node) {
                        if (!td.isCollapsed(node) && currentList) {
                          noUpdate(function () {
                            currentList.selection = node;
                            currentList.focus();
                          });
                        }

                        currentList = lists.shift();
                        noUpdate(function () {
                          return currentList.selection = false;
                        });
                        var originalScroll = currentList.itemScroll;

                        if (currentList._managedNode === node) {
                          currentList.itemScroll = originalScroll;
                          var currentItems = currentList.items;
                          var newItems = td.getChildren(node);

                          if (newItems.length === currentItems.length) {
                            zip(currentItems, newItems).forEach(function (_ref) {
                              var _ref2 = _slicedToArray(_ref, 2),
                                  item = _ref2[0],
                                  value = _ref2[1];

                              if (!value) return;
                              if (!equals(item.value, value)) value.isDirty = true;
                              item.value = value;

                              if (item.value.isDirty) {
                                item.value.isDirty = false;
                                item.label = td.display(item.value);
                              }
                            });
                          } else currentList._managedNode = null;
                        }

                        if (currentList._managedNode !== node) {
                          currentList.items = td.getChildren(node).map(function (each) {
                            return {
                              isListItem: true,
                              label: td.display(each),
                              value: each,
                              tooltip: _this6.defaultTooltips ? each.name : each.tooltip || false
                            };
                          });
                          currentList._managedNode = node;
                        }

                        if (node.listControl) {
                          currentList.submorphs = currentList.submorphs.slice(0, 2).concat([node.listControl]);
                        }
                      });

                      if (selectedFile) {
                        noUpdate(function () {
                          currentList.selection = selectedFile;
                          currentList.focus();
                        });
                      } else {
                        currentList.update();
                      }

                      this.relayout();

                    case 13:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function MullerColumnViewModel_refresh_() {
              return _MullerColumnViewModel_refresh_.apply(this, arguments);
            }

            return MullerColumnViewModel_refresh_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "MullerColumnViewModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              defaultTooltips: {},
              treeData: {},
              listMaster: {
                isComponent: true,
                defaultValue: DefaultList,
                set: function set(url) {
                  this.setProperty("listMaster", url);
                  this.refresh(false);
                }
              },
              lists: {
                derived: true,
                get: function get() {
                  return this.view.submorphs;
                },
                set: function set(lists) {
                  this.view.submorphs = lists.map(function (l) {
                    l.epiMorph = true;
                    return l;
                  });
                  this.relayout();
                  this.view.env.forceUpdate();
                }
              },
              expose: {
                get: function get() {
                  return ["listMaster", "treeData", "setTreeData", "isSelected", "selectNode", "getExpandedPath", "refresh", "keybindings", "commands", "reset", "setExpandedPath", "listNavigationProhibited", "lists"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    signal: "extent",
                    handler: "relayout"
                  }, {
                    signal: "onMouseMove",
                    handler: "onMouseMove"
                  }, {
                    signal: "onHoverOut",
                    handler: "onHoverOut"
                  }, {
                    signal: "onKeyDown",
                    handler: "onKeyDown"
                  }, {
                    signal: "onMouseDown",
                    handler: "onMouseDown"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./muller-columns.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.components",
              version: "0.1.0"
            };
          }
        }, {
          start: 917,
          end: 14968
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$11.MullerColumnViewModel = MullerColumnViewModel;
      __varRecorder__$11.MullerColumnViewModel = MullerColumnViewModel;
      __varRecorder__$11.MullerColumnView = component["for"](function () {
        return component({
          defaultViewModel: __varRecorder__$11.MullerColumnViewModel,
          name: "muller column view",
          acceptDrops: false,
          borderColor: Color.rgb(23, 160, 251),
          clipMode: "auto",
          extent: pt(565.1, 285.2),
          layout: new TilingLayout({
            align: "top",
            orderByIndex: true,
            padding: {
              height: 0,
              width: 0,
              x: 0,
              y: 0
            },
            reactToSubmorphAnimations: false,
            renderViaCSS: true
          }),
          position: pt(875, 1268),
          renderOnGPU: true
        });
      }, {
        module: "lively.components/muller-columns.cp.js",
        "export": "MullerColumnView",
        range: {
          start: 14976,
          end: 15455
        }
      }, System, __varRecorder__$11, "MullerColumnView");
      var MullerColumnView = exports('M', __varRecorder__$11.MullerColumnView);
      var ColumnListDefault = exports('i', __varRecorder__$11.ColumnListDefault);
      var ColumnListDark = exports('j', __varRecorder__$11.ColumnListDark);
      __varRecorder__$11.MullerColumnView = MullerColumnView;
      __varRecorder__$11.ColumnListDefault = ColumnListDefault;
      __varRecorder__$11.ColumnListDark = ColumnListDark;

      var __varRecorder__$10 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/eval-backend-ui.js", __contextModule__);
      var EvalBackendButtonModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/eval-backend-ui.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("EvalBackendButtonModel") && typeof __lively_classholder__.EvalBackendButtonModel === "function" ? __lively_classholder__.EvalBackendButtonModel : __lively_classholder__.EvalBackendButtonModel = function EvalBackendButtonModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "trigger",
          value: function () {
            var _EvalBackendButtonModel_trigger_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var backends, currentBackend, preselect, items, _yield$this$world$fil, _yield$this$world$fil2, sysInterface, _yield$this$world$edi, status, list, _yield$this$world$edi2, choice;

              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return this.evalbackendChooser.allEvalBackends();

                    case 2:
                      backends = _context.sent;
                      currentBackend = this.currentBackend;
                      preselect = 1;
                      items = ["edit..."].concat(_toConsumableArray$1(backends.map(function (ea, i) {
                        if (currentBackend === ea) preselect = i + 1;
                        return {
                          isListItem: true,
                          label: [ea.coreInterface.description || ea.name, {
                            fontSize: "90%"
                          }],
                          value: ea
                        };
                      })));
                      _context.next = 8;
                      return this.world().filterableListPrompt("choose eval backend", items, {
                        requester: this.target,
                        preselect: preselect
                      });

                    case 8:
                      _yield$this$world$fil = _context.sent;
                      _yield$this$world$fil2 = _slicedToArray(_yield$this$world$fil.selected, 1);
                      sysInterface = _yield$this$world$fil2[0];

                      if (!(sysInterface === "edit...")) {
                        _context.next = 25;
                        break;
                      }

                      _context.next = 14;
                      return this.world().editListPrompt("choose and edit eval backends", this.evalbackendChooser.customBackends.map(function (ea) {
                        return {
                          isListItem: true,
                          label: [ea.coreInterface.description || ea.name, {
                            fontSize: "90%"
                          }],
                          value: ea
                        };
                      }), {
                        historyId: "js-eval-backend-history"
                      });

                    case 14:
                      _yield$this$world$edi = _context.sent;
                      status = _yield$this$world$edi.status;
                      list = _yield$this$world$edi.list;
                      _yield$this$world$edi2 = _slicedToArray(_yield$this$world$edi.selections, 1);
                      choice = _yield$this$world$edi2[0];

                      if (!(status === "canceled")) {
                        _context.next = 21;
                        break;
                      }

                      return _context.abrupt("return");

                    case 21:
                      this.evalbackendChooser.customBackends = list;

                      if (choice) {
                        _context.next = 24;
                        break;
                      }

                      return _context.abrupt("return");

                    case 24:
                      sysInterface = typeof choice === "string" ? this.evalbackendChooser.backendWithName(choice) : choice;

                    case 25:
                      this.currentBackend = sysInterface;

                    case 26:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function EvalBackendButtonModel_trigger_() {
              return _EvalBackendButtonModel_trigger_.apply(this, arguments);
            }

            return EvalBackendButtonModel_trigger_;
          }()
        }, {
          key: "ensureSimilarBackend",
          value: function () {
            var _EvalBackendButtonModel_ensureSimilarBackend_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
              var _this$currentBackend$, id, peer, l2lBackends, similar, focused;

              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      if (!(!this.currentBackendName || !this.currentBackendName.startsWith("l2l"))) {
                        _context2.next = 2;
                        break;
                      }

                      return _context2.abrupt("return");

                    case 2:
                      _this$currentBackend$ = this.currentBackend.coreInterface, id = _this$currentBackend$.targetId, peer = _this$currentBackend$.peer;
                      _context2.next = 5;
                      return this.evalbackendChooser.l2lEvalBackends();

                    case 5:
                      l2lBackends = _context2.sent;

                      if (!l2lBackends.some(function (ea) {
                        return ea.coreInterface.targetId === id;
                      })) {
                        _context2.next = 8;
                        break;
                      }

                      return _context2.abrupt("return");

                    case 8:
                      if (peer && peer.type) {
                        similar = l2lBackends.find(function (ea) {
                          if (!ea.coreInterface.peer) return false;
                          if (ea.coreInterface.peer.type !== peer.type) return false;

                          if (peer.user && peer.user.name && ea.coreInterface.peer.user) {
                            return ea.coreInterface.peer.user.name === peer.user.name;
                          }

                          return true;
                        });
                      }

                      if (similar) {
                        focused = $world.focusedMorph;
                        this.currentBackend = similar;
                        focused && setTimeout(function () {
                          return focused.focus();
                        }, 0);
                      }

                    case 10:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function EvalBackendButtonModel_ensureSimilarBackend_() {
              return _EvalBackendButtonModel_ensureSimilarBackend_.apply(this, arguments);
            }

            return EvalBackendButtonModel_ensureSimilarBackend_;
          }()
        }, {
          key: "updateFromTarget",
          value: function EvalBackendButtonModel_updateFromTarget_() {
            this.currentBackend = this.target.systemInterface;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "EvalBackendButtonModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              currentBackendName: {
                after: ["label"],
                defaultValue: "local",
                set: function set(name) {
                  this.setProperty("currentBackendName", name);
                  var backend = this.currentBackend;
                  var descr = backend && backend.coreInterface && backend.coreInterface.description;
                  var label = truncate(descr || name || "local", 25);
                  this.ui.label.textString = label;
                }
              },
              currentBackend: {
                derived: true,
                get: function get() {
                  return this.evalbackendChooser.backendWithName(this.currentBackendName);
                },
                set: function set(backend) {
                  this.currentBackendName = backend ? backend.name : "local";
                  if (this.view) signal(this.view, "currentBackend", backend);
                }
              },
              evalbackendChooser: {
                readOnly: true,
                derived: true,
                get: function get() {
                  return __varRecorder__$10.EvalBackendChooser["default"];
                }
              },
              target: {},
              expose: {
                get: function get() {
                  return ["updateFromTarget", "ensureSimilarBackend", "target"];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/eval-backend-ui.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 492,
          end: 4035
        });
      }({
        referencedAs: "ButtonModel",
        value: ButtonModel
      });
      __varRecorder__$10.EvalBackendButtonModel = EvalBackendButtonModel;
      __varRecorder__$10.EvalBackendButtonModel = EvalBackendButtonModel;

      var EvalBackendChooser = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/eval-backend-ui.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("EvalBackendChooser") && typeof __lively_classholder__.EvalBackendChooser === "function" ? __lively_classholder__.EvalBackendChooser : __lively_classholder__.EvalBackendChooser = function EvalBackendChooser(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "customBackends",
          get: function get() {
            var stored = [];

            try {
              var stringified = localStorage["lively.morphic-ide/js/EvalBackendChooser-history"];

              var _stored = stringified ? JSON.parse(stringified) : [];

              return _stored.map(function (ea) {
                return ea.startsWith("http") ? serverInterfaceFor(ea) : null;
              }).filter(Boolean);
            } catch (e) {}

            return stored || [];
          }
        }, {
          key: "customBackends",
          set: function set(backends) {
            backends = backends.filter(function (ea) {
              return !!ea && ea !== "local" && ea !== "edit...";
            });

            try {
              localStorage["lively.morphic-ide/js/EvalBackendChooser-history"] = JSON.stringify(backends);
            } catch (e) {}
          }
        }, {
          key: "backendWithName",
          value: function EvalBackendChooser_backendWithName_(name) {
            if (!name || name === "local") return localInterface;
            if (name.startsWith("http")) return serverInterfaceFor(name);
            if (name.startsWith("l2l")) return l2lInterfaceFor(name.split(" ")[1]);
            return localInterface;
          }
        }, {
          key: "httpEvalBackends",
          get: function get() {
            return [serverInterfaceFor(config$2.remotes.server)];
          }
        }, {
          key: "l2lEvalBackends",
          value: function () {
            var _EvalBackendChooser_l2lEvalBackends_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
              var l2lClient, peers;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      l2lClient = L2LClient.forLivelyInBrowser();
                      _context4.next = 3;
                      return l2lClient.listPeers();

                    case 3:
                      peers = _context4.sent;
                      peers = peers.filter(function (ea) {
                        return ea.id !== l2lClient.id;
                      });
                      _context4.next = 7;
                      return Promise.all(peers.map( /*#__PURE__*/function () {
                        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(ea) {
                          return regeneratorRuntime.wrap(function _callee3$(_context3) {
                            while (1) {
                              switch (_context3.prev = _context3.next) {
                                case 0:
                                  return _context3.abrupt("return", l2lInterfaceFor(ea.id, ea));

                                case 1:
                                case "end":
                                  return _context3.stop();
                              }
                            }
                          }, _callee3);
                        }));

                        return function (_x) {
                          return _ref.apply(this, arguments);
                        };
                      }()));

                    case 7:
                      return _context4.abrupt("return", _context4.sent);

                    case 8:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            }));

            function EvalBackendChooser_l2lEvalBackends_() {
              return _EvalBackendChooser_l2lEvalBackends_.apply(this, arguments);
            }

            return EvalBackendChooser_l2lEvalBackends_;
          }()
        }, {
          key: "allEvalBackends",
          value: function () {
            var _EvalBackendChooser_allEvalBackends_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.t0 = arr;
                      _context5.t1 = [localInterface];
                      _context5.t2 = _toConsumableArray$1(this.customBackends);
                      _context5.t3 = _toConsumableArray$1(this.httpEvalBackends);
                      _context5.t4 = _toConsumableArray$1;
                      _context5.next = 7;
                      return this.l2lEvalBackends();

                    case 7:
                      _context5.t5 = _context5.sent;
                      _context5.t6 = (0, _context5.t4)(_context5.t5);
                      _context5.t7 = _context5.t1.concat.call(_context5.t1, _context5.t2, _context5.t3, _context5.t6);
                      return _context5.abrupt("return", _context5.t0.uniq.call(_context5.t0, _context5.t7));

                    case 11:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function EvalBackendChooser_allEvalBackends_() {
              return _EvalBackendChooser_allEvalBackends_.apply(this, arguments);
            }

            return EvalBackendChooser_allEvalBackends_;
          }()
        }, {
          key: "buildEvalBackendDropdownFor",
          value: function EvalBackendChooser_buildEvalBackendDropdownFor_(morph, btn) {
            btn = btn || part(SystemButton, {
              name: "eval backend button",
              defaultViewModel: __varRecorder__$10.EvalBackendButtonModel,
              layout: new TilingLayout({
                axisAlign: "center",
                hugContentsHorizontally: true,
                padding: Rectangle.inset(5, 0, 5, 0)
              }),
              viewModel: {
                target: morph
              },
              height: 20,
              submorphs: [{
                name: "label",
                fontSize: 11
              }]
            });
            setTimeout(function () {
              return btn.updateFromTarget();
            }, 0);
            connect(btn, "currentBackend", this, "changeEvalBackend", {
              updater: function updater($upd, choice) {
                $upd(choice, this.sourceObj.target);
              }
            });
            btn.startStepping(5000, "ensureSimilarBackend");
            return btn;
          }
        }, {
          key: "ensureEvalBackendDropdown",
          value: function EvalBackendChooser_ensureEvalBackendDropdown_(morph, currentBackend) {
            var dropdown = morph.getSubmorphNamed("eval backend button");
            if (!dropdown) dropdown = this.buildEvalBackendDropdownFor(morph);
            return dropdown;
          }
        }, {
          key: "changeEvalBackend",
          value: function () {
            var _EvalBackendChooser_changeEvalBackend_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(choice, requester) {
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      if (requester) {
                        _context6.next = 3;
                        break;
                      }

                      console.warn("Called EvalBackendChooser.changeEvalBackend without requester!");
                      return _context6.abrupt("return");

                    case 3:
                      try {
                        if (!choice) choice = localInterface;

                        if (requester.systemInterface !== choice) {
                          requester.setStatusMessage("Eval backend is now ".concat(choice.name));
                          requester.setEvalBackend(choice);
                        }

                        requester.focus();
                      } catch (err) {
                        console.warn("changeEvalBackend error: ".concat(err));
                      }

                    case 4:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6);
            }));

            function EvalBackendChooser_changeEvalBackend_(_x2, _x3) {
              return _EvalBackendChooser_changeEvalBackend_.apply(this, arguments);
            }

            return EvalBackendChooser_changeEvalBackend_;
          }()
        }, {
          key: "activateEvalBackendCommand",
          value: function EvalBackendChooser_activateEvalBackendCommand_(requester) {
            return {
              name: "activate eval backend dropdown list",
              exec: function exec() {
                var btn = requester.getSubmorphNamed("eval backend button");
                btn && btn.trigger();
                return true;
              }
            };
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "EvalBackendChooser";
          }
        }, {
          key: "default",
          get: function get() {
            return this._default || (this._default = new this());
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/eval-backend-ui.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 4052,
          end: 8288
        });
      }(undefined);
      __varRecorder__$10["default"] = EvalBackendChooser;

      var evalBackendUi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        EvalBackendButtonModel: EvalBackendButtonModel,
        'default': EvalBackendChooser
      });

      var __varRecorder__$$ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/browser/tree.js", __contextModule__);
      var __moduleMeta__$u = {
        pathInPackage: function pathInPackage() {
          return "./js/browser/tree.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var listEditableFilesInDir = __varRecorder__$$["lively.ide/js/browser/tree.js__define__"]("listEditableFilesInDir", "function", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(url) {
          var resources;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return resource(url).dirList();

                case 2:
                  _context.t0 = function (res) {
                    return res.isDirectory() || __varRecorder__$$.editableFiles.includes(res.ext());
                  };

                  resources = _context.sent.filter(_context.t0);
                  return _context.abrupt("return", resources.map(function (res) {
                    var type;
                    if (res.isDirectory()) type = "directory";else type = res.ext();
                    return {
                      isCollapsed: true,
                      name: res.name(),
                      size: res.size,
                      lastModified: res.lastModified,
                      url: res.url,
                      type: type
                    };
                  }));

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }(), __moduleMeta__$u);

      __varRecorder__$$.listEditableFilesInDir = listEditableFilesInDir;

      var transformJSONNode = __varRecorder__$$["lively.ide/js/browser/tree.js__define__"]("transformJSONNode", "function", function (property) {
        if (property.type === "ObjectExpression") {
          property.children = property.properties.map(function (n) {
            return transformJSONNode(n);
          });
        }

        if (property.value && property.value.type === "ObjectExpression") {
          property.children = property.value.properties.map(function (n) {
            return transformJSONNode(n);
          });
        }

        if (property.type === "ArrayExpression") {
          property.children = property.elements.map(function (n) {
            return transformJSONNode(n);
          });
        }

        if (property.value && property.value.type === "ArrayExpression") {
          property.children = property.value.elements.map(function (n) {
            return transformJSONNode(n);
          });
        }

        if (!property.key) {
          property.start = property.start - 13;
          property.end = property.end - 13;
          property.name = property.value;
        } else {
          property.start = property.key.start - 13;
          property.end = property.end - 13;
          property.name = property.key.value;
          property.type = property.value.type === "ObjectExpression" ? "object-decl" : property.value.type === "ArrayExpression" ? "array-decl" : "Literal";
        }

        property.isDeclaration = true;
        property.isCollapsed = true;

        if (!property.name) {
          property.name = "[ANONYMOUS OBJECT]";
        }

        return property;
      }, __moduleMeta__$u);

      __varRecorder__$$.transformJSONNode = transformJSONNode;

      var listJSONScope = __varRecorder__$$["lively.ide/js/browser/tree.js__define__"]("listJSONScope", "function", /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url) {
          var json, parsedNode, entries, _iterator, _step, property;

          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return resource(url).read();

                case 2:
                  json = _context2.sent;
                  parsedNode = parse$2("const test = " + json);
                  entries = parsedNode.body[0].declarations[0].init.properties;
                  _iterator = _createForOfIteratorHelper(entries);

                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                      property = _step.value;

                      __varRecorder__$$.transformJSONNode(property);
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }

                  return _context2.abrupt("return", entries);

                case 8:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      }(), __moduleMeta__$u);

      __varRecorder__$$.listJSONScope = listJSONScope;
      __varRecorder__$$.editableFiles = ["md", "js", "json", "css", "html", "mjs", "cjs"];
      var editableFiles = __varRecorder__$$.editableFiles;
      __varRecorder__$$.editableFiles = editableFiles;

      var __varRecorder__$_ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/checker.js", __contextModule__);
      __varRecorder__$_.defaultWarnStyle = {
        "border-bottom": "2px dotted orange"
      };
      __varRecorder__$_.defaultErrorStyle = {
        "background-color": "red"
      };

      var JavaScriptChecker = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/checker.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("JavaScriptChecker") && typeof __lively_classholder__.JavaScriptChecker === "function" ? __lively_classholder__.JavaScriptChecker : __lively_classholder__.JavaScriptChecker = function JavaScriptChecker(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "uninstall",
          value: function JavaScriptChecker_uninstall_(editor) {
            var morph = editor.text || editor;
            (morph.markers || []).forEach(function (ea) {
              return ea.id.startsWith("js-checker-") && morph.removeMarker(ea);
            });
            morph.removeMarker("js-syntax-error");
          }
        }, {
          key: "hasEmbeddedMorphInRange",
          value: function JavaScriptChecker_hasEmbeddedMorphInRange_(textMorph, range) {
            if (!range.isRange) range = new Range(range);
            return _toConsumableArray$1(textMorph.embeddedMorphMap.values()).find(function (_ref) {
              var anchor = _ref.anchor;
              return range.containsPosition(anchor.position);
            });
          }
        }, {
          key: "onDocumentChange",
          value: function JavaScriptChecker_onDocumentChange_(change, morph, jsPlugin) {
            var parsed;
            var doc = morph.document;
            var theme = jsPlugin.theme;

            try {
              parsed = jsPlugin.parse();
            } catch (e) {
              parsed = e;
            }

            if (!parsed) return;
            var prevMarkers = (morph.markers || []).filter(function (_ref2) {
              var id = _ref2.id;
              return id.startsWith("js-checker-");
            });
            var newMarkers = jsPlugin.undeclaredVariables().map(function (_ref3, i) {
              var start = _ref3.start,
                  end = _ref3.end;
                  _ref3.name;
                  _ref3.type;
              start = doc.indexToPosition(start);
              end = doc.indexToPosition(end);
              return morph.addMarker({
                id: "js-checker-" + i,
                style: theme ? theme.warning : __varRecorder__$_.defaultWarnStyle,
                range: {
                  start: start,
                  end: end
                },
                type: "js-undeclared-var"
              });
            });
            prevMarkers.slice(newMarkers.length).forEach(function (ea) {
              return morph.removeMarker(ea);
            });

            if (parsed.parseError) {
              var _parsed$parseError$lo = parsed.parseError.loc,
                  column = _parsed$parseError$lo.column,
                  line = _parsed$parseError$lo.line;
              var row = line - 1;
              __varRecorder__$_.__inter0__ = doc.indexToPosition(parsed.parseError.pos), column = __varRecorder__$_.__inter0__.column, row = __varRecorder__$_.__inter0__.row, __varRecorder__$_.__inter0__;
              var range = {
                start: {
                  column: column - 1,
                  row: row
                },
                end: {
                  column: column + 1,
                  row: row
                }
              };
              if (this.hasEmbeddedMorphInRange(morph, range)) return;
              morph.addMarker({
                id: "js-syntax-error",
                range: range,
                style: theme ? theme.error : __varRecorder__$_.defaultErrorStyle,
                type: "js-syntax-error"
              });
            } else {
              morph.removeMarker("js-syntax-error");
            }
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "JavaScriptChecker";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/checker.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 179,
          end: 2098
        });
      }(undefined);
      __varRecorder__$_["default"] = JavaScriptChecker;

      var __varRecorder__$Z = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/navigator.js", __contextModule__);

      var JavaScriptNavigator = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/navigator.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("JavaScriptNavigator") && typeof __lively_classholder__.JavaScriptNavigator === "function" ? __lively_classholder__.JavaScriptNavigator : __lively_classholder__.JavaScriptNavigator = function JavaScriptNavigator(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "ensureAST",
          value: function JavaScriptNavigator_ensureAST_(ed) {
            return this.parse(ed.textString);
          }
        }, {
          key: "parse",
          value: function JavaScriptNavigator_parse_(source) {
            return fuzzyParse(source);
          }
        }, {
          key: "move",
          value: function JavaScriptNavigator_move_(selector, ed) {
            var select = !!ed.activeMark || !ed.selection.isEmpty();
            var sel = ed.selection;
            var pos = sel.lead;
            var idx = ed.positionToIndex(pos);
            var newIdx = this[selector](ed.textString, idx);
            var newPos = ed.indexToPosition(newIdx);
            sel.isBackwards;
            sel.lead = newPos;

            if (!select) {
              sel.anchor = newPos;
            }

            ed.scrollCursorIntoView();
          }
        }, {
          key: "forwardSexp",
          value: function JavaScriptNavigator_forwardSexp_(ed) {
            this.move("_forwardSexp", ed);
          }
        }, {
          key: "backwardSexp",
          value: function JavaScriptNavigator_backwardSexp_(ed) {
            this.move("_backwardSexp", ed);
          }
        }, {
          key: "backwardUpSexp",
          value: function JavaScriptNavigator_backwardUpSexp_(ed) {
            this.move("_backwardUpSexp", ed);
          }
        }, {
          key: "forwardDownSexp",
          value: function JavaScriptNavigator_forwardDownSexp_(ed) {
            this.move("_forwardDownSexp", ed);
          }
        }, {
          key: "_forwardSexp",
          value: function JavaScriptNavigator__forwardSexp_(src, pos) {
            var ast = this.parse(src);
            var nodes = custom.findNodesIncluding(ast, pos);
            var containingNode = nodes.reverse().find(function (n) {
              return n.end !== pos;
            });
            if (!containingNode) return pos;

            if (containingNode.type === "BlockStatement") {
              var sibling = containingNode.body.find(function (node) {
                return node.start > pos;
              });
              if (sibling) return sibling.start;
            }

            return containingNode.end;
          }
        }, {
          key: "_backwardSexp",
          value: function JavaScriptNavigator__backwardSexp_(src, pos) {
            var ast = this.parse(src);
            var nodes = custom.findNodesIncluding(ast, pos);
            var containingNode = nodes.reverse().find(function (n) {
              return n.start !== pos;
            });
            if (!containingNode) return pos;

            if (containingNode.type === "BlockStatement") {
              var sibling = containingNode.body.slice().reverse().find(function (node) {
                return node.end < pos;
              });
              if (sibling) return sibling.end;
            }

            return containingNode ? containingNode.start : pos;
          }
        }, {
          key: "_backwardUpSexp",
          value: function JavaScriptNavigator__backwardUpSexp_(src, pos) {
            var ast = this.parse(src);
            var nodes = custom.findNodesIncluding(ast, pos);
            var containingNode = nodes.reverse().find(function (n) {
              return n.start !== pos;
            });
            return containingNode ? containingNode.start : pos;
          }
        }, {
          key: "_forwardDownSexp",
          value: function JavaScriptNavigator__forwardDownSexp_(src, pos) {
            var ast = this.parse(src);
            var found = findNodeAfter(ast, pos, function (type, node) {
              return node.start > pos;
            });
            return found ? found.node.start : pos;
          }
        }, {
          key: "markDefun",
          value: function JavaScriptNavigator_markDefun_(ed) {
            var range = this.rangeForFunctionOrDefinition(ed.textString, [ed.positionToIndex(ed.selection.range.start), ed.positionToIndex(ed.selection.range.end)]);
            if (range) ed.execCommand("expandRegion", {
              start: range[0],
              end: range[1]
            });
          }
        }, {
          key: "rangeForNodesMatching",
          value: function JavaScriptNavigator_rangeForNodesMatching_(src, pos, func) {
            var ast = this.parse(src);
            var nodes = custom.findNodesIncluding(ast, pos);
            var containingNode = nodes.reverse().find(func);
            return containingNode ? [containingNode.start, containingNode.end] : null;
          }
        }, {
          key: "rangeForFunctionOrDefinition",
          value: function JavaScriptNavigator_rangeForFunctionOrDefinition_(src, currentRange) {
            var isNullSelection = currentRange[0] === currentRange[1];
            return this.rangeForNodesMatching(src, currentRange[1], function (node) {
              var typeOK = ["AssignmentExpression", "FunctionDeclaration", "FunctionExpression", "MethodDefinition"].includes(node.type);
              if (typeOK && (isNullSelection && node.end !== currentRange[1] || !isNullSelection && node.start < currentRange[0])) return true;
              return false;
            });
          }
        }, {
          key: "resolveIdentifierAt",
          value: function JavaScriptNavigator_resolveIdentifierAt_(editor, pos) {
            if (typeof pos !== "number") pos = editor.positionToIndex(pos);
            var parsed = this.ensureAST(editor);
            var nodes = nodesAt$1(pos, parsed).reverse();
            var id = nodes.find(function (ea) {
              return ea.type === "Identifier";
            });

            if (!id) {
              var node = nodes[0];

              if (node && node.type.includes("Specifier") && node.local && node.local.type === "Identifier") {
                id = node.local;
              }

              if (!id) return undefined;
            }

            var decl = findDeclarationClosestToIndex(parsed, id.name, pos);
            var scope = decl ? scopeAtIndex(parsed, decl.start) : scopeAtIndex(parsed, pos);

            var _query$findReferences = findReferencesAndDeclsInScope(scope, id.name),
                refs = _query$findReferences.refs;

            return {
              parsed: parsed,
              scope: scope,
              id: id,
              name: id.name,
              decl: decl,
              refs: refs
            };
          }
        }, {
          key: "expandRegion",
          value: function JavaScriptNavigator_expandRegion_(ed, src, ast, expandState) {
            var hasSelection = expandState.range[0] !== expandState.range[1];
            var p = ed.indexToPosition(expandState.range[0]);
            var token = ed.tokenAt(p);

            if (!hasSelection && token && ["keyword", "identifier"].includes(token.type)) {
              return expandOnToken();
            }

            ast = ast || this.parse(src);
            var pos = expandState.range[0];
            var nodes = nodesAtIndex(ast, pos);
            var containingNode = nodes.reverse().find(function (node) {
              return node.start < expandState.range[0] || node.end > expandState.range[1];
            });
            if (!containingNode) return expandState;
            var start = containingNode.start;
            var end = containingNode.end;

            if (containingNode.type === "Literal" && (containingNode.raw || "").match(/^['"`]/) && expandState.range[0] !== containingNode.start && expandState.range[1] !== containingNode.end && (containingNode.start + 1 < expandState.range[0] || containingNode.end - 1 > expandState.range[1])) {
              return {
                range: [start + 1, end - 1],
                prev: expandState
              };
            }

            return {
              range: [start, end],
              prev: expandState
            };

            function expandOnToken(t) {
              var tokenPos = tokenPosition();
              return {
                range: [tokenPos.tokenStart, tokenPos.tokenEnd],
                prev: expandState
              };
            }

            function tokenPosition() {
              var offset = posToIdx({
                column: 0,
                row: p.row
              });
              return {
                tokenStart: offset + token.start,
                tokenEnd: offset + token.start + token.value.length
              };
            }

            function posToIdx(pos) {
              return ed.positionToIndex(pos);
            }
          }
        }, {
          key: "contractRegion",
          value: function JavaScriptNavigator_contractRegion_(ed, src, ast, expandState) {
            return expandState.prev || expandState;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "JavaScriptNavigator";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/navigator.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 127,
          end: 6784
        });
      }(undefined);
      __varRecorder__$Z["default"] = JavaScriptNavigator;

      var __varRecorder__$Y = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/snippets.js", __contextModule__);
      var __moduleMeta__$t = {
        pathInPackage: function pathInPackage() {
          return "./text/snippets.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var addIndexToTextPos = __varRecorder__$Y["lively.ide/text/snippets.js__define__"]("addIndexToTextPos", "function", function (textMorph, textPos, index) {
        return textMorph.indexToPosition(textMorph.positionToIndex(textPos) + index);
      }, __moduleMeta__$t);

      __varRecorder__$Y.addIndexToTextPos = addIndexToTextPos;
      var Snippet = exports('S', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/snippets.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("Snippet") && typeof __lively_classholder__.Snippet === "function" ? __lively_classholder__.Snippet : __lively_classholder__.Snippet = function Snippet(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function Snippet_initialize_() {
            var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
              trigger: null,
              expansion: ""
            };
            var trigger = opts.trigger,
                expansion = opts.expansion;
            this.trigger = trigger;
            this.expansion = expansion;
            this.resetExpansionState();
          }
        }, {
          key: "isTextSnippet",
          get: function get() {
            return true;
          }
        }, {
          key: "attach",
          value: function Snippet_attach_(textMorph) {
            if (!this.isExpanding) return;
            this.textMorph = textMorph;
            connect(this.textMorph, "selectionChange", this, "onCursorMove");
          }
        }, {
          key: "detach",
          value: function Snippet_detach_(textMorph) {
            if (!this.isExpanding) return;
            disconnect(textMorph, "selectionChange", this, "onCursorMove");
            this.textMorph = null;
          }
        }, {
          key: "onCursorMove",
          value: function Snippet_onCursorMove_() {
            var _this$expansionState = this.expansionState,
                startAnchor = _this$expansionState.startAnchor,
                endAnchor = _this$expansionState.endAnchor,
                isExpanding = _this$expansionState.isExpanding;

            if (!isExpanding) {
              this.resetExpansionState();
              return;
            }

            var range = Range.fromPositions(startAnchor.position, endAnchor.position);

            if (!range.containsPosition(this.textMorph.cursorPosition)) {
              this.resetExpansionState();
            }
          }
        }, {
          key: "resetExpansionState",
          value: function Snippet_resetExpansionState_() {
            var m = this.textMorph;

            if (m) {
              var _ref = this.expansionState || {},
                  marker = _ref.marker,
                  startAnchor = _ref.startAnchor,
                  endAnchor = _ref.endAnchor,
                  steps = _ref.steps;

              if (startAnchor) m.removeAnchor(startAnchor);
              if (endAnchor) m.removeAnchor(endAnchor);
              if (marker) m.removeMarker(marker);
              steps.forEach(function (_ref2) {
                var anchor = _ref2.anchor;
                return m.removeAnchor(anchor);
              });
            }

            this.expansionState = {
              stepIndex: -1,
              steps: [],
              isExpanding: false,
              startMarker: null,
              endMarker: null
            };
            m && m.removePlugin(this);
          }
        }, {
          key: "isExpanding",
          get: function get() {
            return this.expansionState.isExpanding;
          }
        }, {
          key: "createExpansionSteps",
          value: function Snippet_createExpansionSteps_(expansion) {
            var steps = [];
            var matches = reMatches(expansion, /\$[0-9]+|\$\{[0-9]+:[^\}]*\}/g);
            var offset = 0;
            matches.forEach(function (_ref3) {
              var start = _ref3.start,
                  end = _ref3.end,
                  match = _ref3.match;
              var n;
              var prefill = "";

              if (match.startsWith("${")) {
                var _match$match = match.match(/^\$\{([0-9]+):([^\}]*)\}/),
                    _match$match2 = _slicedToArray(_match$match, 3);
                    _match$match2[0];
                    var nString = _match$match2[1],
                    _prefill = _match$match2[2];

                n = Number(nString);
                prefill = _prefill;
              } else {
                n = Number(match.replace(/^\$/, ""));
              }

              expansion = expansion.slice(0, start - offset) + prefill + expansion.slice(end - offset);
              steps[n] = {
                index: start - offset,
                prefill: prefill,
                anchor: null
              };
              offset += end - start - prefill.length;
            });
            return {
              steps: steps,
              expansion: expansion
            };
          }
        }, {
          key: "expandAtCursor",
          value: function Snippet_expandAtCursor_(textMorph) {
            var m = textMorph;
            var sel = m.selection;

            if (typeof this.expansion === "function") {
              this.expansion = this.expansion(m.document.textInRange({
                start: m.cursorPosition,
                end: m.document.endPosition
              }));
            }

            var indent$1 = m.cursorPosition.column;
            var expansion = this.expansion;

            if (this.trigger) {
              indent$1 -= this.trigger.length;
            }

            indent$1 = Math.max(0, indent$1);

            if (indent$1) {
              var lines$1 = lines(expansion);
              lines$1 = [lines$1[0]].concat(_toConsumableArray$1(lines$1.slice(1).map(function (line) {
                return indent(line, " ", indent$1);
              })));
              expansion = lines$1.join("\n");
            }

            var _this$createExpansion = this.createExpansionSteps(expansion),
                expansion = _this$createExpansion.expansion,
                steps = _this$createExpansion.steps;

            if (this.trigger) {
              sel.growLeft(this.trigger.length);
            }

            sel.text = expansion;
            var start = sel.start,
                end = sel.end;
            sel.collapseToEnd();
            if (!steps.length) return;
            var id = newUUID();
            steps.forEach(function (step, i) {
              return step.anchor = m.addAnchor(Object.assign({
                id: "snippet-step-".concat(i, "-") + id
              }, __varRecorder__$Y.addIndexToTextPos(m, start, step.index)));
            });
            var startAnchor = m.addAnchor(Object.assign({
              id: "snippet-start-" + id
            }, start, {
              insertBehavior: "stay"
            }));
            var endAnchor = m.addAnchor(Object.assign({
              id: "snippet-end-" + id
            }, end));
            var marker = m.addMarker({
              id: "snippet-marker-" + id,

              get range() {
                return {
                  start: startAnchor.position,
                  end: endAnchor.position
                };
              },

              style: {
                "border-radius": "4px",
                "background-color": "rgba(30, 200, 140, 0.3)",
                "box-shadow": "0 0 4px rgba(30, 200, 140, 0.3)",
                "pointer-events": "none",
                content: "fooooo"
              }
            });
            this.expansionState = {
              marker: marker,
              startAnchor: startAnchor,
              endAnchor: endAnchor,
              stepIndex: 0,
              steps: steps,
              isExpanding: true
            };
            m.addPlugin(this);
            this.nextStep();
          }
        }, {
          key: "nextStep",
          value: function Snippet_nextStep_() {
            var _this$expansionState2 = this.expansionState,
                steps = _this$expansionState2.steps,
                stepIndex = _this$expansionState2.stepIndex,
                isExpanding = _this$expansionState2.isExpanding;
            var m = this.textMorph;
            if (!isExpanding || !m) return;
            var sel = m.selection;
            var _steps$stepIndex = steps[stepIndex],
                stepPosition = _steps$stepIndex.anchor.position,
                prefill = _steps$stepIndex.prefill;
            sel.lead = sel.anchor = stepPosition;
            sel.growRight(prefill.length);
            this.expansionState.stepIndex++;

            if (this.expansionState.stepIndex >= steps.length) {
              this.resetExpansionState();
              console.log("[snippet] expansion of ".concat(this.expansion, " done"));
            }
          }
        }, {
          key: "canExpand",
          value: function Snippet_canExpand_(text) {
            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : text.cursorPosition;
            var triggerEnd = text.positionToIndex(text.cursorPosition);
            var triggerStart = triggerEnd - this.trigger.length;
            return text.textString.slice(triggerStart, triggerEnd) === this.trigger;
          }
        }, {
          key: "tryTrigger",
          value: function Snippet_tryTrigger_(text) {
            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : text.cursorPosition;
            if (!this.canExpand(text, text.cursorPosition)) return false;
            this.expandAtCursor(text);
            return true;
          }
        }, {
          key: "getCommands",
          value: function Snippet_getCommands_(commands) {
            var _this = this;

            return commands.concat([{
              name: "[snippet] next expansion step",
              exec: function exec(textMorph) {
                _this.nextStep();

                return true;
              }
            }, {
              name: "[snippet] cancel expansion",
              exec: function exec(textMorph) {
                _this.resetExpansionState();

                return true;
              }
            }]);
          }
        }, {
          key: "getKeyHandlers",
          value: function Snippet_getKeyHandlers_(handlers) {
            return handlers.concat(KeyHandler.withBindings([{
              keys: "Tab",
              command: "[snippet] next expansion step"
            }, {
              keys: "Escape",
              command: "[snippet] cancel expansion"
            }]));
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "Snippet";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./text/snippets.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 357,
          end: 6808
        });
      }(undefined));
      __varRecorder__$Y.Snippet = Snippet;
      __varRecorder__$Y.Snippet = Snippet;
      __varRecorder__$Y.snippetCommands = [{
        name: "get snippets",
        exec: function exec(textMorph) {
          return textMorph.pluginCollect("getSnippets", []);
        }
      }];
      var snippetCommands = __varRecorder__$Y.snippetCommands;
      __varRecorder__$Y.snippetCommands = snippetCommands;

      var __varRecorder__$X = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/completers.js", __contextModule__);
      var __moduleMeta__$s = {
        pathInPackage: function pathInPackage() {
          return "./js/completers.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var buildEvalOpts = __varRecorder__$X["lively.ide/js/completers.js__define__"]("buildEvalOpts", "function", function (morph, additionalOpts) {
        var p = morph.plugins.find(function (p) {
          return p.isJSEditorPlugin;
        });
        return p.sanatizedJsEnv(additionalOpts);
      }, __moduleMeta__$s);

      __varRecorder__$X.buildEvalOpts = buildEvalOpts;
      var ModuleTopLevelVarCompleter = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/completers.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ModuleTopLevelVarCompleter") && typeof __lively_classholder__.ModuleTopLevelVarCompleter === "function" ? __lively_classholder__.ModuleTopLevelVarCompleter : __lively_classholder__.ModuleTopLevelVarCompleter = function ModuleTopLevelVarCompleter(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "compute",
          value: function () {
            var _ModuleTopLevelVarCompleter_compute_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(textMorph, prefix) {
              var p, endpoint, opts, m, names, result, basePriority;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      p = textMorph.pluginFind(function (p) {
                        return p.isJSEditorPlugin;
                      });
                      endpoint = p && p.systemInterface();

                      if (endpoint) {
                        _context.next = 4;
                        break;
                      }

                      return _context.abrupt("return", []);

                    case 4:
                      opts = __varRecorder__$X.buildEvalOpts(textMorph);
                      m = opts.targetModule;

                      if (!(endpoint.name !== "local")) {
                        _context.next = 15;
                        break;
                      }

                      _context.next = 9;
                      return endpoint.runEval("\n        var result, livelySystem = typeof System !== \"undefined\"\n                      && System.get(System.decanonicalize(\"lively-system-interface\"));\n        if (livelySystem) {\n          result = JSON.stringify(\n            Object.getOwnPropertyNames(livelySystem.localInterface.getModule(\"".concat(m, "\").recorder));\n        } else {\n          var G = typeof window !== \"undefined\" ?\n            window : typeof global !== \"undefined\" ? global : this;\n          result = JSON.stringify(Object.getOwnPropertyNames(G));\n        }\n        result;\n      "), {
                        targetModule: "lively://module-recorder-completer"
                      });

                    case 9:
                      result = _context.sent;

                      if (!result.isError) {
                        _context.next = 12;
                        break;
                      }

                      return _context.abrupt("return", []);

                    case 12:
                      names = JSON.parse(result.value);
                      _context.next = 16;
                      break;

                    case 15:
                      names = Object.getOwnPropertyNames(endpoint.getModule(m).recorder);

                    case 16:
                      names = names.filter(function (ea) {
                        return !ea.startsWith("defVar_") && !["System", "__currentLivelyModule", "initializeES6ClassForLively", "_moduleExport", "_moduleImport"].includes(ea);
                      });
                      basePriority = 1100;
                      return _context.abrupt("return", names.map(function (ea) {
                        return {
                          priority: basePriority,
                          completion: ea
                        };
                      }));

                    case 19:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));

            function ModuleTopLevelVarCompleter_compute_(_x, _x2) {
              return _ModuleTopLevelVarCompleter_compute_.apply(this, arguments);
            }

            return ModuleTopLevelVarCompleter_compute_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ModuleTopLevelVarCompleter";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/completers.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 227,
          end: 1700
        });
      }(undefined);
      __varRecorder__$X.ModuleTopLevelVarCompleter = ModuleTopLevelVarCompleter;
      __varRecorder__$X.ModuleTopLevelVarCompleter = ModuleTopLevelVarCompleter;
      var DynamicJavaScriptCompleter = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/completers.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DynamicJavaScriptCompleter") && typeof __lively_classholder__.DynamicJavaScriptCompleter === "function" ? __lively_classholder__.DynamicJavaScriptCompleter : __lively_classholder__.DynamicJavaScriptCompleter = function DynamicJavaScriptCompleter(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "isValidPrefix",
          value: function DynamicJavaScriptCompleter_isValidPrefix_(prefix) {
            return /\.[a-z0-9_]*$/i.test(prefix);
          }
        }, {
          key: "isMethodCallCompletion",
          value: function DynamicJavaScriptCompleter_isMethodCallCompletion_(completion) {
            return completion.endsWith(")") && completion.indexOf("(") > 0;
          }
        }, {
          key: "isValidIdentifier",
          value: function DynamicJavaScriptCompleter_isValidIdentifier_(completion) {
            if (typeof completion !== "string") return false;

            if (this.isMethodCallCompletion(completion)) {
              completion = completion.slice(0, completion.indexOf("("));
            }

            if (/^[a-z_\$][0-9a-z_\$]*$/i.test(completion)) return true;
            return false;
          }
        }, {
          key: "wrapInBrackets",
          value: function DynamicJavaScriptCompleter_wrapInBrackets_(completion) {
            var n = Number(completion);
            if (!isNaN(n) || completion.startsWith("Symbol.")) return "[".concat(completion, "]");
            var trailing = "";

            if (this.isMethodCallCompletion(completion)) {
              trailing = completion.slice(completion.indexOf("("));
              completion = completion.slice(0, completion.indexOf("("));
            }

            return "[\"".concat(completion.replace(/\"/g, "\\\""), "\"]").concat(trailing);
          }
        }, {
          key: "compute",
          value: function () {
            var _DynamicJavaScriptCompleter_compute_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(textMorph) {
              var _this = this;

              var sel, roughPrefix, p, endpoint, opts, _yield$endpoint$dynam, isError, err, completions, prefix, priority, processed;

              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      sel = textMorph.selection;

                      if (sel.isEmpty()) {
                        roughPrefix = textMorph.getLine(sel.lead.row);
                        roughPrefix = roughPrefix.slice(roughPrefix.lastIndexOf(":") + 1, sel.lead.column);
                      } else {
                        roughPrefix = sel.text.slice(Math.max(0, sel.text.indexOf(":")), 0);
                      }

                      if (this.isValidPrefix(roughPrefix)) {
                        _context2.next = 4;
                        break;
                      }

                      return _context2.abrupt("return", []);

                    case 4:
                      p = textMorph.pluginFind(function (p) {
                        return p.isJSEditorPlugin;
                      });
                      endpoint = p && p.systemInterface();

                      if (endpoint) {
                        _context2.next = 8;
                        break;
                      }

                      return _context2.abrupt("return", []);

                    case 8:
                      opts = __varRecorder__$X.buildEvalOpts(textMorph);
                      _context2.next = 11;
                      return endpoint.dynamicCompletionsForPrefix(opts.targetModule, roughPrefix, opts);

                    case 11:
                      _yield$endpoint$dynam = _context2.sent;
                      isError = _yield$endpoint$dynam.isError;
                      err = _yield$endpoint$dynam.value;
                      completions = _yield$endpoint$dynam.completions;
                      prefix = _yield$endpoint$dynam.prefix;

                      if (!isError) {
                        _context2.next = 19;
                        break;
                      }

                      console.warn("javascript completer encountered error: ".concat(err.stack || err));
                      return _context2.abrupt("return", []);

                    case 19:
                      completions.reduce(function (sum, _ref) {
                        var _ref2 = _slicedToArray(_ref, 2);
                            _ref2[0];
                            var completions = _ref2[1];

                        return sum + completions.length;
                      }, 0);
                      priority = 2000;
                      processed = completions.reduce(function (all, _ref3, i) {
                        var _ref4 = _slicedToArray(_ref3, 2),
                            protoName = _ref4[0],
                            completions = _ref4[1];

                        return all.concat(completions.map(function (ea) {
                          var isValidIdentifier = _this.isValidIdentifier(ea);

                          return {
                            info: protoName,
                            completion: ea,
                            prefix: isValidIdentifier ? prefix : "." + prefix,
                            customInsertionFn: isValidIdentifier ? _this.isMethodCallCompletion(ea) ? function (complString, prefix, textMorph, _ref5) {
                              var start = _ref5.start,
                                  end = _ref5.end;
                              var expansion = complString.replace(/\((.*)\)/, function (args) {
                                return "(".concat(args.slice(1, -1).split(", ").map(function (arg, i) {
                                  return "${".concat(i, ":").concat(arg, "}");
                                }).join(", "), ")");
                              });
                              var snippet = new Snippet({
                                expansion: expansion
                              });
                              textMorph.replace({
                                start: start,
                                end: end
                              }, "");
                              snippet.expandAtCursor(textMorph);
                            } : null : function (complString, prefix, textMorph, _ref6) {
                              var start = _ref6.start,
                                  end = _ref6.end;
                              var before = {
                                row: start.row,
                                column: start.column - 1
                              };
                              var range = textMorph.textInRange({
                                start: before,
                                end: start
                              }) === "." ? {
                                start: before,
                                end: end
                              } : {
                                start: start,
                                end: end
                              };
                              textMorph.replace(range, _this.wrapInBrackets(ea));
                            }
                          };
                        }));
                      }, []);
                      processed.forEach(function (ea, i) {
                        return Object.assign(ea, {
                          priority: priority + processed.length - i
                        });
                      });
                      return _context2.abrupt("return", processed);

                    case 24:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function DynamicJavaScriptCompleter_compute_(_x3) {
              return _DynamicJavaScriptCompleter_compute_.apply(this, arguments);
            }

            return DynamicJavaScriptCompleter_compute_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DynamicJavaScriptCompleter";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/completers.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 1709,
          end: 5155
        });
      }(undefined);
      __varRecorder__$X.DynamicJavaScriptCompleter = DynamicJavaScriptCompleter;
      __varRecorder__$X.DynamicJavaScriptCompleter = DynamicJavaScriptCompleter;
      __varRecorder__$X.keywords = ["arguments", "boolean", "break", "case", "catch", "class", "const", "continue", "debugger", "default", "delete", "eval", "export", "import", "extends", "false", "true", "finally", "instanceof", "static", "super", "this", "throw", "typeof", "while", "with", "yield", "await", "Array", "Date", "eval", "function", "hasOwnProperty", "Infinity", "isFinite", "isNaN", "isPrototypeOf", "length", "Math", "NaN", "name", "Number", "Object", "prototype", "String", "toString", "undefined", "valueOf", "alert", "assign", "clearInterval", "clearTimeout", "decodeURI", "decodeURIComponent", "document", "encodeURI", "encodeURIComponent", "escape", "navigator", "parseFloat", "parseInt", "setInterval", "setTimeout", "window", "document", "requestAnimationFrame", "cancelAnimationFrame"];
      var JavaScriptKeywordCompleter = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/completers.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("JavaScriptKeywordCompleter") && typeof __lively_classholder__.JavaScriptKeywordCompleter === "function" ? __lively_classholder__.JavaScriptKeywordCompleter : __lively_classholder__.JavaScriptKeywordCompleter = function JavaScriptKeywordCompleter(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "compute",
          value: function JavaScriptKeywordCompleter_compute_(textMorph, prefix) {
            return __varRecorder__$X.keywords.map(function (ea) {
              return {
                completion: ea,
                priority: 0
              };
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "JavaScriptKeywordCompleter";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/completers.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 6157,
          end: 6295
        });
      }(undefined);
      __varRecorder__$X.JavaScriptKeywordCompleter = JavaScriptKeywordCompleter;
      __varRecorder__$X.JavaScriptKeywordCompleter = JavaScriptKeywordCompleter;
      __varRecorder__$X.completers = [new __varRecorder__$X.DynamicJavaScriptCompleter(), new __varRecorder__$X.JavaScriptKeywordCompleter(), new __varRecorder__$X.ModuleTopLevelVarCompleter()];
      var completers = __varRecorder__$X.completers;
      __varRecorder__$X.completers = completers;

      var __varRecorder__$W = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/snippets.js", __contextModule__);
      __varRecorder__$W.snippets = [["typef", "typeof ${0:object} === \"function\"$1"], ["types", "typeof ${0:object} === \"string\"$1"], ["typen", "typeof ${0:object} === \"number\"$1"], ["typeu", "typeof ${0:object} === \"undefined\"$1"], ["typenu", "typeof ${0:object} !== \"undefined\"$1"], ["import", "import { ${0:name} } from \"${1:module}\";"], ["importd", "import ${0:name} from \"${1:module}\";"], ["import*", "import * as ${0:name} from \"${1:module}\";"], ["subclass", "class ${0:name} extends ${1:base} {\n  constructor(${2:args}) {\n    super(${3:args})\n    $4\n  }\n}"], ["class", "class ${0:name} {\n  constructor(${1:args}) {\n    $2\n  }\n}"], ["switch", "switch (${0:expression}) {\n  case '${2:case}':\n    ${3:// code}\n    break;\n    $4\n    default:\n    ${1:// code}\n}"], ["tryf", "try {${0:/* code */}} finally {}"], ["try", "try {${0:/* code */}} catch (err) {}"], ["do", "do {${1:/* code */}} while (${0:/* condition */});"], ["fori", "for (let ${0:prop} in ${1:obj}) {\n  ${2:obj[prop]}\n}"], ["foro", "for (let ${0:value} of ${1:iterable}) {\n  ${2:value}\n}"], ["for-", "for (let ${0:i} = ${1:list}.length; ${2:i}--; ) {\n  $3\n}"], ["for", "for (let ${0:i} = 0; ${1:i} < ${3:list}.length; ${2:i}++) {\n  $4\n}"], ["Prom", "new Promise((resolve, reject) => {$0})"], ["keys", "Object.keys($0)"], ["assign", "Object.assign(${0:dest}, ${1:source})"], ["stringi", "JSON.stringify(${0:object})"], ["forE", "forEach(${0:ea} => $1)"], ["map", "map(${0:ea} => $1)"], ["reduce", "reduce((${1:all}, ${2:ea}) => {$3}, ${0:init})"], ["from", "Array.from(${0:list})"], ["last", "arr.last(${0:list})"], ["pluck", "arr.pluck(${0:list}, \"${1:key}\")"], ["sortBy", "arr.sortBy(${0:list}, ($1) => $2)"], ["join", "join(\"\\n\")"], ["con", "connect(${0:source}, '${1:sourceAttr}', ${2:target}, '${3:targetAttr}');"], ["once", "once(${0:source}, '${1:sourceAttr}', ${2:target}, '${3:targetAttr}');"], ["sig", "signal(${0:source}, '${1:sourceAttr}', ${2:value});"], ["ll", "lively.lang."], ["lls", "lively.lang.string."], ["lla", "lively.lang.arr."], ["llo", "lively.lang.obj."], ["llf", "lively.lang.fun."], ["llp", "lively.lang.promise."], ["withA", "withAllSubmorphsDo(ea => { return ${0:ea}; })"], ["$w", "$world"], ["$m", "$morph('${0:name}')"], ["get", "get(\"${0:name}\")"], ["vm", "viewModel"], ["$", "${$0}"], ["cl", "console.log($0)"], ["cw", "console.warn($0)"], ["ce", "console.error($0)"], ["s", "show(`$0`);"], ["l2lC", "import L2LClient from \"lively.2lively/client.js\";\nlet l2lClient = L2LClient.default();$0"], ["afun", "async function ${0:functionName}($1) {$2}"], ["fun", "function ${0:functionName}($1) {$2}"], ["fn", "function($0) {$1}"], ["f", "($0) => $1"], ["aw", "await $0"], ["docstring", function (followingSourceCode) {
        try {
          var _ret = function () {
            var sourceCodeByLine = followingSourceCode.split("\n");
            var nextSourceLine = sourceCodeByLine[1];
            var brackets = 0;
            var funcString = "";
            var i = 1;

            while (true) {
              var currLine = sourceCodeByLine[i];

              _toConsumableArray$1(currLine).forEach(function (c) {
                if (c === "{") brackets++;
                if (c === "}") brackets--;
              });

              i++;
              funcString = funcString + currLine;
              if (brackets === 0) break;
            }

            var hasReturn = new RegExp("return", "m").test(funcString);
            nextSourceLine = nextSourceLine.replace("get ", "function ");
            nextSourceLine = nextSourceLine.replace("set ", "function ");
            nextSourceLine = nextSourceLine.replace("function ", "");
            nextSourceLine = nextSourceLine.replace("async ", "");
            nextSourceLine = nextSourceLine.replace("export ", "");
            nextSourceLine = nextSourceLine.replace("static ", "");
            var nextFuncDef = nextSourceLine.match(/.* \(.*\).*$/gm)[0];
            var nextFuncSignature = nextFuncDef.substring(0, nextFuncDef.lastIndexOf(" "));
            var nextFunc = eval("(" + "function " + nextFuncSignature + "{}" + ")");
            var argNodes = parseFunction(nextFunc).params;
            var args = argNodes.map(function (argumentNode) {
              if (argumentNode.type === "Identifier") return argumentNode.name;
              if (argumentNode.type === "AssignmentPattern") return argumentNode.left.name;
              if (argumentNode.type === "RestElement") return argumentNode.argument.name;
            });
            var docstring = "\n/**\n * ${0:description}\n";
            var expansionIndex = 1;

            var _iterator = _createForOfIteratorHelper(args),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var arg = _step.value;
                docstring = docstring.concat(" * @param {${" + expansionIndex++ + ":type}} " + arg + " - ${" + expansionIndex++ + ":description}\n");
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            if (hasReturn) docstring = docstring.concat(" * @returns {${" + expansionIndex++ + ":type}} ${" + expansionIndex++ + ":description}\n");
            docstring = docstring.concat(" */");
            return {
              v: docstring
            };
          }();

          if (_typeof$1(_ret) === "object") return _ret.v;
        } catch (error) {
          return "\n/**\n * ${0:description}\n */";
        }
      }], ["fdesl", "/* eslint-disable ${0:rule} */"], ["desl", "// eslint-disable-line ${0:rule}"]];
      var snippets$1 = __varRecorder__$W.snippets;
      __varRecorder__$W.snippets = snippets$1;

      var __varRecorder__$V = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/commands.js", __contextModule__);
      var __moduleMeta__$r = {
        pathInPackage: function pathInPackage() {
          return "./js/commands.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var setEvalEnv = __varRecorder__$V["lively.ide/js/commands.js__define__"]("setEvalEnv", "function", function (morph, newEnv) {
        var plugin = morph.pluginFind(function (p) {
          return p.isJSEditorPlugin;
        });
        if (plugin) Object.assign(plugin.evalEnvironment, newEnv);
        return plugin.evalEnvironment;
      }, __moduleMeta__$r);

      __varRecorder__$V.setEvalEnv = setEvalEnv;

      var iToP$1 = __varRecorder__$V["lively.ide/js/commands.js__define__"]("iToP", "function", function (ed, pos) {
        return ed.indexToPosition(pos);
      }, __moduleMeta__$r);

      __varRecorder__$V.iToP = iToP$1;
      __varRecorder__$V.jsEditorCommands = [{
        name: "undefine variable",
        doc: "Finds the variable at cursor position (or position passed) and undefines it in the module toplevel scope.",
        exec: function () {
          var _exec = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(ed) {
            var env,
                _env,
                varName,
                position,
                nav,
                parsed,
                node,
                source,
                result,
                err,
                _args = arguments;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    env = _args.length > 1 && _args[1] !== undefined ? _args[1] : {
                      varName: null,
                      position: null
                    };
                    _env = env, varName = _env.varName, position = _env.position;

                    if (varName) {
                      _context.next = 11;
                      break;
                    }

                    if (!position) position = ed.cursorPosition;
                    nav = ed.pluginInvokeFirst("getNavigator");
                    parsed = nav.ensureAST(ed);
                    node = nodesAt$1(ed.positionToIndex(position), parsed).reverse().find(function (ea) {
                      return ea.type === "Identifier";
                    });

                    if (node) {
                      _context.next = 10;
                      break;
                    }

                    ed.showError(new Error("no identifier found!"));
                    return _context.abrupt("return", true);

                  case 10:
                    varName = node.name;

                  case 11:
                    env = ed.pluginFind(function (p) {
                      return p.isJSEditorPlugin;
                    }).sanatizedJsEnv();
                    source = "lively.modules.module(\"".concat(env.targetModule, "\").undefine(\"").concat(varName, "\")");
                    _context.prev = 13;
                    _context.next = 16;
                    return ed.doEval(null, env, source);

                  case 16:
                    result = _context.sent;
                    err = result.error ? result.error : result.isError ? result.value : null;
                    _context.next = 23;
                    break;

                  case 20:
                    _context.prev = 20;
                    _context.t0 = _context["catch"](13);
                    err = _context.t0;

                  case 23:
                    err ? ed.showError(err) : ed.setStatusMessage("".concat(varName, " undefined"));
                    return _context.abrupt("return", true);

                  case 25:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[13, 20]]);
          }));

          function exec(_x) {
            return _exec.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "change doitContext",
        exec: function () {
          var _exec2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(text) {
            var _yield$text$world$exe, _yield$text$world$exe2, selected, reset;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return text.world().execCommand("select morph", {
                      prompt: "select morph for doitContext",
                      justReturn: true,
                      prependItems: ["reset"],
                      filterFn: function filterFn(m) {
                        return !m.isUsedAsEpiMorph();
                      }
                    });

                  case 2:
                    _yield$text$world$exe = _context2.sent;
                    _yield$text$world$exe2 = _slicedToArray(_yield$text$world$exe, 1);
                    selected = _yield$text$world$exe2[0];

                    if (selected) {
                      reset = selected === "reset";
                      text.doitContext = reset ? null : selected;
                      text.setStatusMessage(reset ? "doitContext is now\n" + selected : "doitContext reset");
                    }

                    return _context2.abrupt("return", true);

                  case 7:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function exec(_x2) {
            return _exec2.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "change eval backend",
        exec: function () {
          var _exec3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(text) {
            var opts,
                backend,
                _args3 = arguments;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    opts = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {
                      backend: undefined
                    };
                    backend = opts.backend;

                    if (!(backend === undefined)) {
                      _context3.next = 9;
                      break;
                    }

                    _context3.next = 5;
                    return text.world().prompt("choose eval backend", {
                      historyId: "js-eval-backend-history"
                    });

                  case 5:
                    backend = _context3.sent;

                    if (backend) {
                      _context3.next = 9;
                      break;
                    }

                    text.setStatusMessage("Canceled");
                    return _context3.abrupt("return", true);

                  case 9:
                    if (backend === "local") backend = null;
                    text.setStatusMessage("Eval backend is now ".concat(backend || "local"));
                    return _context3.abrupt("return", __varRecorder__$V.setEvalEnv(text, {
                      remote: backend
                    }));

                  case 12:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));

          function exec(_x3) {
            return _exec3.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "copy current module name to clipboard",
        exec: function exec(text) {
          var modName = text.evalEnvironment.targetModule;
          text.setStatusMessage(modName || "Cannot find module name");
          text.env.eventDispatcher.killRing.add(text);
          text.env.eventDispatcher.doCopy(modName);
          return true;
        }
      }];
      var jsEditorCommands = __varRecorder__$V.jsEditorCommands;
      __varRecorder__$V.jsEditorCommands = jsEditorCommands;
      __varRecorder__$V.jsIdeCommands = [{
        name: "[javascript] list errors and warnings",
        exec: function () {
          var _exec4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(text) {
            var markers, items, _yield$text$world$fil, _yield$text$world$fil2, sel;

            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    markers = (text.markers || []).filter(function (_ref) {
                      var type = _ref.type;
                      return type === "js-undeclared-var" || type === "js-syntax-error";
                    });

                    if (markers.length) {
                      _context4.next = 4;
                      break;
                    }

                    show("no warnings or errors");
                    return _context4.abrupt("return", true);

                  case 4:
                    items = markers.map(function (_ref2) {
                      var range = _ref2.range,
                          type = _ref2.type;
                      var string = "[".concat(type.split("-").slice(1).join(" "), "] ").concat(text.textInRange(range));
                      return {
                        isListItem: true,
                        string: string,
                        value: range
                      };
                    });
                    _context4.next = 7;
                    return text.world().filterableListPrompt("jump to warning or error", items);

                  case 7:
                    _yield$text$world$fil = _context4.sent;
                    _yield$text$world$fil2 = _slicedToArray(_yield$text$world$fil.selected, 1);
                    sel = _yield$text$world$fil2[0];

                    if (sel) {
                      text.saveMark();
                      text.selection = sel;
                      text.centerRow(sel.start.row);
                    }

                    return _context4.abrupt("return", true);

                  case 12:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));

          function exec(_x4) {
            return _exec4.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "[javascript] inject import",
        exec: function () {
          var _exec5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(text) {
            var opts,
                _yield$import,
                interactivelyInjectImportIntoText,
                result,
                _args5 = arguments;

            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    opts = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {
                      gotoImport: false,
                      insertImportAtCursor: true
                    };
                    _context5.next = 3;
                    return delay(0);

                  case 3:
                    _context5.next = 5;
                    return Promise.resolve().then(function () { return importHelper; });

                  case 5:
                    _yield$import = _context5.sent;
                    interactivelyInjectImportIntoText = _yield$import.interactivelyInjectImportIntoText;
                    _context5.next = 9;
                    return interactivelyInjectImportIntoText(text, opts);

                  case 9:
                    result = _context5.sent;
                    if (!result) text.setStatusMessage("canceled");
                    return _context5.abrupt("return", result);

                  case 12:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5);
          }));

          function exec(_x5) {
            return _exec5.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "[javascript] fix undeclared variables",
        exec: function () {
          var _exec6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(text) {
            var opts,
                _yield$import2,
                interactivlyFixUndeclaredVariables,
                result,
                _args6 = arguments;

            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {
                      ignore: [],
                      autoApplyIfSingleChoice: false,
                      requester: text
                    };
                    _context6.next = 3;
                    return Promise.resolve().then(function () { return importHelper; });

                  case 3:
                    _yield$import2 = _context6.sent;
                    interactivlyFixUndeclaredVariables = _yield$import2.interactivlyFixUndeclaredVariables;
                    _context6.next = 7;
                    return interactivlyFixUndeclaredVariables(text, opts);

                  case 7:
                    result = _context6.sent;
                    text.focus();
                    return _context6.abrupt("return", result);

                  case 10:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6);
          }));

          function exec(_x6) {
            return _exec6.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "[javascript] remove unused imports",
        exec: function () {
          var _exec7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(text) {
            var opts,
                _yield$import3,
                cleanupUnusedImports,
                status,
                _args7 = arguments;

            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    opts = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {
                      query: true
                    };
                    _context7.next = 3;
                    return Promise.resolve().then(function () { return importHelper; });

                  case 3:
                    _yield$import3 = _context7.sent;
                    cleanupUnusedImports = _yield$import3.cleanupUnusedImports;
                    _context7.next = 7;
                    return cleanupUnusedImports(text, opts);

                  case 7:
                    status = _context7.sent;
                    text.setStatusMessage(status);
                    return _context7.abrupt("return", true);

                  case 10:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7);
          }));

          function exec(_x7) {
            return _exec7.apply(this, arguments);
          }

          return exec;
        }()
      }];
      var jsIdeCommands = __varRecorder__$V.jsIdeCommands;
      __varRecorder__$V.jsIdeCommands = jsIdeCommands;
      __varRecorder__$V.astEditorCommands = [{
        name: "selectDefinition",
        readOnly: true,
        bindKey: "Alt-.",
        exec: function exec(ed, args) {
          var nav = ed.pluginInvokeFirst("getNavigator");
          if (!nav) return true;
          var found = nav.resolveIdentifierAt(ed, ed.cursorPosition);

          if (!found || !found.id) {
            show("No symbol identifier selected");
            return true;
          }

          if (!found.decl) {
            show("Cannot find declaration of " + found.name);
            return true;
          }

          ed.saveMark();
          ed.selection = {
            start: ed.indexToPosition(found.decl.start),
            end: ed.indexToPosition(found.decl.end)
          };
          ed.scrollCursorIntoView();
          return true;
        }
      }, {
        name: "selectSymbolReferenceOrDeclarationNext",
        readOnly: true,
        multiSelectAction: "single",
        exec: function exec(ed) {
          ed.execCommand("selectSymbolReferenceOrDeclaration", {
            direction: "next"
          });
        }
      }, {
        name: "selectSymbolReferenceOrDeclarationPrev",
        readOnly: true,
        multiSelectAction: "single",
        exec: function exec(ed) {
          ed.execCommand("selectSymbolReferenceOrDeclaration", {
            direction: "prev"
          });
        }
      }, {
        name: "selectSymbolReferenceOrDeclaration",
        doc: "Finds the name of the currently selected symbol and will use the JS ast to select references and declarations whose name matches the symbol in the current scope.",
        readOnly: true,
        multiSelectAction: "single",
        exec: function exec(ed) {
          var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            direction: null
          };
          var nav = ed.pluginInvokeFirst("getNavigator");
          if (!nav) return true;
          var found = nav.resolveIdentifierAt(ed, ed.cursorPosition);

          if (!found || !found.refs) {
            show("No symbol identifier selected");
            return true;
          }

          var sel = ed.selection;
          var ranges = found.refs.map(function (_ref3) {
            var start = _ref3.start,
                end = _ref3.end;
            return Range.fromPositions(__varRecorder__$V.iToP(ed, start), __varRecorder__$V.iToP(ed, end));
          }).concat(found.decl ? Range.fromPositions(__varRecorder__$V.iToP(ed, found.decl.start), __varRecorder__$V.iToP(ed, found.decl.end)) : []).sort(Range.compare);
          if (!ranges.length) return true;
          var currentRangeIdx = ranges.map(String).indexOf(String(sel.range));

          if (args.direction === "next" || args.direction === "prev") {
            if (currentRangeIdx === -1 && ranges.length) ranges = [ranges[0]];else {
              var nextIdx = currentRangeIdx + (args.direction === "next" ? 1 : -1);
              if (nextIdx < 0) nextIdx = ranges.length - 1;else if (nextIdx >= ranges.length) nextIdx = 0;
              ranges = [ranges[nextIdx]];
            }
          }

          ranges.forEach(function (range) {
            var existing = sel.selections.findIndex(function (ea) {
              return ea.range.equals(range);
            });
            var idx = sel.selections.length - 1;
            existing > -1 ? swap$1(sel.selections, existing, idx) : sel.addRange(range, false);
          });
          sel.mergeSelections();
          return true;
        }
      }];
      var astEditorCommands = __varRecorder__$V.astEditorCommands;
      __varRecorder__$V.astEditorCommands = astEditorCommands;

      if (lively.modules && !lively.FreezerRuntime) {
        var mod = lively.modules.module("lively.ide/js/editor-plugin.js");
        if (!mod._frozenModule) mod.reload({
          reloadDeps: false,
          resetEnv: false
        });
      }

      var __varRecorder__$U = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/completion.cp.js", __contextModule__);
      __varRecorder__$U.AutocompleteList = component["for"](function () {
        return component({
          type: FilterableList,
          borderWidth: 0,
          name: "autocomplete list",
          extent: pt(400, 360),
          renderOnGPU: true,
          selectedAction: "default",
          submorphs: [{
            type: InputLine,
            name: "input",
            extent: pt(22, 22),
            fill: Color.rgba(255, 255, 255, 0),
            fixedHeight: false,
            fixedWidth: true,
            fontFamily: "\"IBM Plex Mono\"",
            padding: rect(0, 3, 0, -1),
            placeholder: null
          }, {
            name: "padding",
            extent: pt(10, 0),
            fill: Color.rgba(0, 0, 0, 0),
            position: pt(0, 21)
          }, {
            type: List,
            name: "list",
            borderColor: Color.rgb(149, 165, 166),
            borderRadius: 3,
            clipMode: "auto",
            dropShadow: new ShadowObject({
              distance: 15,
              color: Color.rgba(0, 0, 0, 0.35),
              blur: 52
            }),
            extent: pt(400, 339),
            fill: Color.rgba(255, 255, 255, 0.9),
            fontFamily: "IBM Plex Mono",
            itemHeight: 18,
            itemPadding: rect(3, 2, 7, -1),
            manualItemHeight: true,
            padding: rect(0, 0, 0, 0),
            position: pt(0, 21)
          }]
        });
      }, {
        module: "lively.ide/text/completion.cp.js",
        "export": "AutocompleteList",
        range: {
          start: 231,
          end: 1241
        }
      }, System, __varRecorder__$U, "AutocompleteList");
      var AutocompleteList = __varRecorder__$U.AutocompleteList;
      __varRecorder__$U.AutocompleteList = AutocompleteList;

      var __varRecorder__$T = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/completion.js", __contextModule__);
      var Completer = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/completion.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("Completer") && typeof __lively_classholder__.Completer === "function" ? __lively_classholder__.Completer : __lively_classholder__.Completer = function Completer(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "compute",
          value: function Completer_compute_() {
            return [];
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "Completer";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./text/completion.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 375,
          end: 422
        });
      }(undefined);
      __varRecorder__$T.Completer = Completer;
      __varRecorder__$T.Completer = Completer;
      var WordCompleter = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/completion.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("WordCompleter") && typeof __lively_classholder__.WordCompleter === "function" ? __lively_classholder__.WordCompleter : __lively_classholder__.WordCompleter = function WordCompleter(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "compute",
          value: function WordCompleter_compute_(textMorph, prefix) {
            var words = [];
            var completions = [];
            var lines = textMorph.document.lineStrings;
            var row = textMorph.cursorPosition.row;
            var basePriority = 1000;

            for (var i = row - 1; i >= 0; i--) {
              var _iterator = _createForOfIteratorHelper(lines[i].split(/[^0-9a-z@_]+/i)),
                  _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var word = _step.value;
                  if (!word || words.includes(word) || word === prefix) continue;
                  words.push(word);
                  completions.push({
                    priority: basePriority - (row - i),
                    completion: word
                  });
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }

            for (var _i = row + 1; _i < lines.length; _i++) {
              var _iterator2 = _createForOfIteratorHelper(lines[_i].split(/[^0-9a-z_@]+/i)),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var _word = _step2.value;
                  if (!_word || words.includes(_word) || _word === prefix) continue;
                  words.push(_word);
                  completions.push({
                    priority: basePriority - (_i - row),
                    completion: _word
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }

            return completions;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "WordCompleter";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./text/completion.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 431,
          end: 1294
        });
      }(undefined);
      __varRecorder__$T.WordCompleter = WordCompleter;
      __varRecorder__$T.WordCompleter = WordCompleter;
      __varRecorder__$T.defaultCompleters = [new __varRecorder__$T.WordCompleter()];
      var defaultCompleters = __varRecorder__$T.defaultCompleters;
      __varRecorder__$T.defaultCompleters = defaultCompleters;
      var CompletionController = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/completion.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("CompletionController") && typeof __lively_classholder__.CompletionController === "function" ? __lively_classholder__.CompletionController : __lively_classholder__.CompletionController = function CompletionController(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function CompletionController_initialize_(textMorph) {
            var completers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            this.textMorph = textMorph;
            completers = textMorph.pluginCollect("getCompleters", completers);
            this.completers = completers;
          }
        }, {
          key: "computeCompletions",
          value: function () {
            var _CompletionController_computeCompletions_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(prefix) {
              var completions, _iterator3, _step3, c, groups, withHighestPriority, _iterator4, _step4, val, maxCol, sorted, highestPriority, items;

              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      completions = [];
                      _iterator3 = _createForOfIteratorHelper(this.completers);
                      _context.prev = 2;

                      _iterator3.s();

                    case 4:
                      if ((_step3 = _iterator3.n()).done) {
                        _context.next = 19;
                        break;
                      }

                      c = _step3.value;
                      _context.prev = 6;
                      _context.t0 = completions;
                      _context.next = 10;
                      return c.compute(this.textMorph, prefix);

                    case 10:
                      _context.t1 = _context.sent;
                      completions = _context.t0.concat.call(_context.t0, _context.t1);
                      _context.next = 17;
                      break;

                    case 14:
                      _context.prev = 14;
                      _context.t2 = _context["catch"](6);
                      console.warn("Error in completer ".concat(c, ": ").concat(_context.t2.stack || _context.t2));

                    case 17:
                      _context.next = 4;
                      break;

                    case 19:
                      _context.next = 24;
                      break;

                    case 21:
                      _context.prev = 21;
                      _context.t3 = _context["catch"](2);

                      _iterator3.e(_context.t3);

                    case 24:
                      _context.prev = 24;

                      _iterator3.f();

                      return _context.finish(24);

                    case 27:
                      groups = new Map();
                      completions.forEach(function (ea) {
                        var group = groups.get(ea.completion);

                        if (!group) {
                          group = [];
                          groups.set(ea.completion, group);
                        }

                        group.push(ea);
                      });
                      withHighestPriority = [];
                      _iterator4 = _createForOfIteratorHelper(groups.values());

                      try {
                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                          val = _step4.value;
                          withHighestPriority.push(last$2(sortByKey(val, "priority")));
                        }
                      } catch (err) {
                        _iterator4.e(err);
                      } finally {
                        _iterator4.f();
                      }

                      maxCol = 0;
                      sorted = sortByKey(withHighestPriority, "priority").reverse();
                      highestPriority = sorted.length && sorted[0].priority || 0;
                      items = sorted.map(function (ea) {
                        ea.highestPriority = highestPriority;
                        var string = ea.completion.replace(/\n/g, "");
                        var annotation = String((ea.info || "").replace(/\n/g, ""));
                        maxCol = Math.max(maxCol, string.length + annotation.length);
                        return {
                          isListItem: true,
                          string: string,
                          annotation: annotation,
                          value: ea
                        };
                      });
                      return _context.abrupt("return", {
                        items: items,
                        maxCol: maxCol
                      });

                    case 37:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this, [[2, 21, 24, 27], [6, 14]]);
            }));

            function CompletionController_computeCompletions_(_x) {
              return _CompletionController_computeCompletions_.apply(this, arguments);
            }

            return CompletionController_computeCompletions_;
          }()
        }, {
          key: "computeSortedCompletions",
          value: function () {
            var _CompletionController_computeSortedCompletions_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(prefix) {
              var _this = this;

              var mustStartWithPrefix,
                  parsedInput,
                  completions,
                  completionsFiltered,
                  _args2 = arguments;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      mustStartWithPrefix = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : false;
                      parsedInput = {
                        tokens: [prefix],
                        lowercasedTokens: [prefix],
                        input: prefix
                      };
                      _context2.next = 4;
                      return this.computeCompletions(prefix);

                    case 4:
                      completions = _context2.sent;
                      completionsFiltered = sortBy(completions.items.filter(function (item) {
                        return _this.filterFunction(parsedInput, item, mustStartWithPrefix);
                      }), function (item) {
                        return _this.sortFunction(parsedInput, item);
                      });
                      return _context2.abrupt("return", completionsFiltered);

                    case 7:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function CompletionController_computeSortedCompletions_(_x2) {
              return _CompletionController_computeSortedCompletions_.apply(this, arguments);
            }

            return CompletionController_computeSortedCompletions_;
          }()
        }, {
          key: "_printCompletions",
          value: function () {
            var _CompletionController__printCompletions_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(prefix) {
              var table;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return this.computeSortedCompletions(prefix);

                    case 2:
                      _context3.t0 = function (ea) {
                        return {
                          completion: ea.value.completion,
                          priority: ea.value.priority,
                          maxP: ea.value.highestPriority,
                          sortVal: ea._cache[prefix].sortVal,
                          lev: JSON.stringify(ea._cache[prefix].levenshtein)
                        };
                      };

                      table = _context3.sent.map(_context3.t0);
                      return _context3.abrupt("return", printTable(lively.lang.grid.tableFromObjects(table)));

                    case 5:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function CompletionController__printCompletions_(_x3) {
              return _CompletionController__printCompletions_.apply(this, arguments);
            }

            return CompletionController__printCompletions_;
          }()
        }, {
          key: "prefix",
          value: function CompletionController_prefix_() {
            var m = this.textMorph;
            var sel = m.selection;
            var roughPrefix = sel.isEmpty() ? m.getLine(sel.lead.row).slice(0, sel.lead.column) : sel.text;
            return roughPrefix.match(/[a-z0-9@_]*$/i)[0];
          }
        }, {
          key: "filterFunction",
          value: function CompletionController_filterFunction_(parsedInput, item) {
            var mustStartWithPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            if (!item._cache) item._cache = {};
            var tokens = parsedInput.tokens,
                lTokens = parsedInput.lowercasedTokens,
                input = parsedInput.input;
            var cache = item._cache[input] || (item._cache[input] = {});
            if (cache.hasOwnProperty("filtered")) return cache.filtered;
            var compl = item.value.completion.replace(/\([^\)]*\)$/, "");
            var lCompl = compl.toLowerCase();

            if (mustStartWithPrefix && tokens[0] && !compl.startsWith(tokens[0])) {
              return cache.filtered = false;
            }

            if (lTokens.every(function (token) {
              return lCompl.includes(token);
            })) return true;
            var levCache = cache.levenshtein || (cache.levenshtein = {});
            var filtered = mustStartWithPrefix || sum(parsedInput.lowercasedTokens.map(function (token) {
              return levCache[token] || (levCache[token] = levenshtein(lCompl, token));
            })) <= 3;
            return cache.filtered = filtered;
          }
        }, {
          key: "sortFunction",
          value: function CompletionController_sortFunction_(parsedInput, item) {
            if (!item._cache) item._cache = {};
            var cache = item._cache[parsedInput.input] || (item._cache[parsedInput.input] = {});
            if (cache.hasOwnProperty("sortVal")) return cache.sortVal;
            cache = item._cache[parsedInput.input] = {};
            var _item$value = item.value,
                highestPriority = _item$value.highestPriority,
                completion = _item$value.completion,
                priority = _item$value.priority;
            completion = completion.replace(/\([^\)]*\)$/, "").toLowerCase();
            var boosted = 0;
            parsedInput.lowercasedTokens.forEach(function (t) {
              if (completion.startsWith(t)) boosted += 12;else if (t.length >= 3 && completion.includes(t)) boosted += 5;
            });
            var n = String(highestPriority).length - 2;
            var adjustedPriority = (priority || (boosted ? highestPriority : 0)) / Math.pow(10, n);
            var base = -adjustedPriority - boosted;
            var levCache = cache.levenshtein || (cache.levenshtein = {});
            var lev = sum(parsedInput.lowercasedTokens.map(function (token) {
              return levCache[token] || (levCache[token] = levenshtein(completion, token));
            }));
            if (boosted) lev /= 2;
            return cache.sortVal = lev + base;
          }
        }, {
          key: "positionForMenu",
          value: function CompletionController_positionForMenu_() {
            var m = this.textMorph;
            var cursorBounds = m.charBoundsFromTextPosition(m.cursorPosition);
            var globalCursorBounds = m.getGlobalTransform().transformRectToRect(cursorBounds);
            return globalCursorBounds.topLeft().addXY(-m.scroll.x, -m.scroll.y).addPt(pt(m.borderWidth + 4, m.borderWidth + 4));
          }
        }, {
          key: "completionListSpec",
          value: function () {
            var _CompletionController_completionListSpec_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
              var m, fontSize, fontFamily, position, prefix, _yield$this$computeCo, items, maxCol, charBounds, minWidth, textWidth, lineHeight, width, minHeight, maxHeight, fullHeight, height, bounds, world, visibleBounds, delta, _delta;

              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      m = this.textMorph;
                      fontSize = m.fontSize, fontFamily = m.fontFamily;
                      position = this.positionForMenu();
                      prefix = this.prefix();
                      _context4.next = 6;
                      return this.computeCompletions(prefix);

                    case 6:
                      _yield$this$computeCo = _context4.sent;
                      items = _yield$this$computeCo.items;
                      maxCol = _yield$this$computeCo.maxCol;
                      charBounds = m.env.fontMetric.sizeFor(fontFamily, fontSize, "M");
                      minWidth = 120;
                      textWidth = charBounds.width * maxCol;
                      lineHeight = m.document.getLine(0).height;
                      width = Math.max(minWidth, textWidth < m.width ? textWidth : m.width);
                      minHeight = 70;
                      maxHeight = 700;
                      fullHeight = lineHeight * items.length + lineHeight + 10;
                      height = Math.max(minHeight, Math.min(maxHeight, fullHeight));
                      bounds = position.extent(pt(width, height));
                      world = m.world();

                      if (world) {
                        visibleBounds = world.visibleBounds().insetBy(5);

                        if (bounds.bottom() > visibleBounds.bottom()) {
                          delta = bounds.bottom() - visibleBounds.bottom();
                          if (delta > bounds.height - 50) delta = bounds.height - 50;
                          bounds.height -= delta;
                        }

                        if (bounds.right() > visibleBounds.right()) {
                          _delta = bounds.right() - visibleBounds.right();
                          if (bounds.width - _delta < minWidth) bounds.width = minWidth;else bounds.width -= _delta;
                        }

                        if (!visibleBounds.containsRect(bounds)) {
                          bounds = bounds.withTopLeft(visibleBounds.translateForInclusion(bounds).topLeft());
                        }

                        bounds = bounds.translatedBy(visibleBounds.insetBy(-1).topLeft().negated());
                      }

                      return _context4.abrupt("return", {
                        type: FilterableList,
                        hasFixedPosition: true,
                        epiMorph: true,
                        fontSize: fontSize,
                        position: bounds.topLeft(),
                        extent: bounds.extent(),
                        items: items,
                        input: prefix,
                        name: "text completion menu",
                        historyId: "lively.morphic-text completion",
                        filterFunction: this.filterFunction,
                        sortFunction: this.sortFunction,
                        renderOnGPU: true,
                        selectedIndex: 0,
                        submorphs: [{
                          name: "input",
                          fontColor: m.fontColor,
                          clipMode: "visible",
                          fill: Color.transparent,
                          fixedHeight: true,
                          fixedWidth: true,
                          padding: Rectangle.inset(0, 0, 0, 0)
                        }, {
                          name: "padding",
                          height: 2
                        }]
                      });

                    case 22:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function CompletionController_completionListSpec_() {
              return _CompletionController_completionListSpec_.apply(this, arguments);
            }

            return CompletionController_completionListSpec_;
          }()
        }, {
          key: "removeMenuOnBlur",
          value: function CompletionController_removeMenuOnBlur_(_ref) {
            _ref.evt;
                var menu = _ref.menu;
            setTimeout(function () {
              if (!menu.withAllSubmorphsDetect(function (m) {
                return m.isFocused();
              })) {
                menu.remove();
                return;
              }

              menu.inputMorph.focus();
            });
          }
        }, {
          key: "openCompletionList",
          value: function () {
            var _CompletionController_openCompletionList_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
              var currentCursorPos, spec, menu, intermittendTextRange, intermittendInput, input, list, prefix, mask, world, bg, textSize;
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      currentCursorPos = this.textMorph.selection.start;
                      _context5.next = 3;
                      return this.completionListSpec();

                    case 3:
                      spec = _context5.sent;
                      menu = part(AutocompleteList, spec);
                      intermittendTextRange = new Range({
                        start: currentCursorPos,
                        end: this.textMorph.selection.start
                      });
                      intermittendInput = this.textMorph.textInRange(intermittendTextRange);
                      input = menu.inputMorph;
                      list = menu.listMorph;
                      prefix = spec.input;
                      mask = menu.addMorph({
                        name: "prefix mask",
                        fill: Color.transparent,
                        bounds: input.textBounds()
                      }, input);

                      if (!intermittendTextRange.isEmpty()) {
                        this.textMorph.deleteText(intermittendTextRange);
                        input.input = intermittendInput;
                        input.gotoDocumentEnd();
                      }

                      connect(input, "textString", mask, "setBounds", {
                        converter: "() => input.textBounds()",
                        varMapping: {
                          input: input
                        }
                      });
                      connect(menu, "accepted", this, "insertCompletion", {
                        updater: "function($upd) {\n        let textToInsert, customInsertionFn = null, completion = this.sourceObj.selection;\n        if (completion) {\n          if (completion.prefix) prefix = completion.prefix;\n          textToInsert = completion.completion;\n          customInsertionFn = completion.customInsertionFn;\n        } else {\n          textToInsert = this.sourceObj.inputMorph.textString;\n        }\n        $upd(textToInsert, prefix, customInsertionFn);\n      }",
                        varMapping: {
                          prefix: prefix
                        }
                      });
                      connect(menu, "accepted", menu, "remove");
                      connect(menu, "canceled", menu, "remove");
                      connect(menu, "remove", this.textMorph, "focus");
                      connect(menu.inputMorph, "onBlur", this, "removeMenuOnBlur", {
                        converter: "evt => ({menu, evt})",
                        varMapping: {
                          menu: menu
                        }
                      });
                      world = this.textMorph.world();
                      list.addStyleClass("hiddenScrollbar");
                      input.height = list.itemHeight;
                      input.fontSize = list.fontSize;
                      menu.relayout();
                      input.focus();
                      world.addMorph(menu);
                      bg = menu.addMorph({
                        fill: this.textMorph.fill
                      }, input);
                      input.fixedHeight = false;
                      menu.env.forceUpdate();

                      if (prefix.length) {
                        input.gotoDocumentEnd();
                        input.invalidateTextLayout();
                        textSize = input.textBounds().extent().addXY(0, 0);
                        bg.extent = textSize;
                        menu.moveBy(textSize.withY(0).negated());
                      }

                      return _context5.abrupt("return", menu);

                    case 30:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function CompletionController_openCompletionList_() {
              return _CompletionController_openCompletionList_.apply(this, arguments);
            }

            return CompletionController_openCompletionList_;
          }()
        }, {
          key: "autoInsertBestMatchingCompletion",
          value: function () {
            var _CompletionController_autoInsertBestMatchingCompletion_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(prefix) {
              var completionMustStartWithPrefix,
                  customInsertionFn,
                  _yield$this$computeSo,
                  _yield$this$computeSo2,
                  completion,
                  _args6 = arguments;

              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      completionMustStartWithPrefix = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : true;
                      customInsertionFn = _args6.length > 2 ? _args6[2] : undefined;
                      _context6.next = 4;
                      return this.computeSortedCompletions(prefix, completionMustStartWithPrefix);

                    case 4:
                      _yield$this$computeSo = _context6.sent;
                      _yield$this$computeSo2 = _slicedToArray(_yield$this$computeSo, 1);
                      completion = _yield$this$computeSo2[0];

                      if (completion) {
                        this.insertCompletion(completion.value.completion, prefix, customInsertionFn);
                      }

                    case 8:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function CompletionController_autoInsertBestMatchingCompletion_(_x4) {
              return _CompletionController_autoInsertBestMatchingCompletion_.apply(this, arguments);
            }

            return CompletionController_autoInsertBestMatchingCompletion_;
          }()
        }, {
          key: "insertCompletion",
          value: function CompletionController_insertCompletion_(completion, prefix, customInsertionFn) {
            var m = this.textMorph;
            var doc = m.document;
            var selections = m.selection.isMultiSelection ? m.selection.selections : [m.selection];
            m.undoManager.group();
            selections.forEach(function (sel) {
              sel.collapseToEnd();
              var end = sel.lead;
              var start = prefix ? doc.indexToPosition(doc.positionToIndex(end) - prefix.length) : end;
              typeof customInsertionFn === "function" ? customInsertionFn(completion, prefix, m, {
                start: start,
                end: end
              }, sel) : m.replace({
                start: start,
                end: end
              }, completion);
            });
            m.undoManager.group();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "CompletionController";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./text/completion.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 1424,
          end: 13262
        });
      }(undefined);
      __varRecorder__$T.CompletionController = CompletionController;
      __varRecorder__$T.CompletionController = CompletionController;
      __varRecorder__$T.completionCommands = [{
        name: "text completion",
        handlesCount: true,
        multiSelectAction: "single",
        exec: function exec(morph, opts, count) {
          return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
            var completer;
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    completer = new __varRecorder__$T.CompletionController(morph, __varRecorder__$T.defaultCompleters);
                    _context7.next = 3;
                    return completer.openCompletionList();

                  case 3:
                    return _context7.abrupt("return", true);

                  case 4:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7);
          }))();
        }
      }, {
        name: "text completion first match",
        handlesCount: true,
        multiSelectAction: "single",
        exec: function exec(morph, opts, count) {
          return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
            var completer;
            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    completer = new __varRecorder__$T.CompletionController(morph, __varRecorder__$T.defaultCompleters);
                    _context8.next = 3;
                    return completer.autoInsertBestMatchingCompletion(completer.prefix());

                  case 3:
                    return _context8.abrupt("return", true);

                  case 4:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8);
          }))();
        }
      }];
      var completionCommands = __varRecorder__$T.completionCommands;
      __varRecorder__$T.completionCommands = completionCommands;

      var _this = undefined;

      var __varRecorder__$S = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/multi-select-commands.js", __contextModule__);
      __varRecorder__$S.multiSelectCommands = [{
        name: "[multi select] add cursor above",
        multiSelectAction: "single",
        exec: function exec(morph) {
          var start = morph.selection.start;

          if (start.row > 0) {
            var pos = morph.getPositionAboveOrBelow(1, start, false, 0, morph.charBoundsFromTextPosition(start).x);
            morph.selection.addRange({
              start: pos,
              end: pos
            });
          }

          return true;
        }
      }, {
        name: "[multi select] add cursor below",
        multiSelectAction: "single",
        exec: function exec(morph) {
          var start = morph.selection.start;
          var endRow = morph.documentEndPosition.row;

          if (start.row < endRow) {
            var pos = morph.getPositionAboveOrBelow(-1, start, false, 0, morph.charBoundsFromTextPosition(start).x);
            morph.selection.addRange({
              start: pos,
              end: pos
            });
          }

          return true;
        }
      }, {
        name: "[multi select] all like this",
        multiSelectAction: "single",
        exec: function exec(morph) {
          var idx = morph.selection.selections.length - 1;
          var last = morph.selection.selections[idx];
          if (last.isEmpty()) return true;
          var found = new TextSearcher(morph).searchForAll({
            needle: last.text,
            start: {
              column: 0,
              row: 0
            }
          });
          found.forEach(function (_ref) {
            var range = _ref.range;
            return morph.selection.addRange(range, false);
          });
          morph.selection.mergeSelections();
          remove(morph.selection.selections, last);
          morph.selection.selections.push(last);
          return true;
        }
      }, {
        name: "[multi select] more like this forward",
        multiSelectAction: "single",
        exec: function exec(morph) {
          var idx = morph.selection.selections.length - 1;
          var last = morph.selection.selections[idx];
          if (last.isEmpty()) return true;
          var pos = last.end;

          var _TextSearcher$searchF = new TextSearcher(morph).searchForAll({
            needle: last.text,
            start: pos,
            backwards: false
          }),
              _TextSearcher$searchF2 = _slicedToArray(_TextSearcher$searchF, 1),
              found = _TextSearcher$searchF2[0];

          if (found) {
            var existing = morph.selection.selections.findIndex(function (ea) {
              return ea.range.equals(found.range);
            });
            if (existing > -1) swap$1(morph.selection.selections, existing, idx);else morph.selection.addRange(found.range);
          }

          return true;
        }
      }, {
        name: "[multi select] more like this backward",
        multiSelectAction: "single",
        exec: function exec(morph) {
          var idx = morph.selection.selections.length - 1;
          var last = morph.selection.selections[idx];
          if (last.isEmpty()) return true;
          var _last$start = last.start,
              row = _last$start.row,
              column = _last$start.column;
          var found = new TextSearcher(morph).searchForAll({
            needle: last.text,
            start: {
              row: row,
              column: column - (last.text.length - 1)
            },
            backwards: true
          });

          if (found) {
            var existing = morph.selection.selections.findIndex(function (ea) {
              return ea.range.equals(found.range);
            });
            if (existing > -1) swap$1(morph.selection.selections, existing, idx);else morph.selection.addRange(found.range);
          }

          return true;
        }
      }, {
        name: "[multi select] remove focused cursor",
        multiSelectAction: "single",
        exec: function exec(morph) {
          var l = morph.selection.selections.length;

          if (l > 1) {
            morph.selection.removeSelections(l - 1);
          }

          return true;
        }
      }, {
        name: "[multi select] goto previous focused cursor",
        multiSelectAction: "single",
        exec: function exec(morph) {
          morph.selection.selections = lively.lang.arr.rotate(morph.selection.selections, -1);
          return true;
        }
      }, {
        name: "[multi select] goto next focused cursor",
        multiSelectAction: "single",
        exec: function exec(morph) {
          morph.selection.selections = lively.lang.arr.rotate(morph.selection.selections, 1);
          return true;
        }
      }, {
        name: "[multi select] align cursors",
        multiSelectAction: "single",
        exec: function exec(morph) {
          var selections = morph.selection.selections;
          var l = selections.length;
          if (l <= 1) return true;
          var byRow = groupBy(selections, function (sel) {
            return sel.range.start.row;
          });
          var leftOverSels = byRow.keys().map(function (row) {
            var selsOfRow = byRow[row];
            var rightMostSel = max(selsOfRow, function (ea) {
              return ea.range.start.column;
            });
            without$1(selsOfRow, rightMostSel).forEach(function (sel) {
              return sel.range = rightMostSel.range;
            });
            return rightMostSel;
          });
          var maxCol = max(leftOverSels, function (ea) {
            return ea.range.start.column;
          }).range.start.column;
          leftOverSels.forEach(function (sel) {
            var _sel$range$start = sel.range.start,
                row = _sel$range$start.row,
                column = _sel$range$start.column;
            morph.insertText(" ".repeat(maxCol - column), {
              row: row,
              column: column
            });
          });
          return true;
        }
      }, {
        name: "[multi select] create rectangular selection",
        multiSelectAction: "single",
        exec: function exec(morph) {
          morph.selection.disableMultiSelect();

          if (morph.selection.isEmpty()) {
            var from = morph.lastSavedMark && morph.lastSavedMark.position || _this.lineRange().start;

            var to = morph.cursorPosition;
          } else {
            var _morph$selection = morph.selection,
                to = _morph$selection.lead,
                from = _morph$selection.anchor;
          }

          morph.selection.collapse();
          var startCol = from.column;
          var endCol = to.column;
          range(from.row, to.row).forEach(function (row) {
            return morph.getLine(row).length > Math.min(endCol, startCol) && morph.selection.addRange({
              end: {
                row: row,
                column: endCol
              },
              start: {
                row: row,
                column: startCol
              }
            }, false);
          });
          morph.selection.mergeSelections();
          return true;
        }
      }, {
        name: "[multi select] count",
        multiSelectAction: "single",
        handlesCount: true,
        exec: function exec(morph, _) {
          var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
          morph.undoManager.group();
          morph.selection.selections.forEach(function (sel, i) {
            return sel.text = String(i + count);
          });
          morph.undoManager.group();
          return true;
        }
      }];
      var multiSelectCommands = __varRecorder__$S.multiSelectCommands;
      __varRecorder__$S.multiSelectCommands = multiSelectCommands;

      var __varRecorder__$R = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/code-navigation-commands.js", __contextModule__);
      var __moduleMeta__$q = {
        pathInPackage: function pathInPackage() {
          return "./text/code-navigation-commands.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var pToI = __varRecorder__$R["lively.ide/text/code-navigation-commands.js__define__"]("pToI", "function", function (ed, pos) {
        return ed.positionToIndex(pos);
      }, __moduleMeta__$q);

      __varRecorder__$R.pToI = pToI;

      var iToP = __varRecorder__$R["lively.ide/text/code-navigation-commands.js__define__"]("iToP", "function", function (ed, pos) {
        return ed.indexToPosition(pos);
      }, __moduleMeta__$q);

      __varRecorder__$R.iToP = iToP;

      var execCodeNavigator = __varRecorder__$R["lively.ide/text/code-navigation-commands.js__define__"]("execCodeNavigator", "function", function (sel) {
        return function (ed, args, count) {
          var nav = ed.pluginInvokeFirst("getNavigator");
          if (!nav) return true;
          ed.saveMark();
          var count = count || 1;

          for (var i = 0; i < count; i++) {
            nav[sel](ed, args);
          }

          return true;
        };
      }, __moduleMeta__$q);

      __varRecorder__$R.execCodeNavigator = execCodeNavigator;
      __varRecorder__$R.commands = [{
        name: "forwardSexp",
        bindKey: "Ctrl-Alt-f|Ctrl-Alt-Right",
        exec: __varRecorder__$R.execCodeNavigator("forwardSexp"),
        multiSelectAction: "forEach",
        readOnly: true
      }, {
        name: "backwardSexp",
        bindKey: "Ctrl-Alt-b|Ctrl-Alt-Left",
        exec: __varRecorder__$R.execCodeNavigator("backwardSexp"),
        multiSelectAction: "forEach",
        readOnly: true
      }, {
        name: "backwardUpSexp",
        bindKey: "Ctrl-Alt-u|Ctrl-Alt-Up",
        exec: __varRecorder__$R.execCodeNavigator("backwardUpSexp"),
        multiSelectAction: "forEach",
        readOnly: true
      }, {
        name: "forwardDownSexp",
        bindKey: "Ctrl-Alt-d|Ctrl-Alt-Down",
        exec: __varRecorder__$R.execCodeNavigator("forwardDownSexp"),
        multiSelectAction: "forEach",
        readOnly: true
      }, {
        name: "markDefun",
        bindKey: "Ctrl-Alt-h",
        exec: __varRecorder__$R.execCodeNavigator("markDefun"),
        multiSelectAction: "forEach",
        readOnly: true
      }, {
        name: "expandRegion",
        bindKey: {
          win: "Shift-Ctrl-E|Ctrl-Shift-Space",
          mac: "Shift-Command-Space|Ctrl-Shift-Space"
        },
        exec: function exec(ed, args) {
          args = args || {};
          var expander = ed.pluginInvokeFirst("getNavigator");
          if (!expander) return true;
          var newState;
          var start = args.start;
          var end = args.end;

          if (typeof start === "number" && typeof end === "number") {
            ensureExpandState();
            newState = {
              range: [start, end],
              prev: ensureExpandState()
            };
          } else {
            var ast = expander.ensureAST(ed);
            if (!ast) return;
            var newState = expander.expandRegion(ed, ed.textString, ast, ensureExpandState());
          }

          if (newState && newState.range) {
            ed.selection = {
              start: __varRecorder__$R.iToP(ed, newState.range[0]),
              end: __varRecorder__$R.iToP(ed, newState.range[1])
            };
            ed.$expandRegionState = newState;
          }

          once$1(ed, "selectionChange", function () {
            return ed.$expandRegionState = null;
          }, "call");
          return true;

          function ensureExpandState() {
            var state = ed.$expandRegionState;

            var pos = __varRecorder__$R.pToI(ed, ed.cursorPosition);

            if (state && (state.range[0] === pos || state.range[1] === pos)) {
              return state;
            }

            var range = ed.selection.range;
            return ed.$expandRegionState = {
              range: [__varRecorder__$R.pToI(ed, range.start), __varRecorder__$R.pToI(ed, range.end)]
            };
          }
        },
        multiSelectAction: "forEach",
        readOnly: true
      }, {
        name: "contractRegion",
        bindKey: {
          win: "Shift-Ctrl-S|Ctrl-Alt-Space",
          mac: "Ctrl-Command-space|Ctrl-Alt-Space"
        },
        exec: function exec(ed) {
          if (ed.selection.isEmpty()) return true;
          var expander = ed.pluginInvokeFirst("getNavigator");
          if (!expander) return true;
          var ast = expander.ensureAST(ed);
          if (!ast) return true;
          var state = ed.$expandRegionState;
          if (!state) return true;
          var newState = expander.contractRegion(ed, ed.textString, ast, state);

          if (newState && newState.range) {
            ed.selection = {
              start: __varRecorder__$R.iToP(ed, newState.range[0]),
              end: __varRecorder__$R.iToP(ed, newState.range[1])
            };
            ed.$expandRegionState = newState;
          }

          once$1(ed, "selectionChange", function () {
            return ed.$expandRegionState = null;
          }, "call");
          return true;
        },
        multiSelectAction: "forEach",
        readOnly: true
      }];
      var commands$1 = __varRecorder__$R.commands;
      __varRecorder__$R.commands = commands$1;

      var __varRecorder__$Q = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/generic-code-commands.js", __contextModule__);
      __varRecorder__$Q.commands = [{
        name: "toggle comment",
        exec: function exec(morph) {
          var comment = morph.pluginInvokeFirst("getComment");
          if (!comment) return true;

          if (!comment.lineCommentStart) {
            if (comment.blockCommentStart) return morph.execCommand("toggle block comment");
            return true;
          }

          var cstart = comment.lineCommentStart;
          var commentRe = new RegExp("^(\\s*)(".concat(cstart, "\\s?)(.*)"));
          var doc = morph.document;
          var sel = morph.selection;

          if (!sel.isEmpty() && sel.end.column === 0) {
            sel.growRight(-1);
          }

          var startRow = sel.start.row;
          var lines = doc.lineStrings.slice(sel.start.row, sel.end.row + 1);
          var lines = lines.some(function (l) {
            return !!l.trim();
          }) ? dropWhile(lines, function (l) {
            return !l.trim() ? ++startRow && true : false;
          }) : lines;
          var isCommented = lines.every(function (line) {
            return line.trim() && line.match(commentRe);
          });
          morph.undoManager.group();

          if (isCommented) {
            lines.forEach(function (line, i) {
              var match = line.match(commentRe);

              if (match) {
                var _match = _slicedToArray(match, 4);
                    _match[0];
                    var before = _match[1],
                    _comment = _match[2];
                    _match[3];

                var range = {
                  start: {
                    row: startRow + i,
                    column: before.length
                  },
                  end: {
                    row: startRow + i,
                    column: before.length + _comment.length
                  }
                };
                morph.deleteText(range);
              }
            });
          } else {
            var minSpace = lines.reduce(function (minSpace, line, i) {
              return !line.trim() && (!sel.isEmpty() || sel.start.row !== sel.end.row) ? minSpace : Math.min(minSpace, line.match(/^\s*/)[0].length);
            }, Infinity);
            var minSpace = minSpace === Infinity ? 0 : minSpace;
            lines.forEach(function (line, i) {
              var _line$match = line.match(/^(\s*)(.*)/),
                  _line$match2 = _slicedToArray(_line$match, 3);
                  _line$match2[0];
                  _line$match2[1];
                  _line$match2[2];

              morph.insertText("".concat(cstart, " "), {
                row: startRow + i,
                column: minSpace
              });
            });
          }

          morph.undoManager.group();
          return true;
        }
      }, {
        name: "toggle block comment",
        exec: function exec(morph) {
          var comment = morph.pluginInvokeFirst("getComment");
          if (!comment) return true;

          if (!comment.blockCommentStart) {
            if (comment.lineCommentStart) return morph.execCommand("toggle comment");
            return true;
          }

          if (!comment || !comment.blockCommentStart) return true;
          var cstart = comment.blockCommentStart,
              cend = comment.blockCommentEnd;
          var startRe = new RegExp("^" + cstart.replace(/\*/g, "\\*"));
          var endRe = new RegExp(cend.replace(/\*/g, "\\*") + "$");
          var token = morph.tokenAt(morph.cursorPosition);

          if (token && token.token === "comment") {
            var text = morph.textInRange(token);

            if (text.match(startRe) && text.match(endRe)) {
              morph.undoManager.group();
              morph.replace(token, text.slice(cstart.length, -cend.length));
              morph.undoManager.group();
              return true;
            }
          }

          morph.undoManager.group();
          morph.insertText(cstart, morph.selection.start);
          morph.insertText(cend, morph.selection.end);
          morph.undoManager.group();
          var select = !morph.selection.isEmpty();
          morph.selection.growLeft(cend.length);
          if (!select) morph.selection.collapse();
          return true;
        }
      }, {
        name: "comment box",
        exec: function exec(morph, _, count) {
          var undo = morph.undoManager.ensureNewGroup(morph, "comment box");

          if (morph.selection.isEmpty()) {
            morph.insertText("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
            morph.execCommand("toggle comment");
            morph.undoManager.group(undo);
            return true;
          }

          var range = morph.selection.range;
          var lines = morph.withSelectedLinesDo(function (line) {
            return line;
          });
          var indent$1 = min([range.start.column].concat(chain(lines).map(function (line) {
            return line.match(/^\s*/);
          }).flat().compact().pluck("length").value()));
          var length = max(lines.map(function (ea) {
            return ea.length;
          })) - indent$1;
          var fence = Array(Math.ceil(length / 2) + 1).join("-=") + "-";
          morph.execCommand("toggle comment");
          morph.collapseSelection();
          morph.cursorPosition = {
            row: range.start.row,
            column: 0
          };

          if (count) {
            morph.insertText(indent("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-" + "\n", " ", indent$1));
          } else {
            morph.insertText(indent(fence + "\n", " ", indent$1));
          }

          morph.selection.goUp();
          morph.execCommand("toggle comment");
          morph.cursorPosition = {
            row: range.end.row + 2,
            column: 0
          };
          morph.insertText(indent(fence + "\n", " ", indent$1));
          morph.selection.goUp();
          morph.execCommand("toggle comment");
          morph.selection.range = {
            start: {
              row: range.start.row,
              column: 0
            },
            end: morph.cursorPosition
          };
          morph.undoManager.group(undo);
          return true;
        },
        multiSelectAction: "forEach",
        handlesCount: true
      }];
      var commands = __varRecorder__$Q.commands;
      __varRecorder__$Q.commands = commands;

      var __varRecorder__$P = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/defaults.cp.js", __contextModule__);
      __varRecorder__$P.BlackOnWhite = component["for"](function () {
        return component({
          type: Text,
          fixedWidth: true,
          fixedHeight: true,
          extent: pt(415, 300),
          fill: Color.white,
          clipMode: "auto"
        });
      }, {
        module: "lively.ide/text/defaults.cp.js",
        "export": "BlackOnWhite",
        range: {
          start: 109,
          end: 257
        }
      }, System, __varRecorder__$P, "BlackOnWhite");
      var BlackOnWhite = __varRecorder__$P.BlackOnWhite;
      __varRecorder__$P.BlackOnWhite = BlackOnWhite;

      var __varRecorder__$O = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/code-evaluation-commands.js", __contextModule__);
      __varRecorder__$O.codeEvaluationCommands = [{
        name: "doit",
        doc: "Evaluates the selected code or the current line and report the result",
        exec: function () {
          var _exec = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(morph, opts) {
            var count,
                result,
                err,
                _args = arguments;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    count = _args.length > 2 && _args[2] !== undefined ? _args[2] : 1;
                    morph.maybeSelectCommentOrLine();
                    _context.prev = 2;
                    opts = Object.assign({}, opts, {
                      logDoit: true,
                      inspect: true,
                      inspectDepth: count
                    });
                    _context.next = 6;
                    return morph.doEval(undefined, opts);

                  case 6:
                    result = _context.sent;
                    err = result.error ? result.error : result.isError ? result.value : null;
                    _context.next = 13;
                    break;

                  case 10:
                    _context.prev = 10;
                    _context.t0 = _context["catch"](2);
                    err = _context.t0;

                  case 13:
                    err ? morph.showError(err) : morph.setStatusMessage(truncate(result.value, 1000));
                    return _context.abrupt("return", result);

                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[2, 10]]);
          }));

          function exec(_x, _x2) {
            return _exec.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "blame selection",
        doc: "Retrieves complete git blame information for the selected code.",
        exec: function () {
          var _exec2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(morph) {
            var sel, rangeStart, rangeEnd, fileToBlame, baseDir, command, cmd, result;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    sel = morph.selection.selections[0];
                    rangeStart = sel.range.start.row + 1;
                    rangeEnd = sel.range.end.row + 1;

                    if (morph.editorPlugin.evalEnvironment.targetModule) {
                      _context2.next = 6;
                      break;
                    }

                    morph.showError("Error!");
                    return _context2.abrupt("return");

                  case 6:
                    fileToBlame = morph.editorPlugin.evalEnvironment.targetModule;

                    if (!(!fileToBlame.match(/http:/) && !fileToBlame.match(/file:/))) {
                      _context2.next = 10;
                      break;
                    }

                    morph.showError("Only available for files located in the file system.");
                    return _context2.abrupt("return");

                  case 10:
                    _context2.next = 12;
                    return defaultDirectory();

                  case 12:
                    baseDir = _context2.sent;
                    baseDir = baseDir.replace("http://localhost:9011/", "").replace("/lively.server", "");
                    fileToBlame = fileToBlame.replace("http://localhost:9011/", "").replace("file://", "");
                    command = "git blame --date=short -L ".concat(rangeStart, ",").concat(rangeEnd, " ").concat(fileToBlame, " | while read hash others;\n        do\n          echo $(git log -1 --pretty=%s $hash) \" -- \" $others\n        done");
                    cmd = runCommand(command, {
                      cwd: baseDir
                    });
                    _context2.next = 19;
                    return cmd.whenDone();

                  case 19:
                    result = cmd.output;
                    part(BlackOnWhite, {
                      textString: result,
                      name: "Blame Info"
                    }).openInWindow();

                  case 21:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function exec(_x3) {
            return _exec2.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "blame line",
        doc: "Retrieves git commit message and author name from the last time the line at which the cursor is positioned was changed.",
        exec: function () {
          var _exec3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(morph) {
            var lineNumber, fileToBlame, baseDir, command, cmd, result, author, commitMessage, date;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    lineNumber = morph.cursorPosition.row + 1;

                    if (morph.editorPlugin.evalEnvironment.targetModule) {
                      _context3.next = 4;
                      break;
                    }

                    morph.showError("Error!");
                    return _context3.abrupt("return");

                  case 4:
                    fileToBlame = morph.editorPlugin.evalEnvironment.targetModule;

                    if (!(!fileToBlame.match(/http:/) && !fileToBlame.match(/file:/))) {
                      _context3.next = 8;
                      break;
                    }

                    morph.showError("Only available for files located in the file system.");
                    return _context3.abrupt("return");

                  case 8:
                    _context3.next = 10;
                    return defaultDirectory();

                  case 10:
                    baseDir = _context3.sent;
                    baseDir = baseDir.replace("http://localhost:9011/", "").replace("/lively.server", "");
                    fileToBlame = fileToBlame.replace("http://localhost:9011/", "").replace("file://", "");
                    command = "git blame --date=short -L " + lineNumber + "," + lineNumber + " --porcelain " + fileToBlame;
                    cmd = runCommand(command, {
                      cwd: baseDir
                    });
                    _context3.next = 17;
                    return cmd.whenDone();

                  case 17:
                    result = cmd.output;
                    author = result.match(/author (.*)$/m)[1];
                    commitMessage = result.match(/summary (.*)$/m)[1];
                    date = result.match(/author-time (.*)$/m)[1];
                    date = new Date(date * 1000).toDateString();
                    if (author === "Not Committed Yet") morph.setStatusMessage("Line not yet commited.");else morph.setStatusMessage(commitMessage + " - " + author + " on " + date);

                  case 23:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));

          function exec(_x4) {
            return _exec3.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "eval all",
        doc: "Evaluates the entire text contents",
        scrollCursorIntoView: false,
        exec: function () {
          var _exec4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(morph, opts) {
            var result, err;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.prev = 0;
                    _context4.next = 3;
                    return morph.doEval({
                      start: {
                        row: 0,
                        column: 0
                      },
                      end: morph.documentEndPosition
                    }, Object.assign({}, opts, {
                      logDoit: true
                    }));

                  case 3:
                    result = _context4.sent;
                    err = result.error ? result.error : result.isError ? result.value : null;
                    _context4.next = 10;
                    break;

                  case 7:
                    _context4.prev = 7;
                    _context4.t0 = _context4["catch"](0);
                    err = _context4.t0;

                  case 10:
                    err ? morph.showError(err) : morph.setStatusMessage(String(result.value));
                    return _context4.abrupt("return", result);

                  case 12:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, null, [[0, 7]]);
          }));

          function exec(_x5, _x6) {
            return _exec4.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "printit",
        doc: "Evaluates selected code or the current line and inserts the result in a printed representation",
        exec: function () {
          var _exec5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(morph, opts) {
            var result, err, isColor, embeddedMorph, _morph$selection$star, column, row;

            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    morph.maybeSelectCommentOrLine();
                    _context5.prev = 1;
                    opts = Object.assign({}, opts, {
                      asString: false,
                      logDoit: true
                    });
                    _context5.next = 5;
                    return morph.doEval(undefined, opts);

                  case 5:
                    result = _context5.sent;
                    err = result.error ? result.error : result.isError ? result.value : null;
                    _context5.next = 12;
                    break;

                  case 9:
                    _context5.prev = 9;
                    _context5.t0 = _context5["catch"](1);
                    err = _context5.t0;

                  case 12:
                    morph.selection.collapseToEnd();
                    isColor = result.value && result.value.isColor;

                    if (!isColor) {
                      _context5.next = 22;
                      break;
                    }

                    morph.selection.text = String(result.value);
                    embeddedMorph = new Morph({
                      fill: Color.transparent,
                      extent: pt(morph.fontSize + 2, morph.fontSize + 2),
                      submorphs: [{
                        fill: result.value,
                        center: pt(morph.fontSize + 2, morph.fontSize + 2).scaleBy(0.5)
                      }]
                    });
                    _morph$selection$star = morph.selection.start, column = _morph$selection$star.column, row = _morph$selection$star.row;
                    morph.insertText([embeddedMorph, {}], morph.selection.start);
                    morph.selection.start = {
                      column: column,
                      row: row
                    };
                    morph.focus();
                    return _context5.abrupt("return", result);

                  case 22:
                    morph.insertTextAndSelect(err ? String(err) + (err.stack ? "\n" + err.stack : "") : String(result.value));
                    morph.focus();
                    return _context5.abrupt("return", result);

                  case 25:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, null, [[1, 9]]);
          }));

          function exec(_x7, _x8) {
            return _exec5.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "editit",
        doc: "Evaluates the expression and opens an object editor on the resulting object.",
        exec: function () {
          var _exec6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(morph, opts) {
            var result, target, evalEnvironment, jsPlugin;
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    morph.maybeSelectCommentOrLine();
                    target = morph.textInRange(morph.selection);
                    evalEnvironment = morph.evalEnvironment || {};
                    jsPlugin = morph.pluginFind(function (p) {
                      return p.isEditorPlugin && typeof p.runEval === "function";
                    });

                    if (!evalEnvironment.systemInterface) {
                      evalEnvironment.systemInterface = jsPlugin.systemInterface(opts);
                    }

                    if (!(evalEnvironment.systemInterface.name === "local")) {
                      _context6.next = 15;
                      break;
                    }

                    _context6.prev = 6;
                    _context6.next = 9;
                    return morph.doEval(undefined, opts);

                  case 9:
                    result = _context6.sent;
                    target = result.value;
                    _context6.next = 15;
                    break;

                  case 13:
                    _context6.prev = 13;
                    _context6.t0 = _context6["catch"](6);

                  case 15:
                    morph.world().execCommand("open object editor", {
                      target: target,
                      evalEnvironment: evalEnvironment
                    });
                    return _context6.abrupt("return", result);

                  case 17:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, null, [[6, 13]]);
          }));

          function exec(_x9, _x10) {
            return _exec6.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "inspectit",
        doc: "Evaluates the expression and opens an inspector widget on the resulting object.",
        exec: function () {
          var _exec7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(morph, opts) {
            var result, err, target, evalEnvironment, jsPlugin;
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    morph.maybeSelectCommentOrLine();
                    target = morph.textInRange(morph.selection);
                    evalEnvironment = morph.evalEnvironment || {};
                    jsPlugin = morph.pluginFind(function (p) {
                      return p.isEditorPlugin && typeof p.runEval === "function";
                    });
                    if (!evalEnvironment.systemInterface) evalEnvironment.systemInterface = jsPlugin.systemInterface(opts);

                    if (!(evalEnvironment.systemInterface.name === "local")) {
                      _context7.next = 20;
                      break;
                    }

                    _context7.prev = 6;
                    _context7.next = 9;
                    return morph.doEval(undefined, opts);

                  case 9:
                    result = _context7.sent;
                    err = result.error ? result.error : result.isError ? result.value : null;
                    target = result.value;
                    _context7.next = 17;
                    break;

                  case 14:
                    _context7.prev = 14;
                    _context7.t0 = _context7["catch"](6);
                    err = _context7.t0;

                  case 17:
                    openInWindow({
                      targetObject: err || target
                    });
                    _context7.next = 21;
                    break;

                  case 20:
                    openInWindow({
                      remoteTarget: {
                        code: target,
                        evalEnvironment: evalEnvironment
                      }
                    });

                  case 21:
                    return _context7.abrupt("return", result);

                  case 22:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, null, [[6, 14]]);
          }));

          function exec(_x11, _x12) {
            return _exec7.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "log it",
        doc: "Evaluates the expression and `console.log`s the result.",
        exec: function () {
          var _exec8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(morph, opts) {
            var result, evalEnvironment, jsPlugin;
            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    morph.maybeSelectCommentOrLine();
                    evalEnvironment = morph.evalEnvironment || {};
                    jsPlugin = morph.pluginFind(function (p) {
                      return p.isEditorPlugin && typeof p.runEval === "function";
                    });
                    if (!evalEnvironment.systemInterface) evalEnvironment.systemInterface = jsPlugin.systemInterface(opts);

                    if (!(evalEnvironment.systemInterface.name === "local")) {
                      _context8.next = 8;
                      break;
                    }

                    _context8.next = 7;
                    return morph.doEval(undefined, opts);

                  case 7:
                    result = _context8.sent;

                  case 8:
                    console.log(result.value || result.error);
                    return _context8.abrupt("return", result);

                  case 10:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8);
          }));

          function exec(_x13, _x14) {
            return _exec8.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "print inspectit",
        doc: "Prints a representation of the object showing it's properties. The count argument defines how deep (recursively) objects will be printed.",
        handlesCount: true,
        exec: function () {
          var _exec9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(morph, opts) {
            var count,
                result,
                _args9 = arguments;
            return regeneratorRuntime.wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    count = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : 1;
                    morph.maybeSelectCommentOrLine();
                    _context9.prev = 2;
                    opts = Object.assign({}, opts, {
                      inspect: true,
                      inspectDepth: count,
                      logDoit: true
                    });
                    _context9.next = 6;
                    return morph.doEval(undefined, opts);

                  case 6:
                    result = _context9.sent;
                    _context9.next = 11;
                    break;

                  case 9:
                    _context9.prev = 9;
                    _context9.t0 = _context9["catch"](2);

                  case 11:
                    morph.selection.collapseToEnd();
                    morph.insertTextAndSelect(result.value);
                    return _context9.abrupt("return", result);

                  case 14:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, null, [[2, 9]]);
          }));

          function exec(_x15, _x16) {
            return _exec9.apply(this, arguments);
          }

          return exec;
        }()
      }];
      var codeEvaluationCommands = __varRecorder__$O.codeEvaluationCommands;
      __varRecorder__$O.codeEvaluationCommands = codeEvaluationCommands;

      var __varRecorder__$N = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/editor-plugin.js", __contextModule__);
      var __moduleMeta__$p = {
        pathInPackage: function pathInPackage() {
          return "./editor-plugin.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var guessTextModeName = exports('g', __varRecorder__$N["lively.ide/editor-plugin.js__define__"]("guessTextModeName", "function", function (contentOrEditor) {
        var filename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var hint = arguments.length > 2 ? arguments[2] : undefined;
        var fileExt = filename && last$2(filename.split(".")).toLowerCase();
        var peekString = "";
        var size = 0;
        var maxSize = 1000;
        var maxTextSize = Math.pow(2, 19);

        if (typeof contentOrEditor === "string") {
          if (contentOrEditor.length > maxTextSize) return null;
        } else {
          if (contentOrEditor.document.stringSize > maxTextSize) return null;
        }

        if (typeof contentOrEditor === "string") peekString = contentOrEditor.slice(0, 1000);else {
          var _iterator = _createForOfIteratorHelper(contentOrEditor.document.lines),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var line = _step.value;
              var stringSize = line.stringSize,
                  text = line.text;
              var nl = true;

              if (size + stringSize > maxSize) {
                nl = false;
                stringSize = maxSize - size;
              }

              peekString += text.slice(0, stringSize) + (nl ? "\n" : "");
              size += stringSize;
              if (size >= maxSize) break;
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        var _iterator2 = _createForOfIteratorHelper(modeInfo),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var info = _step2.value;
            var contentTest = info.contentTest,
                mode = info.mode,
                ext = info.ext,
                file = info.file;

            if (typeof contentTest === "function") {
              try {
                if (contentTest(peekString)) return mode;
              } catch (err) {}
            }

            if (file && file instanceof RegExp) {
              if (file.test(filename)) return mode;
            }

            if (ext) {
              var _iterator3 = _createForOfIteratorHelper(ext),
                  _step3;

              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var eaExt = _step3.value;

                  if (eaExt === fileExt) {
                    return mode;
                  }
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return hint;
      }, __moduleMeta__$p));

      __varRecorder__$N.guessTextModeName = guessTextModeName;

      var rangedToken = __varRecorder__$N["lively.ide/editor-plugin.js__define__"]("rangedToken", "function", function (row, startColumn, endColumn, token, mode) {
        return {
          start: {
            row: row,
            column: startColumn
          },
          end: {
            row: row,
            column: endColumn
          },
          token: token,
          mode: mode
        };
      }, __moduleMeta__$p);

      __varRecorder__$N.rangedToken = rangedToken;
      __varRecorder__$N.guessTextModeName = guessTextModeName;

      var EditorPlugin = exports('E', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/editor-plugin.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("EditorPlugin") && typeof __lively_classholder__.EditorPlugin === "function" ? __lively_classholder__.EditorPlugin : __lively_classholder__.EditorPlugin = function EditorPlugin(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function EditorPlugin_initialize_() {
            this.theme = DefaultTheme.instance;
            this.checker = null;
            this._ast = null;
            this._tokens = [];
            this._tokenizerValidBefore = null;
            this.__dont_serialize__ = ["mode", "_ast", "_tokens", "_tokenizerValidBefore"];
          }
        }, {
          key: "isEditorPlugin",
          get: function get() {
            return true;
          }
        }, {
          key: "shortName",
          get: function get() {
            return null;
          }
        }, {
          key: "longName",
          get: function get() {
            return this.shortName;
          }
        }, {
          key: "attach",
          value: function EditorPlugin_attach_(editor) {
            this.textMorph = editor;
            connect(editor, "textChange", this, "onTextChange");
            connect(editor, "viewChange", this, "onViewChange");
            this.highlight();
          }
        }, {
          key: "detach",
          value: function EditorPlugin_detach_(editor) {
            disconnect(editor, "textChange", this, "onTextChange");
            disconnect(editor, "viewChange", this, "onViewChange");
            this.textMorph = null;
          }
        }, {
          key: "onViewChange",
          value: function EditorPlugin_onViewChange_() {
            this.requestHighlight();
          }
        }, {
          key: "onTextChange",
          value: function EditorPlugin_onTextChange_(change) {
            this._ast = null;

            if (change) {
              var validMarker = this._tokenizerValidBefore;
              var row;
              var column;
              if (change.selector === "replace") __varRecorder__$N.__inter0__ = change.args[0].start, row = __varRecorder__$N.__inter0__.row, column = __varRecorder__$N.__inter0__.column, __varRecorder__$N.__inter0__;else {
                row = 0;
                column = 0;
              }

              if (!validMarker || row < validMarker.row || row === validMarker.row && column < validMarker.column) {
                row = Math.max(0, row);
                this._tokenizerValidBefore = {
                  row: row,
                  column: column
                };
              }
            }

            this.requestHighlight();
          }
        }, {
          key: "requestHighlight",
          value: function EditorPlugin_requestHighlight_() {
            var _this2 = this;

            var immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            if (immediate) this.highlight();else {
              debounceNamed(this.textMorph.id + "-requestHighlight", 300, function () {
                _this2.highlight();
              })();
            }
          }
        }, {
          key: "highlight",
          value: function EditorPlugin_highlight_() {
            var textMorph = this.textMorph,
                theme = this.theme,
                mode = this.mode,
                _tokenizerValidBefore = this._tokenizerValidBefore;
            if (!theme || !textMorph || !textMorph.document || !mode) return;
            textMorph.fill = theme.background;
            textMorph.cursorColor = theme.cursorColor || textMorph.fontColor;
            var _textMorph$renderingS = textMorph.renderingState,
                firstVisibleRow = _textMorph$renderingS.firstVisibleRow,
                lastVisibleRow = _textMorph$renderingS.lastVisibleRow;
            var morphAttrs = {};

            var _tokenizeDocument = tokenizeDocument(mode, textMorph.document, firstVisibleRow, lastVisibleRow, _tokenizerValidBefore),
                lines = _tokenizeDocument.lines,
                tokens = _tokenizeDocument.tokens;

            if (lines.length) {
              var row = lines[0].row;
              var attributes = [];

              for (var i = 0; i < tokens.length; row++, i++) {
                var lineTokens = tokens[i];

                for (var _i = 0; _i < lineTokens.length; _i = _i + 5) {
                  var startColumn = lineTokens[_i];
                  var endColumn = lineTokens[_i + 1];
                  var token = lineTokens[_i + 2];
                  var style = theme[token] || theme["default"];
                  style && attributes.push({
                    start: {
                      row: row,
                      column: startColumn
                    },
                    end: {
                      row: row,
                      column: endColumn
                    }
                  }, style);
                }
              }

              textMorph.embeddedMorphs.forEach(function (m) {
                var a = textMorph.embeddedMorphMap.get(m).anchor;
                morphAttrs[m.id] = textMorph.textAttributeAt(a.position);
              });
              textMorph.setTextAttributesWithSortedRanges(attributes);
              textMorph.embeddedMorphs.forEach(function (m) {
                var a = textMorph.embeddedMorphMap.get(m).anchor;
                var r = Range.at(a.position);
                r.end.column += 1;
                textMorph.replace(r, [m, morphAttrs[m.id]], false);
              });
              this._tokenizerValidBefore = {
                row: last$2(lines).row + 1,
                column: 0
              };
            }

            if (this.checker) {
              this.checker.onDocumentChange({}, textMorph, this);
            }
          }
        }, {
          key: "visitTokensInRange",
          value: function EditorPlugin_visitTokensInRange_(_ref, visitFn) {
            var start = _ref.start,
                end = _ref.end;
            var mode = this.mode,
                doc = this.textMorph.document;
            var row = start.row - 1;

            var newLineFn = function newLineFn(line) {
              return row++;
            };

            var recordFn = function recordFn(name, state, fromCol, toCol, stream, line, mode) {
              if (row === start.row && start.column > 0) {
                if (start.column >= toCol) return;

                if (fromCol < start.column && start.column < toCol) {
                  fromCol = start.column;
                }
              }

              if (row === end.row) {
                if (end.column <= fromCol) return;

                if (fromCol < end.column && end.column < toCol) {
                  toCol = end.column;
                }
              }

              visitFn(name, state, row, fromCol, toCol, stream, line, mode);
            };

            visitDocumentTokens(mode, doc, start.row, end.row, null, newLineFn, recordFn);
          }
        }, {
          key: "tokensInRange",
          value: function EditorPlugin_tokensInRange_(range) {
            var result = [];
            this.visitTokensInRange(range, function (token, state, row, fromCol, toCol, stream, line, mode) {
              return result.push(__varRecorder__$N.rangedToken(row, fromCol, toCol, token, mode));
            });
            return result;
          }
        }, {
          key: "tokensOfRow",
          value: function EditorPlugin_tokensOfRow_(row) {
            var to = this.textMorph.getLine(row).length;
            return this.tokensInRange({
              start: {
                row: row,
                column: 0
              },
              end: {
                row: row,
                column: to
              }
            });
          }
        }, {
          key: "tokenAt",
          value: function EditorPlugin_tokenAt_(pos) {
            var tokensOfRow = this.tokensOfRow(pos.row);

            for (var i = tokensOfRow.length; i--;) {
              var token = tokensOfRow[i];

              if (token.token && token.start.column <= pos.column && pos.column <= token.end.column) {
                return token;
              }
            }

            return null;
          }
        }, {
          key: "getCommands",
          value: function EditorPlugin_getCommands_(otherCommands) {
            return [].concat(_toConsumableArray$1(otherCommands), _toConsumableArray$1(completionCommands), _toConsumableArray$1(multiSelectCommands), _toConsumableArray$1(commands$1), _toConsumableArray$1(commands), _toConsumableArray$1(codeEvaluationCommands));
          }
        }, {
          key: "getComment",
          value: function EditorPlugin_getComment_() {
            if (!this.mode) return null;
            var _this$mode = this.mode,
                lineComment = _this$mode.lineComment,
                blockCommentStart = _this$mode.blockCommentStart,
                blockCommentEnd = _this$mode.blockCommentEnd;
            var commentSpec = {};
            if (lineComment) commentSpec.lineCommentStart = lineComment;
            if (blockCommentStart) commentSpec.blockCommentStart = blockCommentStart;
            if (blockCommentEnd) commentSpec.blockCommentEnd = blockCommentEnd;
            return commentSpec;
          }
        }, {
          key: "toString",
          value: function EditorPlugin_toString_() {
            return "".concat(this.constructor.name, "(").concat(this.textMorph, ")");
          }
        }, {
          key: "cmd_newline",
          value: function EditorPlugin_cmd_newline_(cursorPos, lineString, indentDepth) {
            var morph = this.textMorph;
            var row = cursorPos.row,
                column = cursorPos.column;
            var before = lineString[column - 1];
            var after = lineString[column];
            morph.selection.text = "\n";
            morph.selection.collapseToEnd();

            if (before === "{" && after === "}") {
              morph.selection.text = "\n" + " ".repeat(indentDepth);
              morph.selection.collapse();
            }

            morph.execCommand("indent according to mode", {
              undo: false,
              ignoreFollowingText: false,
              firstRow: row + 1,
              lastRow: row + 1
            });
            return true;
          }
        }, {
          key: "openPairs",
          get: function get() {
            return {
              "{": "}",
              "[": "]",
              "(": ")",
              "\"": "\"",
              "'": "'",
              "`": "`"
            };
          }
        }, {
          key: "closePairs",
          get: function get() {
            return {
              "}": "{",
              "]": "[",
              ")": "(",
              "\"": "\"",
              "'": "'",
              "`": "`"
            };
          }
        }, {
          key: "cmd_delete_backwards",
          value: function EditorPlugin_cmd_delete_backwards_() {
            var morph = this.textMorph,
                openPairs = this.openPairs;
            var sel = morph.selection;
            var line = morph.getLine(sel.end.row);
            var left = line[sel.end.column - 1];
            var right = line[sel.end.column];

            if (morph.autoInsertPairs && sel.isEmpty() && left in openPairs && right === openPairs[left]) {
              sel.growRight(1);
              sel.growLeft(1);
            }

            return false;
          }
        }, {
          key: "cmd_insertstring",
          value: function EditorPlugin_cmd_insertstring_(string) {
            var openPairs = this.openPairs,
                closePairs = this.closePairs,
                morph = this.textMorph;
            var sel = morph.selection;
            var isOpen = morph.autoInsertPairs && string in openPairs;
            var isClose = morph.autoInsertPairs && string in closePairs;
            if (!isOpen && !isClose) return false;
            var line = morph.getLine(sel.end.row);
            var right = line[sel.end.column];

            if (!sel.isEmpty()) {
              if (!isOpen) return false;

              var _undo = morph.undoManager.ensureNewGroup(morph);

              morph.insertText(openPairs[string], sel.end);
              morph.insertText(string, sel.start);
              morph.undoManager.group(_undo);
              sel.growRight(-1);
              return true;
            }

            if (right in closePairs && string === right) {
              sel.goRight(1);
              return true;
            }

            if (isClose && !isOpen) return false;
            var undo = morph.undoManager.ensureNewGroup(morph);
            morph.withMetaDo({
              reconcileChanges: true
            }, function () {
              morph.insertText(string + openPairs[string]);
            });
            morph.undoManager.group(undo);
            sel.goLeft(1);
            return true;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "EditorPlugin";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./editor-plugin.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 3002,
          end: 11589
        });
      }(undefined));
      var CodeMirrorEnabledEditorPlugin = exports('C', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/editor-plugin.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("CodeMirrorEnabledEditorPlugin") && typeof __lively_classholder__.CodeMirrorEnabledEditorPlugin === "function" ? __lively_classholder__.CodeMirrorEnabledEditorPlugin : __lively_classholder__.CodeMirrorEnabledEditorPlugin = function CodeMirrorEnabledEditorPlugin(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function CodeMirrorEnabledEditorPlugin_initialize_() {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this);
            this.mode = null;
            return _this;
          }
        }, {
          key: "attach",
          value: function CodeMirrorEnabledEditorPlugin_attach_(editor) {
            this.mode = this.codeMirrorMode(editor);
            return initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "attach", this).call(this, editor);
          }
        }, {
          key: "__deserialize__",
          value: function CodeMirrorEnabledEditorPlugin___deserialize___() {
            this.mode = this.textMorph ? this.codeMirrorMode(this.textMorph) : null;
          }
        }, {
          key: "defaultCodeMirrorModeConfig",
          value: function CodeMirrorEnabledEditorPlugin_defaultCodeMirrorModeConfig_(textMorph) {
            return {
              indentWithTabs: !textMorph.useSoftTabs,
              indentUnit: textMorph.tabWidth,
              tabSize: 4
            };
          }
        }, {
          key: "codeMirrorMode",
          value: function CodeMirrorEnabledEditorPlugin_codeMirrorMode_(textMorph) {
            var config = this.defaultCodeMirrorModeConfig(textMorph);
            var name = this.longName;
            return getMode(config, {
              name: name
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "CodeMirrorEnabledEditorPlugin";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./editor-plugin.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 11598,
          end: 12292
        });
      }(__varRecorder__$N.EditorPlugin));
      __varRecorder__$N.CodeMirrorEnabledEditorPlugin = CodeMirrorEnabledEditorPlugin;
      __varRecorder__$N.CodeMirrorEnabledEditorPlugin = CodeMirrorEnabledEditorPlugin;
      __varRecorder__$N["default"] = EditorPlugin;

      var editorPlugin$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        guessTextModeName: guessTextModeName,
        'default': EditorPlugin,
        CodeMirrorEnabledEditorPlugin: CodeMirrorEnabledEditorPlugin
      });
      exports('ab', editorPlugin$1);

      var __varRecorder__$M = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/mode.js", __contextModule__);
      var __moduleMeta__$o = {
        pathInPackage: function pathInPackage() {
          return "./js/mode.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var expressionAllowed = __varRecorder__$M["lively.ide/js/mode.js__define__"]("expressionAllowed", "function", function (stream, state, backUp) {
        return /^(?:operator|sof|keyword c|case|new|export|default|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
      }, __moduleMeta__$o);

      __varRecorder__$M.expressionAllowed = expressionAllowed;
      __varRecorder__$M.defaultConfig = {
        indentUnit: 2
      };
      __varRecorder__$M.defaultParserConfig = {
        name: "javascript",
        statementIndent: 2,
        jsonld: false,
        json: false,
        typescript: false,
        wordCharacters: /[\w$\xa1-\uffff]/,
        globalVars: [],
        localVars: [],
        doubleIndentSwitch: null
      };
      defineMode("javascript", function crea(config, parserConfig) {
        var indentUnit = config.indentUnit;
        var statementIndent = parserConfig.statementIndent;
        var jsonldMode = parserConfig.jsonld;
        var jsonMode = parserConfig.json || jsonldMode;
        var trackScope = parserConfig.trackScope !== false;
        var isTS = parserConfig.typescript;
        var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

        var keywords = function () {
          function kw(type) {
            return {
              type: type,
              style: "keyword"
            };
          }

          var A = kw("keyword a");
          var B = kw("keyword b");
          var C = kw("keyword c");
          var D = kw("keyword d");
          var operator = kw("operator");
          var atom = {
            type: "atom",
            style: "atom"
          };
          return {
            "if": kw("if"),
            "while": A,
            "with": A,
            "else": B,
            "do": B,
            "try": B,
            "finally": B,
            "return": D,
            "break": D,
            "continue": D,
            "new": kw("new"),
            "delete": C,
            "void": C,
            "throw": C,
            "debugger": kw("debugger"),
            "var": kw("var"),
            "const": kw("var"),
            "let": kw("var"),
            "function": kw("function"),
            "catch": kw("catch"),
            "for": kw("for"),
            "switch": kw("switch"),
            "case": kw("case"),
            "default": kw("default"),
            "in": operator,
            "typeof": operator,
            "instanceof": operator,
            "true": atom,
            "false": atom,
            "null": atom,
            undefined: atom,
            NaN: atom,
            Infinity: atom,
            "this": kw("this"),
            "class": kw("class"),
            "super": kw("atom"),
            "yield": C,
            "export": kw("export"),
            "import": kw("import"),
            "extends": C,
            "await": C
          };
        }();

        var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
        var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

        function readRegexp(stream) {
          var escaped = false;
          var next;
          var inSet = false;

          while ((next = stream.next()) != null) {
            if (!escaped) {
              if (next == "/" && !inSet) return;
              if (next == "[") inSet = true;else if (inSet && next == "]") inSet = false;
            }

            escaped = !escaped && next == "\\";
          }
        }

        var type, content;

        function ret(tp, style, cont) {
          type = tp;
          content = cont;
          return style;
        }

        function tokenBase(stream, state) {
          var ch = stream.next();

          if (ch == "\"" || ch == "'") {
            state.tokenize = tokenString(ch);
            return state.tokenize(stream, state);
          } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
            return ret("number", "number");
          } else if (ch == "." && stream.match("..")) {
            return ret("spread", "meta");
          } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
            return ret(ch);
          } else if (ch == "=" && stream.eat(">")) {
            return ret("=>", "operator");
          } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
            return ret("number", "number");
          } else if (/\d/.test(ch)) {
            stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
            return ret("number", "number");
          } else if (ch == "/") {
            if (stream.eat("*")) {
              state.tokenize = tokenComment;
              return ret("comment", "comment");
            } else if (stream.eat("/")) {
              stream.eatWhile(/\s/);
              if (!stream.eol()) state.tokenize = tokenLineComment;
              return ret("comment", "comment");
            } else if (expressionAllowed(stream, state, 1)) {
              readRegexp(stream);
              stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
              return ret("regexp", "string-2");
            } else {
              stream.eat("=");
              return ret("operator", "operator", stream.current());
            }
          } else if (ch == "`") {
            state.tokenize = tokenQuasi;
            return tokenQuasi(stream, state);
          } else if (ch == "#" && stream.peek() == "!") {
            stream.skipToEnd();
            return ret("meta", "meta");
          } else if (ch == "#" && stream.eatWhile(wordRE)) {
            return ret("variable", "property");
          } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start))) {
            stream.skipToEnd();
            return ret("comment", "comment");
          } else if (isOperatorChar.test(ch)) {
            if (ch != ">" || !state.lexical || state.lexical.type != ">") {
              if (stream.eat("=")) {
                if (ch == "!" || ch == "=") stream.eat("=");
              } else if (/[<>*+\-|&?]/.test(ch)) {
                stream.eat(ch);
                if (ch == ">") stream.eat(ch);
              }
            }

            if (ch == "?" && stream.eat(".")) return ret(".");
            return ret("operator", "operator", stream.current());
          } else if (wordRE.test(ch)) {
            stream.eatWhile(wordRE);
            var word = stream.current();

            if (state.lastType != ".") {
              if (keywords.propertyIsEnumerable(word)) {
                var kw = keywords[word];
                return ret(kw.type, kw.style, word);
              }

              if (word == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false)) {
                return ret("async", "keyword", word);
              }
            }

            return ret("variable", "variable", word);
          }
        }

        function tokenString(quote) {
          return function (stream, state) {
            var escaped = false;
            var next;

            if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
              state.tokenize = tokenBase;
              return ret("jsonld-keyword", "meta");
            }

            while ((next = stream.next()) != null) {
              if (next == quote && !escaped) break;
              escaped = !escaped && next == "\\";
            }

            if (!escaped) state.tokenize = tokenBase;
            return ret("string", "string");
          };
        }

        function tokenComment(stream, state) {
          var maybeEnd = false;
          var ch;
          var ateSome = false;

          while (ch = stream.eat(/[^\w\$_\xa1-\uffff]/)) {
            ateSome = true;

            if (ch == "/" && maybeEnd) {
              state.tokenize = tokenBase;
              break;
            }

            maybeEnd = ch == "*";
          }

          if (ateSome) return ret("comment", "comment");

          if (stream.eatWhile(/[\w\$_\xa1-\uffff]/)) {
            var cur = stream.current();

            if (cur == "TODO" || cur == "FIXME") {
              return ret("commentHighlight", "commentHighlight");
            }
          }

          ret("comment", "comment");
        }

        function tokenLineComment(stream, state) {
          if (stream.eatWhile(/[^\w\$_\xa1-\uffff]/)) {
            if (stream.eol()) {
              state.tokenize = tokenBase;
            }

            return "comment";
          }

          if (stream.eatWhile(/[\w\$_\xa1-\uffff]/)) {
            if (stream.eol()) {
              state.tokenize = tokenBase;
            }

            var cur = stream.current();

            if (cur == "TODO" || cur == "FIXME") {
              return ret("commentHighlight", "commentHighlight");
            }
          }

          stream.eatWhile(/\s/);

          if (stream.eol()) {
            state.tokenize = tokenBase;
          }

          return ret("comment", "comment");
        }

        function tokenQuasi(stream, state) {
          var escaped = false;
          var next;

          while ((next = stream.next()) != null) {
            if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
              state.tokenize = tokenBase;
              break;
            }

            escaped = !escaped && next == "\\";
          }

          return ret("quasi", "string-2", stream.current());
        }

        var brackets = "([{}])";

        function findFatArrow(stream, state) {
          if (state.fatArrowAt) state.fatArrowAt = null;
          var arrow = stream.string.indexOf("=>", stream.start);
          if (arrow < 0) return;

          if (isTS) {
            var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
            if (m) arrow = m.index;
          }

          var depth = 0;
          var sawSomething = false;

          for (var pos = arrow - 1; pos >= 0; --pos) {
            var ch = stream.string.charAt(pos);
            var bracket = brackets.indexOf(ch);

            if (bracket >= 0 && bracket < 3) {
              if (!depth) {
                ++pos;
                break;
              }

              if (--depth == 0) {
                if (ch == "(") sawSomething = true;
                break;
              }
            } else if (bracket >= 3 && bracket < 6) {
              ++depth;
            } else if (wordRE.test(ch)) {
              sawSomething = true;
            } else if (/["'\/`]/.test(ch)) {
              for (;; --pos) {
                if (pos == 0) return;
                var next = stream.string.charAt(pos - 1);

                if (next == ch && stream.string.charAt(pos - 2) != "\\") {
                  pos--;
                  break;
                }
              }
            } else if (sawSomething && !depth) {
              ++pos;
              break;
            }
          }

          if (sawSomething && !depth) state.fatArrowAt = pos;
        }

        var atomicTypes = {
          atom: true,
          number: true,
          variable: true,
          string: true,
          regexp: true,
          "this": true,
          "import": true,
          "jsonld-keyword": true
        };

        function JSLexical(indented, column, type, align, prev, info) {
          this.indented = indented;
          this.column = column;
          this.type = type;
          this.prev = prev;
          this.info = info;
          if (align != null) this.align = align;
        }

        function inScope(state, varname) {
          if (!trackScope) return false;

          for (var v = state.localVars; v; v = v.next) {
            if (v.name == varname) return true;
          }

          for (var _cx = state.context; _cx; _cx = _cx.prev) {
            for (var v = _cx.vars; v; v = v.next) {
              if (v.name == varname) return true;
            }
          }
        }

        function parseJS(state, style, type, content, stream) {
          var cc = state.cc;
          cx.state = state;
          cx.stream = stream;
          cx.marked = null, cx.cc = cc;
          cx.style = style;

          if (!state.lexical.hasOwnProperty("align")) {
            state.lexical.align = true;
          }

          while (true) {
            var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;

            if (combinator(type, content)) {
              while (cc.length && cc[cc.length - 1].lex) {
                cc.pop()();
              }

              if (cx.marked) return cx.marked;
              if (type == "variable" && inScope(state, content)) return "variable-2";
              return style;
            }
          }
        }

        var cx = {
          state: null,
          column: null,
          marked: null,
          cc: null
        };

        function pass() {
          for (var i = arguments.length - 1; i >= 0; i--) {
            cx.cc.push(arguments[i]);
          }
        }

        function cont() {
          pass.apply(null, arguments);
          return true;
        }

        function inList(name, list) {
          for (var v = list; v; v = v.next) {
            if (v.name == name) return true;
          }

          return false;
        }

        function register(varname) {
          var state = cx.state;
          cx.marked = "def";
          if (!trackScope) return;

          if (state.context) {
            if (state.lexical.info == "var" && state.context && state.context.block) {
              var newContext = registerVarScoped(varname, state.context);

              if (newContext != null) {
                state.context = newContext;
                return;
              }
            } else if (!inList(varname, state.localVars)) {
              state.localVars = new Var(varname, state.localVars);
              return;
            }
          }

          if (parserConfig.globalVars && !inList(varname, state.globalVars)) {
            state.globalVars = new Var(varname, state.globalVars);
          }
        }

        function registerVarScoped(varname, context) {
          if (!context) {
            return null;
          } else if (context.block) {
            var inner = registerVarScoped(varname, context.prev);
            if (!inner) return null;
            if (inner == context.prev) return context;
            return new Context(inner, context.vars, true);
          } else if (inList(varname, context.vars)) {
            return context;
          } else {
            return new Context(context.prev, new Var(varname, context.vars), false);
          }
        }

        function isModifier(name) {
          return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly";
        }

        function Context(prev, vars, block) {
          this.prev = prev;
          this.vars = vars;
          this.block = block;
        }

        function Var(name, next) {
          this.name = name;
          this.next = next;
        }

        var defaultVars = new Var("this", new Var("arguments", null));

        function pushcontext() {
          cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
          cx.state.localVars = defaultVars;
        }

        function pushblockcontext() {
          cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
          cx.state.localVars = null;
        }

        pushcontext.lex = pushblockcontext.lex = true;

        function popcontext() {
          cx.state.localVars = cx.state.context.vars;
          cx.state.context = cx.state.context.prev;
        }

        popcontext.lex = true;

        function pushlex(type, info) {
          var result = function result() {
            var state = cx.state;
            var indent = state.indented;
            if (state.lexical.type == "stat") indent = state.lexical.indented;else {
              for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev) {
                indent = outer.indented;
              }
            }
            state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
          };

          result.lex = true;
          return result;
        }

        function poplex() {
          var state = cx.state;

          if (state.lexical.prev) {
            if (state.lexical.type == ")") {
              state.indented = state.lexical.indented;
            }

            state.lexical = state.lexical.prev;
          }
        }

        poplex.lex = true;

        function expect(wanted) {
          function exp(type) {
            if (type == wanted) return cont();else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();else return cont(exp);
          }

          return exp;
        }

        function statement(type, value) {
          if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
          if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
          if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
          if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
          if (type == "debugger") return cont(expect(";"));
          if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
          if (type == ";") return cont();

          if (type == "if") {
            if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex) {
              cx.state.cc.pop()();
            }

            return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
          }

          if (type == "function") return cont(functiondef);
          if (type == "for") return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);

          if (type == "class" || isTS && value == "interface") {
            cx.marked = "keyword";
            return cont(pushlex("form", type == "class" ? type : value), className, poplex);
          }

          if (type == "variable") {
            if (isTS && value == "declare") {
              cx.marked = "keyword";
              return cont(statement);
            } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
              cx.marked = "keyword";
              if (value == "enum") return cont(enumdef);else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex);
            } else if (isTS && value == "namespace") {
              cx.marked = "keyword";
              return cont(pushlex("form"), expression, statement, poplex);
            } else if (isTS && value == "abstract") {
              cx.marked = "keyword";
              return cont(statement);
            } else {
              return cont(pushlex("stat"), maybelabel);
            }
          }

          if (type == "switch") {
            return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext);
          }

          if (type == "case") return cont(expression, expect(":"));
          if (type == "default") return cont(expect(":"));
          if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
          if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
          if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
          if (type == "async") return cont(statement);
          if (value == "@") return cont(expression, statement);
          return pass(pushlex("stat"), expression, expect(";"), poplex);
        }

        function maybeCatchBinding(type) {
          if (type == "(") return cont(funarg, expect(")"));
        }

        function expression(type, value) {
          return expressionInner(type, value, false);
        }

        function expressionNoComma(type, value) {
          return expressionInner(type, value, true);
        }

        function parenExpr(type) {
          if (type != "(") return pass();
          return cont(pushlex(")"), maybeexpression, expect(")"), poplex);
        }

        function expressionInner(type, value, noComma) {
          if (cx.state.fatArrowAt == cx.stream.start) {
            var body = noComma ? arrowBodyNoComma : arrowBody;
            if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
          }

          var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
          if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
          if (type == "function") return cont(functiondef, maybeop);

          if (type == "class" || isTS && value == "interface") {
            cx.marked = "keyword";
            return cont(pushlex("form"), classExpression, poplex);
          }

          if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
          if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
          if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
          if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
          if (type == "{") return contCommasep(objprop, "}", null, maybeop);
          if (type == "quasi") return pass(quasi, maybeop);
          if (type == "new") return cont(maybeTarget(noComma));
          return cont();
        }

        function maybeexpression(type) {
          if (type.match(/[;\}\)\],]/)) return pass();
          return pass(expression);
        }

        function maybeoperatorComma(type, value) {
          if (type == ",") return cont(maybeexpression);
          return maybeoperatorNoComma(type, value, false);
        }

        function maybeoperatorNoComma(type, value, noComma) {
          var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
          var expr = noComma == false ? expression : expressionNoComma;
          if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);

          if (type == "operator") {
            if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);

            if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false)) {
              return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
            }

            if (value == "?") return cont(expression, expect(":"), expr);
            return cont(expr);
          }

          if (type == "quasi") {
            return pass(quasi, me);
          }

          if (type == ";") return;
          if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
          if (type == ".") return cont(property, me);
          if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);

          if (isTS && value == "as") {
            cx.marked = "keyword";
            return cont(typeexpr, me);
          }

          if (type == "regexp") {
            cx.state.lastType = cx.marked = "operator";
            cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
            return cont(expr);
          }
        }

        function quasi(type, value) {
          if (type != "quasi") return pass();
          if (value.slice(value.length - 2) != "${") return cont(quasi);
          return cont(maybeexpression, continueQuasi);
        }

        function continueQuasi(type) {
          if (type == "}") {
            cx.marked = "string-2";
            cx.state.tokenize = tokenQuasi;
            return cont(quasi);
          }
        }

        function arrowBody(type) {
          findFatArrow(cx.stream, cx.state);
          return pass(type == "{" ? statement : expression);
        }

        function arrowBodyNoComma(type) {
          findFatArrow(cx.stream, cx.state);
          return pass(type == "{" ? statement : expressionNoComma);
        }

        function maybeTarget(noComma) {
          return function (type) {
            if (type == ".") return cont(noComma ? targetNoComma : target);else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);else return pass(noComma ? expressionNoComma : expression);
          };
        }

        function target(_, value) {
          if (value == "target") {
            cx.marked = "keyword";
            return cont(maybeoperatorComma);
          }
        }

        function targetNoComma(_, value) {
          if (value == "target") {
            cx.marked = "keyword";
            return cont(maybeoperatorNoComma);
          }
        }

        function maybelabel(type) {
          if (type == ":") return cont(poplex, statement);
          return pass(maybeoperatorComma, expect(";"), poplex);
        }

        function property(type) {
          if (type == "variable") {
            cx.marked = "property";
            return cont();
          }
        }

        function objprop(type, value) {
          if (type == "async") {
            cx.marked = "property";
            return cont(objprop);
          } else if (type == "variable" || cx.style == "keyword") {
            cx.marked = "property";
            if (value == "get" || value == "set") return cont(getterSetter);
            var m;

            if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false))) {
              cx.state.fatArrowAt = cx.stream.pos + m[0].length;
            }

            return cont(afterprop);
          } else if (type == "number" || type == "string") {
            cx.marked = jsonldMode ? "property" : cx.style + " property";
            return cont(afterprop);
          } else if (type == "jsonld-keyword") {
            return cont(afterprop);
          } else if (isTS && isModifier(value)) {
            cx.marked = "keyword";
            return cont(objprop);
          } else if (type == "[") {
            return cont(expression, maybetype, expect("]"), afterprop);
          } else if (type == "spread") {
            return cont(expressionNoComma, afterprop);
          } else if (value == "*") {
            cx.marked = "keyword";
            return cont(objprop);
          } else if (type == ":") {
            return pass(afterprop);
          }
        }

        function getterSetter(type) {
          if (type != "variable") return pass(afterprop);
          cx.marked = "property";
          return cont(functiondef);
        }

        function afterprop(type) {
          if (type == ":") return cont(expressionNoComma);
          if (type == "(") return pass(functiondef);
        }

        function commasep(what, end, sep) {
          function proceed(type, value) {
            if (sep ? sep.indexOf(type) > -1 : type == ",") {
              var lex = cx.state.lexical;
              if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
              return cont(function (type, value) {
                if (type == end || value == end) return pass();
                return pass(what);
              }, proceed);
            }

            if (type == end || value == end) return cont();
            if (sep && sep.indexOf(";") > -1) return pass(what);
            return cont(expect(end));
          }

          return function (type, value) {
            if (type == end || value == end) return cont();
            return pass(what, proceed);
          };
        }

        function contCommasep(what, end, info) {
          for (var i = 3; i < arguments.length; i++) {
            cx.cc.push(arguments[i]);
          }

          return cont(pushlex(end, info), commasep(what, end), poplex);
        }

        function block(type) {
          if (type == "}") return cont();
          return pass(statement, block);
        }

        function maybetype(type, value) {
          if (isTS) {
            if (type == ":") return cont(typeexpr);
            if (value == "?") return cont(maybetype);
          }
        }

        function maybetypeOrIn(type, value) {
          if (isTS && (type == ":" || value == "in")) return cont(typeexpr);
        }

        function mayberettype(type) {
          if (isTS && type == ":") {
            if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr);else return cont(typeexpr);
          }
        }

        function isKW(_, value) {
          if (value == "is") {
            cx.marked = "keyword";
            return cont();
          }
        }

        function typeexpr(type, value) {
          if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
            cx.marked = "keyword";
            return cont(value == "typeof" ? expressionNoComma : typeexpr);
          }

          if (type == "variable" || value == "void") {
            cx.marked = "type";
            return cont(afterType);
          }

          if (value == "|" || value == "&") return cont(typeexpr);
          if (type == "string" || type == "number" || type == "atom") return cont(afterType);
          if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
          if (type == "{") return cont(pushlex("}"), typeprops, poplex, afterType);
          if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType);
          if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr);

          if (type == "quasi") {
            return pass(quasiType, afterType);
          }
        }

        function maybeReturnType(type) {
          if (type == "=>") return cont(typeexpr);
        }

        function typeprops(type) {
          if (type.match(/[\}\)\]]/)) return cont();
          if (type == "," || type == ";") return cont(typeprops);
          return pass(typeprop, typeprops);
        }

        function typeprop(type, value) {
          if (type == "variable" || cx.style == "keyword") {
            cx.marked = "property";
            return cont(typeprop);
          } else if (value == "?" || type == "number" || type == "string") {
            return cont(typeprop);
          } else if (type == ":") {
            return cont(typeexpr);
          } else if (type == "[") {
            return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);
          } else if (type == "(") {
            return pass(functiondecl, typeprop);
          } else if (!type.match(/[;\}\)\],]/)) {
            return cont();
          }
        }

        function quasiType(type, value) {
          if (type != "quasi") return pass();
          if (value.slice(value.length - 2) != "${") return cont(quasiType);
          return cont(typeexpr, continueQuasiType);
        }

        function continueQuasiType(type) {
          if (type == "}") {
            cx.marked = "string-2";
            cx.state.tokenize = tokenQuasi;
            return cont(quasiType);
          }
        }

        function typearg(type, value) {
          if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg);
          if (type == ":") return cont(typeexpr);
          if (type == "spread") return cont(typearg);
          return pass(typeexpr);
        }

        function afterType(type, value) {
          if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
          if (value == "|" || type == "." || value == "&") return cont(typeexpr);
          if (type == "[") return cont(typeexpr, expect("]"), afterType);

          if (value == "extends" || value == "implements") {
            cx.marked = "keyword";
            return cont(typeexpr);
          }

          if (value == "?") return cont(typeexpr, expect(":"), typeexpr);
        }

        function maybeTypeArgs(_, value) {
          if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
        }

        function typeparam() {
          return pass(typeexpr, maybeTypeDefault);
        }

        function maybeTypeDefault(_, value) {
          if (value == "=") return cont(typeexpr);
        }

        function vardef(_, value) {
          if (value == "enum") {
            cx.marked = "keyword";
            return cont(enumdef);
          }

          return pass(pattern, maybetype, maybeAssign, vardefCont);
        }

        function pattern(type, value) {
          if (isTS && isModifier(value)) {
            cx.marked = "keyword";
            return cont(pattern);
          }

          if (type == "variable") {
            register(value);
            return cont();
          }

          if (type == "spread") return cont(pattern);
          if (type == "[") return contCommasep(eltpattern, "]");
          if (type == "{") return contCommasep(proppattern, "}");
        }

        function proppattern(type, value) {
          if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
            register(value);
            return cont(maybeAssign);
          }

          if (type == "variable") cx.marked = "property";
          if (type == "spread") return cont(pattern);
          if (type == "}") return pass();
          if (type == "[") return cont(expression, expect("]"), expect(":"), proppattern);
          return cont(expect(":"), pattern, maybeAssign);
        }

        function eltpattern() {
          return pass(pattern, maybeAssign);
        }

        function maybeAssign(_type, value) {
          if (value == "=") return cont(expressionNoComma);
        }

        function vardefCont(type) {
          if (type == ",") return cont(vardef);
        }

        function maybeelse(type, value) {
          if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
        }

        function forspec(type, value) {
          if (value == "await") return cont(forspec);
          if (type == "(") return cont(pushlex(")"), forspec1, poplex);
        }

        function forspec1(type) {
          if (type == "var") return cont(vardef, forspec2);
          if (type == "variable") return cont(forspec2);
          return pass(forspec2);
        }

        function forspec2(type, value) {
          if (type == ")") return cont();
          if (type == ";") return cont(forspec2);

          if (value == "in" || value == "of") {
            cx.marked = "keyword";
            return cont(expression, forspec2);
          }

          return pass(expression, forspec2);
        }

        function functiondef(type, value) {
          if (value == "*") {
            cx.marked = "keyword";
            return cont(functiondef);
          }

          if (type == "variable") {
            register(value);
            return cont(functiondef);
          }

          if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
          if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
        }

        function functiondecl(type, value) {
          if (value == "*") {
            cx.marked = "keyword";
            return cont(functiondecl);
          }

          if (type == "variable") {
            register(value);
            return cont(functiondecl);
          }

          if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
          if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
        }

        function typename(type, value) {
          if (type == "keyword" || type == "variable") {
            cx.marked = "type";
            return cont(typename);
          } else if (value == "<") {
            return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
          }
        }

        function funarg(type, value) {
          if (value == "@") cont(expression, funarg);
          if (type == "spread") return cont(funarg);

          if (isTS && isModifier(value)) {
            cx.marked = "keyword";
            return cont(funarg);
          }

          if (isTS && type == "this") return cont(maybetype, maybeAssign);
          return pass(pattern, maybetype, maybeAssign);
        }

        function classExpression(type, value) {
          if (type == "variable") return className(type, value);
          return classNameAfter(type, value);
        }

        function className(type, value) {
          if (type == "variable") {
            register(value);
            return cont(classNameAfter);
          }
        }

        function classNameAfter(type, value) {
          if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);

          if (value == "extends" || value == "implements" || isTS && type == ",") {
            if (value == "implements") cx.marked = "keyword";
            return cont(isTS ? typeexpr : expression, classNameAfter);
          }

          if (type == "{") return cont(pushlex("}"), classBody, poplex);
        }

        function classBody(type, value) {
          if (type == "async" || type == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
            cx.marked = "keyword";
            return cont(classBody);
          }

          if (type == "variable" || cx.style == "keyword") {
            cx.marked = "property";
            return cont(classfield, classBody);
          }

          if (type == "number" || type == "string") return cont(classfield, classBody);

          if (type == "[") {
            return cont(expression, maybetype, expect("]"), classfield, classBody);
          }

          if (value == "*") {
            cx.marked = "keyword";
            return cont(classBody);
          }

          if (isTS && type == "(") return pass(functiondecl, classBody);
          if (type == ";" || type == ",") return cont(classBody);
          if (type == "}") return cont();
          if (value == "@") return cont(expression, classBody);
        }

        function classfield(type, value) {
          if (value == "!") return cont(classfield);
          if (value == "?") return cont(classfield);
          if (type == ":") return cont(typeexpr, maybeAssign);
          if (value == "=") return cont(expressionNoComma);
          var context = cx.state.lexical.prev;
          var isInterface = context && context.info == "interface";
          return pass(isInterface ? functiondecl : functiondef);
        }

        function afterExport(type, value) {
          if (value == "*") {
            cx.marked = "keyword";
            return cont(maybeFrom, expect(";"));
          }

          if (value == "default") {
            cx.marked = "keyword";
            return cont(expression, expect(";"));
          }

          if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
          return pass(statement);
        }

        function exportField(type, value) {
          if (value == "as") {
            cx.marked = "keyword";
            return cont(expect("variable"));
          }

          if (type == "variable") return pass(expressionNoComma, exportField);
        }

        function afterImport(type) {
          if (type == "string") return cont();
          if (type == "(") return pass(expression);
          if (type == ".") return pass(maybeoperatorComma);
          return pass(importSpec, maybeMoreImports, maybeFrom);
        }

        function importSpec(type, value) {
          if (type == "{") return contCommasep(importSpec, "}");
          if (type == "variable") register(value);
          if (value == "*") cx.marked = "keyword";
          return cont(maybeAs);
        }

        function maybeMoreImports(type) {
          if (type == ",") return cont(importSpec, maybeMoreImports);
        }

        function maybeAs(_type, value) {
          if (value == "as") {
            cx.marked = "keyword";
            return cont(importSpec);
          }
        }

        function maybeFrom(_type, value) {
          if (value == "from") {
            cx.marked = "keyword";
            return cont(expression);
          }
        }

        function arrayLiteral(type) {
          if (type == "]") return cont();
          return pass(commasep(expressionNoComma, "]"));
        }

        function enumdef() {
          return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
        }

        function enummember() {
          return pass(pattern, maybeAssign);
        }

        function isContinuedStatement(state, textAfter) {
          return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
        }

        function expressionAllowed(stream, state, backUp) {
          return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
        }

        return {
          startState: function startState(basecolumn) {
            var state = {
              tokenize: tokenBase,
              lastType: "sof",
              cc: [],
              lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
              localVars: parserConfig.localVars,
              context: parserConfig.localVars && new Context(null, null, false),
              indented: basecolumn || 0
            };

            if (parserConfig.globalVars && _typeof$1(parserConfig.globalVars) == "object") {
              state.globalVars = parserConfig.globalVars;
            }

            return state;
          },
          token: function token(stream, state) {
            if (stream.sol()) {
              if (!state.lexical.hasOwnProperty("align")) {
                state.lexical.align = false;
              }

              state.indented = stream.indentation();
              findFatArrow(stream, state);
            }

            if (state.tokenize != tokenComment && stream.eatSpace()) return null;
            var style = state.tokenize(stream, state);
            if (type == "comment") return style;
            state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
            return parseJS(state, style, type, content, stream);
          },
          indent: function indent(state, textAfter) {
            if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return passIndent;
            if (state.tokenize != tokenBase) return 0;
            var firstChar = textAfter && textAfter.charAt(0);
            var lexical = state.lexical;
            var top;

            if (!/^\s*else\b/.test(textAfter)) {
              for (var i = state.cc.length - 1; i >= 0; --i) {
                var c = state.cc[i];
                if (c == poplex) lexical = lexical.prev;else if (c != maybeelse && c != popcontext) break;
              }
            }

            while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter))) {
              lexical = lexical.prev;
            }

            if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat") {
              lexical = lexical.prev;
            }

            var type = lexical.type;
            var closing = firstChar == type;
            if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);else if (type == "form" && firstChar == "{") return lexical.indented;else if (type == "form") return lexical.indented + indentUnit;else if (type == "stat") {
              return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
            } else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false) {
              return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
            } else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);
          },
          electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
          blockCommentStart: jsonMode ? null : "/*",
          blockCommentEnd: jsonMode ? null : "*/",
          blockCommentContinue: jsonMode ? null : " * ",
          lineComment: jsonMode ? null : "//",
          fold: "brace",
          closeBrackets: "()[]{}''\"\"``",
          helperType: jsonMode ? "json" : "javascript",
          jsonldMode: jsonldMode,
          jsonMode: jsonMode,
          expressionAllowed: expressionAllowed,
          skipExpression: function skipExpression(state) {
            var top = state.cc[state.cc.length - 1];
            if (top == expression || top == expressionNoComma) state.cc.pop();
          }
        };
      });
      registerHelper("wordChars", "javascript", /[\w$]/);
      defineMIME("text/javascript", "javascript");
      defineMIME("text/ecmascript", "javascript");
      defineMIME("application/javascript", "javascript");
      defineMIME("application/x-javascript", "javascript");
      defineMIME("application/ecmascript", "javascript");
      defineMIME("application/json", {
        name: "javascript",
        json: true
      });
      defineMIME("application/x-json", {
        name: "javascript",
        json: true
      });
      defineMIME("application/ld+json", {
        name: "javascript",
        jsonld: true
      });
      defineMIME("text/typescript", {
        name: "javascript",
        typescript: true
      });
      defineMIME("application/typescript", {
        name: "javascript",
        typescript: true
      });

      var __varRecorder__$L = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/editor-plugin.js", __contextModule__);

      var JavaScriptEditorPlugin = exports('a4', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/editor-plugin.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("JavaScriptEditorPlugin") && typeof __lively_classholder__.JavaScriptEditorPlugin === "function" ? __lively_classholder__.JavaScriptEditorPlugin : __lively_classholder__.JavaScriptEditorPlugin = function JavaScriptEditorPlugin(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function JavaScriptEditorPlugin_initialize_() {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this);
            this.checker = new JavaScriptChecker();
            this.evalEnvironment = {
              format: "esm",
              targetModule: null,
              context: null
            };
            return _this;
          }
        }, {
          key: "isJSEditorPlugin",
          get: function get() {
            return true;
          }
        }, {
          key: "shortName",
          get: function get() {
            return "js";
          }
        }, {
          key: "longName",
          get: function get() {
            return "javascript";
          }
        }, {
          key: "setFormat",
          value: function JavaScriptEditorPlugin_setFormat_(format) {
            var _this$evalEnvironment = this.evalEnvironment,
                targetModule = _this$evalEnvironment.targetModule,
                systemInterface = _this$evalEnvironment.systemInterface;
            systemInterface.setModuleFormat(targetModule, format);
          }
        }, {
          key: "attach",
          value: function JavaScriptEditorPlugin_attach_(editor) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "attach", this).call(this, editor);

            this.evalEnvironment = Object.assign({}, this.evalEnvironment, {
              context: editor
            });
          }
        }, {
          key: "detach",
          value: function JavaScriptEditorPlugin_detach_(editor) {
            this.checker.uninstall(this.textMorph);

            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "detach", this).call(this, editor);
          }
        }, {
          key: "getNavigator",
          value: function JavaScriptEditorPlugin_getNavigator_() {
            return new JavaScriptNavigator();
          }
        }, {
          key: "getCompleters",
          value: function JavaScriptEditorPlugin_getCompleters_(otherCompleters) {
            return completers.concat(otherCompleters);
          }
        }, {
          key: "getCommands",
          value: function JavaScriptEditorPlugin_getCommands_(otherCommands) {
            return [].concat(_toConsumableArray$1(initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "getCommands", this).call(this, otherCommands)), _toConsumableArray$1(jsIdeCommands), _toConsumableArray$1(jsEditorCommands), _toConsumableArray$1(astEditorCommands));
          }
        }, {
          key: "getKeyBindings",
          value: function JavaScriptEditorPlugin_getKeyBindings_(other) {
            return [].concat(_toConsumableArray$1(other), [{
              keys: "Shift-Tab",
              command: {
                command: "[javascript] auto format code"
              }
            }, {
              keys: "Ctrl-C E",
              command: "[javascript] list errors and warnings"
            }, {
              keys: {
                mac: "Meta-Shift-L L I N T R",
                win: "Ctrl-Shift-L L I N T R"
              },
              command: "[javascript] eslint report"
            }, {
              keys: {
                mac: "Meta-Shift-L L I N T P",
                win: "Ctrl-Shift-L L I N T P"
              },
              command: "[javascript] eslint preview fixes"
            }, {
              keys: {
                mac: "Meta-Shift-L L I N T F",
                win: "Ctrl-Shift-L L I N T F"
              },
              command: "[javascript] eslint fix"
            }, {
              keys: {
                mac: "Meta-Shift-L M O D E",
                win: "Ctrl-Shift-L M O D E"
              },
              command: "change editor mode"
            }, {
              keys: "Ctrl-C I",
              command: "[javascript] inject import"
            }, {
              keys: "Ctrl-C C I",
              command: "[javascript] fix undeclared variables"
            }]);
          }
        }, {
          key: "getMenuItems",
          value: function () {
            var _JavaScriptEditorPlugin_getMenuItems_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(items) {
              var editor, jsItems, nav, ref, text;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      editor = this.textMorph;
                      jsItems = [{
                        command: "doit",
                        target: editor,
                        showKeyShortcuts: true
                      }, {
                        command: "inspectit",
                        target: editor,
                        showKeyShortcuts: true
                      }, {
                        command: "editit",
                        target: editor,
                        showKeyShortcuts: true
                      }, {
                        command: "printit",
                        target: editor,
                        showKeyShortcuts: true
                      }, {
                        command: "print inspectit",
                        alias: "print inspect",
                        target: editor,
                        showKeyShortcuts: true
                      }, {
                        command: "log it",
                        target: editor,
                        showKeyShortcuts: true
                      }, {
                        command: "eval all",
                        target: editor,
                        showKeyShortcuts: true
                      }, {
                        command: "text completion",
                        alias: "code completion",
                        target: editor,
                        showKeyShortcuts: true
                      }, {
                        command: "blame line",
                        target: editor,
                        showKeyShortcuts: true
                      }, {
                        command: "[javascript] list errors and warnings",
                        alias: "list errors and warnings",
                        target: editor,
                        showKeyShortcuts: true
                      }, {
                        isDivider: true
                      }];

                      if (this.evalEnvironment.targetModule) {
                        jsItems.push({
                          command: "[javascript] inject import",
                          alias: "add import",
                          target: editor
                        }, {
                          command: "[javascript] fix undeclared variables",
                          alias: "fix undeclared variables",
                          target: editor
                        }, {
                          command: "[javascript] remove unused imports",
                          alias: "remove unused imports",
                          target: editor
                        });
                      }

                      nav = this.getNavigator();
                      ref = nav.resolveIdentifierAt(editor, editor.cursorPosition);

                      if (ref) {
                        jsItems.push({
                          command: "selectDefinition",
                          alias: "jump to definition of \"".concat(ref.name, "\""),
                          target: editor
                        }, {
                          command: "selectSymbolReferenceOrDeclaration",
                          alias: "select all occurrences of \"".concat(ref.name, "\""),
                          target: editor
                        });
                      }

                      text = editor.selection.text.trim();

                      if (text) {
                        jsItems.push({
                          command: "open code search",
                          alias: "code search for \"".concat(truncate(text, 30), "\""),
                          target: editor.world(),
                          args: {
                            input: text,
                            backend: this.backend()
                          }
                        });
                      }

                      jsItems.push({
                        isDivider: true
                      });
                      return _context.abrupt("return", jsItems.concat(items));

                    case 10:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function JavaScriptEditorPlugin_getMenuItems_(_x) {
              return _JavaScriptEditorPlugin_getMenuItems_.apply(this, arguments);
            }

            return JavaScriptEditorPlugin_getMenuItems_;
          }()
        }, {
          key: "getSnippets",
          value: function JavaScriptEditorPlugin_getSnippets_() {
            return snippets$1.map(function (_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                  trigger = _ref2[0],
                  expansion = _ref2[1];

              return new Snippet({
                trigger: trigger,
                expansion: expansion
              });
            });
          }
        }, {
          key: "sanatizedJsEnv",
          value: function JavaScriptEditorPlugin_sanatizedJsEnv_(envMixin) {
            var env = Object.assign({}, this.evalEnvironment, {}, envMixin);
            if (!env.format) env.format = "esm";
            if (!env.context) env.context = this.textMorph;

            if (!env.sourceURL) {
              env.sourceURL = env.targetModule + "_doit_" + Date.now();
            }

            if (!env.systemInterface) env.systemInterface = localInterface;
            return env;
          }
        }, {
          key: "backend",
          value: function JavaScriptEditorPlugin_backend_(envMixin) {
            var env = this.sanatizedJsEnv(envMixin);
            return env.remote ? env.remote : "local";
          }
        }, {
          key: "systemInterface",
          value: function JavaScriptEditorPlugin_systemInterface_(envMixin) {
            var env = this.sanatizedJsEnv(envMixin);
            return env.systemInterface || localInterface;
          }
        }, {
          key: "setSystemInterface",
          value: function JavaScriptEditorPlugin_setSystemInterface_(systemInterface) {
            return this.evalEnvironment.systemInterface = systemInterface;
          }
        }, {
          key: "setSystemInterfaceNamed",
          value: function JavaScriptEditorPlugin_setSystemInterfaceNamed_(interfaceSpec) {
            return this.setSystemInterface(systemInterfaceNamed(interfaceSpec));
          }
        }, {
          key: "runEval",
          value: function JavaScriptEditorPlugin_runEval_(code, opts) {
            var env = this.sanatizedJsEnv(opts);
            var endpoint = this.systemInterface(env);
            return endpoint.runEval(code, env);
          }
        }, {
          key: "parser",
          get: function get() {
            return parser;
          }
        }, {
          key: "parse",
          value: function JavaScriptEditorPlugin_parse_() {
            var astType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            if (this._ast && this._ast._astType === astType) return this._ast;
            var parser = this.parser,
                src = this.textMorph.textString;
            if (!parser) return null;
            var options = {
              withComments: true,
              allowReturnOutsideFunction: true
            };
            if (astType) options.type = astType;

            if (src.startsWith("#!")) {
              var firstLineEnd = src.indexOf("\n");
              src = " ".repeat(firstLineEnd) + src.slice(firstLineEnd);
            }

            var parsed = parser.fuzzyParse(src, options);
            parsed._astType = astType;
            this._ast = parsed;
            return parsed;
          }
        }, {
          key: "undeclaredVariables",
          value: function JavaScriptEditorPlugin_undeclaredVariables_() {
            var astType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var morph = this.textMorph,
                parser = this.parser;
            morph.document;
            var knownGlobals = this.evalEnvironment.knownGlobals || [];
            var parsed = this.parse(astType);
            if (!parser || !parsed) return [];
            return parser.query.findGlobalVarRefs(parsed, {
              jslintGlobalComment: true
            }).filter(function (ea) {
              return !knownGlobals.includes(ea.name);
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "JavaScriptEditorPlugin";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/editor-plugin.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 664,
          end: 7153
        });
      }({
        referencedAs: "CodeMirrorEnabledEditorPlugin",
        value: CodeMirrorEnabledEditorPlugin
      }));
      __varRecorder__$L["default"] = JavaScriptEditorPlugin;

      var editorPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': JavaScriptEditorPlugin
      });
      exports('ac', editorPlugin);

      var __varRecorder__$K = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/json/checker.js", __contextModule__);
      __varRecorder__$K.warnStyle = {
        "border-bottom": "2px dotted orange"
      };
      __varRecorder__$K.errorStyle = {
        "background-color": "red"
      };

      var JSONChecker = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/json/checker.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("JSONChecker") && typeof __lively_classholder__.JSONChecker === "function" ? __lively_classholder__.JSONChecker : __lively_classholder__.JSONChecker = function JSONChecker(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "uninstall",
          value: function JSONChecker_uninstall_(editor) {
            var morph = editor.text || editor;
            (morph.markers || []).forEach(function (ea) {
              return ea.id.startsWith("js-checker-") && morph.removeMarker(ea);
            });
            morph.removeMarker("js-syntax-error");
          }
        }, {
          key: "hasEmbeddedMorphInRange",
          value: function JSONChecker_hasEmbeddedMorphInRange_(textMorph, range) {
            return _toConsumableArray$1(textMorph.embeddedMorphMap.values()).find(function (_ref) {
              var anchor = _ref.anchor;
              return range.containsPosition(anchor.position);
            });
          }
        }, {
          key: "onDocumentChange",
          value: function JSONChecker_onDocumentChange_(change, textMorph, jsPlugin) {
            try {
              JSON.parse(textMorph.textString);
              textMorph.removeMarker("js-syntax-error");
            } catch (err) {
              if (!(err instanceof SyntaxError)) throw err;
              var pos;

              var _ref2 = err.message.match(/position ([0-9]+)/) || [],
                  _ref3 = _slicedToArray(_ref2, 2);
                  _ref3[0];
                  var index = _ref3[1];

              if (index && !isNaN(Number(index))) {
                pos = textMorph.indexToPosition(Number(index));
              }

              if (!pos) {
                var _ref4 = err.message.match(/line ([0-9]+)/) || [],
                    _ref5 = _slicedToArray(_ref4, 2);
                    _ref5[0];
                    var line = _ref5[1];

                var _ref6 = err.message.match(/column ([0-9]+)/) || [],
                    _ref7 = _slicedToArray(_ref6, 2);
                    _ref7[0];
                    var column = _ref7[1];

                if (!isNaN(Number(line))) pos = {
                  row: Number(line) - 1,
                  column: Number(column)
                };
              }

              if (!pos) {
                var column = err.column,
                    line = err.line;
                if (typeof line === "number") pos = {
                  row: line - 1,
                  column: column
                };
              }

              if (pos && !isNaN(pos.row) && !isNaN(pos.column)) {
                var range = new Range({
                  start: {
                    column: pos.column - 1,
                    row: pos.row
                  },
                  end: {
                    column: pos.column + 1,
                    row: pos.row
                  }
                });
                if (this.hasEmbeddedMorphInRange(textMorph, range)) return;
                textMorph.addMarker({
                  id: "js-syntax-error",
                  range: range,
                  style: __varRecorder__$K.errorStyle,
                  type: "js-syntax-error"
                });
              }
            }
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "JSONChecker";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./json/checker.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 180,
          end: 1873
        });
      }(undefined);
      __varRecorder__$K["default"] = JSONChecker;

      var __varRecorder__$J = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/json/completers.js", __contextModule__);
      var __moduleMeta__$n = {
        pathInPackage: function pathInPackage() {
          return "./json/completers.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var doNewNPMSearch = __varRecorder__$J["lively.ide/json/completers.js__define__"]("doNewNPMSearch", "function", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(query) {
          var url, found;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  url = "https://registry.npmjs.com/-/v1/search?text=".concat(query, "&size=50");
                  _context.next = 3;
                  return resource(url).makeProxied().readJson();

                case 3:
                  found = _context.sent;
                  return _context.abrupt("return", found.objects.map(function (p) {
                    p.searchScore;
                        var _p$package = p["package"],
                        name = _p$package.name,
                        version = _p$package.version;
                    return {
                      isListItem: true,
                      string: "".concat(name, "@").concat(version),
                      value: p
                    };
                  }));

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }(), __moduleMeta__$n);

      __varRecorder__$J.doNewNPMSearch = doNewNPMSearch;
      var PackageJSONCompleter = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/json/completers.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PackageJSONCompleter") && typeof __lively_classholder__.PackageJSONCompleter === "function" ? __lively_classholder__.PackageJSONCompleter : __lively_classholder__.PackageJSONCompleter = function PackageJSONCompleter(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "isValidPrefix",
          value: function PackageJSONCompleter_isValidPrefix_(prefix) {
            return !!prefix;
          }
        }, {
          key: "compute",
          value: function () {
            var _PackageJSONCompleter_compute_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(textMorph, prefix) {
              var isInDef, pkgs;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      textMorph.editorPlugin.parse();
                      isInDef = !!textMorph.editorPlugin.tokenAt(textMorph.cursorPosition).find(function (m) {
                        return ["dependencies", "devDependencies"].includes(Path("key.value").get(m));
                      });

                      if (isInDef) {
                        _context2.next = 4;
                        break;
                      }

                      return _context2.abrupt("return", []);

                    case 4:
                      _context2.next = 6;
                      return __varRecorder__$J.doNewNPMSearch(prefix);

                    case 6:
                      pkgs = _context2.sent;
                      return _context2.abrupt("return", pkgs.map(function (pkg) {
                        var _pkg$string$split = pkg.string.split("@"),
                            _pkg$string$split2 = _slicedToArray(_pkg$string$split, 2),
                            completion = _pkg$string$split2[0],
                            info = _pkg$string$split2[1];

                        return {
                          info: "@".concat(info),
                          completion: completion,
                          customInsertionFn: function customInsertionFn(complString, prefix, textMorph, _ref2) {
                            _ref2.start;
                                _ref2.end;
                            textMorph.replace(textMorph.lineRange(), "\"".concat(completion, "\": \"").concat(info, "\""));
                          }
                        };
                      }));

                    case 8:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }));

            function PackageJSONCompleter_compute_(_x2, _x3) {
              return _PackageJSONCompleter_compute_.apply(this, arguments);
            }

            return PackageJSONCompleter_compute_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PackageJSONCompleter";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./json/completers.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 89,
          end: 830
        });
      }(undefined);
      __varRecorder__$J.PackageJSONCompleter = PackageJSONCompleter;
      __varRecorder__$J.PackageJSONCompleter = PackageJSONCompleter;

      var __varRecorder__$I = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/json/editor-plugin.js", __contextModule__);

      var JSONEditorPlugin = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/json/editor-plugin.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("JSONEditorPlugin") && typeof __lively_classholder__.JSONEditorPlugin === "function" ? __lively_classholder__.JSONEditorPlugin : __lively_classholder__.JSONEditorPlugin = function JSONEditorPlugin(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function JSONEditorPlugin_initialize_() {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this);
            this.checker = new JSONChecker();
            return _this;
          }
        }, {
          key: "parse",
          value: function JSONEditorPlugin_parse_() {
            var astType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            if (this._ast && this._ast._astType === astType) {
              return this._ast;
            }

            var parser = this.parser,
                src = this.textMorph.textString;

            if (!parser) {
              return null;
            }

            var options = {
              withComments: true,
              allowReturnOutsideFunction: true
            };

            if (astType) {
              options.type = astType;
            }

            if (src.startsWith("#!")) {
              var firstLineEnd = src.indexOf("\n");
              src = " ".repeat(firstLineEnd) + src.slice(firstLineEnd);
            }

            src = "(".concat(src, ")");
            var parsed = parser.fuzzyParse(src, options);
            parsed._astType = astType;
            this._ast = parsed;
            return parsed;
          }
        }, {
          key: "tokenAt",
          value: function JSONEditorPlugin_tokenAt_(pos) {
            return nodesAt$1(this.textMorph.positionToIndex(pos) - 1, this._ast);
          }
        }, {
          key: "isJSONEditorPlugin",
          get: function get() {
            return true;
          }
        }, {
          key: "shortName",
          get: function get() {
            return "json";
          }
        }, {
          key: "longName",
          get: function get() {
            return "json";
          }
        }, {
          key: "codeMirrorMode",
          value: function JSONEditorPlugin_codeMirrorMode_(textMorph) {
            var config = this.defaultCodeMirrorModeConfig(textMorph);
            return getMode(config, {
              name: "javascript",
              json: true
            });
          }
        }, {
          key: "getCompleters",
          value: function JSONEditorPlugin_getCompleters_(otherCompleters) {
            return [].concat(_toConsumableArray$1(initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "getCompleters", this).call(this, otherCompleters)), [new PackageJSONCompleter()]);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "JSONEditorPlugin";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./json/editor-plugin.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 255,
          end: 1587
        });
      }({
        referencedAs: "JavaScriptEditorPlugin",
        value: JavaScriptEditorPlugin
      });
      __varRecorder__$I["default"] = JSONEditorPlugin;

      var __varRecorder__$H = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/xml/mode.js", __contextModule__);
      __varRecorder__$H.defaultConfig = {
        indentUnit: 2
      };
      __varRecorder__$H.htmlConfig = {
        autoSelfClosers: {
          area: true,
          base: true,
          br: true,
          col: true,
          command: true,
          embed: true,
          frame: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true,
          menuitem: true
        },
        implicitlyClosed: {
          dd: true,
          li: true,
          optgroup: true,
          option: true,
          p: true,
          rp: true,
          rt: true,
          tbody: true,
          td: true,
          tfoot: true,
          th: true,
          tr: true
        },
        contextGrabbers: {
          dd: {
            dd: true,
            dt: true
          },
          dt: {
            dd: true,
            dt: true
          },
          li: {
            li: true
          },
          option: {
            option: true,
            optgroup: true
          },
          optgroup: {
            optgroup: true
          },
          p: {
            address: true,
            article: true,
            aside: true,
            blockquote: true,
            dir: true,
            div: true,
            dl: true,
            fieldset: true,
            footer: true,
            form: true,
            h1: true,
            h2: true,
            h3: true,
            h4: true,
            h5: true,
            h6: true,
            header: true,
            hgroup: true,
            hr: true,
            menu: true,
            nav: true,
            ol: true,
            p: true,
            pre: true,
            section: true,
            table: true,
            ul: true
          },
          rp: {
            rp: true,
            rt: true
          },
          rt: {
            rp: true,
            rt: true
          },
          tbody: {
            tbody: true,
            tfoot: true
          },
          td: {
            td: true,
            th: true
          },
          tfoot: {
            tbody: true
          },
          th: {
            td: true,
            th: true
          },
          thead: {
            tbody: true,
            tfoot: true
          },
          tr: {
            tr: true
          }
        },
        doNotIndent: {
          pre: true
        },
        allowUnquoted: true,
        allowMissing: true,
        caseFold: true
      };
      __varRecorder__$H.xmlConfig = {
        autoSelfClosers: {},
        implicitlyClosed: {},
        contextGrabbers: {},
        doNotIndent: {},
        allowUnquoted: false,
        allowMissing: false,
        caseFold: false
      };
      defineMode("xml", function createMode(editorConf, config_) {
        var _Object$assign = Object.assign({}, __varRecorder__$H.defaultConfig, {}, editorConf),
            indentUnit = _Object$assign.indentUnit;

        var config = {};
        var defaults = config_.htmlMode ? __varRecorder__$H.htmlConfig : __varRecorder__$H.xmlConfig;

        for (var prop in defaults) {
          config[prop] = defaults[prop];
        }

        for (var prop in config_) {
          config[prop] = config_[prop];
        }

        var type, setStyle;

        function inText(stream, state) {
          function chain(parser) {
            state.tokenize = parser;
            return parser(stream, state);
          }

          var ch = stream.next();

          if (ch == "<") {
            if (stream.eat("!")) {
              if (stream.eat("[")) {
                if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));else return null;
              } else if (stream.match("--")) {
                return chain(inBlock("comment", "-->"));
              } else if (stream.match("DOCTYPE", true, true)) {
                stream.eatWhile(/[\w\._\-]/);
                return chain(doctype(1));
              } else {
                return null;
              }
            } else if (stream.eat("?")) {
              stream.eatWhile(/[\w\._\-]/);
              state.tokenize = inBlock("meta", "?>");
              return "meta";
            } else {
              type = stream.eat("/") ? "closeTag" : "openTag";
              state.tokenize = inTag;
              return "tag bracket";
            }
          } else if (ch == "&") {
            var ok;

            if (stream.eat("#")) {
              if (stream.eat("x")) {
                ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
              } else {
                ok = stream.eatWhile(/[\d]/) && stream.eat(";");
              }
            } else {
              ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
            }

            return ok ? "atom" : "error";
          } else {
            stream.eatWhile(/[^&<]/);
            return null;
          }
        }

        inText.isInText = true;

        function inTag(stream, state) {
          var ch = stream.next();

          if (ch == ">" || ch == "/" && stream.eat(">")) {
            state.tokenize = inText;
            type = ch == ">" ? "endTag" : "selfcloseTag";
            return "tag bracket";
          } else if (ch == "=") {
            type = "equals";
            return null;
          } else if (ch == "<") {
            state.tokenize = inText;
            state.state = baseState;
            state.tagName = state.tagStart = null;
            var next = state.tokenize(stream, state);
            return next ? next + " tag error" : "tag error";
          } else if (/[\'\"]/.test(ch)) {
            state.tokenize = inAttribute(ch);
            state.stringStartCol = stream.column();
            return state.tokenize(stream, state);
          } else {
            stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
            return "word";
          }
        }

        function inAttribute(quote) {
          var closure = function closure(stream, state) {
            while (!stream.eol()) {
              if (stream.next() == quote) {
                state.tokenize = inTag;
                break;
              }
            }

            return "string";
          };

          closure.isInAttribute = true;
          return closure;
        }

        function inBlock(style, terminator) {
          return function (stream, state) {
            while (!stream.eol()) {
              if (stream.match(terminator)) {
                state.tokenize = inText;
                break;
              }

              stream.next();
            }

            return style;
          };
        }

        function doctype(depth) {
          return function (stream, state) {
            var ch;

            while ((ch = stream.next()) != null) {
              if (ch == "<") {
                state.tokenize = doctype(depth + 1);
                return state.tokenize(stream, state);
              } else if (ch == ">") {
                if (depth == 1) {
                  state.tokenize = inText;
                  break;
                } else {
                  state.tokenize = doctype(depth - 1);
                  return state.tokenize(stream, state);
                }
              }
            }

            return "meta";
          };
        }

        function Context(state, tagName, startOfLine) {
          this.prev = state.context;
          this.tagName = tagName;
          this.indent = state.indented;
          this.startOfLine = startOfLine;

          if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) {
            this.noIndent = true;
          }
        }

        function popContext(state) {
          if (state.context) state.context = state.context.prev;
        }

        function maybePopContext(state, nextTagName) {
          var parentTagName;

          while (true) {
            if (!state.context) {
              return;
            }

            parentTagName = state.context.tagName;

            if (!config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
              return;
            }

            popContext(state);
          }
        }

        function baseState(type, stream, state) {
          if (type == "openTag") {
            state.tagStart = stream.column();
            return tagNameState;
          } else if (type == "closeTag") {
            return closeTagNameState;
          } else {
            return baseState;
          }
        }

        function tagNameState(type, stream, state) {
          if (type == "word") {
            state.tagName = stream.current();
            setStyle = "tag";
            return attrState;
          } else {
            setStyle = "error";
            return tagNameState;
          }
        }

        function closeTagNameState(type, stream, state) {
          if (type == "word") {
            var tagName = stream.current();

            if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName)) {
              popContext(state);
            }

            if (state.context && state.context.tagName == tagName || config.matchClosing === false) {
              setStyle = "tag";
              return closeState;
            } else {
              setStyle = "tag error";
              return closeStateErr;
            }
          } else {
            setStyle = "error";
            return closeStateErr;
          }
        }

        function closeState(type, _stream, state) {
          if (type != "endTag") {
            setStyle = "error";
            return closeState;
          }

          popContext(state);
          return baseState;
        }

        function closeStateErr(type, stream, state) {
          setStyle = "error";
          return closeState(type, stream, state);
        }

        function attrState(type, _stream, state) {
          if (type == "word") {
            setStyle = "attribute";
            return attrEqState;
          } else if (type == "endTag" || type == "selfcloseTag") {
            var tagName = state.tagName;
            var tagStart = state.tagStart;
            state.tagName = state.tagStart = null;

            if (type == "selfcloseTag" || config.autoSelfClosers.hasOwnProperty(tagName)) {
              maybePopContext(state, tagName);
            } else {
              maybePopContext(state, tagName);
              state.context = new Context(state, tagName, tagStart == state.indented);
            }

            return baseState;
          }

          setStyle = "error";
          return attrState;
        }

        function attrEqState(type, stream, state) {
          if (type == "equals") return attrValueState;
          if (!config.allowMissing) setStyle = "error";
          return attrState(type, stream, state);
        }

        function attrValueState(type, stream, state) {
          if (type == "string") return attrContinuedState;

          if (type == "word" && config.allowUnquoted) {
            setStyle = "string";
            return attrState;
          }

          setStyle = "error";
          return attrState(type, stream, state);
        }

        function attrContinuedState(type, stream, state) {
          if (type == "string") return attrContinuedState;
          return attrState(type, stream, state);
        }

        return {
          startState: function startState(baseIndent) {
            var state = {
              tokenize: inText,
              state: baseState,
              indented: baseIndent || 0,
              tagName: null,
              tagStart: null,
              context: null
            };
            if (baseIndent != null) state.baseIndent = baseIndent;
            return state;
          },
          token: function token(stream, state) {
            if (!state.tagName && stream.sol()) {
              state.indented = stream.indentation();
            }

            if (stream.eatSpace()) return null;
            type = null;
            var style = state.tokenize(stream, state);

            if ((style || type) && style != "comment") {
              setStyle = null;
              state.state = state.state(type || style, stream, state);

              if (setStyle) {
                style = setStyle == "error" ? style + " error" : setStyle;
              }
            }

            return style;
          },
          indent: function indent(state, textAfter, fullLine) {
            var context = state.context;

            if (state.tokenize.isInAttribute) {
              if (state.tagStart == state.indented) {
                return state.stringStartCol + 1;
              } else {
                return state.indented + indentUnit;
              }
            }

            if (context && context.noIndent) return passIndent;

            if (state.tokenize != inTag && state.tokenize != inText) {
              return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
            }

            if (state.tagName) {
              if (config.multilineTagIndentPastTag !== false) {
                return state.tagStart + state.tagName.length + 2;
              } else {
                return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
              }
            }

            if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
            var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);

            if (tagAfter && tagAfter[1]) {
              while (context) {
                if (context.tagName == tagAfter[2]) {
                  context = context.prev;
                  break;
                } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
                  context = context.prev;
                } else {
                  break;
                }
              }
            } else if (tagAfter) {
              while (context) {
                var grabbers = config.contextGrabbers[context.tagName];

                if (grabbers && grabbers.hasOwnProperty(tagAfter[2])) {
                  context = context.prev;
                } else {
                  break;
                }
              }
            }

            while (context && context.prev && !context.startOfLine) {
              context = context.prev;
            }

            if (context) return context.indent + indentUnit;else return state.baseIndent || 0;
          },
          electricInput: /<\/[\s\w:]+>$/,
          blockCommentStart: "<!--",
          blockCommentEnd: "-->",
          configuration: config.htmlMode ? "html" : "xml",
          helperType: config.htmlMode ? "html" : "xml",
          skipAttribute: function skipAttribute(state) {
            if (state.state == attrValueState) {
              state.state = attrState;
            }
          }
        };
      });
      defineMIME("text/xml", "xml");
      defineMIME("application/xml", "xml");

      if (!mimeModes.hasOwnProperty("text/html")) {
        defineMIME("text/html", {
          name: "xml",
          htmlMode: true
        });
      }

      var __varRecorder__$G = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/jsx/mode.js", __contextModule__);
      var __moduleMeta__$m = {
        pathInPackage: function pathInPackage() {
          return "./jsx/mode.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var Context = __varRecorder__$G["lively.ide/jsx/mode.js__define__"]("Context", "function", function (state, mode, depth, prev) {
        this.state = state;
        this.mode = mode;
        this.depth = depth;
        this.prev = prev;
      }, __moduleMeta__$m);

      __varRecorder__$G.Context = Context;

      var copyContext = __varRecorder__$G["lively.ide/jsx/mode.js__define__"]("copyContext", "function", function (context) {
        return new __varRecorder__$G.Context(copyState(context.mode, context.state), context.mode, context.depth, context.prev && copyContext(context.prev));
      }, __moduleMeta__$m);

      __varRecorder__$G.copyContext = copyContext;
      defineMode("jsx", function (config, parserConfig) {
        var xmlMode = getMode(config, {
          name: "xml",
          allowMissing: true,
          multilineTagIndentPastTag: false,
          allowMissingTagName: true
        });
        var jsMode = getMode(config, "javascript");

        function flatXMLIndent(state) {
          var tagName = state.tagName;
          state.tagName = null;
          var result = xmlMode.indent(state, "", "");
          state.tagName = tagName;
          return result;
        }

        function token(stream, state) {
          if (state.context.mode == xmlMode) {
            return xmlToken(stream, state, state.context);
          } else {
            return jsToken(stream, state, state.context);
          }
        }

        function xmlToken(stream, state, cx) {
          if (cx.depth == 2) {
            if (stream.match(/^.*?\*\//)) cx.depth = 1;else stream.skipToEnd();
            return "comment";
          }

          if (stream.peek() == "{") {
            xmlMode.skipAttribute(cx.state);
            var indent = flatXMLIndent(cx.state);
            var xmlContext = cx.state.context;

            if (xmlContext && stream.match(/^[^>]*>\s*$/, false)) {
              while (xmlContext.prev && !xmlContext.startOfLine) {
                xmlContext = xmlContext.prev;
              }

              if (xmlContext.startOfLine) indent -= config.indentUnit;else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented;
            } else if (cx.depth == 1) {
              indent += config.indentUnit;
            }

            state.context = new __varRecorder__$G.Context(startState(jsMode, indent), jsMode, 0, state.context);
            return null;
          }

          if (cx.depth == 1) {
            if (stream.peek() == "<") {
              xmlMode.skipAttribute(cx.state);
              state.context = new __varRecorder__$G.Context(startState(xmlMode, flatXMLIndent(cx.state)), xmlMode, 0, state.context);
              return null;
            } else if (stream.match("//")) {
              stream.skipToEnd();
              return "comment";
            } else if (stream.match("/*")) {
              cx.depth = 2;
              return token(stream, state);
            }
          }

          var style = xmlMode.token(stream, cx.state);
          var cur = stream.current();
          var stop;

          if (/\btag\b/.test(style)) {
            if (/>$/.test(cur)) {
              if (cx.state.context) cx.depth = 0;else state.context = state.context.prev;
            } else if (/^</.test(cur)) {
              cx.depth = 1;
            }
          } else if (!style && (stop = cur.indexOf("{")) > -1) {
            stream.backUp(cur.length - stop);
          }

          return style;
        }

        function jsToken(stream, state, cx) {
          if (stream.peek() == "<" && jsMode.expressionAllowed(stream, cx.state)) {
            jsMode.skipExpression(cx.state);
            state.context = new __varRecorder__$G.Context(startState(xmlMode, jsMode.indent(cx.state, "", "")), xmlMode, 0, state.context);
            return null;
          }

          var style = jsMode.token(stream, cx.state);

          if (!style && cx.depth != null) {
            var cur = stream.current();

            if (cur == "{") {
              cx.depth++;
            } else if (cur == "}") {
              if (--cx.depth == 0) state.context = state.context.prev;
            }
          }

          return style;
        }

        return {
          startState: function startState$1() {
            return {
              context: new __varRecorder__$G.Context(startState(jsMode), jsMode)
            };
          },
          copyState: function copyState(state) {
            return {
              context: __varRecorder__$G.copyContext(state.context)
            };
          },
          token: token,
          indent: function indent(state, textAfter, fullLine) {
            return state.context.mode.indent(state.context.state, textAfter, fullLine);
          },
          innerMode: function innerMode(state) {
            return state.context;
          }
        };
      }, "xml", "javascript");
      defineMIME("text/jsx", "jsx");
      defineMIME("text/typescript-jsx", {
        name: "jsx",
        base: {
          name: "javascript",
          typescript: true
        }
      });

      var __varRecorder__$F = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/jsx/editor-plugin.js", __contextModule__);

      var JSXEditorPlugin = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/jsx/editor-plugin.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("JSXEditorPlugin") && typeof __lively_classholder__.JSXEditorPlugin === "function" ? __lively_classholder__.JSXEditorPlugin : __lively_classholder__.JSXEditorPlugin = function JSXEditorPlugin(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "shortName",
          get: function get() {
            return "jsx";
          }
        }, {
          key: "longName",
          get: function get() {
            return "jsx";
          }
        }, {
          key: "runEval",
          value: function JSXEditorPlugin_runEval_(code, opts) {
            var env = this.sanatizedJsEnv(opts);
            var endpoint = this.systemInterface(env);
            return endpoint.runEval(es5Transpilation(code), Object.assign({}, env, {
              format: "es6"
            }));
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "JSXEditorPlugin";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./jsx/editor-plugin.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 184,
          end: 545
        });
      }({
        referencedAs: "JavaScriptEditorPlugin",
        value: JavaScriptEditorPlugin
      });
      __varRecorder__$F["default"] = JSXEditorPlugin;

      var __varRecorder__$E = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.freezer/src/ui.cp.js", __contextModule__);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.freezer/src/ui.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PackageTextCompleter") && typeof __lively_classholder__.PackageTextCompleter === "function" ? __lively_classholder__.PackageTextCompleter : __lively_classholder__.PackageTextCompleter = function PackageTextCompleter(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "isValidPrefix",
          value: function PackageTextCompleter_isValidPrefix_(prefix) {
            return !!prefix;
          }
        }, {
          key: "compute",
          value: function () {
            var _PackageTextCompleter_compute_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(inputMorph, prefix) {
              var pkgs;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      pkgs = PackageRegistry.ofSystem(System).allPackages();
                      return _context.abrupt("return", pkgs.map(function (pkg) {
                        var name = pkg.name,
                            version = pkg.version;
                        return {
                          info: "@".concat(version),
                          completion: name,
                          customInsertionFn: function customInsertionFn(complString, prefix, inputMorph, _ref) {
                            _ref.start;
                                _ref.end;
                            inputMorph.replace(inputMorph.lineRange(), name);
                          }
                        };
                      }));

                    case 2:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));

            function PackageTextCompleter_compute_(_x, _x2) {
              return _PackageTextCompleter_compute_.apply(this, arguments);
            }

            return PackageTextCompleter_compute_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PackageTextCompleter";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./src/ui.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.freezer",
              version: "0.1.0"
            };
          }
        }, {
          start: 758,
          end: 1251
        });
      })(undefined);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.freezer/src/ui.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DirectoryTextCompleter") && typeof __lively_classholder__.DirectoryTextCompleter === "function" ? __lively_classholder__.DirectoryTextCompleter : __lively_classholder__.DirectoryTextCompleter = function DirectoryTextCompleter(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "isValidPrefix",
          value: function DirectoryTextCompleter_isValidPrefix_(prefix) {
            return !!prefix;
          }
        }, {
          key: "compute",
          value: function () {
            var _DirectoryTextCompleter_compute_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(inputMorph, prefix) {
              var input, res, files;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      input = inputMorph.input;
                      input = prefix ? input.slice(0, -prefix.length) : input;
                      res = resource(System.baseURL + input);
                      files = [];
                      _context2.next = 6;
                      return res.exists();

                    case 6:
                      if (!_context2.sent) {
                        _context2.next = 10;
                        break;
                      }

                      _context2.next = 9;
                      return res.dirList();

                    case 9:
                      files = _context2.sent;

                    case 10:
                      return _context2.abrupt("return", files.map(function (file) {
                        var url = file.url;
                        return {
                          completion: url.replace(res.url, ""),
                          customInsertionFn: function customInsertionFn(complString, prefix, inputMorph, _ref2) {
                            _ref2.start;
                                _ref2.end;
                            inputMorph.replace(inputMorph.lineRange(), url.replace(System.baseURL, "/"));
                          }
                        };
                      }));

                    case 11:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }));

            function DirectoryTextCompleter_compute_(_x3, _x4) {
              return _DirectoryTextCompleter_compute_.apply(this, arguments);
            }

            return DirectoryTextCompleter_compute_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DirectoryTextCompleter";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./src/ui.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.freezer",
              version: "0.1.0"
            };
          }
        }, {
          start: 1253,
          end: 1964
        });
      })(undefined);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.freezer/src/ui.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DirectoryInputPlugin") && typeof __lively_classholder__.DirectoryInputPlugin === "function" ? __lively_classholder__.DirectoryInputPlugin : __lively_classholder__.DirectoryInputPlugin = function DirectoryInputPlugin(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "getCompleters",
          value: function DirectoryInputPlugin_getCompleters_() {
            return [new __varRecorder__$E.DirectoryTextCompleter()];
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DirectoryInputPlugin";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./src/ui.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.freezer",
              version: "0.1.0"
            };
          }
        }, {
          start: 1966,
          end: 2085
        });
      })({
        referencedAs: "EditorPlugin",
        value: EditorPlugin
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.freezer/src/ui.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PackageInputPlugin") && typeof __lively_classholder__.PackageInputPlugin === "function" ? __lively_classholder__.PackageInputPlugin : __lively_classholder__.PackageInputPlugin = function PackageInputPlugin(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "getCompleters",
          value: function PackageInputPlugin_getCompleters_() {
            return [new __varRecorder__$E.PackageTextCompleter()];
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PackageInputPlugin";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./src/ui.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.freezer",
              version: "0.1.0"
            };
          }
        }, {
          start: 2087,
          end: 2202
        });
      })({
        referencedAs: "EditorPlugin",
        value: EditorPlugin
      });

      var FreezerPromptModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.freezer/src/ui.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("FreezerPromptModel") && typeof __lively_classholder__.FreezerPromptModel === "function" ? __lively_classholder__.FreezerPromptModel : __lively_classholder__.FreezerPromptModel = function FreezerPromptModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "cancel",
          value: function FreezerPromptModel_cancel_() {
            this.view.remove();
            this.reject();
          }
        }, {
          key: "focus",
          value: function FreezerPromptModel_focus_() {
            this.ui.compilerSelector.selection = "Google Closure";
            this.ui.dirInput.focus();
          }
        }, {
          key: "resolve",
          value: function FreezerPromptModel_resolve_() {
            var _this$ui = this.ui;
                _this$ui.dirInput;
                _this$ui.packageList;
                var compilerSelector = _this$ui.compilerSelector;
            return initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "resolve", this).call(this, {
              location: this.directory,
              minify: compilerSelector.selection !== "None",
              useTerser: compilerSelector.selection == "Terser + Babel",
              excludedPackages: this.excludedPackages
            });
          }
        }, {
          key: "checkDirStatus",
          value: function () {
            var _FreezerPromptModel_checkDirStatus_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
              var _this = this;

              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      debounceNamed("checkDirStatus", 500, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                        var _this$ui2, dirWarning, dirInput;

                        return regeneratorRuntime.wrap(function _callee3$(_context3) {
                          while (1) {
                            switch (_context3.prev = _context3.next) {
                              case 0:
                                _this$ui2 = _this.ui, dirWarning = _this$ui2.dirWarning, dirInput = _this$ui2.dirInput;
                                _context3.t0 = !!_this.directory;

                                if (!_context3.t0) {
                                  _context3.next = 6;
                                  break;
                                }

                                _context3.next = 5;
                                return resource(System.baseURL).join(_this.directory).exists();

                              case 5:
                                _context3.t0 = _context3.sent;

                              case 6:
                                if (!_context3.t0) {
                                  _context3.next = 12;
                                  break;
                                }

                                dirWarning.textAndAttributes = [].concat(_toConsumableArray$1(Icon.textAttribute("exclamation-circle")), ["  Directory will be overwritten.", {
                                  fontFamily: "IBM Plex Sans",
                                  fontWeight: "600"
                                }]);
                                dirWarning.fontColor = Color.rgb(231, 76, 60);
                                !dirWarning.visible && dirWarning.animate({
                                  visible: true,
                                  isLayoutable: true,
                                  top: dirInput.bottom,
                                  duration: 200,
                                  easing: easings.inOutExpo
                                });
                                _context3.next = 13;
                                break;

                              case 12:
                                dirWarning.animate({
                                  isLayoutable: false,
                                  visible: false,
                                  duration: 200,
                                  easing: easings.inOutExpo
                                });

                              case 13:
                              case "end":
                                return _context3.stop();
                            }
                          }
                        }, _callee3);
                      })))();

                    case 1:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            }));

            function FreezerPromptModel_checkDirStatus_() {
              return _FreezerPromptModel_checkDirStatus_.apply(this, arguments);
            }

            return FreezerPromptModel_checkDirStatus_;
          }()
        }, {
          key: "addExcludedPackage",
          value: function FreezerPromptModel_addExcludedPackage_() {
            this.displayPackageInput(true);
          }
        }, {
          key: "removeExcludedPackage",
          value: function FreezerPromptModel_removeExcludedPackage_() {
            var packageList = this.ui.packageList;
            packageList.removeItem(packageList.selectedItems[0]);
          }
        }, {
          key: "confirmExcludedPackage",
          value: function () {
            var _FreezerPromptModel_confirmExcludedPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      this.ui.packageList.addItem(this.ui.packageInput.input);
                      _context5.next = 3;
                      return this.displayPackageInput(false);

                    case 3:
                      this.ui.packageInput.input = "";

                    case 4:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function FreezerPromptModel_confirmExcludedPackage_() {
              return _FreezerPromptModel_confirmExcludedPackage_.apply(this, arguments);
            }

            return FreezerPromptModel_confirmExcludedPackage_;
          }()
        }, {
          key: "verifyPackageName",
          value: function FreezerPromptModel_verifyPackageName_(pkgName) {
            return PackageRegistry.ofSystem(System).allPackages().find(function (pkg) {
              return pkg.name == pkgName;
            });
          }
        }, {
          key: "onMouseUp",
          value: function FreezerPromptModel_onMouseUp_(evt) {
            var _this$ui3 = this.ui;
                _this$ui3.packageInput;
                _this$ui3.addPackageButton;
                _this$ui3.removePackageButton;
                _this$ui3.confirmPackageButton;
                _this$ui3.packageList;
            this.ui.removePackageButton.deactivated = !this.ui.packageList.selections.length;
          }
        }, {
          key: "displayPackageInput",
          value: function () {
            var _FreezerPromptModel_displayPackageInput_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(show) {
              var _this$ui4, packageInput, packageList, confirmPackageButton, duration;

              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      _this$ui4 = this.ui, packageInput = _this$ui4.packageInput, packageList = _this$ui4.packageList, confirmPackageButton = _this$ui4.confirmPackageButton;
                      duration = 200;

                      if (!show) {
                        _context6.next = 8;
                        break;
                      }

                      packageInput.animate({
                        visible: true,
                        top: packageList.bottom + 10,
                        duration: duration
                      });
                      _context6.next = 6;
                      return confirmPackageButton.animate({
                        visible: true,
                        top: packageList.bottom + 15,
                        duration: duration
                      });

                    case 6:
                      _context6.next = 11;
                      break;

                    case 8:
                      confirmPackageButton.animate({
                        visible: false,
                        bottom: packageList.bottom - 5,
                        duration: duration
                      });
                      _context6.next = 11;
                      return packageInput.animate({
                        visible: false,
                        bottom: packageList.bottom,
                        duration: duration
                      });

                    case 11:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function FreezerPromptModel_displayPackageInput_(_x5) {
              return _FreezerPromptModel_displayPackageInput_.apply(this, arguments);
            }

            return FreezerPromptModel_displayPackageInput_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "FreezerPromptModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              title: {
                defaultValue: "Freeze Part"
              },
              directory: {
                derived: true,
                set: function set(url) {
                  this.ui.dirInput.input = url.replace(System.baseURL, "/");
                },
                get: function get() {
                  return this.ui.dirInput.input;
                }
              },
              isModuleBundle: {
                defaultValue: true
              },
              excludedPackages: {
                derived: true,
                set: function set(packageNames) {
                  this.ui.packageList.items = packageNames;
                },
                get: function get() {
                  return this.ui.packageList.items.map(function (m) {
                    return m.value;
                  });
                }
              },
              expose: {
                get: function get() {
                  return [].concat(_toConsumableArray$1(initializeClass._get(Object.getPrototypeOf(__lively_class__), "prototype", this).expose), ["excludedPackages", "directory", "isModuleBundle"]);
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    signal: "onMouseDown",
                    handler: "onMouseDown"
                  }, {
                    model: "add package button",
                    signal: "fire",
                    handler: "addExcludedPackage"
                  }, {
                    model: "remove package button",
                    signal: "fire",
                    handler: "removeExcludedPackage"
                  }, {
                    model: "confirm excluded package",
                    signal: "fire",
                    handler: "confirmExcludedPackage"
                  }, {
                    model: "cancel button",
                    signal: "fire",
                    handler: "cancel"
                  }, {
                    model: "ok button",
                    signal: "fire",
                    handler: "resolve"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./src/ui.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.freezer",
              version: "0.1.0"
            };
          }
        }, {
          start: 2219,
          end: 6521
        });
      }({
        referencedAs: "AbstractPromptModel",
        value: AbstractPromptModel
      });
      __varRecorder__$E.FreezerPrompt = component["for"](function () {
        return component(LightPrompt, {
          defaultViewModel: __varRecorder__$E.FreezerPromptModel,
          name: "freezer prompt",
          extent: pt(481, 440.8),
          clipMode: "hidden",
          layout: new TilingLayout({
            axis: "column",
            hugContentsVertically: true,
            orderByIndex: true,
            padding: rect(16, 16, 0, 0),
            resizePolicies: [["prompt title", {
              height: "fixed",
              width: "fill"
            }], ["dir input", {
              height: "fixed",
              width: "fill"
            }], ["compiler explanation", {
              height: "fixed",
              width: "fill"
            }], ["exclusion explanation", {
              height: "fixed",
              width: "fill"
            }], ["layout wrapper", {
              height: "fixed",
              width: "fill"
            }], ["button wrapper", {
              height: "fixed",
              width: "fill"
            }]],
            spacing: 16
          }),
          position: pt(960.8, 161.4),
          submorphs: [{
            name: "prompt title",
            textAndAttributes: ["Freeze Part", null]
          }, add({
            type: Label,
            name: "dir label",
            fill: Color.rgba(255, 255, 255, 0),
            fontColor: Color.rgb(45, 45, 45),
            fontSize: 16,
            fontWeight: "500",
            nativeCursor: "pointer",
            textAndAttributes: ["Directory to write files to:", null]
          }), add(part(InputLineDefault, {
            name: "dir input",
            placeholder: "Directory",
            submorphs: [{
              name: "placeholder",
              extent: pt(103, 34.3),
              textAndAttributes: ["Directory", null]
            }]
          })), add({
            type: Text,
            name: "dir warning",
            borderColor: Color.rgb(204, 204, 204),
            borderRadius: 3,
            extent: pt(451.3, 17.2),
            fill: Color.rgba(255, 255, 255, 0),
            fixedWidth: true,
            fontColor: Color.rgb(231, 76, 60),
            fontFamily: "IBM Plex Sans",
            isLayoutable: false,
            lineWrapping: "by-words",
            nativeCursor: "default",
            readOnly: true,
            textAlign: "left",
            visible: false
          }), add({
            type: Text,
            name: "compiler explanation",
            borderColor: Color.rgb(204, 204, 204),
            borderRadius: 3,
            extent: pt(449, 109),
            fill: Color.rgba(255, 255, 255, 0),
            fixedWidth: true,
            fontColor: Color.rgb(102, 102, 102),
            fontFamily: "IBM Plex Sans",
            lineWrapping: "by-words",
            nativeCursor: "default",
            readOnly: true,
            textAlign: "left",
            textAndAttributes: ["Compression:", {
              textAlign: "left",
              fontSize: 16,
              fontColor: Color.rgb(45, 45, 45)
            }, " ", {
              textAlign: "left",
              fontSize: 16
            }, " ", {
              textAlign: "left"
            }, part(DropDownList, {
              name: "compiler selector",
              extent: pt(127.3, 25.9),
              position: pt(104.4, 0),
              viewModel: {
                selection: "Google Closure",
                items: ["Google Closure", "Terser + Babel", "None"],
                listAlign: "selection",
                listMaster: SystemList,
                openListInWorld: true
              }
            }), {
              textAlign: "left"
            }, "   \n", {
              fontSize: 5
            }, "\nSelect the compiler to be used to compress the resulting bundle. Generally speaking Google Closure will yield smaller bundles but may break some parts of your bundle due to aggressive optimization. Terser + Babel is less aggressive but may fail with very large bundles > 10MB.", null]
          }), add({
            type: Label,
            name: "excluded package label",
            fill: Color.rgba(255, 255, 255, 0),
            fontColor: Color.rgb(45, 45, 45),
            fontSize: 16,
            fontWeight: "500",
            nativeCursor: "pointer",
            textAndAttributes: ["Packages to exclude from bundle:", null]
          }), add({
            type: "text",
            name: "exclusion explanation",
            borderColor: Color.rgb(204, 204, 204),
            borderRadius: 3,
            extent: pt(449, 67),
            fill: Color.rgba(255, 255, 255, 0),
            fixedWidth: true,
            fontColor: Color.rgb(102, 102, 102),
            fontFamily: "IBM Plex Sans",
            lineWrapping: "by-words",
            textAndAttributes: ["Excluding packages from the bundle of the frozen part can reduce the total payload and its loading time ", null, "dramatically", {
              fontWeight: "bold"
            }, ". This however needs to be done with care. Make sure that none of your functionality depends of these excluded packages. If you do not know what you are doing it is best to leave this list as is.", {
              textAlign: "left"
            }],
            nativeCursor: "default",
            textAlign: "center"
          }), add({
            name: "layout wrapper",
            extent: pt(450, 155),
            fill: Color.rgba(46, 75, 223, 0),
            layout: new ConstraintLayout({
              lastExtent: pt(450, 155),
              submorphSettings: [["package list", {
                x: "resize",
                y: "resize"
              }], ["add package button", {
                x: "move",
                y: "move"
              }], ["remove package button", {
                x: "move",
                y: "move"
              }], ["package input", {
                x: "resize",
                y: "fixed"
              }]]
            }),
            submorphs: [part(InputLineDefault, {
              name: "package input",
              borderColor: Color.rgb(204, 204, 204),
              borderRadius: 4,
              extent: pt(445, 32),
              highlightWhenFocused: true,
              padding: rect(10, 3, 0, 0),
              placeholder: "Excluded package name",
              position: pt(0, 120),
              visible: false,
              submorphs: [{
                name: "placeholder",
                extent: pt(237, 32),
                textAndAttributes: ["Excluded package name", null]
              }]
            }), part(DarkButton, {
              name: "confirm excluded package",
              extent: pt(25, 21.9),
              viewModel: {
                label: Icon.textAttribute("check")
              },
              position: pt(0, 126.1),
              tooltip: "add a new method",
              visible: false
            }), part(DefaultList, {
              name: "package list",
              borderRadius: 4,
              dropShadow: new ShadowObject({
                distance: 3,
                rotation: 75,
                color: Color.rgba(0, 0, 0, 0.2)
              }),
              extent: pt(442.4, 148.6),
              fontFamily: "IBM Plex Sans",
              fontSize: 20,
              itemHeight: 29,
              manualItemHeight: true,
              position: pt(2.8, 4.5)
            }), part(DarkButton, {
              name: "add package button",
              extent: pt(25, 25),
              position: pt(383.1, 125.2),
              tooltip: "add a new method",
              submorphs: [{
                name: "label",
                value: Icon.textAttribute("plus")
              }]
            }), part(DarkButton, {
              name: "remove package button",
              extent: pt(25, 25),
              position: pt(414, 125),
              tooltip: "remove a method or class",
              submorphs: [{
                name: "label",
                value: Icon.textAttribute("minus")
              }]
            })]
          }), add({
            name: "button wrapper",
            extent: pt(449, 48.9),
            fill: Color.rgba(0, 0, 0, 0),
            layout: new TilingLayout({
              align: "center",
              axis: "row",
              axisAlign: "center",
              orderByIndex: true,
              padding: {
                height: 0,
                width: 0,
                x: 20,
                y: 20
              },
              reactToSubmorphAnimations: false,
              renderViaCSS: true,
              spacing: 20
            }),
            submorphs: [part(GreenButton, {
              name: "ok button",
              extent: pt(90, 39),
              label: "OK"
            }), part(RedButton, {
              name: "cancel button",
              extent: pt(94, 39),
              label: "CANCEL"
            })]
          })]
        });
      }, {
        module: "lively.freezer/src/ui.cp.js",
        "export": "FreezerPrompt",
        range: {
          start: 6529,
          end: 13347
        }
      }, System, __varRecorder__$E, "FreezerPrompt");
      var FreezerPrompt = __varRecorder__$E.FreezerPrompt;
      __varRecorder__$E.FreezerPrompt = FreezerPrompt;
      __varRecorder__$E["default"] = FreezerPromptModel;

      const __varRecorder__$D = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.freezer/src/util/eval.cjs", __contextModule__);
      __varRecorder__$D._eval = function runEval(code) {
        return eval(code);
      };
      var _eval = __varRecorder__$D._eval;
      var runEval = _eval;
      var _eval = __varRecorder__$D._eval;
      __varRecorder__$D._eval = _eval;
      __varRecorder__$D.default = _eval;

      var global$1 = (typeof global !== "undefined" ? global :
        typeof self !== "undefined" ? self :
        typeof window !== "undefined" ? window : {});

      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
      var inited = false;
      function init () {
        inited = true;
        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }

        revLookup['-'.charCodeAt(0)] = 62;
        revLookup['_'.charCodeAt(0)] = 63;
      }

      function toByteArray (b64) {
        if (!inited) {
          init();
        }
        var i, j, l, tmp, placeHolders, arr;
        var len = b64.length;

        if (len % 4 > 0) {
          throw new Error('Invalid string. Length must be a multiple of 4')
        }

        // the number of equal signs (place holders)
        // if there are two placeholders, than the two characters before it
        // represent one byte
        // if there is only one, then the three characters before it represent 2 bytes
        // this is just a cheap hack to not do indexOf twice
        placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

        // base64 is 4/3 + up to two characters of the original data
        arr = new Arr(len * 3 / 4 - placeHolders);

        // if there are placeholders, only get up to the last complete 4 chars
        l = placeHolders > 0 ? len - 4 : len;

        var L = 0;

        for (i = 0, j = 0; i < l; i += 4, j += 3) {
          tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
          arr[L++] = (tmp >> 16) & 0xFF;
          arr[L++] = (tmp >> 8) & 0xFF;
          arr[L++] = tmp & 0xFF;
        }

        if (placeHolders === 2) {
          tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
          arr[L++] = tmp & 0xFF;
        } else if (placeHolders === 1) {
          tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
          arr[L++] = (tmp >> 8) & 0xFF;
          arr[L++] = tmp & 0xFF;
        }

        return arr
      }

      function tripletToBase64 (num) {
        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
      }

      function encodeChunk (uint8, start, end) {
        var tmp;
        var output = [];
        for (var i = start; i < end; i += 3) {
          tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
          output.push(tripletToBase64(tmp));
        }
        return output.join('')
      }

      function fromByteArray (uint8) {
        if (!inited) {
          init();
        }
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
        var output = '';
        var parts = [];
        var maxChunkLength = 16383; // must be multiple of 3

        // go through the array every three bytes, we'll deal with trailing stuff later
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
        }

        // pad the end with zeros, but make sure to not forget the extra bytes
        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          output += lookup[tmp >> 2];
          output += lookup[(tmp << 4) & 0x3F];
          output += '==';
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
          output += lookup[tmp >> 10];
          output += lookup[(tmp >> 4) & 0x3F];
          output += lookup[(tmp << 2) & 0x3F];
          output += '=';
        }

        parts.push(output);

        return parts.join('')
      }

      function read (buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? (nBytes - 1) : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];

        i += d;

        e = s & ((1 << (-nBits)) - 1);
        s >>= (-nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & ((1 << (-nBits)) - 1);
        e >>= (-nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : ((s ? -1 : 1) * Infinity)
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
      }

      function write (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
        var i = isLE ? 0 : (nBytes - 1);
        var d = isLE ? 1 : -1;
        var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }

          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = (e << mLen) | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128;
      }

      var toString = {}.toString;

      var isArray$1 = Array.isArray || function (arr) {
        return toString.call(arr) == '[object Array]';
      };

      /*!
       * The buffer module from node.js, for the browser.
       *
       * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
       * @license  MIT
       */

      var INSPECT_MAX_BYTES = 50;

      /**
       * If `Buffer.TYPED_ARRAY_SUPPORT`:
       *   === true    Use Uint8Array implementation (fastest)
       *   === false   Use Object implementation (most compatible, even IE6)
       *
       * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
       * Opera 11.6+, iOS 4.2+.
       *
       * Due to various browser bugs, sometimes the Object implementation will be used even
       * when the browser supports typed arrays.
       *
       * Note:
       *
       *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
       *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
       *
       *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
       *
       *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
       *     incorrect length in some situations.

       * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
       * get the Object implementation, which is slower but behaves correctly.
       */
      Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
        ? global$1.TYPED_ARRAY_SUPPORT
        : true;

      function kMaxLength () {
        return Buffer$1.TYPED_ARRAY_SUPPORT
          ? 0x7fffffff
          : 0x3fffffff
      }

      function createBuffer (that, length) {
        if (kMaxLength() < length) {
          throw new RangeError('Invalid typed array length')
        }
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          // Return an augmented `Uint8Array` instance, for best performance
          that = new Uint8Array(length);
          that.__proto__ = Buffer$1.prototype;
        } else {
          // Fallback: Return an object instance of the Buffer class
          if (that === null) {
            that = new Buffer$1(length);
          }
          that.length = length;
        }

        return that
      }

      /**
       * The Buffer constructor returns instances of `Uint8Array` that have their
       * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
       * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
       * and the `Uint8Array` methods. Square bracket notation works as expected -- it
       * returns a single octet.
       *
       * The `Uint8Array` prototype remains unmodified.
       */

      function Buffer$1 (arg, encodingOrOffset, length) {
        if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
          return new Buffer$1(arg, encodingOrOffset, length)
        }

        // Common case.
        if (typeof arg === 'number') {
          if (typeof encodingOrOffset === 'string') {
            throw new Error(
              'If encoding is specified then the first argument must be a string'
            )
          }
          return allocUnsafe(this, arg)
        }
        return from(this, arg, encodingOrOffset, length)
      }

      Buffer$1.poolSize = 8192; // not used by this implementation

      // TODO: Legacy, not needed anymore. Remove in next major version.
      Buffer$1._augment = function (arr) {
        arr.__proto__ = Buffer$1.prototype;
        return arr
      };

      function from (that, value, encodingOrOffset, length) {
        if (typeof value === 'number') {
          throw new TypeError('"value" argument must not be a number')
        }

        if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
          return fromArrayBuffer(that, value, encodingOrOffset, length)
        }

        if (typeof value === 'string') {
          return fromString(that, value, encodingOrOffset)
        }

        return fromObject(that, value)
      }

      /**
       * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
       * if value is a number.
       * Buffer.from(str[, encoding])
       * Buffer.from(array)
       * Buffer.from(buffer)
       * Buffer.from(arrayBuffer[, byteOffset[, length]])
       **/
      Buffer$1.from = function (value, encodingOrOffset, length) {
        return from(null, value, encodingOrOffset, length)
      };

      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        Buffer$1.prototype.__proto__ = Uint8Array.prototype;
        Buffer$1.__proto__ = Uint8Array;
      }

      function assertSize (size) {
        if (typeof size !== 'number') {
          throw new TypeError('"size" argument must be a number')
        } else if (size < 0) {
          throw new RangeError('"size" argument must not be negative')
        }
      }

      function alloc (that, size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(that, size)
        }
        if (fill !== undefined) {
          // Only pay attention to encoding if it's a string. This
          // prevents accidentally sending in a number that would
          // be interpretted as a start offset.
          return typeof encoding === 'string'
            ? createBuffer(that, size).fill(fill, encoding)
            : createBuffer(that, size).fill(fill)
        }
        return createBuffer(that, size)
      }

      /**
       * Creates a new filled Buffer instance.
       * alloc(size[, fill[, encoding]])
       **/
      Buffer$1.alloc = function (size, fill, encoding) {
        return alloc(null, size, fill, encoding)
      };

      function allocUnsafe (that, size) {
        assertSize(size);
        that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
        if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
          for (var i = 0; i < size; ++i) {
            that[i] = 0;
          }
        }
        return that
      }

      /**
       * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
       * */
      Buffer$1.allocUnsafe = function (size) {
        return allocUnsafe(null, size)
      };
      /**
       * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
       */
      Buffer$1.allocUnsafeSlow = function (size) {
        return allocUnsafe(null, size)
      };

      function fromString (that, string, encoding) {
        if (typeof encoding !== 'string' || encoding === '') {
          encoding = 'utf8';
        }

        if (!Buffer$1.isEncoding(encoding)) {
          throw new TypeError('"encoding" must be a valid string encoding')
        }

        var length = byteLength(string, encoding) | 0;
        that = createBuffer(that, length);

        var actual = that.write(string, encoding);

        if (actual !== length) {
          // Writing a hex string, for example, that contains invalid characters will
          // cause everything after the first invalid character to be ignored. (e.g.
          // 'abxxcd' will be treated as 'ab')
          that = that.slice(0, actual);
        }

        return that
      }

      function fromArrayLike (that, array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        that = createBuffer(that, length);
        for (var i = 0; i < length; i += 1) {
          that[i] = array[i] & 255;
        }
        return that
      }

      function fromArrayBuffer (that, array, byteOffset, length) {
        array.byteLength; // this throws if `array` is not a valid ArrayBuffer

        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('\'offset\' is out of bounds')
        }

        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('\'length\' is out of bounds')
        }

        if (byteOffset === undefined && length === undefined) {
          array = new Uint8Array(array);
        } else if (length === undefined) {
          array = new Uint8Array(array, byteOffset);
        } else {
          array = new Uint8Array(array, byteOffset, length);
        }

        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          // Return an augmented `Uint8Array` instance, for best performance
          that = array;
          that.__proto__ = Buffer$1.prototype;
        } else {
          // Fallback: Return an object instance of the Buffer class
          that = fromArrayLike(that, array);
        }
        return that
      }

      function fromObject (that, obj) {
        if (internalIsBuffer(obj)) {
          var len = checked(obj.length) | 0;
          that = createBuffer(that, len);

          if (that.length === 0) {
            return that
          }

          obj.copy(that, 0, 0, len);
          return that
        }

        if (obj) {
          if ((typeof ArrayBuffer !== 'undefined' &&
              obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
            if (typeof obj.length !== 'number' || isnan(obj.length)) {
              return createBuffer(that, 0)
            }
            return fromArrayLike(that, obj)
          }

          if (obj.type === 'Buffer' && isArray$1(obj.data)) {
            return fromArrayLike(that, obj.data)
          }
        }

        throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
      }

      function checked (length) {
        // Note: cannot use `length < kMaxLength()` here because that fails when
        // length is NaN (which is otherwise coerced to zero.)
        if (length >= kMaxLength()) {
          throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                               'size: 0x' + kMaxLength().toString(16) + ' bytes')
        }
        return length | 0
      }
      Buffer$1.isBuffer = isBuffer;
      function internalIsBuffer (b) {
        return !!(b != null && b._isBuffer)
      }

      Buffer$1.compare = function compare (a, b) {
        if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
          throw new TypeError('Arguments must be Buffers')
        }

        if (a === b) return 0

        var x = a.length;
        var y = b.length;

        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break
          }
        }

        if (x < y) return -1
        if (y < x) return 1
        return 0
      };

      Buffer$1.isEncoding = function isEncoding (encoding) {
        switch (String(encoding).toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'latin1':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return true
          default:
            return false
        }
      };

      Buffer$1.concat = function concat (list, length) {
        if (!isArray$1(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }

        if (list.length === 0) {
          return Buffer$1.alloc(0)
        }

        var i;
        if (length === undefined) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }

        var buffer = Buffer$1.allocUnsafe(length);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (!internalIsBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers')
          }
          buf.copy(buffer, pos);
          pos += buf.length;
        }
        return buffer
      };

      function byteLength (string, encoding) {
        if (internalIsBuffer(string)) {
          return string.length
        }
        if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
            (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
          return string.byteLength
        }
        if (typeof string !== 'string') {
          string = '' + string;
        }

        var len = string.length;
        if (len === 0) return 0

        // Use a for loop to avoid recursion
        var loweredCase = false;
        for (;;) {
          switch (encoding) {
            case 'ascii':
            case 'latin1':
            case 'binary':
              return len
            case 'utf8':
            case 'utf-8':
            case undefined:
              return utf8ToBytes(string).length
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return len * 2
            case 'hex':
              return len >>> 1
            case 'base64':
              return base64ToBytes(string).length
            default:
              if (loweredCase) return utf8ToBytes(string).length // assume utf8
              encoding = ('' + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer$1.byteLength = byteLength;

      function slowToString (encoding, start, end) {
        var loweredCase = false;

        // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
        // property of a typed array.

        // This behaves neither like String nor Uint8Array in that we set start/end
        // to their upper/lower bounds if the value passed is out of range.
        // undefined is handled specially as per ECMA-262 6th Edition,
        // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
        if (start === undefined || start < 0) {
          start = 0;
        }
        // Return early if start > this.length. Done here to prevent potential uint32
        // coercion fail below.
        if (start > this.length) {
          return ''
        }

        if (end === undefined || end > this.length) {
          end = this.length;
        }

        if (end <= 0) {
          return ''
        }

        // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
        end >>>= 0;
        start >>>= 0;

        if (end <= start) {
          return ''
        }

        if (!encoding) encoding = 'utf8';

        while (true) {
          switch (encoding) {
            case 'hex':
              return hexSlice(this, start, end)

            case 'utf8':
            case 'utf-8':
              return utf8Slice(this, start, end)

            case 'ascii':
              return asciiSlice(this, start, end)

            case 'latin1':
            case 'binary':
              return latin1Slice(this, start, end)

            case 'base64':
              return base64Slice(this, start, end)

            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return utf16leSlice(this, start, end)

            default:
              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
              encoding = (encoding + '').toLowerCase();
              loweredCase = true;
          }
        }
      }

      // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
      // Buffer instances.
      Buffer$1.prototype._isBuffer = true;

      function swap (b, n, m) {
        var i = b[n];
        b[n] = b[m];
        b[m] = i;
      }

      Buffer$1.prototype.swap16 = function swap16 () {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 16-bits')
        }
        for (var i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this
      };

      Buffer$1.prototype.swap32 = function swap32 () {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 32-bits')
        }
        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this
      };

      Buffer$1.prototype.swap64 = function swap64 () {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 64-bits')
        }
        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this
      };

      Buffer$1.prototype.toString = function toString () {
        var length = this.length | 0;
        if (length === 0) return ''
        if (arguments.length === 0) return utf8Slice(this, 0, length)
        return slowToString.apply(this, arguments)
      };

      Buffer$1.prototype.equals = function equals (b) {
        if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
        if (this === b) return true
        return Buffer$1.compare(this, b) === 0
      };

      Buffer$1.prototype.inspect = function inspect () {
        var str = '';
        var max = INSPECT_MAX_BYTES;
        if (this.length > 0) {
          str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
          if (this.length > max) str += ' ... ';
        }
        return '<Buffer ' + str + '>'
      };

      Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
        if (!internalIsBuffer(target)) {
          throw new TypeError('Argument must be a Buffer')
        }

        if (start === undefined) {
          start = 0;
        }
        if (end === undefined) {
          end = target ? target.length : 0;
        }
        if (thisStart === undefined) {
          thisStart = 0;
        }
        if (thisEnd === undefined) {
          thisEnd = this.length;
        }

        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError('out of range index')
        }

        if (thisStart >= thisEnd && start >= end) {
          return 0
        }
        if (thisStart >= thisEnd) {
          return -1
        }
        if (start >= end) {
          return 1
        }

        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;

        if (this === target) return 0

        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);

        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);

        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break
          }
        }

        if (x < y) return -1
        if (y < x) return 1
        return 0
      };

      // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
      // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
      //
      // Arguments:
      // - buffer - a Buffer to search
      // - val - a string, Buffer, or number
      // - byteOffset - an index into `buffer`; will be clamped to an int32
      // - encoding - an optional encoding, relevant is val is a string
      // - dir - true for indexOf, false for lastIndexOf
      function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
        // Empty buffer means no match
        if (buffer.length === 0) return -1

        // Normalize byteOffset
        if (typeof byteOffset === 'string') {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 0x7fffffff) {
          byteOffset = 0x7fffffff;
        } else if (byteOffset < -0x80000000) {
          byteOffset = -0x80000000;
        }
        byteOffset = +byteOffset;  // Coerce to Number.
        if (isNaN(byteOffset)) {
          // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
          byteOffset = dir ? 0 : (buffer.length - 1);
        }

        // Normalize byteOffset: negative offsets start from the end of the buffer
        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir) return -1
          else byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1
        }

        // Normalize val
        if (typeof val === 'string') {
          val = Buffer$1.from(val, encoding);
        }

        // Finally, search either indexOf (if dir is true) or lastIndexOf
        if (internalIsBuffer(val)) {
          // Special case: looking for empty string/buffer always fails
          if (val.length === 0) {
            return -1
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
        } else if (typeof val === 'number') {
          val = val & 0xFF; // Search for a byte value [0-255]
          if (Buffer$1.TYPED_ARRAY_SUPPORT &&
              typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
            }
          }
          return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
        }

        throw new TypeError('val must be string, number or Buffer')
      }

      function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;

        if (encoding !== undefined) {
          encoding = String(encoding).toLowerCase();
          if (encoding === 'ucs2' || encoding === 'ucs-2' ||
              encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) {
              return -1
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }

        function read (buf, i) {
          if (indexSize === 1) {
            return buf[i]
          } else {
            return buf.readUInt16BE(i * indexSize)
          }
        }

        var i;
        if (dir) {
          var foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i;
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
            } else {
              if (foundIndex !== -1) i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            var found = true;
            for (var j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break
              }
            }
            if (found) return i
          }
        }

        return -1
      }

      Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1
      };

      Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
      };

      Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
      };

      function hexWrite (buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }

        // must be an even number of digits
        var strLen = string.length;
        if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

        if (length > strLen / 2) {
          length = strLen / 2;
        }
        for (var i = 0; i < length; ++i) {
          var parsed = parseInt(string.substr(i * 2, 2), 16);
          if (isNaN(parsed)) return i
          buf[offset + i] = parsed;
        }
        return i
      }

      function utf8Write (buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
      }

      function asciiWrite (buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length)
      }

      function latin1Write (buf, string, offset, length) {
        return asciiWrite(buf, string, offset, length)
      }

      function base64Write (buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length)
      }

      function ucs2Write (buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
      }

      Buffer$1.prototype.write = function write (string, offset, length, encoding) {
        // Buffer#write(string)
        if (offset === undefined) {
          encoding = 'utf8';
          length = this.length;
          offset = 0;
        // Buffer#write(string, encoding)
        } else if (length === undefined && typeof offset === 'string') {
          encoding = offset;
          length = this.length;
          offset = 0;
        // Buffer#write(string, offset[, length][, encoding])
        } else if (isFinite(offset)) {
          offset = offset | 0;
          if (isFinite(length)) {
            length = length | 0;
            if (encoding === undefined) encoding = 'utf8';
          } else {
            encoding = length;
            length = undefined;
          }
        // legacy write(string, encoding, offset, length) - remove in v0.13
        } else {
          throw new Error(
            'Buffer.write(string, encoding, offset[, length]) is no longer supported'
          )
        }

        var remaining = this.length - offset;
        if (length === undefined || length > remaining) length = remaining;

        if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
          throw new RangeError('Attempt to write outside buffer bounds')
        }

        if (!encoding) encoding = 'utf8';

        var loweredCase = false;
        for (;;) {
          switch (encoding) {
            case 'hex':
              return hexWrite(this, string, offset, length)

            case 'utf8':
            case 'utf-8':
              return utf8Write(this, string, offset, length)

            case 'ascii':
              return asciiWrite(this, string, offset, length)

            case 'latin1':
            case 'binary':
              return latin1Write(this, string, offset, length)

            case 'base64':
              // Warning: maxLength not taken into account in base64Write
              return base64Write(this, string, offset, length)

            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return ucs2Write(this, string, offset, length)

            default:
              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
              encoding = ('' + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };

      Buffer$1.prototype.toJSON = function toJSON () {
        return {
          type: 'Buffer',
          data: Array.prototype.slice.call(this._arr || this, 0)
        }
      };

      function base64Slice (buf, start, end) {
        if (start === 0 && end === buf.length) {
          return fromByteArray(buf)
        } else {
          return fromByteArray(buf.slice(start, end))
        }
      }

      function utf8Slice (buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];

        var i = start;
        while (i < end) {
          var firstByte = buf[i];
          var codePoint = null;
          var bytesPerSequence = (firstByte > 0xEF) ? 4
            : (firstByte > 0xDF) ? 3
            : (firstByte > 0xBF) ? 2
            : 1;

          if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;

            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 0x80) {
                  codePoint = firstByte;
                }
                break
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                  if (tempCodePoint > 0x7F) {
                    codePoint = tempCodePoint;
                  }
                }
                break
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                  if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                    codePoint = tempCodePoint;
                  }
                }
                break
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                  if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }

          if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
          } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
          }

          res.push(codePoint);
          i += bytesPerSequence;
        }

        return decodeCodePointsArray(res)
      }

      // Based on http://stackoverflow.com/a/22747272/680742, the browser with
      // the lowest limit is Chrome, with 0x10000 args.
      // We go 1 magnitude less, for safety
      var MAX_ARGUMENTS_LENGTH = 0x1000;

      function decodeCodePointsArray (codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
        }

        // Decode in chunks to avoid "call stack size exceeded".
        var res = '';
        var i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res
      }

      function asciiSlice (buf, start, end) {
        var ret = '';
        end = Math.min(buf.length, end);

        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 0x7F);
        }
        return ret
      }

      function latin1Slice (buf, start, end) {
        var ret = '';
        end = Math.min(buf.length, end);

        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret
      }

      function hexSlice (buf, start, end) {
        var len = buf.length;

        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;

        var out = '';
        for (var i = start; i < end; ++i) {
          out += toHex(buf[i]);
        }
        return out
      }

      function utf16leSlice (buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = '';
        for (var i = 0; i < bytes.length; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res
      }

      Buffer$1.prototype.slice = function slice (start, end) {
        var len = this.length;
        start = ~~start;
        end = end === undefined ? len : ~~end;

        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }

        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }

        if (end < start) end = start;

        var newBuf;
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer$1.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer$1(sliceLen, undefined);
          for (var i = 0; i < sliceLen; ++i) {
            newBuf[i] = this[i + start];
          }
        }

        return newBuf
      };

      /*
       * Need to make sure that buffer isn't trying to write out of bounds.
       */
      function checkOffset (offset, ext, length) {
        if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
        if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
      }

      Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
        offset = offset | 0;
        byteLength = byteLength | 0;
        if (!noAssert) checkOffset(offset, byteLength, this.length);

        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength && (mul *= 0x100)) {
          val += this[offset + i] * mul;
        }

        return val
      };

      Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
        offset = offset | 0;
        byteLength = byteLength | 0;
        if (!noAssert) {
          checkOffset(offset, byteLength, this.length);
        }

        var val = this[offset + --byteLength];
        var mul = 1;
        while (byteLength > 0 && (mul *= 0x100)) {
          val += this[offset + --byteLength] * mul;
        }

        return val
      };

      Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset]
      };

      Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | (this[offset + 1] << 8)
      };

      Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length);
        return (this[offset] << 8) | this[offset + 1]
      };

      Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length);

        return ((this[offset]) |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16)) +
            (this[offset + 3] * 0x1000000)
      };

      Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length);

        return (this[offset] * 0x1000000) +
          ((this[offset + 1] << 16) |
          (this[offset + 2] << 8) |
          this[offset + 3])
      };

      Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
        offset = offset | 0;
        byteLength = byteLength | 0;
        if (!noAssert) checkOffset(offset, byteLength, this.length);

        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength && (mul *= 0x100)) {
          val += this[offset + i] * mul;
        }
        mul *= 0x80;

        if (val >= mul) val -= Math.pow(2, 8 * byteLength);

        return val
      };

      Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
        offset = offset | 0;
        byteLength = byteLength | 0;
        if (!noAssert) checkOffset(offset, byteLength, this.length);

        var i = byteLength;
        var mul = 1;
        var val = this[offset + --i];
        while (i > 0 && (mul *= 0x100)) {
          val += this[offset + --i] * mul;
        }
        mul *= 0x80;

        if (val >= mul) val -= Math.pow(2, 8 * byteLength);

        return val
      };

      Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 0x80)) return (this[offset])
        return ((0xff - this[offset] + 1) * -1)
      };

      Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length);
        var val = this[offset] | (this[offset + 1] << 8);
        return (val & 0x8000) ? val | 0xFFFF0000 : val
      };

      Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | (this[offset] << 8);
        return (val & 0x8000) ? val | 0xFFFF0000 : val
      };

      Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length);

        return (this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16) |
          (this[offset + 3] << 24)
      };

      Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length);

        return (this[offset] << 24) |
          (this[offset + 1] << 16) |
          (this[offset + 2] << 8) |
          (this[offset + 3])
      };

      Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length);
        return read(this, offset, true, 23, 4)
      };

      Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length);
        return read(this, offset, false, 23, 4)
      };

      Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 8, this.length);
        return read(this, offset, true, 52, 8)
      };

      Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 8, this.length);
        return read(this, offset, false, 52, 8)
      };

      function checkInt (buf, value, offset, ext, max, min) {
        if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
        if (offset + ext > buf.length) throw new RangeError('Index out of range')
      }

      Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength = byteLength | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength) - 1;
          checkInt(this, value, offset, byteLength, maxBytes, 0);
        }

        var mul = 1;
        var i = 0;
        this[offset] = value & 0xFF;
        while (++i < byteLength && (mul *= 0x100)) {
          this[offset + i] = (value / mul) & 0xFF;
        }

        return offset + byteLength
      };

      Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength = byteLength | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength) - 1;
          checkInt(this, value, offset, byteLength, maxBytes, 0);
        }

        var i = byteLength - 1;
        var mul = 1;
        this[offset + i] = value & 0xFF;
        while (--i >= 0 && (mul *= 0x100)) {
          this[offset + i] = (value / mul) & 0xFF;
        }

        return offset + byteLength
      };

      Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
        if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
        this[offset] = (value & 0xff);
        return offset + 1
      };

      function objectWriteUInt16 (buf, value, offset, littleEndian) {
        if (value < 0) value = 0xffff + value + 1;
        for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
          buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8;
        }
      }

      Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value & 0xff);
          this[offset + 1] = (value >>> 8);
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2
      };

      Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 8);
          this[offset + 1] = (value & 0xff);
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2
      };

      function objectWriteUInt32 (buf, value, offset, littleEndian) {
        if (value < 0) value = 0xffffffff + value + 1;
        for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
          buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
        }
      }

      Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = (value >>> 24);
          this[offset + 2] = (value >>> 16);
          this[offset + 1] = (value >>> 8);
          this[offset] = (value & 0xff);
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4
      };

      Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 24);
          this[offset + 1] = (value >>> 16);
          this[offset + 2] = (value >>> 8);
          this[offset + 3] = (value & 0xff);
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4
      };

      Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength - 1);

          checkInt(this, value, offset, byteLength, limit - 1, -limit);
        }

        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 0xFF;
        while (++i < byteLength && (mul *= 0x100)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
        }

        return offset + byteLength
      };

      Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength - 1);

          checkInt(this, value, offset, byteLength, limit - 1, -limit);
        }

        var i = byteLength - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = value & 0xFF;
        while (--i >= 0 && (mul *= 0x100)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
        }

        return offset + byteLength
      };

      Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
        if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
        if (value < 0) value = 0xff + value + 1;
        this[offset] = (value & 0xff);
        return offset + 1
      };

      Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value & 0xff);
          this[offset + 1] = (value >>> 8);
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2
      };

      Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 8);
          this[offset + 1] = (value & 0xff);
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2
      };

      Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value & 0xff);
          this[offset + 1] = (value >>> 8);
          this[offset + 2] = (value >>> 16);
          this[offset + 3] = (value >>> 24);
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4
      };

      Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
        if (value < 0) value = 0xffffffff + value + 1;
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 24);
          this[offset + 1] = (value >>> 16);
          this[offset + 2] = (value >>> 8);
          this[offset + 3] = (value & 0xff);
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4
      };

      function checkIEEE754 (buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError('Index out of range')
        if (offset < 0) throw new RangeError('Index out of range')
      }

      function writeFloat (buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4);
        }
        write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4
      }

      Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert)
      };

      Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert)
      };

      function writeDouble (buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8);
        }
        write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8
      }

      Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert)
      };

      Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert)
      };

      // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
      Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;

        // Copy 0 bytes; we're done
        if (end === start) return 0
        if (target.length === 0 || this.length === 0) return 0

        // Fatal error conditions
        if (targetStart < 0) {
          throw new RangeError('targetStart out of bounds')
        }
        if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
        if (end < 0) throw new RangeError('sourceEnd out of bounds')

        // Are we oob?
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }

        var len = end - start;
        var i;

        if (this === target && start < targetStart && targetStart < end) {
          // descending copy from end
          for (i = len - 1; i >= 0; --i) {
            target[i + targetStart] = this[i + start];
          }
        } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
          // ascending copy from start
          for (i = 0; i < len; ++i) {
            target[i + targetStart] = this[i + start];
          }
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, start + len),
            targetStart
          );
        }

        return len
      };

      // Usage:
      //    buffer.fill(number[, offset[, end]])
      //    buffer.fill(buffer[, offset[, end]])
      //    buffer.fill(string[, offset[, end]][, encoding])
      Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
        // Handle string cases:
        if (typeof val === 'string') {
          if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) {
              val = code;
            }
          }
          if (encoding !== undefined && typeof encoding !== 'string') {
            throw new TypeError('encoding must be a string')
          }
          if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
            throw new TypeError('Unknown encoding: ' + encoding)
          }
        } else if (typeof val === 'number') {
          val = val & 255;
        }

        // Invalid ranges are not set to a default, so can range check early.
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError('Out of range index')
        }

        if (end <= start) {
          return this
        }

        start = start >>> 0;
        end = end === undefined ? this.length : end >>> 0;

        if (!val) val = 0;

        var i;
        if (typeof val === 'number') {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = internalIsBuffer(val)
            ? val
            : utf8ToBytes(new Buffer$1(val, encoding).toString());
          var len = bytes.length;
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }

        return this
      };

      // HELPER FUNCTIONS
      // ================

      var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

      function base64clean (str) {
        // Node strips out invalid characters like \n and \t from the string, base64-js does not
        str = stringtrim(str).replace(INVALID_BASE64_RE, '');
        // Node converts strings with length < 2 to ''
        if (str.length < 2) return ''
        // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
        while (str.length % 4 !== 0) {
          str = str + '=';
        }
        return str
      }

      function stringtrim (str) {
        if (str.trim) return str.trim()
        return str.replace(/^\s+|\s+$/g, '')
      }

      function toHex (n) {
        if (n < 16) return '0' + n.toString(16)
        return n.toString(16)
      }

      function utf8ToBytes (string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];

        for (var i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);

          // is surrogate component
          if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
              // no lead yet
              if (codePoint > 0xDBFF) {
                // unexpected trail
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                continue
              } else if (i + 1 === length) {
                // unpaired lead
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                continue
              }

              // valid lead
              leadSurrogate = codePoint;

              continue
            }

            // 2 leads in a row
            if (codePoint < 0xDC00) {
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              leadSurrogate = codePoint;
              continue
            }

            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
          } else if (leadSurrogate) {
            // valid bmp char, but last char was a lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          }

          leadSurrogate = null;

          // encode utf8
          if (codePoint < 0x80) {
            if ((units -= 1) < 0) break
            bytes.push(codePoint);
          } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break
            bytes.push(
              codePoint >> 0x6 | 0xC0,
              codePoint & 0x3F | 0x80
            );
          } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break
            bytes.push(
              codePoint >> 0xC | 0xE0,
              codePoint >> 0x6 & 0x3F | 0x80,
              codePoint & 0x3F | 0x80
            );
          } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break
            bytes.push(
              codePoint >> 0x12 | 0xF0,
              codePoint >> 0xC & 0x3F | 0x80,
              codePoint >> 0x6 & 0x3F | 0x80,
              codePoint & 0x3F | 0x80
            );
          } else {
            throw new Error('Invalid code point')
          }
        }

        return bytes
      }

      function asciiToBytes (str) {
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          // Node's code seems to be doing this and not & 0x7F..
          byteArray.push(str.charCodeAt(i) & 0xFF);
        }
        return byteArray
      }

      function utf16leToBytes (str, units) {
        var c, hi, lo;
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break

          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }

        return byteArray
      }


      function base64ToBytes (str) {
        return toByteArray(base64clean(str))
      }

      function blitBuffer (src, dst, offset, length) {
        for (var i = 0; i < length; ++i) {
          if ((i + offset >= dst.length) || (i >= src.length)) break
          dst[i + offset] = src[i];
        }
        return i
      }

      function isnan (val) {
        return val !== val // eslint-disable-line no-self-compare
      }


      // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
      // The _isBuffer check is for Safari 5-7 support, because it's missing
      // Object.prototype.constructor. Remove this eventually
      function isBuffer(obj) {
        return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
      }

      function isFastBuffer (obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
      }

      // For Node v0.10 support. Remove this eventually.
      function isSlowBuffer (obj) {
        return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
      }

      // shim for using process in browser
      // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

      function defaultSetTimout() {
          throw new Error('setTimeout has not been defined');
      }
      function defaultClearTimeout () {
          throw new Error('clearTimeout has not been defined');
      }
      var cachedSetTimeout = defaultSetTimout;
      var cachedClearTimeout = defaultClearTimeout;
      if (typeof global$1.setTimeout === 'function') {
          cachedSetTimeout = setTimeout;
      }
      if (typeof global$1.clearTimeout === 'function') {
          cachedClearTimeout = clearTimeout;
      }

      function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
              //normal enviroments in sane situations
              return setTimeout(fun, 0);
          }
          // if setTimeout wasn't available but was latter defined
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
          }
          try {
              // when when somebody has screwed with setTimeout but no I.E. maddness
              return cachedSetTimeout(fun, 0);
          } catch(e){
              try {
                  // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                  return cachedSetTimeout.call(null, fun, 0);
              } catch(e){
                  // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                  return cachedSetTimeout.call(this, fun, 0);
              }
          }


      }
      function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
              //normal enviroments in sane situations
              return clearTimeout(marker);
          }
          // if clearTimeout wasn't available but was latter defined
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
          }
          try {
              // when when somebody has screwed with setTimeout but no I.E. maddness
              return cachedClearTimeout(marker);
          } catch (e){
              try {
                  // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                  return cachedClearTimeout.call(null, marker);
              } catch (e){
                  // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                  // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                  return cachedClearTimeout.call(this, marker);
              }
          }



      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() {
          if (!draining || !currentQueue) {
              return;
          }
          draining = false;
          if (currentQueue.length) {
              queue = currentQueue.concat(queue);
          } else {
              queueIndex = -1;
          }
          if (queue.length) {
              drainQueue();
          }
      }

      function drainQueue() {
          if (draining) {
              return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;

          var len = queue.length;
          while(len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                  if (currentQueue) {
                      currentQueue[queueIndex].run();
                  }
              }
              queueIndex = -1;
              len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
      }
      function nextTick(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                  args[i - 1] = arguments[i];
              }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
          }
      }
      // v8 likes predictible objects
      function Item(fun, array) {
          this.fun = fun;
          this.array = array;
      }
      Item.prototype.run = function () {
          this.fun.apply(null, this.array);
      };
      var title = 'browser';
      var platform = 'browser';
      var browser = true;
      var env = {};
      var argv = [];
      var version$2 = ''; // empty string to avoid regexp issues
      var versions = {};
      var release = {};
      var config$1 = {};

      function noop() {}

      var on = noop;
      var addListener = noop;
      var once = noop;
      var off = noop;
      var removeListener = noop;
      var removeAllListeners = noop;
      var emit = noop;

      function binding$1(name) {
          throw new Error('process.binding is not supported');
      }

      function cwd () { return '/' }
      function chdir (dir) {
          throw new Error('process.chdir is not supported');
      }function umask() { return 0; }

      // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
      var performance = global$1.performance || {};
      var performanceNow =
        performance.now        ||
        performance.mozNow     ||
        performance.msNow      ||
        performance.oNow       ||
        performance.webkitNow  ||
        function(){ return (new Date()).getTime() };

      // generate timestamp or delta
      // see http://nodejs.org/api/process.html#process_process_hrtime
      function hrtime(previousTimestamp){
        var clocktime = performanceNow.call(performance)*1e-3;
        var seconds = Math.floor(clocktime);
        var nanoseconds = Math.floor((clocktime%1)*1e9);
        if (previousTimestamp) {
          seconds = seconds - previousTimestamp[0];
          nanoseconds = nanoseconds - previousTimestamp[1];
          if (nanoseconds<0) {
            seconds--;
            nanoseconds += 1e9;
          }
        }
        return [seconds,nanoseconds]
      }

      var startTime = new Date();
      function uptime() {
        var currentTime = new Date();
        var dif = currentTime - startTime;
        return dif / 1000;
      }

      var browser$1 = {
        nextTick: nextTick,
        title: title,
        browser: browser,
        env: env,
        argv: argv,
        version: version$2,
        versions: versions,
        on: on,
        addListener: addListener,
        once: once,
        off: off,
        removeListener: removeListener,
        removeAllListeners: removeAllListeners,
        emit: emit,
        binding: binding$1,
        cwd: cwd,
        chdir: chdir,
        umask: umask,
        hrtime: hrtime,
        platform: platform,
        release: release,
        config: config$1,
        uptime: uptime
      };

      var inherits;
      if (typeof Object.create === 'function'){
        inherits = function inherits(ctor, superCtor) {
          // implementation from standard node.js 'util' module
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        inherits = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function () {};
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
      var inherits$1 = inherits;

      var formatRegExp = /%[sdj%]/g;
      function format$1(f) {
        if (!isString$2(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(' ');
        }

        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x) {
          if (x === '%%') return '%';
          if (i >= len) return x;
          switch (x) {
            case '%s': return String(args[i++]);
            case '%d': return Number(args[i++]);
            case '%j':
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return '[Circular]';
              }
            default:
              return x;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject$1(x)) {
            str += ' ' + x;
          } else {
            str += ' ' + inspect(x);
          }
        }
        return str;
      }

      // Mark that a method should not be used.
      // Returns a modified function which warns once by default.
      // If --no-deprecation is set, then it is a no-op.
      function deprecate(fn, msg) {
        // Allow for deprecating things in the process of starting up.
        if (isUndefined(global$1.process)) {
          return function() {
            return deprecate(fn, msg).apply(this, arguments);
          };
        }

        if (browser$1.noDeprecation === true) {
          return fn;
        }

        var warned = false;
        function deprecated() {
          if (!warned) {
            if (browser$1.throwDeprecation) {
              throw new Error(msg);
            } else if (browser$1.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }

        return deprecated;
      }

      var debugs = {};
      var debugEnviron;
      function debuglog(set) {
        if (isUndefined(debugEnviron))
          debugEnviron = browser$1.env.NODE_DEBUG || '';
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
            var pid = 0;
            debugs[set] = function() {
              var msg = format$1.apply(null, arguments);
              console.error('%s %d: %s', set, pid, msg);
            };
          } else {
            debugs[set] = function() {};
          }
        }
        return debugs[set];
      }

      /**
       * Echos the value of a value. Trys to print the value out
       * in the best way possible given the different types.
       *
       * @param {Object} obj The object to print out.
       * @param {Object} opts Optional options object that alters the output.
       */
      /* legacy: obj, showHidden, depth, colors*/
      function inspect(obj, opts) {
        // default options
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        // legacy...
        if (arguments.length >= 3) ctx.depth = arguments[2];
        if (arguments.length >= 4) ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          // legacy...
          ctx.showHidden = opts;
        } else if (opts) {
          // got an "options" object
          _extend(ctx, opts);
        }
        // set default options
        if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
        if (isUndefined(ctx.depth)) ctx.depth = 2;
        if (isUndefined(ctx.colors)) ctx.colors = false;
        if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
        if (ctx.colors) ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }

      // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
      inspect.colors = {
        'bold' : [1, 22],
        'italic' : [3, 23],
        'underline' : [4, 24],
        'inverse' : [7, 27],
        'white' : [37, 39],
        'grey' : [90, 39],
        'black' : [30, 39],
        'blue' : [34, 39],
        'cyan' : [36, 39],
        'green' : [32, 39],
        'magenta' : [35, 39],
        'red' : [31, 39],
        'yellow' : [33, 39]
      };

      // Don't use 'blue' not visible on cmd.exe
      inspect.styles = {
        'special': 'cyan',
        'number': 'yellow',
        'boolean': 'yellow',
        'undefined': 'grey',
        'null': 'bold',
        'string': 'green',
        'date': 'magenta',
        // "name": intentionally not styling
        'regexp': 'red'
      };


      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];

        if (style) {
          return '\u001b[' + inspect.colors[style][0] + 'm' + str +
                 '\u001b[' + inspect.colors[style][1] + 'm';
        } else {
          return str;
        }
      }


      function stylizeNoColor(str, styleType) {
        return str;
      }


      function arrayToHash(array) {
        var hash = {};

        array.forEach(function(val, idx) {
          hash[val] = true;
        });

        return hash;
      }


      function formatValue(ctx, value, recurseTimes) {
        // Provide a hook for user-specified inspect functions.
        // Check that value is an object with an inspect function on it
        if (ctx.customInspect &&
            value &&
            isFunction$1(value.inspect) &&
            // Filter out the util module, it's inspect function is special
            value.inspect !== inspect &&
            // Also filter out any prototype objects using the circular check.
            !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString$2(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }

        // Primitive types cannot have properties
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }

        // Look up the keys of the object.
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);

        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }

        // IE doesn't make error fields non-enumerable
        // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
        if (isError(value)
            && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
          return formatError(value);
        }

        // Some type of object without properties can be shortcutted.
        if (keys.length === 0) {
          if (isFunction$1(value)) {
            var name = value.name ? ': ' + value.name : '';
            return ctx.stylize('[Function' + name + ']', 'special');
          }
          if (isRegExp$1(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), 'date');
          }
          if (isError(value)) {
            return formatError(value);
          }
        }

        var base = '', array = false, braces = ['{', '}'];

        // Make Array say that they are Array
        if (isArray(value)) {
          array = true;
          braces = ['[', ']'];
        }

        // Make functions say that they are functions
        if (isFunction$1(value)) {
          var n = value.name ? ': ' + value.name : '';
          base = ' [Function' + n + ']';
        }

        // Make RegExps say that they are RegExps
        if (isRegExp$1(value)) {
          base = ' ' + RegExp.prototype.toString.call(value);
        }

        // Make dates with properties first say the date
        if (isDate(value)) {
          base = ' ' + Date.prototype.toUTCString.call(value);
        }

        // Make error with message first say the error
        if (isError(value)) {
          base = ' ' + formatError(value);
        }

        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }

        if (recurseTimes < 0) {
          if (isRegExp$1(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
          } else {
            return ctx.stylize('[Object]', 'special');
          }
        }

        ctx.seen.push(value);

        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }

        ctx.seen.pop();

        return reduceToSingleString(output, base, braces);
      }


      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize('undefined', 'undefined');
        if (isString$2(value)) {
          var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                   .replace(/'/g, "\\'")
                                                   .replace(/\\"/g, '"') + '\'';
          return ctx.stylize(simple, 'string');
        }
        if (isNumber$1(value))
          return ctx.stylize('' + value, 'number');
        if (isBoolean(value))
          return ctx.stylize('' + value, 'boolean');
        // For some reason typeof null is "object", so special case here.
        if (isNull(value))
          return ctx.stylize('null', 'null');
      }


      function formatError(value) {
        return '[' + Error.prototype.toString.call(value) + ']';
      }


      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                String(i), true));
          } else {
            output.push('');
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                key, true));
          }
        });
        return output;
      }


      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize('[Getter/Setter]', 'special');
          } else {
            str = ctx.stylize('[Getter]', 'special');
          }
        } else {
          if (desc.set) {
            str = ctx.stylize('[Setter]', 'special');
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = '[' + key + ']';
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf('\n') > -1) {
              if (array) {
                str = str.split('\n').map(function(line) {
                  return '  ' + line;
                }).join('\n').substr(2);
              } else {
                str = '\n' + str.split('\n').map(function(line) {
                  return '   ' + line;
                }).join('\n');
              }
            }
          } else {
            str = ctx.stylize('[Circular]', 'special');
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify('' + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, 'name');
          } else {
            name = name.replace(/'/g, "\\'")
                       .replace(/\\"/g, '"')
                       .replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, 'string');
          }
        }

        return name + ': ' + str;
      }


      function reduceToSingleString(output, base, braces) {
        var length = output.reduce(function(prev, cur) {
          if (cur.indexOf('\n') >= 0) ;
          return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
        }, 0);

        if (length > 60) {
          return braces[0] +
                 (base === '' ? '' : base + '\n ') +
                 ' ' +
                 output.join(',\n  ') +
                 ' ' +
                 braces[1];
        }

        return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
      }


      // NOTE: These type checking functions intentionally don't use `instanceof`
      // because it is fragile and can be easily faked with `Object.create()`.
      function isArray(ar) {
        return Array.isArray(ar);
      }

      function isBoolean(arg) {
        return typeof arg === 'boolean';
      }

      function isNull(arg) {
        return arg === null;
      }

      function isNumber$1(arg) {
        return typeof arg === 'number';
      }

      function isString$2(arg) {
        return typeof arg === 'string';
      }

      function isUndefined(arg) {
        return arg === void 0;
      }

      function isRegExp$1(re) {
        return isObject$1(re) && objectToString(re) === '[object RegExp]';
      }

      function isObject$1(arg) {
        return typeof arg === 'object' && arg !== null;
      }

      function isDate(d) {
        return isObject$1(d) && objectToString(d) === '[object Date]';
      }

      function isError(e) {
        return isObject$1(e) &&
            (objectToString(e) === '[object Error]' || e instanceof Error);
      }

      function isFunction$1(arg) {
        return typeof arg === 'function';
      }

      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }

      function _extend(origin, add) {
        // Don't do anything if add isn't an object
        if (!add || !isObject$1(add)) return origin;

        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      }
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }

      function BufferList() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }

      BufferList.prototype.push = function (v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;else this.head = entry;
        this.tail = entry;
        ++this.length;
      };

      BufferList.prototype.unshift = function (v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };

      BufferList.prototype.shift = function () {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
        --this.length;
        return ret;
      };

      BufferList.prototype.clear = function () {
        this.head = this.tail = null;
        this.length = 0;
      };

      BufferList.prototype.join = function (s) {
        if (this.length === 0) return '';
        var p = this.head;
        var ret = '' + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }return ret;
      };

      BufferList.prototype.concat = function (n) {
        if (this.length === 0) return Buffer$1.alloc(0);
        if (this.length === 1) return this.head.data;
        var ret = Buffer$1.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          p.data.copy(ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };

      // Copyright Joyent, Inc. and other Node contributors.
      var isBufferEncoding = Buffer$1.isEncoding
        || function(encoding) {
             switch (encoding && encoding.toLowerCase()) {
               case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
               default: return false;
             }
           };


      function assertEncoding(encoding) {
        if (encoding && !isBufferEncoding(encoding)) {
          throw new Error('Unknown encoding: ' + encoding);
        }
      }

      // StringDecoder provides an interface for efficiently splitting a series of
      // buffers into a series of JS strings without breaking apart multi-byte
      // characters. CESU-8 is handled as part of the UTF-8 encoding.
      //
      // @TODO Handling all encodings inside a single object makes it very difficult
      // to reason about this code, so it should be split up in the future.
      // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
      // points as used by CESU-8.
      function StringDecoder(encoding) {
        this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
        assertEncoding(encoding);
        switch (this.encoding) {
          case 'utf8':
            // CESU-8 represents each of Surrogate Pair by 3-bytes
            this.surrogateSize = 3;
            break;
          case 'ucs2':
          case 'utf16le':
            // UTF-16 represents each of Surrogate Pair by 2-bytes
            this.surrogateSize = 2;
            this.detectIncompleteChar = utf16DetectIncompleteChar;
            break;
          case 'base64':
            // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
            this.surrogateSize = 3;
            this.detectIncompleteChar = base64DetectIncompleteChar;
            break;
          default:
            this.write = passThroughWrite;
            return;
        }

        // Enough space to store all bytes of a single character. UTF-8 needs 4
        // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
        this.charBuffer = new Buffer$1(6);
        // Number of bytes received for the current incomplete multi-byte character.
        this.charReceived = 0;
        // Number of bytes expected for the current incomplete multi-byte character.
        this.charLength = 0;
      }

      // write decodes the given buffer and returns it as JS string that is
      // guaranteed to not contain any partial multi-byte characters. Any partial
      // character found at the end of the buffer is buffered up, and will be
      // returned when calling write again with the remaining bytes.
      //
      // Note: Converting a Buffer containing an orphan surrogate to a String
      // currently works, but converting a String to a Buffer (via `new Buffer`, or
      // Buffer#write) will replace incomplete surrogates with the unicode
      // replacement character. See https://codereview.chromium.org/121173009/ .
      StringDecoder.prototype.write = function(buffer) {
        var charStr = '';
        // if our last write ended with an incomplete multibyte character
        while (this.charLength) {
          // determine how many remaining bytes this buffer has to offer for this char
          var available = (buffer.length >= this.charLength - this.charReceived) ?
              this.charLength - this.charReceived :
              buffer.length;

          // add the new bytes to the char buffer
          buffer.copy(this.charBuffer, this.charReceived, 0, available);
          this.charReceived += available;

          if (this.charReceived < this.charLength) {
            // still not enough chars in this buffer? wait for more ...
            return '';
          }

          // remove bytes belonging to the current character from the buffer
          buffer = buffer.slice(available, buffer.length);

          // get the character that was split
          charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

          // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
          var charCode = charStr.charCodeAt(charStr.length - 1);
          if (charCode >= 0xD800 && charCode <= 0xDBFF) {
            this.charLength += this.surrogateSize;
            charStr = '';
            continue;
          }
          this.charReceived = this.charLength = 0;

          // if there are no more bytes in this buffer, just emit our char
          if (buffer.length === 0) {
            return charStr;
          }
          break;
        }

        // determine and set charLength / charReceived
        this.detectIncompleteChar(buffer);

        var end = buffer.length;
        if (this.charLength) {
          // buffer the incomplete character bytes we got
          buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
          end -= this.charReceived;
        }

        charStr += buffer.toString(this.encoding, 0, end);

        var end = charStr.length - 1;
        var charCode = charStr.charCodeAt(end);
        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          var size = this.surrogateSize;
          this.charLength += size;
          this.charReceived += size;
          this.charBuffer.copy(this.charBuffer, size, 0, size);
          buffer.copy(this.charBuffer, 0, 0, size);
          return charStr.substring(0, end);
        }

        // or just emit the charStr
        return charStr;
      };

      // detectIncompleteChar determines if there is an incomplete UTF-8 character at
      // the end of the given buffer. If so, it sets this.charLength to the byte
      // length that character, and sets this.charReceived to the number of bytes
      // that are available for this character.
      StringDecoder.prototype.detectIncompleteChar = function(buffer) {
        // determine how many bytes we have to check at the end of this buffer
        var i = (buffer.length >= 3) ? 3 : buffer.length;

        // Figure out if one of the last i bytes of our buffer announces an
        // incomplete char.
        for (; i > 0; i--) {
          var c = buffer[buffer.length - i];

          // See http://en.wikipedia.org/wiki/UTF-8#Description

          // 110XXXXX
          if (i == 1 && c >> 5 == 0x06) {
            this.charLength = 2;
            break;
          }

          // 1110XXXX
          if (i <= 2 && c >> 4 == 0x0E) {
            this.charLength = 3;
            break;
          }

          // 11110XXX
          if (i <= 3 && c >> 3 == 0x1E) {
            this.charLength = 4;
            break;
          }
        }
        this.charReceived = i;
      };

      StringDecoder.prototype.end = function(buffer) {
        var res = '';
        if (buffer && buffer.length)
          res = this.write(buffer);

        if (this.charReceived) {
          var cr = this.charReceived;
          var buf = this.charBuffer;
          var enc = this.encoding;
          res += buf.slice(0, cr).toString(enc);
        }

        return res;
      };

      function passThroughWrite(buffer) {
        return buffer.toString(this.encoding);
      }

      function utf16DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 2;
        this.charLength = this.charReceived ? 2 : 0;
      }

      function base64DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 3;
        this.charLength = this.charReceived ? 3 : 0;
      }

      Readable.ReadableState = ReadableState;

      var debug = debuglog('stream');
      inherits$1(Readable, EventEmitter);

      function prependListener(emitter, event, fn) {
        // Sadly this is not cacheable as some libraries bundle their own
        // event emitter implementation with them.
        if (typeof emitter.prependListener === 'function') {
          return emitter.prependListener(event, fn);
        } else {
          // This is a hack to make sure that our error handler is attached before any
          // userland ones.  NEVER DO THIS. This is here only because this code needs
          // to continue to work with older versions of Node.js that do not include
          // the prependListener() method. The goal is to eventually remove this hack.
          if (!emitter._events || !emitter._events[event])
            emitter.on(event, fn);
          else if (Array.isArray(emitter._events[event]))
            emitter._events[event].unshift(fn);
          else
            emitter._events[event] = [fn, emitter._events[event]];
        }
      }
      function listenerCount (emitter, type) {
        return emitter.listeners(type).length;
      }
      function ReadableState(options, stream) {

        options = options || {};

        // object stream flag. Used to make read(n) ignore n and to
        // make all the buffer merging and length checks go away
        this.objectMode = !!options.objectMode;

        if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

        // the point at which it stops calling _read() to fill the buffer
        // Note: 0 is a valid value, means "don't call _read preemptively ever"
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

        // cast to ints.
        this.highWaterMark = ~ ~this.highWaterMark;

        // A linked list is used to store data chunks instead of an array because the
        // linked list can remove elements from the beginning faster than
        // array.shift()
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;

        // a flag to be able to tell if the onwrite cb is called immediately,
        // or on a later tick.  We set this to true at first, because any
        // actions that shouldn't happen until "later" should generally also
        // not happen before the first write call.
        this.sync = true;

        // whenever we return null, then we set a flag to say
        // that we're awaiting a 'readable' event emission.
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;

        // Crypto is kind of old and crusty.  Historically, its default string
        // encoding is 'binary' so we have to make this configurable.
        // Everything else in the universe uses 'utf8', though.
        this.defaultEncoding = options.defaultEncoding || 'utf8';

        // when piping, we only care about 'readable' events that happen
        // after read()ing all the bytes and not getting any pushback.
        this.ranOut = false;

        // the number of writers that are awaiting a drain event in .pipe()s
        this.awaitDrain = 0;

        // if true, a maybeReadMore has been scheduled
        this.readingMore = false;

        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable(options) {

        if (!(this instanceof Readable)) return new Readable(options);

        this._readableState = new ReadableState(options, this);

        // legacy
        this.readable = true;

        if (options && typeof options.read === 'function') this._read = options.read;

        EventEmitter.call(this);
      }

      // Manually shove something into the read() buffer.
      // This returns true if the highWaterMark has not been hit yet,
      // similar to how Writable.write() returns true if you should
      // write() some more.
      Readable.prototype.push = function (chunk, encoding) {
        var state = this._readableState;

        if (!state.objectMode && typeof chunk === 'string') {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer$1.from(chunk, encoding);
            encoding = '';
          }
        }

        return readableAddChunk(this, state, chunk, encoding, false);
      };

      // Unshift should *always* be something directly out of read()
      Readable.prototype.unshift = function (chunk) {
        var state = this._readableState;
        return readableAddChunk(this, state, chunk, '', true);
      };

      Readable.prototype.isPaused = function () {
        return this._readableState.flowing === false;
      };

      function readableAddChunk(stream, state, chunk, encoding, addToFront) {
        var er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit('error', er);
        } else if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (state.ended && !addToFront) {
            var e = new Error('stream.push() after EOF');
            stream.emit('error', e);
          } else if (state.endEmitted && addToFront) {
            var _e = new Error('stream.unshift() after end event');
            stream.emit('error', _e);
          } else {
            var skipAdd;
            if (state.decoder && !addToFront && !encoding) {
              chunk = state.decoder.write(chunk);
              skipAdd = !state.objectMode && chunk.length === 0;
            }

            if (!addToFront) state.reading = false;

            // Don't add to the buffer if we've decoded to an empty string chunk and
            // we're not in object mode
            if (!skipAdd) {
              // if we want the data now, just emit it.
              if (state.flowing && state.length === 0 && !state.sync) {
                stream.emit('data', chunk);
                stream.read(0);
              } else {
                // update the buffer info.
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

                if (state.needReadable) emitReadable(stream);
              }
            }

            maybeReadMore(stream, state);
          }
        } else if (!addToFront) {
          state.reading = false;
        }

        return needMoreData(state);
      }

      // if it's past the high water mark, we can push in some more.
      // Also, if we have no data yet, we can stand some
      // more bytes.  This is to work around cases where hwm=0,
      // such as the repl.  Also, if the push() triggered a
      // readable event, and the user called read(largeNumber) such that
      // needReadable was set, then we ought to push more, so that another
      // 'readable' event will be triggered.
      function needMoreData(state) {
        return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
      }

      // backwards compatibility.
      Readable.prototype.setEncoding = function (enc) {
        this._readableState.decoder = new StringDecoder(enc);
        this._readableState.encoding = enc;
        return this;
      };

      // Don't raise the hwm > 8MB
      var MAX_HWM = 0x800000;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          // Get the next highest power of 2 to prevent increasing hwm excessively in
          // tiny amounts
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }

      // This function is designed to be inlinable, so please take care when making
      // changes to the function body.
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended) return 0;
        if (state.objectMode) return 1;
        if (n !== n) {
          // Only flow one buffer at a time
          if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
        }
        // If we're asking for more than the current hwm, then raise the hwm.
        if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length) return n;
        // Don't have enough
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }

      // you can override either this method, or the async _read(n) below.
      Readable.prototype.read = function (n) {
        debug('read', n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;

        if (n !== 0) state.emittedReadable = false;

        // if we're doing read(0) to trigger a readable event, but we
        // already have a bunch of data in the buffer, then just trigger
        // the 'readable' event and move on.
        if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
          debug('read: emitReadable', state.length, state.ended);
          if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
          return null;
        }

        n = howMuchToRead(n, state);

        // if we've ended, and we're now clear, then finish it up.
        if (n === 0 && state.ended) {
          if (state.length === 0) endReadable(this);
          return null;
        }

        // All the actual chunk generation logic needs to be
        // *below* the call to _read.  The reason is that in certain
        // synthetic stream cases, such as passthrough streams, _read
        // may be a completely synchronous operation which may change
        // the state of the read buffer, providing enough data when
        // before there was *not* enough.
        //
        // So, the steps are:
        // 1. Figure out what the state of things will be after we do
        // a read from the buffer.
        //
        // 2. If that resulting state will trigger a _read, then call _read.
        // Note that this may be asynchronous, or synchronous.  Yes, it is
        // deeply ugly to write APIs this way, but that still doesn't mean
        // that the Readable class should behave improperly, as streams are
        // designed to be sync/async agnostic.
        // Take note if the _read call is sync or async (ie, if the read call
        // has returned yet), so that we know whether or not it's safe to emit
        // 'readable' etc.
        //
        // 3. Actually pull the requested chunks out of the buffer and return.

        // if we need a readable event, then we need to do some reading.
        var doRead = state.needReadable;
        debug('need readable', doRead);

        // if we currently have less than the highWaterMark, then also read some
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug('length less than watermark', doRead);
        }

        // however, if we've ended, then there's no point, and if we're already
        // reading, then it's unnecessary.
        if (state.ended || state.reading) {
          doRead = false;
          debug('reading or ended', doRead);
        } else if (doRead) {
          debug('do read');
          state.reading = true;
          state.sync = true;
          // if the length is currently zero, then we *need* a readable event.
          if (state.length === 0) state.needReadable = true;
          // call internal read method
          this._read(state.highWaterMark);
          state.sync = false;
          // If _read pushed data synchronously, then `reading` will be false,
          // and we need to re-evaluate how much data we can return to the user.
          if (!state.reading) n = howMuchToRead(nOrig, state);
        }

        var ret;
        if (n > 0) ret = fromList(n, state);else ret = null;

        if (ret === null) {
          state.needReadable = true;
          n = 0;
        } else {
          state.length -= n;
        }

        if (state.length === 0) {
          // If we have nothing in the buffer, then we want to know
          // as soon as we *do* get something into the buffer.
          if (!state.ended) state.needReadable = true;

          // If we tried to read() past the EOF, then emit end on the next tick.
          if (nOrig !== n && state.ended) endReadable(this);
        }

        if (ret !== null) this.emit('data', ret);

        return ret;
      };

      function chunkInvalid(state, chunk) {
        var er = null;
        if (!Buffer$1.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
          er = new TypeError('Invalid non-string/buffer chunk');
        }
        return er;
      }

      function onEofChunk(stream, state) {
        if (state.ended) return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;

        // emit 'readable' now to make sure it gets picked up.
        emitReadable(stream);
      }

      // Don't emit readable right away in sync mode, because this can trigger
      // another read() call => stack overflow.  This way, it might trigger
      // a nextTick recursion warning, but that's not so bad.
      function emitReadable(stream) {
        var state = stream._readableState;
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug('emitReadable', state.flowing);
          state.emittedReadable = true;
          if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);
        }
      }

      function emitReadable_(stream) {
        debug('emit readable');
        stream.emit('readable');
        flow(stream);
      }

      // at this point, the user has presumably seen the 'readable' event,
      // and called read() to consume some data.  that may have triggered
      // in turn another _read(n) call, in which case reading = true if
      // it's in progress.
      // However, if we're not ended, or reading, and the length < hwm,
      // then go ahead and try to read some more preemptively.
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          nextTick(maybeReadMore_, stream, state);
        }
      }

      function maybeReadMore_(stream, state) {
        var len = state.length;
        while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
          debug('maybeReadMore read 0');
          stream.read(0);
          if (len === state.length)
            // didn't get any data, stop spinning.
            break;else len = state.length;
        }
        state.readingMore = false;
      }

      // abstract method.  to be overridden in specific implementation classes.
      // call cb(er, data) where data is <= n in length.
      // for virtual (non-string, non-buffer) streams, "length" is somewhat
      // arbitrary, and perhaps not very meaningful.
      Readable.prototype._read = function (n) {
        this.emit('error', new Error('not implemented'));
      };

      Readable.prototype.pipe = function (dest, pipeOpts) {
        var src = this;
        var state = this._readableState;

        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

        var doEnd = (!pipeOpts || pipeOpts.end !== false);

        var endFn = doEnd ? onend : cleanup;
        if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);

        dest.on('unpipe', onunpipe);
        function onunpipe(readable) {
          debug('onunpipe');
          if (readable === src) {
            cleanup();
          }
        }

        function onend() {
          debug('onend');
          dest.end();
        }

        // when the dest drains, it reduces the awaitDrain counter
        // on the source.  This would be more elegant with a .once()
        // handler in flow(), but adding and removing repeatedly is
        // too slow.
        var ondrain = pipeOnDrain(src);
        dest.on('drain', ondrain);

        var cleanedUp = false;
        function cleanup() {
          debug('cleanup');
          // cleanup event handlers once the pipe is broken
          dest.removeListener('close', onclose);
          dest.removeListener('finish', onfinish);
          dest.removeListener('drain', ondrain);
          dest.removeListener('error', onerror);
          dest.removeListener('unpipe', onunpipe);
          src.removeListener('end', onend);
          src.removeListener('end', cleanup);
          src.removeListener('data', ondata);

          cleanedUp = true;

          // if the reader is waiting for a drain event from this
          // specific writer, then it would cause it to never start
          // flowing again.
          // So, if this is awaiting a drain, then we just call it now.
          // If we don't know, then assume that we are waiting for one.
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
        }

        // If the user pushes more data while we're writing to dest then we'll end up
        // in ondata again. However, we only want to increase awaitDrain once because
        // dest will only emit one 'drain' event for the multiple writes.
        // => Introduce a guard on increasing awaitDrain.
        var increasedAwaitDrain = false;
        src.on('data', ondata);
        function ondata(chunk) {
          debug('ondata');
          increasedAwaitDrain = false;
          var ret = dest.write(chunk);
          if (false === ret && !increasedAwaitDrain) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug('false write response, pause', src._readableState.awaitDrain);
              src._readableState.awaitDrain++;
              increasedAwaitDrain = true;
            }
            src.pause();
          }
        }

        // if the dest has an error, then stop piping into it.
        // however, don't suppress the throwing behavior for this.
        function onerror(er) {
          debug('onerror', er);
          unpipe();
          dest.removeListener('error', onerror);
          if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
        }

        // Make sure our error handler is attached before userland ones.
        prependListener(dest, 'error', onerror);

        // Both close and finish should trigger unpipe, but only once.
        function onclose() {
          dest.removeListener('finish', onfinish);
          unpipe();
        }
        dest.once('close', onclose);
        function onfinish() {
          debug('onfinish');
          dest.removeListener('close', onclose);
          unpipe();
        }
        dest.once('finish', onfinish);

        function unpipe() {
          debug('unpipe');
          src.unpipe(dest);
        }

        // tell the dest that it's being piped to
        dest.emit('pipe', src);

        // start the flow if it hasn't been started already.
        if (!state.flowing) {
          debug('pipe resume');
          src.resume();
        }

        return dest;
      };

      function pipeOnDrain(src) {
        return function () {
          var state = src._readableState;
          debug('pipeOnDrain', state.awaitDrain);
          if (state.awaitDrain) state.awaitDrain--;
          if (state.awaitDrain === 0 && src.listeners('data').length) {
            state.flowing = true;
            flow(src);
          }
        };
      }

      Readable.prototype.unpipe = function (dest) {
        var state = this._readableState;

        // if we're not piping anywhere, then do nothing.
        if (state.pipesCount === 0) return this;

        // just one destination.  most common case.
        if (state.pipesCount === 1) {
          // passed in one, but it's not the right one.
          if (dest && dest !== state.pipes) return this;

          if (!dest) dest = state.pipes;

          // got a match.
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest) dest.emit('unpipe', this);
          return this;
        }

        // slow case. multiple pipe destinations.

        if (!dest) {
          // remove all.
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;

          for (var _i = 0; _i < len; _i++) {
            dests[_i].emit('unpipe', this);
          }return this;
        }

        // try to find the right one.
        var i = indexOf(state.pipes, dest);
        if (i === -1) return this;

        state.pipes.splice(i, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1) state.pipes = state.pipes[0];

        dest.emit('unpipe', this);

        return this;
      };

      // set up data events if they are asked for
      // Ensure readable listeners eventually get something
      Readable.prototype.on = function (ev, fn) {
        var res = EventEmitter.prototype.on.call(this, ev, fn);

        if (ev === 'data') {
          // Start flowing on next tick if stream isn't explicitly paused
          if (this._readableState.flowing !== false) this.resume();
        } else if (ev === 'readable') {
          var state = this._readableState;
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
              nextTick(nReadingNextTick, this);
            } else if (state.length) {
              emitReadable(this);
            }
          }
        }

        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;

      function nReadingNextTick(self) {
        debug('readable nexttick read 0');
        self.read(0);
      }

      // pause() and resume() are remnants of the legacy readable stream API
      // If the user uses them, then switch into old mode.
      Readable.prototype.resume = function () {
        var state = this._readableState;
        if (!state.flowing) {
          debug('resume');
          state.flowing = true;
          resume(this, state);
        }
        return this;
      };

      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          nextTick(resume_, stream, state);
        }
      }

      function resume_(stream, state) {
        if (!state.reading) {
          debug('resume read 0');
          stream.read(0);
        }

        state.resumeScheduled = false;
        state.awaitDrain = 0;
        stream.emit('resume');
        flow(stream);
        if (state.flowing && !state.reading) stream.read(0);
      }

      Readable.prototype.pause = function () {
        debug('call pause flowing=%j', this._readableState.flowing);
        if (false !== this._readableState.flowing) {
          debug('pause');
          this._readableState.flowing = false;
          this.emit('pause');
        }
        return this;
      };

      function flow(stream) {
        var state = stream._readableState;
        debug('flow', state.flowing);
        while (state.flowing && stream.read() !== null) {}
      }

      // wrap an old-style stream as the async data source.
      // This is *not* part of the readable stream interface.
      // It is an ugly unfortunate mess of history.
      Readable.prototype.wrap = function (stream) {
        var state = this._readableState;
        var paused = false;

        var self = this;
        stream.on('end', function () {
          debug('wrapped end');
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) self.push(chunk);
          }

          self.push(null);
        });

        stream.on('data', function (chunk) {
          debug('wrapped data');
          if (state.decoder) chunk = state.decoder.write(chunk);

          // don't skip over falsy values in objectMode
          if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

          var ret = self.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });

        // proxy all the other methods.
        // important when wrapping filters and duplexes.
        for (var i in stream) {
          if (this[i] === undefined && typeof stream[i] === 'function') {
            this[i] = function (method) {
              return function () {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }

        // proxy certain important events.
        var events = ['error', 'close', 'destroy', 'pause', 'resume'];
        forEach(events, function (ev) {
          stream.on(ev, self.emit.bind(self, ev));
        });

        // when we try to consume some more bytes, simply unpause the
        // underlying stream.
        self._read = function (n) {
          debug('wrapped _read', n);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };

        return self;
      };

      // exposed for testing purposes only.
      Readable._fromList = fromList;

      // Pluck off n bytes from an array of buffers.
      // Length is the combined lengths of all the buffers in the list.
      // This function is designed to be inlinable, so please take care when making
      // changes to the function body.
      function fromList(n, state) {
        // nothing buffered
        if (state.length === 0) return null;

        var ret;
        if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
          // read it all, truncate the list
          if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          // read part of list
          ret = fromListPartial(n, state.buffer, state.decoder);
        }

        return ret;
      }

      // Extracts only enough buffered data to satisfy the amount requested.
      // This function is designed to be inlinable, so please take care when making
      // changes to the function body.
      function fromListPartial(n, list, hasStrings) {
        var ret;
        if (n < list.head.data.length) {
          // slice is the same for buffers and strings
          ret = list.head.data.slice(0, n);
          list.head.data = list.head.data.slice(n);
        } else if (n === list.head.data.length) {
          // first chunk is a perfect match
          ret = list.shift();
        } else {
          // result spans more than one buffer
          ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
        }
        return ret;
      }

      // Copies a specified amount of characters from the list of buffered data
      // chunks.
      // This function is designed to be inlinable, so please take care when making
      // changes to the function body.
      function copyFromBufferString(n, list) {
        var p = list.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) list.head = p.next;else list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        list.length -= c;
        return ret;
      }

      // Copies a specified amount of bytes from the list of buffered data chunks.
      // This function is designed to be inlinable, so please take care when making
      // changes to the function body.
      function copyFromBuffer(n, list) {
        var ret = Buffer$1.allocUnsafe(n);
        var p = list.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) list.head = p.next;else list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        list.length -= c;
        return ret;
      }

      function endReadable(stream) {
        var state = stream._readableState;

        // If we get here before consuming all the bytes, then that is a
        // bug in node.  Should never happen.
        if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

        if (!state.endEmitted) {
          state.ended = true;
          nextTick(endReadableNT, state, stream);
        }
      }

      function endReadableNT(state, stream) {
        // Check that we didn't get one last unshift.
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit('end');
        }
      }

      function forEach(xs, f) {
        for (var i = 0, l = xs.length; i < l; i++) {
          f(xs[i], i);
        }
      }

      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x) return i;
        }
        return -1;
      }

      // A bit simpler than readable streams.
      Writable.WritableState = WritableState;
      inherits$1(Writable, EventEmitter);

      function nop() {}

      function WriteReq(chunk, encoding, cb) {
        this.chunk = chunk;
        this.encoding = encoding;
        this.callback = cb;
        this.next = null;
      }

      function WritableState(options, stream) {
        Object.defineProperty(this, 'buffer', {
          get: deprecate(function () {
            return this.getBuffer();
          }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
        });
        options = options || {};

        // object stream flag to indicate whether or not this stream
        // contains buffers or objects.
        this.objectMode = !!options.objectMode;

        if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

        // the point at which write() starts returning false
        // Note: 0 is a valid value, means that we always return false if
        // the entire buffer is not flushed immediately on write()
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

        // cast to ints.
        this.highWaterMark = ~ ~this.highWaterMark;

        this.needDrain = false;
        // at the start of calling end()
        this.ending = false;
        // when end() has been called, and returned
        this.ended = false;
        // when 'finish' is emitted
        this.finished = false;

        // should we decode strings into buffers before passing to _write?
        // this is here so that some node-core streams can optimize string
        // handling at a lower level.
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;

        // Crypto is kind of old and crusty.  Historically, its default string
        // encoding is 'binary' so we have to make this configurable.
        // Everything else in the universe uses 'utf8', though.
        this.defaultEncoding = options.defaultEncoding || 'utf8';

        // not an actual buffer we keep track of, but a measurement
        // of how much we're waiting to get pushed to some underlying
        // socket or file.
        this.length = 0;

        // a flag to see when we're in the middle of a write.
        this.writing = false;

        // when true all writes will be buffered until .uncork() call
        this.corked = 0;

        // a flag to be able to tell if the onwrite cb is called immediately,
        // or on a later tick.  We set this to true at first, because any
        // actions that shouldn't happen until "later" should generally also
        // not happen before the first write call.
        this.sync = true;

        // a flag to know if we're processing previously buffered items, which
        // may call the _write() callback in the same tick, so that we don't
        // end up in an overlapped onwrite situation.
        this.bufferProcessing = false;

        // the callback that's passed to _write(chunk,cb)
        this.onwrite = function (er) {
          onwrite(stream, er);
        };

        // the callback that the user supplies to write(chunk,encoding,cb)
        this.writecb = null;

        // the amount that is being written when _write is called.
        this.writelen = 0;

        this.bufferedRequest = null;
        this.lastBufferedRequest = null;

        // number of pending user-supplied write callbacks
        // this must be 0 before 'finish' can be emitted
        this.pendingcb = 0;

        // emit prefinish if the only thing we're waiting for is _write cbs
        // This is relevant for synchronous Transform streams
        this.prefinished = false;

        // True if the error was already emitted and should not be thrown again
        this.errorEmitted = false;

        // count buffered requests
        this.bufferedRequestCount = 0;

        // allocate the first CorkedRequest, there is always
        // one allocated and free to use, and we maintain at most two
        this.corkedRequestsFree = new CorkedRequest(this);
      }

      WritableState.prototype.getBuffer = function writableStateGetBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      function Writable(options) {

        // Writable ctor is applied to Duplexes, though they're not
        // instanceof Writable, they're instanceof Readable.
        if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

        this._writableState = new WritableState(options, this);

        // legacy.
        this.writable = true;

        if (options) {
          if (typeof options.write === 'function') this._write = options.write;

          if (typeof options.writev === 'function') this._writev = options.writev;
        }

        EventEmitter.call(this);
      }

      // Otherwise people can pipe Writable streams, which is just wrong.
      Writable.prototype.pipe = function () {
        this.emit('error', new Error('Cannot pipe, not readable'));
      };

      function writeAfterEnd(stream, cb) {
        var er = new Error('write after end');
        // TODO: defer error events consistently everywhere, not just the cb
        stream.emit('error', er);
        nextTick(cb, er);
      }

      // If we get something that is not a buffer, string, null, or undefined,
      // and we're not in objectMode, then that's an error.
      // Otherwise stream chunks are all considered to be of length=1, and the
      // watermarks determine how many objects to keep in the buffer, rather than
      // how many bytes or characters.
      function validChunk(stream, state, chunk, cb) {
        var valid = true;
        var er = false;
        // Always throw error if a null is written
        // if we are not in object mode then throw
        // if it is not a buffer, string, or undefined.
        if (chunk === null) {
          er = new TypeError('May not write null values to stream');
        } else if (!Buffer$1.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
          er = new TypeError('Invalid non-string/buffer chunk');
        }
        if (er) {
          stream.emit('error', er);
          nextTick(cb, er);
          valid = false;
        }
        return valid;
      }

      Writable.prototype.write = function (chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;

        if (typeof encoding === 'function') {
          cb = encoding;
          encoding = null;
        }

        if (Buffer$1.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

        if (typeof cb !== 'function') cb = nop;

        if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, chunk, encoding, cb);
        }

        return ret;
      };

      Writable.prototype.cork = function () {
        var state = this._writableState;

        state.corked++;
      };

      Writable.prototype.uncork = function () {
        var state = this._writableState;

        if (state.corked) {
          state.corked--;

          if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
        }
      };

      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        // node::ParseEncoding() requires lower case.
        if (typeof encoding === 'string') encoding = encoding.toLowerCase();
        if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };

      function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
          chunk = Buffer$1.from(chunk, encoding);
        }
        return chunk;
      }

      // if we're already writing something, then just put this
      // in the queue, and wait our turn.  Otherwise, call _write
      // If we return false, then we need a drain event, so set that flag.
      function writeOrBuffer(stream, state, chunk, encoding, cb) {
        chunk = decodeChunk(state, chunk, encoding);

        if (Buffer$1.isBuffer(chunk)) encoding = 'buffer';
        var len = state.objectMode ? 1 : chunk.length;

        state.length += len;

        var ret = state.length < state.highWaterMark;
        // we must ensure that previous needDrain will not be reset to false.
        if (!ret) state.needDrain = true;

        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding, cb);
        }

        return ret;
      }

      function doWrite(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }

      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) nextTick(cb, er);else cb(er);

        stream._writableState.errorEmitted = true;
        stream.emit('error', er);
      }

      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }

      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;

        onwriteStateUpdate(state);

        if (er) onwriteError(stream, state, sync, er, cb);else {
          // Check if we're actually ready to finish, but don't emit yet
          var finished = needFinish(state);

          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }

          if (sync) {
            /*<replacement>*/
              nextTick(afterWrite, stream, state, finished, cb);
            /*</replacement>*/
          } else {
              afterWrite(stream, state, finished, cb);
            }
        }
      }

      function afterWrite(stream, state, finished, cb) {
        if (!finished) onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }

      // Must force callback to be called on nextTick, so that we don't
      // emit 'drain' before the write() consumer gets the 'false' return
      // value, and has a chance to attach a 'drain' listener.
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit('drain');
        }
      }

      // if there's something in the buffer waiting, then process it
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;

        if (stream._writev && entry && entry.next) {
          // Fast case, write everything using _writev()
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;

          var count = 0;
          while (entry) {
            buffer[count] = entry;
            entry = entry.next;
            count += 1;
          }

          doWrite(stream, state, true, state.length, buffer, '', holder.finish);

          // doWrite is almost always async, defer these to save a bit of time
          // as the hot path ends with doWrite
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
        } else {
          // Slow case, write chunks one-by-one
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;

            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) {
              break;
            }
          }

          if (entry === null) state.lastBufferedRequest = null;
        }

        state.bufferedRequestCount = 0;
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }

      Writable.prototype._write = function (chunk, encoding, cb) {
        cb(new Error('not implemented'));
      };

      Writable.prototype._writev = null;

      Writable.prototype.end = function (chunk, encoding, cb) {
        var state = this._writableState;

        if (typeof chunk === 'function') {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === 'function') {
          cb = encoding;
          encoding = null;
        }

        if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

        // .end() fully uncorks
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }

        // ignore unnecessary end() calls.
        if (!state.ending && !state.finished) endWritable(this, state, cb);
      };

      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }

      function prefinish(stream, state) {
        if (!state.prefinished) {
          state.prefinished = true;
          stream.emit('prefinish');
        }
      }

      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          if (state.pendingcb === 0) {
            prefinish(stream, state);
            state.finished = true;
            stream.emit('finish');
          } else {
            prefinish(stream, state);
          }
        }
        return need;
      }

      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished) nextTick(cb);else stream.once('finish', cb);
        }
        state.ended = true;
        stream.writable = false;
      }

      // It seems a linked list but it is not
      // there will be only 2 of these for each stream
      function CorkedRequest(state) {
        var _this = this;

        this.next = null;
        this.entry = null;

        this.finish = function (err) {
          var entry = _this.entry;
          _this.entry = null;
          while (entry) {
            var cb = entry.callback;
            state.pendingcb--;
            cb(err);
            entry = entry.next;
          }
          if (state.corkedRequestsFree) {
            state.corkedRequestsFree.next = _this;
          } else {
            state.corkedRequestsFree = _this;
          }
        };
      }

      inherits$1(Duplex, Readable);

      var keys = Object.keys(Writable.prototype);
      for (var v = 0; v < keys.length; v++) {
        var method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
      function Duplex(options) {
        if (!(this instanceof Duplex)) return new Duplex(options);

        Readable.call(this, options);
        Writable.call(this, options);

        if (options && options.readable === false) this.readable = false;

        if (options && options.writable === false) this.writable = false;

        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

        this.once('end', onend);
      }

      // the no-half-open enforcer
      function onend() {
        // if we allow half-open state, or if the writable side ended,
        // then we're ok.
        if (this.allowHalfOpen || this._writableState.ended) return;

        // no more data can be written.
        // But allow more writes to happen in this tick.
        nextTick(onEndNT, this);
      }

      function onEndNT(self) {
        self.end();
      }

      // a transform stream is a readable/writable stream where you do
      inherits$1(Transform, Duplex);

      function TransformState(stream) {
        this.afterTransform = function (er, data) {
          return afterTransform(stream, er, data);
        };

        this.needTransform = false;
        this.transforming = false;
        this.writecb = null;
        this.writechunk = null;
        this.writeencoding = null;
      }

      function afterTransform(stream, er, data) {
        var ts = stream._transformState;
        ts.transforming = false;

        var cb = ts.writecb;

        if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

        ts.writechunk = null;
        ts.writecb = null;

        if (data !== null && data !== undefined) stream.push(data);

        cb(er);

        var rs = stream._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          stream._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform)) return new Transform(options);

        Duplex.call(this, options);

        this._transformState = new TransformState(this);

        // when the writable side finishes, then flush out anything remaining.
        var stream = this;

        // start out asking for a readable event once data is transformed.
        this._readableState.needReadable = true;

        // we have implemented the _read method, and done the other things
        // that Readable wants before the first _read call, so unset the
        // sync guard flag.
        this._readableState.sync = false;

        if (options) {
          if (typeof options.transform === 'function') this._transform = options.transform;

          if (typeof options.flush === 'function') this._flush = options.flush;
        }

        this.once('prefinish', function () {
          if (typeof this._flush === 'function') this._flush(function (er) {
            done(stream, er);
          });else done(stream);
        });
      }

      Transform.prototype.push = function (chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };

      // This is the part where you do stuff!
      // override this function in implementation classes.
      // 'chunk' is an input chunk.
      //
      // Call `push(newChunk)` to pass along transformed output
      // to the readable side.  You may call 'push' zero or more times.
      //
      // Call `cb(err)` when you are done with this chunk.  If you pass
      // an error, then that'll put the hurt on the whole operation.  If you
      // never call cb(), then you'll never get another chunk.
      Transform.prototype._transform = function (chunk, encoding, cb) {
        throw new Error('Not implemented');
      };

      Transform.prototype._write = function (chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
        }
      };

      // Doesn't matter what the args are here.
      // _transform does all the work.
      // That we got here means that the readable side wants more data.
      Transform.prototype._read = function (n) {
        var ts = this._transformState;

        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          // mark that we need a transform, so that any data that comes in
          // will get processed, now that we've asked for it.
          ts.needTransform = true;
        }
      };

      function done(stream, er) {
        if (er) return stream.emit('error', er);

        // if there's nothing in the write buffer, then that means
        // that nothing more will ever be provided
        var ws = stream._writableState;
        var ts = stream._transformState;

        if (ws.length) throw new Error('Calling transform done when ws.length != 0');

        if (ts.transforming) throw new Error('Calling transform done when still transforming');

        return stream.push(null);
      }

      inherits$1(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough)) return new PassThrough(options);

        Transform.call(this, options);
      }

      PassThrough.prototype._transform = function (chunk, encoding, cb) {
        cb(null, chunk);
      };

      inherits$1(Stream, EventEmitter);
      Stream.Readable = Readable;
      Stream.Writable = Writable;
      Stream.Duplex = Duplex;
      Stream.Transform = Transform;
      Stream.PassThrough = PassThrough;

      // Backwards-compat with node 0.4.x
      Stream.Stream = Stream;

      // old-style streams.  Note that the pipe method (the only relevant
      // part of this class) is overridden in the Readable class.

      function Stream() {
        EventEmitter.call(this);
      }

      Stream.prototype.pipe = function(dest, options) {
        var source = this;

        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }

        source.on('data', ondata);

        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }

        dest.on('drain', ondrain);

        // If the 'end' option is not supplied, dest.end() will be called when
        // source gets the 'end' or 'close' events.  Only dest.end() once.
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on('end', onend);
          source.on('close', onclose);
        }

        var didOnEnd = false;
        function onend() {
          if (didOnEnd) return;
          didOnEnd = true;

          dest.end();
        }


        function onclose() {
          if (didOnEnd) return;
          didOnEnd = true;

          if (typeof dest.destroy === 'function') dest.destroy();
        }

        // don't leave dangling pipes when there are errors.
        function onerror(er) {
          cleanup();
          if (EventEmitter.listenerCount(this, 'error') === 0) {
            throw er; // Unhandled stream error in pipe.
          }
        }

        source.on('error', onerror);
        dest.on('error', onerror);

        // remove all the event listeners that were added.
        function cleanup() {
          source.removeListener('data', ondata);
          dest.removeListener('drain', ondrain);

          source.removeListener('end', onend);
          source.removeListener('close', onclose);

          source.removeListener('error', onerror);
          dest.removeListener('error', onerror);

          source.removeListener('end', cleanup);
          source.removeListener('close', cleanup);

          dest.removeListener('close', cleanup);
        }

        source.on('end', cleanup);
        source.on('close', cleanup);

        dest.on('close', cleanup);

        dest.emit('pipe', source);

        // Allow for unix-like usage: A.pipe(B).pipe(C)
        return dest;
      };

      var msg = {
        2:      'need dictionary',     /* Z_NEED_DICT       2  */
        1:      'stream end',          /* Z_STREAM_END      1  */
        0:      '',                    /* Z_OK              0  */
        '-1':   'file error',          /* Z_ERRNO         (-1) */
        '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
        '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
        '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
        '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
        '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
      };

      function ZStream() {
        /* next input byte */
        this.input = null; // JS specific, because we have no pointers
        this.next_in = 0;
        /* number of bytes available at input */
        this.avail_in = 0;
        /* total number of input bytes read so far */
        this.total_in = 0;
        /* next output byte should be put there */
        this.output = null; // JS specific, because we have no pointers
        this.next_out = 0;
        /* remaining free space at output */
        this.avail_out = 0;
        /* total number of bytes output so far */
        this.total_out = 0;
        /* last error message, NULL if no error */
        this.msg = ''/*Z_NULL*/;
        /* not visible by applications */
        this.state = null;
        /* best guess about the data type: binary or text */
        this.data_type = 2/*Z_UNKNOWN*/;
        /* adler32 value of the uncompressed data */
        this.adler = 0;
      }

      function arraySet(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        // Fallback to ordinary array
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      }


      var Buf8 = Uint8Array;
      var Buf16 = Uint16Array;
      var Buf32 = Int32Array;
      // Enable/Disable typed arrays use, for testing
      //

      /* Public constants ==========================================================*/
      /* ===========================================================================*/


      //var Z_FILTERED          = 1;
      //var Z_HUFFMAN_ONLY      = 2;
      //var Z_RLE               = 3;
      var Z_FIXED$2 = 4;
      //var Z_DEFAULT_STRATEGY  = 0;

      /* Possible values of the data_type field (though see inflate()) */
      var Z_BINARY$1 = 0;
      var Z_TEXT$1 = 1;
      //var Z_ASCII             = 1; // = Z_TEXT
      var Z_UNKNOWN$2 = 2;

      /*============================================================================*/


      function zero$1(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }

      // From zutil.h

      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      /* The three kinds of block type */

      var MIN_MATCH$1 = 3;
      var MAX_MATCH$1 = 258;
      /* The minimum and maximum match lengths */

      // From deflate.h
      /* ===========================================================================
       * Internal compression state.
       */

      var LENGTH_CODES$1 = 29;
      /* number of length codes, not counting the special END_BLOCK code */

      var LITERALS$2 = 256;
      /* number of literal bytes 0..255 */

      var L_CODES$1 = LITERALS$2 + 1 + LENGTH_CODES$1;
      /* number of Literal or Length codes, including the END_BLOCK code */

      var D_CODES$1 = 30;
      /* number of distance codes */

      var BL_CODES$1 = 19;
      /* number of codes used to transfer the bit lengths */

      var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
      /* maximum heap size */

      var MAX_BITS$1 = 15;
      /* All codes must not exceed MAX_BITS bits */

      var Buf_size = 16;
      /* size of bit buffer in bi_buf */


      /* ===========================================================================
       * Constants
       */

      var MAX_BL_BITS = 7;
      /* Bit length codes must not exceed MAX_BL_BITS bits */

      var END_BLOCK = 256;
      /* end of block literal code */

      var REP_3_6 = 16;
      /* repeat previous bit length 3-6 times (2 bits of repeat count) */

      var REPZ_3_10 = 17;
      /* repeat a zero length 3-10 times  (3 bits of repeat count) */

      var REPZ_11_138 = 18;
      /* repeat a zero length 11-138 times  (7 bits of repeat count) */

      /* eslint-disable comma-spacing,array-bracket-spacing */
      var extra_lbits = /* extra bits for each length code */ [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];

      var extra_dbits = /* extra bits for each distance code */ [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

      var extra_blbits = /* extra bits for each bit length code */ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];

      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      /* eslint-enable comma-spacing,array-bracket-spacing */

      /* The lengths of the bit length codes are sent in order of decreasing
       * probability, to avoid transmitting the lengths for unused bit length codes.
       */

      /* ===========================================================================
       * Local data. These are initialized only once.
       */

      // We pre-fill arrays with 0 to avoid uninitialized gaps

      var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

      // !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
      var static_ltree = new Array((L_CODES$1 + 2) * 2);
      zero$1(static_ltree);
      /* The static literal tree. Since the bit lengths are imposed, there is no
       * need for the L_CODES extra codes used during heap construction. However
       * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
       * below).
       */

      var static_dtree = new Array(D_CODES$1 * 2);
      zero$1(static_dtree);
      /* The static distance tree. (Actually a trivial tree since all codes use
       * 5 bits.)
       */

      var _dist_code = new Array(DIST_CODE_LEN);
      zero$1(_dist_code);
      /* Distance codes. The first 256 values correspond to the distances
       * 3 .. 258, the last 256 values correspond to the top 8 bits of
       * the 15 bit distances.
       */

      var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
      zero$1(_length_code);
      /* length code for each normalized match length (0 == MIN_MATCH) */

      var base_length = new Array(LENGTH_CODES$1);
      zero$1(base_length);
      /* First normalized length for each code (0 = MIN_MATCH) */

      var base_dist = new Array(D_CODES$1);
      zero$1(base_dist);
      /* First normalized distance for each code (0 = distance of 1) */


      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

        this.static_tree = static_tree; /* static tree or NULL */
        this.extra_bits = extra_bits; /* extra bits for each code or NULL */
        this.extra_base = extra_base; /* base index for extra_bits */
        this.elems = elems; /* max number of elements in the tree */
        this.max_length = max_length; /* max bit length for the codes */

        // show if `static_tree` has data or dummy - needed for monomorphic objects
        this.has_stree = static_tree && static_tree.length;
      }


      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;


      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree; /* the dynamic tree */
        this.max_code = 0; /* largest code with non zero frequency */
        this.stat_desc = stat_desc; /* the corresponding static tree */
      }



      function d_code(dist) {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
      }


      /* ===========================================================================
       * Output a short LSB first on the stream.
       * IN assertion: there is enough room in pendingBuf.
       */
      function put_short(s, w) {
        //    put_byte(s, (uch)((w) & 0xff));
        //    put_byte(s, (uch)((ush)(w) >> 8));
        s.pending_buf[s.pending++] = (w) & 0xff;
        s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
      }


      /* ===========================================================================
       * Send a value on a given number of bits.
       * IN assertion: length <= 16 and value fits in length bits.
       */
      function send_bits(s, value, length) {
        if (s.bi_valid > (Buf_size - length)) {
          s.bi_buf |= (value << s.bi_valid) & 0xffff;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> (Buf_size - s.bi_valid);
          s.bi_valid += length - Buf_size;
        } else {
          s.bi_buf |= (value << s.bi_valid) & 0xffff;
          s.bi_valid += length;
        }
      }


      function send_code(s, c, tree) {
        send_bits(s, tree[c * 2] /*.Code*/ , tree[c * 2 + 1] /*.Len*/ );
      }


      /* ===========================================================================
       * Reverse the first len bits of a code, using straightforward code (a faster
       * method would use a table)
       * IN assertion: 1 <= len <= 15
       */
      function bi_reverse(code, len) {
        var res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1;
        } while (--len > 0);
        return res >>> 1;
      }


      /* ===========================================================================
       * Flush the bit buffer, keeping at most 7 bits in it.
       */
      function bi_flush(s) {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0;

        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 0xff;
          s.bi_buf >>= 8;
          s.bi_valid -= 8;
        }
      }


      /* ===========================================================================
       * Compute the optimal bit lengths for a tree and update the total bit length
       * for the current block.
       * IN assertion: the fields freq and dad are set, heap[heap_max] and
       *    above are the tree nodes sorted by increasing frequency.
       * OUT assertions: the field len is set to the optimal bit length, the
       *     array bl_count contains the frequencies for each bit length.
       *     The length opt_len is updated; static_len is also updated if stree is
       *     not null.
       */
      function gen_bitlen(s, desc) {
      //    deflate_state *s;
      //    tree_desc *desc;    /* the tree descriptor */
        var tree = desc.dyn_tree;
        var max_code = desc.max_code;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var extra = desc.stat_desc.extra_bits;
        var base = desc.stat_desc.extra_base;
        var max_length = desc.stat_desc.max_length;
        var h; /* heap index */
        var n, m; /* iterate over the tree elements */
        var bits; /* bit length */
        var xbits; /* extra bits */
        var f; /* frequency */
        var overflow = 0; /* number of elements with bit length too large */

        for (bits = 0; bits <= MAX_BITS$1; bits++) {
          s.bl_count[bits] = 0;
        }

        /* In a first pass, compute the optimal bit lengths (which may
         * overflow in the case of the bit length tree).
         */
        tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0; /* root of the heap */

        for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
          n = s.heap[h];
          bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }
          tree[n * 2 + 1] /*.Len*/ = bits;
          /* We overwrite tree[n].Dad which is no longer needed */

          if (n > max_code) {
            continue;
          } /* not a leaf node */

          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base];
          }
          f = tree[n * 2] /*.Freq*/ ;
          s.opt_len += f * (bits + xbits);
          if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits);
          }
        }
        if (overflow === 0) {
          return;
        }

        // Trace((stderr,"\nbit length overflow\n"));
        /* This happens for example on obj2 and pic of the Calgary corpus */

        /* Find the first bit length which could increase: */
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--;
          }
          s.bl_count[bits]--; /* move one leaf down the tree */
          s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
          s.bl_count[max_length]--;
          /* The brother of the overflow item also moves one step up,
           * but this does not affect bl_count[max_length]
           */
          overflow -= 2;
        } while (overflow > 0);

        /* Now recompute all bit lengths, scanning in increasing frequency.
         * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
         * lengths instead of fixing only the wrong ones. This idea is taken
         * from 'ar' written by Haruhiko Okumura.)
         */
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h];
            if (m > max_code) {
              continue;
            }
            if (tree[m * 2 + 1] /*.Len*/ !== bits) {
              // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
              s.opt_len += (bits - tree[m * 2 + 1] /*.Len*/ ) * tree[m * 2] /*.Freq*/ ;
              tree[m * 2 + 1] /*.Len*/ = bits;
            }
            n--;
          }
        }
      }


      /* ===========================================================================
       * Generate the codes for a given tree and bit counts (which need not be
       * optimal).
       * IN assertion: the array bl_count contains the bit length statistics for
       * the given tree and the field len is set for all tree elements.
       * OUT assertion: the field code is set for all tree elements of non
       *     zero code length.
       */
      function gen_codes(tree, max_code, bl_count) {
      //    ct_data *tree;             /* the tree to decorate */
      //    int max_code;              /* largest code with non zero frequency */
      //    ushf *bl_count;            /* number of codes at each bit length */

        var next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
        var code = 0; /* running code value */
        var bits; /* bit index */
        var n; /* code index */

        /* The distribution counts are first used to generate the code values
         * without bit reversal.
         */
        for (bits = 1; bits <= MAX_BITS$1; bits++) {
          next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
        }
        /* Check that the bit counts in bl_count are consistent. The last code
         * must be all ones.
         */
        //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
        //        "inconsistent bit counts");
        //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

        for (n = 0; n <= max_code; n++) {
          var len = tree[n * 2 + 1] /*.Len*/ ;
          if (len === 0) {
            continue;
          }
          /* Now reverse the bits */
          tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len);

          //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
          //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
        }
      }


      /* ===========================================================================
       * Initialize the various 'constant' tables.
       */
      function tr_static_init() {
        var n; /* iterates over tree elements */
        var bits; /* bit counter */
        var length; /* length value */
        var code; /* code value */
        var dist; /* distance index */
        var bl_count = new Array(MAX_BITS$1 + 1);
        /* number of codes at each bit length for an optimal tree */

        // do check in _tr_init()
        //if (static_init_done) return;

        /* For some embedded targets, global variables are not initialized: */
        /*#ifdef NO_INIT_GLOBAL_POINTERS
          static_l_desc.static_tree = static_ltree;
          static_l_desc.extra_bits = extra_lbits;
          static_d_desc.static_tree = static_dtree;
          static_d_desc.extra_bits = extra_dbits;
          static_bl_desc.extra_bits = extra_blbits;
        #endif*/

        /* Initialize the mapping length (0..255) -> length code (0..28) */
        length = 0;
        for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
          base_length[code] = length;
          for (n = 0; n < (1 << extra_lbits[code]); n++) {
            _length_code[length++] = code;
          }
        }
        //Assert (length == 256, "tr_static_init: length != 256");
        /* Note that the length 255 (match length 258) can be represented
         * in two different ways: code 284 + 5 bits or code 285, so we
         * overwrite length_code[255] to use the best encoding:
         */
        _length_code[length - 1] = code;

        /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;
          for (n = 0; n < (1 << extra_dbits[code]); n++) {
            _dist_code[dist++] = code;
          }
        }
        //Assert (dist == 256, "tr_static_init: dist != 256");
        dist >>= 7; /* from now on, all distances are divided by 128 */
        for (; code < D_CODES$1; code++) {
          base_dist[code] = dist << 7;
          for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
            _dist_code[256 + dist++] = code;
          }
        }
        //Assert (dist == 256, "tr_static_init: 256+dist != 512");

        /* Construct the codes of the static literal tree */
        for (bits = 0; bits <= MAX_BITS$1; bits++) {
          bl_count[bits] = 0;
        }

        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] /*.Len*/ = 8;
          n++;
          bl_count[8]++;
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] /*.Len*/ = 9;
          n++;
          bl_count[9]++;
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] /*.Len*/ = 7;
          n++;
          bl_count[7]++;
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] /*.Len*/ = 8;
          n++;
          bl_count[8]++;
        }
        /* Codes 286 and 287 do not exist, but we must include them in the
         * tree construction to get a canonical Huffman tree (longest code
         * all ones)
         */
        gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

        /* The static distance tree is trivial: */
        for (n = 0; n < D_CODES$1; n++) {
          static_dtree[n * 2 + 1] /*.Len*/ = 5;
          static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5);
        }

        // Now data ready and we can init static trees
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$2 + 1, L_CODES$1, MAX_BITS$1);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);

        //static_init_done = true;
      }


      /* ===========================================================================
       * Initialize a new block.
       */
      function init_block(s) {
        var n; /* iterates over tree elements */

        /* Initialize the trees. */
        for (n = 0; n < L_CODES$1; n++) {
          s.dyn_ltree[n * 2] /*.Freq*/ = 0;
        }
        for (n = 0; n < D_CODES$1; n++) {
          s.dyn_dtree[n * 2] /*.Freq*/ = 0;
        }
        for (n = 0; n < BL_CODES$1; n++) {
          s.bl_tree[n * 2] /*.Freq*/ = 0;
        }

        s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0;
      }


      /* ===========================================================================
       * Flush the bit buffer and align the output on a byte boundary
       */
      function bi_windup(s) {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
          //put_byte(s, (Byte)s->bi_buf);
          s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
      }

      /* ===========================================================================
       * Copy a stored block, storing first the length and its
       * one's complement if requested.
       */
      function copy_block(s, buf, len, header) {
      //DeflateState *s;
      //charf    *buf;    /* the input data */
      //unsigned len;     /* its length */
      //int      header;  /* true if block header must be written */

        bi_windup(s); /* align on byte boundary */

        if (header) {
          put_short(s, len);
          put_short(s, ~len);
        }
        //  while (len--) {
        //    put_byte(s, *buf++);
        //  }
        arraySet(s.pending_buf, s.window, buf, len, s.pending);
        s.pending += len;
      }

      /* ===========================================================================
       * Compares to subtrees, using the tree depth as tie breaker when
       * the subtrees have equal frequency. This minimizes the worst case length.
       */
      function smaller(tree, n, m, depth) {
        var _n2 = n * 2;
        var _m2 = m * 2;
        return (tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ ||
          (tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m]));
      }

      /* ===========================================================================
       * Restore the heap property by moving down the tree starting at node k,
       * exchanging a node with the smallest of its two sons if necessary, stopping
       * when the heap property is re-established (each father smaller than its
       * two sons).
       */
      function pqdownheap(s, tree, k)
      //    deflate_state *s;
      //    ct_data *tree;  /* the tree to restore */
      //    int k;               /* node to move down */
      {
        var v = s.heap[k];
        var j = k << 1; /* left son of k */
        while (j <= s.heap_len) {
          /* Set j to the smallest of the two sons: */
          if (j < s.heap_len &&
            smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++;
          }
          /* Exit if v is smaller than both sons */
          if (smaller(tree, v, s.heap[j], s.depth)) {
            break;
          }

          /* Exchange v with the smallest son */
          s.heap[k] = s.heap[j];
          k = j;

          /* And continue down the tree, setting j to the left son of k */
          j <<= 1;
        }
        s.heap[k] = v;
      }


      // inlined manually
      // var SMALLEST = 1;

      /* ===========================================================================
       * Send the block data compressed using the given Huffman trees
       */
      function compress_block(s, ltree, dtree)
      //    deflate_state *s;
      //    const ct_data *ltree; /* literal tree */
      //    const ct_data *dtree; /* distance tree */
      {
        var dist; /* distance of matched string */
        var lc; /* match length or unmatched char (if dist == 0) */
        var lx = 0; /* running index in l_buf */
        var code; /* the code to send */
        var extra; /* number of extra bits to send */

        if (s.last_lit !== 0) {
          do {
            dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
            lc = s.pending_buf[s.l_buf + lx];
            lx++;

            if (dist === 0) {
              send_code(s, lc, ltree); /* send a literal byte */
              //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
            } else {
              /* Here, lc is the match length - MIN_MATCH */
              code = _length_code[lc];
              send_code(s, code + LITERALS$2 + 1, ltree); /* send the length code */
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra); /* send the extra length bits */
              }
              dist--; /* dist is now the match distance - 1 */
              code = d_code(dist);
              //Assert (code < D_CODES, "bad d_code");

              send_code(s, code, dtree); /* send the distance code */
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra); /* send the extra distance bits */
              }
            } /* literal or match pair ? */

            /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
            //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
            //       "pendingBuf overflow");

          } while (lx < s.last_lit);
        }

        send_code(s, END_BLOCK, ltree);
      }


      /* ===========================================================================
       * Construct one Huffman tree and assigns the code bit strings and lengths.
       * Update the total bit length for the current block.
       * IN assertion: the field freq is set for all tree elements.
       * OUT assertions: the fields len and code are set to the optimal bit length
       *     and corresponding code. The length opt_len is updated; static_len is
       *     also updated if stree is not null. The field max_code is set.
       */
      function build_tree(s, desc)
      //    deflate_state *s;
      //    tree_desc *desc; /* the tree descriptor */
      {
        var tree = desc.dyn_tree;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems = desc.stat_desc.elems;
        var n, m; /* iterate over heap elements */
        var max_code = -1; /* largest code with non zero frequency */
        var node; /* new node being created */

        /* Construct the initial heap, with least frequent element in
         * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
         * heap[0] is not used.
         */
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE$1;

        for (n = 0; n < elems; n++) {
          if (tree[n * 2] /*.Freq*/ !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;

          } else {
            tree[n * 2 + 1] /*.Len*/ = 0;
          }
        }

        /* The pkzip format requires that at least one distance code exists,
         * and that at least one bit should be sent even if there is only one
         * possible code. So to avoid special checks later on we force at least
         * two codes of non zero frequency.
         */
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
          tree[node * 2] /*.Freq*/ = 1;
          s.depth[node] = 0;
          s.opt_len--;

          if (has_stree) {
            s.static_len -= stree[node * 2 + 1] /*.Len*/ ;
          }
          /* node is 0 or 1 so it does not have extra bits */
        }
        desc.max_code = max_code;

        /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
         * establish sub-heaps of increasing lengths:
         */
        for (n = (s.heap_len >> 1 /*int /2*/ ); n >= 1; n--) {
          pqdownheap(s, tree, n);
        }

        /* Construct the Huffman tree by repeatedly combining the least two
         * frequent nodes.
         */
        node = elems; /* next internal node of the tree */
        do {
          //pqremove(s, tree, n);  /* n = node of least frequency */
          /*** pqremove ***/
          n = s.heap[1 /*SMALLEST*/ ];
          s.heap[1 /*SMALLEST*/ ] = s.heap[s.heap_len--];
          pqdownheap(s, tree, 1 /*SMALLEST*/ );
          /***/

          m = s.heap[1 /*SMALLEST*/ ]; /* m = node of next least frequency */

          s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
          s.heap[--s.heap_max] = m;

          /* Create a new node father of n and m */
          tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/ ;
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node;

          /* and insert the new node in the heap */
          s.heap[1 /*SMALLEST*/ ] = node++;
          pqdownheap(s, tree, 1 /*SMALLEST*/ );

        } while (s.heap_len >= 2);

        s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/ ];

        /* At this point, the fields freq and dad are set. We can now
         * generate the bit lengths.
         */
        gen_bitlen(s, desc);

        /* The field len is now set, we can generate the bit codes */
        gen_codes(tree, max_code, s.bl_count);
      }


      /* ===========================================================================
       * Scan a literal or distance tree to determine the frequencies of the codes
       * in the bit length tree.
       */
      function scan_tree(s, tree, max_code)
      //    deflate_state *s;
      //    ct_data *tree;   /* the tree to be scanned */
      //    int max_code;    /* and its largest code of non zero frequency */
      {
        var n; /* iterates over all tree elements */
        var prevlen = -1; /* last emitted length */
        var curlen; /* length of current code */

        var nextlen = tree[0 * 2 + 1] /*.Len*/ ; /* length of next code */

        var count = 0; /* repeat count of the current code */
        var max_count = 7; /* max repeat count */
        var min_count = 4; /* min repeat count */

        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff; /* guard */

        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;

          if (++count < max_count && curlen === nextlen) {
            continue;

          } else if (count < min_count) {
            s.bl_tree[curlen * 2] /*.Freq*/ += count;

          } else if (curlen !== 0) {

            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2] /*.Freq*/ ++;
            }
            s.bl_tree[REP_3_6 * 2] /*.Freq*/ ++;

          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2] /*.Freq*/ ++;

          } else {
            s.bl_tree[REPZ_11_138 * 2] /*.Freq*/ ++;
          }

          count = 0;
          prevlen = curlen;

          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;

          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;

          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }


      /* ===========================================================================
       * Send a literal or distance tree in compressed form, using the codes in
       * bl_tree.
       */
      function send_tree(s, tree, max_code)
      //    deflate_state *s;
      //    ct_data *tree; /* the tree to be scanned */
      //    int max_code;       /* and its largest code of non zero frequency */
      {
        var n; /* iterates over all tree elements */
        var prevlen = -1; /* last emitted length */
        var curlen; /* length of current code */

        var nextlen = tree[0 * 2 + 1] /*.Len*/ ; /* length of next code */

        var count = 0; /* repeat count of the current code */
        var max_count = 7; /* max repeat count */
        var min_count = 4; /* min repeat count */

        /* tree[max_code+1].Len = -1; */
        /* guard already set */
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }

        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;

          if (++count < max_count && curlen === nextlen) {
            continue;

          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree);
            } while (--count !== 0);

          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--;
            }
            //Assert(count >= 3 && count <= 6, " 3_6?");
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2);

          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3);

          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7);
          }

          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;

          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;

          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }


      /* ===========================================================================
       * Construct the Huffman tree for the bit lengths and return the index in
       * bl_order of the last bit length code to send.
       */
      function build_bl_tree(s) {
        var max_blindex; /* index of last bit length code of non zero freq */

        /* Determine the bit length frequencies for literal and distance trees */
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

        /* Build the bit length tree: */
        build_tree(s, s.bl_desc);
        /* opt_len now includes the length of the tree representations, except
         * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
         */

        /* Determine the number of bit length codes to send. The pkzip format
         * requires that at least 4 bit length codes be sent. (appnote.txt says
         * 3 but the actual value used is 4.)
         */
        for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {
            break;
          }
        }
        /* Update opt_len to include the bit length tree and counts */
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
        //        s->opt_len, s->static_len));

        return max_blindex;
      }


      /* ===========================================================================
       * Send the header for a block using dynamic Huffman trees: the counts, the
       * lengths of the bit length codes, the literal tree and the distance tree.
       * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
       */
      function send_all_trees(s, lcodes, dcodes, blcodes)
      //    deflate_state *s;
      //    int lcodes, dcodes, blcodes; /* number of codes for each tree */
      {
        var rank; /* index in bl_order */

        //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
        //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
        //        "too many codes");
        //Tracev((stderr, "\nbl counts: "));
        send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */
        for (rank = 0; rank < blcodes; rank++) {
          //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/ , 3);
        }
        //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

        send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
        //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

        send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
        //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
      }


      /* ===========================================================================
       * Check if the data type is TEXT or BINARY, using the following algorithm:
       * - TEXT if the two conditions below are satisfied:
       *    a) There are no non-portable control characters belonging to the
       *       "black list" (0..6, 14..25, 28..31).
       *    b) There is at least one printable character belonging to the
       *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
       * - BINARY otherwise.
       * - The following partially-portable control characters form a
       *   "gray list" that is ignored in this detection algorithm:
       *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
       * IN assertion: the fields Freq of dyn_ltree are set.
       */
      function detect_data_type(s) {
        /* black_mask is the bit mask of black-listed bytes
         * set bits 0..6, 14..25, and 28..31
         * 0xf3ffc07f = binary 11110011111111111100000001111111
         */
        var black_mask = 0xf3ffc07f;
        var n;

        /* Check for non-textual ("black-listed") bytes. */
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
          if ((black_mask & 1) && (s.dyn_ltree[n * 2] /*.Freq*/ !== 0)) {
            return Z_BINARY$1;
          }
        }

        /* Check for textual ("white-listed") bytes. */
        if (s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 ||
          s.dyn_ltree[13 * 2] /*.Freq*/ !== 0) {
          return Z_TEXT$1;
        }
        for (n = 32; n < LITERALS$2; n++) {
          if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
            return Z_TEXT$1;
          }
        }

        /* There are no "black-listed" or "white-listed" bytes:
         * this stream either is empty or has tolerated ("gray-listed") bytes only.
         */
        return Z_BINARY$1;
      }


      var static_init_done = false;

      /* ===========================================================================
       * Initialize the tree data structures for a new zlib stream.
       */
      function _tr_init(s) {

        if (!static_init_done) {
          tr_static_init();
          static_init_done = true;
        }

        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

        s.bi_buf = 0;
        s.bi_valid = 0;

        /* Initialize the first block of the first file: */
        init_block(s);
      }


      /* ===========================================================================
       * Send a stored block
       */
      function _tr_stored_block(s, buf, stored_len, last)
      //DeflateState *s;
      //charf *buf;       /* input block */
      //ulg stored_len;   /* length of input block */
      //int last;         /* one if this is the last block for a file */
      {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */
        copy_block(s, buf, stored_len, true); /* with header */
      }


      /* ===========================================================================
       * Send one empty static block to give enough lookahead for inflate.
       * This takes 10 bits, of which 7 may remain in the bit buffer.
       */
      function _tr_align(s) {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
      }


      /* ===========================================================================
       * Determine the best encoding for the current block: dynamic trees, static
       * trees or store, and output the encoded block to the zip file.
       */
      function _tr_flush_block(s, buf, stored_len, last)
      //DeflateState *s;
      //charf *buf;       /* input block, or NULL if too old */
      //ulg stored_len;   /* length of input block */
      //int last;         /* one if this is the last block for a file */
      {
        var opt_lenb, static_lenb; /* opt_len and static_len in bytes */
        var max_blindex = 0; /* index of last bit length code of non zero freq */

        /* Build the Huffman trees unless a stored block is forced */
        if (s.level > 0) {

          /* Check if the file is binary or text */
          if (s.strm.data_type === Z_UNKNOWN$2) {
            s.strm.data_type = detect_data_type(s);
          }

          /* Construct the literal and distance trees */
          build_tree(s, s.l_desc);
          // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
          //        s->static_len));

          build_tree(s, s.d_desc);
          // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
          //        s->static_len));
          /* At this point, opt_len and static_len are the total bit lengths of
           * the compressed block data, excluding the tree representations.
           */

          /* Build the bit length tree for the above two trees, and get the index
           * in bl_order of the last bit length code to send.
           */
          max_blindex = build_bl_tree(s);

          /* Determine the best encoding. Compute the block lengths in bytes. */
          opt_lenb = (s.opt_len + 3 + 7) >>> 3;
          static_lenb = (s.static_len + 3 + 7) >>> 3;

          // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
          //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
          //        s->last_lit));

          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }

        } else {
          // Assert(buf != (char*)0, "lost buf");
          opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
        }

        if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
          /* 4: two words for the lengths */

          /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
           * Otherwise we can't have processed more than WSIZE input bytes since
           * the last block flush, because compression would have been
           * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
           * transform a block into a stored block.
           */
          _tr_stored_block(s, buf, stored_len, last);

        } else if (s.strategy === Z_FIXED$2 || static_lenb === opt_lenb) {

          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree);

        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
        /* The above check is made mod 2^32, for files larger than 512 MB
         * and uLong implemented on 32 bits.
         */
        init_block(s);

        if (last) {
          bi_windup(s);
        }
        // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
        //       s->compressed_len-7*last));
      }

      /* ===========================================================================
       * Save the match info and tally the frequency counts. Return true if
       * the current block must be flushed.
       */
      function _tr_tally(s, dist, lc)
      //    deflate_state *s;
      //    unsigned dist;  /* distance of matched string */
      //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
      {
        //var out_length, in_length, dcode;

        s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

        s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
        s.last_lit++;

        if (dist === 0) {
          /* lc is the unmatched char */
          s.dyn_ltree[lc * 2] /*.Freq*/ ++;
        } else {
          s.matches++;
          /* Here, lc is the match length - MIN_MATCH */
          dist--; /* dist = match distance - 1 */
          //Assert((ush)dist < (ush)MAX_DIST(s) &&
          //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
          //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

          s.dyn_ltree[(_length_code[lc] + LITERALS$2 + 1) * 2] /*.Freq*/ ++;
          s.dyn_dtree[d_code(dist) * 2] /*.Freq*/ ++;
        }

        // (!) This block is disabled in zlib defailts,
        // don't enable it for binary compatibility

        //#ifdef TRUNCATE_BLOCK
        //  /* Try to guess if it is profitable to stop the current block here */
        //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
        //    /* Compute an upper bound for the compressed length */
        //    out_length = s.last_lit*8;
        //    in_length = s.strstart - s.block_start;
        //
        //    for (dcode = 0; dcode < D_CODES; dcode++) {
        //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
        //    }
        //    out_length >>>= 3;
        //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
        //    //       s->last_lit, in_length, out_length,
        //    //       100L - out_length*100L/in_length));
        //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
        //      return true;
        //    }
        //  }
        //#endif

        return (s.last_lit === s.lit_bufsize - 1);
        /* We avoid equality with lit_bufsize because of wraparound at 64K
         * on 16 bit machines and because stored blocks are restricted to
         * 64K-1 bytes.
         */
      }

      // Note: adler32 takes 12% for level 0 and 2% for level 6.
      // It doesn't worth to make additional optimizationa as in original.
      // Small size is preferable.

      function adler32(adler, buf, len, pos) {
        var s1 = (adler & 0xffff) |0,
            s2 = ((adler >>> 16) & 0xffff) |0,
            n = 0;

        while (len !== 0) {
          // Set limit ~ twice less than 5552, to keep
          // s2 in 31-bits, because we force signed ints.
          // in other case %= will fail.
          n = len > 2000 ? 2000 : len;
          len -= n;

          do {
            s1 = (s1 + buf[pos++]) |0;
            s2 = (s2 + s1) |0;
          } while (--n);

          s1 %= 65521;
          s2 %= 65521;
        }

        return (s1 | (s2 << 16)) |0;
      }

      // Note: we can't get significant speed boost here.
      // So write code to minimize size - no pregenerated tables
      // and array tools dependencies.


      // Use ordinary array, since untyped makes no boost here
      function makeTable() {
        var c, table = [];

        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
          }
          table[n] = c;
        }

        return table;
      }

      // Create table on load. Just 255 signed longs. Not a problem.
      var crcTable = makeTable();


      function crc32(crc, buf, len, pos) {
        var t = crcTable,
            end = pos + len;

        crc ^= -1;

        for (var i = pos; i < end; i++) {
          crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
        }

        return (crc ^ (-1)); // >>> 0;
      }

      /* Public constants ==========================================================*/
      /* ===========================================================================*/


      /* Allowed flush values; see deflate() and inflate() below for details */
      var Z_NO_FLUSH$1 = 0;
      var Z_PARTIAL_FLUSH$1 = 1;
      //var Z_SYNC_FLUSH    = 2;
      var Z_FULL_FLUSH$1 = 3;
      var Z_FINISH$2 = 4;
      var Z_BLOCK$2 = 5;
      //var Z_TREES         = 6;


      /* Return codes for the compression/decompression functions. Negative values
       * are errors, positive values are used for special but normal events.
       */
      var Z_OK$2 = 0;
      var Z_STREAM_END$2 = 1;
      //var Z_NEED_DICT     = 2;
      //var Z_ERRNO         = -1;
      var Z_STREAM_ERROR$2 = -2;
      var Z_DATA_ERROR$2 = -3;
      //var Z_MEM_ERROR     = -4;
      var Z_BUF_ERROR$2 = -5;
      //var Z_VERSION_ERROR = -6;


      /* compression levels */
      //var Z_NO_COMPRESSION      = 0;
      //var Z_BEST_SPEED          = 1;
      //var Z_BEST_COMPRESSION    = 9;
      var Z_DEFAULT_COMPRESSION$1 = -1;


      var Z_FILTERED$1 = 1;
      var Z_HUFFMAN_ONLY$1 = 2;
      var Z_RLE$1 = 3;
      var Z_FIXED$1 = 4;

      /* Possible values of the data_type field (though see inflate()) */
      //var Z_BINARY              = 0;
      //var Z_TEXT                = 1;
      //var Z_ASCII               = 1; // = Z_TEXT
      var Z_UNKNOWN$1 = 2;


      /* The deflate compression method */
      var Z_DEFLATED$2 = 8;

      /*============================================================================*/


      var MAX_MEM_LEVEL = 9;


      var LENGTH_CODES = 29;
      /* number of length codes, not counting the special END_BLOCK code */
      var LITERALS$1 = 256;
      /* number of literal bytes 0..255 */
      var L_CODES = LITERALS$1 + 1 + LENGTH_CODES;
      /* number of Literal or Length codes, including the END_BLOCK code */
      var D_CODES = 30;
      /* number of distance codes */
      var BL_CODES = 19;
      /* number of codes used to transfer the bit lengths */
      var HEAP_SIZE = 2 * L_CODES + 1;
      /* maximum heap size */
      var MAX_BITS = 15;
      /* All codes must not exceed MAX_BITS bits */

      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

      var PRESET_DICT = 0x20;

      var INIT_STATE = 42;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;

      var BS_NEED_MORE = 1; /* block not completed, need more input or more output */
      var BS_BLOCK_DONE = 2; /* block flush performed */
      var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
      var BS_FINISH_DONE = 4; /* finish done, accept no more input or output */

      var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

      function err(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode;
      }

      function rank(f) {
        return ((f) << 1) - ((f) > 4 ? 9 : 0);
      }

      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }


      /* =========================================================================
       * Flush as much pending output as possible. All deflate() output goes
       * through this function so some applications may wish to modify it
       * to avoid allocating a large strm->output buffer and copying into it.
       * (See also read_buf()).
       */
      function flush_pending(strm) {
        var s = strm.state;

        //_tr_flush_bits(s);
        var len = s.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out;
        }
        if (len === 0) {
          return;
        }

        arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
          s.pending_out = 0;
        }
      }


      function flush_block_only(s, last) {
        _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
      }


      function put_byte(s, b) {
        s.pending_buf[s.pending++] = b;
      }


      /* =========================================================================
       * Put a short in the pending buffer. The 16-bit value is put in MSB order.
       * IN assertion: the stream state is correct and there is enough room in
       * pending_buf.
       */
      function putShortMSB(s, b) {
        //  put_byte(s, (Byte)(b >> 8));
        //  put_byte(s, (Byte)(b & 0xff));
        s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
        s.pending_buf[s.pending++] = b & 0xff;
      }


      /* ===========================================================================
       * Read a new buffer from the current input stream, update the adler32
       * and total number of bytes read.  All deflate() input goes through
       * this function so some applications may wish to modify it to avoid
       * allocating a large strm->input buffer and copying from it.
       * (See also flush_pending()).
       */
      function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;

        if (len > size) {
          len = size;
        }
        if (len === 0) {
          return 0;
        }

        strm.avail_in -= len;

        // zmemcpy(buf, strm->next_in, len);
        arraySet(buf, strm.input, strm.next_in, len, start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len, start);
        }

        strm.next_in += len;
        strm.total_in += len;

        return len;
      }


      /* ===========================================================================
       * Set match_start to the longest match starting at the given string and
       * return its length. Matches shorter or equal to prev_length are discarded,
       * in which case the result is equal to prev_length and match_start is
       * garbage.
       * IN assertions: cur_match is the head of the hash chain for the current
       *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
       * OUT assertion: the match length is not greater than s->lookahead.
       */
      function longest_match(s, cur_match) {
        var chain_length = s.max_chain_length; /* max hash chain length */
        var scan = s.strstart; /* current string */
        var match; /* matched string */
        var len; /* length of current match */
        var best_len = s.prev_length; /* best match length so far */
        var nice_match = s.nice_match; /* stop if match long enough */
        var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
          s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/ ;

        var _win = s.window; // shortcut

        var wmask = s.w_mask;
        var prev = s.prev;

        /* Stop when cur_match becomes <= limit. To simplify the code,
         * we prevent matches with the string of window index 0.
         */

        var strend = s.strstart + MAX_MATCH;
        var scan_end1 = _win[scan + best_len - 1];
        var scan_end = _win[scan + best_len];

        /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
         * It is easy to get rid of this optimization if necessary.
         */
        // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

        /* Do not waste too much time if we already have a good match: */
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2;
        }
        /* Do not look for matches beyond the end of the input. This is necessary
         * to make deflate deterministic.
         */
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead;
        }

        // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

        do {
          // Assert(cur_match < s->strstart, "no future");
          match = cur_match;

          /* Skip to next match if the match length cannot increase
           * or if the match length is less than 2.  Note that the checks below
           * for insufficient lookahead only occur occasionally for performance
           * reasons.  Therefore uninitialized memory will be accessed, and
           * conditional jumps will be made that depend on those values.
           * However the length of the match is limited to the lookahead, so
           * the output of deflate is not affected by the uninitialized values.
           */

          if (_win[match + best_len] !== scan_end ||
            _win[match + best_len - 1] !== scan_end1 ||
            _win[match] !== _win[scan] ||
            _win[++match] !== _win[scan + 1]) {
            continue;
          }

          /* The check at best_len-1 can be removed because it will be made
           * again later. (This heuristic is not always a win.)
           * It is not necessary to compare scan[2] and match[2] since they
           * are always equal when the other bytes match, given that
           * the hash keys are equal and that HASH_BITS >= 8.
           */
          scan += 2;
          match++;
          // Assert(*scan == *match, "match[2]?");

          /* We check for insufficient lookahead only every 8th comparison;
           * the 256th check will be made at strstart+258.
           */
          do {
            /*jshint noempty:false*/
          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            scan < strend);

          // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;

          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

        if (best_len <= s.lookahead) {
          return best_len;
        }
        return s.lookahead;
      }


      /* ===========================================================================
       * Fill the window when the lookahead becomes insufficient.
       * Updates strstart and lookahead.
       *
       * IN assertion: lookahead < MIN_LOOKAHEAD
       * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
       *    At least one byte has been read, or avail_in == 0; reads are
       *    performed for at least two bytes (required for the zip translate_eol
       *    option -- not supported here).
       */
      function fill_window(s) {
        var _w_size = s.w_size;
        var p, n, m, more, str;

        //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

        do {
          more = s.window_size - s.lookahead - s.strstart;

          // JS ints have 32 bit, block below not needed
          /* Deal with !@#$% 64K limit: */
          //if (sizeof(int) <= 2) {
          //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
          //        more = wsize;
          //
          //  } else if (more == (unsigned)(-1)) {
          //        /* Very unlikely, but possible on 16 bit machine if
          //         * strstart == 0 && lookahead == 1 (input done a byte at time)
          //         */
          //        more--;
          //    }
          //}


          /* If the window is almost full and there is insufficient lookahead,
           * move the upper half to the lower one to make room in the upper half.
           */
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

            arraySet(s.window, s.window, _w_size, _w_size, 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            /* we now have strstart >= MAX_DIST */
            s.block_start -= _w_size;

            /* Slide the hash table (could be avoided with 32 bit values
             at the expense of memory usage). We slide even when level == 0
             to keep the hash table consistent if we switch back to level > 0
             later. (Using level 0 permanently is not an optimal usage of
             zlib, so we don't care about this pathological case.)
             */

            n = s.hash_size;
            p = n;
            do {
              m = s.head[--p];
              s.head[p] = (m >= _w_size ? m - _w_size : 0);
            } while (--n);

            n = _w_size;
            p = n;
            do {
              m = s.prev[--p];
              s.prev[p] = (m >= _w_size ? m - _w_size : 0);
              /* If n is not on any hash chain, prev[n] is garbage but
               * its value will never be used.
               */
            } while (--n);

            more += _w_size;
          }
          if (s.strm.avail_in === 0) {
            break;
          }

          /* If there was no sliding:
           *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
           *    more == window_size - lookahead - strstart
           * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
           * => more >= window_size - 2*WSIZE + 2
           * In the BIG_MEM or MMAP case (not yet supported),
           *   window_size == input_size + MIN_LOOKAHEAD  &&
           *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
           * Otherwise, window_size == 2*WSIZE so more >= 2.
           * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
           */
          //Assert(more >= 2, "more < 2");
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;

          /* Initialize the hash value now that we have some input: */
          if (s.lookahead + s.insert >= MIN_MATCH) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];

            /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
            //#if MIN_MATCH != 3
            //        Call update_hash() MIN_MATCH-3 more times
            //#endif
            while (s.insert) {
              /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH) {
                break;
              }
            }
          }
          /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
           * but this is not important since only literal bytes will be emitted.
           */

        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

        /* If the WIN_INIT bytes after the end of the current data have never been
         * written, then zero those bytes in order to avoid memory check reports of
         * the use of uninitialized (or uninitialised as Julian writes) bytes by
         * the longest match routines.  Update the high water mark for the next
         * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
         * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
         */
        //  if (s.high_water < s.window_size) {
        //    var curr = s.strstart + s.lookahead;
        //    var init = 0;
        //
        //    if (s.high_water < curr) {
        //      /* Previous high water mark below current data -- zero WIN_INIT
        //       * bytes or up to end of window, whichever is less.
        //       */
        //      init = s.window_size - curr;
        //      if (init > WIN_INIT)
        //        init = WIN_INIT;
        //      zmemzero(s->window + curr, (unsigned)init);
        //      s->high_water = curr + init;
        //    }
        //    else if (s->high_water < (ulg)curr + WIN_INIT) {
        //      /* High water mark at or above current data, but below current data
        //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
        //       * to end of window, whichever is less.
        //       */
        //      init = (ulg)curr + WIN_INIT - s->high_water;
        //      if (init > s->window_size - s->high_water)
        //        init = s->window_size - s->high_water;
        //      zmemzero(s->window + s->high_water, (unsigned)init);
        //      s->high_water += init;
        //    }
        //  }
        //
        //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
        //    "not enough room for search");
      }

      /* ===========================================================================
       * Copy without compression as much as possible from the input stream, return
       * the current block state.
       * This function does not insert new strings in the dictionary since
       * uncompressible data is probably not useful. This function is used
       * only for the level=0 compression option.
       * NOTE: this function should be optimized to avoid extra copying from
       * window to pending_buf.
       */
      function deflate_stored(s, flush) {
        /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
         * to pending_buf_size, and each stored block has a 5 byte header:
         */
        var max_block_size = 0xffff;

        if (max_block_size > s.pending_buf_size - 5) {
          max_block_size = s.pending_buf_size - 5;
        }

        /* Copy as much as possible from input to output: */
        for (;;) {
          /* Fill the window as much as possible: */
          if (s.lookahead <= 1) {

            //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
            //  s->block_start >= (long)s->w_size, "slide too late");
            //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
            //        s.block_start >= s.w_size)) {
            //        throw  new Error("slide too late");
            //      }

            fill_window(s);
            if (s.lookahead === 0 && flush === Z_NO_FLUSH$1) {
              return BS_NEED_MORE;
            }

            if (s.lookahead === 0) {
              break;
            }
            /* flush the current block */
          }
          //Assert(s->block_start >= 0L, "block gone");
          //    if (s.block_start < 0) throw new Error("block gone");

          s.strstart += s.lookahead;
          s.lookahead = 0;

          /* Emit a stored block if pending_buf will be full: */
          var max_start = s.block_start + max_block_size;

          if (s.strstart === 0 || s.strstart >= max_start) {
            /* strstart == 0 is possible when wraparound on 16-bit machine */
            s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
            /***/


          }
          /* Flush if we may have to slide, otherwise block_start may become
           * negative and the data will be gone:
           */
          if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
            /***/
          }
        }

        s.insert = 0;

        if (flush === Z_FINISH$2) {
          /*** FLUSH_BLOCK(s, 1); ***/
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          /***/
          return BS_FINISH_DONE;
        }

        if (s.strstart > s.block_start) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }

        return BS_NEED_MORE;
      }

      /* ===========================================================================
       * Compress as much as possible from the input stream, return the current
       * block state.
       * This function does not perform lazy evaluation of matches and inserts
       * new strings in the dictionary only for unmatched strings or for short
       * matches. It is used only for the fast compression options.
       */
      function deflate_fast(s, flush) {
        var hash_head; /* head of the hash chain */
        var bflush; /* set if current block must be flushed */

        for (;;) {
          /* Make sure that we always have enough lookahead, except
           * at the end of the input file. We need MAX_MATCH bytes
           * for the next match, plus MIN_MATCH bytes to insert the
           * string following the next match.
           */
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break; /* flush the current block */
            }
          }

          /* Insert the string window[strstart .. strstart+2] in the
           * dictionary, and set hash_head to the head of the hash chain:
           */
          hash_head = 0 /*NIL*/ ;
          if (s.lookahead >= MIN_MATCH) {
            /*** INSERT_STRING(s, s.strstart, hash_head); ***/
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
            /***/
          }

          /* Find the longest match, discarding those <= prev_length.
           * At this point we have always match_length < MIN_MATCH
           */
          if (hash_head !== 0 /*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            s.match_length = longest_match(s, hash_head);
            /* longest_match() sets match_start */
          }
          if (s.match_length >= MIN_MATCH) {
            // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

            /*** _tr_tally_dist(s, s.strstart - s.match_start,
                           s.match_length - MIN_MATCH, bflush); ***/
            bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

            s.lookahead -= s.match_length;

            /* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */
            if (s.match_length <= s.max_lazy_match /*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
              s.match_length--; /* string at strstart already in table */
              do {
                s.strstart++;
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
                /***/
                /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                 * always MIN_MATCH bytes ahead.
                 */
              } while (--s.match_length !== 0);
              s.strstart++;
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

              //#if MIN_MATCH != 3
              //                Call UPDATE_HASH() MIN_MATCH-3 more times
              //#endif
              /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
               * matter since it will be recomputed at next deflate call.
               */
            }
          } else {
            /* No match, output a literal byte */
            //Tracevv((stderr,"%c", s.window[s.strstart]));
            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
            bflush = _tr_tally(s, 0, s.window[s.strstart]);

            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
            /***/
          }
        }
        s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
        if (flush === Z_FINISH$2) {
          /*** FLUSH_BLOCK(s, 1); ***/
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          /***/
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
        return BS_BLOCK_DONE;
      }

      /* ===========================================================================
       * Same as above, but achieves better compression. We use a lazy
       * evaluation for matches: a match is finally adopted only if there is
       * no better match at the next window position.
       */
      function deflate_slow(s, flush) {
        var hash_head; /* head of hash chain */
        var bflush; /* set if current block must be flushed */

        var max_insert;

        /* Process the input block. */
        for (;;) {
          /* Make sure that we always have enough lookahead, except
           * at the end of the input file. We need MAX_MATCH bytes
           * for the next match, plus MIN_MATCH bytes to insert the
           * string following the next match.
           */
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            } /* flush the current block */
          }

          /* Insert the string window[strstart .. strstart+2] in the
           * dictionary, and set hash_head to the head of the hash chain:
           */
          hash_head = 0 /*NIL*/ ;
          if (s.lookahead >= MIN_MATCH) {
            /*** INSERT_STRING(s, s.strstart, hash_head); ***/
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
            /***/
          }

          /* Find the longest match, discarding those <= prev_length.
           */
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;

          if (hash_head !== 0 /*NIL*/ && s.prev_length < s.max_lazy_match &&
            s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD) /*MAX_DIST(s)*/ ) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            s.match_length = longest_match(s, hash_head);
            /* longest_match() sets match_start */

            if (s.match_length <= 5 &&
              (s.strategy === Z_FILTERED$1 || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/ ))) {

              /* If prev_match is also MIN_MATCH, match_start is garbage
               * but we will ignore the current match anyway.
               */
              s.match_length = MIN_MATCH - 1;
            }
          }
          /* If there was a match at the previous step and the current
           * match is not better, output the previous match:
           */
          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            /* Do not insert strings in hash table beyond this. */

            //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

            /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                           s.prev_length - MIN_MATCH, bflush);***/
            bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            /* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted. If there is not
             * enough lookahead, the last two strings are not inserted in
             * the hash table.
             */
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
                /***/
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;

            if (bflush) {
              /*** FLUSH_BLOCK(s, 0); ***/
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
              /***/
            }

          } else if (s.match_available) {
            /* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */
            //Tracevv((stderr,"%c", s->window[s->strstart-1]));
            /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
            bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

            if (bflush) {
              /*** FLUSH_BLOCK_ONLY(s, 0) ***/
              flush_block_only(s, false);
              /***/
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          } else {
            /* There is no previous match to compare with, wait for
             * the next step to decide.
             */
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
          }
        }
        //Assert (flush != Z_NO_FLUSH, "no flush?");
        if (s.match_available) {
          //Tracevv((stderr,"%c", s->window[s->strstart-1]));
          /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

          s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH$2) {
          /*** FLUSH_BLOCK(s, 1); ***/
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          /***/
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }

        return BS_BLOCK_DONE;
      }


      /* ===========================================================================
       * For Z_RLE, simply look for runs of bytes, generate matches only of distance
       * one.  Do not maintain a hash table.  (It will be regenerated if this run of
       * deflate switches away from Z_RLE.)
       */
      function deflate_rle(s, flush) {
        var bflush; /* set if current block must be flushed */
        var prev; /* byte at distance one to match */
        var scan, strend; /* scan goes up to strend for length of run */

        var _win = s.window;

        for (;;) {
          /* Make sure that we always have enough lookahead, except
           * at the end of the input file. We need MAX_MATCH bytes
           * for the longest run, plus one for the unrolled loop.
           */
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$1) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            } /* flush the current block */
          }

          /* See how many times the previous byte repeats */
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;
              do {
                /*jshint noempty:false*/
              } while (prev === _win[++scan] && prev === _win[++scan] &&
                prev === _win[++scan] && prev === _win[++scan] &&
                prev === _win[++scan] && prev === _win[++scan] &&
                prev === _win[++scan] && prev === _win[++scan] &&
                scan < strend);
              s.match_length = MAX_MATCH - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead;
              }
            }
            //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
          }

          /* Emit match if have run of MIN_MATCH or longer, else emit literal */
          if (s.match_length >= MIN_MATCH) {
            //check_match(s, s.strstart, s.strstart - 1, s.match_length);

            /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
            bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
          } else {
            /* No match, output a literal byte */
            //Tracevv((stderr,"%c", s->window[s->strstart]));
            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
            bflush = _tr_tally(s, 0, s.window[s.strstart]);

            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
            /***/
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH$2) {
          /*** FLUSH_BLOCK(s, 1); ***/
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          /***/
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
        return BS_BLOCK_DONE;
      }

      /* ===========================================================================
       * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
       * (It will be regenerated if this run of deflate switches away from Huffman.)
       */
      function deflate_huff(s, flush) {
        var bflush; /* set if current block must be flushed */

        for (;;) {
          /* Make sure that we have a literal to write. */
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH$1) {
                return BS_NEED_MORE;
              }
              break; /* flush the current block */
            }
          }

          /* Output a literal byte */
          s.match_length = 0;
          //Tracevv((stderr,"%c", s->window[s->strstart]));
          /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
            /***/
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH$2) {
          /*** FLUSH_BLOCK(s, 1); ***/
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          /***/
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
        return BS_BLOCK_DONE;
      }

      /* Values for max_lazy_match, good_match and max_chain_length, depending on
       * the desired pack level (0..9). The values given below have been tuned to
       * exclude worst case performance for pathological files. Better values may be
       * found for specific files.
       */
      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
      }

      var configuration_table;

      configuration_table = [
        /*      good lazy nice chain */
        new Config(0, 0, 0, 0, deflate_stored), /* 0 store only */
        new Config(4, 4, 8, 4, deflate_fast), /* 1 max speed, no lazy matches */
        new Config(4, 5, 16, 8, deflate_fast), /* 2 */
        new Config(4, 6, 32, 32, deflate_fast), /* 3 */

        new Config(4, 4, 16, 16, deflate_slow), /* 4 lazy matches */
        new Config(8, 16, 32, 32, deflate_slow), /* 5 */
        new Config(8, 16, 128, 128, deflate_slow), /* 6 */
        new Config(8, 32, 128, 256, deflate_slow), /* 7 */
        new Config(32, 128, 258, 1024, deflate_slow), /* 8 */
        new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */
      ];


      /* ===========================================================================
       * Initialize the "longest match" routines for a new zlib stream
       */
      function lm_init(s) {
        s.window_size = 2 * s.w_size;

        /*** CLEAR_HASH(s); ***/
        zero(s.head); // Fill with NIL (= 0);

        /* Set the default configuration parameters:
         */
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;

        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
      }


      function DeflateState() {
        this.strm = null; /* pointer back to this zlib stream */
        this.status = 0; /* as the name implies */
        this.pending_buf = null; /* output still pending */
        this.pending_buf_size = 0; /* size of pending_buf */
        this.pending_out = 0; /* next pending byte to output to the stream */
        this.pending = 0; /* nb of bytes in the pending buffer */
        this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
        this.gzhead = null; /* gzip header information to write */
        this.gzindex = 0; /* where in extra, name, or comment */
        this.method = Z_DEFLATED$2; /* can only be DEFLATED */
        this.last_flush = -1; /* value of flush param for previous deflate call */

        this.w_size = 0; /* LZ77 window size (32K by default) */
        this.w_bits = 0; /* log2(w_size)  (8..16) */
        this.w_mask = 0; /* w_size - 1 */

        this.window = null;
        /* Sliding window. Input bytes are read into the second half of the window,
         * and move to the first half later to keep a dictionary of at least wSize
         * bytes. With this organization, matches are limited to a distance of
         * wSize-MAX_MATCH bytes, but this ensures that IO is always
         * performed with a length multiple of the block size.
         */

        this.window_size = 0;
        /* Actual size of window: 2*wSize, except when the user input buffer
         * is directly used as sliding window.
         */

        this.prev = null;
        /* Link to older string with same hash index. To limit the size of this
         * array to 64K, this link is maintained only for the last 32K strings.
         * An index in this array is thus a window index modulo 32K.
         */

        this.head = null; /* Heads of the hash chains or NIL. */

        this.ins_h = 0; /* hash index of string to be inserted */
        this.hash_size = 0; /* number of elements in hash table */
        this.hash_bits = 0; /* log2(hash_size) */
        this.hash_mask = 0; /* hash_size-1 */

        this.hash_shift = 0;
        /* Number of bits by which ins_h must be shifted at each input
         * step. It must be such that after MIN_MATCH steps, the oldest
         * byte no longer takes part in the hash key, that is:
         *   hash_shift * MIN_MATCH >= hash_bits
         */

        this.block_start = 0;
        /* Window position at the beginning of the current output block. Gets
         * negative when the window is moved backwards.
         */

        this.match_length = 0; /* length of best match */
        this.prev_match = 0; /* previous match */
        this.match_available = 0; /* set if previous match exists */
        this.strstart = 0; /* start of string to insert */
        this.match_start = 0; /* start of matching string */
        this.lookahead = 0; /* number of valid bytes ahead in window */

        this.prev_length = 0;
        /* Length of the best match at previous step. Matches not greater than this
         * are discarded. This is used in the lazy match evaluation.
         */

        this.max_chain_length = 0;
        /* To speed up deflation, hash chains are never searched beyond this
         * length.  A higher limit improves compression ratio but degrades the
         * speed.
         */

        this.max_lazy_match = 0;
        /* Attempt to find a better match only when the current match is strictly
         * smaller than this value. This mechanism is used only for compression
         * levels >= 4.
         */
        // That's alias to max_lazy_match, don't use directly
        //this.max_insert_length = 0;
        /* Insert new strings in the hash table only if the match length is not
         * greater than this length. This saves time but degrades compression.
         * max_insert_length is used only for compression levels <= 3.
         */

        this.level = 0; /* compression level (1..9) */
        this.strategy = 0; /* favor or force Huffman coding*/

        this.good_match = 0;
        /* Use a faster search when the previous match is longer than this */

        this.nice_match = 0; /* Stop searching when current match exceeds this */

        /* used by c: */

        /* Didn't use ct_data typedef below to suppress compiler warning */

        // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
        // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
        // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

        // Use flat array of DOUBLE size, with interleaved fata,
        // because JS does not support effective
        this.dyn_ltree = new Buf16(HEAP_SIZE * 2);
        this.dyn_dtree = new Buf16((2 * D_CODES + 1) * 2);
        this.bl_tree = new Buf16((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);

        this.l_desc = null; /* desc. for literal tree */
        this.d_desc = null; /* desc. for distance tree */
        this.bl_desc = null; /* desc. for bit length tree */

        //ush bl_count[MAX_BITS+1];
        this.bl_count = new Buf16(MAX_BITS + 1);
        /* number of codes at each bit length for an optimal tree */

        //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
        this.heap = new Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */
        zero(this.heap);

        this.heap_len = 0; /* number of elements in the heap */
        this.heap_max = 0; /* element of largest frequency */
        /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
         * The same heap array is used to build all
         */

        this.depth = new Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
        zero(this.depth);
        /* Depth of each subtree used as tie breaker for trees of equal frequency
         */

        this.l_buf = 0; /* buffer index for literals or lengths */

        this.lit_bufsize = 0;
        /* Size of match buffer for literals/lengths.  There are 4 reasons for
         * limiting lit_bufsize to 64K:
         *   - frequencies can be kept in 16 bit counters
         *   - if compression is not successful for the first block, all input
         *     data is still in the window so we can still emit a stored block even
         *     when input comes from standard input.  (This can also be done for
         *     all blocks if lit_bufsize is not greater than 32K.)
         *   - if compression is not successful for a file smaller than 64K, we can
         *     even emit a stored file instead of a stored block (saving 5 bytes).
         *     This is applicable only for zip (not gzip or zlib).
         *   - creating new Huffman trees less frequently may not provide fast
         *     adaptation to changes in the input data statistics. (Take for
         *     example a binary file with poorly compressible code followed by
         *     a highly compressible string table.) Smaller buffer sizes give
         *     fast adaptation but have of course the overhead of transmitting
         *     trees more frequently.
         *   - I can't count above 4
         */

        this.last_lit = 0; /* running index in l_buf */

        this.d_buf = 0;
        /* Buffer index for distances. To simplify the code, d_buf and l_buf have
         * the same number of elements. To use different lengths, an extra flag
         * array would be necessary.
         */

        this.opt_len = 0; /* bit length of current block with optimal trees */
        this.static_len = 0; /* bit length of current block with static trees */
        this.matches = 0; /* number of string matches in current block */
        this.insert = 0; /* bytes at end of window left to insert */


        this.bi_buf = 0;
        /* Output buffer. bits are inserted starting at the bottom (least
         * significant bits).
         */
        this.bi_valid = 0;
        /* Number of valid bits in bi_buf.  All bits above the last valid bit
         * are always zero.
         */

        // Used for window memory init. We safely ignore it for JS. That makes
        // sense only for pointers and memory check tools.
        //this.high_water = 0;
        /* High water mark offset in window for initialized bytes -- bytes above
         * this are set to zero in order to avoid memory check warnings when
         * longest match routines access bytes past the input.  This is then
         * updated to the new high water mark.
         */
      }


      function deflateResetKeep(strm) {
        var s;

        if (!strm || !strm.state) {
          return err(strm, Z_STREAM_ERROR$2);
        }

        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN$1;

        s = strm.state;
        s.pending = 0;
        s.pending_out = 0;

        if (s.wrap < 0) {
          s.wrap = -s.wrap;
          /* was made negative by deflate(..., Z_FINISH); */
        }
        s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
        strm.adler = (s.wrap === 2) ?
          0 // crc32(0, Z_NULL, 0)
          :
          1; // adler32(0, Z_NULL, 0)
        s.last_flush = Z_NO_FLUSH$1;
        _tr_init(s);
        return Z_OK$2;
      }


      function deflateReset(strm) {
        var ret = deflateResetKeep(strm);
        if (ret === Z_OK$2) {
          lm_init(strm.state);
        }
        return ret;
      }


      function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) { // === Z_NULL
          return Z_STREAM_ERROR$2;
        }
        var wrap = 1;

        if (level === Z_DEFAULT_COMPRESSION$1) {
          level = 6;
        }

        if (windowBits < 0) { /* suppress zlib wrapper */
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2; /* write gzip wrapper instead */
          windowBits -= 16;
        }


        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||
          windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
          strategy < 0 || strategy > Z_FIXED$1) {
          return err(strm, Z_STREAM_ERROR$2);
        }


        if (windowBits === 8) {
          windowBits = 9;
        }
        /* until 256-byte window bug fixed */

        var s = new DeflateState();

        strm.state = s;
        s.strm = strm;

        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;

        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

        s.window = new Buf8(s.w_size * 2);
        s.head = new Buf16(s.hash_size);
        s.prev = new Buf16(s.w_size);

        // Don't need mem init magic for JS.
        //s.high_water = 0;  /* nothing written to s->window yet */

        s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

        s.pending_buf_size = s.lit_bufsize * 4;

        //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
        //s->pending_buf = (uchf *) overlay;
        s.pending_buf = new Buf8(s.pending_buf_size);

        // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
        //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
        s.d_buf = 1 * s.lit_bufsize;

        //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
        s.l_buf = (1 + 2) * s.lit_bufsize;

        s.level = level;
        s.strategy = strategy;
        s.method = method;

        return deflateReset(strm);
      }


      function deflate$1(strm, flush) {
        var old_flush, s;
        var beg, val; // for gzip header write only

        if (!strm || !strm.state ||
          flush > Z_BLOCK$2 || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
        }

        s = strm.state;

        if (!strm.output ||
          (!strm.input && strm.avail_in !== 0) ||
          (s.status === FINISH_STATE && flush !== Z_FINISH$2)) {
          return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$2 : Z_STREAM_ERROR$2);
        }

        s.strm = strm; /* just in case */
        old_flush = s.last_flush;
        s.last_flush = flush;

        /* Write the header */
        if (s.status === INIT_STATE) {
          if (s.wrap === 2) {
            // GZIP header
            strm.adler = 0; //crc32(0L, Z_NULL, 0);
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) { // s->gzhead == Z_NULL
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, s.level === 9 ? 2 :
                (s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2 ?
                  4 : 0));
              put_byte(s, OS_CODE);
              s.status = BUSY_STATE;
            } else {
              put_byte(s, (s.gzhead.text ? 1 : 0) +
                (s.gzhead.hcrc ? 2 : 0) +
                (!s.gzhead.extra ? 0 : 4) +
                (!s.gzhead.name ? 0 : 8) +
                (!s.gzhead.comment ? 0 : 16)
              );
              put_byte(s, s.gzhead.time & 0xff);
              put_byte(s, (s.gzhead.time >> 8) & 0xff);
              put_byte(s, (s.gzhead.time >> 16) & 0xff);
              put_byte(s, (s.gzhead.time >> 24) & 0xff);
              put_byte(s, s.level === 9 ? 2 :
                (s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2 ?
                  4 : 0));
              put_byte(s, s.gzhead.os & 0xff);
              if (s.gzhead.extra && s.gzhead.extra.length) {
                put_byte(s, s.gzhead.extra.length & 0xff);
                put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
              }
              if (s.gzhead.hcrc) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
              }
              s.gzindex = 0;
              s.status = EXTRA_STATE;
            }
          } else // DEFLATE header
          {
            var header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;
            var level_flags = -1;

            if (s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2) {
              level_flags = 0;
            } else if (s.level < 6) {
              level_flags = 1;
            } else if (s.level === 6) {
              level_flags = 2;
            } else {
              level_flags = 3;
            }
            header |= (level_flags << 6);
            if (s.strstart !== 0) {
              header |= PRESET_DICT;
            }
            header += 31 - (header % 31);

            s.status = BUSY_STATE;
            putShortMSB(s, header);

            /* Save the adler32 of the preset dictionary: */
            if (s.strstart !== 0) {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 0xffff);
            }
            strm.adler = 1; // adler32(0L, Z_NULL, 0);
          }
        }

        //#ifdef GZIP
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra /* != Z_NULL*/ ) {
            beg = s.pending; /* start of bytes to update crc */

            while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  break;
                }
              }
              put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
              s.gzindex++;
            }
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (s.gzindex === s.gzhead.extra.length) {
              s.gzindex = 0;
              s.status = NAME_STATE;
            }
          } else {
            s.status = NAME_STATE;
          }
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name /* != Z_NULL*/ ) {
            beg = s.pending; /* start of bytes to update crc */
            //int val;

            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              // JS specific: little magic to add zero terminator to end of string
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);

            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.gzindex = 0;
              s.status = COMMENT_STATE;
            }
          } else {
            s.status = COMMENT_STATE;
          }
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment /* != Z_NULL*/ ) {
            beg = s.pending; /* start of bytes to update crc */
            //int val;

            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              // JS specific: little magic to add zero terminator to end of string
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);

            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.status = HCRC_STATE;
            }
          } else {
            s.status = HCRC_STATE;
          }
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm);
            }
            if (s.pending + 2 <= s.pending_buf_size) {
              put_byte(s, strm.adler & 0xff);
              put_byte(s, (strm.adler >> 8) & 0xff);
              strm.adler = 0; //crc32(0L, Z_NULL, 0);
              s.status = BUSY_STATE;
            }
          } else {
            s.status = BUSY_STATE;
          }
        }
        //#endif

        /* Flush as much pending output as possible */
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            /* Since avail_out is 0, deflate will be called again with
             * more output space, but possibly with both pending and
             * avail_in equal to zero. There won't be anything to do,
             * but this is not an error situation so make sure we
             * return OK instead of BUF_ERROR at next call of deflate:
             */
            s.last_flush = -1;
            return Z_OK$2;
          }

          /* Make sure there is something to do and avoid duplicate consecutive
           * flushes. For repeated and useless calls with Z_FINISH, we keep
           * returning Z_STREAM_END instead of Z_BUF_ERROR.
           */
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
          flush !== Z_FINISH$2) {
          return err(strm, Z_BUF_ERROR$2);
        }

        /* User must not provide more input after the first FINISH: */
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR$2);
        }

        /* Start a new block or continue the current one.
         */
        if (strm.avail_in !== 0 || s.lookahead !== 0 ||
          (flush !== Z_NO_FLUSH$1 && s.status !== FINISH_STATE)) {
          var bstate = (s.strategy === Z_HUFFMAN_ONLY$1) ? deflate_huff(s, flush) :
            (s.strategy === Z_RLE$1 ? deflate_rle(s, flush) :
              configuration_table[s.level].func(s, flush));

          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE;
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              /* avoid BUF_ERROR next call, see above */
            }
            return Z_OK$2;
            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
             * of deflate should use the same flush parameter to make sure
             * that the flush is complete. So we don't have to output an
             * empty block here, this will be done at next call. This also
             * ensures that for a very small output buffer, we emit at most
             * one empty block.
             */
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH$1) {
              _tr_align(s);
            } else if (flush !== Z_BLOCK$2) { /* FULL_FLUSH or SYNC_FLUSH */

              _tr_stored_block(s, 0, 0, false);
              /* For a full flush, this empty block will be recognized
               * as a special marker by inflate_sync().
               */
              if (flush === Z_FULL_FLUSH$1) {
                /*** CLEAR_HASH(s); ***/
                /* forget history */
                zero(s.head); // Fill with NIL (= 0);

                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0;
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
              return Z_OK$2;
            }
          }
        }
        //Assert(strm->avail_out > 0, "bug2");
        //if (strm.avail_out <= 0) { throw new Error("bug2");}

        if (flush !== Z_FINISH$2) {
          return Z_OK$2;
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END$2;
        }

        /* Write the trailer */
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 0xff);
          put_byte(s, (strm.adler >> 8) & 0xff);
          put_byte(s, (strm.adler >> 16) & 0xff);
          put_byte(s, (strm.adler >> 24) & 0xff);
          put_byte(s, strm.total_in & 0xff);
          put_byte(s, (strm.total_in >> 8) & 0xff);
          put_byte(s, (strm.total_in >> 16) & 0xff);
          put_byte(s, (strm.total_in >> 24) & 0xff);
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 0xffff);
        }

        flush_pending(strm);
        /* If avail_out is zero, the application will call deflate again
         * to flush the rest.
         */
        if (s.wrap > 0) {
          s.wrap = -s.wrap;
        }
        /* write the trailer only once! */
        return s.pending !== 0 ? Z_OK$2 : Z_STREAM_END$2;
      }

      function deflateEnd(strm) {
        var status;

        if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/ ) {
          return Z_STREAM_ERROR$2;
        }

        status = strm.state.status;
        if (status !== INIT_STATE &&
          status !== EXTRA_STATE &&
          status !== NAME_STATE &&
          status !== COMMENT_STATE &&
          status !== HCRC_STATE &&
          status !== BUSY_STATE &&
          status !== FINISH_STATE
        ) {
          return err(strm, Z_STREAM_ERROR$2);
        }

        strm.state = null;

        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$2;
      }

      /* Not implemented
      exports.deflateBound = deflateBound;
      exports.deflateCopy = deflateCopy;
      exports.deflateParams = deflateParams;
      exports.deflatePending = deflatePending;
      exports.deflatePrime = deflatePrime;
      exports.deflateTune = deflateTune;
      */

      // See state defs from inflate.js
      var BAD$1 = 30;       /* got a data error -- remain here until reset */
      var TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */

      /*
         Decode literal, length, and distance codes and write out the resulting
         literal and match bytes until either not enough input or output is
         available, an end-of-block is encountered, or a data error is encountered.
         When large enough input and output buffers are supplied to inflate(), for
         example, a 16K input buffer and a 64K output buffer, more than 95% of the
         inflate execution time is spent in this routine.

         Entry assumptions:

              state.mode === LEN
              strm.avail_in >= 6
              strm.avail_out >= 258
              start >= strm.avail_out
              state.bits < 8

         On return, state.mode is one of:

              LEN -- ran out of enough output space or enough available input
              TYPE -- reached end of block code, inflate() to interpret next block
              BAD -- error in block data

         Notes:

          - The maximum input bits used by a length/distance pair is 15 bits for the
            length code, 5 bits for the length extra, 15 bits for the distance code,
            and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
            Therefore if strm.avail_in >= 6, then there is enough input to avoid
            checking for available input while decoding.

          - The maximum bytes that a single length/distance pair can output is 258
            bytes, which is the maximum length that can be coded.  inflate_fast()
            requires strm.avail_out >= 258 for each loop to avoid checking for
            output space.
       */
      function inflate_fast(strm, start) {
        var state;
        var _in;                    /* local strm.input */
        var last;                   /* have enough input while in < last */
        var _out;                   /* local strm.output */
        var beg;                    /* inflate()'s initial strm.output */
        var end;                    /* while out < end, enough space available */
      //#ifdef INFLATE_STRICT
        var dmax;                   /* maximum distance from zlib header */
      //#endif
        var wsize;                  /* window size or zero if not using window */
        var whave;                  /* valid bytes in the window */
        var wnext;                  /* window write index */
        // Use `s_window` instead `window`, avoid conflict with instrumentation tools
        var s_window;               /* allocated sliding window, if wsize != 0 */
        var hold;                   /* local strm.hold */
        var bits;                   /* local strm.bits */
        var lcode;                  /* local strm.lencode */
        var dcode;                  /* local strm.distcode */
        var lmask;                  /* mask for first level of length codes */
        var dmask;                  /* mask for first level of distance codes */
        var here;                   /* retrieved table entry */
        var op;                     /* code bits, operation, extra bits, or */
                                    /*  window position, window bytes to copy */
        var len;                    /* match length, unused bytes */
        var dist;                   /* match distance */
        var from;                   /* where to copy match from */
        var from_source;


        var input, output; // JS specific, because we have no pointers

        /* copy state to local variables */
        state = strm.state;
        //here = state.here;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
      //#ifdef INFLATE_STRICT
        dmax = state.dmax;
      //#endif
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;


        /* decode literals and length/distances until end-of-block or not enough
           input data or output space */

        top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }

          here = lcode[hold & lmask];

          dolen:
          for (;;) { // Goto emulation
            op = here >>> 24/*here.bits*/;
            hold >>>= op;
            bits -= op;
            op = (here >>> 16) & 0xff/*here.op*/;
            if (op === 0) {                          /* literal */
              //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
              //        "inflate:         literal '%c'\n" :
              //        "inflate:         literal 0x%02x\n", here.val));
              output[_out++] = here & 0xffff/*here.val*/;
            }
            else if (op & 16) {                     /* length base */
              len = here & 0xffff/*here.val*/;
              op &= 15;                           /* number of extra bits */
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & ((1 << op) - 1);
                hold >>>= op;
                bits -= op;
              }
              //Tracevv((stderr, "inflate:         length %u\n", len));
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];

              dodist:
              for (;;) { // goto emulation
                op = here >>> 24/*here.bits*/;
                hold >>>= op;
                bits -= op;
                op = (here >>> 16) & 0xff/*here.op*/;

                if (op & 16) {                      /* distance base */
                  dist = here & 0xffff/*here.val*/;
                  op &= 15;                       /* number of extra bits */
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & ((1 << op) - 1);
      //#ifdef INFLATE_STRICT
                  if (dist > dmax) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD$1;
                    break top;
                  }
      //#endif
                  hold >>>= op;
                  bits -= op;
                  //Tracevv((stderr, "inflate:         distance %u\n", dist));
                  op = _out - beg;                /* max distance in output */
                  if (dist > op) {                /* see if copy from window */
                    op = dist - op;               /* distance back in window */
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = 'invalid distance too far back';
                        state.mode = BAD$1;
                        break top;
                      }

      // (!) This block is disabled in zlib defailts,
      // don't enable it for binary compatibility
      //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
      //                if (len <= op - whave) {
      //                  do {
      //                    output[_out++] = 0;
      //                  } while (--len);
      //                  continue top;
      //                }
      //                len -= op - whave;
      //                do {
      //                  output[_out++] = 0;
      //                } while (--op > whave);
      //                if (op === 0) {
      //                  from = _out - dist;
      //                  do {
      //                    output[_out++] = output[from++];
      //                  } while (--len);
      //                  continue top;
      //                }
      //#endif
                    }
                    from = 0; // window index
                    from_source = s_window;
                    if (wnext === 0) {           /* very common case */
                      from += wsize - op;
                      if (op < len) {         /* some from window */
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;  /* rest from output */
                        from_source = output;
                      }
                    }
                    else if (wnext < op) {      /* wrap around window */
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {         /* some from end of window */
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {  /* some from start of window */
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;      /* rest from output */
                          from_source = output;
                        }
                      }
                    }
                    else {                      /* contiguous in window */
                      from += wnext - op;
                      if (op < len) {         /* some from window */
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;  /* rest from output */
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  }
                  else {
                    from = _out - dist;          /* copy direct from output */
                    do {                        /* minimum length is three */
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                }
                else if ((op & 64) === 0) {          /* 2nd level distance code */
                  here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
                  continue dodist;
                }
                else {
                  strm.msg = 'invalid distance code';
                  state.mode = BAD$1;
                  break top;
                }

                break; // need to emulate goto via "continue"
              }
            }
            else if ((op & 64) === 0) {              /* 2nd level length code */
              here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
              continue dolen;
            }
            else if (op & 32) {                     /* end-of-block */
              //Tracevv((stderr, "inflate:         end of block\n"));
              state.mode = TYPE$1;
              break top;
            }
            else {
              strm.msg = 'invalid literal/length code';
              state.mode = BAD$1;
              break top;
            }

            break; // need to emulate goto via "continue"
          }
        } while (_in < last && _out < end);

        /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;

        /* update state and return */
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
        strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
        state.hold = hold;
        state.bits = bits;
        return;
      }

      var MAXBITS = 15;
      var ENOUGH_LENS$1 = 852;
      var ENOUGH_DISTS$1 = 592;
      //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

      var CODES$1 = 0;
      var LENS$1 = 1;
      var DISTS$1 = 2;

      var lbase = [ /* Length codes 257..285 base */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
      ];

      var lext = [ /* Length codes 257..285 extra */
        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
      ];

      var dbase = [ /* Distance codes 0..29 base */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577, 0, 0
      ];

      var dext = [ /* Distance codes 0..29 extra */
        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
        28, 28, 29, 29, 64, 64
      ];

      function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
        var bits = opts.bits;
        //here = opts.here; /* table entry for duplication */

        var len = 0; /* a code's length in bits */
        var sym = 0; /* index of code symbols */
        var min = 0,
          max = 0; /* minimum and maximum code lengths */
        var root = 0; /* number of index bits for root table */
        var curr = 0; /* number of index bits for current table */
        var drop = 0; /* code bits to drop for sub-table */
        var left = 0; /* number of prefix codes available */
        var used = 0; /* code entries in table used */
        var huff = 0; /* Huffman code */
        var incr; /* for incrementing code, index */
        var fill; /* index for replicating entries */
        var low; /* low bits for current root entry */
        var mask; /* mask for low root bits */
        var next; /* next available space in table */
        var base = null; /* base value table to use */
        var base_index = 0;
        //  var shoextra;    /* extra bits table to use */
        var end; /* use base and extra for symbol > end */
        var count = new Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
        var offs = new Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
        var extra = null;
        var extra_index = 0;

        var here_bits, here_op, here_val;

        /*
         Process a set of code lengths to create a canonical Huffman code.  The
         code lengths are lens[0..codes-1].  Each length corresponds to the
         symbols 0..codes-1.  The Huffman code is generated by first sorting the
         symbols by length from short to long, and retaining the symbol order
         for codes with equal lengths.  Then the code starts with all zero bits
         for the first code of the shortest length, and the codes are integer
         increments for the same length, and zeros are appended as the length
         increases.  For the deflate format, these bits are stored backwards
         from their more natural integer increment ordering, and so when the
         decoding tables are built in the large loop below, the integer codes
         are incremented backwards.

         This routine assumes, but does not check, that all of the entries in
         lens[] are in the range 0..MAXBITS.  The caller must assure this.
         1..MAXBITS is interpreted as that code length.  zero means that that
         symbol does not occur in this code.

         The codes are sorted by computing a count of codes for each length,
         creating from that a table of starting indices for each length in the
         sorted table, and then entering the symbols in order in the sorted
         table.  The sorted table is work[], with that space being provided by
         the caller.

         The length counts are used for other purposes as well, i.e. finding
         the minimum and maximum length codes, determining if there are any
         codes at all, checking for a valid set of lengths, and looking ahead
         at length counts to determine sub-table sizes when building the
         decoding tables.
         */

        /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++;
        }

        /* bound code lengths, force root to be within code lengths */
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
          if (count[max] !== 0) {
            break;
          }
        }
        if (root > max) {
          root = max;
        }
        if (max === 0) { /* no symbols to code at all */
          //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
          //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
          //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
          table[table_index++] = (1 << 24) | (64 << 16) | 0;


          //table.op[opts.table_index] = 64;
          //table.bits[opts.table_index] = 1;
          //table.val[opts.table_index++] = 0;
          table[table_index++] = (1 << 24) | (64 << 16) | 0;

          opts.bits = 1;
          return 0; /* no symbols, but wait for decoding to report error */
        }
        for (min = 1; min < max; min++) {
          if (count[min] !== 0) {
            break;
          }
        }
        if (root < min) {
          root = min;
        }

        /* check for an over-subscribed or incomplete set of lengths */
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];
          if (left < 0) {
            return -1;
          } /* over-subscribed */
        }
        if (left > 0 && (type === CODES$1 || max !== 1)) {
          return -1; /* incomplete set */
        }

        /* generate offsets into symbol table for each length for sorting */
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len];
        }

        /* sort symbols by length, by symbol order within each length */
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
          }
        }

        /*
         Create and fill in decoding tables.  In this loop, the table being
         filled is at next and has curr index bits.  The code being used is huff
         with length len.  That code is converted to an index by dropping drop
         bits off of the bottom.  For codes where len is less than drop + curr,
         those top drop + curr - len bits are incremented through all values to
         fill the table with replicated entries.

         root is the number of index bits for the root table.  When len exceeds
         root, sub-tables are created pointed to by the root entry with an index
         of the low root bits of huff.  This is saved in low to check for when a
         new sub-table should be started.  drop is zero when the root table is
         being filled, and drop is root when sub-tables are being filled.

         When a new sub-table is needed, it is necessary to look ahead in the
         code lengths to determine what size sub-table is needed.  The length
         counts are used for this, and so count[] is decremented as codes are
         entered in the tables.

         used keeps track of how many table entries have been allocated from the
         provided *table space.  It is checked for LENS and DIST tables against
         the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
         the initial root table size constants.  See the comments in inftrees.h
         for more information.

         sym increments through all symbols, and the loop terminates when
         all codes of length max, i.e. all codes, have been processed.  This
         routine permits incomplete codes, so another loop after this one fills
         in the rest of the decoding tables with invalid code markers.
         */

        /* set up for code type */
        // poor man optimization - use if-else instead of switch,
        // to avoid deopts in old v8
        if (type === CODES$1) {
          base = extra = work; /* dummy value--not used */
          end = 19;

        } else if (type === LENS$1) {
          base = lbase;
          base_index -= 257;
          extra = lext;
          extra_index -= 257;
          end = 256;

        } else { /* DISTS */
          base = dbase;
          extra = dext;
          end = -1;
        }

        /* initialize opts for loop */
        huff = 0; /* starting code */
        sym = 0; /* starting code symbol */
        len = min; /* starting code length */
        next = table_index; /* current table to fill in */
        curr = root; /* current table index bits */
        drop = 0; /* current bits to drop from code for index */
        low = -1; /* trigger new sub-table when len > root */
        used = 1 << root; /* use root table entries */
        mask = used - 1; /* mask for comparing low */

        /* check available table space */
        if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
          (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
          return 1;
        }
        /* process all codes and make table entries */
        for (;;) {
          /* create table entry */
          here_bits = len - drop;
          if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
          } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]];
          } else {
            here_op = 32 + 64; /* end of block */
            here_val = 0;
          }

          /* replicate for those indices with low len bits equal to huff */
          incr = 1 << (len - drop);
          fill = 1 << curr;
          min = fill; /* save offset to next table */
          do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val | 0;
          } while (fill !== 0);

          /* backwards increment the len-bit code huff */
          incr = 1 << (len - 1);
          while (huff & incr) {
            incr >>= 1;
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
          } else {
            huff = 0;
          }

          /* go to next symbol, update count, len */
          sym++;
          if (--count[len] === 0) {
            if (len === max) {
              break;
            }
            len = lens[lens_index + work[sym]];
          }

          /* create new sub-table if needed */
          if (len > root && (huff & mask) !== low) {
            /* if first time, transition to sub-tables */
            if (drop === 0) {
              drop = root;
            }

            /* increment past last table */
            next += min; /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = 1 << curr;
            while (curr + drop < max) {
              left -= count[curr + drop];
              if (left <= 0) {
                break;
              }
              curr++;
              left <<= 1;
            }

            /* check for enough space */
            used += 1 << curr;
            if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
              (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
              return 1;
            }

            /* point entry in root table to sub-table */
            low = huff & mask;
            /*table.op[low] = curr;
            table.bits[low] = root;
            table.val[low] = next - opts.table_index;*/
            table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;
          }
        }

        /* fill in remaining table entry if code is incomplete (guaranteed to have
         at most one remaining entry, since if the code is incomplete, the
         maximum code length that was allowed to get this far is one bit) */
        if (huff !== 0) {
          //table.op[next + huff] = 64;            /* invalid code marker */
          //table.bits[next + huff] = len - drop;
          //table.val[next + huff] = 0;
          table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;
        }

        /* set return parameters */
        //opts.table_index += used;
        opts.bits = root;
        return 0;
      }

      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;

      /* Public constants ==========================================================*/
      /* ===========================================================================*/


      /* Allowed flush values; see deflate() and inflate() below for details */
      //var Z_NO_FLUSH      = 0;
      //var Z_PARTIAL_FLUSH = 1;
      //var Z_SYNC_FLUSH    = 2;
      //var Z_FULL_FLUSH    = 3;
      var Z_FINISH$1 = 4;
      var Z_BLOCK$1 = 5;
      var Z_TREES$1 = 6;


      /* Return codes for the compression/decompression functions. Negative values
       * are errors, positive values are used for special but normal events.
       */
      var Z_OK$1 = 0;
      var Z_STREAM_END$1 = 1;
      var Z_NEED_DICT$1 = 2;
      //var Z_ERRNO         = -1;
      var Z_STREAM_ERROR$1 = -2;
      var Z_DATA_ERROR$1 = -3;
      var Z_MEM_ERROR = -4;
      var Z_BUF_ERROR$1 = -5;
      //var Z_VERSION_ERROR = -6;

      /* The deflate compression method */
      var Z_DEFLATED$1 = 8;


      /* STATES ====================================================================*/
      /* ===========================================================================*/


      var HEAD = 1; /* i: waiting for magic header */
      var FLAGS = 2; /* i: waiting for method and flags (gzip) */
      var TIME = 3; /* i: waiting for modification time (gzip) */
      var OS = 4; /* i: waiting for extra flags and operating system (gzip) */
      var EXLEN = 5; /* i: waiting for extra length (gzip) */
      var EXTRA = 6; /* i: waiting for extra bytes (gzip) */
      var NAME = 7; /* i: waiting for end of file name (gzip) */
      var COMMENT$1 = 8; /* i: waiting for end of comment (gzip) */
      var HCRC = 9; /* i: waiting for header crc (gzip) */
      var DICTID = 10; /* i: waiting for dictionary check value */
      var DICT = 11; /* waiting for inflateSetDictionary() call */
      var TYPE = 12; /* i: waiting for type bits, including last-flag bit */
      var TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */
      var STORED = 14; /* i: waiting for stored size (length and complement) */
      var COPY_ = 15; /* i/o: same as COPY below, but only first time in */
      var COPY = 16; /* i/o: waiting for input or output to copy stored block */
      var TABLE = 17; /* i: waiting for dynamic block table lengths */
      var LENLENS = 18; /* i: waiting for code length code lengths */
      var CODELENS = 19; /* i: waiting for length/lit and distance code lengths */
      var LEN_ = 20; /* i: same as LEN below, but only first time in */
      var LEN = 21; /* i: waiting for length/lit/eob code */
      var LENEXT = 22; /* i: waiting for length extra bits */
      var DIST = 23; /* i: waiting for distance code */
      var DISTEXT = 24; /* i: waiting for distance extra bits */
      var MATCH = 25; /* o: waiting for output space to copy string */
      var LIT = 26; /* o: waiting for output space to write literal */
      var CHECK = 27; /* i: waiting for 32-bit check value */
      var LENGTH = 28; /* i: waiting for 32-bit length (gzip) */
      var DONE = 29; /* finished check, done -- remain here until reset */
      var BAD = 30; /* got a data error -- remain here until reset */
      var MEM = 31; /* got an inflate() memory error -- remain here until reset */
      var SYNC = 32; /* looking for synchronization bytes to restart inflate() */

      /* ===========================================================================*/



      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;


      function zswap32(q) {
        return (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
      }


      function InflateState() {
        this.mode = 0; /* current inflate mode */
        this.last = false; /* true if processing last block */
        this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
        this.havedict = false; /* true if dictionary provided */
        this.flags = 0; /* gzip header method and flags (0 if zlib) */
        this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */
        this.check = 0; /* protected copy of check value */
        this.total = 0; /* protected copy of output count */
        // TODO: may be {}
        this.head = null; /* where to save gzip header information */

        /* sliding window */
        this.wbits = 0; /* log base 2 of requested window size */
        this.wsize = 0; /* window size or zero if not using window */
        this.whave = 0; /* valid bytes in the window */
        this.wnext = 0; /* window write index */
        this.window = null; /* allocated sliding window, if needed */

        /* bit accumulator */
        this.hold = 0; /* input bit accumulator */
        this.bits = 0; /* number of bits in "in" */

        /* for string and stored block copying */
        this.length = 0; /* literal or length of data to copy */
        this.offset = 0; /* distance back to copy string from */

        /* for table and code decoding */
        this.extra = 0; /* extra bits needed */

        /* fixed and dynamic code tables */
        this.lencode = null; /* starting table for length/literal codes */
        this.distcode = null; /* starting table for distance codes */
        this.lenbits = 0; /* index bits for lencode */
        this.distbits = 0; /* index bits for distcode */

        /* dynamic table building */
        this.ncode = 0; /* number of code length code lengths */
        this.nlen = 0; /* number of length code lengths */
        this.ndist = 0; /* number of distance code lengths */
        this.have = 0; /* number of code lengths in lens[] */
        this.next = null; /* next available space in codes[] */

        this.lens = new Buf16(320); /* temporary storage for code lengths */
        this.work = new Buf16(288); /* work area for code table building */

        /*
         because we don't have pointers in js, we use lencode and distcode directly
         as buffers so we don't need codes
        */
        //this.codes = new Buf32(ENOUGH);       /* space for code tables */
        this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */
        this.distdyn = null; /* dynamic table for distance codes (JS specific) */
        this.sane = 0; /* if false, allow invalid distance too far */
        this.back = 0; /* bits back of last unprocessed length/lit */
        this.was = 0; /* initial length of match */
      }

      function inflateResetKeep(strm) {
        var state;

        if (!strm || !strm.state) {
          return Z_STREAM_ERROR$1;
        }
        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = ''; /*Z_NULL*/
        if (state.wrap) { /* to support ill-conceived Java test suite */
          strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null /*Z_NULL*/ ;
        state.hold = 0;
        state.bits = 0;
        //state.lencode = state.distcode = state.next = state.codes;
        state.lencode = state.lendyn = new Buf32(ENOUGH_LENS);
        state.distcode = state.distdyn = new Buf32(ENOUGH_DISTS);

        state.sane = 1;
        state.back = -1;
        //Tracev((stderr, "inflate: reset\n"));
        return Z_OK$1;
      }

      function inflateReset(strm) {
        var state;

        if (!strm || !strm.state) {
          return Z_STREAM_ERROR$1;
        }
        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);

      }

      function inflateReset2(strm, windowBits) {
        var wrap;
        var state;

        /* get the state */
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR$1;
        }
        state = strm.state;

        /* extract wrap request from windowBits parameter */
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else {
          wrap = (windowBits >> 4) + 1;
          if (windowBits < 48) {
            windowBits &= 15;
          }
        }

        /* set number of window bits, free window if different */
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR$1;
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null;
        }

        /* update state and reset the rest of it */
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
      }

      function inflateInit2(strm, windowBits) {
        var ret;
        var state;

        if (!strm) {
          return Z_STREAM_ERROR$1;
        }
        //strm.msg = Z_NULL;                 /* in case we return an error */

        state = new InflateState();

        //if (state === Z_NULL) return Z_MEM_ERROR;
        //Tracev((stderr, "inflate: allocated\n"));
        strm.state = state;
        state.window = null /*Z_NULL*/ ;
        ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK$1) {
          strm.state = null /*Z_NULL*/ ;
        }
        return ret;
      }


      /*
       Return state with length and distance decoding tables and index sizes set to
       fixed code decoding.  Normally this returns fixed tables from inffixed.h.
       If BUILDFIXED is defined, then instead this routine builds the tables the
       first time it's called, and returns those tables the first time and
       thereafter.  This reduces the size of the code by about 2K bytes, in
       exchange for a little execution time.  However, BUILDFIXED should not be
       used for threaded applications, since the rewriting of the tables and virgin
       may not be thread-safe.
       */
      var virgin = true;

      var lenfix, distfix; // We have no pointers in JS, so keep tables separate

      function fixedtables(state) {
        /* build fixed huffman tables if first call (may not be thread safe) */
        if (virgin) {
          var sym;

          lenfix = new Buf32(512);
          distfix = new Buf32(32);

          /* literal/length table */
          sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8;
          }
          while (sym < 256) {
            state.lens[sym++] = 9;
          }
          while (sym < 280) {
            state.lens[sym++] = 7;
          }
          while (sym < 288) {
            state.lens[sym++] = 8;
          }

          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
            bits: 9
          });

          /* distance table */
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5;
          }

          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
            bits: 5
          });

          /* do this just once */
          virgin = false;
        }

        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
      }


      /*
       Update the window with the last wsize (normally 32K) bytes written before
       returning.  If window does not exist yet, create it.  This is only called
       when a window is already in use, or when output has been written during this
       inflate call, but the end of the deflate stream has not been reached yet.
       It is also called to create a window for dictionary data when a dictionary
       is loaded.

       Providing output buffers larger than 32K to inflate() should provide a speed
       advantage, since only the last 32K of output is copied to the sliding window
       upon return from inflate(), and since all distances after the first 32K of
       output will fall in the output data, making match copies simpler and faster.
       The advantage may be dependent on the size of the processor's data caches.
       */
      function updatewindow(strm, src, end, copy) {
        var dist;
        var state = strm.state;

        /* if it hasn't been done already, allocate space for the window */
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;

          state.window = new Buf8(state.wsize);
        }

        /* copy state->wsize or less output bytes into the circular window */
        if (copy >= state.wsize) {
          arraySet(state.window, src, end - state.wsize, state.wsize, 0);
          state.wnext = 0;
          state.whave = state.wsize;
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy) {
            dist = copy;
          }
          //zmemcpy(state->window + state->wnext, end - copy, dist);
          arraySet(state.window, src, end - copy, dist, state.wnext);
          copy -= dist;
          if (copy) {
            //zmemcpy(state->window, end - copy, copy);
            arraySet(state.window, src, end - copy, copy, 0);
            state.wnext = copy;
            state.whave = state.wsize;
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0;
            }
            if (state.whave < state.wsize) {
              state.whave += dist;
            }
          }
        }
        return 0;
      }

      function inflate$1(strm, flush) {
        var state;
        var input, output; // input/output buffers
        var next; /* next input INDEX */
        var put; /* next output INDEX */
        var have, left; /* available input and output */
        var hold; /* bit buffer */
        var bits; /* bits in bit buffer */
        var _in, _out; /* save starting available input and output */
        var copy; /* number of stored or match bytes to copy */
        var from; /* where to copy match bytes from */
        var from_source;
        var here = 0; /* current decoding table entry */
        var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
        //var last;                   /* parent table entry */
        var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
        var len; /* length to copy for repeats, bits to drop */
        var ret; /* return code */
        var hbuf = new Buf8(4); /* buffer for gzip header crc calculation */
        var opts;

        var n; // temporary var for NEED_BITS

        var order = /* permutation of code lengths */ [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];


        if (!strm || !strm.state || !strm.output ||
          (!strm.input && strm.avail_in !== 0)) {
          return Z_STREAM_ERROR$1;
        }

        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO;
        } /* skip check */


        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        _in = have;
        _out = left;
        ret = Z_OK$1;

        inf_leave: // goto emulation
          for (;;) {
            switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              //=== NEEDBITS(16);
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              if ((state.wrap & 2) && hold === 0x8b1f) { /* gzip header */
                state.check = 0 /*crc32(0L, Z_NULL, 0)*/ ;
                //=== CRC2(state.check, hold);
                hbuf[0] = hold & 0xff;
                hbuf[1] = (hold >>> 8) & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
                //===//

                //=== INITBITS();
                hold = 0;
                bits = 0;
                //===//
                state.mode = FLAGS;
                break;
              }
              state.flags = 0; /* expect zlib header */
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
                (((hold & 0xff) /*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
                strm.msg = 'incorrect header check';
                state.mode = BAD;
                break;
              }
              if ((hold & 0x0f) /*BITS(4)*/ !== Z_DEFLATED$1) {
                strm.msg = 'unknown compression method';
                state.mode = BAD;
                break;
              }
              //--- DROPBITS(4) ---//
              hold >>>= 4;
              bits -= 4;
              //---//
              len = (hold & 0x0f) /*BITS(4)*/ + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = 'invalid window size';
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              //Tracev((stderr, "inflate:   zlib header ok\n"));
              strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;
              state.mode = hold & 0x200 ? DICTID : TYPE;
              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
              break;
            case FLAGS:
              //=== NEEDBITS(16); */
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              state.flags = hold;
              if ((state.flags & 0xff) !== Z_DEFLATED$1) {
                strm.msg = 'unknown compression method';
                state.mode = BAD;
                break;
              }
              if (state.flags & 0xe000) {
                strm.msg = 'unknown header flags set';
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = ((hold >> 8) & 1);
              }
              if (state.flags & 0x0200) {
                //=== CRC2(state.check, hold);
                hbuf[0] = hold & 0xff;
                hbuf[1] = (hold >>> 8) & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
                //===//
              }
              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
              state.mode = TIME;
              /* falls through */
            case TIME:
              //=== NEEDBITS(32); */
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 0x0200) {
                //=== CRC4(state.check, hold)
                hbuf[0] = hold & 0xff;
                hbuf[1] = (hold >>> 8) & 0xff;
                hbuf[2] = (hold >>> 16) & 0xff;
                hbuf[3] = (hold >>> 24) & 0xff;
                state.check = crc32(state.check, hbuf, 4, 0);
                //===
              }
              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
              state.mode = OS;
              /* falls through */
            case OS:
              //=== NEEDBITS(16); */
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              if (state.head) {
                state.head.xflags = (hold & 0xff);
                state.head.os = (hold >> 8);
              }
              if (state.flags & 0x0200) {
                //=== CRC2(state.check, hold);
                hbuf[0] = hold & 0xff;
                hbuf[1] = (hold >>> 8) & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
                //===//
              }
              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
              state.mode = EXLEN;
              /* falls through */
            case EXLEN:
              if (state.flags & 0x0400) {
                //=== NEEDBITS(16); */
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 0x0200) {
                  //=== CRC2(state.check, hold);
                  hbuf[0] = hold & 0xff;
                  hbuf[1] = (hold >>> 8) & 0xff;
                  state.check = crc32(state.check, hbuf, 2, 0);
                  //===//
                }
                //=== INITBITS();
                hold = 0;
                bits = 0;
                //===//
              } else if (state.head) {
                state.head.extra = null /*Z_NULL*/ ;
              }
              state.mode = EXTRA;
              /* falls through */
            case EXTRA:
              if (state.flags & 0x0400) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      // Use untyped array for more conveniend processing later
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                    //zmemcpy(state.head.extra + len, next,
                    //        len + copy > state.head.extra_max ?
                    //        state.head.extra_max - len : copy);
                  }
                  if (state.flags & 0x0200) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
              /* falls through */
            case NAME:
              if (state.flags & 0x0800) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  // TODO: 2 or 1 bytes?
                  len = input[next + copy++];
                  /* use constant limit because in js we should not preallocate memory */
                  if (state.head && len &&
                    (state.length < 65536 /*state.head.name_max*/ )) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);

                if (state.flags & 0x0200) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT$1;
              /* falls through */
            case COMMENT$1:
              if (state.flags & 0x1000) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  /* use constant limit because in js we should not preallocate memory */
                  if (state.head && len &&
                    (state.length < 65536 /*state.head.comm_max*/ )) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 0x0200) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
              /* falls through */
            case HCRC:
              if (state.flags & 0x0200) {
                //=== NEEDBITS(16); */
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                if (hold !== (state.check & 0xffff)) {
                  strm.msg = 'header crc mismatch';
                  state.mode = BAD;
                  break;
                }
                //=== INITBITS();
                hold = 0;
                bits = 0;
                //===//
              }
              if (state.head) {
                state.head.hcrc = ((state.flags >> 9) & 1);
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              //=== NEEDBITS(32); */
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              strm.adler = state.check = zswap32(hold);
              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
              state.mode = DICT;
              /* falls through */
            case DICT:
              if (state.havedict === 0) {
                //--- RESTORE() ---
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                //---
                return Z_NEED_DICT$1;
              }
              strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;
              state.mode = TYPE;
              /* falls through */
            case TYPE:
              if (flush === Z_BLOCK$1 || flush === Z_TREES$1) {
                break inf_leave;
              }
              /* falls through */
            case TYPEDO:
              if (state.last) {
                //--- BYTEBITS() ---//
                hold >>>= bits & 7;
                bits -= bits & 7;
                //---//
                state.mode = CHECK;
                break;
              }
              //=== NEEDBITS(3); */
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              state.last = (hold & 0x01) /*BITS(1)*/ ;
              //--- DROPBITS(1) ---//
              hold >>>= 1;
              bits -= 1;
              //---//

              switch ((hold & 0x03) /*BITS(2)*/ ) {
              case 0:
                /* stored block */
                //Tracev((stderr, "inflate:     stored block%s\n",
                //        state.last ? " (last)" : ""));
                state.mode = STORED;
                break;
              case 1:
                /* fixed block */
                fixedtables(state);
                //Tracev((stderr, "inflate:     fixed codes block%s\n",
                //        state.last ? " (last)" : ""));
                state.mode = LEN_; /* decode codes */
                if (flush === Z_TREES$1) {
                  //--- DROPBITS(2) ---//
                  hold >>>= 2;
                  bits -= 2;
                  //---//
                  break inf_leave;
                }
                break;
              case 2:
                /* dynamic block */
                //Tracev((stderr, "inflate:     dynamic codes block%s\n",
                //        state.last ? " (last)" : ""));
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = 'invalid block type';
                state.mode = BAD;
              }
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break;
            case STORED:
              //--- BYTEBITS() ---// /* go to byte boundary */
              hold >>>= bits & 7;
              bits -= bits & 7;
              //---//
              //=== NEEDBITS(32); */
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
                strm.msg = 'invalid stored block lengths';
                state.mode = BAD;
                break;
              }
              state.length = hold & 0xffff;
              //Tracev((stderr, "inflate:       stored length %u\n",
              //        state.length));
              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
              state.mode = COPY_;
              if (flush === Z_TREES$1) {
                break inf_leave;
              }
              /* falls through */
            case COPY_:
              state.mode = COPY;
              /* falls through */
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                //--- zmemcpy(put, next, copy); ---
                arraySet(output, input, next, copy, put);
                //---//
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              //Tracev((stderr, "inflate:       stored end\n"));
              state.mode = TYPE;
              break;
            case TABLE:
              //=== NEEDBITS(14); */
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              state.nlen = (hold & 0x1f) /*BITS(5)*/ + 257;
              //--- DROPBITS(5) ---//
              hold >>>= 5;
              bits -= 5;
              //---//
              state.ndist = (hold & 0x1f) /*BITS(5)*/ + 1;
              //--- DROPBITS(5) ---//
              hold >>>= 5;
              bits -= 5;
              //---//
              state.ncode = (hold & 0x0f) /*BITS(4)*/ + 4;
              //--- DROPBITS(4) ---//
              hold >>>= 4;
              bits -= 4;
              //---//
              //#ifndef PKZIP_BUG_WORKAROUND
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = 'too many length or distance symbols';
                state.mode = BAD;
                break;
              }
              //#endif
              //Tracev((stderr, "inflate:       table sizes ok\n"));
              state.have = 0;
              state.mode = LENLENS;
              /* falls through */
            case LENLENS:
              while (state.have < state.ncode) {
                //=== NEEDBITS(3);
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                state.lens[order[state.have++]] = (hold & 0x07); //BITS(3);
                //--- DROPBITS(3) ---//
                hold >>>= 3;
                bits -= 3;
                //---//
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              // We have separate tables & no pointers. 2 commented lines below not needed.
              //state.next = state.codes;
              //state.lencode = state.next;
              // Switch to use dynamic table
              state.lencode = state.lendyn;
              state.lenbits = 7;

              opts = {
                bits: state.lenbits
              };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;

              if (ret) {
                strm.msg = 'invalid code lengths set';
                state.mode = BAD;
                break;
              }
              //Tracev((stderr, "inflate:       code lengths ok\n"));
              state.have = 0;
              state.mode = CODELENS;
              /* falls through */
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (;;) {
                  here = state.lencode[hold & ((1 << state.lenbits) - 1)]; /*BITS(state.lenbits)*/
                  here_bits = here >>> 24;
                  here_op = (here >>> 16) & 0xff;
                  here_val = here & 0xffff;

                  if ((here_bits) <= bits) {
                    break;
                  }
                  //--- PULLBYTE() ---//
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                  //---//
                }
                if (here_val < 16) {
                  //--- DROPBITS(here.bits) ---//
                  hold >>>= here_bits;
                  bits -= here_bits;
                  //---//
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    //=== NEEDBITS(here.bits + 2);
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    //===//
                    //--- DROPBITS(here.bits) ---//
                    hold >>>= here_bits;
                    bits -= here_bits;
                    //---//
                    if (state.have === 0) {
                      strm.msg = 'invalid bit length repeat';
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 0x03); //BITS(2);
                    //--- DROPBITS(2) ---//
                    hold >>>= 2;
                    bits -= 2;
                    //---//
                  } else if (here_val === 17) {
                    //=== NEEDBITS(here.bits + 3);
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    //===//
                    //--- DROPBITS(here.bits) ---//
                    hold >>>= here_bits;
                    bits -= here_bits;
                    //---//
                    len = 0;
                    copy = 3 + (hold & 0x07); //BITS(3);
                    //--- DROPBITS(3) ---//
                    hold >>>= 3;
                    bits -= 3;
                    //---//
                  } else {
                    //=== NEEDBITS(here.bits + 7);
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    //===//
                    //--- DROPBITS(here.bits) ---//
                    hold >>>= here_bits;
                    bits -= here_bits;
                    //---//
                    len = 0;
                    copy = 11 + (hold & 0x7f); //BITS(7);
                    //--- DROPBITS(7) ---//
                    hold >>>= 7;
                    bits -= 7;
                    //---//
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = 'invalid bit length repeat';
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }

              /* handle error breaks in while */
              if (state.mode === BAD) {
                break;
              }

              /* check for end-of-block code (better have one) */
              if (state.lens[256] === 0) {
                strm.msg = 'invalid code -- missing end-of-block';
                state.mode = BAD;
                break;
              }

              /* build code tables -- note: do not change the lenbits or distbits
                 values here (9 and 6) without reading the comments in inftrees.h
                 concerning the ENOUGH constants, which depend on those values */
              state.lenbits = 9;

              opts = {
                bits: state.lenbits
              };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              // We have separate tables & no pointers. 2 commented lines below not needed.
              // state.next_index = opts.table_index;
              state.lenbits = opts.bits;
              // state.lencode = state.next;

              if (ret) {
                strm.msg = 'invalid literal/lengths set';
                state.mode = BAD;
                break;
              }

              state.distbits = 6;
              //state.distcode.copy(state.codes);
              // Switch to use dynamic table
              state.distcode = state.distdyn;
              opts = {
                bits: state.distbits
              };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              // We have separate tables & no pointers. 2 commented lines below not needed.
              // state.next_index = opts.table_index;
              state.distbits = opts.bits;
              // state.distcode = state.next;

              if (ret) {
                strm.msg = 'invalid distances set';
                state.mode = BAD;
                break;
              }
              //Tracev((stderr, 'inflate:       codes ok\n'));
              state.mode = LEN_;
              if (flush === Z_TREES$1) {
                break inf_leave;
              }
              /* falls through */
            case LEN_:
              state.mode = LEN;
              /* falls through */
            case LEN:
              if (have >= 6 && left >= 258) {
                //--- RESTORE() ---
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                //---
                inflate_fast(strm, _out);
                //--- LOAD() ---
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                //---

                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (;;) {
                here = state.lencode[hold & ((1 << state.lenbits) - 1)]; /*BITS(state.lenbits)*/
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;

                if (here_bits <= bits) {
                  break;
                }
                //--- PULLBYTE() ---//
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
                //---//
              }
              if (here_op && (here_op & 0xf0) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (;;) {
                  here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1)) /*BITS(last.bits + last.op)*/ >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = (here >>> 16) & 0xff;
                  here_val = here & 0xffff;

                  if ((last_bits + here_bits) <= bits) {
                    break;
                  }
                  //--- PULLBYTE() ---//
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                  //---//
                }
                //--- DROPBITS(last.bits) ---//
                hold >>>= last_bits;
                bits -= last_bits;
                //---//
                state.back += last_bits;
              }
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                //        "inflate:         literal '%c'\n" :
                //        "inflate:         literal 0x%02x\n", here.val));
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                //Tracevv((stderr, "inflate:         end of block\n"));
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = 'invalid literal/length code';
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
              /* falls through */
            case LENEXT:
              if (state.extra) {
                //=== NEEDBITS(state.extra);
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                state.length += hold & ((1 << state.extra) - 1) /*BITS(state.extra)*/ ;
                //--- DROPBITS(state.extra) ---//
                hold >>>= state.extra;
                bits -= state.extra;
                //---//
                state.back += state.extra;
              }
              //Tracevv((stderr, "inflate:         length %u\n", state.length));
              state.was = state.length;
              state.mode = DIST;
              /* falls through */
            case DIST:
              for (;;) {
                here = state.distcode[hold & ((1 << state.distbits) - 1)]; /*BITS(state.distbits)*/
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;

                if ((here_bits) <= bits) {
                  break;
                }
                //--- PULLBYTE() ---//
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
                //---//
              }
              if ((here_op & 0xf0) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (;;) {
                  here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1)) /*BITS(last.bits + last.op)*/ >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = (here >>> 16) & 0xff;
                  here_val = here & 0xffff;

                  if ((last_bits + here_bits) <= bits) {
                    break;
                  }
                  //--- PULLBYTE() ---//
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                  //---//
                }
                //--- DROPBITS(last.bits) ---//
                hold >>>= last_bits;
                bits -= last_bits;
                //---//
                state.back += last_bits;
              }
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = 'invalid distance code';
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = (here_op) & 15;
              state.mode = DISTEXT;
              /* falls through */
            case DISTEXT:
              if (state.extra) {
                //=== NEEDBITS(state.extra);
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                state.offset += hold & ((1 << state.extra) - 1) /*BITS(state.extra)*/ ;
                //--- DROPBITS(state.extra) ---//
                hold >>>= state.extra;
                bits -= state.extra;
                //---//
                state.back += state.extra;
              }
              //#ifdef INFLATE_STRICT
              if (state.offset > state.dmax) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break;
              }
              //#endif
              //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
              state.mode = MATCH;
              /* falls through */
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) { /* copy from window */
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD;
                    break;
                  }
                  // (!) This block is disabled in zlib defailts,
                  // don't enable it for binary compatibility
                  //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                  //          Trace((stderr, "inflate.c too far\n"));
                  //          copy -= state.whave;
                  //          if (copy > state.length) { copy = state.length; }
                  //          if (copy > left) { copy = left; }
                  //          left -= copy;
                  //          state.length -= copy;
                  //          do {
                  //            output[put++] = 0;
                  //          } while (--copy);
                  //          if (state.length === 0) { state.mode = LEN; }
                  //          break;
                  //#endif
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else { /* copy from output */
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                //=== NEEDBITS(32);
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  // Use '|' insdead of '+' to make sure that result is signed
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                //===//
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check =
                    /*UPDATE(state.check, put - _out, _out);*/
                    (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

                }
                _out = left;
                // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = 'incorrect data check';
                  state.mode = BAD;
                  break;
                }
                //=== INITBITS();
                hold = 0;
                bits = 0;
                //===//
                //Tracev((stderr, "inflate:   check matches trailer\n"));
              }
              state.mode = LENGTH;
              /* falls through */
            case LENGTH:
              if (state.wrap && state.flags) {
                //=== NEEDBITS(32);
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                if (hold !== (state.total & 0xffffffff)) {
                  strm.msg = 'incorrect length check';
                  state.mode = BAD;
                  break;
                }
                //=== INITBITS();
                hold = 0;
                bits = 0;
                //===//
                //Tracev((stderr, "inflate:   length matches trailer\n"));
              }
              state.mode = DONE;
              /* falls through */
            case DONE:
              ret = Z_STREAM_END$1;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR$1;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
              /* falls through */
            default:
              return Z_STREAM_ERROR$1;
            }
          }

        // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

        /*
           Return from inflate(), updating the total counts and the check value.
           If there was no progress during the inflate() call, return a buffer
           error.  Call updatewindow() to create and/or update the window state.
           Note: a memory error from inflate() is non-recoverable.
         */

        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---

        if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
            (state.mode < CHECK || flush !== Z_FINISH$1))) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
          strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
            (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) +
          (state.mode === TYPE ? 128 : 0) +
          (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
          ret = Z_BUF_ERROR$1;
        }
        return ret;
      }

      function inflateEnd(strm) {

        if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/ ) {
          return Z_STREAM_ERROR$1;
        }

        var state = strm.state;
        if (state.window) {
          state.window = null;
        }
        strm.state = null;
        return Z_OK$1;
      }

      /* Not implemented
      exports.inflateCopy = inflateCopy;
      exports.inflateGetDictionary = inflateGetDictionary;
      exports.inflateMark = inflateMark;
      exports.inflatePrime = inflatePrime;
      exports.inflateSync = inflateSync;
      exports.inflateSyncPoint = inflateSyncPoint;
      exports.inflateUndermine = inflateUndermine;
      */

      // import constants from './constants';


      // zlib modes
      var NONE = 0;
      var DEFLATE = 1;
      var INFLATE = 2;
      var GZIP = 3;
      var GUNZIP = 4;
      var DEFLATERAW = 5;
      var INFLATERAW = 6;
      var UNZIP = 7;
      var Z_NO_FLUSH=         0,
        Z_PARTIAL_FLUSH=    1,
        Z_SYNC_FLUSH=    2,
        Z_FULL_FLUSH=       3,
        Z_FINISH=       4,
        Z_BLOCK=           5,
        Z_TREES=            6,

        /* Return codes for the compression/decompression functions. Negative values
        * are errors, positive values are used for special but normal events.
        */
        Z_OK=               0,
        Z_STREAM_END=       1,
        Z_NEED_DICT=      2,
        Z_ERRNO=       -1,
        Z_STREAM_ERROR=   -2,
        Z_DATA_ERROR=    -3,
        //Z_MEM_ERROR:     -4,
        Z_BUF_ERROR=    -5,
        //Z_VERSION_ERROR: -6,

        /* compression levels */
        Z_NO_COMPRESSION=         0,
        Z_BEST_SPEED=             1,
        Z_BEST_COMPRESSION=       9,
        Z_DEFAULT_COMPRESSION=   -1,


        Z_FILTERED=               1,
        Z_HUFFMAN_ONLY=           2,
        Z_RLE=                    3,
        Z_FIXED=                  4,
        Z_DEFAULT_STRATEGY=       0,

        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY=                 0,
        Z_TEXT=                   1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN=                2,

        /* The deflate compression method */
        Z_DEFLATED=               8;
      function Zlib$1(mode) {
        if (mode < DEFLATE || mode > UNZIP)
          throw new TypeError('Bad argument');

        this.mode = mode;
        this.init_done = false;
        this.write_in_progress = false;
        this.pending_close = false;
        this.windowBits = 0;
        this.level = 0;
        this.memLevel = 0;
        this.strategy = 0;
        this.dictionary = null;
      }

      Zlib$1.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
        this.windowBits = windowBits;
        this.level = level;
        this.memLevel = memLevel;
        this.strategy = strategy;
        // dictionary not supported.

        if (this.mode === GZIP || this.mode === GUNZIP)
          this.windowBits += 16;

        if (this.mode === UNZIP)
          this.windowBits += 32;

        if (this.mode === DEFLATERAW || this.mode === INFLATERAW)
          this.windowBits = -this.windowBits;

        this.strm = new ZStream();
        var status;
        switch (this.mode) {
        case DEFLATE:
        case GZIP:
        case DEFLATERAW:
          status = deflateInit2(
            this.strm,
            this.level,
            Z_DEFLATED,
            this.windowBits,
            this.memLevel,
            this.strategy
          );
          break;
        case INFLATE:
        case GUNZIP:
        case INFLATERAW:
        case UNZIP:
          status  = inflateInit2(
            this.strm,
            this.windowBits
          );
          break;
        default:
          throw new Error('Unknown mode ' + this.mode);
        }

        if (status !== Z_OK) {
          this._error(status);
          return;
        }

        this.write_in_progress = false;
        this.init_done = true;
      };

      Zlib$1.prototype.params = function() {
        throw new Error('deflateParams Not supported');
      };

      Zlib$1.prototype._writeCheck = function() {
        if (!this.init_done)
          throw new Error('write before init');

        if (this.mode === NONE)
          throw new Error('already finalized');

        if (this.write_in_progress)
          throw new Error('write already in progress');

        if (this.pending_close)
          throw new Error('close is pending');
      };

      Zlib$1.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
        this._writeCheck();
        this.write_in_progress = true;

        var self = this;
        browser$1.nextTick(function() {
          self.write_in_progress = false;
          var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
          self.callback(res[0], res[1]);

          if (self.pending_close)
            self.close();
        });

        return this;
      };

      // set method for Node buffers, used by pako
      function bufferSet(data, offset) {
        for (var i = 0; i < data.length; i++) {
          this[offset + i] = data[i];
        }
      }

      Zlib$1.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
        this._writeCheck();
        return this._write(flush, input, in_off, in_len, out, out_off, out_len);
      };

      Zlib$1.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {
        this.write_in_progress = true;

        if (flush !== Z_NO_FLUSH &&
            flush !== Z_PARTIAL_FLUSH &&
            flush !== Z_SYNC_FLUSH &&
            flush !== Z_FULL_FLUSH &&
            flush !== Z_FINISH &&
            flush !== Z_BLOCK) {
          throw new Error('Invalid flush value');
        }

        if (input == null) {
          input = new Buffer$1(0);
          in_len = 0;
          in_off = 0;
        }

        if (out._set)
          out.set = out._set;
        else
          out.set = bufferSet;

        var strm = this.strm;
        strm.avail_in = in_len;
        strm.input = input;
        strm.next_in = in_off;
        strm.avail_out = out_len;
        strm.output = out;
        strm.next_out = out_off;
        var status;
        switch (this.mode) {
        case DEFLATE:
        case GZIP:
        case DEFLATERAW:
          status = deflate$1(strm, flush);
          break;
        case UNZIP:
        case INFLATE:
        case GUNZIP:
        case INFLATERAW:
          status = inflate$1(strm, flush);
          break;
        default:
          throw new Error('Unknown mode ' + this.mode);
        }

        if (status !== Z_STREAM_END && status !== Z_OK) {
          this._error(status);
        }

        this.write_in_progress = false;
        return [strm.avail_in, strm.avail_out];
      };

      Zlib$1.prototype.close = function() {
        if (this.write_in_progress) {
          this.pending_close = true;
          return;
        }

        this.pending_close = false;

        if (this.mode === DEFLATE || this.mode === GZIP || this.mode === DEFLATERAW) {
          deflateEnd(this.strm);
        } else {
          inflateEnd(this.strm);
        }

        this.mode = NONE;
      };
      var status;
      Zlib$1.prototype.reset = function() {
        switch (this.mode) {
        case DEFLATE:
        case DEFLATERAW:
          status = deflateReset(this.strm);
          break;
        case INFLATE:
        case INFLATERAW:
          status = inflateReset(this.strm);
          break;
        }

        if (status !== Z_OK) {
          this._error(status);
        }
      };

      Zlib$1.prototype._error = function(status) {
        this.onerror(msg[status] + ': ' + this.strm.msg, status);

        this.write_in_progress = false;
        if (this.pending_close)
          this.close();
      };

      var _binding = /*#__PURE__*/Object.freeze({
        __proto__: null,
        NONE: NONE,
        DEFLATE: DEFLATE,
        INFLATE: INFLATE,
        GZIP: GZIP,
        GUNZIP: GUNZIP,
        DEFLATERAW: DEFLATERAW,
        INFLATERAW: INFLATERAW,
        UNZIP: UNZIP,
        Z_NO_FLUSH: Z_NO_FLUSH,
        Z_PARTIAL_FLUSH: Z_PARTIAL_FLUSH,
        Z_SYNC_FLUSH: Z_SYNC_FLUSH,
        Z_FULL_FLUSH: Z_FULL_FLUSH,
        Z_FINISH: Z_FINISH,
        Z_BLOCK: Z_BLOCK,
        Z_TREES: Z_TREES,
        Z_OK: Z_OK,
        Z_STREAM_END: Z_STREAM_END,
        Z_NEED_DICT: Z_NEED_DICT,
        Z_ERRNO: Z_ERRNO,
        Z_STREAM_ERROR: Z_STREAM_ERROR,
        Z_DATA_ERROR: Z_DATA_ERROR,
        Z_BUF_ERROR: Z_BUF_ERROR,
        Z_NO_COMPRESSION: Z_NO_COMPRESSION,
        Z_BEST_SPEED: Z_BEST_SPEED,
        Z_BEST_COMPRESSION: Z_BEST_COMPRESSION,
        Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION,
        Z_FILTERED: Z_FILTERED,
        Z_HUFFMAN_ONLY: Z_HUFFMAN_ONLY,
        Z_RLE: Z_RLE,
        Z_FIXED: Z_FIXED,
        Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY,
        Z_BINARY: Z_BINARY,
        Z_TEXT: Z_TEXT,
        Z_UNKNOWN: Z_UNKNOWN,
        Z_DEFLATED: Z_DEFLATED,
        Zlib: Zlib$1
      });

      function assert (a, msg) {
        if (!a) {
          throw new Error(msg);
        }
      }
      var binding = {};
      Object.keys(_binding).forEach(function (key) {
        binding[key] = _binding[key];
      });
      // zlib doesn't provide these, so kludge them in following the same
      // const naming scheme zlib uses.
      binding.Z_MIN_WINDOWBITS = 8;
      binding.Z_MAX_WINDOWBITS = 15;
      binding.Z_DEFAULT_WINDOWBITS = 15;

      // fewer than 64 bytes per chunk is stupid.
      // technically it could work with as few as 8, but even 64 bytes
      // is absurdly low.  Usually a MB or more is best.
      binding.Z_MIN_CHUNK = 64;
      binding.Z_MAX_CHUNK = Infinity;
      binding.Z_DEFAULT_CHUNK = (16 * 1024);

      binding.Z_MIN_MEMLEVEL = 1;
      binding.Z_MAX_MEMLEVEL = 9;
      binding.Z_DEFAULT_MEMLEVEL = 8;

      binding.Z_MIN_LEVEL = -1;
      binding.Z_MAX_LEVEL = 9;
      binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;


      // translation table for return codes.
      var codes = {
        Z_OK: binding.Z_OK,
        Z_STREAM_END: binding.Z_STREAM_END,
        Z_NEED_DICT: binding.Z_NEED_DICT,
        Z_ERRNO: binding.Z_ERRNO,
        Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
        Z_DATA_ERROR: binding.Z_DATA_ERROR,
        Z_MEM_ERROR: binding.Z_MEM_ERROR,
        Z_BUF_ERROR: binding.Z_BUF_ERROR,
        Z_VERSION_ERROR: binding.Z_VERSION_ERROR
      };

      Object.keys(codes).forEach(function(k) {
        codes[codes[k]] = k;
      });

      function createDeflate(o) {
        return new Deflate(o);
      }

      function createInflate(o) {
        return new Inflate(o);
      }

      function createDeflateRaw(o) {
        return new DeflateRaw(o);
      }

      function createInflateRaw(o) {
        return new InflateRaw(o);
      }

      function createGzip(o) {
        return new Gzip(o);
      }

      function createGunzip(o) {
        return new Gunzip(o);
      }

      function createUnzip(o) {
        return new Unzip(o);
      }


      // Convenience methods.
      // compress/decompress a string or buffer in one step.
      function deflate(buffer, opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        return zlibBuffer(new Deflate(opts), buffer, callback);
      }

      function deflateSync(buffer, opts) {
        return zlibBufferSync(new Deflate(opts), buffer);
      }

      function gzip$1(buffer, opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        return zlibBuffer(new Gzip(opts), buffer, callback);
      }

      function gzipSync(buffer, opts) {
        return zlibBufferSync(new Gzip(opts), buffer);
      }

      function deflateRaw(buffer, opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        return zlibBuffer(new DeflateRaw(opts), buffer, callback);
      }

      function deflateRawSync(buffer, opts) {
        return zlibBufferSync(new DeflateRaw(opts), buffer);
      }

      function unzip(buffer, opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        return zlibBuffer(new Unzip(opts), buffer, callback);
      }

      function unzipSync(buffer, opts) {
        return zlibBufferSync(new Unzip(opts), buffer);
      }

      function inflate(buffer, opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        return zlibBuffer(new Inflate(opts), buffer, callback);
      }

      function inflateSync(buffer, opts) {
        return zlibBufferSync(new Inflate(opts), buffer);
      }

      function gunzip(buffer, opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        return zlibBuffer(new Gunzip(opts), buffer, callback);
      }

      function gunzipSync(buffer, opts) {
        return zlibBufferSync(new Gunzip(opts), buffer);
      }

      function inflateRaw(buffer, opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        return zlibBuffer(new InflateRaw(opts), buffer, callback);
      }

      function inflateRawSync(buffer, opts) {
        return zlibBufferSync(new InflateRaw(opts), buffer);
      }

      function zlibBuffer(engine, buffer, callback) {
        var buffers = [];
        var nread = 0;

        engine.on('error', onError);
        engine.on('end', onEnd);

        engine.end(buffer);
        flow();

        function flow() {
          var chunk;
          while (null !== (chunk = engine.read())) {
            buffers.push(chunk);
            nread += chunk.length;
          }
          engine.once('readable', flow);
        }

        function onError(err) {
          engine.removeListener('end', onEnd);
          engine.removeListener('readable', flow);
          callback(err);
        }

        function onEnd() {
          var buf = Buffer$1.concat(buffers, nread);
          buffers = [];
          callback(null, buf);
          engine.close();
        }
      }

      function zlibBufferSync(engine, buffer) {
        if (typeof buffer === 'string')
          buffer = new Buffer$1(buffer);
        if (!Buffer$1.isBuffer(buffer))
          throw new TypeError('Not a string or buffer');

        var flushFlag = binding.Z_FINISH;

        return engine._processChunk(buffer, flushFlag);
      }

      // generic zlib
      // minimal 2-byte header
      function Deflate(opts) {
        if (!(this instanceof Deflate)) return new Deflate(opts);
        Zlib.call(this, opts, binding.DEFLATE);
      }

      function Inflate(opts) {
        if (!(this instanceof Inflate)) return new Inflate(opts);
        Zlib.call(this, opts, binding.INFLATE);
      }



      // gzip - bigger header, same deflate compression
      function Gzip(opts) {
        if (!(this instanceof Gzip)) return new Gzip(opts);
        Zlib.call(this, opts, binding.GZIP);
      }

      function Gunzip(opts) {
        if (!(this instanceof Gunzip)) return new Gunzip(opts);
        Zlib.call(this, opts, binding.GUNZIP);
      }



      // raw - no header
      function DeflateRaw(opts) {
        if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
        Zlib.call(this, opts, binding.DEFLATERAW);
      }

      function InflateRaw(opts) {
        if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
        Zlib.call(this, opts, binding.INFLATERAW);
      }


      // auto-detect header.
      function Unzip(opts) {
        if (!(this instanceof Unzip)) return new Unzip(opts);
        Zlib.call(this, opts, binding.UNZIP);
      }


      // the Zlib class they all inherit from
      // This thing manages the queue of requests, and returns
      // true or false if there is anything in the queue when
      // you call the .write() method.

      function Zlib(opts, mode) {
        this._opts = opts = opts || {};
        this._chunkSize = opts.chunkSize || binding.Z_DEFAULT_CHUNK;

        Transform.call(this, opts);

        if (opts.flush) {
          if (opts.flush !== binding.Z_NO_FLUSH &&
              opts.flush !== binding.Z_PARTIAL_FLUSH &&
              opts.flush !== binding.Z_SYNC_FLUSH &&
              opts.flush !== binding.Z_FULL_FLUSH &&
              opts.flush !== binding.Z_FINISH &&
              opts.flush !== binding.Z_BLOCK) {
            throw new Error('Invalid flush flag: ' + opts.flush);
          }
        }
        this._flushFlag = opts.flush || binding.Z_NO_FLUSH;

        if (opts.chunkSize) {
          if (opts.chunkSize < binding.Z_MIN_CHUNK ||
              opts.chunkSize > binding.Z_MAX_CHUNK) {
            throw new Error('Invalid chunk size: ' + opts.chunkSize);
          }
        }

        if (opts.windowBits) {
          if (opts.windowBits < binding.Z_MIN_WINDOWBITS ||
              opts.windowBits > binding.Z_MAX_WINDOWBITS) {
            throw new Error('Invalid windowBits: ' + opts.windowBits);
          }
        }

        if (opts.level) {
          if (opts.level < binding.Z_MIN_LEVEL ||
              opts.level > binding.Z_MAX_LEVEL) {
            throw new Error('Invalid compression level: ' + opts.level);
          }
        }

        if (opts.memLevel) {
          if (opts.memLevel < binding.Z_MIN_MEMLEVEL ||
              opts.memLevel > binding.Z_MAX_MEMLEVEL) {
            throw new Error('Invalid memLevel: ' + opts.memLevel);
          }
        }

        if (opts.strategy) {
          if (opts.strategy != binding.Z_FILTERED &&
              opts.strategy != binding.Z_HUFFMAN_ONLY &&
              opts.strategy != binding.Z_RLE &&
              opts.strategy != binding.Z_FIXED &&
              opts.strategy != binding.Z_DEFAULT_STRATEGY) {
            throw new Error('Invalid strategy: ' + opts.strategy);
          }
        }

        if (opts.dictionary) {
          if (!Buffer$1.isBuffer(opts.dictionary)) {
            throw new Error('Invalid dictionary: it should be a Buffer instance');
          }
        }

        this._binding = new binding.Zlib(mode);

        var self = this;
        this._hadError = false;
        this._binding.onerror = function(message, errno) {
          // there is no way to cleanly recover.
          // continuing only obscures problems.
          self._binding = null;
          self._hadError = true;

          var error = new Error(message);
          error.errno = errno;
          error.code = binding.codes[errno];
          self.emit('error', error);
        };

        var level = binding.Z_DEFAULT_COMPRESSION;
        if (typeof opts.level === 'number') level = opts.level;

        var strategy = binding.Z_DEFAULT_STRATEGY;
        if (typeof opts.strategy === 'number') strategy = opts.strategy;

        this._binding.init(opts.windowBits || binding.Z_DEFAULT_WINDOWBITS,
                           level,
                           opts.memLevel || binding.Z_DEFAULT_MEMLEVEL,
                           strategy,
                           opts.dictionary);

        this._buffer = new Buffer$1(this._chunkSize);
        this._offset = 0;
        this._closed = false;
        this._level = level;
        this._strategy = strategy;

        this.once('end', this.close);
      }

      inherits$1(Zlib, Transform);

      Zlib.prototype.params = function(level, strategy, callback) {
        if (level < binding.Z_MIN_LEVEL ||
            level > binding.Z_MAX_LEVEL) {
          throw new RangeError('Invalid compression level: ' + level);
        }
        if (strategy != binding.Z_FILTERED &&
            strategy != binding.Z_HUFFMAN_ONLY &&
            strategy != binding.Z_RLE &&
            strategy != binding.Z_FIXED &&
            strategy != binding.Z_DEFAULT_STRATEGY) {
          throw new TypeError('Invalid strategy: ' + strategy);
        }

        if (this._level !== level || this._strategy !== strategy) {
          var self = this;
          this.flush(binding.Z_SYNC_FLUSH, function() {
            self._binding.params(level, strategy);
            if (!self._hadError) {
              self._level = level;
              self._strategy = strategy;
              if (callback) callback();
            }
          });
        } else {
          browser$1.nextTick(callback);
        }
      };

      Zlib.prototype.reset = function() {
        return this._binding.reset();
      };

      // This is the _flush function called by the transform class,
      // internally, when the last chunk has been written.
      Zlib.prototype._flush = function(callback) {
        this._transform(new Buffer$1(0), '', callback);
      };

      Zlib.prototype.flush = function(kind, callback) {
        var ws = this._writableState;

        if (typeof kind === 'function' || (kind === void 0 && !callback)) {
          callback = kind;
          kind = binding.Z_FULL_FLUSH;
        }

        if (ws.ended) {
          if (callback)
            browser$1.nextTick(callback);
        } else if (ws.ending) {
          if (callback)
            this.once('end', callback);
        } else if (ws.needDrain) {
          var self = this;
          this.once('drain', function() {
            self.flush(callback);
          });
        } else {
          this._flushFlag = kind;
          this.write(new Buffer$1(0), '', callback);
        }
      };

      Zlib.prototype.close = function(callback) {
        if (callback)
          browser$1.nextTick(callback);

        if (this._closed)
          return;

        this._closed = true;

        this._binding.close();

        var self = this;
        browser$1.nextTick(function() {
          self.emit('close');
        });
      };

      Zlib.prototype._transform = function(chunk, encoding, cb) {
        var flushFlag;
        var ws = this._writableState;
        var ending = ws.ending || ws.ended;
        var last = ending && (!chunk || ws.length === chunk.length);

        if (!chunk === null && !Buffer$1.isBuffer(chunk))
          return cb(new Error('invalid input'));

        // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.
        // If it's explicitly flushing at some other time, then we use
        // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
        // goodness.
        if (last)
          flushFlag = binding.Z_FINISH;
        else {
          flushFlag = this._flushFlag;
          // once we've flushed the last of the queue, stop flushing and
          // go back to the normal behavior.
          if (chunk.length >= ws.length) {
            this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
          }
        }

        this._processChunk(chunk, flushFlag, cb);
      };

      Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
        var availInBefore = chunk && chunk.length;
        var availOutBefore = this._chunkSize - this._offset;
        var inOff = 0;

        var self = this;

        var async = typeof cb === 'function';

        if (!async) {
          var buffers = [];
          var nread = 0;

          var error;
          this.on('error', function(er) {
            error = er;
          });

          do {
            var res = this._binding.writeSync(flushFlag,
                                              chunk, // in
                                              inOff, // in_off
                                              availInBefore, // in_len
                                              this._buffer, // out
                                              this._offset, //out_off
                                              availOutBefore); // out_len
          } while (!this._hadError && callback(res[0], res[1]));

          if (this._hadError) {
            throw error;
          }

          var buf = Buffer$1.concat(buffers, nread);
          this.close();

          return buf;
        }

        var req = this._binding.write(flushFlag,
                                      chunk, // in
                                      inOff, // in_off
                                      availInBefore, // in_len
                                      this._buffer, // out
                                      this._offset, //out_off
                                      availOutBefore); // out_len

        req.buffer = chunk;
        req.callback = callback;

        function callback(availInAfter, availOutAfter) {
          if (self._hadError)
            return;

          var have = availOutBefore - availOutAfter;
          assert(have >= 0, 'have should not go down');

          if (have > 0) {
            var out = self._buffer.slice(self._offset, self._offset + have);
            self._offset += have;
            // serve some output to the consumer.
            if (async) {
              self.push(out);
            } else {
              buffers.push(out);
              nread += out.length;
            }
          }

          // exhausted the output buffer, or used all the input create a new one.
          if (availOutAfter === 0 || self._offset >= self._chunkSize) {
            availOutBefore = self._chunkSize;
            self._offset = 0;
            self._buffer = new Buffer$1(self._chunkSize);
          }

          if (availOutAfter === 0) {
            // Not actually done.  Need to reprocess.
            // Also, update the availInBefore to the availInAfter value,
            // so that if we have to hit it a third (fourth, etc.) time,
            // it'll have the correct byte counts.
            inOff += (availInBefore - availInAfter);
            availInBefore = availInAfter;

            if (!async)
              return true;

            var newReq = self._binding.write(flushFlag,
                                             chunk,
                                             inOff,
                                             availInBefore,
                                             self._buffer,
                                             self._offset,
                                             self._chunkSize);
            newReq.callback = callback; // this same function
            newReq.buffer = chunk;
            return;
          }

          if (!async)
            return false;

          // finished with the chunk.
          cb();
        }
      };

      inherits$1(Deflate, Zlib);
      inherits$1(Inflate, Zlib);
      inherits$1(Gzip, Zlib);
      inherits$1(Gunzip, Zlib);
      inherits$1(DeflateRaw, Zlib);
      inherits$1(InflateRaw, Zlib);
      inherits$1(Unzip, Zlib);
      var zlib = {
        codes: codes,
        createDeflate: createDeflate,
        createInflate: createInflate,
        createDeflateRaw: createDeflateRaw,
        createInflateRaw: createInflateRaw,
        createGzip: createGzip,
        createGunzip: createGunzip,
        createUnzip: createUnzip,
        deflate: deflate,
        deflateSync: deflateSync,
        gzip: gzip$1,
        gzipSync: gzipSync,
        deflateRaw: deflateRaw,
        deflateRawSync: deflateRawSync,
        unzip: unzip,
        unzipSync: unzipSync,
        inflate: inflate,
        inflateSync: inflateSync,
        gunzip: gunzip,
        gunzipSync: gunzipSync,
        inflateRaw: inflateRaw,
        inflateRawSync: inflateRawSync,
        Deflate: Deflate,
        Inflate: Inflate,
        Gzip: Gzip,
        Gunzip: Gunzip,
        DeflateRaw: DeflateRaw,
        InflateRaw: InflateRaw,
        Unzip: Unzip,
        Zlib: Zlib
      };

      var __varRecorder__$C = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.freezer/src/util/helpers.js", __contextModule__);

      var __moduleMeta__$l = {
        pathInPackage: function pathInPackage() {
          return "./src/util/helpers.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.freezer",
            version: "0.1.0"
          };
        }
      };

      var findUniqJsName = __varRecorder__$C["lively.freezer/src/util/helpers.js__define__"]("findUniqJsName", "function", function (name) {
        var boundNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        name = toJsIdentifier(name, true);

        while (boundNames.includes(name)) {
          name = incName(name);
        }

        return name;
      }, __moduleMeta__$l);

      __varRecorder__$C.findUniqJsName = findUniqJsName;

      var gzip = __varRecorder__$C["lively.freezer/src/util/helpers.js__define__"]("gzip", "function", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(blob) {
          var inflate,
              useBrotli,
              _yield$import,
              EvalBackendChooser,
              _yield$import2,
              RemoteCoreInterface,
              remoteInterface,
              res,
              compressionFn,
              compressed,
              _args = arguments;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  inflate = _args.length > 1 && _args[1] !== undefined ? _args[1] : true;
                  useBrotli = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;

                  if (__varRecorder__$C.isNode) {
                    _context.next = 20;
                    break;
                  }

                  _context.next = 5;
                  return Promise.resolve().then(function () { return evalBackendUi; });

                case 5:
                  _yield$import = _context.sent;
                  EvalBackendChooser = _yield$import["default"];
                  _context.next = 9;
                  return Promise.resolve().then(function () { return _interface; });

                case 9:
                  _yield$import2 = _context.sent;
                  RemoteCoreInterface = _yield$import2.RemoteCoreInterface;
                  _context.next = 13;
                  return EvalBackendChooser["default"].allEvalBackends();

                case 13:
                  _context.t0 = function (backend) {
                    return backend.coreInterface;
                  };

                  _context.t1 = function (coreInterface) {
                    return coreInterface instanceof RemoteCoreInterface;
                  };

                  remoteInterface = _context.sent.map(_context.t0).find(_context.t1);
                  _context.next = 18;
                  return remoteInterface.runEvalAndStringify("\n        let { gzip } = await System.import('lively.freezer/src/util/helpers.js');\n        await gzip(".concat(JSON.stringify(blob), ", ").concat(inflate, ", ").concat(useBrotli, ");"));

                case 18:
                  res = _context.sent;
                  return _context.abrupt("return", res);

                case 20:
                  if (__varRecorder__$C.isNode) {
                    _context.next = 22;
                    break;
                  }

                  return _context.abrupt("return");

                case 22:
                  compressionFn = useBrotli ? inflate ? zlib.brotliCompressSync : zlib.brotliDecompressSync : inflate ? zlib.gzipSync : zlib.gunzipSync;
                  blob = inflate ? blob : new Buffer(blob, "base64");
                  compressed = compressionFn(blob);
                  return _context.abrupt("return", compressed.toString(inflate ? "base64" : "utf8"));

                case 26:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }(), __moduleMeta__$l);

      __varRecorder__$C.gzip = gzip;

      var brotli = __varRecorder__$C["lively.freezer/src/util/helpers.js__define__"]("brotli", "function", /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(blob) {
          var inflate,
              _args2 = arguments;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  inflate = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : true;
                  _context2.next = 3;
                  return __varRecorder__$C.gzip(blob, inflate, true);

                case 3:
                  return _context2.abrupt("return", _context2.sent);

                case 4:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      }(), __moduleMeta__$l);

      __varRecorder__$C.brotli = brotli;

      var transpileAttributeConnections = __varRecorder__$C["lively.freezer/src/util/helpers.js__define__"]("transpileAttributeConnections", "function", function (snap) {
        var transpile = compose(function (c) {
          return "(".concat(c, ")");
        }, es5Transpilation, stringifyFunctionWithoutToplevelRecorder);
        Object.values(snap.snapshot).filter(function (m) {
          return Path(["lively.serializer-class-info", "className"]).get(m) === "AttributeConnection";
        }).forEach(function (m) {
          if (m.props.converterString) {
            return m.props.converterString.value = transpile(m.props.converterString.value);
          }

          if (m.props.updaterString) {
            return m.props.updaterString.value = transpile(m.props.updaterString.value);
          }
        });
      }, __moduleMeta__$l);

      __varRecorder__$C.transpileAttributeConnections = transpileAttributeConnections;

      var fixSourceForBugsInGoogleClosure = __varRecorder__$C["lively.freezer/src/util/helpers.js__define__"]("fixSourceForBugsInGoogleClosure", "function", function (id, source) {
        if (id.includes("rollup")) {
          return source.replace("if(({entryModules:this.entryModules,implicitEntryModules:this.implicitEntryModules}=await this.moduleLoader.addEntryModules((e=this.options.input,Array.isArray(e)?e.map(e=>({fileName:null,id:e,implicitlyLoadedAfter:[],importer:void 0,name:null})):Object.keys(e).map(t=>({fileName:null,id:e[t],implicitlyLoadedAfter:[],importer:void 0,name:t}))),!0)),0===this.entryModules.length)", "({entryModules:this.entryModules,implicitEntryModules:this.implicitEntryModules}=await this.moduleLoader.addEntryModules((e=this.options.input,Array.isArray(e)?e.map(e=>({fileName:null,id:e,implicitlyLoadedAfter:[],importer:void 0,name:null})):Object.keys(e).map(t=>({fileName:null,id:e[t],implicitlyLoadedAfter:[],importer:void 0,name:t}))),!0))\n      if(0===this.entryModules.length)");
        }

        if (id.includes("lottie-web") && source.includes("var loopIn, loop_in, loopOut, loop_out, smooth;")) {
          return source.replace("var loopIn, loop_in, loopOut, loop_out, smooth;", "function __capture__(...args) { if (args[100]) console.log(args) }; var loopIn, loop_in, loopOut, loop_out, smooth; __capture__($bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, radiansToDegrees, length);\n");
        }

        return source;
      }, __moduleMeta__$l);

      __varRecorder__$C.fixSourceForBugsInGoogleClosure = fixSourceForBugsInGoogleClosure;

      var evalOnServer = exports('e', __varRecorder__$C["lively.freezer/src/util/helpers.js__define__"]("evalOnServer", "function", /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(code) {
          var _yield$import3, EvalBackendChooser, _yield$import4, RemoteCoreInterface, remoteInterface;

          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (!__varRecorder__$C.isNode) {
                    _context3.next = 2;
                    break;
                  }

                  return _context3.abrupt("return", runEval(code));

                case 2:
                  _context3.next = 4;
                  return Promise.resolve().then(function () { return evalBackendUi; });

                case 4:
                  _yield$import3 = _context3.sent;
                  EvalBackendChooser = _yield$import3["default"];
                  _context3.next = 8;
                  return Promise.resolve().then(function () { return _interface; });

                case 8:
                  _yield$import4 = _context3.sent;
                  RemoteCoreInterface = _yield$import4.RemoteCoreInterface;
                  _context3.next = 12;
                  return EvalBackendChooser["default"].allEvalBackends();

                case 12:
                  _context3.t0 = function (backend) {
                    return backend.coreInterface;
                  };

                  _context3.t1 = function (coreInterface) {
                    return coreInterface instanceof RemoteCoreInterface;
                  };

                  remoteInterface = _context3.sent.map(_context3.t0).find(_context3.t1);
                  _context3.next = 17;
                  return remoteInterface.runEvalAndStringify(code, {
                    classTransform: classToFunctionTransform
                  });

                case 17:
                  return _context3.abrupt("return", _context3.sent);

                case 18:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function (_x3) {
          return _ref3.apply(this, arguments);
        };
      }(), __moduleMeta__$l));

      __varRecorder__$C.evalOnServer = evalOnServer;

      var getConfig = __varRecorder__$C["lively.freezer/src/util/helpers.js__define__"]("getConfig", "function", /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(resolver) {
          var os;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return __varRecorder__$C.evalOnServer("process.platform");

                case 2:
                  os = _context4.sent;
                  _context4.t0 = os;
                  _context4.next = 6;
                  return __varRecorder__$C.evalOnServer("require.resolve(\"lively.freezer\")");

                case 6:
                  _context4.t1 = _context4.sent.replace("/index.js", "");
                  _context4.next = 9;
                  return __varRecorder__$C.evalOnServer("require.resolve('@babel/preset-env').replace('file://', '')");

                case 9:
                  _context4.t2 = _context4.sent;
                  _context4.next = 12;
                  return __varRecorder__$C.evalOnServer("require.resolve('@babel/cli/bin/babel.js')");

                case 12:
                  _context4.t3 = _context4.sent;
                  _context4.t4 = resource(resolver.ensureFileFormat(resolver.decanonicalizeFileName("lively.freezer/tmp.js")));
                  _context4.t5 = resource(resolver.ensureFileFormat(resolver.decanonicalizeFileName("lively.freezer/tmp.min.js")));
                  _context4.t6 = resource(resolver.ensureFileFormat(resolver.decanonicalizeFileName("lively.freezer/.babelrc")));
                  _context4.t7 = !!resolver.isBrowserResolver;
                  _context4.next = 19;
                  return __varRecorder__$C.evalOnServer("require('lively.freezer/src/resolvers/node.cjs').decanonicalizeFileName(\"google-closure-compiler-".concat(os === "darwin" ? "osx" : "linux", "/compiler\")"));

                case 19:
                  _context4.t8 = _context4.sent;
                  return _context4.abrupt("return", {
                    os: _context4.t0,
                    cwd: _context4.t1,
                    presetPath: _context4.t2,
                    babelPath: _context4.t3,
                    tmp: _context4.t4,
                    min: _context4.t5,
                    babelConfig: _context4.t6,
                    preprocessViaBabel: _context4.t7,
                    pathToGoogleClosure: _context4.t8
                  });

                case 21:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        return function (_x4) {
          return _ref4.apply(this, arguments);
        };
      }(), __moduleMeta__$l);

      __varRecorder__$C.getConfig = getConfig;

      var compileOnServer = __varRecorder__$C["lively.freezer/src/util/helpers.js__define__"]("compileOnServer", "function", /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(code, resolver, useTerser) {
          var transpilationSpeed, compressionSpeed, _yield$__varRecorder_, cwd, tmp, min, presetPath, babelPath, babelConfig, pathToGoogleClosure, preprocessViaBabel, c, res, _iterator, _step, i, _iterator2, _step2, _i;

          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  transpilationSpeed = 100000;
                  compressionSpeed = 150000;
                  _context5.next = 4;
                  return __varRecorder__$C.getConfig(resolver);

                case 4:
                  _yield$__varRecorder_ = _context5.sent;
                  cwd = _yield$__varRecorder_.cwd;
                  tmp = _yield$__varRecorder_.tmp;
                  min = _yield$__varRecorder_.min;
                  presetPath = _yield$__varRecorder_.presetPath;
                  babelPath = _yield$__varRecorder_.babelPath;
                  babelConfig = _yield$__varRecorder_.babelConfig;
                  pathToGoogleClosure = _yield$__varRecorder_.pathToGoogleClosure;
                  preprocessViaBabel = _yield$__varRecorder_.preprocessViaBabel;

                  tmp.onProgress = function (evt) {
                    var p = evt.loaded / evt.total;
                    resolver.setStatus({
                      progress: p,
                      status: "Sending code to Google Closure: " + (100 * p).toFixed() + "%"
                    });
                  };

                  min.onProgress = function (evt) {
                    var p = evt.loaded / evt.total;
                    resolver.setStatus({
                      progress: p,
                      status: "Retrieving compiled code..." + (100 * p).toFixed() + "%"
                    });
                  };

                  _context5.next = 17;
                  return tmp.write(code);

                case 17:
                  res = {};

                  if (!(preprocessViaBabel || useTerser)) {
                    _context5.next = 60;
                    break;
                  }

                  _context5.t0 = babelConfig;
                  _context5.next = 22;
                  return __varRecorder__$C.evalOnServer("require.resolve('@babel/plugin-proposal-optional-chaining')");

                case 22:
                  _context5.t1 = _context5.sent;
                  _context5.t2 = [_context5.t1];
                  _context5.t3 = [[presetPath, {
                    modules: false
                  }]];
                  _context5.t4 = {
                    plugins: _context5.t2,
                    presets: _context5.t3
                  };
                  _context5.next = 28;
                  return _context5.t0.writeJson.call(_context5.t0, _context5.t4);

                case 28:
                  _context5.next = 30;
                  return resolver.spawn({
                    command: "".concat(babelPath, " -o tmp.es5.js tmp.js"),
                    cwd: cwd
                  });

                case 30:
                  c = _context5.sent;
                  resolver.setStatus({
                    status: "Transpiling source...",
                    progress: 0.01
                  });
                  _iterator = _createForOfIteratorHelper(range(0, code.length / transpilationSpeed));
                  _context5.prev = 33;

                  _iterator.s();

                case 35:
                  if ((_step = _iterator.n()).done) {
                    _context5.next = 44;
                    break;
                  }

                  i = _step.value;
                  _context5.next = 39;
                  return delay(400);

                case 39:
                  if (!c.status.startsWith("exited")) {
                    _context5.next = 41;
                    break;
                  }

                  return _context5.abrupt("break", 44);

                case 41:
                  resolver.setStatus({
                    status: "Transpiling source",
                    progress: (i + 1) / (code.length / transpilationSpeed)
                  });

                case 42:
                  _context5.next = 35;
                  break;

                case 44:
                  _context5.next = 49;
                  break;

                case 46:
                  _context5.prev = 46;
                  _context5.t5 = _context5["catch"](33);

                  _iterator.e(_context5.t5);

                case 49:
                  _context5.prev = 49;

                  _iterator.f();

                  return _context5.finish(49);

                case 52:
                  _context5.next = 54;
                  return waitFor(100 * 1000, function () {
                    return c.status.startsWith("exited");
                  });

                case 54:
                  _context5.next = 56;
                  return resolver.spawn({
                    command: "mv tmp.es5.js tmp.js",
                    cwd: cwd
                  });

                case 56:
                  c = _context5.sent;
                  _context5.next = 59;
                  return waitFor(100 * 1000, function () {
                    return c.status.startsWith("exited");
                  });

                case 59:
                  babelConfig.remove();

                case 60:
                  resolver.setStatus({
                    status: "Minifying source files...",
                    progress: 0.01
                  });

                  if (!useTerser) {
                    _context5.next = 67;
                    break;
                  }

                  _context5.next = 64;
                  return resolver.spawn({
                    command: "terser --compress --mangle --comments false --ecma 5 --output tmp.min.js -- tmp.js",
                    cwd: cwd
                  });

                case 64:
                  c = _context5.sent;
                  _context5.next = 70;
                  break;

                case 67:
                  _context5.next = 69;
                  return resolver.spawn({
                    command: "".concat(pathToGoogleClosure, " tmp.js > tmp.min.js --warning_level=QUIET --language_out=ECMASCRIPT_2018 --language_in=ECMASCRIPT_NEXT"),
                    cwd: cwd
                  });

                case 69:
                  c = _context5.sent;

                case 70:
                  _iterator2 = _createForOfIteratorHelper(range(0, code.length / compressionSpeed));
                  _context5.prev = 71;

                  _iterator2.s();

                case 73:
                  if ((_step2 = _iterator2.n()).done) {
                    _context5.next = 82;
                    break;
                  }

                  _i = _step2.value;
                  _context5.next = 77;
                  return delay(400);

                case 77:
                  if (!c.status.startsWith("exited")) {
                    _context5.next = 79;
                    break;
                  }

                  return _context5.abrupt("break", 82);

                case 79:
                  resolver.setStatus({
                    status: "Minifying source files ",
                    progress: (_i + 1) / (code.length / compressionSpeed)
                  });

                case 80:
                  _context5.next = 73;
                  break;

                case 82:
                  _context5.next = 87;
                  break;

                case 84:
                  _context5.prev = 84;
                  _context5.t6 = _context5["catch"](71);

                  _iterator2.e(_context5.t6);

                case 87:
                  _context5.prev = 87;

                  _iterator2.f();

                  return _context5.finish(87);

                case 90:
                  _context5.next = 92;
                  return waitFor(100 * 1000, function () {
                    return c.status.startsWith("exited");
                  });

                case 92:
                  if (!(c.stderr && c.exitCode !== 0)) {
                    _context5.next = 95;
                    break;
                  }

                  resolver.finish();
                  throw new Error(c.stderr);

                case 95:
                  resolver.setStatus({
                    status: "finished compression"
                  });
                  res.code = code;
                  _context5.next = 99;
                  return min.read();

                case 99:
                  res.min = _context5.sent;
                  _context5.next = 102;
                  return Promise.all([tmp, min].map(function (m) {
                    return m.remove();
                  }));

                case 102:
                  return _context5.abrupt("return", res);

                case 103:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, null, [[33, 46, 49, 52], [71, 84, 87, 90]]);
        }));

        return function (_x5, _x6, _x7) {
          return _ref5.apply(this, arguments);
        };
      }(), __moduleMeta__$l);

      __varRecorder__$C.compileOnServer = compileOnServer;

      var translateToEsm = __varRecorder__$C["lively.freezer/src/util/helpers.js__define__"]("translateToEsm", "function", function (jsonString) {
        var source = "";
        if (jsonString.match(/\nexport/)) return jsonString;

        for (var _i2 = 0, _Object$entries = Object.entries(JSON.parse(jsonString)); _i2 < _Object$entries.length; _i2++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
              key = _Object$entries$_i[0],
              value = _Object$entries$_i[1];

          source += "export var ".concat(key, " = ").concat(JSON.stringify(value), ";\n");
        }

        return source;
      }, __moduleMeta__$l);

      __varRecorder__$C.translateToEsm = translateToEsm;

      var instrumentStaticSystemJS = __varRecorder__$C["lively.freezer/src/util/helpers.js__define__"]("instrumentStaticSystemJS", "function", function (system) {
        var _origGet = system.get ? system.get.bind(system) : function () {};

        system.get = function (id) {
          var recorder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          return lively.FreezerRuntime && lively.FreezerRuntime.get(id, recorder) || _origGet(id);
        };

        var _origDecanonicalize = system.decanonicalize ? system.decanonicalize.bind(system) : function (id) {
          return id;
        };

        system.decanonicalize = function (id) {
          return lively.FreezerRuntime ? lively.FreezerRuntime.decanonicalize(id) : _origDecanonicalize(id);
        };

        window._missingExportShim = function () {};

        system.moduleRegisters = {};
        system.moduleSources = {};

        var _originalRegister = system.register.bind(system);

        system.register = function (name, deps, def) {
          var res;

          if (typeof name !== "string") {
            def = deps;
            deps = name;

            var _registerFn = function _registerFn(exports, module) {
              var res = def(exports, module);
              if (!res.setters) res.setters = [];
              return res;
            };

            res = _originalRegister(deps, _registerFn);
            var key = system.baseURL + system._currentFile;

            if (!system.moduleRegisters[key]) {
              system.moduleRegisters[key] = [deps, _registerFn];
            }
          } else {
            res = _originalRegister(name, deps, function (exports, module) {
              var res = def(exports, module);
              if (!res.setters) res.setters = [];
              return res;
            });

            var _key = system.baseURL + system._currentFile;

            if (!system.moduleRegisters[_key]) {
              system.moduleRegisters[_key] = [name, deps, registerFn];
            }
          }

          return res;
        };

        if (!system.config) system.config = function () {};
        if (!system.global) system.global = window;

        if (system.set && system.newModule) {
          system.set("stub-transpiler", system.newModule({
            translate: function translate(load) {
              return load.source;
            }
          }));
        }

        if (!system.newModule) system.newModule = function (exports) {
          return exports;
        };
        system.config({
          transpiler: "stub-transpiler"
        });
        system.get("@lively-env").loadedModules = lively.FreezerRuntime.registry;
        system.trace = false;
      }, __moduleMeta__$l);

      __varRecorder__$C.instrumentStaticSystemJS = instrumentStaticSystemJS;

      var generateLoadHtml = __varRecorder__$C["lively.freezer/src/util/helpers.js__define__"]("generateLoadHtml", "function", /*#__PURE__*/function () {
        var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(htmlConfig, importMap, resolver, modules, isResurrectionBuild) {
          var htmlTemplate, entryPoint, loadCode, title, head, load, crawler;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return resource(resolver.ensureFileFormat(resolver.decanonicalizeFileName("lively.freezer/src/util/load-template.html"))).read();

                case 2:
                  htmlTemplate = _context6.sent;
                  entryPoint = modules.find(function (snippet) {
                    return snippet.isEntry;
                  }).fileName;
                  loadCode = "\n    window.frozenPart = {\n      renderFrozenPart: (domNode, baseURL) => {\n        if (baseURL) System.config( { baseURL });\n        if (!baseURL) baseURL = './';\n        System.config({\n          meta: {\n           ".concat(modules.map(function (snippet) {
                    return "[baseURL + '".concat(snippet.fileName, "']: {format: \"system\", nonce: \"lively\" }");
                  }).join(",\n"), "\n          }\n        });\n        ").concat(isResurrectionBuild ? "window.BootstrapSystem = System;" : "", "\n        System.trace = ").concat(isResurrectionBuild ? "true" : "false", ";\n        System.import(\"./").concat(entryPoint, "\").then(m => { m.renderFrozenPart(domNode); });\n      }\n    }\n  ");
                  title = htmlConfig.title || "lively.next app";
                  head = htmlConfig.head || "";
                  load = htmlConfig.load || "";
                  crawler = htmlConfig.crawler || "";

                  if (importMap) {
                    head += importMap;
                  }

                  head += "<script>" + loadCode + "</script>";
                  return _context6.abrupt("return", htmlTemplate.replace("__TITLE_TAG__", title).replace("__HEAD_HTML__", head).replace("__LOADING_HTML__", load).replace("__CRAWLER_HTML__", crawler));

                case 12:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        return function (_x8, _x9, _x10, _x11, _x12) {
          return _ref6.apply(this, arguments);
        };
      }(), __moduleMeta__$l);

      __varRecorder__$C.generateLoadHtml = generateLoadHtml;

      var writeFiles = __varRecorder__$C["lively.freezer/src/util/helpers.js__define__"]("writeFiles", "function", /*#__PURE__*/function () {
        var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(frozen, li, _ref7) {
          var dir, currentFile, _iterator3, _step3, file, handle, _yield$import5, StatusMessageConfirm;

          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  dir = _ref7.dir;
                  currentFile = "";

                  dir.onProgress = function (evt) {
                    var p = evt.loaded / evt.total;
                    li.progress = p;
                    li.status = "Writing file " + currentFile + " " + (100 * p).toFixed() + "%";
                  };

                  _iterator3 = _createForOfIteratorHelper(frozen.output);
                  _context7.prev = 4;

                  _iterator3.s();

                case 6:
                  if ((_step3 = _iterator3.n()).done) {
                    _context7.next = 18;
                    break;
                  }

                  file = _step3.value;
                  handle = dir.join(file.fileName);
                  _context7.next = 11;
                  return handle.exists();

                case 11:
                  if (!_context7.sent) {
                    _context7.next = 14;
                    break;
                  }

                  _context7.next = 14;
                  return handle.remove();

                case 14:
                  _context7.next = 16;
                  return handle.ensureExistance(file.code || file.source);

                case 16:
                  _context7.next = 6;
                  break;

                case 18:
                  _context7.next = 23;
                  break;

                case 20:
                  _context7.prev = 20;
                  _context7.t0 = _context7["catch"](4);

                  _iterator3.e(_context7.t0);

                case 23:
                  _context7.prev = 23;

                  _iterator3.f();

                  return _context7.finish(23);

                case 26:
                  li.remove();
                  _context7.next = 29;
                  return module.import('./messages.cp-bdc8d7af.js');

                case 29:
                  _yield$import5 = _context7.sent;
                  StatusMessageConfirm = _yield$import5.StatusMessageConfirm;
                  $world.setStatusMessage(["Published. Click ", null, "here", {
                    textDecoration: "underline",
                    fontWeight: "bold",
                    doit: {
                      code: "window.open(\"".concat(dir.join("index.html").url, "\")")
                    }
                  }, " to view."], StatusMessageConfirm, false);

                case 32:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, null, [[4, 20, 23, 26]]);
        }));

        return function (_x13, _x14, _x15) {
          return _ref8.apply(this, arguments);
        };
      }(), __moduleMeta__$l);

      __varRecorder__$C.writeFiles = writeFiles;
      __varRecorder__$C.ROOT_ID = "__rootModule__";
      var ROOT_ID = __varRecorder__$C.ROOT_ID;
      __varRecorder__$C.ROOT_ID = ROOT_ID;
      __varRecorder__$C.isNode = typeof System !== "undefined" ? System.get("@system-env").node : typeof global !== "undefined" && typeof process !== "undefined";
      var isNode = __varRecorder__$C.isNode;
      __varRecorder__$C.isNode = isNode;
      __varRecorder__$C.findUniqJsName = findUniqJsName;
      __varRecorder__$C.gzip = gzip;
      __varRecorder__$C.brotli = brotli;
      __varRecorder__$C.transpileAttributeConnections = transpileAttributeConnections;
      __varRecorder__$C.fixSourceForBugsInGoogleClosure = fixSourceForBugsInGoogleClosure;
      __varRecorder__$C.evalOnServer = evalOnServer;
      __varRecorder__$C.getConfig = getConfig;
      __varRecorder__$C.compileOnServer = compileOnServer;
      __varRecorder__$C.translateToEsm = translateToEsm;
      __varRecorder__$C.instrumentStaticSystemJS = instrumentStaticSystemJS;
      __varRecorder__$C.generateLoadHtml = generateLoadHtml;
      __varRecorder__$C.writeFiles = writeFiles;

      var __varRecorder__$B = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.freezer/src/resolvers/browser.js", __contextModule__);

      var __moduleMeta__$k = {
        pathInPackage: function pathInPackage() {
          return "./src/resolvers/browser.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.freezer",
            version: "0.1.0"
          };
        }
      };

      var resolveModuleId = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("resolveModuleId", "function", function (moduleName, importer) {
        return module$1(moduleName).id;
      }, __moduleMeta__$k);

      __varRecorder__$B.resolveModuleId = resolveModuleId;

      var ensureFileFormat = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("ensureFileFormat", "function", function (url) {
        return url;
      }, __moduleMeta__$k);

      __varRecorder__$B.ensureFileFormat = ensureFileFormat;

      var normalizeFileName = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("normalizeFileName", "function", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(fileName) {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return System.normalize(fileName);

                case 2:
                  return _context.abrupt("return", _context.sent);

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }(), __moduleMeta__$k);

      __varRecorder__$B.normalizeFileName = normalizeFileName;

      var decanonicalizeFileName = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("decanonicalizeFileName", "function", function (fileName) {
        return System.decanonicalize(fileName);
      }, __moduleMeta__$k);

      __varRecorder__$B.decanonicalizeFileName = decanonicalizeFileName;

      var resolvePackage = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("resolvePackage", "function", function (moduleName) {
        return module$1(moduleName)["package"]();
      }, __moduleMeta__$k);

      __varRecorder__$B.resolvePackage = resolvePackage;

      var dontTransform = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("dontTransform", "function", function (moduleId) {
        return module$1(moduleId).dontTransform;
      }, __moduleMeta__$k);

      __varRecorder__$B.dontTransform = dontTransform;

      var pathInPackageFor = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("pathInPackageFor", "function", function (moduleId) {
        return module$1(moduleId).pathInPackage();
      }, __moduleMeta__$k);

      __varRecorder__$B.pathInPackageFor = pathInPackageFor;

      var detectFormatFromSource = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("detectFormatFromSource", "function", function (source) {
        return detectModuleFormat(source);
      }, __moduleMeta__$k);

      __varRecorder__$B.detectFormatFromSource = detectFormatFromSource;

      var detectFormat = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("detectFormat", "function", function (moduleId) {
        return module$1(moduleId).format();
      }, __moduleMeta__$k);

      __varRecorder__$B.detectFormat = detectFormat;

      var setStatus = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("setStatus", "function", function (_ref2) {
        var status = _ref2.status,
            progress = _ref2.progress,
            label = _ref2.label;
        if (!__varRecorder__$B.li) __varRecorder__$B.li = open$1();
        if (!__varRecorder__$B.li.world()) __varRecorder__$B.li.openInWorld();
        if (status) __varRecorder__$B.li.status = status;
        if (label) __varRecorder__$B.li.label = label;
        if (typeof progress !== "undefined") __varRecorder__$B.li.progress = progress;
      }, __moduleMeta__$k);

      __varRecorder__$B.setStatus = setStatus;

      var finish = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("finish", "function", function () {
        __varRecorder__$B.li.remove();

        __varRecorder__$B.li = null;
      }, __moduleMeta__$k);

      __varRecorder__$B.finish = finish;

      var whenReady = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("whenReady", "function", function () {
        return __varRecorder__$B.li.whenEnvReady();
      }, __moduleMeta__$k);

      __varRecorder__$B.whenReady = whenReady;

      var spawn = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("spawn", "function", function (_ref3) {
        var command = _ref3.command,
            cwd = _ref3.cwd;
        return runCommand(command, {
          cwd: cwd
        });
      }, __moduleMeta__$k);

      __varRecorder__$B.spawn = spawn;

      var fetchFile = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("fetchFile", "function", /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url) {
          var attempts, maxAttempts;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:

                  attempts = 0;
                  maxAttempts = 3;
                  _context2.prev = 3;
                  _context2.prev = 4;
                  _context2.next = 7;
                  return resource(url).read();

                case 7:
                  return _context2.abrupt("return", _context2.sent);

                case 10:
                  _context2.prev = 10;
                  _context2.t0 = _context2["catch"](4);
                  _context2.next = 14;
                  return resource(url).makeProxied().read();

                case 14:
                  return _context2.abrupt("return", _context2.sent);

                case 15:
                  _context2.next = 23;
                  break;

                case 17:
                  _context2.prev = 17;
                  _context2.t1 = _context2["catch"](3);
                  attempts++;

                  if (!(attempts < maxAttempts)) {
                    _context2.next = 22;
                    break;
                  }

                  return _context2.abrupt("continue", 0);

                case 22:
                  throw _context2.t1;

                case 23:
                  _context2.next = 0;
                  break;

                case 25:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[3, 17], [4, 10]]);
        }));

        return function (_x2) {
          return _ref4.apply(this, arguments);
        };
      }(), __moduleMeta__$k);

      __varRecorder__$B.fetchFile = fetchFile;

      var load = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("load", "function", /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(url) {
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (!(url === "@empty.js")) {
                    _context3.next = 2;
                    break;
                  }

                  return _context3.abrupt("return", "");

                case 2:
                  _context3.next = 4;
                  return __varRecorder__$B.fetchFile(url);

                case 4:
                  return _context3.abrupt("return", _context3.sent);

                case 5:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function (_x3) {
          return _ref5.apply(this, arguments);
        };
      }(), __moduleMeta__$k);

      __varRecorder__$B.load = load;

      var supportingPlugins = __varRecorder__$B["lively.freezer/src/resolvers/browser.js__define__"]("supportingPlugins", "function", function (self) {
        return [self, _missingExportShim({
          sourceMap: false,
          defaultIsModuleExports: true,
          transformMixedEsModules: true,
          dynamicRequireRoot: System.baseURL
        }), _missingExportShim()];
      }, __moduleMeta__$k);

      __varRecorder__$B.supportingPlugins = supportingPlugins;
      __varRecorder__$B.resolvePackage = resolvePackage;
      __varRecorder__$B.li = __varRecorder__$B.li || undefined;
      __varRecorder__$B.builtinModules = [];
      __varRecorder__$B.BrowserResolver = {
        availableFonts: availableFonts,
        resolveModuleId: __varRecorder__$B.resolveModuleId,
        isBrowserResolver: true,
        normalizeFileName: __varRecorder__$B.normalizeFileName,
        decanonicalizeFileName: __varRecorder__$B.decanonicalizeFileName,
        resolvePackage: __varRecorder__$B.resolvePackage,
        dontTransform: __varRecorder__$B.dontTransform,
        pathInPackageFor: __varRecorder__$B.pathInPackageFor,
        detectFormat: __varRecorder__$B.detectFormat,
        detectFormatFromSource: __varRecorder__$B.detectFormatFromSource,
        setStatus: __varRecorder__$B.setStatus,
        finish: __varRecorder__$B.finish,
        whenReady: __varRecorder__$B.whenReady,
        spawn: __varRecorder__$B.spawn,
        load: __varRecorder__$B.load,
        fetchFile: __varRecorder__$B.fetchFile,
        builtinModules: __varRecorder__$B.builtinModules,
        ensureFileFormat: __varRecorder__$B.ensureFileFormat,
        supportingPlugins: __varRecorder__$B.supportingPlugins
      };
      var BrowserResolver = __varRecorder__$B.BrowserResolver;
      __varRecorder__$B["default"] = BrowserResolver;

      var __varRecorder__$A = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.freezer/src/bundler.js", __contextModule__);
      var __moduleMeta__$j = {
        pathInPackage: function pathInPackage() {
          return "./src/bundler.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.freezer",
            version: "0.1.0"
          };
        }
      };

      var customWarn = __varRecorder__$A["lively.freezer/src/bundler.js__define__"]("customWarn", "function", function (warning, warn, bundler) {
        if (warning.code === "UNRESOLVED_IMPORT") {
          pushIfNotIncluded(bundler.excludedModules, warning.source);
        }

        if (!bundler.verbose) return;

        switch (warning.code) {
          case "THIS_IS_UNDEFINED":
          case "EVAL":
          case "MODULE_LEVEL_DIRECTIVE":
            return;

          case "CIRCULAR_DEPENDENCY":
            bundler.resolver.setStatus({
              status: warning.message
            });
            return;

          case "SOURCEMAP_ERROR":
            return;

          case "SHIMMED_EXPORT":
            if (warning.exporter === "@empty") return;
            if (warning.exporter.startsWith("\0")) return;
            bundler.resolver.setStatus({
              status: warning.message
            });
            return;
        }

        warn(warning);
      }, __moduleMeta__$j);

      __varRecorder__$A.customWarn = customWarn;

      var resolutionId = __varRecorder__$A["lively.freezer/src/bundler.js__define__"]("resolutionId", "function", function (id, importer) {
        if (!importer) return id;else return importer + " -> " + id;
      }, __moduleMeta__$j);

      __varRecorder__$A.resolutionId = resolutionId;

      var isCdnImport = __varRecorder__$A["lively.freezer/src/bundler.js__define__"]("isCdnImport", "function", function (id, importer, resolver) {
        if (__varRecorder__$A.ESM_CDNS.find(function (cdn) {
          return id.match(cdn) || importer.match(cdn);
        }) && importer && importer !== ROOT_ID) {
          var _resource$root = resource(resolver.ensureFileFormat(importer)).root(),
              url = _resource$root.url;

          return __varRecorder__$A.ESM_CDNS.find(function (cdn) {
            return url.match(cdn);
          });
        }

        return false;
      }, __moduleMeta__$j);

      __varRecorder__$A.isCdnImport = isCdnImport;
      __varRecorder__$A.separator = "__".concat("Separator", "__");
      __varRecorder__$A.GLOBAL_FETCH = "var G = typeof window !== \"undefined\" ? window :\n      typeof global!==\"undefined\" ? global :\n        typeof self!==\"undefined\" ? self : this;";
      __varRecorder__$A.SYSTEMJS_STUB = "\n".concat(__varRecorder__$A.GLOBAL_FETCH, "\nif (!G.System) G.System = G.lively.FreezerRuntime;");
      __varRecorder__$A.CLASS_INSTRUMENTATION_MODULES = ["lively.morphic", "lively.components", "lively.ide", "lively.halos", "lively.bindings", "lively-system-interface", "typeshift.components", "lively.collab", "https://jspm.dev/npm:rollup@2.28.2"];
      __varRecorder__$A.ESM_CDNS = ["jspm.dev", "jspm.io", "skypack.dev", "esm://cache", "esm://run", /esm:\/\/([^\/]*)\//];
      __varRecorder__$A.CLASS_INSTRUMENTATION_MODULES_EXCLUSION = ["lively.lang"];
      __varRecorder__$A.ALWAYS_EXCLUDED_MODULES = ["mermaid-it-markdown"];
      __varRecorder__$A.ADVANCED_EXCLUDED_MODULES = ["lively.ast", "lively.vm", "lively.ide", "lively.modules", "babel-plugin-transform-jsx", "lively-system-interface", "lively.storage", "lively.collab", "localconfig.js"];
      __varRecorder__$A.baseURL = typeof System !== "undefined" ? System.baseURL : ensureFolder(process.env.lv_next_dir || process.cwd());
      __varRecorder__$A.customWarn = customWarn;

      var LivelyRollup = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.freezer/src/bundler.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("LivelyRollup") && typeof __lively_classholder__.LivelyRollup === "function" ? __lively_classholder__.LivelyRollup : __lively_classholder__.LivelyRollup = function LivelyRollup(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function LivelyRollup_initialize_() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            this.setup(props);
          }
        }, {
          key: "setup",
          value: function LivelyRollup_setup_(_ref) {
            var _this$excludedModules;

            _ref.snapshot;
                var rootModule = _ref.rootModule,
                resolver = _ref.resolver,
                _ref$excludedModules = _ref.excludedModules,
                excludedModules = _ref$excludedModules === void 0 ? [] : _ref$excludedModules,
                _ref$autoRun = _ref.autoRun,
                autoRun = _ref$autoRun === void 0 ? false : _ref$autoRun,
                _ref$asBrowserModule = _ref.asBrowserModule,
                asBrowserModule = _ref$asBrowserModule === void 0 ? true : _ref$asBrowserModule,
                _ref$useTerser = _ref.useTerser,
                useTerser = _ref$useTerser === void 0 ? false : _ref$useTerser,
                _ref$isResurrectionBu = _ref.isResurrectionBuild,
                isResurrectionBuild = _ref$isResurrectionBu === void 0 ? false : _ref$isResurrectionBu,
                _ref$includePolyfills = _ref.includePolyfills,
                includePolyfills = _ref$includePolyfills === void 0 ? true : _ref$includePolyfills,
                _ref$includeLivelyAss = _ref.includeLivelyAssets,
                includeLivelyAssets = _ref$includeLivelyAss === void 0 ? true : _ref$includeLivelyAss,
                _ref$compress = _ref.compress,
                compress = _ref$compress === void 0 ? true : _ref$compress,
                _ref$minify = _ref.minify,
                minify = _ref$minify === void 0 ? true : _ref$minify,
                _ref$captureModuleSco = _ref.captureModuleScope,
                captureModuleScope = _ref$captureModuleSco === void 0 ? true : _ref$captureModuleSco,
                _ref$verbose = _ref.verbose,
                verbose = _ref$verbose === void 0 ? false : _ref$verbose;
            this.verbose = verbose;
            this.resolver = resolver;
            this.useTerser = useTerser;
            this.includePolyfills = includePolyfills;
            this.snapshot = null;

            if (rootModule) {
              this.rootModuleId = resolver.resolveModuleId(rootModule);
            }

            this.autoRun = autoRun;
            this.asBrowserModule = asBrowserModule;
            this.excludedModules = excludedModules;

            (_this$excludedModules = this.excludedModules).push.apply(_this$excludedModules, _toConsumableArray$1(__varRecorder__$A.ALWAYS_EXCLUDED_MODULES));

            this.captureModuleScope = captureModuleScope;
            this.isResurrectionBuild = isResurrectionBuild;
            this.includeLivelyAssets = includeLivelyAssets;
            this.compress = compress;
            this.minify = minify;
            this.globalMap = {};
            this.modulesWithDynamicLoads = new Set();
            this.hasDynamicImports = false;
            this.globalModules = {};
            this.resolved = {};
            this.projectAssets = [];
            this.customFontFiles = [];
            this.projectsInBundle = new Set();
            this.moduleToPkg = new Map();
            this.resolver.setStatus({
              label: "Freezing in Progress"
            });
          }
        }, {
          key: "needsOldSystem",
          get: function get() {
            return this.isResurrectionBuild || !this.excludedModules.includes("lively.modules");
          }
        }, {
          key: "getResolutionContext",
          value: function LivelyRollup_getResolutionContext_() {
            if (!this.asBrowserModule) {
              return "systemjs-node";
            } else {
              return "systemjs-browser";
            }
          }
        }, {
          key: "resolveRelativeImport",
          value: function () {
            var _LivelyRollup_resolveRelativeImport_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(moduleId, path) {
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (path.startsWith(".")) {
                        _context.next = 2;
                        break;
                      }

                      return _context.abrupt("return", this.resolver.normalizeFileName(path));

                    case 2:
                      _context.t0 = this.resolver;
                      _context.t1 = string;
                      _context.next = 6;
                      return this.resolver.normalizeFileName(moduleId);

                    case 6:
                      _context.t2 = _context.sent;
                      _context.t3 = path;
                      _context.t4 = _context.t1.joinPath.call(_context.t1, _context.t2, "..", _context.t3);
                      _context.next = 11;
                      return _context.t0.normalizeFileName.call(_context.t0, _context.t4);

                    case 11:
                      return _context.abrupt("return", _context.sent);

                    case 12:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function LivelyRollup_resolveRelativeImport_(_x, _x2) {
              return _LivelyRollup_resolveRelativeImport_.apply(this, arguments);
            }

            return LivelyRollup_resolveRelativeImport_;
          }()
        }, {
          key: "normalizedId",
          value: function LivelyRollup_normalizedId_(id) {
            return id.replace(__varRecorder__$A.baseURL, "").replace("local://lively-object-modules/", "").replace("local_projects/", "").replace("https://jspm.dev/", "esm://cache/");
          }
        }, {
          key: "getTransformOptions",
          value: function LivelyRollup_getTransformOptions_(modId, parsedSource) {
            if (modId === "@empty.js") return {};
            var version, name;
            var pkg = this.resolver.resolvePackage(modId);

            if (pkg) {
              name = pkg.name;
              version = pkg.version;
            } else {
              version = modId.split("@")[1];
              name = modId.split("npm:")[1].split("@")[0];
            }

            var classToFunction = {
              classHolder: parse$2("((lively.FreezerRuntime || lively.frozenModules).recorderFor(\"".concat(this.normalizedId(modId), "\", __contextModule__))")),
              functionNode: {
                type: "Identifier",
                name: "initializeES6ClassForLively"
              },
              transform: classToFunctionTransform,
              currentModuleAccessor: parse$2("({\n        pathInPackage: () => {\n           return \"".concat(this.resolver.pathInPackageFor(modId), "\"\n        },\n        unsubscribeFromToplevelDefinitionChanges: () => () => {},\n        subscribeToToplevelDefinitionChanges: () => () => {},\n        package: () => { \n          return {\n            name: \"").concat(name, "\",\n            version: \"").concat(version, "\"\n          } \n        } \n      })")).body[0].expression
            };
            return {
              captureImports: false,
              exclude: ["System", "__contextModule__"].concat(_toConsumableArray$1(this.resolver.dontTransform(modId, [].concat(_toConsumableArray$1(knownGlobals), _toConsumableArray$1(GlobalInjector.getGlobals(null, parsedSource))))), _toConsumableArray$1(range(0, 50).map(function (i) {
                return "__captured".concat(i, "__");
              }))),
              classToFunction: classToFunction
            };
          }
        }, {
          key: "getRootModule",
          value: function () {
            var _LivelyRollup_getRootModule_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      if (!this.rootModuleId) {
                        _context2.next = 6;
                        break;
                      }

                      if (this.autoRun) {
                        _context2.next = 3;
                        break;
                      }

                      return _context2.abrupt("return", "export * from \"".concat(this.rootModuleId, "\";"));

                    case 3:
                      _context2.next = 5;
                      return this.synthesizeMainModule();

                    case 5:
                      return _context2.abrupt("return", _context2.sent);

                    case 6:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function LivelyRollup_getRootModule_() {
              return _LivelyRollup_getRootModule_.apply(this, arguments);
            }

            return LivelyRollup_getRootModule_;
          }()
        }, {
          key: "synthesizeMainModule",
          value: function () {
            var _LivelyRollup_synthesizeMainModule_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
              var mainModuleSource;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.t0 = resource;
                      _context3.t1 = this.resolver;
                      _context3.next = 4;
                      return this.resolver.normalizeFileName("lively.freezer/src/util/main-module.js");

                    case 4:
                      _context3.t2 = _context3.sent;
                      _context3.t3 = _context3.t1.ensureFileFormat.call(_context3.t1, _context3.t2);
                      _context3.next = 8;
                      return (0, _context3.t0)(_context3.t3).read();

                    case 8:
                      mainModuleSource = _context3.sent;
                      mainModuleSource = mainModuleSource.replaceAll("TRACE", this.isResurrectionBuild ? "true" : "false");
                      return _context3.abrupt("return", mainModuleSource.replace("prepare()", "const { main, WORLD_CLASS = World, TITLE } = await System.import('".concat(this.rootModuleId, "')")));

                    case 11:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function LivelyRollup_synthesizeMainModule_() {
              return _LivelyRollup_synthesizeMainModule_.apply(this, arguments);
            }

            return LivelyRollup_synthesizeMainModule_;
          }()
        }, {
          key: "needsScopeToBeCaptured",
          value: function LivelyRollup_needsScopeToBeCaptured_(moduleId, importModuleId) {
            var sourceCode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            if (sourceCode && this.resolver.detectFormatFromSource(sourceCode) === "global") return false;
            if (this.isResurrectionBuild && this.wasFetchedFromEsmCdn(moduleId)) return true;

            if (importModuleId && resource(moduleId).host() !== resource(importModuleId).host()) {
              return false;
            }

            return !this.wasFetchedFromEsmCdn(moduleId);
          }
        }, {
          key: "wasFetchedFromEsmCdn",
          value: function LivelyRollup_wasFetchedFromEsmCdn_(moduleId) {
            return !!__varRecorder__$A.ESM_CDNS.find(function (url) {
              return moduleId.match(url);
            });
          }
        }, {
          key: "needsClassInstrumentation",
          value: function LivelyRollup_needsClassInstrumentation_(moduleId, moduleSource) {
            if (__varRecorder__$A.CLASS_INSTRUMENTATION_MODULES_EXCLUSION.some(function (pkgName) {
              return moduleId.includes(pkgName);
            })) {
              return false;
            }

            if (__varRecorder__$A.CLASS_INSTRUMENTATION_MODULES.some(function (pkgName) {
              return moduleId.includes(pkgName) || pkgName === moduleId;
            })) {
              return true;
            }

            if (this.isResurrectionBuild) return true;
            if (this.wasFetchedFromEsmCdn(moduleId)) return false;
            if (this.isComponentModule(moduleId)) return true;
            if (moduleSource && moduleSource.match(/extends\ (Morph|Image|Ellipse|HTMLMorph|Path|Polygon|Text|InteractiveMorph|ViewModel)/)) return true;
            return false;
          }
        }, {
          key: "isComponentModule",
          value: function LivelyRollup_isComponentModule_(moduleId) {
            return moduleId.endsWith(".cp.js");
          }
        }, {
          key: "isLivelyCoreModule",
          value: function LivelyRollup_isLivelyCoreModule_(moduleId) {
            return moduleId.includes("lively.");
          }
        }, {
          key: "needsDynamicLoadTransform",
          value: function LivelyRollup_needsDynamicLoadTransform_(sourceCode) {
            return sourceCode.includes("System.import");
          }
        }, {
          key: "instrumentDynamicLoads",
          value: function LivelyRollup_instrumentDynamicLoads_(parsed, moduleId) {
            var _this = this;

            return ReplaceVisitor.run(parsed, function (node) {
              if (node.type === "CallExpression" && node.callee.type === "MemberExpression") {
                if (node.callee.property.name === "import" && node.callee.object.name === "System" && node.arguments.length === 1) {
                  try {
                    var resolvedImport = eval(stringify(node.arguments[0]));
                    if (resolvedImport) _this.hasDynamicImports = true;
                    return parse$2("import(\"".concat(resolvedImport, "\")")).body[0].expression;
                  } catch (err) {
                    return node;
                  }
                }
              }

              return node;
            });
          }
        }, {
          key: "transform",
          value: function () {
            var _LivelyRollup_transform_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(source, id) {
              var _this2 = this;

              var _id$match, projectAssetRegex, currentlyTransformedProject, assetNameRewriter, parsed, instrumentClasses, sourceHash;

              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:

                      if (!(id.startsWith("\0") || id.endsWith(".json") || this.excludedModules.find(function (m) {
                        return id.startsWith(m);
                      }))) {
                        _context4.next = 3;
                        break;
                      }

                      return _context4.abrupt("return", source);

                    case 3:
                      if (!id.includes("lively.ide/components/helpers.js")) {
                        projectAssetRegex = /*#__PURE__*/_wrapRegExp(/projectAsset\('(.*)'\)/g, {
                          assetName: 1
                        });
                        currentlyTransformedProject = (_id$match = id.match(/local_projects\/([^\/]*)\//)) === null || _id$match === void 0 ? void 0 : _id$match[1];
                        if (currentlyTransformedProject) this.projectsInBundle.add(currentlyTransformedProject);

                        assetNameRewriter = function assetNameRewriter(match, assetName) {
                          var newName = currentlyTransformedProject + "__" + assetName;

                          _this2.projectAssets.push({
                            oldName: assetName,
                            newName: newName,
                            project: currentlyTransformedProject
                          });

                          return "projectAsset('".concat(newName, "')");
                        };

                        source = source.replaceAll(projectAssetRegex, assetNameRewriter);
                      }

                      parsed = parse$2(source);

                      if (this.needsDynamicLoadTransform(source)) {
                        parsed = this.instrumentDynamicLoads(parsed, id);
                      }

                      if (!(id === ROOT_ID)) {
                        _context4.next = 8;
                        break;
                      }

                      return _context4.abrupt("return", stringify(parsed));

                    case 8:
                      instrumentClasses = this.needsClassInstrumentation(id, source);

                      if (!(this.needsScopeToBeCaptured(id, null, source) || instrumentClasses)) {
                        _context4.next = 18;
                        break;
                      }

                      _context4.t0 = string;
                      _context4.next = 13;
                      return this.resolver.load(id);

                    case 13:
                      _context4.t1 = _context4.sent;
                      sourceHash = _context4.t0.hashCode.call(_context4.t0, _context4.t1);
                      _context4.next = 17;
                      return this.captureScope(parsed, id, sourceHash, instrumentClasses);

                    case 17:
                      parsed = _context4.sent;

                    case 18:
                      return _context4.abrupt("return", stringify(parsed));

                    case 19:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function LivelyRollup_transform_(_x3, _x4) {
              return _LivelyRollup_transform_.apply(this, arguments);
            }

            return LivelyRollup_transform_;
          }()
        }, {
          key: "resolveId",
          value: function () {
            var _LivelyRollup_resolveId_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(id, importer) {
              var importingPackage, _ref2, mapping, importMap, _importMap$imports, remapped, scope, _remapped, ctx, absolutePath;

              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      if (!this.resolved[__varRecorder__$A.resolutionId(id, importer)]) {
                        _context5.next = 2;
                        break;
                      }

                      return _context5.abrupt("return", this.resolved[__varRecorder__$A.resolutionId(id, importer)]);

                    case 2:
                      if (!(id === ROOT_ID)) {
                        _context5.next = 4;
                        break;
                      }

                      return _context5.abrupt("return", id);

                    case 4:
                      if (importer) {
                        _context5.next = 6;
                        break;
                      }

                      return _context5.abrupt("return", this.resolver.resolveModuleId(id, importer, this.getResolutionContext()));

                    case 6:
                      if (__varRecorder__$A.isCdnImport(id, importer, this.resolver)) {
                        if (id.startsWith(".")) {
                          id = resource(importer).parent().join(id).withRelativePartsResolved().url;
                        } else if (id.startsWith("/")) {
                          id = resource(importer).root().join(id).withRelativePartsResolved().url;
                        }
                      }

                      importingPackage = this.resolver.resolvePackage(importer) || this.moduleToPkg.get(importer);
                      _ref2 = (importingPackage === null || importingPackage === void 0 ? void 0 : importingPackage.systemjs) || {}, mapping = _ref2.map, importMap = _ref2.importMap;

                      if (importMap) {
                        if (remapped = (_importMap$imports = importMap.imports) === null || _importMap$imports === void 0 ? void 0 : _importMap$imports[id]) {
                          id = remapped;
                        }

                        if (scope = Object.entries(importMap.scopes).filter(function (_ref3) {
                          var _ref4 = _slicedToArray(_ref3, 2),
                              k = _ref4[0];
                              _ref4[1];

                          return importer.startsWith(k);
                        }).sort(function (a, b) {
                          return a[0].length - b[0].length;
                        }).map(function (_ref5) {
                          var _ref6 = _slicedToArray(_ref5, 2);
                              _ref6[0];
                              var scope = _ref6[1];

                          return scope;
                        }).reduce(function (a, b) {
                          return Object.assign({}, a, {}, b);
                        }, false)) {
                          remapped = scope[id];
                        }

                        if (remapped) {
                          id = remapped;
                        }
                      }

                      this.moduleToPkg.set(id, importingPackage);

                      if (!mapping) {
                        _context5.next = 21;
                        break;
                      }

                      this.globalMap = Object.assign({}, this.globalMap, {}, mapping);

                      if (!(mapping[id] || this.globalMap[id])) {
                        _context5.next = 21;
                        break;
                      }

                      if (!mapping[id] && this.globalMap[id]) {
                        console.warn("[freezer] No mapping for \"".concat(id, "\" provided by package \"").concat(importingPackage.name, "\". Guessing \"").concat(this.globalMap[id], "\" based on past resolutions. Please consider adding a map entry to this package config in oder to make the package definition sound and work independently of the current setup!"));
                      }

                      if (!this.excludedModules.includes(id)) {
                        _context5.next = 17;
                        break;
                      }

                      return _context5.abrupt("return", id);

                    case 17:
                      _remapped = mapping[id] || this.globalMap[id];
                      ctx = this.asBrowserModule ? "~node" : "node";
                      if (_remapped[ctx]) _remapped = _remapped[ctx];
                      if (typeof _remapped === "string") id = _remapped;

                    case 21:
                      if (!id.startsWith(".")) {
                        _context5.next = 34;
                        break;
                      }

                      _context5.prev = 22;
                      _context5.next = 25;
                      return this.resolveRelativeImport(importer, id);

                    case 25:
                      absolutePath = _context5.sent;

                      if (!this.belongsToExcludedPackage(absolutePath)) {
                        _context5.next = 28;
                        break;
                      }

                      return _context5.abrupt("return", null);

                    case 28:
                      return _context5.abrupt("return", this.resolved[__varRecorder__$A.resolutionId(id, importer)] = absolutePath);

                    case 31:
                      _context5.prev = 31;
                      _context5.t0 = _context5["catch"](22);
                      return _context5.abrupt("return", null);

                    case 34:
                      absolutePath = this.resolver.resolveModuleId(id, importer, this.getResolutionContext());

                      if (!this.belongsToExcludedPackage(absolutePath)) {
                        _context5.next = 37;
                        break;
                      }

                      return _context5.abrupt("return", id);

                    case 37:
                      return _context5.abrupt("return", this.resolved[__varRecorder__$A.resolutionId(id, importer)] = absolutePath);

                    case 38:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this, [[22, 31]]);
            }));

            function LivelyRollup_resolveId_(_x5, _x6) {
              return _LivelyRollup_resolveId_.apply(this, arguments);
            }

            return LivelyRollup_resolveId_;
          }()
        }, {
          key: "belongsToExcludedPackage",
          value: function LivelyRollup_belongsToExcludedPackage_(id) {
            if (id === null) return true;
            var pkg = this.resolver.resolvePackage(id);

            if (pkg && this.excludedModules.includes(pkg.name)) {
              return true;
            }

            return false;
          }
        }, {
          key: "resolveDynamicImport",
          value: function LivelyRollup_resolveDynamicImport_(node, importer) {
            if (node.type && this.isLivelyCoreModule(importer)) return null;
            var id = node;
            var res = this.resolveId(id, importer);

            if (res && isString$3(res)) {
              return {
                external: false,
                id: res
              };
            }

            return res;
          }
        }, {
          key: "load",
          value: function () {
            var _LivelyRollup_load_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(id) {
              var res, pkg, s;
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      if (!this.excludedModules.find(function (m) {
                        return id.startsWith(m);
                      })) {
                        _context6.next = 6;
                        break;
                      }

                      if (!(id === "lively.ast")) {
                        _context6.next = 3;
                        break;
                      }

                      return _context6.abrupt("return", "\n        let nodes = {}, query = {}, transform = {}, BaseVisitor = Object;\n        export { nodes, query, transform, BaseVisitor };");

                    case 3:
                      if (!(id === "lively.modules")) {
                        _context6.next = 5;
                        break;
                      }

                      return _context6.abrupt("return", "\n        let scripting = {};\n        export { scripting };");

                    case 5:
                      return _context6.abrupt("return", "");

                    case 6:
                      if (!(id === ROOT_ID)) {
                        _context6.next = 11;
                        break;
                      }

                      _context6.next = 9;
                      return this.getRootModule();

                    case 9:
                      res = _context6.sent;
                      return _context6.abrupt("return", res);

                    case 11:
                      pkg = this.resolver.resolvePackage(id);

                      if (!(pkg && this.excludedModules.includes(pkg.name) && !id.endsWith(".json"))) {
                        _context6.next = 14;
                        break;
                      }

                      return _context6.abrupt("return", "");

                    case 14:
                      _context6.next = 16;
                      return this.resolver.load(id);

                    case 16:
                      s = _context6.sent;

                      if (!id.endsWith(".json")) {
                        _context6.next = 19;
                        break;
                      }

                      return _context6.abrupt("return", s);

                    case 19:
                      s = fixSourceForBugsInGoogleClosure(id, s);
                      return _context6.abrupt("return", s);

                    case 21:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function LivelyRollup_load_(_x7) {
              return _LivelyRollup_load_.apply(this, arguments);
            }

            return LivelyRollup_load_;
          }()
        }, {
          key: "buildStart",
          value: function () {
            var _LivelyRollup_buildStart_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(plugin) {
              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      this.resolver.setStatus({
                        status: "Bundling..."
                      });
                      _context7.next = 3;
                      return this.resolver.whenReady();

                    case 3:
                      if (this.autoRun) {
                        plugin.emitFile({
                          type: "chunk",
                          id: ROOT_ID
                        });
                      }

                    case 4:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7, this);
            }));

            function LivelyRollup_buildStart_(_x8) {
              return _LivelyRollup_buildStart_.apply(this, arguments);
            }

            return LivelyRollup_buildStart_;
          }()
        }, {
          key: "captureScope",
          value: function () {
            var _LivelyRollup_captureScope_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(parsed, id, hashCode, instrumentClasses) {
              var classRuntimeImport, recorderName, declsAndRefs, exports, _iterator, _step, exp, localLivelyVar, recorderString, moduleHash, moduleExports, captureObj, tfm, opts, currentModuleAccessor, instrumented, normalizedId, defaultExport, imports, toBeReplaced, _i, _Object$values, stmts, toBeMerged, mergedSpecifiers;

              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      classRuntimeImport = "";
                      recorderName = "__varRecorder__";
                      declsAndRefs = topLevelDeclsAndRefs(parsed);
                      exports = [];
                      _iterator = _createForOfIteratorHelper(exports$$(declsAndRefs.scope));
                      _context8.prev = 5;

                      _iterator.s();

                    case 7:
                      if ((_step = _iterator.n()).done) {
                        _context8.next = 28;
                        break;
                      }

                      exp = _step.value;

                      if (!(exp.local && exp.exported !== "default" && exp.exported !== exp.local)) {
                        _context8.next = 12;
                        break;
                      }

                      exports.push(JSON.stringify("__rename__" + exp.local + "->" + exp.exported));
                      return _context8.abrupt("continue", 26);

                    case 12:
                      if (!(exp.exported === "*")) {
                        _context8.next = 24;
                        break;
                      }

                      _context8.t0 = exports;
                      _context8.t1 = JSON;
                      _context8.t2 = this;
                      _context8.next = 18;
                      return this.resolveId(exp.fromModule, id);

                    case 18:
                      _context8.t3 = _context8.sent;
                      _context8.t4 = _context8.t2.normalizedId.call(_context8.t2, _context8.t3);
                      _context8.t5 = "__reexport__" + _context8.t4;
                      _context8.t6 = _context8.t1.stringify.call(_context8.t1, _context8.t5);

                      _context8.t0.push.call(_context8.t0, _context8.t6);

                      return _context8.abrupt("continue", 26);

                    case 24:
                      if (exp.exported === "default") {
                        exports.push(JSON.stringify("__default__" + exp.local));
                      }

                      exports.push(JSON.stringify(exp.exported));

                    case 26:
                      _context8.next = 7;
                      break;

                    case 28:
                      _context8.next = 33;
                      break;

                    case 30:
                      _context8.prev = 30;
                      _context8.t7 = _context8["catch"](5);

                      _iterator.e(_context8.t7);

                    case 33:
                      _context8.prev = 33;

                      _iterator.f();

                      return _context8.finish(33);

                    case 36:
                      localLivelyVar = declsAndRefs.declaredNames.includes("lively");
                      recorderString = this.captureModuleScope ? "".concat(localLivelyVar ? __varRecorder__$A.GLOBAL_FETCH : "", " const ").concat(recorderName, " = (").concat(localLivelyVar ? "G." : "", "lively.FreezerRuntime || ").concat(localLivelyVar ? "G." : "", "lively.frozenModules).recorderFor(\"").concat(this.normalizedId(id), "\", __contextModule__);\n") : "";
                      moduleHash = "".concat(recorderName, ".__module_hash__ = ").concat(hashCode, ";\n");
                      moduleExports = "".concat(recorderName, ".__module_exports__ = ").concat(recorderName, ".__module_exports__ || [").concat(exports.join(","), "];\n");
                      captureObj = {
                        name: recorderName,
                        type: "Identifier"
                      };
                      tfm = compose(rewriteToCaptureTopLevelVariables, objectSpreadTransform);
                      opts = this.getTransformOptions(this.resolver.resolveModuleId(id), parsed);
                      currentModuleAccessor = opts.classToFunction.currentModuleAccessor;

                      if (instrumentClasses) {
                        classRuntimeImport = "import { initializeClass as initializeES6ClassForLively } from \"".concat(this.isResurrectionBuild ? "livelyClassesRuntime.js" : "lively.classes/runtime.js", "\";\n");
                      } else {
                        opts.classToFunction = false;
                      }

                      instrumented = parsed;
                      normalizedId = this.normalizedId(id);

                      if (this.isComponentModule(id)) {
                        instrumented = ensureComponentDescriptors(parsed, normalizedId, recorderName);
                      }

                      defaultExport = "";

                      if (!this.captureModuleScope) {
                        _context8.next = 65;
                        break;
                      }

                      instrumented = replaceExportedVarDeclarations(parsed, recorderName, normalizedId);

                      if (!this.isResurrectionBuild) {
                        _context8.next = 58;
                        break;
                      }

                      _context8.next = 54;
                      return replaceImportedNamespaces(instrumented, id, this);

                    case 54:
                      instrumented = _context8.sent;
                      _context8.next = 57;
                      return replaceExportedNamespaces(instrumented, id, this);

                    case 57:
                      instrumented = _context8.sent;

                    case 58:
                      instrumented = tfm(instrumented, captureObj, opts);
                      instrumented = insertCapturesForExportedImports(instrumented, {
                        captureObj: captureObj
                      });
                      instrumented = insertCapturesForFunctionDeclarations(instrumented, {
                        declarationWrapper: member(captureObj, literal(normalizedId + "__define__")),
                        currentModuleAccessor: currentModuleAccessor
                      });
                      imports = [];
                      toBeReplaced = [];
                      custom.forEachNode(instrumented, function (n) {
                        if (n.type === "ImportDeclaration") pushIfNotIncluded(imports, n);

                        if (n.type === "ExportDefaultDeclaration") {
                          var exp;

                          switch (n.declaration.type) {
                            case "Literal":
                              exp = Path("declaration.raw").get(n);
                              break;

                            case "Identifier":
                              exp = Path("declaration.name").get(n);
                              break;

                            case "ClassDeclaration":
                            case "FunctionDeclaration":
                              exp = Path("declaration.id.name").get(n);
                              break;
                          }

                          if (exp) defaultExport = "".concat(captureObj.name, ".default = ").concat(exp, ";\n");
                        }
                      });

                      for (_i = 0, _Object$values = Object.values(groupBy(imports, function (imp) {
                        return imp.source.value;
                      })); _i < _Object$values.length; _i++) {
                        stmts = _Object$values[_i];
                        toBeMerged = stmts.filter(function (stmt) {
                          return stmt.specifiers.every(function (spec) {
                            return spec.type === "ImportSpecifier";
                          });
                        });

                        if (toBeMerged.length > 1) {
                          mergedSpecifiers = uniqBy(toBeMerged.map(function (stmt) {
                            return stmt.specifiers;
                          }).flat(), function (spec1, spec2) {
                            return spec1.type === "ImportSpecifier" && spec2.type === "ImportSpecifier" && spec1.imported.name === spec2.imported.name && spec1.local.name === spec2.local.name;
                          });
                          toBeMerged[0].specifiers = mergedSpecifiers;
                          toBeReplaced.push.apply(toBeReplaced, _toConsumableArray$1(toBeMerged.slice(1).map(function (stmt) {
                            stmt.body = [];
                            stmt.type = "Program";
                            return stmt;
                          })));
                        }
                      }

                    case 65:
                      instrumented.body = [].concat(_toConsumableArray$1(parse$2(recorderString).body), _toConsumableArray$1(parse$2(this.isResurrectionBuild ? moduleHash + moduleExports : "").body), _toConsumableArray$1(parse$2(classRuntimeImport).body), _toConsumableArray$1(instrumented.body), _toConsumableArray$1(parse$2(defaultExport).body));
                      return _context8.abrupt("return", instrumented);

                    case 67:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, this, [[5, 30, 33, 36]]);
            }));

            function LivelyRollup_captureScope_(_x9, _x10, _x11, _x12) {
              return _LivelyRollup_captureScope_.apply(this, arguments);
            }

            return LivelyRollup_captureScope_;
          }()
        }, {
          key: "deriveVarName",
          value: function LivelyRollup_deriveVarName_(moduleId) {
            return camelize(last$2(moduleId.split("/")).replace(/\.js|\.min/g, "").split(".").join(""));
          }
        }, {
          key: "wrapStandalone",
          value: function () {
            var _LivelyRollup_wrapStandalone_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(moduleId) {
              var source, globalVarName, code;
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      moduleId = this.resolver.resolveModuleId(moduleId, undefined, this.getResolutionContext());
                      _context9.next = 3;
                      return resource(moduleId).read();

                    case 3:
                      source = _context9.sent;
                      globalVarName = this.deriveVarName(moduleId);

                      if (this.resolver.detectFormat(moduleId) === "global") {
                        code = "var ".concat(globalVarName, " = (function() {\n         var fetchGlobals = prepareGlobal(\"").concat(moduleId, "\");\n         ").concat(source, ";\n         return fetchGlobals();\n      })();\n");
                      } else {
                        code = "\n      var ".concat(globalVarName, ";\n        (function(module /* exports, require */) {\n         // optional parameters\n         var exports = arguments.length > 0 && arguments[1] !== undefined ? arguments[1] : {};\n         var require = arguments.length > 1 && arguments[2] !== undefined ? arguments[2] : function () {};\n  \n         // try to simulate node.js context\n         var exec = function(exports, require) {\n            ").concat(source, " \n         };\n         exec(exports, require);\n         if (typeof module.exports !== 'function' && Object.keys(module.exports).length === 0) Object.assign(module.exports, exports);\n         if (typeof module.exports !== 'function' && Object.keys(module.exports).length === 0) {\n            exec(); // try to run as global\n         }\n         ").concat(globalVarName, " = module.exports;\n       })({exports: {}});\n");
                      }

                      return _context9.abrupt("return", {
                        code: code,
                        global: globalVarName
                      });

                    case 7:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, this);
            }));

            function LivelyRollup_wrapStandalone_(_x13) {
              return _LivelyRollup_wrapStandalone_.apply(this, arguments);
            }

            return LivelyRollup_wrapStandalone_;
          }()
        }, {
          key: "generateGlobals",
          value: function () {
            var _LivelyRollup_generateGlobals_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
              var systemJsEnabled,
                  code,
                  importMap,
                  globals,
                  modId,
                  _yield$this$wrapStand,
                  newCode,
                  newGlobal,
                  _iterator2,
                  _step2,
                  id,
                  _iterator3,
                  _step3,
                  _id,
                  varName,
                  _args10 = arguments;

              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      systemJsEnabled = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : this.hasDynamicImports;
                      _context10.next = 3;
                      return this.getRuntimeCode();

                    case 3:
                      code = _context10.sent;
                      importMap = false;
                      globals = {};

                      if (!systemJsEnabled) {
                        code += "".concat(this.asBrowserModule ? "var fs = {};" : "var fs = require(\"fs\");", " var _missingExportShim = () => {}, show, System, require, timing, lively, Namespace, localStorage;");
                      }

                      _context10.t0 = regeneratorRuntime.keys(this.globalModules);

                    case 8:
                      if ((_context10.t1 = _context10.t0()).done) {
                        _context10.next = 19;
                        break;
                      }

                      modId = _context10.t1.value;
                      _context10.next = 12;
                      return this.wrapStandalone(modId);

                    case 12:
                      _yield$this$wrapStand = _context10.sent;
                      newCode = _yield$this$wrapStand.code;
                      newGlobal = _yield$this$wrapStand.global;
                      code += newCode;
                      globals[modId] = newGlobal;
                      _context10.next = 8;
                      break;

                    case 19:
                      if (!systemJsEnabled) {
                        _context10.next = 47;
                        break;
                      }

                      if (!this.needsOldSystem) {
                        _context10.next = 33;
                        break;
                      }

                      _context10.t2 = code;
                      _context10.t3 = resource;
                      _context10.t4 = this.resolver;
                      _context10.next = 26;
                      return this.resolver.normalizeFileName("lively.freezer/src/util/system.0.21.js");

                    case 26:
                      _context10.t5 = _context10.sent;
                      _context10.t6 = _context10.t4.ensureFileFormat.call(_context10.t4, _context10.t5);
                      _context10.next = 30;
                      return (0, _context10.t3)(_context10.t6).read();

                    case 30:
                      code = _context10.t2 += _context10.sent;
                      _context10.next = 43;
                      break;

                    case 33:
                      _context10.t7 = code;
                      _context10.t8 = resource;
                      _context10.t9 = this.resolver;
                      _context10.next = 38;
                      return this.resolver.normalizeFileName("lively.freezer/src/util/system.6.js");

                    case 38:
                      _context10.t10 = _context10.sent;
                      _context10.t11 = _context10.t9.ensureFileFormat.call(_context10.t9, _context10.t10);
                      _context10.next = 42;
                      return (0, _context10.t8)(_context10.t11).read();

                    case 42:
                      code = _context10.t7 += _context10.sent;

                    case 43:
                      code += "(".concat(instrumentStaticSystemJS.toString(), ")(System);\n");

                      if (this.needsOldSystem) {
                        _iterator2 = _createForOfIteratorHelper(this.excludedModules.concat(this.asBrowserModule ? ["fs", "events"] : []));

                        try {
                          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                            id = _step2.value;
                            code += "System.set(\"".concat(id, "\", System.newModule({ default: {} }));\n");
                          }
                        } catch (err) {
                          _iterator2.e(err);
                        } finally {
                          _iterator2.f();
                        }
                      } else {
                        importMap = "<script type=\"systemjs-importmap\">\n{\n\"imports\": {\n";
                        importMap += this.excludedModules.concat(this.asBrowserModule ? ["fs", "events"] : []).map(function (id) {
                          return "\"".concat(id, "\": \"./@empty.js\"");
                        }).join(",\n");
                        importMap += "\n  }\n}\n</script>";
                      }

                      _context10.next = 49;
                      break;

                    case 47:
                      _iterator3 = _createForOfIteratorHelper(this.excludedModules);

                      try {
                        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                          _id = _step3.value;
                          varName = globals[_id] = this.deriveVarName(_id);
                          code += "var ".concat(varName, " = {};\n");
                        }
                      } catch (err) {
                        _iterator3.e(err);
                      } finally {
                        _iterator3.f();
                      }

                    case 49:
                      return _context10.abrupt("return", {
                        code: code,
                        globals: globals,
                        importMap: importMap
                      });

                    case 50:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, this);
            }));

            function LivelyRollup_generateGlobals_() {
              return _LivelyRollup_generateGlobals_.apply(this, arguments);
            }

            return LivelyRollup_generateGlobals_;
          }()
        }, {
          key: "getRuntimeCode",
          value: function () {
            var _LivelyRollup_getRuntimeCode_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
              var includePolyfills, runtimeCode, regeneratorSource, polyfills;
              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      includePolyfills = this.includePolyfills && this.asBrowserModule;
                      _context11.t0 = resource;
                      _context11.t1 = this.resolver;
                      _context11.next = 5;
                      return this.resolver.normalizeFileName("lively.freezer/src/util/runtime.js");

                    case 5:
                      _context11.t2 = _context11.sent;
                      _context11.t3 = _context11.t1.ensureFileFormat.call(_context11.t1, _context11.t2);
                      _context11.next = 9;
                      return (0, _context11.t0)(_context11.t3).read();

                    case 9:
                      runtimeCode = _context11.sent;
                      _context11.t4 = resource;
                      _context11.t5 = this.resolver;
                      _context11.next = 14;
                      return this.resolver.normalizeFileName("lively.freezer/src/util/regenerator-runtime.js");

                    case 14:
                      _context11.t6 = _context11.sent;
                      _context11.t7 = _context11.t5.ensureFileFormat.call(_context11.t5, _context11.t6);
                      _context11.next = 18;
                      return (0, _context11.t4)(_context11.t7).read();

                    case 18:
                      regeneratorSource = _context11.sent;

                      if (!includePolyfills) {
                        _context11.next = 31;
                        break;
                      }

                      _context11.t9 = resource;
                      _context11.t10 = this.resolver;
                      _context11.next = 24;
                      return this.resolver.normalizeFileName("lively.freezer/deps/fetch.umd.js");

                    case 24:
                      _context11.t11 = _context11.sent;
                      _context11.t12 = _context11.t10.ensureFileFormat.call(_context11.t10, _context11.t11);
                      _context11.next = 28;
                      return (0, _context11.t9)(_context11.t12).read();

                    case 28:
                      _context11.t8 = _context11.sent;
                      _context11.next = 32;
                      break;

                    case 31:
                      _context11.t8 = "";

                    case 32:
                      polyfills = _context11.t8;
                      runtimeCode = "(".concat(runtimeCode.slice(0, -1).replace("export ", ""), ")();\n");

                      if (!this.hasDynamicImports) {
                        runtimeCode += __varRecorder__$A.SYSTEMJS_STUB;
                      }

                      if (this.isResurrectionBuild) {
                        runtimeCode += "lively.isResurrectionBuild = true;";
                      }

                      runtimeCode += regeneratorSource;
                      runtimeCode += polyfills;
                      return _context11.abrupt("return", es5Transpilation(runtimeCode));

                    case 39:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11, this);
            }));

            function LivelyRollup_getRuntimeCode_() {
              return _LivelyRollup_getRuntimeCode_.apply(this, arguments);
            }

            return LivelyRollup_getRuntimeCode_;
          }()
        }, {
          key: "generateAssetPreloads",
          value: function LivelyRollup_generateAssetPreloads_() {
            return compact(uniq(this.customFontFiles.map(function (fontFile) {
              return "<link rel=\"preload\" href=\"".concat(joinPath("./assets", "".concat(fontFile.name())), "\" as=\"font\">");
            }))).join("\n");
          }
        }, {
          key: "generateIndexHtml",
          value: function () {
            var _LivelyRollup_generateIndexHtml_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(importMap, modules) {
              var _this$autoRun;

              return regeneratorRuntime.wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      _context12.next = 2;
                      return generateLoadHtml(Object.assign({}, this.autoRun || {}, {
                        head: (((_this$autoRun = this.autoRun) === null || _this$autoRun === void 0 ? void 0 : _this$autoRun.head) || "") + this.generateAssetPreloads()
                      }), importMap, this.resolver, modules, this.isResurrectionBuild);

                    case 2:
                      return _context12.abrupt("return", _context12.sent);

                    case 3:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12, this);
            }));

            function LivelyRollup_generateIndexHtml_(_x14, _x15) {
              return _LivelyRollup_generateIndexHtml_.apply(this, arguments);
            }

            return LivelyRollup_generateIndexHtml_;
          }()
        }, {
          key: "generateBundle",
          value: function () {
            var _LivelyRollup_generateBundle_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(plugin, bundle, depsCode, importMap, opts) {
              var _this3 = this;

              var modules, codeToMinify, _yield$compileOnServe, minfiedCode, compiledSnippets, adjustedSnippets, polyfills, _iterator4, _step4, _step4$value, snippet, compiled, _iterator5, _step5, chunk, morphicUrl, fontBundleDir, fontFiles, _iterator6, _step6, file, _source, assetDir, morphicCSS, source, livelyDir, projectsDir, bundledProjectCSS, bundledProjectFontCSS, _iterator7, _step7, _step7$value, project, indexCSSFile, indexCSSContents, fontCSSFile, fontCSSContents, _assetDir, _this$customFontFiles, _fontFiles, _iterator9, _step9, _file, _source2, bundledCSS, _iterator8, _step8, asset, _file2, _source3;

              return regeneratorRuntime.wrap(function _callee13$(_context13) {
                while (1) {
                  switch (_context13.prev = _context13.next) {
                    case 0:
                      modules = Object.values(bundle);
                      modules.forEach(function (chunk) {
                        if (chunk.code) {
                          if (_this3.isResurrectionBuild) {
                            chunk.code = chunk.code.replace("System.register", "BootstrapSystem._currentFile = \"".concat(chunk.fileName, "\";\nBootstrapSystem.register"));
                          }

                          chunk.code = chunk.code.replace("'use strict'", "var __contextModule__ = typeof module !== 'undefined' ? module : arguments[1];\n");
                        }
                      });

                      if (!(this.minify && opts.format !== "esm")) {
                        _context13.next = 18;
                        break;
                      }

                      modules.forEach(function (chunk, i) {
                        chunk.instrumentedCode = "\"".concat(__varRecorder__$A.separator, "\",").concat(i, ";\n") + chunk.code;
                      });
                      codeToMinify = modules.map(function (chunk) {
                        return chunk.instrumentedCode;
                      }).join("\n");
                      _context13.next = 7;
                      return compileOnServer(codeToMinify, this.resolver, this.useTerser);

                    case 7:
                      _yield$compileOnServe = _context13.sent;
                      minfiedCode = _yield$compileOnServe.min;
                      compiledSnippets = minfiedCode.split(new RegExp("\"".concat(__varRecorder__$A.separator, "\";\n?")));
                      adjustedSnippets = new Map();
                      modules.forEach(function (snippet, i) {
                        adjustedSnippets.set(i, snippet.code);
                      });
                      compiledSnippets.forEach(function (compiledSnippet, i) {
                        var hit = compiledSnippet.match(/^[0-9]+;\n?/);
                        if (!hit) return;
                        var hint = Number(hit[0].replace(/;\n?/, ""));
                        adjustedSnippets.set(hint, compiledSnippet.replace(/^[0-9]+;\n?/, ""));
                      });
                      polyfills = compiledSnippets[0];
                      compiledSnippets = _toConsumableArray$1(adjustedSnippets.values());
                      compiledSnippets[0] = polyfills + compiledSnippets[0];
                      _iterator4 = _createForOfIteratorHelper(zip(modules, compiledSnippets));

                      try {
                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                          _step4$value = _slicedToArray(_step4.value, 2), snippet = _step4$value[0], compiled = _step4$value[1];
                          snippet.code = compiled.replace("'use strict';", "");
                        }
                      } catch (err) {
                        _iterator4.e(err);
                      } finally {
                        _iterator4.f();
                      }

                    case 18:
                      if (!this.isResurrectionBuild) {
                        _context13.next = 29;
                        break;
                      }

                      _context13.t0 = plugin;
                      _context13.t1 = this.resolver;
                      _context13.next = 23;
                      return this.resolver.normalizeFileName("lively.classes/build/runtime.js");

                    case 23:
                      _context13.t2 = _context13.sent;
                      _context13.next = 26;
                      return _context13.t1.load.call(_context13.t1, _context13.t2);

                    case 26:
                      _context13.t3 = _context13.sent;
                      _context13.t4 = {
                        type: "asset",
                        fileName: "livelyClassesRuntime.js",
                        source: _context13.t3
                      };

                      _context13.t0.emitFile.call(_context13.t0, _context13.t4);

                    case 29:
                      if (!this.compress) {
                        _context13.next = 59;
                        break;
                      }

                      _iterator5 = _createForOfIteratorHelper(modules);
                      _context13.prev = 31;

                      _iterator5.s();

                    case 33:
                      if ((_step5 = _iterator5.n()).done) {
                        _context13.next = 51;
                        break;
                      }

                      chunk = _step5.value;
                      _context13.t5 = plugin;
                      _context13.t6 = chunk.fileName + ".gz";
                      _context13.next = 39;
                      return gzip(chunk.code);

                    case 39:
                      _context13.t7 = _context13.sent;
                      _context13.t8 = {
                        type: "asset",
                        fileName: _context13.t6,
                        source: _context13.t7
                      };

                      _context13.t5.emitFile.call(_context13.t5, _context13.t8);

                      _context13.t9 = plugin;
                      _context13.t10 = chunk.fileName + ".br";
                      _context13.next = 46;
                      return brotli(chunk.code);

                    case 46:
                      _context13.t11 = _context13.sent;
                      _context13.t12 = {
                        type: "asset",
                        fileName: _context13.t10,
                        source: _context13.t11
                      };

                      _context13.t9.emitFile.call(_context13.t9, _context13.t12);

                    case 49:
                      _context13.next = 33;
                      break;

                    case 51:
                      _context13.next = 56;
                      break;

                    case 53:
                      _context13.prev = 53;
                      _context13.t13 = _context13["catch"](31);

                      _iterator5.e(_context13.t13);

                    case 56:
                      _context13.prev = 56;

                      _iterator5.f();

                      return _context13.finish(56);

                    case 59:
                      morphicUrl = this.resolver.ensureFileFormat(this.resolver.decanonicalizeFileName("lively.morphic").replace("index.js", ""));

                      if (!this.includeLivelyAssets) {
                        _context13.next = 94;
                        break;
                      }

                      fontBundleDir = resource(config$2.css.fontBundle).parent();
                      _context13.next = 64;
                      return fontBundleDir.dirList();

                    case 64:
                      fontFiles = _context13.sent;
                      _iterator6 = _createForOfIteratorHelper(fontFiles);
                      _context13.prev = 66;

                      _iterator6.s();

                    case 68:
                      if ((_step6 = _iterator6.n()).done) {
                        _context13.next = 78;
                        break;
                      }

                      file = _step6.value;
                      file.beBinary();
                      _context13.next = 73;
                      return file.read();

                    case 73:
                      _source = _context13.sent;
                      if (_source instanceof ArrayBuffer) _source = new Uint8Array(_source);
                      plugin.emitFile({
                        type: "asset",
                        fileName: joinPath(fontBundleDir.url.replace(morphicUrl, ""), file.name()),
                        source: _source
                      });

                    case 76:
                      _context13.next = 68;
                      break;

                    case 78:
                      _context13.next = 83;
                      break;

                    case 80:
                      _context13.prev = 80;
                      _context13.t14 = _context13["catch"](66);

                      _iterator6.e(_context13.t14);

                    case 83:
                      _context13.prev = 83;

                      _iterator6.f();

                      return _context13.finish(83);

                    case 86:
                      assetDir = resource(config$2.css.fontBundle).parent().parent();
                      morphicCSS = assetDir.join("morphic.css");
                      morphicCSS.beBinary();
                      _context13.next = 91;
                      return morphicCSS.read();

                    case 91:
                      source = _context13.sent;
                      if (source instanceof ArrayBuffer) source = new Uint8Array(source);
                      plugin.emitFile({
                        type: "asset",
                        fileName: joinPath(assetDir.url.replace(morphicUrl, ""), "morphic.css"),
                        source: source
                      });

                    case 94:
                      livelyDir = resource(morphicUrl).join("..").withRelativePartsResolved();
                      projectsDir = resource(livelyDir).join("local_projects");
                      bundledProjectCSS = "";
                      bundledProjectFontCSS = "";
                      _iterator7 = _createForOfIteratorHelper(this.projectsInBundle.entries());
                      _context13.prev = 99;

                      _iterator7.s();

                    case 101:
                      if ((_step7 = _iterator7.n()).done) {
                        _context13.next = 147;
                        break;
                      }

                      _step7$value = _slicedToArray(_step7.value, 1), project = _step7$value[0];
                      indexCSSFile = projectsDir.join(project).join("index.css");
                      _context13.next = 106;
                      return indexCSSFile.read();

                    case 106:
                      indexCSSContents = _context13.sent;
                      bundledProjectCSS = indexCSSContents + "\n" + bundledProjectCSS;
                      fontCSSFile = projectsDir.join(project).join("fonts.css");
                      _context13.next = 111;
                      return fontCSSFile.read();

                    case 111:
                      fontCSSContents = _context13.sent.replaceAll(/\.\/assets\//g, "./");
                      bundledProjectFontCSS = fontCSSContents + "\n" + bundledProjectFontCSS;
                      _context13.next = 115;
                      return projectsDir.join(project).join("assets");

                    case 115:
                      _assetDir = _context13.sent;
                      _context13.next = 118;
                      return _assetDir.exists();

                    case 118:
                      if (!_context13.sent) {
                        _context13.next = 145;
                        break;
                      }

                      _context13.next = 121;
                      return _assetDir.dirList();

                    case 121:
                      _context13.t15 = function (f) {
                        return f.url.includes("woff2");
                      };

                      _fontFiles = _context13.sent.filter(_context13.t15);

                      (_this$customFontFiles = this.customFontFiles).push.apply(_this$customFontFiles, _toConsumableArray$1(_fontFiles));

                      _iterator9 = _createForOfIteratorHelper(_fontFiles);
                      _context13.prev = 125;

                      _iterator9.s();

                    case 127:
                      if ((_step9 = _iterator9.n()).done) {
                        _context13.next = 137;
                        break;
                      }

                      _file = _step9.value;

                      _file.beBinary();

                      _context13.next = 132;
                      return _file.read();

                    case 132:
                      _source2 = _context13.sent;
                      if (_source2 instanceof ArrayBuffer) _source2 = new Uint8Array(_source2);
                      plugin.emitFile({
                        type: "asset",
                        fileName: joinPath("assets", _file.name()),
                        source: _source2
                      });

                    case 135:
                      _context13.next = 127;
                      break;

                    case 137:
                      _context13.next = 142;
                      break;

                    case 139:
                      _context13.prev = 139;
                      _context13.t16 = _context13["catch"](125);

                      _iterator9.e(_context13.t16);

                    case 142:
                      _context13.prev = 142;

                      _iterator9.f();

                      return _context13.finish(142);

                    case 145:
                      _context13.next = 101;
                      break;

                    case 147:
                      _context13.next = 152;
                      break;

                    case 149:
                      _context13.prev = 149;
                      _context13.t17 = _context13["catch"](99);

                      _iterator7.e(_context13.t17);

                    case 152:
                      _context13.prev = 152;

                      _iterator7.f();

                      return _context13.finish(152);

                    case 155:
                      bundledCSS = bundledProjectFontCSS + "\n" + bundledProjectCSS;
                      plugin.emitFile({
                        type: "asset",
                        fileName: joinPath("assets", "bundle.css"),
                        source: bundledCSS
                      });
                      _iterator8 = _createForOfIteratorHelper(this.projectAssets);
                      _context13.prev = 158;

                      _iterator8.s();

                    case 160:
                      if ((_step8 = _iterator8.n()).done) {
                        _context13.next = 173;
                        break;
                      }

                      asset = _step8.value;
                      _file2 = resource(projectsDir).join(asset.project).join("assets").join("".concat(asset.oldName));

                      if (!_file2.isDirectory()) {
                        _context13.next = 165;
                        break;
                      }

                      return _context13.abrupt("continue", 171);

                    case 165:
                      _file2.beBinary();

                      _context13.next = 168;
                      return _file2.read();

                    case 168:
                      _source3 = _context13.sent;
                      if (_source3 instanceof ArrayBuffer) _source3 = new Uint8Array(_source3);
                      plugin.emitFile({
                        type: "asset",
                        fileName: joinPath("assets", "".concat(asset.newName)),
                        source: _source3
                      });

                    case 171:
                      _context13.next = 160;
                      break;

                    case 173:
                      _context13.next = 178;
                      break;

                    case 175:
                      _context13.prev = 175;
                      _context13.t18 = _context13["catch"](158);

                      _iterator8.e(_context13.t18);

                    case 178:
                      _context13.prev = 178;

                      _iterator8.f();

                      return _context13.finish(178);

                    case 181:
                      plugin.emitFile({
                        type: "asset",
                        fileName: "@empty.js",
                        source: ""
                      });

                      if (!this.autoRun) {
                        _context13.next = 198;
                        break;
                      }

                      _context13.t19 = depsCode;
                      _context13.t20 = "lively.FreezerRuntime.availableFonts = ";
                      _context13.t21 = JSON;
                      _context13.next = 188;
                      return this.resolver.availableFonts(bundledProjectFontCSS);

                    case 188:
                      _context13.t22 = _context13.sent;
                      _context13.t23 = _context13.t21.stringify.call(_context13.t21, _context13.t22);
                      depsCode = _context13.t19 += _context13.t20.concat.call(_context13.t20, _context13.t23);
                      plugin.emitFile({
                        type: "asset",
                        fileName: "deps.js",
                        source: depsCode
                      });
                      _context13.t24 = plugin;
                      _context13.next = 195;
                      return this.generateIndexHtml(importMap, modules);

                    case 195:
                      _context13.t25 = _context13.sent;
                      _context13.t26 = {
                        type: "asset",
                        fileName: "index.html",
                        source: _context13.t25
                      };

                      _context13.t24.emitFile.call(_context13.t24, _context13.t26);

                    case 198:
                      this.resolver.finish();

                    case 199:
                    case "end":
                      return _context13.stop();
                  }
                }
              }, _callee13, this, [[31, 53, 56, 59], [66, 80, 83, 86], [99, 149, 152, 155], [125, 139, 142, 145], [158, 175, 178, 181]]);
            }));

            function LivelyRollup_generateBundle_(_x16, _x17, _x18, _x19, _x20) {
              return _LivelyRollup_generateBundle_.apply(this, arguments);
            }

            return LivelyRollup_generateBundle_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "LivelyRollup";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./src/bundler.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.freezer",
              version: "0.1.0"
            };
          }
        }, {
          start: 4786,
          end: 43204
        });
      }(undefined);
      __varRecorder__$A["default"] = LivelyRollup;

      var G$1 = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : undefined;

      var __varRecorder__$z = (G$1.lively.FreezerRuntime || G$1.lively.frozenModules).recorderFor("lively.freezer/src/plugins/rollup.js", __contextModule__);

      var __moduleMeta__$i = {
        pathInPackage: function pathInPackage() {
          return "./src/plugins/rollup.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.freezer",
            version: "0.1.0"
          };
        }
      };

      var isBuiltin = __varRecorder__$z["lively.freezer/src/plugins/rollup.js__define__"]("isBuiltin", "function", function (id, resolver) {
        return id.startsWith("node:") || resolver.builtinModules.includes(id);
      }, __moduleMeta__$i);

      __varRecorder__$z.isBuiltin = isBuiltin;

      var isCommonJsModule = __varRecorder__$z["lively.freezer/src/plugins/rollup.js__define__"]("isCommonJsModule", "function", function (id) {
        return id.includes("?commonjs-external") || id.includes("?commonjs-exports") || id.includes("?commonjs-entry") || id.includes("commonjsHelpers.js");
      }, __moduleMeta__$i);

      __varRecorder__$z.isCommonJsModule = isCommonJsModule;
      function lively$1(args) {
        var globals, importMap, depsCode;
        var bundler = new LivelyRollup(args);
        var _args$map = args.map,
            map = _args$map === void 0 ? {} : _args$map,
            isResurrectionBuild = args.isResurrectionBuild;
        return {
          name: "rollup-plugin-lively",
          buildStart: function buildStart() {
            return bundler.buildStart(this);
          },
          resolveId: function () {
            var _resolveId = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(id, importer) {
              var res;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (!(__varRecorder__$z.isBuiltin(id, bundler.resolver) || id.startsWith("\0"))) {
                        _context.next = 2;
                        break;
                      }

                      return _context.abrupt("return", null);

                    case 2:
                      _context.next = 4;
                      return bundler.resolveId(map[id] || id, importer);

                    case 4:
                      res = _context.sent;
                      return _context.abrupt("return", res);

                    case 6:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));

            function resolveId(_x, _x2) {
              return _resolveId.apply(this, arguments);
            }

            return resolveId;
          }(),
          resolveDynamicImport: function () {
            var _resolveDynamicImport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(node, importer) {
              var res;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      if (!(typeof node === "string" && __varRecorder__$z.isBuiltin(node, bundler.resolver))) {
                        _context2.next = 2;
                        break;
                      }

                      return _context2.abrupt("return", node.replace("node:", ""));

                    case 2:
                      _context2.next = 4;
                      return bundler.resolveDynamicImport(node, importer);

                    case 4:
                      res = _context2.sent;
                      return _context2.abrupt("return", res);

                    case 6:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }));

            function resolveDynamicImport(_x3, _x4) {
              return _resolveDynamicImport.apply(this, arguments);
            }

            return resolveDynamicImport;
          }(),
          load: function load(id) {
            if (id.startsWith("\0")) return null;
            if (__varRecorder__$z.isBuiltin(id, bundler.resolver) || __varRecorder__$z.isCommonJsModule(id)) return null;

            try {
              return bundler.load(id);
            } catch (err) {
              return null;
            }
          },
          transform: function () {
            var _transform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(source, id) {
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      if (!id.startsWith("\0")) {
                        _context3.next = 2;
                        break;
                      }

                      return _context3.abrupt("return", null);

                    case 2:
                      _context3.prev = 2;
                      _context3.next = 5;
                      return bundler.transform(source, id);

                    case 5:
                      return _context3.abrupt("return", _context3.sent);

                    case 8:
                      _context3.prev = 8;
                      _context3.t0 = _context3["catch"](2);
                      return _context3.abrupt("return", null);

                    case 11:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, null, [[2, 8]]);
            }));

            function transform(_x5, _x6) {
              return _transform.apply(this, arguments);
            }

            return transform;
          }(),
          buildEnd: function buildEnd() {
            return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      _context4.next = 2;
                      return bundler.generateGlobals();

                    case 2:
                      __varRecorder__$z.__inter0__ = _context4.sent;
                      depsCode = __varRecorder__$z.__inter0__.code;
                      globals = __varRecorder__$z.__inter0__.globals;
                      importMap = __varRecorder__$z.__inter0__.importMap;
                      __varRecorder__$z.__inter0__;

                    case 7:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            }))();
          },
          options: function options(opts) {
            if (isResurrectionBuild) {
              opts.external ? pushIfNotIncluded(opts.external, "livelyClassesRuntime.js") : opts.external = ["livelyClassesRuntime.js"];
            }

            if (bundler.snapshot || !!bundler.autoRun) {
              bundler.rootModuleId = opts.input;
              delete opts.input;
            }

            if (bundler.excludedModules.length > 0) {
              opts.shimMissingExports = true;
            }

            if (!opts.onwarn) opts.onwarn = function (warning, warn) {
              return customWarn(warning, warn, bundler);
            };
            var self = opts.plugins.find(function (plugin) {
              return plugin.name === "rollup-plugin-lively";
            });
            opts.plugins = [].concat(_toConsumableArray$1(bundler.resolver.supportingPlugins(bundler.asBrowserModule ? "browser" : "node", self)), _toConsumableArray$1(without$1(opts.plugins, self)));

            var _iterator = _createForOfIteratorHelper(opts.plugins),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var plugin = _step.value;
                if (plugin === self) continue;
                if (plugin.options) opts = plugin.options.bind(this)(opts) || opts;
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            return opts;
          },
          outputOptions: function outputOptions(opts) {
            if (opts.globals) {
              if (isFunction$2(opts.globals)) {
                var origGetGlobal = opts.globals;

                opts.globals = function (id) {
                  return globals[id] || origGetGlobal(id);
                };
              } else {
                opts.globals = Object.assign({}, opts.globals, {}, globals);
              }
            }

            return opts;
          },
          renderDynamicImport: function renderDynamicImport() {
            bundler.hasDynamicImports = true;
            return null;
          },
          generateBundle: function generateBundle(options, bundle, isWrite) {
            var _this = this;

            return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.next = 2;
                      return bundler.generateBundle(_this, bundle, depsCode, importMap, options);

                    case 2:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5);
            }))();
          },
          renderError: function renderError() {
            process.exit(1);
          }
        };
      }

      var G = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : undefined;

      var __varRecorder__$y = (G.lively.FreezerRuntime || G.lively.frozenModules).recorderFor("lively.freezer/index.js", __contextModule__);

      var __moduleMeta__$h = {
        pathInPackage: function pathInPackage() {
          return "./index.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.freezer",
            version: "0.1.0"
          };
        }
      };

      var clearWorldSnapshot = __varRecorder__$y["lively.freezer/index.js__define__"]("clearWorldSnapshot", "function", function (snap) {
        var deletedIds = [];
        var toolIds = [];
        values(snap.snapshot).forEach(function (m) {
          return delete m.props.metadata;
        });
        transpileAttributeConnections(snap);

        for (var id in snap.snapshot) {
          delete snap.snapshot[id].props.localComponents;
          delete snap.snapshot[id].props.metadata;
          delete snap.snapshot[id]._cachedLineCharBounds;

          if (id === snap.id) {
            snap.snapshot[id].props.askForName = {
              value: false
            };
          }

          var module = moduleOfId(snap.snapshot, id);
          if (!module["package"]) continue;
          if (module["package"].name === "lively.ide") toolIds.push(id);

          if (__varRecorder__$y.DEFAULT_EXCLUDED_MODULES_WORLD.includes(module["package"].name)) {
            delete snap.snapshot[id];
            deletedIds.push(id);
            continue;
          }
        }

        for (var _id in snap.snapshot) {
          var className = classNameOfId(snap.snapshot, _id);

          if (intersect(referencesOfId(snap.snapshot, _id), [].concat(deletedIds, toolIds)).length > 0) {
            if (className === "Window") {
              delete snap.snapshot[_id];
              continue;
            }

            for (var _i = 0, _Object$entries = Object.entries(snap.snapshot[_id].props); _i < _Object$entries.length; _i++) {
              var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                  key = _Object$entries$_i[0],
                  v = _Object$entries$_i[1].value;

              if (isReference(v) && deletedIds.includes(v.id)) {
                delete snap.snapshot[_id].props[key];
              }

              if (Array.isArray(v)) {
                snap.snapshot[_id].props[key].value = v.filter(function (v) {
                  return !(isReference(v) && deletedIds.includes(v.id));
                });
              }
            }
          }
        }

        removeUnreachableObjects([snap.id], snap.snapshot);
        return snap;
      }, __moduleMeta__$h);

      __varRecorder__$y.clearWorldSnapshot = clearWorldSnapshot;

      var promptForFreezing = __varRecorder__$y["lively.freezer/index.js__define__"]("promptForFreezing", "function", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(targetOrModule, requester) {
          var title,
              excludedModules,
              freezerPrompt,
              userName,
              previouslyExcludedPackages,
              previouslyPublishedDir,
              res,
              _args2 = arguments;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  title = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : "Freeze Part";
                  excludedModules = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : false;
                  freezerPrompt = part(FreezerPrompt, {
                    submorphs: [{
                      name: "prompt title",
                      textAndAttributes: [title, null]
                    }]
                  });
                  userName = currentUsername();
                  previouslyExcludedPackages = excludedModules || Path("metadata.excludedPackages").get(targetOrModule) || __varRecorder__$y.DEFAULT_EXCLUDED_MODULES;
                  previouslyPublishedDir = Path("metadata.publishedLocation").get(targetOrModule) || resource(System.baseURL).join("users").join(userName).join("published").join(targetOrModule.name || BrowserResolver.resolvePackage(targetOrModule).name).url;
                  _context2.next = 8;
                  return $world.withRequesterDo(requester, /*#__PURE__*/function () {
                    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(pos) {
                      return regeneratorRuntime.wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              freezerPrompt.isModuleBundle = typeof targetOrModule === "string";

                              if (freezerPrompt.isModuleBundle && requester.isBrowser) {
                                freezerPrompt.mainCandidates = requester.renderedCodeEntities().filter(function (node) {
                                  return node.type === "function-decl";
                                }).map(function (node) {
                                  return node.name;
                                });
                              }

                              freezerPrompt.excludedPackages = previouslyExcludedPackages;
                              freezerPrompt.directory = previouslyPublishedDir;
                              freezerPrompt.openInWorld();
                              freezerPrompt.env.forceUpdate();
                              freezerPrompt.center = pos;
                              _context.next = 9;
                              return freezerPrompt.activate();

                            case 9:
                              res = _context.sent;

                            case 10:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee);
                    }));

                    return function (_x3) {
                      return _ref2.apply(this, arguments);
                    };
                  }());

                case 8:
                  return _context2.abrupt("return", res);

                case 9:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }(), __moduleMeta__$h);

      __varRecorder__$y.promptForFreezing = promptForFreezing;

      var bundlePart = __varRecorder__$y["lively.freezer/index.js__define__"]("bundlePart", "function", /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(partOrSnapshot, _ref3) {
          var _ref3$exclude, excludedModules, useTerser, jsonPlugin, snapshot, freezerPlugin, bundle;

          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _ref3$exclude = _ref3.exclude, excludedModules = _ref3$exclude === void 0 ? [] : _ref3$exclude, useTerser = _ref3.useTerser;
                  _context3.next = 3;
                  return module.import('./plugin-json-b5b353e0.js');

                case 3:
                  jsonPlugin = _context3.sent;

                  if (!partOrSnapshot.isMorph) {
                    _context3.next = 10;
                    break;
                  }

                  _context3.next = 7;
                  return createMorphSnapshot(partOrSnapshot, {
                    frozenSnapshot: true
                  });

                case 7:
                  _context3.t0 = _context3.sent;
                  _context3.next = 11;
                  break;

                case 10:
                  _context3.t0 = partOrSnapshot;

                case 11:
                  snapshot = _context3.t0;
                  transpileAttributeConnections(snapshot);
                  freezerPlugin = lively$1({
                    excludedModules: excludedModules,
                    snapshot: snapshot,
                    useTerser: useTerser,
                    resolver: BrowserResolver
                  });
                  _context3.next = 16;
                  return _missingExportShim({
                    plugins: [freezerPlugin, jsonPlugin({
                      exclude: /esm\:\/\/cache\/.*\.json/
                    })]
                  });

                case 16:
                  bundle = _context3.sent;
                  _context3.next = 19;
                  return bundle.generate({
                    globalName: "frozenPart",
                    format: "system",
                    plugins: [freezerPlugin]
                  });

                case 19:
                  return _context3.abrupt("return", _context3.sent);

                case 20:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function (_x4, _x5) {
          return _ref4.apply(this, arguments);
        };
      }(), __moduleMeta__$h);

      __varRecorder__$y.bundlePart = bundlePart;

      var bundleModule = __varRecorder__$y["lively.freezer/index.js__define__"]("bundleModule", "function", /*#__PURE__*/function () {
        var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(moduleId, _ref5) {
          var _ref5$exclude, excludedModules, _ref5$compress, compress, _ref5$minify, minify, mainFunction, htmlConfig, useTerser, _yield$import, jsonPlugin, bundle;

          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _ref5$exclude = _ref5.exclude, excludedModules = _ref5$exclude === void 0 ? [] : _ref5$exclude, _ref5$compress = _ref5.compress, compress = _ref5$compress === void 0 ? false : _ref5$compress, _ref5$minify = _ref5.minify, minify = _ref5$minify === void 0 ? true : _ref5$minify, mainFunction = _ref5.mainFunction, htmlConfig = _ref5.htmlConfig, useTerser = _ref5.useTerser;
                  _context4.next = 3;
                  return module.import('./plugin-json-b5b353e0.js');

                case 3:
                  _yield$import = _context4.sent;
                  jsonPlugin = _yield$import["default"];
                  _context4.next = 7;
                  return _missingExportShim({
                    input: moduleId,
                    plugins: [lively$1({
                      excludedModules: excludedModules,
                      mainFunction: mainFunction,
                      useTerser: useTerser,
                      compress: compress,
                      minify: minify,
                      resolver: BrowserResolver,
                      autoRun: htmlConfig
                    }), jsonPlugin({
                      exclude: /esm\:\/\/cache\/.*\.json/
                    })]
                  });

                case 7:
                  bundle = _context4.sent;
                  _context4.next = 10;
                  return bundle.generate({
                    format: "system"
                  });

                case 10:
                  return _context4.abrupt("return", _context4.sent);

                case 11:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        return function (_x6, _x7) {
          return _ref6.apply(this, arguments);
        };
      }(), __moduleMeta__$h);

      __varRecorder__$y.bundleModule = bundleModule;

      var jspmCompile = __varRecorder__$y["lively.freezer/index.js__define__"]("jspmCompile", "function", /*#__PURE__*/function () {
        var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(url, out, globalName) {
          var redirect,
              jsonPlugin,
              freezerPlugin,
              bundle,
              _args5 = arguments;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  redirect = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : {};
                  _context5.next = 3;
                  return module.import('./plugin-json-b5b353e0.js');

                case 3:
                  jsonPlugin = _context5.sent;
                  freezerPlugin = lively$1({
                    includePolyfills: false,
                    redirect: redirect,
                    resolver: BrowserResolver,
                    excludedModules: ["babel-plugin-transform-jsx"]
                  });
                  _context5.next = 7;
                  return _missingExportShim({
                    input: url,
                    plugins: [freezerPlugin, jsonPlugin({
                      exclude: /esm\:\/\/cache\/.*\.json/
                    })]
                  });

                case 7:
                  bundle = _context5.sent;
                  _context5.next = 10;
                  return bundle.generate({
                    globalName: globalName,
                    format: "system",
                    plugins: [freezerPlugin]
                  });

                case 10:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        return function (_x8, _x9, _x10) {
          return _ref7.apply(this, arguments);
        };
      }(), __moduleMeta__$h);

      __varRecorder__$y.jspmCompile = jspmCompile;

      var bootstrapLibrary = __varRecorder__$y["lively.freezer/index.js__define__"]("bootstrapLibrary", "function", /*#__PURE__*/function () {
        var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(url, out) {
          var asBrowserModule,
              globalName,
              jsonPlugin,
              bundle,
              _args6 = arguments;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  asBrowserModule = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : true;
                  globalName = _args6.length > 3 ? _args6[3] : undefined;
                  _context6.next = 4;
                  return module.import('./plugin-json-b5b353e0.js');

                case 4:
                  jsonPlugin = _context6.sent;
                  _context6.next = 7;
                  return _missingExportShim({
                    input: url,
                    plugins: [lively$1({
                      asBrowserModule: asBrowserModule,
                      resolver: BrowserResolver,
                      excludedModules: ["babel-plugin-transform-jsx"]
                    }), jsonPlugin({
                      exclude: /esm\:\/\/cache\/.*\.json/
                    })]
                  });

                case 7:
                  bundle = _context6.sent;
                  _context6.next = 10;
                  return bundle.generate({
                    format: "system",
                    globalName: globalName
                  });

                case 10:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        return function (_x11, _x12) {
          return _ref8.apply(this, arguments);
        };
      }(), __moduleMeta__$h);

      __varRecorder__$y.bootstrapLibrary = bootstrapLibrary;

      var interactivelyFreezeWorld = __varRecorder__$y["lively.freezer/index.js__define__"]("interactivelyFreezeWorld", "function", /*#__PURE__*/function () {
        var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(world) {
          var userName, publicAlias, frozenPartsDir, publicationDirShell, publicationDir, proceed, worldSnap, frozen, li;
          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  userName = world.currentUsername;
                  publicAlias = world.metadata.commit.name;
                  _context7.next = 4;
                  return resource(System.baseURL).join("users").join(userName).join("published/").ensureExistance();

                case 4:
                  frozenPartsDir = _context7.sent;
                  _context7.t0 = resource;
                  _context7.next = 8;
                  return defaultDirectory();

                case 8:
                  _context7.t1 = _context7.sent;
                  _context7.t2 = userName;
                  publicationDirShell = (0, _context7.t0)(_context7.t1).join("..").join("users").join(_context7.t2).join("published/").withRelativePartsResolved().asDirectory();
                  publicationDir = frozenPartsDir.join(publicAlias + "/");

                case 12:
                  _context7.next = 14;
                  return publicationDir.exists();

                case 14:
                  if (!_context7.sent) {
                    _context7.next = 28;
                    break;
                  }

                  _context7.next = 17;
                  return $world.confirm("A world published as \"".concat(publicAlias, "\" already exists.\nDo you want to overwrite this publication?"), {
                    rejectLabel: "CHANGE NAME"
                  });

                case 17:
                  proceed = _context7.sent;

                  if (!proceed) {
                    _context7.next = 20;
                    break;
                  }

                  return _context7.abrupt("break", 28);

                case 20:
                  _context7.next = 22;
                  return $world.prompt("Please enter a different name for this published world:");

                case 22:
                  publicAlias = _context7.sent;

                  if (publicAlias) {
                    _context7.next = 25;
                    break;
                  }

                  return _context7.abrupt("return");

                case 25:
                  publicationDir = frozenPartsDir.join(publicAlias + "/");
                  _context7.next = 12;
                  break;

                case 28:
                  _context7.next = 30;
                  return publicationDir.ensureExistance();

                case 30:
                  worldSnap = __varRecorder__$y.clearWorldSnapshot(serializeMorph(world));
                  _context7.prev = 31;
                  _context7.next = 34;
                  return __varRecorder__$y.bundlePart(worldSnap, {
                    compress: true,
                    exclude: __varRecorder__$y.DEFAULT_EXCLUDED_MODULES_WORLD
                  });

                case 34:
                  frozen = _context7.sent;
                  frozen.part = world;
                  _context7.next = 41;
                  break;

                case 38:
                  _context7.prev = 38;
                  _context7.t3 = _context7["catch"](31);
                  throw _context7.t3;

                case 41:
                  li = open$1("Freezing World", {
                    status: "Writing files..."
                  });
                  _context7.next = 44;
                  return writeFiles(frozen, li, {
                    dir: publicationDir,
                    shell: publicationDirShell,
                    resolver: BrowserResolver
                  });

                case 44:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, null, [[31, 38]]);
        }));

        return function (_x13) {
          return _ref9.apply(this, arguments);
        };
      }(), __moduleMeta__$h);

      __varRecorder__$y.interactivelyFreezeWorld = interactivelyFreezeWorld;

      var interactivelyFreezePart = exports('a5', __varRecorder__$y["lively.freezer/index.js__define__"]("interactivelyFreezePart", "function", /*#__PURE__*/function () {
        var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(part) {
          var requester,
              options,
              publicationDir,
              publicationDirShell,
              worldSnap,
              frozen,
              li,
              _args8 = arguments;
          return regeneratorRuntime.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  requester = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : false;
                  _context8.next = 3;
                  return __varRecorder__$y.promptForFreezing(part, requester, "Freeze Part");

                case 3:
                  options = _context8.sent;

                  if (options) {
                    _context8.next = 6;
                    break;
                  }

                  return _context8.abrupt("return");

                case 6:
                  _context8.next = 8;
                  return resource(System.baseURL).join(options.location).asDirectory().ensureExistance();

                case 8:
                  publicationDir = _context8.sent;
                  _context8.t0 = resource;
                  _context8.next = 12;
                  return defaultDirectory();

                case 12:
                  _context8.t1 = _context8.sent;
                  _context8.t2 = options.location;
                  publicationDirShell = (0, _context8.t0)(_context8.t1).join("..").join(_context8.t2).withRelativePartsResolved().asDirectory();
                  part.changeMetaData("excludedPackages", options.excludedPackages, true, false);
                  part.changeMetaData("publishedLocation", options.location, true, false);

                  if (part.isWorld) {
                    worldSnap = __varRecorder__$y.clearWorldSnapshot(serializeMorph(part));
                  }

                  _context8.prev = 18;
                  _context8.next = 21;
                  return __varRecorder__$y.bundlePart(worldSnap || part, {
                    compress: true,
                    minify: options.minify,
                    useTerser: options.useTerser,
                    exclude: options.excludedPackages,
                    requester: false
                  });

                case 21:
                  frozen = _context8.sent;
                  frozen.part = part;
                  _context8.next = 28;
                  break;

                case 25:
                  _context8.prev = 25;
                  _context8.t3 = _context8["catch"](18);
                  throw _context8.t3;

                case 28:
                  li = open$1("Freezing Part", {
                    status: "Writing files..."
                  });
                  _context8.next = 31;
                  return writeFiles(frozen, li, {
                    dir: publicationDir,
                    shell: publicationDirShell,
                    resolver: BrowserResolver
                  });

                case 31:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, null, [[18, 25]]);
        }));

        return function (_x14) {
          return _ref10.apply(this, arguments);
        };
      }(), __moduleMeta__$h));

      __varRecorder__$y.interactivelyFreezePart = interactivelyFreezePart;

      var interactivelyFreezeModule = __varRecorder__$y["lively.freezer/index.js__define__"]("interactivelyFreezeModule", "function", /*#__PURE__*/function () {
        var _ref11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(moduleUrl, requester) {
          var source, _topLevelDeclsAndRefs, varDecls, excludedModuleNode, titleNode, excludedModules, title, options, publicationDir, publicationDirShell, frozen, li;

          return regeneratorRuntime.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  _context9.next = 2;
                  return resource(moduleUrl).read();

                case 2:
                  source = _context9.sent;
                  _topLevelDeclsAndRefs = topLevelDeclsAndRefs(parse$2(source)), varDecls = _topLevelDeclsAndRefs.varDecls;
                  excludedModuleNode = varDecls.find(function (decl) {
                    return Path("declarations.0.id.name").get(decl) === "EXCLUDED_MODULES";
                  });
                  titleNode = varDecls.find(function (decl) {
                    return Path("declarations.0.id.name").get(decl) === "TITLE";
                  });
                  excludedModules = __varRecorder__$y.DEFAULT_EXCLUDED_MODULES;
                  title = moduleUrl;

                  try {
                    excludedModules = eval(stringify(excludedModuleNode.declarations[0].init));
                    title = eval(stringify(titleNode.declarations[0].init));
                  } catch (err) {}

                  _context9.next = 11;
                  return __varRecorder__$y.promptForFreezing(moduleUrl, requester, "Freeze Module", excludedModules);

                case 11:
                  options = _context9.sent;

                  if (options) {
                    _context9.next = 14;
                    break;
                  }

                  return _context9.abrupt("return");

                case 14:
                  _context9.next = 16;
                  return resource(System.baseURL).join(options.location).asDirectory().ensureExistance();

                case 16:
                  publicationDir = _context9.sent;
                  _context9.t0 = resource;
                  _context9.next = 20;
                  return defaultDirectory();

                case 20:
                  _context9.t1 = _context9.sent;
                  _context9.t2 = options.location;
                  publicationDirShell = (0, _context9.t0)(_context9.t1).join("..").join(_context9.t2).withRelativePartsResolved().asDirectory();
                  _context9.prev = 23;
                  _context9.next = 26;
                  return __varRecorder__$y.bundleModule(moduleUrl, {
                    compress: true,
                    minify: options.minify,
                    useTerser: options.useTerser,
                    exclude: options.excludedPackages,
                    htmlConfig: {
                      title: title
                    },
                    requester: requester
                  });

                case 26:
                  frozen = _context9.sent;
                  _context9.next = 32;
                  break;

                case 29:
                  _context9.prev = 29;
                  _context9.t3 = _context9["catch"](23);
                  throw _context9.t3;

                case 32:
                  li = open$1("Freezing Module", {
                    status: "Writing files..."
                  });
                  _context9.next = 35;
                  return writeFiles(frozen, li, {
                    dir: publicationDir,
                    shell: publicationDirShell,
                    resolver: BrowserResolver
                  });

                case 35:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9, null, [[23, 29]]);
        }));

        return function (_x15, _x16) {
          return _ref11.apply(this, arguments);
        };
      }(), __moduleMeta__$h);

      __varRecorder__$y.interactivelyFreezeModule = interactivelyFreezeModule;
      __varRecorder__$y.DEFAULT_EXCLUDED_MODULES_PART = ["kld-intersections"];
      __varRecorder__$y.DEFAULT_EXCLUDED_MODULES_WORLD = ["lively.ast", "lively.vm", "lively-system-interface", "pouchdb", "pouchdb-adapter-mem", "rollup", "lively.halos"];
      __varRecorder__$y.DEFAULT_EXCLUDED_MODULES = ["lively.ast", "lively.vm", "lively-system-interface", "pouchdb", "pouchdb-adapter-mem", "rollup", "lively.halos", "lively.ide", "lively.freezer", "lively.modules", "lively.storage"];
      __varRecorder__$y.bundlePart = bundlePart;
      __varRecorder__$y.bundleModule = bundleModule;
      __varRecorder__$y.jspmCompile = jspmCompile;
      __varRecorder__$y.bootstrapLibrary = bootstrapLibrary;
      __varRecorder__$y.interactivelyFreezeWorld = interactivelyFreezeWorld;
      __varRecorder__$y.interactivelyFreezePart = interactivelyFreezePart;
      __varRecorder__$y.interactivelyFreezeModule = interactivelyFreezeModule;

      var index$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bundlePart: bundlePart,
        bundleModule: bundleModule,
        jspmCompile: jspmCompile,
        bootstrapLibrary: bootstrapLibrary,
        interactivelyFreezeWorld: interactivelyFreezeWorld,
        interactivelyFreezePart: interactivelyFreezePart,
        interactivelyFreezeModule: interactivelyFreezeModule
      });
      exports('ad', index$1);

      var __varRecorder__$x = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/browser/commands.js", __contextModule__);
      var __moduleMeta__$g = {
        pathInPackage: function pathInPackage() {
          return "./js/browser/commands.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var isMarkdown = __varRecorder__$x["lively.ide/js/browser/commands.js__define__"]("isMarkdown", "function", function (m) {
        return m.type === "md";
      }, __moduleMeta__$g);

      __varRecorder__$x.isMarkdown = isMarkdown;

      var browserCommands = __varRecorder__$x["lively.ide/js/browser/commands.js__define__"]("browserCommands", "function", function (browser) {
        var world = browser.world();

        function runTestsInModule(_x, _x2, _x3) {
          return _runTestsInModule.apply(this, arguments);
        }

        function _runTestsInModule() {
          _runTestsInModule = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(browser, moduleName, spec) {
            var runner;
            return regeneratorRuntime.wrap(function _callee18$(_context18) {
              while (1) {
                switch (_context18.prev = _context18.next) {
                  case 0:
                    runner = browser.get("test runner window");

                    if (runner) {
                      _context18.next = 5;
                      break;
                    }

                    _context18.next = 4;
                    return world.execCommand("open test runner");

                  case 4:
                    runner = _context18.sent;

                  case 5:
                    if (runner.minimized) {
                      runner.toggleMinimize();
                    }

                    runner.bringToFront();
                    runner = runner.getWindow().targetMorph;

                    if (runner.systemInterface !== browser.systemInterface) {
                      runner.systemInterface = browser.systemInterface;
                    }

                    return _context18.abrupt("return", spec ? runner[spec.type === "suite" ? "runSuite" : "runTest"](spec.fullTitle) : runner.runTestFile(moduleName));

                  case 10:
                  case "end":
                    return _context18.stop();
                }
              }
            }, _callee18);
          }));
          return _runTestsInModule.apply(this, arguments);
        }

        function runTestsInPackage(_x4, _x5) {
          return _runTestsInPackage.apply(this, arguments);
        }

        function _runTestsInPackage() {
          _runTestsInPackage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(browser, packageURL) {
            var runner;
            return regeneratorRuntime.wrap(function _callee19$(_context19) {
              while (1) {
                switch (_context19.prev = _context19.next) {
                  case 0:
                    runner = browser.get("test runner window");

                    if (runner) {
                      _context19.next = 5;
                      break;
                    }

                    _context19.next = 4;
                    return world.execCommand("open test runner");

                  case 4:
                    runner = _context19.sent;

                  case 5:
                    if (runner.minimized) {
                      runner.toggleMinimize();
                    }

                    runner = runner.getWindow().targetMorph;

                    if (runner.systemInterface !== browser.systemInterface) {
                      runner.systemInterface = browser.systemInterface;
                    }

                    return _context19.abrupt("return", runner.runTestsInPackage(packageURL));

                  case 9:
                  case "end":
                    return _context19.stop();
                }
              }
            }, _callee19);
          }));
          return _runTestsInPackage.apply(this, arguments);
        }

        return [{
          name: "focus list with selection",
          exec: function exec() {
            return browser.focusColumnView();
          }
        }, {
          name: "open new tab",
          exec: function () {
            var _exec = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var proceed;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (!browser.hasUnsavedChanges()) {
                        _context.next = 6;
                        break;
                      }

                      _context.next = 3;
                      return browser.warnForUnsavedChanges();

                    case 3:
                      proceed = _context.sent;

                      if (proceed) {
                        _context.next = 6;
                        break;
                      }

                      return _context.abrupt("return");

                    case 6:
                      browser.ui.tabs.addTab("New Browser Tab");

                    case 7:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));

            function exec() {
              return _exec.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "focus source editor",
          exec: function exec() {
            browser.focusSourceEditor();
            return true;
          }
        }, {
          name: "resize editor panel",
          exec: function exec() {
            var hresizer = browser.ui.hresizer;
            var ratio = hresizer.getRelativeDivide();
            var newRatio = ratio > 0.39 ? 0.15 : 0.4;
            hresizer.divideRelativeToParent(newRatio);
            return true;
          }
        }, {
          name: "browser history backward",
          exec: function exec(browser) {
            browser.historyBackward();
            return true;
          }
        }, {
          name: "browser history forward",
          exec: function exec(browser) {
            browser.historyForward();
            return true;
          }
        }, {
          name: "browser save",
          exec: function exec(browser) {
            return browser.save();
          }
        }, {
          name: "jump to codeentity",
          exec: function () {
            var _exec2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(browser) {
              var ed, codeEntities, currentIdx, items, _yield$browser$world$, _yield$browser$world$2, choice;

              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      ed = browser.editorPlugin.textMorph;

                      if (!browser.isTestModule(ed.textString)) {
                        _context2.next = 3;
                        break;
                      }

                      return _context2.abrupt("return", browser.execCommand("jump to test"));

                    case 3:
                      if (!__varRecorder__$x.isMarkdown(browser.selectedModule)) {
                        _context2.next = 5;
                        break;
                      }

                      return _context2.abrupt("return", ed.execCommand("[markdown] goto heading"));

                    case 5:
                      codeEntities = browser.renderedCodeEntities();
                      currentIdx = codeEntities.map(function (m) {
                        return m.name;
                      }).indexOf(browser.selectedCodeEntity && browser.selectedCodeEntity.name);
                      items = codeEntities.map(function (def) {
                        var name = def.name,
                            type = def.type,
                            parent = def.parent;
                        return {
                          isListItem: true,
                          label: ["".concat(parent ? parent.name + ">>" : "").concat(name), null, "".concat(type), {
                            fontSize: "70%",
                            textStyleClasses: ["annotation"]
                          }],
                          value: def
                        };
                      });
                      _context2.next = 10;
                      return browser.world().filterableListPrompt("Select item", items, {
                        preselect: currentIdx,
                        requester: browser,
                        historyId: "js-browser-codeentity-jump-hist"
                      });

                    case 10:
                      _yield$browser$world$ = _context2.sent;
                      _yield$browser$world$2 = _slicedToArray(_yield$browser$world$.selected, 1);
                      choice = _yield$browser$world$2[0];

                      if (choice) {
                        ed.saveMark();
                        browser.selectCodeEntity(choice);
                      }

                      return _context2.abrupt("return", true);

                    case 15:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }));

            function exec(_x6) {
              return _exec2.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "jump to test",
          exec: function () {
            var _exec3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(browser) {
              var m, ed, source, items, testsByFile, lines, currentRow, preselect, _yield$import, loadTestModuleAndExtractTestState, tests, _loop, i, _yield$browser$world$3, _yield$browser$world$4, choice;

              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      m = browser.selectedModule, ed = browser.editorPlugin.textMorph;

                      if (m) {
                        _context3.next = 3;
                        break;
                      }

                      return _context3.abrupt("return", true);

                    case 3:
                      source = ed.textString;
                      items = [];
                      testsByFile = [];
                      lines = source.split("\n");
                      currentRow = ed.cursorPosition.row;
                      preselect = 0;
                      _context3.next = 11;
                      return module.import('./mocha-es6-5c28146c.js');

                    case 11:
                      _yield$import = _context3.sent;
                      loadTestModuleAndExtractTestState = _yield$import.loadTestModuleAndExtractTestState;
                      _context3.next = 15;
                      return loadTestModuleAndExtractTestState(m.url, testsByFile);

                    case 15:
                      tests = testsByFile[0].tests.filter(function (ea) {
                        return ea.fullTitle;
                      });

                      _loop = function _loop(i) {
                        var value = tests[i];
                        var depth = value.depth,
                            fullTitle = value.fullTitle,
                            title = value.title,
                            type = value.type;
                        var fnName = type === "suite" ? "describe" : "it";
                        var row = value.row = lines.findIndex(function (line) {
                          return line.match(new RegExp("".concat(fnName, ".*\".*").concat(title, ".*\"")));
                        });
                        if (row <= currentRow) preselect = i;
                        items.push({
                          isListItem: true,
                          value: value,
                          label: ["".concat("\u2002".repeat(depth - 1)).concat(fullTitle), null, "line ".concat(row, " ").concat(type), {
                            fontSize: "70%",
                            textStyleClasses: ["annotation"]
                          }]
                        });
                      };

                      for (i = 0; i < tests.length; i++) {
                        _loop(i);
                      }

                      _context3.next = 20;
                      return browser.world().filterableListPrompt("tests of ".concat(m.nameInPackage), items, {
                        requester: browser,
                        preselect: preselect
                      });

                    case 20:
                      _yield$browser$world$3 = _context3.sent;
                      _yield$browser$world$4 = _slicedToArray(_yield$browser$world$3.selected, 1);
                      choice = _yield$browser$world$4[0];

                      if (choice) {
                        ed.saveMark();
                        ed.cursorPosition = {
                          row: choice.row,
                          column: 0
                        };
                        ed.execCommand("goto line start");
                        ed.centerRow(choice.row);
                      }

                      return _context3.abrupt("return", true);

                    case 25:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3);
            }));

            function exec(_x7) {
              return _exec3.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "browser history browse",
          exec: function exec(browser) {
            return browser.interactivelyBrowseHistory();
          }
        }, {
          name: "open code search",
          exec: function exec(browser) {
            return browser.world().execCommand("open code search", {
              browser: browser
            });
          }
        }, {
          name: "choose and browse package resources",
          exec: function exec(browser) {
            return browser.world().execCommand("choose and browse package resources", {
              browser: browser
            });
          }
        }, {
          name: "choose and browse module",
          exec: function exec(browser) {
            return browser.world().execCommand("choose and browse module", {
              browser: browser
            });
          }
        }, {
          name: "reload module",
          exec: function () {
            var _exec4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_) {
              var opts,
                  result,
                  _args4 = arguments;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      opts = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {
                        hard: false
                      };
                      _context4.next = 3;
                      return browser.reloadModule(opts.hard);

                    case 3:
                      result = _context4.sent;

                      if (result) {
                        _context4.next = 6;
                        break;
                      }

                      return _context4.abrupt("return", browser.world().inform("No module selected", {
                        requester: browser
                      }));

                    case 6:
                      if (!(result instanceof Error)) {
                        _context4.next = 8;
                        break;
                      }

                      return _context4.abrupt("return", browser.world().inform(result.message, {
                        requester: browser
                      }));

                    case 8:
                      browser.setStatusMessage("Reloaded ".concat(result.name));
                      return _context4.abrupt("return", true);

                    case 10:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            }));

            function exec(_x8) {
              return _exec4.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "load or add module",
          exec: function () {
            var _exec5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(browser) {
              var p,
                  m,
                  system,
                  mods;
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      p = browser.selectedPackage;
                      m = browser.selectedModule;
                      system = browser.systemInterface;
                      _context5.prev = 4;
                      _context5.next = 7;
                      return system.interactivelyAddModule(browser, m ? m.name : p ? p.address : null);

                    case 7:
                      mods = _context5.sent;
                      _context5.next = 14;
                      break;

                    case 10:
                      _context5.prev = 10;
                      _context5.t0 = _context5["catch"](4);
                      _context5.t0 === "Canceled" ? browser.setStatusMessage(_context5.t0) : browser.world().inform("Error while trying to load modules:\n".concat(_context5.t0.stack || _context5.t0), {
                        requester: browser
                      });
                      return _context5.abrupt("return");

                    case 14:
                      mods.forEach(function (_ref) {
                        var name = _ref.name,
                            error = _ref.error;
                        return error ? browser.showError("Error while loading module ".concat(name, ": ").concat(error.stack || error)) : browser.setStatusMessage("Module ".concat(name, " loaded"));
                      });
                      _context5.next = 17;
                      return browser.updateModuleList(p);

                    case 17:
                      mods.length && browser.selectModuleNamed(mods[0].name);
                      return _context5.abrupt("return", true);

                    case 19:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, null, [[4, 10]]);
            }));

            function exec(_x9) {
              return _exec5.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "create new folder",
          exec: function () {
            var _exec6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(browser) {
              var opts,
                  dir,
                  _args6 = arguments;
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
                      dir = opts.dir;
                      _context6.next = 4;
                      return browser.interactivelyCreateNewFolder(dir);

                    case 4:
                      return _context6.abrupt("return", _context6.sent);

                    case 5:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6);
            }));

            function exec(_x10) {
              return _exec6.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "create new module",
          exec: function () {
            var _exec7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(browser) {
              var opts,
                  dir,
                  type,
                  _args7 = arguments;
              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      opts = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};
                      dir = opts.dir, type = opts.type;
                      _context7.next = 4;
                      return browser.interactivelyAddNewModule(dir, type);

                    case 4:
                      return _context7.abrupt("return", _context7.sent);

                    case 5:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7);
            }));

            function exec(_x11) {
              return _exec7.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "remove selected entity",
          exec: function exec(browser) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var dir = opts.dir;
            return browser.interactivelyRemoveSelectedItem(dir);
          }
        }, {
          name: "remove module",
          exec: function () {
            var _exec8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(browser) {
              var opts,
                  p,
                  m,
                  system,
                  _args8 = arguments;
              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      opts = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};
                      p = browser.selectedPackage;
                      m = opts.mod || browser.selectedModule;
                      system = browser.systemInterface;

                      if (p) {
                        _context8.next = 6;
                        break;
                      }

                      return _context8.abrupt("return", browser.world().inform("No package selected", {
                        requester: browser
                      }));

                    case 6:
                      if (m) {
                        _context8.next = 8;
                        break;
                      }

                      return _context8.abrupt("return", browser.world().inform("No module selected", {
                        requester: browser
                      }));

                    case 8:
                      _context8.prev = 8;
                      _context8.next = 11;
                      return system.interactivelyRemoveModule(browser, m.url || m.name || m.id);

                    case 11:
                      _context8.next = 17;
                      break;

                    case 13:
                      _context8.prev = 13;
                      _context8.t0 = _context8["catch"](8);
                      if (_context8.t0 !== "Canceled") browser.showError("Error while trying to load modules:\n".concat(_context8.t0.stack || _context8.t0));
                      return _context8.abrupt("return", false);

                    case 17:
                      _context8.next = 19;
                      return browser.updateModuleList(m);

                    case 19:
                      return _context8.abrupt("return", true);

                    case 20:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, null, [[8, 13]]);
            }));

            function exec(_x12) {
              return _exec8.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "add package",
          exec: function () {
            var _exec9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(browser) {
              var what, pkg, system;
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      _context9.next = 2;
                      return browser.world().multipleChoicePrompt("Add Package", {
                        requester: browser,
                        choices: new Map([[[].concat(_toConsumableArray$1(Icon.textAttribute("cube")), [" Create New Package", {}]), "Create New Package"], [[].concat(_toConsumableArray$1(Icon.textAttribute("external-link-alt")), [" Load Existing Package", {}]), "Load Existing Package"]])
                      });

                    case 2:
                      what = _context9.sent;

                      if (!(!what || what === "Cancel")) {
                        _context9.next = 5;
                        break;
                      }

                      return _context9.abrupt("return", true);

                    case 5:
                      _context9.prev = 5;
                      system = browser.systemInterface;

                      if (!(what === "Create New Package")) {
                        _context9.next = 13;
                        break;
                      }

                      _context9.next = 10;
                      return system.interactivelyCreatePackage(browser);

                    case 10:
                      _context9.t0 = _context9.sent;
                      _context9.next = 16;
                      break;

                    case 13:
                      _context9.next = 15;
                      return system.interactivelyLoadPackage(browser, browser.selectedPackage ? browser.selectedPackage.address : null);

                    case 15:
                      _context9.t0 = _context9.sent;

                    case 16:
                      pkg = _context9.t0;
                      _context9.next = 26;
                      break;

                    case 19:
                      _context9.prev = 19;
                      _context9.t1 = _context9["catch"](5);

                      if (!(_context9.t1 === "Canceled")) {
                        _context9.next = 24;
                        break;
                      }

                      _context9.next = 25;
                      break;

                    case 24:
                      throw _context9.t1;

                    case 25:
                      return _context9.abrupt("return", true);

                    case 26:
                      _context9.next = 28;
                      return browser.selectPackageNamed(pkg.name, true);

                    case 28:
                      return _context9.abrupt("return", true);

                    case 29:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, null, [[5, 19]]);
            }));

            function exec(_x13) {
              return _exec9.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "remove package",
          exec: function () {
            var _exec10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(browser) {
              var p;
              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      p = browser.selectedPackage;

                      if (p) {
                        _context10.next = 4;
                        break;
                      }

                      browser.world().inform("No package selected", {
                        requester: browser
                      });
                      return _context10.abrupt("return", true);

                    case 4:
                      _context10.prev = 4;
                      _context10.next = 7;
                      return browser.systemInterface.interactivelyRemovePackage(browser, p.address);

                    case 7:
                      _context10.next = 14;
                      break;

                    case 9:
                      _context10.prev = 9;
                      _context10.t0 = _context10["catch"](4);

                      if (!(_context10.t0 !== "Canceled")) {
                        _context10.next = 13;
                        break;
                      }

                      throw _context10.t0;

                    case 13:
                      return _context10.abrupt("return", true);

                    case 14:
                      _context10.next = 16;
                      return browser.selectPackageNamed(null, true);

                    case 16:
                      return _context10.abrupt("return", true);

                    case 17:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, null, [[4, 9]]);
            }));

            function exec(_x14) {
              return _exec10.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "show imports and exports of package",
          exec: function () {
            var _exec11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(browser) {
              var system, packages, items, _yield$browser$world$5, selected;

              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      system = browser.systemInterface;
                      _context11.next = 3;
                      return system.getPackages();

                    case 3:
                      packages = _context11.sent;
                      items = packages.map(function (ea) {
                        return {
                          isListItem: true,
                          label: ["".concat(ea.name), null, "".concat(ea.url), {
                            paddingLeft: "5px",
                            fontSize: "70%",
                            textStyleClasses: ["annotation"]
                          }],
                          value: ea
                        };
                      });
                      _context11.next = 7;
                      return browser.world().filterableListPrompt("Choose package(s)", items, {
                        multiselect: true,
                        requester: browser,
                        historyId: "lively.ide.js-browser-choose-package-for-showing-export-imports-hist"
                      });

                    case 7:
                      _yield$browser$world$5 = _context11.sent;
                      selected = _yield$browser$world$5.selected;
                      _context11.next = 11;
                      return Promise.all(selected.map(function (ea) {
                        return system.showExportsAndImportsOf(ea.url);
                      }));

                    case 11:
                      return _context11.abrupt("return", true);

                    case 12:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11);
            }));

            function exec(_x15) {
              return _exec11.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "open browse snippet",
          exec: function exec(browser) {
            return browser.world().execCommand("open workspace", {
              content: browser.browseSnippetForSelection(),
              language: "javascript"
            });
          }
        }, {
          name: "open selected module in text editor",
          exec: function exec(browser) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var m = opts.module || browser.selectedModule;
            var c = opts.hasOwnProperty("codeEntity") ? opts.codeEntity : browser.selectedCodeEntity;
            if (isArray$2(c)) c = c[0];

            if (!m) {
              browser.world().inform("No module selected / specified!", {
                requester: browser,
                autoWidth: true
              });
              return true;
            }

            var lineNumber = c ? browser.editorPlugin.textMorph.indexToPosition(c.node.start).row : null;
            var url = m.url;
            if (url.startsWith("file://")) url = url.replace("file://", "");
            return browser.world().execCommand("open file", {
              url: url,
              lineNumber: lineNumber
            });
          }
        }, {
          name: "run all tests in package",
          exec: function () {
            var _exec12 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(browser) {
              var p, results;
              return regeneratorRuntime.wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      p = browser.selectedPackage;

                      if (p) {
                        _context12.next = 3;
                        break;
                      }

                      return _context12.abrupt("return", browser.world().inform("No package selected", {
                        requester: browser
                      }));

                    case 3:
                      _context12.next = 5;
                      return runTestsInPackage(browser, p.name);

                    case 5:
                      results = _context12.sent;
                      browser.focus();
                      return _context12.abrupt("return", results);

                    case 8:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12);
            }));

            function exec(_x16) {
              return _exec12.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "run all tests in module",
          exec: function () {
            var _exec13 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(browser) {
              var m, results;
              return regeneratorRuntime.wrap(function _callee13$(_context13) {
                while (1) {
                  switch (_context13.prev = _context13.next) {
                    case 0:
                      m = browser.selectedModule;

                      if (m) {
                        _context13.next = 3;
                        break;
                      }

                      return _context13.abrupt("return", browser.world().inform("No module selected", {
                        requester: browser
                      }));

                    case 3:
                      _context13.next = 5;
                      return runTestsInModule(browser, m.url, null);

                    case 5:
                      results = _context13.sent;
                      browser.focus();
                      return _context13.abrupt("return", results);

                    case 8:
                    case "end":
                      return _context13.stop();
                  }
                }
              }, _callee13);
            }));

            function exec(_x17) {
              return _exec13.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "run tests at point",
          exec: function () {
            var _exec14 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(browser) {
              var m, ed, _yield$import2, extractTestDescriptors, testDescriptors, spec, results;

              return regeneratorRuntime.wrap(function _callee14$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      m = browser.selectedModule;

                      if (m) {
                        _context14.next = 3;
                        break;
                      }

                      return _context14.abrupt("return", browser.world().inform("No module selected", {
                        requester: browser
                      }));

                    case 3:
                      ed = browser.get("sourceEditor");
                      _context14.next = 6;
                      return module.import('./test-analysis-fc4e44f9.js');

                    case 6:
                      _yield$import2 = _context14.sent;
                      extractTestDescriptors = _yield$import2.extractTestDescriptors;
                      _context14.next = 10;
                      return extractTestDescriptors(ed.textString, ed.document.positionToIndex(ed.cursorPosition));

                    case 10:
                      testDescriptors = _context14.sent;

                      if (!(!testDescriptors || !testDescriptors.length)) {
                        _context14.next = 13;
                        break;
                      }

                      return _context14.abrupt("return", browser.world().inform("No test at " + JSON.stringify(ed.cursorPosition), {
                        requester: browser
                      }));

                    case 13:
                      spec = {
                        fullTitle: pluck(testDescriptors, "title").join(" "),
                        type: last$2(testDescriptors).type,
                        file: m.name
                      };
                      _context14.next = 16;
                      return runTestsInModule(browser, m.name, spec);

                    case 16:
                      results = _context14.sent;
                      browser.focus();
                      return _context14.abrupt("return", results);

                    case 19:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee14);
            }));

            function exec(_x18) {
              return _exec14.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "run setup code of tests (before and beforeEach)",
          exec: function () {
            var _exec15 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(browser) {
              var args,
                  m,
                  ed,
                  _yield$import3,
                  extractTestDescriptors,
                  testDescriptors,
                  what,
                  prop,
                  nCalls,
                  beforeCode,
                  _args15 = arguments;

              return regeneratorRuntime.wrap(function _callee15$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      args = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : {
                        what: "setup"
                      };
                      m = browser.selectedModule;

                      if (m) {
                        _context15.next = 4;
                        break;
                      }

                      return _context15.abrupt("return", browser.world().inform("No module selected", {
                        requester: browser
                      }));

                    case 4:
                      ed = browser.get("sourceEditor");
                      _context15.next = 7;
                      return module.import('./test-analysis-fc4e44f9.js');

                    case 7:
                      _yield$import3 = _context15.sent;
                      extractTestDescriptors = _yield$import3.extractTestDescriptors;
                      _context15.next = 11;
                      return extractTestDescriptors(ed.textString, ed.document.positionToIndex(ed.cursorPosition));

                    case 11:
                      testDescriptors = _context15.sent;

                      if (!(!testDescriptors || !testDescriptors.length)) {
                        _context15.next = 14;
                        break;
                      }

                      return _context15.abrupt("return", browser.world().inform("No test at " + JSON.stringify(ed.cursorPosition), {
                        requester: browser
                      }));

                    case 14:
                      what = args && args.what || "setup";
                      prop = what === "setup" ? "setupCalls" : "teardownCalls";
                      nCalls = 0;
                      beforeCode = testDescriptors.flatMap(function (descr) {
                        return descr[prop].map(function (beforeFn, i) {
                          nCalls++;
                          return "await ((".concat(lively.ast.stringify(beforeFn), ")());");
                        });
                      }).join("\n");
                      _context15.prev = 18;
                      _context15.next = 21;
                      return browser.systemInterface.runEval(beforeCode, Object.assign({}, ed.evalEnvironment));

                    case 21:
                      browser.setStatusMessage("Executed ".concat(nCalls, " test ").concat(what, " functions"));
                      _context15.next = 27;
                      break;

                    case 24:
                      _context15.prev = 24;
                      _context15.t0 = _context15["catch"](18);
                      browser.showError(new Error("Error when running ".concat(what, " calls of test:\n").concat(_context15.t0.stack)));

                    case 27:
                      return _context15.abrupt("return", true);

                    case 28:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee15, null, [[18, 24]]);
            }));

            function exec(_x19) {
              return _exec15.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "run teardown code of tests (after and afterEach)",
          exec: function () {
            var _exec16 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(browser) {
              return regeneratorRuntime.wrap(function _callee16$(_context16) {
                while (1) {
                  switch (_context16.prev = _context16.next) {
                    case 0:
                      return _context16.abrupt("return", browser.execCommand("run setup code of tests (before and beforeEach)", {
                        what: "teardown"
                      }));

                    case 1:
                    case "end":
                      return _context16.stop();
                  }
                }
              }, _callee16);
            }));

            function exec(_x20) {
              return _exec16.apply(this, arguments);
            }

            return exec;
          }()
        }, {
          name: "freeze selected module",
          doc: "Enters the freeze prompt which allows the user to configure and execute a build for the currently selected module. The resulting bundle will execute the specified main() method in the current module and pass the default world object as a parameter. This allows us to bundle apps in lively without snapshots.",
          exec: function () {
            var _exec17 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(browser) {
              return regeneratorRuntime.wrap(function _callee17$(_context17) {
                while (1) {
                  switch (_context17.prev = _context17.next) {
                    case 0:
                      interactivelyFreezeModule(browser.selectedModule.url, browser);

                    case 1:
                    case "end":
                      return _context17.stop();
                  }
                }
              }, _callee17);
            }));

            function exec(_x21) {
              return _exec17.apply(this, arguments);
            }

            return exec;
          }()
        }];
      }, __moduleMeta__$g);

      __varRecorder__$x.browserCommands = browserCommands;
      __varRecorder__$x["default"] = browserCommands;

      function Diff() {
      }
      Diff.prototype = {
        diff: function diff(oldString, newString) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var callback = options.callback;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          this.options = options;
          var self = this;
          function done(value) {
            if (callback) {
              setTimeout(function () {
                callback(undefined, value);
              }, 0);
              return true;
            } else {
              return value;
            }
          }
          oldString = this.castInput(oldString);
          newString = this.castInput(newString);
          oldString = this.removeEmpty(this.tokenize(oldString));
          newString = this.removeEmpty(this.tokenize(newString));
          var newLen = newString.length, oldLen = oldString.length;
          var editLength = 1;
          var maxEditLength = newLen + oldLen;
          var bestPath = [{
              newPos: -1,
              components: []
            }];
          var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
          if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
            return done([{
                value: this.join(newString),
                count: newString.length
              }]);
          }
          function execEditLength() {
            for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
              var basePath = void 0;
              var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
              if (addPath) {
                bestPath[diagonalPath - 1] = undefined;
              }
              var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
              if (!canAdd && !canRemove) {
                bestPath[diagonalPath] = undefined;
                continue;
              }
              if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
                basePath = clonePath(removePath);
                self.pushComponent(basePath.components, undefined, true);
              } else {
                basePath = addPath;
                basePath.newPos++;
                self.pushComponent(basePath.components, true, undefined);
              }
              _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
              if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
                return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
              } else {
                bestPath[diagonalPath] = basePath;
              }
            }
            editLength++;
          }
          if (callback) {
            (function exec() {
              setTimeout(function () {
                if (editLength > maxEditLength) {
                  return callback();
                }
                if (!execEditLength()) {
                  exec();
                }
              }, 0);
            }());
          } else {
            while (editLength <= maxEditLength) {
              var ret = execEditLength();
              if (ret) {
                return ret;
              }
            }
          }
        },
        pushComponent: function pushComponent(components, added, removed) {
          var last = components[components.length - 1];
          if (last && last.added === added && last.removed === removed) {
            components[components.length - 1] = {
              count: last.count + 1,
              added: added,
              removed: removed
            };
          } else {
            components.push({
              count: 1,
              added: added,
              removed: removed
            });
          }
        },
        extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
          var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
          while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
            newPos++;
            oldPos++;
            commonCount++;
          }
          if (commonCount) {
            basePath.components.push({ count: commonCount });
          }
          basePath.newPos = newPos;
          return oldPos;
        },
        equals: function equals(left, right) {
          if (this.options.comparator) {
            return this.options.comparator(left, right);
          } else {
            return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
          }
        },
        removeEmpty: function removeEmpty(array) {
          var ret = [];
          for (var i = 0; i < array.length; i++) {
            if (array[i]) {
              ret.push(array[i]);
            }
          }
          return ret;
        },
        castInput: function castInput(value) {
          return value;
        },
        tokenize: function tokenize(value) {
          return value.split("");
        },
        join: function join(chars) {
          return chars.join("");
        }
      };
      function buildValues(diff, components, newString, oldString, useLongestToken) {
        var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
        for (; componentPos < componentLen; componentPos++) {
          var component = components[componentPos];
          if (!component.removed) {
            if (!component.added && useLongestToken) {
              var value = newString.slice(newPos, newPos + component.count);
              value = value.map(function (value, i) {
                var oldValue = oldString[oldPos + i];
                return oldValue.length > value.length ? oldValue : value;
              });
              component.value = diff.join(value);
            } else {
              component.value = diff.join(newString.slice(newPos, newPos + component.count));
            }
            newPos += component.count;
            if (!component.added) {
              oldPos += component.count;
            }
          } else {
            component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
            oldPos += component.count;
            if (componentPos && components[componentPos - 1].added) {
              var tmp = components[componentPos - 1];
              components[componentPos - 1] = components[componentPos];
              components[componentPos] = tmp;
            }
          }
        }
        var lastComponent = components[componentLen - 1];
        if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
          components[componentLen - 2].value += lastComponent.value;
          components.pop();
        }
        return components;
      }
      function clonePath(path) {
        return {
          newPos: path.newPos,
          components: path.components.slice(0)
        };
      }
      var characterDiff = new Diff();
      function diffChars(oldStr, newStr, options) {
        return characterDiff.diff(oldStr, newStr, options);
      }
      function generateOptions(options, defaults) {
        if (typeof options === "function") {
          defaults.callback = options;
        } else if (options) {
          for (var name in options) {
            if (options.hasOwnProperty(name)) {
              defaults[name] = options[name];
            }
          }
        }
        return defaults;
      }
      var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
      var reWhitespace = /\S/;
      var wordDiff = new Diff();
      wordDiff.equals = function (left, right) {
        if (this.options.ignoreCase) {
          left = left.toLowerCase();
          right = right.toLowerCase();
        }
        return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
      };
      wordDiff.tokenize = function (value) {
        var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
        for (var i = 0; i < tokens.length - 1; i++) {
          if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
            tokens[i] += tokens[i + 2];
            tokens.splice(i + 1, 2);
            i--;
          }
        }
        return tokens;
      };
      function diffWords(oldStr, newStr, options) {
        options = generateOptions(options, { ignoreWhitespace: true });
        return wordDiff.diff(oldStr, newStr, options);
      }
      function diffWordsWithSpace(oldStr, newStr, options) {
        return wordDiff.diff(oldStr, newStr, options);
      }
      var lineDiff = new Diff();
      lineDiff.tokenize = function (value) {
        var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
        if (!linesAndNewlines[linesAndNewlines.length - 1]) {
          linesAndNewlines.pop();
        }
        for (var i = 0; i < linesAndNewlines.length; i++) {
          var line = linesAndNewlines[i];
          if (i % 2 && !this.options.newlineIsToken) {
            retLines[retLines.length - 1] += line;
          } else {
            if (this.options.ignoreWhitespace) {
              line = line.trim();
            }
            retLines.push(line);
          }
        }
        return retLines;
      };
      function diffLines(oldStr, newStr, callback) {
        return lineDiff.diff(oldStr, newStr, callback);
      }
      function diffTrimmedLines(oldStr, newStr, callback) {
        var options = generateOptions(callback, { ignoreWhitespace: true });
        return lineDiff.diff(oldStr, newStr, options);
      }
      var sentenceDiff = new Diff();
      sentenceDiff.tokenize = function (value) {
        return value.split(/(\S.+?[.!?])(?=\s+|$)/);
      };
      function diffSentences(oldStr, newStr, callback) {
        return sentenceDiff.diff(oldStr, newStr, callback);
      }
      var cssDiff = new Diff();
      cssDiff.tokenize = function (value) {
        return value.split(/([{}:;,]|\s+)/);
      };
      function diffCss(oldStr, newStr, callback) {
        return cssDiff.diff(oldStr, newStr, callback);
      }
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function (obj) {
            return typeof obj;
          };
        } else {
          _typeof = function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }
        return _typeof(obj);
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray(arr);
      }
      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
          return Array.from(iter);
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++)
          arr2[i] = arr[i];
        return arr2;
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var objectPrototypeToString = Object.prototype.toString;
      var jsonDiff = new Diff();
      jsonDiff.useLongestToken = true;
      jsonDiff.tokenize = lineDiff.tokenize;
      jsonDiff.castInput = function (value) {
        var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
            return typeof v === "undefined" ? undefinedReplacement : v;
          } : _this$options$stringi;
        return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
      };
      jsonDiff.equals = function (left, right) {
        return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
      };
      function diffJson(oldObj, newObj, options) {
        return jsonDiff.diff(oldObj, newObj, options);
      }
      function canonicalize(obj, stack, replacementStack, replacer, key) {
        stack = stack || [];
        replacementStack = replacementStack || [];
        if (replacer) {
          obj = replacer(key, obj);
        }
        var i;
        for (i = 0; i < stack.length; i += 1) {
          if (stack[i] === obj) {
            return replacementStack[i];
          }
        }
        var canonicalizedObj;
        if ("[object Array]" === objectPrototypeToString.call(obj)) {
          stack.push(obj);
          canonicalizedObj = new Array(obj.length);
          replacementStack.push(canonicalizedObj);
          for (i = 0; i < obj.length; i += 1) {
            canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
          }
          stack.pop();
          replacementStack.pop();
          return canonicalizedObj;
        }
        if (obj && obj.toJSON) {
          obj = obj.toJSON();
        }
        if (_typeof(obj) === "object" && obj !== null) {
          stack.push(obj);
          canonicalizedObj = {};
          replacementStack.push(canonicalizedObj);
          var sortedKeys = [], _key;
          for (_key in obj) {
            if (obj.hasOwnProperty(_key)) {
              sortedKeys.push(_key);
            }
          }
          sortedKeys.sort();
          for (i = 0; i < sortedKeys.length; i += 1) {
            _key = sortedKeys[i];
            canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
          }
          stack.pop();
          replacementStack.pop();
        } else {
          canonicalizedObj = obj;
        }
        return canonicalizedObj;
      }
      var arrayDiff = new Diff();
      arrayDiff.tokenize = function (value) {
        return value.slice();
      };
      arrayDiff.join = arrayDiff.removeEmpty = function (value) {
        return value;
      };
      function diffArrays(oldArr, newArr, callback) {
        return arrayDiff.diff(oldArr, newArr, callback);
      }
      function parsePatch(uniDiff) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/), delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [], list = [], i = 0;
        function parseIndex() {
          var index = {};
          list.push(index);
          while (i < diffstr.length) {
            var line = diffstr[i];
            if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
              break;
            }
            var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
            if (header) {
              index.index = header[1];
            }
            i++;
          }
          parseFileHeader(index);
          parseFileHeader(index);
          index.hunks = [];
          while (i < diffstr.length) {
            var _line = diffstr[i];
            if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
              break;
            } else if (/^@@/.test(_line)) {
              index.hunks.push(parseHunk());
            } else if (_line && options.strict) {
              throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(_line));
            } else {
              i++;
            }
          }
        }
        function parseFileHeader(index) {
          var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);
          if (fileHeader) {
            var keyPrefix = fileHeader[1] === "---" ? "old" : "new";
            var data = fileHeader[2].split("\t", 2);
            var fileName = data[0].replace(/\\\\/g, "\\");
            if (/^".*"$/.test(fileName)) {
              fileName = fileName.substr(1, fileName.length - 2);
            }
            index[keyPrefix + "FileName"] = fileName;
            index[keyPrefix + "Header"] = (data[1] || "").trim();
            i++;
          }
        }
        function parseHunk() {
          var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
          var hunk = {
            oldStart: +chunkHeader[1],
            oldLines: typeof chunkHeader[2] === "undefined" ? 1 : +chunkHeader[2],
            newStart: +chunkHeader[3],
            newLines: typeof chunkHeader[4] === "undefined" ? 1 : +chunkHeader[4],
            lines: [],
            linedelimiters: []
          };
          if (hunk.oldLines === 0) {
            hunk.oldStart += 1;
          }
          if (hunk.newLines === 0) {
            hunk.newStart += 1;
          }
          var addCount = 0, removeCount = 0;
          for (; i < diffstr.length; i++) {
            if (diffstr[i].indexOf("--- ") === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf("+++ ") === 0 && diffstr[i + 2].indexOf("@@") === 0) {
              break;
            }
            var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? " " : diffstr[i][0];
            if (operation === "+" || operation === "-" || operation === " " || operation === "\\") {
              hunk.lines.push(diffstr[i]);
              hunk.linedelimiters.push(delimiters[i] || "\n");
              if (operation === "+") {
                addCount++;
              } else if (operation === "-") {
                removeCount++;
              } else if (operation === " ") {
                addCount++;
                removeCount++;
              }
            } else {
              break;
            }
          }
          if (!addCount && hunk.newLines === 1) {
            hunk.newLines = 0;
          }
          if (!removeCount && hunk.oldLines === 1) {
            hunk.oldLines = 0;
          }
          if (options.strict) {
            if (addCount !== hunk.newLines) {
              throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
            }
            if (removeCount !== hunk.oldLines) {
              throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1));
            }
          }
          return hunk;
        }
        while (i < diffstr.length) {
          parseIndex();
        }
        return list;
      }
      function distanceIterator(start, minLine, maxLine) {
        var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
        return function iterator() {
          if (wantForward && !forwardExhausted) {
            if (backwardExhausted) {
              localOffset++;
            } else {
              wantForward = false;
            }
            if (start + localOffset <= maxLine) {
              return localOffset;
            }
            forwardExhausted = true;
          }
          if (!backwardExhausted) {
            if (!forwardExhausted) {
              wantForward = true;
            }
            if (minLine <= start - localOffset) {
              return -localOffset++;
            }
            backwardExhausted = true;
            return iterator();
          }
        };
      }
      function applyPatch(source, uniDiff) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        if (typeof uniDiff === "string") {
          uniDiff = parsePatch(uniDiff);
        }
        if (Array.isArray(uniDiff)) {
          if (uniDiff.length > 1) {
            throw new Error("applyPatch only works with a single input.");
          }
          uniDiff = uniDiff[0];
        }
        var lines = source.split(/\r\n|[\n\v\f\r\x85]/), delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {
            return line === patchContent;
          }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;
        function hunkFits(hunk, toPos) {
          for (var j = 0; j < hunk.lines.length; j++) {
            var line = hunk.lines[j], operation = line.length > 0 ? line[0] : " ", content = line.length > 0 ? line.substr(1) : line;
            if (operation === " " || operation === "-") {
              if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
                errorCount++;
                if (errorCount > fuzzFactor) {
                  return false;
                }
              }
              toPos++;
            }
          }
          return true;
        }
        for (var i = 0; i < hunks.length; i++) {
          var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1;
          var iterator = distanceIterator(toPos, minLine, maxLine);
          for (; localOffset !== undefined; localOffset = iterator()) {
            if (hunkFits(hunk, toPos + localOffset)) {
              hunk.offset = offset += localOffset;
              break;
            }
          }
          if (localOffset === undefined) {
            return false;
          }
          minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
        }
        var diffOffset = 0;
        for (var _i = 0; _i < hunks.length; _i++) {
          var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
          diffOffset += _hunk.newLines - _hunk.oldLines;
          for (var j = 0; j < _hunk.lines.length; j++) {
            var line = _hunk.lines[j], operation = line.length > 0 ? line[0] : " ", content = line.length > 0 ? line.substr(1) : line, delimiter = _hunk.linedelimiters[j];
            if (operation === " ") {
              _toPos++;
            } else if (operation === "-") {
              lines.splice(_toPos, 1);
              delimiters.splice(_toPos, 1);
            } else if (operation === "+") {
              lines.splice(_toPos, 0, content);
              delimiters.splice(_toPos, 0, delimiter);
              _toPos++;
            } else if (operation === "\\") {
              var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
              if (previousOperation === "+") {
                removeEOFNL = true;
              } else if (previousOperation === "-") {
                addEOFNL = true;
              }
            }
          }
        }
        if (removeEOFNL) {
          while (!lines[lines.length - 1]) {
            lines.pop();
            delimiters.pop();
          }
        } else if (addEOFNL) {
          lines.push("");
          delimiters.push("\n");
        }
        for (var _k = 0; _k < lines.length - 1; _k++) {
          lines[_k] = lines[_k] + delimiters[_k];
        }
        return lines.join("");
      }
      function applyPatches(uniDiff, options) {
        if (typeof uniDiff === "string") {
          uniDiff = parsePatch(uniDiff);
        }
        var currentIndex = 0;
        function processIndex() {
          var index = uniDiff[currentIndex++];
          if (!index) {
            return options.complete();
          }
          options.loadFile(index, function (err, data) {
            if (err) {
              return options.complete(err);
            }
            var updatedContent = applyPatch(data, index, options);
            options.patched(index, updatedContent, function (err) {
              if (err) {
                return options.complete(err);
              }
              processIndex();
            });
          });
        }
        processIndex();
      }
      function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        if (!options) {
          options = {};
        }
        if (typeof options.context === "undefined") {
          options.context = 4;
        }
        var diff = diffLines(oldStr, newStr, options);
        diff.push({
          value: "",
          lines: []
        });
        function contextLines(lines) {
          return lines.map(function (entry) {
            return " " + entry;
          });
        }
        var hunks = [];
        var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
        var _loop = function _loop(i) {
          var current = diff[i], lines = current.lines || current.value.replace(/\n$/, "").split("\n");
          current.lines = lines;
          if (current.added || current.removed) {
            var _curRange;
            if (!oldRangeStart) {
              var prev = diff[i - 1];
              oldRangeStart = oldLine;
              newRangeStart = newLine;
              if (prev) {
                curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
                oldRangeStart -= curRange.length;
                newRangeStart -= curRange.length;
              }
            }
            (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {
              return (current.added ? "+" : "-") + entry;
            })));
            if (current.added) {
              newLine += lines.length;
            } else {
              oldLine += lines.length;
            }
          } else {
            if (oldRangeStart) {
              if (lines.length <= options.context * 2 && i < diff.length - 2) {
                var _curRange2;
                (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
              } else {
                var _curRange3;
                var contextSize = Math.min(lines.length, options.context);
                (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
                var hunk = {
                  oldStart: oldRangeStart,
                  oldLines: oldLine - oldRangeStart + contextSize,
                  newStart: newRangeStart,
                  newLines: newLine - newRangeStart + contextSize,
                  lines: curRange
                };
                if (i >= diff.length - 2 && lines.length <= options.context) {
                  var oldEOFNewline = /\n$/.test(oldStr);
                  var newEOFNewline = /\n$/.test(newStr);
                  var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
                  if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {
                    curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file");
                  }
                  if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                    curRange.push("\\ No newline at end of file");
                  }
                }
                hunks.push(hunk);
                oldRangeStart = 0;
                newRangeStart = 0;
                curRange = [];
              }
            }
            oldLine += lines.length;
            newLine += lines.length;
          }
        };
        for (var i = 0; i < diff.length; i++) {
          _loop(i);
        }
        return {
          oldFileName: oldFileName,
          newFileName: newFileName,
          oldHeader: oldHeader,
          newHeader: newHeader,
          hunks: hunks
        };
      }
      function formatPatch(diff) {
        var ret = [];
        if (diff.oldFileName == diff.newFileName) {
          ret.push("Index: " + diff.oldFileName);
        }
        ret.push("===================================================================");
        ret.push("--- " + diff.oldFileName + (typeof diff.oldHeader === "undefined" ? "" : "\t" + diff.oldHeader));
        ret.push("+++ " + diff.newFileName + (typeof diff.newHeader === "undefined" ? "" : "\t" + diff.newHeader));
        for (var i = 0; i < diff.hunks.length; i++) {
          var hunk = diff.hunks[i];
          if (hunk.oldLines === 0) {
            hunk.oldStart -= 1;
          }
          if (hunk.newLines === 0) {
            hunk.newStart -= 1;
          }
          ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
          ret.push.apply(ret, hunk.lines);
        }
        return ret.join("\n") + "\n";
      }
      function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
      }
      function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
        return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
      }
      function arrayEqual(a, b) {
        if (a.length !== b.length) {
          return false;
        }
        return arrayStartsWith(a, b);
      }
      function arrayStartsWith(array, start) {
        if (start.length > array.length) {
          return false;
        }
        for (var i = 0; i < start.length; i++) {
          if (start[i] !== array[i]) {
            return false;
          }
        }
        return true;
      }
      function calcLineCount(hunk) {
        var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;
        if (oldLines !== undefined) {
          hunk.oldLines = oldLines;
        } else {
          delete hunk.oldLines;
        }
        if (newLines !== undefined) {
          hunk.newLines = newLines;
        } else {
          delete hunk.newLines;
        }
      }
      function merge(mine, theirs, base) {
        mine = loadPatch(mine, base);
        theirs = loadPatch(theirs, base);
        var ret = {};
        if (mine.index || theirs.index) {
          ret.index = mine.index || theirs.index;
        }
        if (mine.newFileName || theirs.newFileName) {
          if (!fileNameChanged(mine)) {
            ret.oldFileName = theirs.oldFileName || mine.oldFileName;
            ret.newFileName = theirs.newFileName || mine.newFileName;
            ret.oldHeader = theirs.oldHeader || mine.oldHeader;
            ret.newHeader = theirs.newHeader || mine.newHeader;
          } else if (!fileNameChanged(theirs)) {
            ret.oldFileName = mine.oldFileName;
            ret.newFileName = mine.newFileName;
            ret.oldHeader = mine.oldHeader;
            ret.newHeader = mine.newHeader;
          } else {
            ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
            ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
            ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
            ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
          }
        }
        ret.hunks = [];
        var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;
        while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
          var mineCurrent = mine.hunks[mineIndex] || { oldStart: Infinity }, theirsCurrent = theirs.hunks[theirsIndex] || { oldStart: Infinity };
          if (hunkBefore(mineCurrent, theirsCurrent)) {
            ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
            mineIndex++;
            theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
          } else if (hunkBefore(theirsCurrent, mineCurrent)) {
            ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
            theirsIndex++;
            mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
          } else {
            var mergedHunk = {
              oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
              oldLines: 0,
              newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
              newLines: 0,
              lines: []
            };
            mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
            theirsIndex++;
            mineIndex++;
            ret.hunks.push(mergedHunk);
          }
        }
        return ret;
      }
      function loadPatch(param, base) {
        if (typeof param === "string") {
          if (/^@@/m.test(param) || /^Index:/m.test(param)) {
            return parsePatch(param)[0];
          }
          if (!base) {
            throw new Error("Must provide a base reference or pass in a patch");
          }
          return structuredPatch(undefined, undefined, base, param);
        }
        return param;
      }
      function fileNameChanged(patch) {
        return patch.newFileName && patch.newFileName !== patch.oldFileName;
      }
      function selectField(index, mine, theirs) {
        if (mine === theirs) {
          return mine;
        } else {
          index.conflict = true;
          return {
            mine: mine,
            theirs: theirs
          };
        }
      }
      function hunkBefore(test, check) {
        return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
      }
      function cloneHunk(hunk, offset) {
        return {
          oldStart: hunk.oldStart,
          oldLines: hunk.oldLines,
          newStart: hunk.newStart + offset,
          newLines: hunk.newLines,
          lines: hunk.lines
        };
      }
      function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
        var mine = {
            offset: mineOffset,
            lines: mineLines,
            index: 0
          }, their = {
            offset: theirOffset,
            lines: theirLines,
            index: 0
          };
        insertLeading(hunk, mine, their);
        insertLeading(hunk, their, mine);
        while (mine.index < mine.lines.length && their.index < their.lines.length) {
          var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];
          if ((mineCurrent[0] === "-" || mineCurrent[0] === "+") && (theirCurrent[0] === "-" || theirCurrent[0] === "+")) {
            mutualChange(hunk, mine, their);
          } else if (mineCurrent[0] === "+" && theirCurrent[0] === " ") {
            var _hunk$lines;
            (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
          } else if (theirCurrent[0] === "+" && mineCurrent[0] === " ") {
            var _hunk$lines2;
            (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
          } else if (mineCurrent[0] === "-" && theirCurrent[0] === " ") {
            removal(hunk, mine, their);
          } else if (theirCurrent[0] === "-" && mineCurrent[0] === " ") {
            removal(hunk, their, mine, true);
          } else if (mineCurrent === theirCurrent) {
            hunk.lines.push(mineCurrent);
            mine.index++;
            their.index++;
          } else {
            conflict(hunk, collectChange(mine), collectChange(their));
          }
        }
        insertTrailing(hunk, mine);
        insertTrailing(hunk, their);
        calcLineCount(hunk);
      }
      function mutualChange(hunk, mine, their) {
        var myChanges = collectChange(mine), theirChanges = collectChange(their);
        if (allRemoves(myChanges) && allRemoves(theirChanges)) {
          if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
            var _hunk$lines3;
            (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));
            return;
          } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
            var _hunk$lines4;
            (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));
            return;
          }
        } else if (arrayEqual(myChanges, theirChanges)) {
          var _hunk$lines5;
          (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));
          return;
        }
        conflict(hunk, myChanges, theirChanges);
      }
      function removal(hunk, mine, their, swap) {
        var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);
        if (theirChanges.merged) {
          var _hunk$lines6;
          (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
        } else {
          conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
        }
      }
      function conflict(hunk, mine, their) {
        hunk.conflict = true;
        hunk.lines.push({
          conflict: true,
          mine: mine,
          theirs: their
        });
      }
      function insertLeading(hunk, insert, their) {
        while (insert.offset < their.offset && insert.index < insert.lines.length) {
          var line = insert.lines[insert.index++];
          hunk.lines.push(line);
          insert.offset++;
        }
      }
      function insertTrailing(hunk, insert) {
        while (insert.index < insert.lines.length) {
          var line = insert.lines[insert.index++];
          hunk.lines.push(line);
        }
      }
      function collectChange(state) {
        var ret = [], operation = state.lines[state.index][0];
        while (state.index < state.lines.length) {
          var line = state.lines[state.index];
          if (operation === "-" && line[0] === "+") {
            operation = "+";
          }
          if (operation === line[0]) {
            ret.push(line);
            state.index++;
          } else {
            break;
          }
        }
        return ret;
      }
      function collectContext(state, matchChanges) {
        var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;
        while (matchIndex < matchChanges.length && state.index < state.lines.length) {
          var change = state.lines[state.index], match = matchChanges[matchIndex];
          if (match[0] === "+") {
            break;
          }
          contextChanges = contextChanges || change[0] !== " ";
          merged.push(match);
          matchIndex++;
          if (change[0] === "+") {
            conflicted = true;
            while (change[0] === "+") {
              changes.push(change);
              change = state.lines[++state.index];
            }
          }
          if (match.substr(1) === change.substr(1)) {
            changes.push(change);
            state.index++;
          } else {
            conflicted = true;
          }
        }
        if ((matchChanges[matchIndex] || "")[0] === "+" && contextChanges) {
          conflicted = true;
        }
        if (conflicted) {
          return changes;
        }
        while (matchIndex < matchChanges.length) {
          merged.push(matchChanges[matchIndex++]);
        }
        return {
          merged: merged,
          changes: changes
        };
      }
      function allRemoves(changes) {
        return changes.reduce(function (prev, change) {
          return prev && change[0] === "-";
        }, true);
      }
      function skipRemoveSuperset(state, removeChanges, delta) {
        for (var i = 0; i < delta; i++) {
          var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
          if (state.lines[state.index + i] !== " " + changeContent) {
            return false;
          }
        }
        state.index += delta;
        return true;
      }
      function calcOldNewLineCount(lines) {
        var oldLines = 0;
        var newLines = 0;
        lines.forEach(function (line) {
          if (typeof line !== "string") {
            var myCount = calcOldNewLineCount(line.mine);
            var theirCount = calcOldNewLineCount(line.theirs);
            if (oldLines !== undefined) {
              if (myCount.oldLines === theirCount.oldLines) {
                oldLines += myCount.oldLines;
              } else {
                oldLines = undefined;
              }
            }
            if (newLines !== undefined) {
              if (myCount.newLines === theirCount.newLines) {
                newLines += myCount.newLines;
              } else {
                newLines = undefined;
              }
            }
          } else {
            if (newLines !== undefined && (line[0] === "+" || line[0] === " ")) {
              newLines++;
            }
            if (oldLines !== undefined && (line[0] === "-" || line[0] === " ")) {
              oldLines++;
            }
          }
        });
        return {
          oldLines: oldLines,
          newLines: newLines
        };
      }
      function convertChangesToDMP(changes) {
        var ret = [], change, operation;
        for (var i = 0; i < changes.length; i++) {
          change = changes[i];
          if (change.added) {
            operation = 1;
          } else if (change.removed) {
            operation = -1;
          } else {
            operation = 0;
          }
          ret.push([
            operation,
            change.value
          ]);
        }
        return ret;
      }
      function convertChangesToXML(changes) {
        var ret = [];
        for (var i = 0; i < changes.length; i++) {
          var change = changes[i];
          if (change.added) {
            ret.push("<ins>");
          } else if (change.removed) {
            ret.push("<del>");
          }
          ret.push(escapeHTML$1(change.value));
          if (change.added) {
            ret.push("</ins>");
          } else if (change.removed) {
            ret.push("</del>");
          }
        }
        return ret.join("");
      }
      function escapeHTML$1(s) {
        var n = s;
        n = n.replace(/&/g, "&amp;");
        n = n.replace(/</g, "&lt;");
        n = n.replace(/>/g, "&gt;");
        n = n.replace(/"/g, "&quot;");
        return n;
      }

      var jsDiff = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Diff: Diff,
        applyPatch: applyPatch,
        applyPatches: applyPatches,
        canonicalize: canonicalize,
        convertChangesToDMP: convertChangesToDMP,
        convertChangesToXML: convertChangesToXML,
        createPatch: createPatch,
        createTwoFilesPatch: createTwoFilesPatch,
        diffArrays: diffArrays,
        diffChars: diffChars,
        diffCss: diffCss,
        diffJson: diffJson,
        diffLines: diffLines,
        diffSentences: diffSentences,
        diffTrimmedLines: diffTrimmedLines,
        diffWords: diffWords,
        diffWordsWithSpace: diffWordsWithSpace,
        merge: merge,
        parsePatch: parsePatch,
        structuredPatch: structuredPatch
      });
      exports('ae', jsDiff);

      var __varRecorder__$w = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/test-runner.js", __contextModule__);
      var __moduleMeta__$f = {
        pathInPackage: function pathInPackage() {
          return "./test-runner.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var testsFromSource = __varRecorder__$w["lively.ide/test-runner.js__define__"]("testsFromSource", "function", function (sourceOrAst) {
        var testStack = [];
        var testsAndSuites = [];
        var parsed;

        try {
          parsed = typeof sourceOrAst === "string" ? parse$2(sourceOrAst) : sourceOrAst;
        } catch (err) {
          return testsAndSuites;
        }

        recursive(parsed, {}, {
          CallExpression: function CallExpression(node, state, c) {
            var spec;

            if (node.callee.name && node.callee.name.match(/^(describe|it|describeInBrowser|xdescribe|xit)$/) && node.arguments.length >= 2) {
              spec = {
                title: node.arguments[0].value,
                type: node.callee.name.match(/describe/) ? "suite" : "test"
              };
              testStack.push(spec);
              var recorded = {
                fullTitle: pluck(testStack, "title").join(" "),
                type: spec.type,
                node: node
              };
              testsAndSuites.push(recorded);
            }

            base.CallExpression(node, state, c);
            if (spec) testStack.pop();
          }
        }, Object.assign({}, base, {
          SpreadProperty: function SpreadProperty(node, st, c) {}
        }));
        return testsAndSuites;
      }, __moduleMeta__$f);

      __varRecorder__$w.testsFromSource = testsFromSource;

      var testsFromMocha = __varRecorder__$w["lively.ide/test-runner.js__define__"]("testsFromMocha", "function", function (mocha) {
        return _buildTestList(mocha.suite).reduce(function (byFile, test) {
          if (!test.file) return byFile;
          var found = byFile.find(function (ea) {
            return ea.file === test.file;
          });
          if (found) found.tests.push(test);else byFile.push({
            file: test.file,
            tests: [test]
          });
          return byFile;
        }, []);

        function _buildTestList(suite) {
          var _concat;

          var parentFullTitle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          var suiteFullTitle = (parentFullTitle + " " + suite.title).trim();
          return (_concat = [{
            parent: parentFullTitle,
            fullTitle: suiteFullTitle,
            title: suite.title,
            file: suite.file,
            depth: depth,
            type: "suite"
          }].concat((suite.tests || []).map(function (_ref) {
            var title = _ref.title,
                file = _ref.file,
                type = _ref.type;
            return {
              state: "",
              duration: -1,
              parent: suiteFullTitle,
              fullTitle: (suiteFullTitle + " " + title).trim(),
              title: title,
              file: file,
              depth: depth,
              type: type
            };
          }))).concat.apply(_concat, _toConsumableArray$1((suite.suites || []).map(function (suite) {
            return _buildTestList(suite, suiteFullTitle, depth + 1);
          })));
        }
      }, __moduleMeta__$f);

      __varRecorder__$w.testsFromMocha = testsFromMocha;

      var findTestModulesInPackage = __varRecorder__$w["lively.ide/test-runner.js__define__"]("findTestModulesInPackage", "function", /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(systemInterface, packageOrUrl) {
          var resources;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return systemInterface.resourcesOfPackage(packageOrUrl);

                case 2:
                  resources = _context2.sent;
                  return _context2.abrupt("return", Promise.all(resources.map( /*#__PURE__*/function () {
                    var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref3) {
                      var url, source, parsed, hasMochaImports;
                      return regeneratorRuntime.wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              url = _ref3.url;

                              if (url.endsWith(".js")) {
                                _context.next = 3;
                                break;
                              }

                              return _context.abrupt("return", null);

                            case 3:
                              _context.next = 5;
                              return systemInterface.moduleRead(url);

                            case 5:
                              source = _context.sent;
                              _context.prev = 6;
                              parsed = parse$2(source);
                              _context.next = 13;
                              break;

                            case 10:
                              _context.prev = 10;
                              _context.t0 = _context["catch"](6);
                              return _context.abrupt("return", null);

                            case 13:
                              hasMochaImports = imports(scopes(parsed)).some(function (_ref5) {
                                var fromModule = _ref5.fromModule;
                                return fromModule.includes("mocha-es6");
                              });

                              if (hasMochaImports) {
                                _context.next = 16;
                                break;
                              }

                              return _context.abrupt("return", null);

                            case 16:
                              _context.prev = 16;
                              return _context.abrupt("return", __varRecorder__$w.testsFromSource(source).length ? url : null);

                            case 20:
                              _context.prev = 20;
                              _context.t1 = _context["catch"](16);
                              return _context.abrupt("return", null);

                            case 23:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, null, [[6, 10], [16, 20]]);
                    }));

                    return function (_x3) {
                      return _ref4.apply(this, arguments);
                    };
                  }())).then(function (tests) {
                    return tests.filter(Boolean);
                  }));

                case 4:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function (_x, _x2) {
          return _ref2.apply(this, arguments);
        };
      }(), __moduleMeta__$f);

      __varRecorder__$w.findTestModulesInPackage = findTestModulesInPackage;
      __varRecorder__$w.testsFromSource = testsFromSource;
      __varRecorder__$w.testsFromMocha = testsFromMocha;
      __varRecorder__$w.findTestModulesInPackage = findTestModulesInPackage;
      __varRecorder__$w.testRunnerCSS = "\n\n.mocha-test-runner {\n  font-family: IBM Plex Sans;\n  font-size: 12px;\n  line-height: 1.5em;\n  height: 100%;\n}\n\n.mocha-test-runner .controls input {\n  display: inline;\n}\n\n.mocha-test-runner .row h2 {\n  display: inline;\n  margin: 2px 4px;\n  font-size: small;\n}\n\n.mocha-test-runner .row.test-file {\n  margin-top: 0px;\n}\n\n.controls {\n  pointer-events: auto;\n  margin: 6px 6px;\n}\n\n.mocha-test-runner .row {\n  white-space: wrap;\n}\n\n.mocha-test-runner .suites {\n  pointer-events: auto;\n  overflow-y: auto;\n  overflow-x: hidden;\n  height: calc(100% - 30px);\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  background: rgba(0,0,0,0.5);\n}\n\n.mocha-test-runner .suite {\n  font-weight: bold;\n}\n\n.mocha-test-runner .collapse-button {\n  font-weight: bold;\n}\n\n.mocha-test-runner .collapse-button.collapsed {\n  font-weight: bold;\n}\n\n.mocha-test-runner .row {\n/*line-height: 2.2;*/\n}\n\n.mocha-test-runner .run-button {\n  color: rgb(30,30,30);\n  border: rgb(150,150,150) 1px solid;\n  font-size: 12px;\n  border-radius: 5px;\n  padding: 2px 8px;\n  cursor: pointer;\n}\n\n.mocha-test-runner .run-button:active {\n  background-color: rgb(200,200,200);\n}\n\n.row .run-button {\n  font-size: 11px;\n}\n\n.mocha-test-runner .heading .run-button, .row .run-button, .row .remove-button {\n  display: none;\n}\n\n.mocha-test-runner .heading:hover .run-button, .row:hover .run-button, .row:hover .remove-button {\n  display: inline;\n}\n\n.mocha-test-runner .test-file, .suite, .test, .collapse-button {\n  cursor: pointer;\n}\n\n.mocha-test-runner .suite, .test {\n  padding: 2px;\n/*outline: 1px red solid;*/\n}\n\n.mocha-test-runner .row.collapsed {\n  display: none;\n}\n\n.mocha-test-runner .hidden {\n  display: none;\n}\n\n.mocha-test-runner .suite .running::before, .test .running::before {\n  content: \"\u261B \";\n}\n\n.mocha-test-runner .failed {\n  background-color: red;\n  color: white;\n}\n\n.mocha-test-runner .succeeded {\n  background-color: #60d610;\n  color: white;\n}\n\n.mocha-test-runner .duration {\n  font-size: 80%;\n}\n\n.mocha-test-runner .duration.slow {\n  color: yellow;\n}\n\n.mocha-test-runner .duration.very-slow {\n  color: red;\n}";

      var TestRunner = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/test-runner.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("TestRunner") && typeof __lively_classholder__.TestRunner === "function" ? __lively_classholder__.TestRunner : __lively_classholder__.TestRunner = function TestRunner(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function TestRunner_initialize_(props) {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this, props);
            this.reset();
            this.cssDeclaration = __varRecorder__$w.testRunnerCSS;
            return _this;
          }
        }, {
          key: "onLoad",
          value: function () {
            var _TestRunner_onLoad_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
              var _yield$this$systemInt, isInstalled;

              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return this.systemInterface.runEval("\n    const g = typeof global !== 'undefined' ? global : window;\n   !!g.Mocha && !!g.chai\n    ", {
                        targetModule: "lively://lively.ide/test-runner"
                      });

                    case 2:
                      _yield$this$systemInt = _context3.sent;
                      isInstalled = _yield$this$systemInt.value;

                      if (!isInstalled) {
                        _context3.next = 6;
                        break;
                      }

                      return _context3.abrupt("return");

                    case 6:
                      _context3.next = 8;
                      return this.systemInterface.importPackage("mocha-es6");

                    case 8:
                      _context3.next = 10;
                      return this.systemInterface.runEval("\n    const g = typeof global !== 'undefined' ? global : window;\n    const promise = await System.import('lively.lang/promise.js')\n    promise.waitFor(30 * 1000, () =>  !!g.Mocha && !!g.chai);\n  ", {
                        targetModule: "lively://lively.ide/test-runner"
                      });

                    case 10:
                      _context3.next = 12;
                      return this.whenEnvReady();

                    case 12:
                      resource(document.URL).query().runAllTests && this.runAllTests();
                      this.update();

                    case 14:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function TestRunner_onLoad_() {
              return _TestRunner_onLoad_.apply(this, arguments);
            }

            return TestRunner_onLoad_;
          }()
        }, {
          key: "reset",
          value: function TestRunner_reset_() {
            var win = this.getWindow();
            win && (win.extent = pt(500, 600));
            this.state = {
              grep: null,
              loadedTests: [],
              collapsedSuites: {}
            };
            this.layout = new TilingLayout({
              align: "right",
              padding: rect(5, 5, 0, 0)
            });
            this.addMorph(EvalBackendChooser["default"].ensureEvalBackendDropdown(this, null));
            this.update();
          }
        }, {
          key: "setEvalBackend",
          value: function TestRunner_setEvalBackend_(choice) {
            this.editorPlugin.setSystemInterfaceNamed(choice);
          }
        }, {
          key: "findBrowserForFile",
          value: function TestRunner_findBrowserForFile_(file) {
            return browserForFile(file) || $world.execCommand("open browser");
          }
        }, {
          key: "jumpToTest",
          value: function () {
            var _TestRunner_jumpToTest_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(test, file) {
              var li, browser, win, ed, tests, target;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      li = open$1("Scanning source code...");
                      _context4.prev = 1;
                      _context4.next = 4;
                      return this.findBrowserForFile(file);

                    case 4:
                      browser = _context4.sent;
                      win = browser.getWindow();
                      if (win.minimized) win.minimized = false;
                      win.activate();
                      _context4.next = 10;
                      return browser.searchForModuleAndSelect(file);

                    case 10:
                      ed = browser.editorPlugin.textMorph;
                      tests = __varRecorder__$w.testsFromSource(ed.textString);
                      target = tests.find(function (ea) {
                        return ea.fullTitle === test.fullTitle;
                      });

                      if (target) {
                        _context4.next = 15;
                        break;
                      }

                      throw new Error("Cannot find test ".concat(test.title, " in file ").concat(file));

                    case 15:
                      ed.selection = ed.astNodeRange(target.node);
                      ed.centerRow(ed.selection.start.row);
                      _context4.next = 22;
                      break;

                    case 19:
                      _context4.prev = 19;
                      _context4.t0 = _context4["catch"](1);
                      this.showError(_context4.t0);

                    case 22:
                      _context4.prev = 22;
                      li.remove();
                      return _context4.finish(22);

                    case 25:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this, [[1, 19, 22, 25]]);
            }));

            function TestRunner_jumpToTest_(_x4, _x5) {
              return _TestRunner_jumpToTest_.apply(this, arguments);
            }

            return TestRunner_jumpToTest_;
          }()
        }, {
          key: "showError",
          value: function TestRunner_showError_(err) {
            if (this.world()) this.world().logError(err);
          }
        }, {
          key: "removeTestFile",
          value: function TestRunner_removeTestFile_(file) {
            var _this$state = this.state,
                loadedTests = _this$state.loadedTests,
                collapsedSuites = _this$state.collapsedSuites;
            var loaded = loadedTests.find(function (ea) {
              return ea.file === file;
            });

            if (loaded) {
              remove(loadedTests, loaded);
              [file].concat(pluck(loaded.tests, "fullTitle")).forEach(function (name) {
                return delete collapsedSuites[name];
              });
            }

            this.update();
          }
        }, {
          key: "runAllTests",
          value: function () {
            var _TestRunner_runAllTests_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
              var files, _iterator, _step, f;

              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      files = pluck(this.state.loadedTests, "file");
                      _context5.prev = 1;
                      _iterator = _createForOfIteratorHelper(files);
                      _context5.prev = 3;

                      _iterator.s();

                    case 5:
                      if ((_step = _iterator.n()).done) {
                        _context5.next = 11;
                        break;
                      }

                      f = _step.value;
                      _context5.next = 9;
                      return this.runTestFile(f);

                    case 9:
                      _context5.next = 5;
                      break;

                    case 11:
                      _context5.next = 16;
                      break;

                    case 13:
                      _context5.prev = 13;
                      _context5.t0 = _context5["catch"](3);

                      _iterator.e(_context5.t0);

                    case 16:
                      _context5.prev = 16;

                      _iterator.f();

                      return _context5.finish(16);

                    case 19:
                      _context5.next = 24;
                      break;

                    case 21:
                      _context5.prev = 21;
                      _context5.t1 = _context5["catch"](1);
                      this.world().logError(_context5.t1);

                    case 24:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this, [[1, 21], [3, 13, 16, 19]]);
            }));

            function TestRunner_runAllTests_() {
              return _TestRunner_runAllTests_.apply(this, arguments);
            }

            return TestRunner_runAllTests_;
          }()
        }, {
          key: "runSuite",
          value: function () {
            var _TestRunner_runSuite_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(suiteName) {
              var test, grep, newTest;
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      test = this.state.loadedTests.find(function (ea) {
                        return ea.tests.some(function (t) {
                          return t.fullTitle === suiteName;
                        });
                      });

                      if (test) {
                        _context6.next = 3;
                        break;
                      }

                      throw new Error("Cannot find test file for test " + suiteName);

                    case 3:
                      grep = new RegExp("^" + suiteName.replace(/\*/g, "\\*") + ".*");
                      _context6.next = 6;
                      return this.runTestFile(test.file, grep);

                    case 6:
                      newTest = this.state.loadedTests.find(function (ea) {
                        return ea.file === test.file;
                      });

                      if (newTest) {
                        newTest.tests = newTest.tests.map(function (t) {
                          return t.fullTitle.match(grep) ? t : test.tests.find(function (prevT) {
                            return prevT.fullTitle === t.fullTitle;
                          }) || t;
                        });
                        this.update();
                      }

                      _context6.next = 10;
                      return this.scrollIntoView(suiteName);

                    case 10:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function TestRunner_runSuite_(_x6) {
              return _TestRunner_runSuite_.apply(this, arguments);
            }

            return TestRunner_runSuite_;
          }()
        }, {
          key: "runTest",
          value: function TestRunner_runTest_(testName) {
            return this.runSuite(testName);
          }
        }, {
          key: "runTestFile",
          value: function () {
            var _TestRunner_runTestFile_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(file, grep, options) {
              var win, li, recordIndex, result;
              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      if (!System._testsRunning) {
                        _context7.next = 2;
                        break;
                      }

                      return _context7.abrupt("return");

                    case 2:
                      System._testsRunning = true;
                      win = this.getWindow();
                      li = open$1("Running tests...", {
                        target: this
                      });
                      win === null || win === void 0 ? void 0 : win.toggleFader(true);
                      _context7.prev = 6;
                      if (!this.state.loadedTests) this.state.loadedTests = [];

                      if (!this.state.loadedTests.some(function (ea) {
                        return ea.file === file;
                      })) {
                        this.state.loadedTests.push({
                          file: file,
                          tests: []
                        });
                      }

                      recordIndex = this.state.loadedTests.findIndex(function (ea) {
                        return ea.file === file;
                      });
                      _context7.next = 12;
                      return this.runTestFiles([file], grep, options);

                    case 12:
                      result = _context7.sent;
                      this.state.loadedTests[recordIndex] = result.find(function (ea) {
                        return ea.file === file;
                      });
                      this.update();
                      return _context7.abrupt("return", this.state.loadedTests[recordIndex]);

                    case 16:
                      _context7.prev = 16;
                      li.remove();
                      win === null || win === void 0 ? void 0 : win.toggleFader(false);
                      System._testsRunning = false;
                      return _context7.finish(16);

                    case 21:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7, this, [[6,, 16, 21]]);
            }));

            function TestRunner_runTestFile_(_x7, _x8, _x9) {
              return _TestRunner_runTestFile_.apply(this, arguments);
            }

            return TestRunner_runTestFile_;
          }()
        }, {
          key: "runTestFiles",
          value: function () {
            var _TestRunner_runTestFiles_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(files, grep, options) {
              var _this2 = this;

              var testRecords, result;
              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      testRecords = files.map(function (file) {
                        return {
                          file: file,
                          tests: []
                        };
                      });
                      grep = grep || this.state.grep || /.*/;
                      _context8.prev = 2;
                      _context8.next = 5;
                      return this.systemInterface.runMochaTests(grep, testRecords, function () {
                        return _this2.update();
                      }, function (err, when) {
                        return _this2.showError("Error during ".concat(when, ": ").concat(err));
                      });

                    case 5:
                      result = _context8.sent;

                      if (!(result && result.isError)) {
                        _context8.next = 8;
                        break;
                      }

                      throw new Error(result.value.stack || result.value);

                    case 8:
                      if (!(!result || !result.testsByFile)) {
                        _context8.next = 10;
                        break;
                      }

                      throw new Error("No test results when runnin tests of ".concat(files));

                    case 10:
                      return _context8.abrupt("return", result.testsByFile);

                    case 13:
                      _context8.prev = 13;
                      _context8.t0 = _context8["catch"](2);
                      this.showError(_context8.t0);
                      _context8.next = 18;
                      return this.update();

                    case 18:
                      throw _context8.t0;

                    case 19:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, this, [[2, 13]]);
            }));

            function TestRunner_runTestFiles_(_x10, _x11, _x12) {
              return _TestRunner_runTestFiles_.apply(this, arguments);
            }

            return TestRunner_runTestFiles_;
          }()
        }, {
          key: "updateEvalBackendForPackage",
          value: function TestRunner_updateEvalBackendForPackage_(wantsServer) {
            if (wantsServer) this.systemInterface = EvalBackendChooser["default"].httpEvalBackends[0];else this.systemInterface = localInterface;
          }
        }, {
          key: "runTestsInPackage",
          value: function () {
            var _TestRunner_runTestsInPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(packageName) {
              var _pkgsConf$find;

              var pkgs, pkg, pkgsConf, wantsServerInterface, testModuleURLs, results, _iterator2, _step2, url;

              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      pkgs = localInterface.coreInterface.getPackages();
                      pkg = pkgs.find(function (pkg) {
                        return pkg.name === packageName;
                      });

                      if (pkg) {
                        _context9.next = 4;
                        break;
                      }

                      throw new Error("Cannot find package for name: " + packageName);

                    case 4:
                      _context9.next = 6;
                      return packagesConfig();

                    case 6:
                      pkgsConf = _context9.sent;
                      wantsServerInterface = (_pkgsConf$find = pkgsConf.find(function (p) {
                        return p.name === packageName;
                      })) === null || _pkgsConf$find === void 0 ? void 0 : _pkgsConf$find.wantsServerInterface;
                      this.updateEvalBackendForPackage(wantsServerInterface);
                      _context9.next = 11;
                      return __varRecorder__$w.findTestModulesInPackage(this.systemInterface, packageName);

                    case 11:
                      testModuleURLs = _context9.sent;
                      results = [];
                      _iterator2 = _createForOfIteratorHelper(testModuleURLs);
                      _context9.prev = 14;

                      _iterator2.s();

                    case 16:
                      if ((_step2 = _iterator2.n()).done) {
                        _context9.next = 25;
                        break;
                      }

                      url = _step2.value;
                      _context9.t0 = results;
                      _context9.next = 21;
                      return this.runTestFile(url);

                    case 21:
                      _context9.t1 = _context9.sent;

                      _context9.t0.push.call(_context9.t0, _context9.t1);

                    case 23:
                      _context9.next = 16;
                      break;

                    case 25:
                      _context9.next = 30;
                      break;

                    case 27:
                      _context9.prev = 27;
                      _context9.t2 = _context9["catch"](14);

                      _iterator2.e(_context9.t2);

                    case 30:
                      _context9.prev = 30;

                      _iterator2.f();

                      return _context9.finish(30);

                    case 33:
                      return _context9.abrupt("return", results);

                    case 34:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, this, [[14, 27, 30, 33]]);
            }));

            function TestRunner_runTestsInPackage_(_x13) {
              return _TestRunner_runTestsInPackage_.apply(this, arguments);
            }

            return TestRunner_runTestsInPackage_;
          }()
        }, {
          key: "collapseAll",
          value: function TestRunner_collapseAll_() {
            var _this3 = this;

            this.state.collapsedSuites = {};
            chain(this.state.loadedTests).pluck("tests").flat().filter(function (ea) {
              return ea.type === "suite" && ea.fullTitle;
            }).forEach(function (suite) {
              return _this3.state.collapsedSuites[suite.fullTitle] = true;
            });
            pluck(this.state.loadedTests, "file").forEach(function (f) {
              return _this3.state.collapsedSuites[f] = true;
            });
            this.update();
          }
        }, {
          key: "collapseToggle",
          value: function TestRunner_collapseToggle_() {
            var sel = Object.keys(this.state.collapsedSuites).length === 0 ? "collapseAll" : "uncollapseAll";
            this[sel]();
          }
        }, {
          key: "uncollapseAll",
          value: function TestRunner_uncollapseAll_() {
            this.state.collapsedSuites = {};
            this.update();
          }
        }, {
          key: "onClickCollapseButton",
          value: function TestRunner_onClickCollapseButton_(evt, target, file) {
            var recursive = evt.shiftKey;
            var collapsed = this.state.collapsedSuites;
            var tests = this.state.loadedTests;

            if (target in collapsed) {
              delete collapsed[target];

              if (recursive) {
                if (file === target) {
                  var testsOfFile = tests.find(function (ea) {
                    return ea.file === file;
                  });
                  if (testsOfFile) testsOfFile.tests.forEach(function (t) {
                    return delete collapsed[t.fullTitle];
                  });
                } else {
                  Object.keys(collapsed).forEach(function (k) {
                    return k.indexOf(target) === 0 && delete collapsed[k];
                  });
                }
              }
            } else {
              collapsed[target] = true;

              if (recursive) {
                var _testsOfFile = tests.find(function (ea) {
                  return ea.file === file;
                });

                if (file === target) {
                  if (_testsOfFile) {
                    _testsOfFile.tests.forEach(function (t) {
                      return t.type === "suite" && t.depth >= 1 && (collapsed[t.fullTitle] = true);
                    });
                  }
                } else {
                  if (_testsOfFile) {
                    _testsOfFile.tests.forEach(function (t) {
                      return t.type === "suite" && t.fullTitle.indexOf(target) === 0 && (collapsed[t.fullTitle] = true);
                    });
                  }
                }
              }
            }

            this.update();
          }
        }, {
          key: "onClickTest",
          value: function () {
            var _TestRunner_onClickTest_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(evt, testTitle, file) {
              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      _context10.prev = 0;
                      _context10.next = 3;
                      return this.jumpToTest({
                        fullTitle: testTitle
                      }, file);

                    case 3:
                      _context10.next = 8;
                      break;

                    case 5:
                      _context10.prev = 5;
                      _context10.t0 = _context10["catch"](0);
                      this.showError(_context10.t0);

                    case 8:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, this, [[0, 5]]);
            }));

            function TestRunner_onClickTest_(_x14, _x15, _x16) {
              return _TestRunner_onClickTest_.apply(this, arguments);
            }

            return TestRunner_onClickTest_;
          }()
        }, {
          key: "onClickError",
          value: function TestRunner_onClickError_(evt, testTitle, file) {
            var testsOfFile = this.state.loadedTests.find(function (ea) {
              return ea.file === file;
            });
            var test = testsOfFile.tests.find(function (test) {
              return test.fullTitle === testTitle;
            });
            var printed = this.stringifyExpectedAndActualOfError(test.error);

            if (printed && test.error.actual && test.error.expected) {
              this.world().execCommand("diff and open in window", {
                a: test.error.actual,
                b: test.error.expected,
                title: test.fullTitle
              });
            } else {
              var win = this.world().execCommand("open text window", {
                title: test.fullTitle,
                content: test.error + "\n" + test.error.stack
              });
              setTimeout(function () {
                return win.activate();
              });
            }
          }
        }, {
          key: "onClickFile",
          value: function () {
            var _TestRunner_onClickFile_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(evt, file) {
              var browser;
              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      _context11.prev = 0;
                      _context11.next = 3;
                      return this.findBrowserForFile(file);

                    case 3:
                      browser = _context11.sent;
                      browser.getWindow().activate();
                      _context11.next = 7;
                      return browser.searchForModuleAndSelect(file);

                    case 7:
                      _context11.next = 12;
                      break;

                    case 9:
                      _context11.prev = 9;
                      _context11.t0 = _context11["catch"](0);
                      this.showError(_context11.t0);

                    case 12:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11, this, [[0, 9]]);
            }));

            function TestRunner_onClickFile_(_x17, _x18) {
              return _TestRunner_onClickFile_.apply(this, arguments);
            }

            return TestRunner_onClickFile_;
          }()
        }, {
          key: "onClickSuite",
          value: function TestRunner_onClickSuite_(evt, suiteTitle, file) {
            this.onClickTest(evt, suiteTitle, file);
          }
        }, {
          key: "update",
          value: function TestRunner_update_() {
            var _this4 = this;

            return new Promise(function (resolve, reject) {
              throttleNamed(_this4.id + "-update", 100, function () {
                return resolve(_this4.renderTests(_this4.state));
              })();
            });
          }
        }, {
          key: "ensureScrollPosition",
          value: function TestRunner_ensureScrollPosition_() {
            var _this$domNode$getElem = this.domNode.getElementsByClassName("suites"),
                _this$domNode$getElem2 = _slicedToArray(_this$domNode$getElem, 1),
                currentSuites = _this$domNode$getElem2[0];

            currentSuites.scrollTop = this._currentScrollY || 0;
          }
        }, {
          key: "htmlRef",
          get: function get() {
            return "System.get(System.normalizeSync('lively.morphic')).MorphicEnv.default().world.getMorphWithId('".concat(this.id, "')");
          }
        }, {
          key: "renderTests",
          value: function () {
            var _TestRunner_renderTests_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(state) {
              var _this5 = this;

              var collapsed, tests, runningTest, renderedFiles, _iterator3, _step3, _loop, _this$domNode$getElem3, _this$domNode$getElem4, currentSuites;

              return regeneratorRuntime.wrap(function _callee12$(_context13) {
                while (1) {
                  switch (_context13.prev = _context13.next) {
                    case 0:
                      collapsed = Object.keys(state.collapsedSuites);
                      tests = state.loadedTests || [];
                      runningTest = tests.find(function (test) {
                        return test.state === "running";
                      });
                      renderedFiles = [];
                      _iterator3 = _createForOfIteratorHelper(tests);
                      _context13.prev = 5;
                      _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {
                        var test;
                        return regeneratorRuntime.wrap(function _loop$(_context12) {
                          while (1) {
                            switch (_context12.prev = _context12.next) {
                              case 0:
                                test = _step3.value;
                                _context12.t0 = renderedFiles;
                                _context12.next = 4;
                                return _this5.renderFile(test.file, test.tests, collapsed);

                              case 4:
                                _context12.t1 = _context12.sent;
                                _context12.t2 = test.tests.slice(1).map(function (ea) {
                                  return ea.type === "test" ? _this5.renderTest(ea, test.tests, test.file, collapsed) : _this5.renderSuite(ea, test.tests, test.file, collapsed);
                                }).join("\n");
                                _context12.t3 = _context12.t1 + _context12.t2;

                                _context12.t0.push.call(_context12.t0, _context12.t3);

                              case 8:
                              case "end":
                                return _context12.stop();
                            }
                          }
                        }, _loop);
                      });

                      _iterator3.s();

                    case 8:
                      if ((_step3 = _iterator3.n()).done) {
                        _context13.next = 12;
                        break;
                      }

                      return _context13.delegateYield(_loop(), "t0", 10);

                    case 10:
                      _context13.next = 8;
                      break;

                    case 12:
                      _context13.next = 17;
                      break;

                    case 14:
                      _context13.prev = 14;
                      _context13.t1 = _context13["catch"](5);

                      _iterator3.e(_context13.t1);

                    case 17:
                      _context13.prev = 17;

                      _iterator3.f();

                      return _context13.finish(17);

                    case 20:
                      this.html = "\n       <div class=\"mocha-test-runner\">\n       <div class=\"controls\" ".concat(this.showControls ? "" : "style=\"display: none;\"", ">\n         <input type=\"button\" class=\"load-test-button run-button\" value=\"load test\" onmousedown=\"").concat(this.htmlRef, ".interactivelyloadTests()\"></input>\n         <input type=\"button\" class=\"run-button\" value=\"run all\" onmouseup=\"").concat(this.htmlRef, ".runAllTests()\"></input>\n         <input type=\"button\" class=\"collapse-button run-button\" value=\"toggle collapse\" onmousedown=\"").concat(this.htmlRef, ".collapseToggle()\"></input>\n         <span class=\"").concat(runningTest ? "" : "hidden", "\">Running: ").concat(runningTest && runningTest.title, "</span>\n       </div>\n       <div class=\"suites\">").concat(renderedFiles.join("\n"), "</div>\n       <div>");
                      _this$domNode$getElem3 = this.domNode.getElementsByClassName("suites"), _this$domNode$getElem4 = _slicedToArray(_this$domNode$getElem3, 1), currentSuites = _this$domNode$getElem4[0];

                      currentSuites.onscroll = function () {
                        _this5._currentScrollY = currentSuites.scrollTop;
                      };

                      this.ensureScrollPosition();

                    case 24:
                    case "end":
                      return _context13.stop();
                  }
                }
              }, _callee12, this, [[5, 14, 17, 20]]);
            }));

            function TestRunner_renderTests_(_x19) {
              return _TestRunner_renderTests_.apply(this, arguments);
            }

            return TestRunner_renderTests_;
          }()
        }, {
          key: "renderTest",
          value: function TestRunner_renderTest_(test, testsAndSuites, file, collapsed) {
            var id = test.fullTitle;
            var isCollapsed = collapsed.includes(file) || (collapsed || []).some(function (ea) {
              return id.indexOf(ea) === 0;
            });
            var classes = ["test", test.state];
            var depthOffset = test.depth * 10 + 20;
            var title = test.title;
            return "<div class=\"row ".concat(isCollapsed ? "collapsed" : "", " ").concat(classes.join(" "), "\">\n              <span\n                class=\"").concat(classes.join(" "), "\"\n                onmousedown=\"").concat(this.htmlRef, ".onClickTest(event, '").concat(id, "', '").concat(file, "', this);\"\n                id=\"").concat(id, "\"\n                style=\"margin-left: ").concat(depthOffset, "px;\"\n                >").concat(title, "</span>\n              <span\n                class=\"duration\n                ").concat(test.duration ? "" : "hidden", "\n                ").concat(test.duration > 500 ? "very-slow" : test.duration > 100 ? "slow" : "", "\"\n                >").concat(test.duration, "ms</span>\n              <input\n                type=\"button\" class=\"run-button\" value=\"run\"\n                onmousedown=\"").concat(this.htmlRef, ".runTest('").concat(id, "')\"></input>\n              <div\n                onmousedown=\"").concat(this.htmlRef, ".onClickError(event, '").concat(id, "', '").concat(file, "', this);\"\n                class=\"error ").concat(test.error ? "" : "hidden", "\"\n                style=\"margin-left: ").concat(depthOffset + 10, "px;\"\n                >").concat(this.renderError(test), "\n              </div>\n            </div>");
          }
        }, {
          key: "renderSuite",
          value: function TestRunner_renderSuite_(suite, testsAndSuites, file, collapsed) {
            var id = suite.fullTitle;
            var myTests = testsAndSuites.filter(function (ea) {
              return ea.type === "test" && ea.fullTitle.indexOf(suite.fullTitle) === 0;
            });
            var duration = sum(compact(myTests.map(function (ea) {
              return ea.duration;
            })));
            var state = (myTests || []).some(function (t) {
              return t.state === "failed";
            }) ? "failed" : myTests.every(function (t) {
              return t.state === "succeeded";
            }) ? "succeeded" : "";
            var classes = ["suite", state];
            var relatedCollapsed = collapsed.filter(function (ea) {
              return id.indexOf(ea) === 0;
            });
            var parentCollapsed = collapsed.includes(file) || (relatedCollapsed || []).some(function (ea) {
              return ea.length < id.length;
            });
            var collapseStart = !parentCollapsed && !!relatedCollapsed.length;
            var depthOffset = suite.depth * 10;
            var title = suite.title;
            return "<div class=\"row ".concat(parentCollapsed ? "collapsed" : "", " ").concat(classes.join(" "), "\">\n              <span\n                class=\"collapse-button ").concat(collapseStart ? "collapsed" : "", "\"\n                onmousedown=\"").concat(this.htmlRef, ".onClickCollapseButton(event, '").concat(id, "', '").concat(file, "', this);\"\n                style=\"margin-left: ").concat(depthOffset, "px;\">").concat(collapseStart ? "\u25BA " : "\u25BC ", "</span>\n              <span\n                class=\"").concat(classes.join(" "), "\"\n                onmousedown=\"").concat(this.htmlRef, ".onClickSuite(event, '").concat(id, "', '").concat(file, "', this);\"\n                id=\"").concat(id, "\">").concat(title, "</span>\n              <span class=\"duration\">").concat(duration, "ms</span>\n              <input\n                type=\"button\" class=\"run-button\" value=\"run\"\n                onmousedown=\"").concat(this.htmlRef, ".runSuite('").concat(id, "')\"></input>\n            </div>");
          }
        }, {
          key: "renderFile",
          value: function () {
            var _TestRunner_renderFile_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(file, testsAndSuites, collapsed) {
              var id, myTests, duration, state, sys, pack, name, classes, isCollapsed;
              return regeneratorRuntime.wrap(function _callee13$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      id = file;
                      myTests = testsAndSuites.filter(function (ea) {
                        return ea.type === "test";
                      });
                      duration = sum(compact(myTests.map(function (ea) {
                        return ea.duration;
                      })));
                      state = (myTests || []).some(function (t) {
                        return t.state === "failed";
                      }) ? "failed" : myTests.every(function (t) {
                        return t.state === "succeeded";
                      }) ? "succeeded" : "";
                      sys = this.systemInterface;
                      _context14.next = 7;
                      return sys.getPackageForModule(id);

                    case 7:
                      pack = _context14.sent;
                      name = pack ? pack.name + "/" + sys.shortModuleName(id, pack) : id;
                      classes = ["test-file", state];
                      isCollapsed = collapsed.includes(id);
                      return _context14.abrupt("return", "<div class=\"row ".concat(classes.join(" "), "\">\n              <span\n                class=\"collapse-button ").concat(isCollapsed ? "collapsed" : "", "\"\n                onmousedown=\"").concat(this.htmlRef, ".onClickCollapseButton(event, '").concat(id, "', '").concat(file, "', this);\">\n                ").concat(isCollapsed ? "\u25BA " : "\u25BC ", "</span>\n              <h2 class=\"").concat(classes.join(" "), "\"\n                  onmousedown=\"").concat(this.htmlRef, ".onClickFile(event, '").concat(id, "', this);\"\n               >").concat(name, "</h2>\n              <span class=\"duration\">").concat(duration, "ms</span>\n              <input\n                type=\"button\" class=\"run-button\" value=\"run\"\n                onmousedown=\"").concat(this.htmlRef, ".runTestFile('").concat(id, "')\"></input>\n              <i class=\"far fa-window-close remove-button\"\n                 onmousedown=\"").concat(this.htmlRef, ".removeTestFile('").concat(id, "')\"></i>\n            </div>"));

                    case 12:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee13, this);
            }));

            function TestRunner_renderFile_(_x20, _x21, _x22) {
              return _TestRunner_renderFile_.apply(this, arguments);
            }

            return TestRunner_renderFile_;
          }()
        }, {
          key: "renderError",
          value: function TestRunner_renderError_(test) {
            if (!test.error) return "";
            var msg = test.error.message ? "<p>".concat(test.error.message, "</p>") : "";

            if (!test.error.actual || !test.error.expected) {
              return "".concat(msg, "<pre>").concat(test.error.stack || test.error, "</pre>");
            }

            var printed = this.stringifyExpectedAndActualOfError(test.error);

            if (jsDiff && printed && printed.expected && printed.actual) {
              return "".concat(msg, "<p>diff + = actual, - = expected:</p><pre>").concat(diffIt(printed.expected, printed.actual), "</pre>");
            } else {
              return "".concat(msg, "<p>expected:</p><pre>").concat(String(test.error.expected), "</pre><p>actual:</p><pre>").concat(String(test.error.actual), "</pre>");
            }

            function diffIt(a, b) {
              return diffLines(a, b).reduce(function (result, line) {
                if (!line.added && !line.removed) {
                  return last$2(result) === "  ..." ? result : result.concat("  ...\n");
                }

                if (line.added) return result.concat("+ " + line.value.replace(/\n?$/, "\n"));
                if (line.removed) return result.concat("- " + line.value.replace(/\n?$/, "\n"));
                return result.concat("???\n");
              }, []).join("");
            }
          }
        }, {
          key: "stringifyExpectedAndActualOfError",
          value: function TestRunner_stringifyExpectedAndActualOfError_(error) {
            return !error.expected || !error.actual ? null : {
              expected: tryPrint(error.expected),
              actual: tryPrint(error.actual)
            };

            function tryPrint(o) {
              if (typeof o === "function") return String(o);
              if (typeof o === "string") return o;

              try {
                return JSON.stringify(o, null, 2);
              } catch (e) {}

              try {
                return inspect$1(o, {
                  maxDepth: 3
                });
              } catch (e) {}

              return String(o);
            }
          }
        }, {
          key: "scrollIntoView",
          value: function TestRunner_scrollIntoView_(fullTitle) {
            var el = document.getElementById(fullTitle);
            if (el && el.scrollIntoViewIfNeeded) el.scrollIntoViewIfNeeded();else if (el && el.scrollIntoView) el.scrollIntoView();
            return Promise.resolve();
          }
        }, {
          key: "interactivelyloadTests",
          value: function () {
            var _TestRunner_interactivelyloadTests_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
              var sys, packages, _yield$$world$filtera, _yield$$world$filtera2, pkg, li, tests, testItems, _yield$$world$filtera3, selected, _iterator4, _step4, _step4$value, url;

              return regeneratorRuntime.wrap(function _callee14$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      sys = this.systemInterface;
                      _context15.next = 3;
                      return sys.getPackages();

                    case 3:
                      _context15.t0 = function (_ref6) {
                        var name = _ref6.name,
                            url = _ref6.url;
                        return {
                          isListItem: true,
                          string: name,
                          value: {
                            name: name,
                            url: url
                          }
                        };
                      };

                      packages = _context15.sent.map(_context15.t0);
                      _context15.next = 7;
                      return $world.filterableListPrompt("Choose package", packages, {
                        requester: this,
                        multiSelect: true,
                        historyId: "lively.morphic-test-runner-load-tests-pkg-hist"
                      });

                    case 7:
                      _yield$$world$filtera = _context15.sent;
                      _yield$$world$filtera2 = _slicedToArray(_yield$$world$filtera.selected, 1);
                      pkg = _yield$$world$filtera2[0];
                      li = open$1("Finding Testmodules in Package");
                      _context15.next = 13;
                      return __varRecorder__$w.findTestModulesInPackage(sys, pkg.url);

                    case 13:
                      tests = _context15.sent;
                      li.remove();
                      testItems = tests.map(function (url) {
                        var nameInPackage = url.slice(pkg.url.length);
                        return {
                          string: nameInPackage,
                          value: {
                            url: url,
                            nameInPackage: url.slice(pkg.url.length)
                          },
                          isListItem: true
                        };
                      });
                      _context15.next = 18;
                      return $world.filterableListPrompt("Load tests", testItems, {
                        requester: this,
                        multiSelect: true,
                        historyId: "lively.morphic-test-runner-load-tests-module-hist"
                      });

                    case 18:
                      _yield$$world$filtera3 = _context15.sent;
                      selected = _yield$$world$filtera3.selected;
                      _context15.prev = 20;
                      _iterator4 = _createForOfIteratorHelper(selected);
                      _context15.prev = 22;

                      _iterator4.s();

                    case 24:
                      if ((_step4 = _iterator4.n()).done) {
                        _context15.next = 30;
                        break;
                      }

                      _step4$value = _step4.value, url = _step4$value.url;
                      _context15.next = 28;
                      return this.runTestFile(url);

                    case 28:
                      _context15.next = 24;
                      break;

                    case 30:
                      _context15.next = 35;
                      break;

                    case 32:
                      _context15.prev = 32;
                      _context15.t1 = _context15["catch"](22);

                      _iterator4.e(_context15.t1);

                    case 35:
                      _context15.prev = 35;

                      _iterator4.f();

                      return _context15.finish(35);

                    case 38:
                      _context15.prev = 38;
                      return _context15.finish(38);

                    case 40:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee14, this, [[20,, 38, 40], [22, 32, 35, 38]]);
            }));

            function TestRunner_interactivelyloadTests_() {
              return _TestRunner_interactivelyloadTests_.apply(this, arguments);
            }

            return TestRunner_interactivelyloadTests_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "TestRunner";
          }
        }, {
          key: "open",
          value: function () {
            var _TestRunner_open_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(props) {
              var runner;
              return regeneratorRuntime.wrap(function _callee15$(_context16) {
                while (1) {
                  switch (_context16.prev = _context16.next) {
                    case 0:
                      runner = new this(Object.assign({
                        extent: pt(500, 600)
                      }, props)).openInWorld();
                      return _context16.abrupt("return", runner.world().openInWindow(runner, {
                        title: "test runner",
                        name: "test runner window"
                      }).activate());

                    case 2:
                    case "end":
                      return _context16.stop();
                  }
                }
              }, _callee15, this);
            }));

            function TestRunner_open_(_x23) {
              return _TestRunner_open_.apply(this, arguments);
            }

            return TestRunner_open_;
          }()
        }, {
          key: "properties",
          get: function get() {
            return {
              showControls: {
                defaultValue: true,
                after: ["html", "submorphs"],
                set: function set(visible) {
                  this.setProperty("showControls", visible);
                  this.get("eval backend button").visible = visible;
                  this.update();
                }
              },
              reactsToPointer: {
                defaultValue: false
              },
              fill: {
                defaultValue: Color.transparent
              },
              state: {},
              editorPlugin: {
                get: function get() {
                  return this.getProperty("editorPlugin") || (this.editorPlugin = new JavaScriptEditorPlugin());
                }
              },
              name: {
                defaultValue: "test runner"
              },
              systemInterface: {
                derived: true,
                after: ["editorPlugin", "submorphs"],
                get: function get() {
                  return this.editorPlugin.systemInterface();
                },
                set: function set(systemInterface) {
                  this.editorPlugin.setSystemInterface(systemInterface);
                  this.get("eval backend button").updateFromTarget();
                }
              },
              isTestRunner: {
                defaultValue: true
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./test-runner.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 6154,
          end: 26946
        });
      }({
        referencedAs: "HTMLMorph",
        value: HTMLMorph
      });
      __varRecorder__$w["default"] = TestRunner;

      var testRunner = /*#__PURE__*/Object.freeze({
        __proto__: null,
        testsFromSource: testsFromSource,
        testsFromMocha: testsFromMocha,
        findTestModulesInPackage: findTestModulesInPackage,
        'default': TestRunner
      });
      exports('af', testRunner);

      var _entities$1 = {"Aacute":"","aacute":"","Abreve":"","abreve":"","ac":"","acd":"","acE":"","Acirc":"","acirc":"","acute":"","Acy":"","acy":"","AElig":"","aelig":"","af":"","Afr":"","afr":"","Agrave":"","agrave":"","alefsym":"","aleph":"","Alpha":"","alpha":"","Amacr":"","amacr":"","amalg":"","amp":"&","AMP":"&","andand":"","And":"","and":"","andd":"","andslope":"","andv":"","ang":"","ange":"","angle":"","angmsdaa":"","angmsdab":"","angmsdac":"","angmsdad":"","angmsdae":"","angmsdaf":"","angmsdag":"","angmsdah":"","angmsd":"","angrt":"","angrtvb":"","angrtvbd":"","angsph":"","angst":"","angzarr":"","Aogon":"","aogon":"","Aopf":"","aopf":"","apacir":"","ap":"","apE":"","ape":"","apid":"","apos":"'","ApplyFunction":"","approx":"","approxeq":"","Aring":"","aring":"","Ascr":"","ascr":"","Assign":"","ast":"*","asymp":"","asympeq":"","Atilde":"","atilde":"","Auml":"","auml":"","awconint":"","awint":"","backcong":"","backepsilon":"","backprime":"","backsim":"","backsimeq":"","Backslash":"","Barv":"","barvee":"","barwed":"","Barwed":"","barwedge":"","bbrk":"","bbrktbrk":"","bcong":"","Bcy":"","bcy":"","bdquo":"","becaus":"","because":"","Because":"","bemptyv":"","bepsi":"","bernou":"","Bernoullis":"","Beta":"","beta":"","beth":"","between":"","Bfr":"","bfr":"","bigcap":"","bigcirc":"","bigcup":"","bigodot":"","bigoplus":"","bigotimes":"","bigsqcup":"","bigstar":"","bigtriangledown":"","bigtriangleup":"","biguplus":"","bigvee":"","bigwedge":"","bkarow":"","blacklozenge":"","blacksquare":"","blacktriangle":"","blacktriangledown":"","blacktriangleleft":"","blacktriangleright":"","blank":"","blk12":"","blk14":"","blk34":"","block":"","bne":"=","bnequiv":"","bNot":"","bnot":"","Bopf":"","bopf":"","bot":"","bottom":"","bowtie":"","boxbox":"","boxdl":"","boxdL":"","boxDl":"","boxDL":"","boxdr":"","boxdR":"","boxDr":"","boxDR":"","boxh":"","boxH":"","boxhd":"","boxHd":"","boxhD":"","boxHD":"","boxhu":"","boxHu":"","boxhU":"","boxHU":"","boxminus":"","boxplus":"","boxtimes":"","boxul":"","boxuL":"","boxUl":"","boxUL":"","boxur":"","boxuR":"","boxUr":"","boxUR":"","boxv":"","boxV":"","boxvh":"","boxvH":"","boxVh":"","boxVH":"","boxvl":"","boxvL":"","boxVl":"","boxVL":"","boxvr":"","boxvR":"","boxVr":"","boxVR":"","bprime":"","breve":"","Breve":"","brvbar":"","bscr":"","Bscr":"","bsemi":"","bsim":"","bsime":"","bsolb":"","bsol":"\\","bsolhsub":"","bull":"","bullet":"","bump":"","bumpE":"","bumpe":"","Bumpeq":"","bumpeq":"","Cacute":"","cacute":"","capand":"","capbrcup":"","capcap":"","cap":"","Cap":"","capcup":"","capdot":"","CapitalDifferentialD":"","caps":"","caret":"","caron":"","Cayleys":"","ccaps":"","Ccaron":"","ccaron":"","Ccedil":"","ccedil":"","Ccirc":"","ccirc":"","Cconint":"","ccups":"","ccupssm":"","Cdot":"","cdot":"","cedil":"","Cedilla":"","cemptyv":"","cent":"","centerdot":"","CenterDot":"","cfr":"","Cfr":"","CHcy":"","chcy":"","check":"","checkmark":"","Chi":"","chi":"","circ":"","circeq":"","circlearrowleft":"","circlearrowright":"","circledast":"","circledcirc":"","circleddash":"","CircleDot":"","circledR":"","circledS":"","CircleMinus":"","CirclePlus":"","CircleTimes":"","cir":"","cirE":"","cire":"","cirfnint":"","cirmid":"","cirscir":"","ClockwiseContourIntegral":"","CloseCurlyDoubleQuote":"","CloseCurlyQuote":"","clubs":"","clubsuit":"","colon":":","Colon":"","Colone":"","colone":"","coloneq":"","comma":",","commat":"@","comp":"","compfn":"","complement":"","complexes":"","cong":"","congdot":"","Congruent":"","conint":"","Conint":"","ContourIntegral":"","copf":"","Copf":"","coprod":"","Coproduct":"","copy":"","COPY":"","copysr":"","CounterClockwiseContourIntegral":"","crarr":"","cross":"","Cross":"","Cscr":"","cscr":"","csub":"","csube":"","csup":"","csupe":"","ctdot":"","cudarrl":"","cudarrr":"","cuepr":"","cuesc":"","cularr":"","cularrp":"","cupbrcap":"","cupcap":"","CupCap":"","cup":"","Cup":"","cupcup":"","cupdot":"","cupor":"","cups":"","curarr":"","curarrm":"","curlyeqprec":"","curlyeqsucc":"","curlyvee":"","curlywedge":"","curren":"","curvearrowleft":"","curvearrowright":"","cuvee":"","cuwed":"","cwconint":"","cwint":"","cylcty":"","dagger":"","Dagger":"","daleth":"","darr":"","Darr":"","dArr":"","dash":"","Dashv":"","dashv":"","dbkarow":"","dblac":"","Dcaron":"","dcaron":"","Dcy":"","dcy":"","ddagger":"","ddarr":"","DD":"","dd":"","DDotrahd":"","ddotseq":"","deg":"","Del":"","Delta":"","delta":"","demptyv":"","dfisht":"","Dfr":"","dfr":"","dHar":"","dharl":"","dharr":"","DiacriticalAcute":"","DiacriticalDot":"","DiacriticalDoubleAcute":"","DiacriticalGrave":"`","DiacriticalTilde":"","diam":"","diamond":"","Diamond":"","diamondsuit":"","diams":"","die":"","DifferentialD":"","digamma":"","disin":"","div":"","divide":"","divideontimes":"","divonx":"","DJcy":"","djcy":"","dlcorn":"","dlcrop":"","dollar":"$","Dopf":"","dopf":"","Dot":"","dot":"","DotDot":"","doteq":"","doteqdot":"","DotEqual":"","dotminus":"","dotplus":"","dotsquare":"","doublebarwedge":"","DoubleContourIntegral":"","DoubleDot":"","DoubleDownArrow":"","DoubleLeftArrow":"","DoubleLeftRightArrow":"","DoubleLeftTee":"","DoubleLongLeftArrow":"","DoubleLongLeftRightArrow":"","DoubleLongRightArrow":"","DoubleRightArrow":"","DoubleRightTee":"","DoubleUpArrow":"","DoubleUpDownArrow":"","DoubleVerticalBar":"","DownArrowBar":"","downarrow":"","DownArrow":"","Downarrow":"","DownArrowUpArrow":"","DownBreve":"","downdownarrows":"","downharpoonleft":"","downharpoonright":"","DownLeftRightVector":"","DownLeftTeeVector":"","DownLeftVectorBar":"","DownLeftVector":"","DownRightTeeVector":"","DownRightVectorBar":"","DownRightVector":"","DownTeeArrow":"","DownTee":"","drbkarow":"","drcorn":"","drcrop":"","Dscr":"","dscr":"","DScy":"","dscy":"","dsol":"","Dstrok":"","dstrok":"","dtdot":"","dtri":"","dtrif":"","duarr":"","duhar":"","dwangle":"","DZcy":"","dzcy":"","dzigrarr":"","Eacute":"","eacute":"","easter":"","Ecaron":"","ecaron":"","Ecirc":"","ecirc":"","ecir":"","ecolon":"","Ecy":"","ecy":"","eDDot":"","Edot":"","edot":"","eDot":"","ee":"","efDot":"","Efr":"","efr":"","eg":"","Egrave":"","egrave":"","egs":"","egsdot":"","el":"","Element":"","elinters":"","ell":"","els":"","elsdot":"","Emacr":"","emacr":"","empty":"","emptyset":"","EmptySmallSquare":"","emptyv":"","EmptyVerySmallSquare":"","emsp13":"","emsp14":"","emsp":"","ENG":"","eng":"","ensp":"","Eogon":"","eogon":"","Eopf":"","eopf":"","epar":"","eparsl":"","eplus":"","epsi":"","Epsilon":"","epsilon":"","epsiv":"","eqcirc":"","eqcolon":"","eqsim":"","eqslantgtr":"","eqslantless":"","Equal":"","equals":"=","EqualTilde":"","equest":"","Equilibrium":"","equiv":"","equivDD":"","eqvparsl":"","erarr":"","erDot":"","escr":"","Escr":"","esdot":"","Esim":"","esim":"","Eta":"","eta":"","ETH":"","eth":"","Euml":"","euml":"","euro":"","excl":"!","exist":"","Exists":"","expectation":"","exponentiale":"","ExponentialE":"","fallingdotseq":"","Fcy":"","fcy":"","female":"","ffilig":"","fflig":"","ffllig":"","Ffr":"","ffr":"","filig":"","FilledSmallSquare":"","FilledVerySmallSquare":"","fjlig":"fj","flat":"","fllig":"","fltns":"","fnof":"","Fopf":"","fopf":"","forall":"","ForAll":"","fork":"","forkv":"","Fouriertrf":"","fpartint":"","frac12":"","frac13":"","frac14":"","frac15":"","frac16":"","frac18":"","frac23":"","frac25":"","frac34":"","frac35":"","frac38":"","frac45":"","frac56":"","frac58":"","frac78":"","frasl":"","frown":"","fscr":"","Fscr":"","gacute":"","Gamma":"","gamma":"","Gammad":"","gammad":"","gap":"","Gbreve":"","gbreve":"","Gcedil":"","Gcirc":"","gcirc":"","Gcy":"","gcy":"","Gdot":"","gdot":"","ge":"","gE":"","gEl":"","gel":"","geq":"","geqq":"","geqslant":"","gescc":"","ges":"","gesdot":"","gesdoto":"","gesdotol":"","gesl":"","gesles":"","Gfr":"","gfr":"","gg":"","Gg":"","ggg":"","gimel":"","GJcy":"","gjcy":"","gla":"","gl":"","glE":"","glj":"","gnap":"","gnapprox":"","gne":"","gnE":"","gneq":"","gneqq":"","gnsim":"","Gopf":"","gopf":"","grave":"`","GreaterEqual":"","GreaterEqualLess":"","GreaterFullEqual":"","GreaterGreater":"","GreaterLess":"","GreaterSlantEqual":"","GreaterTilde":"","Gscr":"","gscr":"","gsim":"","gsime":"","gsiml":"","gtcc":"","gtcir":"","gt":">","GT":">","Gt":"","gtdot":"","gtlPar":"","gtquest":"","gtrapprox":"","gtrarr":"","gtrdot":"","gtreqless":"","gtreqqless":"","gtrless":"","gtrsim":"","gvertneqq":"","gvnE":"","Hacek":"","hairsp":"","half":"","hamilt":"","HARDcy":"","hardcy":"","harrcir":"","harr":"","hArr":"","harrw":"","Hat":"^","hbar":"","Hcirc":"","hcirc":"","hearts":"","heartsuit":"","hellip":"","hercon":"","hfr":"","Hfr":"","HilbertSpace":"","hksearow":"","hkswarow":"","hoarr":"","homtht":"","hookleftarrow":"","hookrightarrow":"","hopf":"","Hopf":"","horbar":"","HorizontalLine":"","hscr":"","Hscr":"","hslash":"","Hstrok":"","hstrok":"","HumpDownHump":"","HumpEqual":"","hybull":"","hyphen":"","Iacute":"","iacute":"","ic":"","Icirc":"","icirc":"","Icy":"","icy":"","Idot":"","IEcy":"","iecy":"","iexcl":"","iff":"","ifr":"","Ifr":"","Igrave":"","igrave":"","ii":"","iiiint":"","iiint":"","iinfin":"","iiota":"","IJlig":"","ijlig":"","Imacr":"","imacr":"","image":"","ImaginaryI":"","imagline":"","imagpart":"","imath":"","Im":"","imof":"","imped":"","Implies":"","incare":"","in":"","infin":"","infintie":"","inodot":"","intcal":"","int":"","Int":"","integers":"","Integral":"","intercal":"","Intersection":"","intlarhk":"","intprod":"","InvisibleComma":"","InvisibleTimes":"","IOcy":"","iocy":"","Iogon":"","iogon":"","Iopf":"","iopf":"","Iota":"","iota":"","iprod":"","iquest":"","iscr":"","Iscr":"","isin":"","isindot":"","isinE":"","isins":"","isinsv":"","isinv":"","it":"","Itilde":"","itilde":"","Iukcy":"","iukcy":"","Iuml":"","iuml":"","Jcirc":"","jcirc":"","Jcy":"","jcy":"","Jfr":"","jfr":"","jmath":"","Jopf":"","jopf":"","Jscr":"","jscr":"","Jsercy":"","jsercy":"","Jukcy":"","jukcy":"","Kappa":"","kappa":"","kappav":"","Kcedil":"","kcedil":"","Kcy":"","kcy":"","Kfr":"","kfr":"","kgreen":"","KHcy":"","khcy":"","KJcy":"","kjcy":"","Kopf":"","kopf":"","Kscr":"","kscr":"","lAarr":"","Lacute":"","lacute":"","laemptyv":"","lagran":"","Lambda":"","lambda":"","lang":"","Lang":"","langd":"","langle":"","lap":"","Laplacetrf":"","laquo":"","larrb":"","larrbfs":"","larr":"","Larr":"","lArr":"","larrfs":"","larrhk":"","larrlp":"","larrpl":"","larrsim":"","larrtl":"","latail":"","lAtail":"","lat":"","late":"","lates":"","lbarr":"","lBarr":"","lbbrk":"","lbrace":"{","lbrack":"[","lbrke":"","lbrksld":"","lbrkslu":"","Lcaron":"","lcaron":"","Lcedil":"","lcedil":"","lceil":"","lcub":"{","Lcy":"","lcy":"","ldca":"","ldquo":"","ldquor":"","ldrdhar":"","ldrushar":"","ldsh":"","le":"","lE":"","LeftAngleBracket":"","LeftArrowBar":"","leftarrow":"","LeftArrow":"","Leftarrow":"","LeftArrowRightArrow":"","leftarrowtail":"","LeftCeiling":"","LeftDoubleBracket":"","LeftDownTeeVector":"","LeftDownVectorBar":"","LeftDownVector":"","LeftFloor":"","leftharpoondown":"","leftharpoonup":"","leftleftarrows":"","leftrightarrow":"","LeftRightArrow":"","Leftrightarrow":"","leftrightarrows":"","leftrightharpoons":"","leftrightsquigarrow":"","LeftRightVector":"","LeftTeeArrow":"","LeftTee":"","LeftTeeVector":"","leftthreetimes":"","LeftTriangleBar":"","LeftTriangle":"","LeftTriangleEqual":"","LeftUpDownVector":"","LeftUpTeeVector":"","LeftUpVectorBar":"","LeftUpVector":"","LeftVectorBar":"","LeftVector":"","lEg":"","leg":"","leq":"","leqq":"","leqslant":"","lescc":"","les":"","lesdot":"","lesdoto":"","lesdotor":"","lesg":"","lesges":"","lessapprox":"","lessdot":"","lesseqgtr":"","lesseqqgtr":"","LessEqualGreater":"","LessFullEqual":"","LessGreater":"","lessgtr":"","LessLess":"","lesssim":"","LessSlantEqual":"","LessTilde":"","lfisht":"","lfloor":"","Lfr":"","lfr":"","lg":"","lgE":"","lHar":"","lhard":"","lharu":"","lharul":"","lhblk":"","LJcy":"","ljcy":"","llarr":"","ll":"","Ll":"","llcorner":"","Lleftarrow":"","llhard":"","lltri":"","Lmidot":"","lmidot":"","lmoustache":"","lmoust":"","lnap":"","lnapprox":"","lne":"","lnE":"","lneq":"","lneqq":"","lnsim":"","loang":"","loarr":"","lobrk":"","longleftarrow":"","LongLeftArrow":"","Longleftarrow":"","longleftrightarrow":"","LongLeftRightArrow":"","Longleftrightarrow":"","longmapsto":"","longrightarrow":"","LongRightArrow":"","Longrightarrow":"","looparrowleft":"","looparrowright":"","lopar":"","Lopf":"","lopf":"","loplus":"","lotimes":"","lowast":"","lowbar":"_","LowerLeftArrow":"","LowerRightArrow":"","loz":"","lozenge":"","lozf":"","lpar":"(","lparlt":"","lrarr":"","lrcorner":"","lrhar":"","lrhard":"","lrm":"","lrtri":"","lsaquo":"","lscr":"","Lscr":"","lsh":"","Lsh":"","lsim":"","lsime":"","lsimg":"","lsqb":"[","lsquo":"","lsquor":"","Lstrok":"","lstrok":"","ltcc":"","ltcir":"","lt":"<","LT":"<","Lt":"","ltdot":"","lthree":"","ltimes":"","ltlarr":"","ltquest":"","ltri":"","ltrie":"","ltrif":"","ltrPar":"","lurdshar":"","luruhar":"","lvertneqq":"","lvnE":"","macr":"","male":"","malt":"","maltese":"","Map":"","map":"","mapsto":"","mapstodown":"","mapstoleft":"","mapstoup":"","marker":"","mcomma":"","Mcy":"","mcy":"","mdash":"","mDDot":"","measuredangle":"","MediumSpace":"","Mellintrf":"","Mfr":"","mfr":"","mho":"","micro":"","midast":"*","midcir":"","mid":"","middot":"","minusb":"","minus":"","minusd":"","minusdu":"","MinusPlus":"","mlcp":"","mldr":"","mnplus":"","models":"","Mopf":"","mopf":"","mp":"","mscr":"","Mscr":"","mstpos":"","Mu":"","mu":"","multimap":"","mumap":"","nabla":"","Nacute":"","nacute":"","nang":"","nap":"","napE":"","napid":"","napos":"","napprox":"","natural":"","naturals":"","natur":"","nbsp":"","nbump":"","nbumpe":"","ncap":"","Ncaron":"","ncaron":"","Ncedil":"","ncedil":"","ncong":"","ncongdot":"","ncup":"","Ncy":"","ncy":"","ndash":"","nearhk":"","nearr":"","neArr":"","nearrow":"","ne":"","nedot":"","NegativeMediumSpace":"","NegativeThickSpace":"","NegativeThinSpace":"","NegativeVeryThinSpace":"","nequiv":"","nesear":"","nesim":"","NestedGreaterGreater":"","NestedLessLess":"","NewLine":"\n","nexist":"","nexists":"","Nfr":"","nfr":"","ngE":"","nge":"","ngeq":"","ngeqq":"","ngeqslant":"","nges":"","nGg":"","ngsim":"","nGt":"","ngt":"","ngtr":"","nGtv":"","nharr":"","nhArr":"","nhpar":"","ni":"","nis":"","nisd":"","niv":"","NJcy":"","njcy":"","nlarr":"","nlArr":"","nldr":"","nlE":"","nle":"","nleftarrow":"","nLeftarrow":"","nleftrightarrow":"","nLeftrightarrow":"","nleq":"","nleqq":"","nleqslant":"","nles":"","nless":"","nLl":"","nlsim":"","nLt":"","nlt":"","nltri":"","nltrie":"","nLtv":"","nmid":"","NoBreak":"","NonBreakingSpace":"","nopf":"","Nopf":"","Not":"","not":"","NotCongruent":"","NotCupCap":"","NotDoubleVerticalBar":"","NotElement":"","NotEqual":"","NotEqualTilde":"","NotExists":"","NotGreater":"","NotGreaterEqual":"","NotGreaterFullEqual":"","NotGreaterGreater":"","NotGreaterLess":"","NotGreaterSlantEqual":"","NotGreaterTilde":"","NotHumpDownHump":"","NotHumpEqual":"","notin":"","notindot":"","notinE":"","notinva":"","notinvb":"","notinvc":"","NotLeftTriangleBar":"","NotLeftTriangle":"","NotLeftTriangleEqual":"","NotLess":"","NotLessEqual":"","NotLessGreater":"","NotLessLess":"","NotLessSlantEqual":"","NotLessTilde":"","NotNestedGreaterGreater":"","NotNestedLessLess":"","notni":"","notniva":"","notnivb":"","notnivc":"","NotPrecedes":"","NotPrecedesEqual":"","NotPrecedesSlantEqual":"","NotReverseElement":"","NotRightTriangleBar":"","NotRightTriangle":"","NotRightTriangleEqual":"","NotSquareSubset":"","NotSquareSubsetEqual":"","NotSquareSuperset":"","NotSquareSupersetEqual":"","NotSubset":"","NotSubsetEqual":"","NotSucceeds":"","NotSucceedsEqual":"","NotSucceedsSlantEqual":"","NotSucceedsTilde":"","NotSuperset":"","NotSupersetEqual":"","NotTilde":"","NotTildeEqual":"","NotTildeFullEqual":"","NotTildeTilde":"","NotVerticalBar":"","nparallel":"","npar":"","nparsl":"","npart":"","npolint":"","npr":"","nprcue":"","nprec":"","npreceq":"","npre":"","nrarrc":"","nrarr":"","nrArr":"","nrarrw":"","nrightarrow":"","nRightarrow":"","nrtri":"","nrtrie":"","nsc":"","nsccue":"","nsce":"","Nscr":"","nscr":"","nshortmid":"","nshortparallel":"","nsim":"","nsime":"","nsimeq":"","nsmid":"","nspar":"","nsqsube":"","nsqsupe":"","nsub":"","nsubE":"","nsube":"","nsubset":"","nsubseteq":"","nsubseteqq":"","nsucc":"","nsucceq":"","nsup":"","nsupE":"","nsupe":"","nsupset":"","nsupseteq":"","nsupseteqq":"","ntgl":"","Ntilde":"","ntilde":"","ntlg":"","ntriangleleft":"","ntrianglelefteq":"","ntriangleright":"","ntrianglerighteq":"","Nu":"","nu":"","num":"#","numero":"","numsp":"","nvap":"","nvdash":"","nvDash":"","nVdash":"","nVDash":"","nvge":"","nvgt":">","nvHarr":"","nvinfin":"","nvlArr":"","nvle":"","nvlt":"<","nvltrie":"","nvrArr":"","nvrtrie":"","nvsim":"","nwarhk":"","nwarr":"","nwArr":"","nwarrow":"","nwnear":"","Oacute":"","oacute":"","oast":"","Ocirc":"","ocirc":"","ocir":"","Ocy":"","ocy":"","odash":"","Odblac":"","odblac":"","odiv":"","odot":"","odsold":"","OElig":"","oelig":"","ofcir":"","Ofr":"","ofr":"","ogon":"","Ograve":"","ograve":"","ogt":"","ohbar":"","ohm":"","oint":"","olarr":"","olcir":"","olcross":"","oline":"","olt":"","Omacr":"","omacr":"","Omega":"","omega":"","Omicron":"","omicron":"","omid":"","ominus":"","Oopf":"","oopf":"","opar":"","OpenCurlyDoubleQuote":"","OpenCurlyQuote":"","operp":"","oplus":"","orarr":"","Or":"","or":"","ord":"","order":"","orderof":"","ordf":"","ordm":"","origof":"","oror":"","orslope":"","orv":"","oS":"","Oscr":"","oscr":"","Oslash":"","oslash":"","osol":"","Otilde":"","otilde":"","otimesas":"","Otimes":"","otimes":"","Ouml":"","ouml":"","ovbar":"","OverBar":"","OverBrace":"","OverBracket":"","OverParenthesis":"","para":"","parallel":"","par":"","parsim":"","parsl":"","part":"","PartialD":"","Pcy":"","pcy":"","percnt":"%","period":".","permil":"","perp":"","pertenk":"","Pfr":"","pfr":"","Phi":"","phi":"","phiv":"","phmmat":"","phone":"","Pi":"","pi":"","pitchfork":"","piv":"","planck":"","planckh":"","plankv":"","plusacir":"","plusb":"","pluscir":"","plus":"+","plusdo":"","plusdu":"","pluse":"","PlusMinus":"","plusmn":"","plussim":"","plustwo":"","pm":"","Poincareplane":"","pointint":"","popf":"","Popf":"","pound":"","prap":"","Pr":"","pr":"","prcue":"","precapprox":"","prec":"","preccurlyeq":"","Precedes":"","PrecedesEqual":"","PrecedesSlantEqual":"","PrecedesTilde":"","preceq":"","precnapprox":"","precneqq":"","precnsim":"","pre":"","prE":"","precsim":"","prime":"","Prime":"","primes":"","prnap":"","prnE":"","prnsim":"","prod":"","Product":"","profalar":"","profline":"","profsurf":"","prop":"","Proportional":"","Proportion":"","propto":"","prsim":"","prurel":"","Pscr":"","pscr":"","Psi":"","psi":"","puncsp":"","Qfr":"","qfr":"","qint":"","qopf":"","Qopf":"","qprime":"","Qscr":"","qscr":"","quaternions":"","quatint":"","quest":"?","questeq":"","quot":"\"","QUOT":"\"","rAarr":"","race":"","Racute":"","racute":"","radic":"","raemptyv":"","rang":"","Rang":"","rangd":"","range":"","rangle":"","raquo":"","rarrap":"","rarrb":"","rarrbfs":"","rarrc":"","rarr":"","Rarr":"","rArr":"","rarrfs":"","rarrhk":"","rarrlp":"","rarrpl":"","rarrsim":"","Rarrtl":"","rarrtl":"","rarrw":"","ratail":"","rAtail":"","ratio":"","rationals":"","rbarr":"","rBarr":"","RBarr":"","rbbrk":"","rbrace":"}","rbrack":"]","rbrke":"","rbrksld":"","rbrkslu":"","Rcaron":"","rcaron":"","Rcedil":"","rcedil":"","rceil":"","rcub":"}","Rcy":"","rcy":"","rdca":"","rdldhar":"","rdquo":"","rdquor":"","rdsh":"","real":"","realine":"","realpart":"","reals":"","Re":"","rect":"","reg":"","REG":"","ReverseElement":"","ReverseEquilibrium":"","ReverseUpEquilibrium":"","rfisht":"","rfloor":"","rfr":"","Rfr":"","rHar":"","rhard":"","rharu":"","rharul":"","Rho":"","rho":"","rhov":"","RightAngleBracket":"","RightArrowBar":"","rightarrow":"","RightArrow":"","Rightarrow":"","RightArrowLeftArrow":"","rightarrowtail":"","RightCeiling":"","RightDoubleBracket":"","RightDownTeeVector":"","RightDownVectorBar":"","RightDownVector":"","RightFloor":"","rightharpoondown":"","rightharpoonup":"","rightleftarrows":"","rightleftharpoons":"","rightrightarrows":"","rightsquigarrow":"","RightTeeArrow":"","RightTee":"","RightTeeVector":"","rightthreetimes":"","RightTriangleBar":"","RightTriangle":"","RightTriangleEqual":"","RightUpDownVector":"","RightUpTeeVector":"","RightUpVectorBar":"","RightUpVector":"","RightVectorBar":"","RightVector":"","ring":"","risingdotseq":"","rlarr":"","rlhar":"","rlm":"","rmoustache":"","rmoust":"","rnmid":"","roang":"","roarr":"","robrk":"","ropar":"","ropf":"","Ropf":"","roplus":"","rotimes":"","RoundImplies":"","rpar":")","rpargt":"","rppolint":"","rrarr":"","Rrightarrow":"","rsaquo":"","rscr":"","Rscr":"","rsh":"","Rsh":"","rsqb":"]","rsquo":"","rsquor":"","rthree":"","rtimes":"","rtri":"","rtrie":"","rtrif":"","rtriltri":"","RuleDelayed":"","ruluhar":"","rx":"","Sacute":"","sacute":"","sbquo":"","scap":"","Scaron":"","scaron":"","Sc":"","sc":"","sccue":"","sce":"","scE":"","Scedil":"","scedil":"","Scirc":"","scirc":"","scnap":"","scnE":"","scnsim":"","scpolint":"","scsim":"","Scy":"","scy":"","sdotb":"","sdot":"","sdote":"","searhk":"","searr":"","seArr":"","searrow":"","sect":"","semi":";","seswar":"","setminus":"","setmn":"","sext":"","Sfr":"","sfr":"","sfrown":"","sharp":"","SHCHcy":"","shchcy":"","SHcy":"","shcy":"","ShortDownArrow":"","ShortLeftArrow":"","shortmid":"","shortparallel":"","ShortRightArrow":"","ShortUpArrow":"","shy":"","Sigma":"","sigma":"","sigmaf":"","sigmav":"","sim":"","simdot":"","sime":"","simeq":"","simg":"","simgE":"","siml":"","simlE":"","simne":"","simplus":"","simrarr":"","slarr":"","SmallCircle":"","smallsetminus":"","smashp":"","smeparsl":"","smid":"","smile":"","smt":"","smte":"","smtes":"","SOFTcy":"","softcy":"","solbar":"","solb":"","sol":"/","Sopf":"","sopf":"","spades":"","spadesuit":"","spar":"","sqcap":"","sqcaps":"","sqcup":"","sqcups":"","Sqrt":"","sqsub":"","sqsube":"","sqsubset":"","sqsubseteq":"","sqsup":"","sqsupe":"","sqsupset":"","sqsupseteq":"","square":"","Square":"","SquareIntersection":"","SquareSubset":"","SquareSubsetEqual":"","SquareSuperset":"","SquareSupersetEqual":"","SquareUnion":"","squarf":"","squ":"","squf":"","srarr":"","Sscr":"","sscr":"","ssetmn":"","ssmile":"","sstarf":"","Star":"","star":"","starf":"","straightepsilon":"","straightphi":"","strns":"","sub":"","Sub":"","subdot":"","subE":"","sube":"","subedot":"","submult":"","subnE":"","subne":"","subplus":"","subrarr":"","subset":"","Subset":"","subseteq":"","subseteqq":"","SubsetEqual":"","subsetneq":"","subsetneqq":"","subsim":"","subsub":"","subsup":"","succapprox":"","succ":"","succcurlyeq":"","Succeeds":"","SucceedsEqual":"","SucceedsSlantEqual":"","SucceedsTilde":"","succeq":"","succnapprox":"","succneqq":"","succnsim":"","succsim":"","SuchThat":"","sum":"","Sum":"","sung":"","sup1":"","sup2":"","sup3":"","sup":"","Sup":"","supdot":"","supdsub":"","supE":"","supe":"","supedot":"","Superset":"","SupersetEqual":"","suphsol":"","suphsub":"","suplarr":"","supmult":"","supnE":"","supne":"","supplus":"","supset":"","Supset":"","supseteq":"","supseteqq":"","supsetneq":"","supsetneqq":"","supsim":"","supsub":"","supsup":"","swarhk":"","swarr":"","swArr":"","swarrow":"","swnwar":"","szlig":"","Tab":"\t","target":"","Tau":"","tau":"","tbrk":"","Tcaron":"","tcaron":"","Tcedil":"","tcedil":"","Tcy":"","tcy":"","tdot":"","telrec":"","Tfr":"","tfr":"","there4":"","therefore":"","Therefore":"","Theta":"","theta":"","thetasym":"","thetav":"","thickapprox":"","thicksim":"","ThickSpace":"","ThinSpace":"","thinsp":"","thkap":"","thksim":"","THORN":"","thorn":"","tilde":"","Tilde":"","TildeEqual":"","TildeFullEqual":"","TildeTilde":"","timesbar":"","timesb":"","times":"","timesd":"","tint":"","toea":"","topbot":"","topcir":"","top":"","Topf":"","topf":"","topfork":"","tosa":"","tprime":"","trade":"","TRADE":"","triangle":"","triangledown":"","triangleleft":"","trianglelefteq":"","triangleq":"","triangleright":"","trianglerighteq":"","tridot":"","trie":"","triminus":"","TripleDot":"","triplus":"","trisb":"","tritime":"","trpezium":"","Tscr":"","tscr":"","TScy":"","tscy":"","TSHcy":"","tshcy":"","Tstrok":"","tstrok":"","twixt":"","twoheadleftarrow":"","twoheadrightarrow":"","Uacute":"","uacute":"","uarr":"","Uarr":"","uArr":"","Uarrocir":"","Ubrcy":"","ubrcy":"","Ubreve":"","ubreve":"","Ucirc":"","ucirc":"","Ucy":"","ucy":"","udarr":"","Udblac":"","udblac":"","udhar":"","ufisht":"","Ufr":"","ufr":"","Ugrave":"","ugrave":"","uHar":"","uharl":"","uharr":"","uhblk":"","ulcorn":"","ulcorner":"","ulcrop":"","ultri":"","Umacr":"","umacr":"","uml":"","UnderBar":"_","UnderBrace":"","UnderBracket":"","UnderParenthesis":"","Union":"","UnionPlus":"","Uogon":"","uogon":"","Uopf":"","uopf":"","UpArrowBar":"","uparrow":"","UpArrow":"","Uparrow":"","UpArrowDownArrow":"","updownarrow":"","UpDownArrow":"","Updownarrow":"","UpEquilibrium":"","upharpoonleft":"","upharpoonright":"","uplus":"","UpperLeftArrow":"","UpperRightArrow":"","upsi":"","Upsi":"","upsih":"","Upsilon":"","upsilon":"","UpTeeArrow":"","UpTee":"","upuparrows":"","urcorn":"","urcorner":"","urcrop":"","Uring":"","uring":"","urtri":"","Uscr":"","uscr":"","utdot":"","Utilde":"","utilde":"","utri":"","utrif":"","uuarr":"","Uuml":"","uuml":"","uwangle":"","vangrt":"","varepsilon":"","varkappa":"","varnothing":"","varphi":"","varpi":"","varpropto":"","varr":"","vArr":"","varrho":"","varsigma":"","varsubsetneq":"","varsubsetneqq":"","varsupsetneq":"","varsupsetneqq":"","vartheta":"","vartriangleleft":"","vartriangleright":"","vBar":"","Vbar":"","vBarv":"","Vcy":"","vcy":"","vdash":"","vDash":"","Vdash":"","VDash":"","Vdashl":"","veebar":"","vee":"","Vee":"","veeeq":"","vellip":"","verbar":"|","Verbar":"","vert":"|","Vert":"","VerticalBar":"","VerticalLine":"|","VerticalSeparator":"","VerticalTilde":"","VeryThinSpace":"","Vfr":"","vfr":"","vltri":"","vnsub":"","vnsup":"","Vopf":"","vopf":"","vprop":"","vrtri":"","Vscr":"","vscr":"","vsubnE":"","vsubne":"","vsupnE":"","vsupne":"","Vvdash":"","vzigzag":"","Wcirc":"","wcirc":"","wedbar":"","wedge":"","Wedge":"","wedgeq":"","weierp":"","Wfr":"","wfr":"","Wopf":"","wopf":"","wp":"","wr":"","wreath":"","Wscr":"","wscr":"","xcap":"","xcirc":"","xcup":"","xdtri":"","Xfr":"","xfr":"","xharr":"","xhArr":"","Xi":"","xi":"","xlarr":"","xlArr":"","xmap":"","xnis":"","xodot":"","Xopf":"","xopf":"","xoplus":"","xotime":"","xrarr":"","xrArr":"","Xscr":"","xscr":"","xsqcup":"","xuplus":"","xutri":"","xvee":"","xwedge":"","Yacute":"","yacute":"","YAcy":"","yacy":"","Ycirc":"","ycirc":"","Ycy":"","ycy":"","yen":"","Yfr":"","yfr":"","YIcy":"","yicy":"","Yopf":"","yopf":"","Yscr":"","yscr":"","YUcy":"","yucy":"","yuml":"","Yuml":"","Zacute":"","zacute":"","Zcaron":"","zcaron":"","Zcy":"","zcy":"","Zdot":"","zdot":"","zeetrf":"","ZeroWidthSpace":"","Zeta":"","zeta":"","zfr":"","Zfr":"","ZHcy":"","zhcy":"","zigrarr":"","zopf":"","Zopf":"","Zscr":"","zscr":"","zwj":"","zwnj":""}
      ;

      var _entities2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _entities$1
      });

      var exports$_ = {};
      exports$_ = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
      var _regex4$1 = exports$_;

      var _regex8 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _regex4$1
      });

      var exports$Z = {};
      var encodeCache = {};
      function getEncodeCache(exclude) {
        var i, ch, cache = encodeCache[exclude];
        if (cache) {
          return cache;
        }
        cache = encodeCache[exclude] = [];
        for (i = 0; i < 128; i++) {
          ch = String.fromCharCode(i);
          if (/^[0-9a-z]$/i.test(ch)) {
            cache.push(ch);
          } else {
            cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
          }
        }
        for (i = 0; i < exclude.length; i++) {
          cache[exclude.charCodeAt(i)] = exclude[i];
        }
        return cache;
      }
      function encode$2(string, exclude, keepEscaped) {
        var i, l, code, nextCode, cache, result = "";
        if (typeof exclude !== "string") {
          keepEscaped = exclude;
          exclude = encode$2.defaultChars;
        }
        if (typeof keepEscaped === "undefined") {
          keepEscaped = true;
        }
        cache = getEncodeCache(exclude);
        for (i = 0, l = string.length; i < l; i++) {
          code = string.charCodeAt(i);
          if (keepEscaped && code === 37 && i + 2 < l) {
            if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
              result += string.slice(i, i + 3);
              i += 2;
              continue;
            }
          }
          if (code < 128) {
            result += cache[code];
            continue;
          }
          if (code >= 55296 && code <= 57343) {
            if (code >= 55296 && code <= 56319 && i + 1 < l) {
              nextCode = string.charCodeAt(i + 1);
              if (nextCode >= 56320 && nextCode <= 57343) {
                result += encodeURIComponent(string[i] + string[i + 1]);
                i++;
                continue;
              }
            }
            result += "%EF%BF%BD";
            continue;
          }
          result += encodeURIComponent(string[i]);
        }
        return result;
      }
      encode$2.defaultChars = ";/?:@&=+$,-_.!~*'()#";
      encode$2.componentChars = "-_.!~*'()";
      exports$Z = encode$2;
      var _encode = exports$Z;

      var exports$Y = {};
      var decodeCache = {};
      function getDecodeCache(exclude) {
        var i, ch, cache = decodeCache[exclude];
        if (cache) {
          return cache;
        }
        cache = decodeCache[exclude] = [];
        for (i = 0; i < 128; i++) {
          ch = String.fromCharCode(i);
          cache.push(ch);
        }
        for (i = 0; i < exclude.length; i++) {
          ch = exclude.charCodeAt(i);
          cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
        }
        return cache;
      }
      function decode$2(string, exclude) {
        var cache;
        if (typeof exclude !== "string") {
          exclude = decode$2.defaultChars;
        }
        cache = getDecodeCache(exclude);
        return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
          var i, l, b1, b2, b3, b4, chr, result = "";
          for (i = 0, l = seq.length; i < l; i += 3) {
            b1 = parseInt(seq.slice(i + 1, i + 3), 16);
            if (b1 < 128) {
              result += cache[b1];
              continue;
            }
            if ((b1 & 224) === 192 && i + 3 < l) {
              b2 = parseInt(seq.slice(i + 4, i + 6), 16);
              if ((b2 & 192) === 128) {
                chr = b1 << 6 & 1984 | b2 & 63;
                if (chr < 128) {
                  result += "\uFFFD\uFFFD";
                } else {
                  result += String.fromCharCode(chr);
                }
                i += 3;
                continue;
              }
            }
            if ((b1 & 240) === 224 && i + 6 < l) {
              b2 = parseInt(seq.slice(i + 4, i + 6), 16);
              b3 = parseInt(seq.slice(i + 7, i + 9), 16);
              if ((b2 & 192) === 128 && (b3 & 192) === 128) {
                chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
                if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                  result += "\uFFFD\uFFFD\uFFFD";
                } else {
                  result += String.fromCharCode(chr);
                }
                i += 6;
                continue;
              }
            }
            if ((b1 & 248) === 240 && i + 9 < l) {
              b2 = parseInt(seq.slice(i + 4, i + 6), 16);
              b3 = parseInt(seq.slice(i + 7, i + 9), 16);
              b4 = parseInt(seq.slice(i + 10, i + 12), 16);
              if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
                chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
                if (chr < 65536 || chr > 1114111) {
                  result += "\uFFFD\uFFFD\uFFFD\uFFFD";
                } else {
                  chr -= 65536;
                  result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
                }
                i += 9;
                continue;
              }
            }
            result += "\uFFFD";
          }
          return result;
        });
      }
      decode$2.defaultChars = ";/?:@&=+$,#";
      decode$2.componentChars = "";
      exports$Y = decode$2;
      var _decode = exports$Y;

      var exports$X = {};
      function Url() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.pathname = null;
      }
      var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = [
          "<",
          ">",
          "\"",
          "`",
          " ",
          "\r",
          "\n",
          "\t"
        ], unwise = [
          "{",
          "}",
          "|",
          "\\",
          "^",
          "`"
        ].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = [
          "%",
          "/",
          "?",
          ";",
          "#"
        ].concat(autoEscape), hostEndingChars = [
          "/",
          "?",
          "#"
        ], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, hostlessProtocol = {
          "javascript": true,
          "javascript:": true
        }, slashedProtocol = {
          "http": true,
          "https": true,
          "ftp": true,
          "gopher": true,
          "file": true,
          "http:": true,
          "https:": true,
          "ftp:": true,
          "gopher:": true,
          "file:": true
        };
      function urlParse(url, slashesDenoteHost) {
        if (url && url instanceof Url) {
          return url;
        }
        var u = new Url();
        u.parse(url, slashesDenoteHost);
        return u;
      }
      Url.prototype.parse = function (url, slashesDenoteHost) {
        var i, l, lowerProto, hec, slashes, rest = url;
        rest = rest.trim();
        if (!slashesDenoteHost && url.split("#").length === 1) {
          var simplePath = simplePathPattern.exec(rest);
          if (simplePath) {
            this.pathname = simplePath[1];
            if (simplePath[2]) {
              this.search = simplePath[2];
            }
            return this;
          }
        }
        var proto = protocolPattern.exec(rest);
        if (proto) {
          proto = proto[0];
          lowerProto = proto.toLowerCase();
          this.protocol = proto;
          rest = rest.substr(proto.length);
        }
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          slashes = rest.substr(0, 2) === "//";
          if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
          }
        }
        if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
          var hostEnd = -1;
          for (i = 0; i < hostEndingChars.length; i++) {
            hec = rest.indexOf(hostEndingChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
              hostEnd = hec;
            }
          }
          var auth, atSign;
          if (hostEnd === -1) {
            atSign = rest.lastIndexOf("@");
          } else {
            atSign = rest.lastIndexOf("@", hostEnd);
          }
          if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = auth;
          }
          hostEnd = -1;
          for (i = 0; i < nonHostChars.length; i++) {
            hec = rest.indexOf(nonHostChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
              hostEnd = hec;
            }
          }
          if (hostEnd === -1) {
            hostEnd = rest.length;
          }
          if (rest[hostEnd - 1] === ":") {
            hostEnd--;
          }
          var host = rest.slice(0, hostEnd);
          rest = rest.slice(hostEnd);
          this.parseHost(host);
          this.hostname = this.hostname || "";
          var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
          if (!ipv6Hostname) {
            var hostparts = this.hostname.split(/\./);
            for (i = 0, l = hostparts.length; i < l; i++) {
              var part = hostparts[i];
              if (!part) {
                continue;
              }
              if (!part.match(hostnamePartPattern)) {
                var newpart = "";
                for (var j = 0, k = part.length; j < k; j++) {
                  if (part.charCodeAt(j) > 127) {
                    newpart += "x";
                  } else {
                    newpart += part[j];
                  }
                }
                if (!newpart.match(hostnamePartPattern)) {
                  var validParts = hostparts.slice(0, i);
                  var notHost = hostparts.slice(i + 1);
                  var bit = part.match(hostnamePartStart);
                  if (bit) {
                    validParts.push(bit[1]);
                    notHost.unshift(bit[2]);
                  }
                  if (notHost.length) {
                    rest = notHost.join(".") + rest;
                  }
                  this.hostname = validParts.join(".");
                  break;
                }
              }
            }
          }
          if (this.hostname.length > hostnameMaxLen) {
            this.hostname = "";
          }
          if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          }
        }
        var hash = rest.indexOf("#");
        if (hash !== -1) {
          this.hash = rest.substr(hash);
          rest = rest.slice(0, hash);
        }
        var qm = rest.indexOf("?");
        if (qm !== -1) {
          this.search = rest.substr(qm);
          rest = rest.slice(0, qm);
        }
        if (rest) {
          this.pathname = rest;
        }
        if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
          this.pathname = "";
        }
        return this;
      };
      Url.prototype.parseHost = function (host) {
        var port = portPattern.exec(host);
        if (port) {
          port = port[0];
          if (port !== ":") {
            this.port = port.substr(1);
          }
          host = host.substr(0, host.length - port.length);
        }
        if (host) {
          this.hostname = host;
        }
      };
      exports$X = urlParse;
      var _parse = exports$X;

      var exports$W = {};
      exports$W = function format(url) {
        var result = "";
        result += url.protocol || "";
        result += url.slashes ? "//" : "";
        result += url.auth ? url.auth + "@" : "";
        if (url.hostname && url.hostname.indexOf(":") !== -1) {
          result += "[" + url.hostname + "]";
        } else {
          result += url.hostname || "";
        }
        result += url.port ? ":" + url.port : "";
        result += url.pathname || "";
        result += url.search || "";
        result += url.hash || "";
        return result;
      };
      var _format = exports$W;
      var exports$1$7 = {};
      exports$1$7.encode = _encode;
      exports$1$7.decode = _decode;
      exports$1$7.format = _format;
      exports$1$7.parse = _parse;
      const encode$1 = exports$1$7.encode, decode$1 = exports$1$7.decode, format = exports$1$7.format, parse$1 = exports$1$7.parse;

      var _mdurl2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': exports$1$7,
        decode: decode$1,
        encode: encode$1,
        format: format,
        parse: parse$1
      });

      var exports$V = {};
      exports$V = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var _regex$2 = exports$V;

      var exports$U = {};
      exports$U = /[\0-\x1F\x7F-\x9F]/;
      var _regex2$1 = exports$U;

      var exports$T = {};
      exports$T = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
      var _regex3$1 = exports$T;

      var exports$S = {};
      exports$S = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
      var _regex5$1 = exports$S;

      var exports$R = {};
      exports$R.Any = _regex$2;
      exports$R.Cc = _regex2$1;
      exports$R.Cf = _regex3$1;
      exports$R.P = _regex4$1;
      exports$R.Z = _regex5$1;
      const Any = exports$R.Any, Cc = exports$R.Cc, Cf = exports$R.Cf, P = exports$R.P, Z = exports$R.Z;

      var _uc2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': exports$R,
        Any: Any,
        Cc: Cc,
        Cf: Cf,
        P: P,
        Z: Z
      });

      var _entities = "default" in _entities2 ? _entities$1 : _entities2;

      var _regex$1 = "default" in _regex8 ? _regex4$1 : _regex8;

      var _mdurl$1 = "default" in _mdurl2 ? exports$1$7 : _mdurl2;

      var _uc = "default" in _uc2 ? exports$R : _uc2;

      var exports$Q = {};

      function _class$1(obj) {
        return Object.prototype.toString.call(obj);
      }

      function isString$1(obj) {
        return _class$1(obj) === "[object String]";
      }

      var _hasOwnProperty = Object.prototype.hasOwnProperty;

      function has$1(object, key) {
        return _hasOwnProperty.call(object, key);
      }

      function assign$2(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        sources.forEach(function (source) {
          if (!source) {
            return;
          }

          if (_typeof$1(source) !== "object") {
            throw new TypeError(source + "must be object");
          }

          Object.keys(source).forEach(function (key) {
            obj[key] = source[key];
          });
        });
        return obj;
      }

      function arrayReplaceAt$1(src, pos, newElements) {
        return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
      }

      function isValidEntityCode$1(c) {
        if (c >= 55296 && c <= 57343) {
          return false;
        }

        if (c >= 64976 && c <= 65007) {
          return false;
        }

        if ((c & 65535) === 65535 || (c & 65535) === 65534) {
          return false;
        }

        if (c >= 0 && c <= 8) {
          return false;
        }

        if (c === 11) {
          return false;
        }

        if (c >= 14 && c <= 31) {
          return false;
        }

        if (c >= 127 && c <= 159) {
          return false;
        }

        if (c > 1114111) {
          return false;
        }

        return true;
      }

      function fromCodePoint$2(c) {
        if (c > 65535) {
          c -= 65536;
          var surrogate1 = 55296 + (c >> 10),
              surrogate2 = 56320 + (c & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        }

        return String.fromCharCode(c);
      }

      var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
      var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
      var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
      var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
      var entities$1 = _entities;

      function replaceEntityPattern(match, name) {
        var code = 0;

        if (has$1(entities$1, name)) {
          return entities$1[name];
        }

        if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
          code = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);

          if (isValidEntityCode$1(code)) {
            return fromCodePoint$2(code);
          }
        }

        return match;
      }

      function unescapeMd(str) {
        if (str.indexOf("\\") < 0) {
          return str;
        }

        return str.replace(UNESCAPE_MD_RE, "$1");
      }

      function unescapeAll$3(str) {
        if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
          return str;
        }

        return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
          if (escaped) {
            return escaped;
          }

          return replaceEntityPattern(match, entity);
        });
      }

      var HTML_ESCAPE_TEST_RE$1 = /[&<>"]/;
      var HTML_ESCAPE_REPLACE_RE$1 = /[&<>"]/g;
      var HTML_REPLACEMENTS$1 = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "\"": "&quot;"
      };

      function replaceUnsafeChar$1(ch) {
        return HTML_REPLACEMENTS$1[ch];
      }

      function escapeHtml$1(str) {
        if (HTML_ESCAPE_TEST_RE$1.test(str)) {
          return str.replace(HTML_ESCAPE_REPLACE_RE$1, replaceUnsafeChar$1);
        }

        return str;
      }

      var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

      function escapeRE$1(str) {
        return str.replace(REGEXP_ESCAPE_RE, "\\$&");
      }

      function isSpace$b(code) {
        switch (code) {
          case 9:
          case 32:
            return true;
        }

        return false;
      }

      function isWhiteSpace$2(code) {
        if (code >= 8192 && code <= 8202) {
          return true;
        }

        switch (code) {
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 32:
          case 160:
          case 5760:
          case 8239:
          case 8287:
          case 12288:
            return true;
        }

        return false;
      }

      var UNICODE_PUNCT_RE = _regex$1;

      function isPunctChar$2(ch) {
        return UNICODE_PUNCT_RE.test(ch);
      }

      function isMdAsciiPunct$2(ch) {
        switch (ch) {
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
          case 38:
          case 39:
          case 40:
          case 41:
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 58:
          case 59:
          case 60:
          case 61:
          case 62:
          case 63:
          case 64:
          case 91:
          case 92:
          case 93:
          case 94:
          case 95:
          case 96:
          case 123:
          case 124:
          case 125:
          case 126:
            return true;

          default:
            return false;
        }
      }

      function normalizeReference$3(str) {
        str = str.trim().replace(/\s+/g, " ");

        if ("".toLowerCase() === "") {
          str = str.replace(//g, "");
        }

        return str.toLowerCase().toUpperCase();
      }

      exports$Q.lib = {};
      exports$Q.lib.mdurl = _mdurl$1;
      exports$Q.lib.ucmicro = _uc;
      exports$Q.assign = assign$2;
      exports$Q.isString = isString$1;
      exports$Q.has = has$1;
      exports$Q.unescapeMd = unescapeMd;
      exports$Q.unescapeAll = unescapeAll$3;
      exports$Q.isValidEntityCode = isValidEntityCode$1;
      exports$Q.fromCodePoint = fromCodePoint$2;
      exports$Q.escapeHtml = escapeHtml$1;
      exports$Q.arrayReplaceAt = arrayReplaceAt$1;
      exports$Q.isSpace = isSpace$b;
      exports$Q.isWhiteSpace = isWhiteSpace$2;
      exports$Q.isMdAsciiPunct = isMdAsciiPunct$2;
      exports$Q.isPunctChar = isPunctChar$2;
      exports$Q.escapeRE = escapeRE$1;
      exports$Q.normalizeReference = normalizeReference$3;
      exports$Q.lib;
      exports$Q.assign;
          exports$Q.isString;
          exports$Q.has;
          exports$Q.unescapeMd;
          exports$Q.unescapeAll;
          exports$Q.isValidEntityCode;
          exports$Q.fromCodePoint;
          exports$Q.escapeHtml;
          exports$Q.arrayReplaceAt;
          exports$Q.isSpace;
          exports$Q.isWhiteSpace;
          exports$Q.isMdAsciiPunct;
          exports$Q.isPunctChar;
          exports$Q.escapeRE;
          exports$Q.normalizeReference;

      var exports$P = {};
      exports$P = function parseLinkLabel(state, start, disableNested) {
        var level, found, marker, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
        state.pos = start + 1;
        level = 1;
        while (state.pos < max) {
          marker = state.src.charCodeAt(state.pos);
          if (marker === 93) {
            level--;
            if (level === 0) {
              found = true;
              break;
            }
          }
          prevPos = state.pos;
          state.md.inline.skipToken(state);
          if (marker === 91) {
            if (prevPos === state.pos - 1) {
              level++;
            } else if (disableNested) {
              state.pos = oldPos;
              return -1;
            }
          }
        }
        if (found) {
          labelEnd = state.pos;
        }
        state.pos = oldPos;
        return labelEnd;
      };
      var _parse_link_label = exports$P;

      var exports$O = {};
      var assign$1 = exports$Q.assign;
      var unescapeAll$2 = exports$Q.unescapeAll;
      var escapeHtml = exports$Q.escapeHtml;
      var default_rules = {};
      default_rules.code_inline = function (tokens, idx, options, env, slf) {
        var token = tokens[idx];
        return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(tokens[idx].content) + "</code>";
      };
      default_rules.code_block = function (tokens, idx, options, env, slf) {
        var token = tokens[idx];
        return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
      };
      default_rules.fence = function (tokens, idx, options, env, slf) {
        var token = tokens[idx], info = token.info ? unescapeAll$2(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
        if (info) {
          arr = info.split(/(\s+)/g);
          langName = arr[0];
          langAttrs = arr.slice(2).join("");
        }
        if (options.highlight) {
          highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
        } else {
          highlighted = escapeHtml(token.content);
        }
        if (highlighted.indexOf("<pre") === 0) {
          return highlighted + "\n";
        }
        if (info) {
          i = token.attrIndex("class");
          tmpAttrs = token.attrs ? token.attrs.slice() : [];
          if (i < 0) {
            tmpAttrs.push([
              "class",
              options.langPrefix + langName
            ]);
          } else {
            tmpAttrs[i] = tmpAttrs[i].slice();
            tmpAttrs[i][1] += " " + options.langPrefix + langName;
          }
          tmpToken = { attrs: tmpAttrs };
          return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
        }
        return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
      };
      default_rules.image = function (tokens, idx, options, env, slf) {
        var token = tokens[idx];
        token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
        return slf.renderToken(tokens, idx, options);
      };
      default_rules.hardbreak = function (tokens, idx, options) {
        return options.xhtmlOut ? "<br />\n" : "<br>\n";
      };
      default_rules.softbreak = function (tokens, idx, options) {
        return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
      };
      default_rules.text = function (tokens, idx) {
        return escapeHtml(tokens[idx].content);
      };
      default_rules.html_block = function (tokens, idx) {
        return tokens[idx].content;
      };
      default_rules.html_inline = function (tokens, idx) {
        return tokens[idx].content;
      };
      function Renderer$1() {
        this.rules = assign$1({}, default_rules);
      }
      Renderer$1.prototype.renderAttrs = function renderAttrs(token) {
        var i, l, result;
        if (!token.attrs) {
          return "";
        }
        result = "";
        for (i = 0, l = token.attrs.length; i < l; i++) {
          result += " " + escapeHtml(token.attrs[i][0]) + "=\"" + escapeHtml(token.attrs[i][1]) + "\"";
        }
        return result;
      };
      Renderer$1.prototype.renderToken = function renderToken(tokens, idx, options) {
        var nextToken, result = "", needLf = false, token = tokens[idx];
        if (token.hidden) {
          return "";
        }
        if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
          result += "\n";
        }
        result += (token.nesting === -1 ? "</" : "<") + token.tag;
        result += this.renderAttrs(token);
        if (token.nesting === 0 && options.xhtmlOut) {
          result += " /";
        }
        if (token.block) {
          needLf = true;
          if (token.nesting === 1) {
            if (idx + 1 < tokens.length) {
              nextToken = tokens[idx + 1];
              if (nextToken.type === "inline" || nextToken.hidden) {
                needLf = false;
              } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
                needLf = false;
              }
            }
          }
        }
        result += needLf ? ">\n" : ">";
        return result;
      };
      Renderer$1.prototype.renderInline = function (tokens, options, env) {
        var type, result = "", rules = this.rules;
        for (var i = 0, len = tokens.length; i < len; i++) {
          type = tokens[i].type;
          if (typeof rules[type] !== "undefined") {
            result += rules[type](tokens, i, options, env, this);
          } else {
            result += this.renderToken(tokens, i, options);
          }
        }
        return result;
      };
      Renderer$1.prototype.renderInlineAsText = function (tokens, options, env) {
        var result = "";
        for (var i = 0, len = tokens.length; i < len; i++) {
          if (tokens[i].type === "text") {
            result += tokens[i].content;
          } else if (tokens[i].type === "image") {
            result += this.renderInlineAsText(tokens[i].children, options, env);
          } else if (tokens[i].type === "softbreak") {
            result += "\n";
          }
        }
        return result;
      };
      Renderer$1.prototype.render = function (tokens, options, env) {
        var i, len, type, result = "", rules = this.rules;
        for (i = 0, len = tokens.length; i < len; i++) {
          type = tokens[i].type;
          if (type === "inline") {
            result += this.renderInline(tokens[i].children, options, env);
          } else if (typeof rules[type] !== "undefined") {
            result += rules[tokens[i].type](tokens, i, options, env, this);
          } else {
            result += this.renderToken(tokens, i, options, env);
          }
        }
        return result;
      };
      exports$O = Renderer$1;
      var _renderer = exports$O;

      var exports$N = {};
      function Token$3(type, tag, nesting) {
        this.type = type;
        this.tag = tag;
        this.attrs = null;
        this.map = null;
        this.nesting = nesting;
        this.level = 0;
        this.children = null;
        this.content = "";
        this.markup = "";
        this.info = "";
        this.meta = null;
        this.block = false;
        this.hidden = false;
      }
      Token$3.prototype.attrIndex = function attrIndex(name) {
        var attrs, i, len;
        if (!this.attrs) {
          return -1;
        }
        attrs = this.attrs;
        for (i = 0, len = attrs.length; i < len; i++) {
          if (attrs[i][0] === name) {
            return i;
          }
        }
        return -1;
      };
      Token$3.prototype.attrPush = function attrPush(attrData) {
        if (this.attrs) {
          this.attrs.push(attrData);
        } else {
          this.attrs = [attrData];
        }
      };
      Token$3.prototype.attrSet = function attrSet(name, value) {
        var idx = this.attrIndex(name), attrData = [
            name,
            value
          ];
        if (idx < 0) {
          this.attrPush(attrData);
        } else {
          this.attrs[idx] = attrData;
        }
      };
      Token$3.prototype.attrGet = function attrGet(name) {
        var idx = this.attrIndex(name), value = null;
        if (idx >= 0) {
          value = this.attrs[idx][1];
        }
        return value;
      };
      Token$3.prototype.attrJoin = function attrJoin(name, value) {
        var idx = this.attrIndex(name);
        if (idx < 0) {
          this.attrPush([
            name,
            value
          ]);
        } else {
          this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
        }
      };
      exports$N = Token$3;
      var _token = exports$N;

      var exports$M = {};
      exports$M = [
        "address",
        "article",
        "aside",
        "base",
        "basefont",
        "blockquote",
        "body",
        "caption",
        "center",
        "col",
        "colgroup",
        "dd",
        "details",
        "dialog",
        "dir",
        "div",
        "dl",
        "dt",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "frame",
        "frameset",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hr",
        "html",
        "iframe",
        "legend",
        "li",
        "link",
        "main",
        "menu",
        "menuitem",
        "nav",
        "noframes",
        "ol",
        "optgroup",
        "option",
        "p",
        "param",
        "section",
        "source",
        "summary",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "title",
        "tr",
        "track",
        "ul"
      ];
      var _html_blocks = exports$M;

      var exports$L = {};
      var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
      var unquoted = "[^\"'=<>`\\x00-\\x20]+";
      var single_quoted = "'[^']*'";
      var double_quoted = "\"[^\"]*\"";
      var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
      var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
      var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
      var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
      var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
      var processing = "<[?][\\s\\S]*?[?]>";
      var declaration = "<![A-Z]+\\s+[^>]*>";
      var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
      var HTML_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
      var HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
      exports$L.HTML_TAG_RE = HTML_TAG_RE$1;
      exports$L.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE$1;

      var exports$K = {};
      var Token$2 = _token;
      var isWhiteSpace$1 = exports$Q.isWhiteSpace;
      var isPunctChar$1 = exports$Q.isPunctChar;
      var isMdAsciiPunct$1 = exports$Q.isMdAsciiPunct;
      function StateInline(src, md, env, outTokens) {
        this.src = src;
        this.env = env;
        this.md = md;
        this.tokens = outTokens;
        this.tokens_meta = Array(outTokens.length);
        this.pos = 0;
        this.posMax = this.src.length;
        this.level = 0;
        this.pending = "";
        this.pendingLevel = 0;
        this.cache = {};
        this.delimiters = [];
        this._prev_delimiters = [];
        this.backticks = {};
        this.backticksScanned = false;
      }
      StateInline.prototype.pushPending = function () {
        var token = new Token$2("text", "", 0);
        token.content = this.pending;
        token.level = this.pendingLevel;
        this.tokens.push(token);
        this.pending = "";
        return token;
      };
      StateInline.prototype.push = function (type, tag, nesting) {
        if (this.pending) {
          this.pushPending();
        }
        var token = new Token$2(type, tag, nesting);
        var token_meta = null;
        if (nesting < 0) {
          this.level--;
          this.delimiters = this._prev_delimiters.pop();
        }
        token.level = this.level;
        if (nesting > 0) {
          this.level++;
          this._prev_delimiters.push(this.delimiters);
          this.delimiters = [];
          token_meta = { delimiters: this.delimiters };
        }
        this.pendingLevel = this.level;
        this.tokens.push(token);
        this.tokens_meta.push(token_meta);
        return token;
      };
      StateInline.prototype.scanDelims = function (start, canSplitWord) {
        var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker = this.src.charCodeAt(start);
        lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
        while (pos < max && this.src.charCodeAt(pos) === marker) {
          pos++;
        }
        count = pos - start;
        nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
        isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
        isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));
        isLastWhiteSpace = isWhiteSpace$1(lastChar);
        isNextWhiteSpace = isWhiteSpace$1(nextChar);
        if (isNextWhiteSpace) {
          left_flanking = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            left_flanking = false;
          }
        }
        if (isLastWhiteSpace) {
          right_flanking = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            right_flanking = false;
          }
        }
        if (!canSplitWord) {
          can_open = left_flanking && (!right_flanking || isLastPunctChar);
          can_close = right_flanking && (!left_flanking || isNextPunctChar);
        } else {
          can_open = left_flanking;
          can_close = right_flanking;
        }
        return {
          can_open: can_open,
          can_close: can_close,
          length: count
        };
      };
      StateInline.prototype.Token = Token$2;
      exports$K = StateInline;
      var _state_inline = exports$K;

      var _regex2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _regex$2
      });

      var _regex4 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _regex2$1
      });

      var _regex6 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _regex5$1
      });

      var _regex = "default" in _regex2 ? _regex$2 : _regex2;
      var _regex3 = "default" in _regex4 ? _regex2$1 : _regex4;
      var _regex5 = "default" in _regex6 ? _regex5$1 : _regex6;
      var _regex7 = "default" in _regex8 ? _regex4$1 : _regex8;
      var exports$2$2 = {};
      exports$2$2 = function (opts) {
        var re = {};
        re.src_Any = _regex.source;
        re.src_Cc = _regex3.source;
        re.src_Z = _regex5.source;
        re.src_P = _regex7.source;
        re.src_ZPCc = [
          re.src_Z,
          re.src_P,
          re.src_Cc
        ].join("|");
        re.src_ZCc = [
          re.src_Z,
          re.src_Cc
        ].join("|");
        var text_separators = "[><\uFF5C]";
        re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
        re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
        re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
        re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
        re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
        re.src_path = "(?:" + "[/?#]" + "(?:" + "(?!" + re.src_ZCc + "|" + text_separators + "|[()[\\]{}.,\"'?!\\-;]).|" + "\\[(?:(?!" + re.src_ZCc + "|\\]).)*\\]|" + "\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|" + "\\{(?:(?!" + re.src_ZCc + "|[}]).)*\\}|" + "\\\"(?:(?!" + re.src_ZCc + "|[\"]).)+\\\"|" + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + "|[-]).|" + "\\.{2,}[a-zA-Z0-9%/&]|" + "\\.(?!" + re.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + ").|" + ";(?!" + re.src_ZCc + ").|" + "\\!+(?!" + re.src_ZCc + "|[!]).|" + "\\?(?!" + re.src_ZCc + "|[?])." + ")+" + "|\\/" + ")?";
        re.src_email_name = "[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\\"\\.a-zA-Z0-9_]*";
        re.src_xn = "xn--[a-z0-9\\-]{1,59}";
        re.src_domain_root = "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63}" + ")";
        re.src_domain = "(?:" + re.src_xn + "|" + "(?:" + re.src_pseudo_letter + ")" + "|" + "(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + ")" + ")";
        re.src_host = "(?:" + "(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + ")" + ")";
        re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|" + "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))" + ")";
        re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
        re.src_host_strict = re.src_host + re.src_host_terminator;
        re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
        re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
        re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
        re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
        re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
        re.tpl_email_fuzzy = "(^|" + text_separators + "|\"|\\(|" + re.src_ZCc + ")" + "(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
        re.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))" + "((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
        re.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))" + "((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
        return re;
      };
      var _re = exports$2$2;
      var exports$J = {};
      function assign(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        sources.forEach(function (source) {
          if (!source) {
            return;
          }
          Object.keys(source).forEach(function (key) {
            obj[key] = source[key];
          });
        });
        return obj;
      }
      function _class(obj) {
        return Object.prototype.toString.call(obj);
      }
      function isString(obj) {
        return _class(obj) === "[object String]";
      }
      function isObject(obj) {
        return _class(obj) === "[object Object]";
      }
      function isRegExp(obj) {
        return _class(obj) === "[object RegExp]";
      }
      function isFunction(obj) {
        return _class(obj) === "[object Function]";
      }
      function escapeRE(str) {
        return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
      }
      var defaultOptions$1 = {
        fuzzyLink: true,
        fuzzyEmail: true,
        fuzzyIP: false
      };
      function isOptionsObj(obj) {
        return Object.keys(obj || {}).reduce(function (acc, k) {
          return acc || defaultOptions$1.hasOwnProperty(k);
        }, false);
      }
      var defaultSchemas = {
        "http:": {
          validate: function (text, pos, self) {
            var tail = text.slice(pos);
            if (!self.re.http) {
              self.re.http = new RegExp("^\\/\\/" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, "i");
            }
            if (self.re.http.test(tail)) {
              return tail.match(self.re.http)[0].length;
            }
            return 0;
          }
        },
        "https:": "http:",
        "ftp:": "http:",
        "//": {
          validate: function (text, pos, self) {
            var tail = text.slice(pos);
            if (!self.re.no_http) {
              self.re.no_http = new RegExp("^" + self.re.src_auth + "(?:localhost|(?:(?:" + self.re.src_domain + ")\\.)+" + self.re.src_domain_root + ")" + self.re.src_port + self.re.src_host_terminator + self.re.src_path, "i");
            }
            if (self.re.no_http.test(tail)) {
              if (pos >= 3 && text[pos - 3] === ":") {
                return 0;
              }
              if (pos >= 3 && text[pos - 3] === "/") {
                return 0;
              }
              return tail.match(self.re.no_http)[0].length;
            }
            return 0;
          }
        },
        "mailto:": {
          validate: function (text, pos, self) {
            var tail = text.slice(pos);
            if (!self.re.mailto) {
              self.re.mailto = new RegExp("^" + self.re.src_email_name + "@" + self.re.src_host_strict, "i");
            }
            if (self.re.mailto.test(tail)) {
              return tail.match(self.re.mailto)[0].length;
            }
            return 0;
          }
        }
      };
      var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
      var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");
      function resetScanCache(self) {
        self.__index__ = -1;
        self.__text_cache__ = "";
      }
      function createValidator(re) {
        return function (text, pos) {
          var tail = text.slice(pos);
          if (re.test(tail)) {
            return tail.match(re)[0].length;
          }
          return 0;
        };
      }
      function createNormalizer() {
        return function (match, self) {
          self.normalize(match);
        };
      }
      function compile(self) {
        var re = self.re = _re(self.__opts__);
        var tlds = self.__tlds__.slice();
        self.onCompile();
        if (!self.__tlds_replaced__) {
          tlds.push(tlds_2ch_src_re);
        }
        tlds.push(re.src_xn);
        re.src_tlds = tlds.join("|");
        function untpl(tpl) {
          return tpl.replace("%TLDS%", re.src_tlds);
        }
        re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
        re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
        re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
        re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
        var aliases = [];
        self.__compiled__ = {};
        function schemaError(name, val) {
          throw new Error("(LinkifyIt) Invalid schema \"" + name + "\": " + val);
        }
        Object.keys(self.__schemas__).forEach(function (name) {
          var val = self.__schemas__[name];
          if (val === null) {
            return;
          }
          var compiled = {
            validate: null,
            link: null
          };
          self.__compiled__[name] = compiled;
          if (isObject(val)) {
            if (isRegExp(val.validate)) {
              compiled.validate = createValidator(val.validate);
            } else if (isFunction(val.validate)) {
              compiled.validate = val.validate;
            } else {
              schemaError(name, val);
            }
            if (isFunction(val.normalize)) {
              compiled.normalize = val.normalize;
            } else if (!val.normalize) {
              compiled.normalize = createNormalizer();
            } else {
              schemaError(name, val);
            }
            return;
          }
          if (isString(val)) {
            aliases.push(name);
            return;
          }
          schemaError(name, val);
        });
        aliases.forEach(function (alias) {
          if (!self.__compiled__[self.__schemas__[alias]]) {
            return;
          }
          self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
          self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
        });
        self.__compiled__[""] = {
          validate: null,
          normalize: createNormalizer()
        };
        var slist = Object.keys(self.__compiled__).filter(function (name) {
          return name.length > 0 && self.__compiled__[name];
        }).map(escapeRE).join("|");
        self.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
        self.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
        self.re.pretest = RegExp("(" + self.re.schema_test.source + ")|(" + self.re.host_fuzzy_test.source + ")|@", "i");
        resetScanCache(self);
      }
      function Match(self, shift) {
        var start = self.__index__, end = self.__last_index__, text = self.__text_cache__.slice(start, end);
        this.schema = self.__schema__.toLowerCase();
        this.index = start + shift;
        this.lastIndex = end + shift;
        this.raw = text;
        this.text = text;
        this.url = text;
      }
      function createMatch(self, shift) {
        var match = new Match(self, shift);
        self.__compiled__[match.schema].normalize(match, self);
        return match;
      }
      function LinkifyIt$1(schemas, options) {
        if (!(this instanceof LinkifyIt$1)) {
          return new LinkifyIt$1(schemas, options);
        }
        if (!options) {
          if (isOptionsObj(schemas)) {
            options = schemas;
            schemas = {};
          }
        }
        this.__opts__ = assign({}, defaultOptions$1, options);
        this.__index__ = -1;
        this.__last_index__ = -1;
        this.__schema__ = "";
        this.__text_cache__ = "";
        this.__schemas__ = assign({}, defaultSchemas, schemas);
        this.__compiled__ = {};
        this.__tlds__ = tlds_default;
        this.__tlds_replaced__ = false;
        this.re = {};
        compile(this);
      }
      LinkifyIt$1.prototype.add = function add(schema, definition) {
        this.__schemas__[schema] = definition;
        compile(this);
        return this;
      };
      LinkifyIt$1.prototype.set = function set(options) {
        this.__opts__ = assign(this.__opts__, options);
        return this;
      };
      LinkifyIt$1.prototype.test = function test(text) {
        this.__text_cache__ = text;
        this.__index__ = -1;
        if (!text.length) {
          return false;
        }
        var m, ml, me, len, shift, next, re, tld_pos, at_pos;
        if (this.re.schema_test.test(text)) {
          re = this.re.schema_search;
          re.lastIndex = 0;
          while ((m = re.exec(text)) !== null) {
            len = this.testSchemaAt(text, m[2], re.lastIndex);
            if (len) {
              this.__schema__ = m[2];
              this.__index__ = m.index + m[1].length;
              this.__last_index__ = m.index + m[0].length + len;
              break;
            }
          }
        }
        if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
          tld_pos = text.search(this.re.host_fuzzy_test);
          if (tld_pos >= 0) {
            if (this.__index__ < 0 || tld_pos < this.__index__) {
              if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
                shift = ml.index + ml[1].length;
                if (this.__index__ < 0 || shift < this.__index__) {
                  this.__schema__ = "";
                  this.__index__ = shift;
                  this.__last_index__ = ml.index + ml[0].length;
                }
              }
            }
          }
        }
        if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
          at_pos = text.indexOf("@");
          if (at_pos >= 0) {
            if ((me = text.match(this.re.email_fuzzy)) !== null) {
              shift = me.index + me[1].length;
              next = me.index + me[0].length;
              if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
                this.__schema__ = "mailto:";
                this.__index__ = shift;
                this.__last_index__ = next;
              }
            }
          }
        }
        return this.__index__ >= 0;
      };
      LinkifyIt$1.prototype.pretest = function pretest(text) {
        return this.re.pretest.test(text);
      };
      LinkifyIt$1.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
        if (!this.__compiled__[schema.toLowerCase()]) {
          return 0;
        }
        return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
      };
      LinkifyIt$1.prototype.match = function match(text) {
        var shift = 0, result = [];
        if (this.__index__ >= 0 && this.__text_cache__ === text) {
          result.push(createMatch(this, shift));
          shift = this.__last_index__;
        }
        var tail = shift ? text.slice(shift) : text;
        while (this.test(tail)) {
          result.push(createMatch(this, shift));
          tail = tail.slice(this.__last_index__);
          shift += this.__last_index__;
        }
        if (result.length) {
          return result;
        }
        return null;
      };
      LinkifyIt$1.prototype.tlds = function tlds(list, keepOld) {
        list = Array.isArray(list) ? list : [list];
        if (!keepOld) {
          this.__tlds__ = list.slice();
          this.__tlds_replaced__ = true;
          compile(this);
          return this;
        }
        this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
          return el !== arr[idx - 1];
        }).reverse();
        compile(this);
        return this;
      };
      LinkifyIt$1.prototype.normalize = function normalize(match) {
        if (!match.schema) {
          match.url = "http://" + match.url;
        }
        if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
          match.url = "mailto:" + match.url;
        }
      };
      LinkifyIt$1.prototype.onCompile = function onCompile() {
      };
      exports$J = LinkifyIt$1;
      var exports$1$6 = exports$J;

      var _linkifyIt2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': exports$1$6
      });

      p.decode;
      p.encode;
      p.toASCII;
      p.toUnicode;
      p.ucs2;
      p.version;
      var decode = p.decode;
      var encode = p.encode;
      var toASCII = p.toASCII;
      var toUnicode = p.toUnicode;
      var ucs2 = p.ucs2;
      var version$1 = p.version;

      var _punycode2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': p,
        decode: decode,
        encode: encode,
        toASCII: toASCII,
        toUnicode: toUnicode,
        ucs2: ucs2,
        version: version$1
      });

      var exports$I = {};
      exports$I = {
        options: {
          html: false,
          xhtmlOut: false,
          breaks: false,
          langPrefix: "language-",
          linkify: false,
          typographer: false,
          quotes: "\u201C\u201D\u2018\u2019",
          highlight: null,
          maxNesting: 100
        },
        components: {
          core: {},
          block: {},
          inline: {}
        }
      };
      var _default = exports$I;

      var exports$G = {};
      var unescapeAll$1 = exports$Q.unescapeAll;
      exports$G = function parseLinkDestination(str, pos, max) {
        var code, level, lines = 0, start = pos, result = {
            ok: false,
            pos: 0,
            lines: 0,
            str: ""
          };
        if (str.charCodeAt(pos) === 60) {
          pos++;
          while (pos < max) {
            code = str.charCodeAt(pos);
            if (code === 10) {
              return result;
            }
            if (code === 60) {
              return result;
            }
            if (code === 62) {
              result.pos = pos + 1;
              result.str = unescapeAll$1(str.slice(start + 1, pos));
              result.ok = true;
              return result;
            }
            if (code === 92 && pos + 1 < max) {
              pos += 2;
              continue;
            }
            pos++;
          }
          return result;
        }
        level = 0;
        while (pos < max) {
          code = str.charCodeAt(pos);
          if (code === 32) {
            break;
          }
          if (code < 32 || code === 127) {
            break;
          }
          if (code === 92 && pos + 1 < max) {
            if (str.charCodeAt(pos + 1) === 32) {
              break;
            }
            pos += 2;
            continue;
          }
          if (code === 40) {
            level++;
            if (level > 32) {
              return result;
            }
          }
          if (code === 41) {
            if (level === 0) {
              break;
            }
            level--;
          }
          pos++;
        }
        if (start === pos) {
          return result;
        }
        if (level !== 0) {
          return result;
        }
        result.str = unescapeAll$1(str.slice(start, pos));
        result.lines = lines;
        result.pos = pos;
        result.ok = true;
        return result;
      };
      var _parse_link_destination = exports$G;
      var exports$F = {};
      var unescapeAll = exports$Q.unescapeAll;
      exports$F = function parseLinkTitle(str, pos, max) {
        var code, marker, lines = 0, start = pos, result = {
            ok: false,
            pos: 0,
            lines: 0,
            str: ""
          };
        if (pos >= max) {
          return result;
        }
        marker = str.charCodeAt(pos);
        if (marker !== 34 && marker !== 39 && marker !== 40) {
          return result;
        }
        pos++;
        if (marker === 40) {
          marker = 41;
        }
        while (pos < max) {
          code = str.charCodeAt(pos);
          if (code === marker) {
            result.pos = pos + 1;
            result.lines = lines;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          } else if (code === 40 && marker === 41) {
            return result;
          } else if (code === 10) {
            lines++;
          } else if (code === 92 && pos + 1 < max) {
            pos++;
            if (str.charCodeAt(pos) === 10) {
              lines++;
            }
          }
          pos++;
        }
        return result;
      };
      var _parse_link_title = exports$F;
      var exports$E = {};
      exports$E.parseLinkLabel = _parse_link_label;
      exports$E.parseLinkDestination = _parse_link_destination;
      exports$E.parseLinkTitle = _parse_link_title;
      var exports$D = {};
      function Ruler$3() {
        this.__rules__ = [];
        this.__cache__ = null;
      }
      Ruler$3.prototype.__find__ = function (name) {
        for (var i = 0; i < this.__rules__.length; i++) {
          if (this.__rules__[i].name === name) {
            return i;
          }
        }
        return -1;
      };
      Ruler$3.prototype.__compile__ = function () {
        var self = this;
        var chains = [""];
        self.__rules__.forEach(function (rule) {
          if (!rule.enabled) {
            return;
          }
          rule.alt.forEach(function (altName) {
            if (chains.indexOf(altName) < 0) {
              chains.push(altName);
            }
          });
        });
        self.__cache__ = {};
        chains.forEach(function (chain) {
          self.__cache__[chain] = [];
          self.__rules__.forEach(function (rule) {
            if (!rule.enabled) {
              return;
            }
            if (chain && rule.alt.indexOf(chain) < 0) {
              return;
            }
            self.__cache__[chain].push(rule.fn);
          });
        });
      };
      Ruler$3.prototype.at = function (name, fn, options) {
        var index = this.__find__(name);
        var opt = options || {};
        if (index === -1) {
          throw new Error("Parser rule not found: " + name);
        }
        this.__rules__[index].fn = fn;
        this.__rules__[index].alt = opt.alt || [];
        this.__cache__ = null;
      };
      Ruler$3.prototype.before = function (beforeName, ruleName, fn, options) {
        var index = this.__find__(beforeName);
        var opt = options || {};
        if (index === -1) {
          throw new Error("Parser rule not found: " + beforeName);
        }
        this.__rules__.splice(index, 0, {
          name: ruleName,
          enabled: true,
          fn: fn,
          alt: opt.alt || []
        });
        this.__cache__ = null;
      };
      Ruler$3.prototype.after = function (afterName, ruleName, fn, options) {
        var index = this.__find__(afterName);
        var opt = options || {};
        if (index === -1) {
          throw new Error("Parser rule not found: " + afterName);
        }
        this.__rules__.splice(index + 1, 0, {
          name: ruleName,
          enabled: true,
          fn: fn,
          alt: opt.alt || []
        });
        this.__cache__ = null;
      };
      Ruler$3.prototype.push = function (ruleName, fn, options) {
        var opt = options || {};
        this.__rules__.push({
          name: ruleName,
          enabled: true,
          fn: fn,
          alt: opt.alt || []
        });
        this.__cache__ = null;
      };
      Ruler$3.prototype.enable = function (list, ignoreInvalid) {
        if (!Array.isArray(list)) {
          list = [list];
        }
        var result = [];
        list.forEach(function (name) {
          var idx = this.__find__(name);
          if (idx < 0) {
            if (ignoreInvalid) {
              return;
            }
            throw new Error("Rules manager: invalid rule name " + name);
          }
          this.__rules__[idx].enabled = true;
          result.push(name);
        }, this);
        this.__cache__ = null;
        return result;
      };
      Ruler$3.prototype.enableOnly = function (list, ignoreInvalid) {
        if (!Array.isArray(list)) {
          list = [list];
        }
        this.__rules__.forEach(function (rule) {
          rule.enabled = false;
        });
        this.enable(list, ignoreInvalid);
      };
      Ruler$3.prototype.disable = function (list, ignoreInvalid) {
        if (!Array.isArray(list)) {
          list = [list];
        }
        var result = [];
        list.forEach(function (name) {
          var idx = this.__find__(name);
          if (idx < 0) {
            if (ignoreInvalid) {
              return;
            }
            throw new Error("Rules manager: invalid rule name " + name);
          }
          this.__rules__[idx].enabled = false;
          result.push(name);
        }, this);
        this.__cache__ = null;
        return result;
      };
      Ruler$3.prototype.getRules = function (chainName) {
        if (this.__cache__ === null) {
          this.__compile__();
        }
        return this.__cache__[chainName] || [];
      };
      exports$D = Ruler$3;
      var _ruler = exports$D;
      var exports$C = {};
      var NEWLINES_RE = /\r\n?|\n/g;
      var NULL_RE = /\0/g;
      exports$C = function normalize(state) {
        var str;
        str = state.src.replace(NEWLINES_RE, "\n");
        str = str.replace(NULL_RE, "\uFFFD");
        state.src = str;
      };
      var _normalize = exports$C;
      var exports$B = {};
      exports$B = function block(state) {
        var token;
        if (state.inlineMode) {
          token = new state.Token("inline", "", 0);
          token.content = state.src;
          token.map = [
            0,
            1
          ];
          token.children = [];
          state.tokens.push(token);
        } else {
          state.md.block.parse(state.src, state.md, state.env, state.tokens);
        }
      };
      var _block = exports$B;
      var exports$A = {};
      exports$A = function inline(state) {
        var tokens = state.tokens, tok, i, l;
        for (i = 0, l = tokens.length; i < l; i++) {
          tok = tokens[i];
          if (tok.type === "inline") {
            state.md.inline.parse(tok.content, state.md, state.env, tok.children);
          }
        }
      };
      var _inline = exports$A;
      var exports$z = {};
      var arrayReplaceAt = exports$Q.arrayReplaceAt;
      function isLinkOpen(str) {
        return /^<a[>\s]/i.test(str);
      }
      function isLinkClose(str) {
        return /^<\/a\s*>/i.test(str);
      }
      exports$z = function linkify(state) {
        var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
        if (!state.md.options.linkify) {
          return;
        }
        for (j = 0, l = blockTokens.length; j < l; j++) {
          if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
            continue;
          }
          tokens = blockTokens[j].children;
          htmlLinkLevel = 0;
          for (i = tokens.length - 1; i >= 0; i--) {
            currentToken = tokens[i];
            if (currentToken.type === "link_close") {
              i--;
              while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
                i--;
              }
              continue;
            }
            if (currentToken.type === "html_inline") {
              if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
                htmlLinkLevel--;
              }
              if (isLinkClose(currentToken.content)) {
                htmlLinkLevel++;
              }
            }
            if (htmlLinkLevel > 0) {
              continue;
            }
            if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
              text = currentToken.content;
              links = state.md.linkify.match(text);
              nodes = [];
              level = currentToken.level;
              lastPos = 0;
              for (ln = 0; ln < links.length; ln++) {
                url = links[ln].url;
                fullUrl = state.md.normalizeLink(url);
                if (!state.md.validateLink(fullUrl)) {
                  continue;
                }
                urlText = links[ln].text;
                if (!links[ln].schema) {
                  urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
                } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                  urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
                } else {
                  urlText = state.md.normalizeLinkText(urlText);
                }
                pos = links[ln].index;
                if (pos > lastPos) {
                  token = new state.Token("text", "", 0);
                  token.content = text.slice(lastPos, pos);
                  token.level = level;
                  nodes.push(token);
                }
                token = new state.Token("link_open", "a", 1);
                token.attrs = [[
                    "href",
                    fullUrl
                  ]];
                token.level = level++;
                token.markup = "linkify";
                token.info = "auto";
                nodes.push(token);
                token = new state.Token("text", "", 0);
                token.content = urlText;
                token.level = level;
                nodes.push(token);
                token = new state.Token("link_close", "a", -1);
                token.level = --level;
                token.markup = "linkify";
                token.info = "auto";
                nodes.push(token);
                lastPos = links[ln].lastIndex;
              }
              if (lastPos < text.length) {
                token = new state.Token("text", "", 0);
                token.content = text.slice(lastPos);
                token.level = level;
                nodes.push(token);
              }
              blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
            }
          }
        }
      };
      var _linkify = exports$z;
      var exports$y = {};
      var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
      var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
      var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
      var SCOPED_ABBR = {
        c: "\xA9",
        r: "\xAE",
        p: "\xA7",
        tm: "\u2122"
      };
      function replaceFn(match, name) {
        return SCOPED_ABBR[name.toLowerCase()];
      }
      function replace_scoped(inlineTokens) {
        var i, token, inside_autolink = 0;
        for (i = inlineTokens.length - 1; i >= 0; i--) {
          token = inlineTokens[i];
          if (token.type === "text" && !inside_autolink) {
            token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
          }
          if (token.type === "link_open" && token.info === "auto") {
            inside_autolink--;
          }
          if (token.type === "link_close" && token.info === "auto") {
            inside_autolink++;
          }
        }
      }
      function replace_rare(inlineTokens) {
        var i, token, inside_autolink = 0;
        for (i = inlineTokens.length - 1; i >= 0; i--) {
          token = inlineTokens[i];
          if (token.type === "text" && !inside_autolink) {
            if (RARE_RE.test(token.content)) {
              token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
            }
          }
          if (token.type === "link_open" && token.info === "auto") {
            inside_autolink--;
          }
          if (token.type === "link_close" && token.info === "auto") {
            inside_autolink++;
          }
        }
      }
      exports$y = function replace(state) {
        var blkIdx;
        if (!state.md.options.typographer) {
          return;
        }
        for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
          if (state.tokens[blkIdx].type !== "inline") {
            continue;
          }
          if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
            replace_scoped(state.tokens[blkIdx].children);
          }
          if (RARE_RE.test(state.tokens[blkIdx].content)) {
            replace_rare(state.tokens[blkIdx].children);
          }
        }
      };
      var _replacements = exports$y;
      var exports$x = {};
      var isWhiteSpace = exports$Q.isWhiteSpace;
      var isPunctChar = exports$Q.isPunctChar;
      var isMdAsciiPunct = exports$Q.isMdAsciiPunct;
      var QUOTE_TEST_RE = /['"]/;
      var QUOTE_RE = /['"]/g;
      var APOSTROPHE = "\u2019";
      function replaceAt(str, index, ch) {
        return str.substr(0, index) + ch + str.substr(index + 1);
      }
      function process_inlines(tokens, state) {
        var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
        stack = [];
        for (i = 0; i < tokens.length; i++) {
          token = tokens[i];
          thisLevel = tokens[i].level;
          for (j = stack.length - 1; j >= 0; j--) {
            if (stack[j].level <= thisLevel) {
              break;
            }
          }
          stack.length = j + 1;
          if (token.type !== "text") {
            continue;
          }
          text = token.content;
          pos = 0;
          max = text.length;
          OUTER:
            while (pos < max) {
              QUOTE_RE.lastIndex = pos;
              t = QUOTE_RE.exec(text);
              if (!t) {
                break;
              }
              canOpen = canClose = true;
              pos = t.index + 1;
              isSingle = t[0] === "'";
              lastChar = 32;
              if (t.index - 1 >= 0) {
                lastChar = text.charCodeAt(t.index - 1);
              } else {
                for (j = i - 1; j >= 0; j--) {
                  if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                    break;
                  if (!tokens[j].content)
                    continue;
                  lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                  break;
                }
              }
              nextChar = 32;
              if (pos < max) {
                nextChar = text.charCodeAt(pos);
              } else {
                for (j = i + 1; j < tokens.length; j++) {
                  if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                    break;
                  if (!tokens[j].content)
                    continue;
                  nextChar = tokens[j].content.charCodeAt(0);
                  break;
                }
              }
              isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
              isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
              isLastWhiteSpace = isWhiteSpace(lastChar);
              isNextWhiteSpace = isWhiteSpace(nextChar);
              if (isNextWhiteSpace) {
                canOpen = false;
              } else if (isNextPunctChar) {
                if (!(isLastWhiteSpace || isLastPunctChar)) {
                  canOpen = false;
                }
              }
              if (isLastWhiteSpace) {
                canClose = false;
              } else if (isLastPunctChar) {
                if (!(isNextWhiteSpace || isNextPunctChar)) {
                  canClose = false;
                }
              }
              if (nextChar === 34 && t[0] === "\"") {
                if (lastChar >= 48 && lastChar <= 57) {
                  canClose = canOpen = false;
                }
              }
              if (canOpen && canClose) {
                canOpen = isLastPunctChar;
                canClose = isNextPunctChar;
              }
              if (!canOpen && !canClose) {
                if (isSingle) {
                  token.content = replaceAt(token.content, t.index, APOSTROPHE);
                }
                continue;
              }
              if (canClose) {
                for (j = stack.length - 1; j >= 0; j--) {
                  item = stack[j];
                  if (stack[j].level < thisLevel) {
                    break;
                  }
                  if (item.single === isSingle && stack[j].level === thisLevel) {
                    item = stack[j];
                    if (isSingle) {
                      openQuote = state.md.options.quotes[2];
                      closeQuote = state.md.options.quotes[3];
                    } else {
                      openQuote = state.md.options.quotes[0];
                      closeQuote = state.md.options.quotes[1];
                    }
                    token.content = replaceAt(token.content, t.index, closeQuote);
                    tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
                    pos += closeQuote.length - 1;
                    if (item.token === i) {
                      pos += openQuote.length - 1;
                    }
                    text = token.content;
                    max = text.length;
                    stack.length = j;
                    continue OUTER;
                  }
                }
              }
              if (canOpen) {
                stack.push({
                  token: i,
                  pos: t.index,
                  single: isSingle,
                  level: thisLevel
                });
              } else if (canClose && isSingle) {
                token.content = replaceAt(token.content, t.index, APOSTROPHE);
              }
            }
        }
      }
      exports$x = function smartquotes(state) {
        var blkIdx;
        if (!state.md.options.typographer) {
          return;
        }
        for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
          if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
            continue;
          }
          process_inlines(state.tokens[blkIdx].children, state);
        }
      };
      var _smartquotes = exports$x;
      var exports$w = {};
      var Token$1 = _token;
      function StateCore(src, md, env) {
        this.src = src;
        this.env = env;
        this.tokens = [];
        this.inlineMode = false;
        this.md = md;
      }
      StateCore.prototype.Token = Token$1;
      exports$w = StateCore;
      var _state_core = exports$w;
      var exports$v = {};
      var Ruler$2 = _ruler;
      var _rules$2 = [
        [
          "normalize",
          _normalize
        ],
        [
          "block",
          _block
        ],
        [
          "inline",
          _inline
        ],
        [
          "linkify",
          _linkify
        ],
        [
          "replacements",
          _replacements
        ],
        [
          "smartquotes",
          _smartquotes
        ]
      ];
      function Core() {
        this.ruler = new Ruler$2();
        for (var i = 0; i < _rules$2.length; i++) {
          this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
        }
      }
      Core.prototype.process = function (state) {
        var i, l, rules;
        rules = this.ruler.getRules("");
        for (i = 0, l = rules.length; i < l; i++) {
          rules[i](state);
        }
      };
      Core.prototype.State = _state_core;
      exports$v = Core;
      var _parser_core = exports$v;
      var exports$u = {};
      var isSpace$a = exports$Q.isSpace;
      function getLine(state, line) {
        var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
        return state.src.substr(pos, max - pos);
      }
      function escapedSplit(str) {
        var result = [], pos = 0, max = str.length, ch, isEscaped = false, lastPos = 0, current = "";
        ch = str.charCodeAt(pos);
        while (pos < max) {
          if (ch === 124) {
            if (!isEscaped) {
              result.push(current + str.substring(lastPos, pos));
              current = "";
              lastPos = pos + 1;
            } else {
              current += str.substring(lastPos, pos - 1);
              lastPos = pos;
            }
          }
          isEscaped = ch === 92;
          pos++;
          ch = str.charCodeAt(pos);
        }
        result.push(current + str.substring(lastPos));
        return result;
      }
      exports$u = function table(state, startLine, endLine, silent) {
        var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
        if (startLine + 2 > endLine) {
          return false;
        }
        nextLine = startLine + 1;
        if (state.sCount[nextLine] < state.blkIndent) {
          return false;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          return false;
        }
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        if (pos >= state.eMarks[nextLine]) {
          return false;
        }
        firstCh = state.src.charCodeAt(pos++);
        if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
          return false;
        }
        if (pos >= state.eMarks[nextLine]) {
          return false;
        }
        secondCh = state.src.charCodeAt(pos++);
        if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace$a(secondCh)) {
          return false;
        }
        if (firstCh === 45 && isSpace$a(secondCh)) {
          return false;
        }
        while (pos < state.eMarks[nextLine]) {
          ch = state.src.charCodeAt(pos);
          if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace$a(ch)) {
            return false;
          }
          pos++;
        }
        lineText = getLine(state, startLine + 1);
        columns = lineText.split("|");
        aligns = [];
        for (i = 0; i < columns.length; i++) {
          t = columns[i].trim();
          if (!t) {
            if (i === 0 || i === columns.length - 1) {
              continue;
            } else {
              return false;
            }
          }
          if (!/^:?-+:?$/.test(t)) {
            return false;
          }
          if (t.charCodeAt(t.length - 1) === 58) {
            aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
          } else if (t.charCodeAt(0) === 58) {
            aligns.push("left");
          } else {
            aligns.push("");
          }
        }
        lineText = getLine(state, startLine).trim();
        if (lineText.indexOf("|") === -1) {
          return false;
        }
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          return false;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        columnCount = columns.length;
        if (columnCount === 0 || columnCount !== aligns.length) {
          return false;
        }
        if (silent) {
          return true;
        }
        oldParentType = state.parentType;
        state.parentType = "table";
        terminatorRules = state.md.block.ruler.getRules("blockquote");
        token = state.push("table_open", "table", 1);
        token.map = tableLines = [
          startLine,
          0
        ];
        token = state.push("thead_open", "thead", 1);
        token.map = [
          startLine,
          startLine + 1
        ];
        token = state.push("tr_open", "tr", 1);
        token.map = [
          startLine,
          startLine + 1
        ];
        for (i = 0; i < columns.length; i++) {
          token = state.push("th_open", "th", 1);
          if (aligns[i]) {
            token.attrs = [[
                "style",
                "text-align:" + aligns[i]
              ]];
          }
          token = state.push("inline", "", 0);
          token.content = columns[i].trim();
          token.children = [];
          token = state.push("th_close", "th", -1);
        }
        token = state.push("tr_close", "tr", -1);
        token = state.push("thead_close", "thead", -1);
        for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          terminate = false;
          for (i = 0, l = terminatorRules.length; i < l; i++) {
            if (terminatorRules[i](state, nextLine, endLine, true)) {
              terminate = true;
              break;
            }
          }
          if (terminate) {
            break;
          }
          lineText = getLine(state, nextLine).trim();
          if (!lineText) {
            break;
          }
          if (state.sCount[nextLine] - state.blkIndent >= 4) {
            break;
          }
          columns = escapedSplit(lineText);
          if (columns.length && columns[0] === "")
            columns.shift();
          if (columns.length && columns[columns.length - 1] === "")
            columns.pop();
          if (nextLine === startLine + 2) {
            token = state.push("tbody_open", "tbody", 1);
            token.map = tbodyLines = [
              startLine + 2,
              0
            ];
          }
          token = state.push("tr_open", "tr", 1);
          token.map = [
            nextLine,
            nextLine + 1
          ];
          for (i = 0; i < columnCount; i++) {
            token = state.push("td_open", "td", 1);
            if (aligns[i]) {
              token.attrs = [[
                  "style",
                  "text-align:" + aligns[i]
                ]];
            }
            token = state.push("inline", "", 0);
            token.content = columns[i] ? columns[i].trim() : "";
            token.children = [];
            token = state.push("td_close", "td", -1);
          }
          token = state.push("tr_close", "tr", -1);
        }
        if (tbodyLines) {
          token = state.push("tbody_close", "tbody", -1);
          tbodyLines[1] = nextLine;
        }
        token = state.push("table_close", "table", -1);
        tableLines[1] = nextLine;
        state.parentType = oldParentType;
        state.line = nextLine;
        return true;
      };
      var _table = exports$u;
      var exports$t = {};
      exports$t = function code(state, startLine, endLine) {
        var nextLine, last, token;
        if (state.sCount[startLine] - state.blkIndent < 4) {
          return false;
        }
        last = nextLine = startLine + 1;
        while (nextLine < endLine) {
          if (state.isEmpty(nextLine)) {
            nextLine++;
            continue;
          }
          if (state.sCount[nextLine] - state.blkIndent >= 4) {
            nextLine++;
            last = nextLine;
            continue;
          }
          break;
        }
        state.line = last;
        token = state.push("code_block", "code", 0);
        token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
        token.map = [
          startLine,
          state.line
        ];
        return true;
      };
      var _code = exports$t;
      var exports$s = {};
      exports$s = function fence(state, startLine, endLine, silent) {
        var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          return false;
        }
        if (pos + 3 > max) {
          return false;
        }
        marker = state.src.charCodeAt(pos);
        if (marker !== 126 && marker !== 96) {
          return false;
        }
        mem = pos;
        pos = state.skipChars(pos, marker);
        len = pos - mem;
        if (len < 3) {
          return false;
        }
        markup = state.src.slice(mem, pos);
        params = state.src.slice(pos, max);
        if (marker === 96) {
          if (params.indexOf(String.fromCharCode(marker)) >= 0) {
            return false;
          }
        }
        if (silent) {
          return true;
        }
        nextLine = startLine;
        for (;;) {
          nextLine++;
          if (nextLine >= endLine) {
            break;
          }
          pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          if (pos < max && state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          if (state.src.charCodeAt(pos) !== marker) {
            continue;
          }
          if (state.sCount[nextLine] - state.blkIndent >= 4) {
            continue;
          }
          pos = state.skipChars(pos, marker);
          if (pos - mem < len) {
            continue;
          }
          pos = state.skipSpaces(pos);
          if (pos < max) {
            continue;
          }
          haveEndMarker = true;
          break;
        }
        len = state.sCount[startLine];
        state.line = nextLine + (haveEndMarker ? 1 : 0);
        token = state.push("fence", "code", 0);
        token.info = params;
        token.content = state.getLines(startLine + 1, nextLine, len, true);
        token.markup = markup;
        token.map = [
          startLine,
          state.line
        ];
        return true;
      };
      var _fence = exports$s;
      var exports$r = {};
      var isSpace$9 = exports$Q.isSpace;
      exports$r = function blockquote(state, startLine, endLine, silent) {
        var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          return false;
        }
        if (state.src.charCodeAt(pos++) !== 62) {
          return false;
        }
        if (silent) {
          return true;
        }
        initial = offset = state.sCount[startLine] + 1;
        if (state.src.charCodeAt(pos) === 32) {
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 9) {
          spaceAfterMarker = true;
          if ((state.bsCount[startLine] + offset) % 4 === 3) {
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            adjustTab = true;
          }
        } else {
          spaceAfterMarker = false;
        }
        oldBMarks = [state.bMarks[startLine]];
        state.bMarks[startLine] = pos;
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (isSpace$9(ch)) {
            if (ch === 9) {
              offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
            } else {
              offset++;
            }
          } else {
            break;
          }
          pos++;
        }
        oldBSCount = [state.bsCount[startLine]];
        state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
        lastLineEmpty = pos >= max;
        oldSCount = [state.sCount[startLine]];
        state.sCount[startLine] = offset - initial;
        oldTShift = [state.tShift[startLine]];
        state.tShift[startLine] = pos - state.bMarks[startLine];
        terminatorRules = state.md.block.ruler.getRules("blockquote");
        oldParentType = state.parentType;
        state.parentType = "blockquote";
        for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
          isOutdented = state.sCount[nextLine] < state.blkIndent;
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          if (pos >= max) {
            break;
          }
          if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
            initial = offset = state.sCount[nextLine] + 1;
            if (state.src.charCodeAt(pos) === 32) {
              pos++;
              initial++;
              offset++;
              adjustTab = false;
              spaceAfterMarker = true;
            } else if (state.src.charCodeAt(pos) === 9) {
              spaceAfterMarker = true;
              if ((state.bsCount[nextLine] + offset) % 4 === 3) {
                pos++;
                initial++;
                offset++;
                adjustTab = false;
              } else {
                adjustTab = true;
              }
            } else {
              spaceAfterMarker = false;
            }
            oldBMarks.push(state.bMarks[nextLine]);
            state.bMarks[nextLine] = pos;
            while (pos < max) {
              ch = state.src.charCodeAt(pos);
              if (isSpace$9(ch)) {
                if (ch === 9) {
                  offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
                } else {
                  offset++;
                }
              } else {
                break;
              }
              pos++;
            }
            lastLineEmpty = pos >= max;
            oldBSCount.push(state.bsCount[nextLine]);
            state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] = offset - initial;
            oldTShift.push(state.tShift[nextLine]);
            state.tShift[nextLine] = pos - state.bMarks[nextLine];
            continue;
          }
          if (lastLineEmpty) {
            break;
          }
          terminate = false;
          for (i = 0, l = terminatorRules.length; i < l; i++) {
            if (terminatorRules[i](state, nextLine, endLine, true)) {
              terminate = true;
              break;
            }
          }
          if (terminate) {
            state.lineMax = nextLine;
            if (state.blkIndent !== 0) {
              oldBMarks.push(state.bMarks[nextLine]);
              oldBSCount.push(state.bsCount[nextLine]);
              oldTShift.push(state.tShift[nextLine]);
              oldSCount.push(state.sCount[nextLine]);
              state.sCount[nextLine] -= state.blkIndent;
            }
            break;
          }
          oldBMarks.push(state.bMarks[nextLine]);
          oldBSCount.push(state.bsCount[nextLine]);
          oldTShift.push(state.tShift[nextLine]);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = -1;
        }
        oldIndent = state.blkIndent;
        state.blkIndent = 0;
        token = state.push("blockquote_open", "blockquote", 1);
        token.markup = ">";
        token.map = lines = [
          startLine,
          0
        ];
        state.md.block.tokenize(state, startLine, nextLine);
        token = state.push("blockquote_close", "blockquote", -1);
        token.markup = ">";
        state.lineMax = oldLineMax;
        state.parentType = oldParentType;
        lines[1] = state.line;
        for (i = 0; i < oldTShift.length; i++) {
          state.bMarks[i + startLine] = oldBMarks[i];
          state.tShift[i + startLine] = oldTShift[i];
          state.sCount[i + startLine] = oldSCount[i];
          state.bsCount[i + startLine] = oldBSCount[i];
        }
        state.blkIndent = oldIndent;
        return true;
      };
      var _blockquote = exports$r;
      var exports$q = {};
      var isSpace$8 = exports$Q.isSpace;
      exports$q = function hr(state, startLine, endLine, silent) {
        var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          return false;
        }
        marker = state.src.charCodeAt(pos++);
        if (marker !== 42 && marker !== 45 && marker !== 95) {
          return false;
        }
        cnt = 1;
        while (pos < max) {
          ch = state.src.charCodeAt(pos++);
          if (ch !== marker && !isSpace$8(ch)) {
            return false;
          }
          if (ch === marker) {
            cnt++;
          }
        }
        if (cnt < 3) {
          return false;
        }
        if (silent) {
          return true;
        }
        state.line = startLine + 1;
        token = state.push("hr", "hr", 0);
        token.map = [
          startLine,
          state.line
        ];
        token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
        return true;
      };
      var _hr = exports$q;
      var exports$p = {};
      var isSpace$7 = exports$Q.isSpace;
      function skipBulletListMarker(state, startLine) {
        var marker, pos, max, ch;
        pos = state.bMarks[startLine] + state.tShift[startLine];
        max = state.eMarks[startLine];
        marker = state.src.charCodeAt(pos++);
        if (marker !== 42 && marker !== 45 && marker !== 43) {
          return -1;
        }
        if (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (!isSpace$7(ch)) {
            return -1;
          }
        }
        return pos;
      }
      function skipOrderedListMarker(state, startLine) {
        var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
        if (pos + 1 >= max) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch < 48 || ch > 57) {
          return -1;
        }
        for (;;) {
          if (pos >= max) {
            return -1;
          }
          ch = state.src.charCodeAt(pos++);
          if (ch >= 48 && ch <= 57) {
            if (pos - start >= 10) {
              return -1;
            }
            continue;
          }
          if (ch === 41 || ch === 46) {
            break;
          }
          return -1;
        }
        if (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (!isSpace$7(ch)) {
            return -1;
          }
        }
        return pos;
      }
      function markTightParagraphs(state, idx) {
        var i, l, level = state.level + 2;
        for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
          if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
            state.tokens[i + 2].hidden = true;
            state.tokens[i].hidden = true;
            i += 2;
          }
        }
      }
      exports$p = function list(state, startLine, endLine, silent) {
        var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          return false;
        }
        if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
          return false;
        }
        if (silent && state.parentType === "paragraph") {
          if (state.sCount[startLine] >= state.blkIndent) {
            isTerminatingParagraph = true;
          }
        }
        if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
          isOrdered = true;
          start = state.bMarks[startLine] + state.tShift[startLine];
          markerValue = Number(state.src.slice(start, posAfterMarker - 1));
          if (isTerminatingParagraph && markerValue !== 1)
            return false;
        } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
          isOrdered = false;
        } else {
          return false;
        }
        if (isTerminatingParagraph) {
          if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
            return false;
        }
        markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
        if (silent) {
          return true;
        }
        listTokIdx = state.tokens.length;
        if (isOrdered) {
          token = state.push("ordered_list_open", "ol", 1);
          if (markerValue !== 1) {
            token.attrs = [[
                "start",
                markerValue
              ]];
          }
        } else {
          token = state.push("bullet_list_open", "ul", 1);
        }
        token.map = listLines = [
          startLine,
          0
        ];
        token.markup = String.fromCharCode(markerCharCode);
        nextLine = startLine;
        prevEmptyEnd = false;
        terminatorRules = state.md.block.ruler.getRules("list");
        oldParentType = state.parentType;
        state.parentType = "list";
        while (nextLine < endLine) {
          pos = posAfterMarker;
          max = state.eMarks[nextLine];
          initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (ch === 9) {
              offset += 4 - (offset + state.bsCount[nextLine]) % 4;
            } else if (ch === 32) {
              offset++;
            } else {
              break;
            }
            pos++;
          }
          contentStart = pos;
          if (contentStart >= max) {
            indentAfterMarker = 1;
          } else {
            indentAfterMarker = offset - initial;
          }
          if (indentAfterMarker > 4) {
            indentAfterMarker = 1;
          }
          indent = initial + indentAfterMarker;
          token = state.push("list_item_open", "li", 1);
          token.markup = String.fromCharCode(markerCharCode);
          token.map = itemLines = [
            startLine,
            0
          ];
          if (isOrdered) {
            token.info = state.src.slice(start, posAfterMarker - 1);
          }
          oldTight = state.tight;
          oldTShift = state.tShift[startLine];
          oldSCount = state.sCount[startLine];
          oldListIndent = state.listIndent;
          state.listIndent = state.blkIndent;
          state.blkIndent = indent;
          state.tight = true;
          state.tShift[startLine] = contentStart - state.bMarks[startLine];
          state.sCount[startLine] = offset;
          if (contentStart >= max && state.isEmpty(startLine + 1)) {
            state.line = Math.min(state.line + 2, endLine);
          } else {
            state.md.block.tokenize(state, startLine, endLine, true);
          }
          if (!state.tight || prevEmptyEnd) {
            tight = false;
          }
          prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
          state.blkIndent = state.listIndent;
          state.listIndent = oldListIndent;
          state.tShift[startLine] = oldTShift;
          state.sCount[startLine] = oldSCount;
          state.tight = oldTight;
          token = state.push("list_item_close", "li", -1);
          token.markup = String.fromCharCode(markerCharCode);
          nextLine = startLine = state.line;
          itemLines[1] = nextLine;
          contentStart = state.bMarks[startLine];
          if (nextLine >= endLine) {
            break;
          }
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          if (state.sCount[startLine] - state.blkIndent >= 4) {
            break;
          }
          terminate = false;
          for (i = 0, l = terminatorRules.length; i < l; i++) {
            if (terminatorRules[i](state, nextLine, endLine, true)) {
              terminate = true;
              break;
            }
          }
          if (terminate) {
            break;
          }
          if (isOrdered) {
            posAfterMarker = skipOrderedListMarker(state, nextLine);
            if (posAfterMarker < 0) {
              break;
            }
            start = state.bMarks[nextLine] + state.tShift[nextLine];
          } else {
            posAfterMarker = skipBulletListMarker(state, nextLine);
            if (posAfterMarker < 0) {
              break;
            }
          }
          if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
            break;
          }
        }
        if (isOrdered) {
          token = state.push("ordered_list_close", "ol", -1);
        } else {
          token = state.push("bullet_list_close", "ul", -1);
        }
        token.markup = String.fromCharCode(markerCharCode);
        listLines[1] = nextLine;
        state.line = nextLine;
        state.parentType = oldParentType;
        if (tight) {
          markTightParagraphs(state, listTokIdx);
        }
        return true;
      };
      var _list = exports$p;
      var exports$o = {};
      var normalizeReference$2 = exports$Q.normalizeReference;
      var isSpace$6 = exports$Q.isSpace;
      exports$o = function reference(state, startLine, _endLine, silent) {
        var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          return false;
        }
        if (state.src.charCodeAt(pos) !== 91) {
          return false;
        }
        while (++pos < max) {
          if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
            if (pos + 1 === max) {
              return false;
            }
            if (state.src.charCodeAt(pos + 1) !== 58) {
              return false;
            }
            break;
          }
        }
        endLine = state.lineMax;
        terminatorRules = state.md.block.ruler.getRules("reference");
        oldParentType = state.parentType;
        state.parentType = "reference";
        for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
          if (state.sCount[nextLine] - state.blkIndent > 3) {
            continue;
          }
          if (state.sCount[nextLine] < 0) {
            continue;
          }
          terminate = false;
          for (i = 0, l = terminatorRules.length; i < l; i++) {
            if (terminatorRules[i](state, nextLine, endLine, true)) {
              terminate = true;
              break;
            }
          }
          if (terminate) {
            break;
          }
        }
        str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
        max = str.length;
        for (pos = 1; pos < max; pos++) {
          ch = str.charCodeAt(pos);
          if (ch === 91) {
            return false;
          } else if (ch === 93) {
            labelEnd = pos;
            break;
          } else if (ch === 10) {
            lines++;
          } else if (ch === 92) {
            pos++;
            if (pos < max && str.charCodeAt(pos) === 10) {
              lines++;
            }
          }
        }
        if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
          return false;
        }
        for (pos = labelEnd + 2; pos < max; pos++) {
          ch = str.charCodeAt(pos);
          if (ch === 10) {
            lines++;
          } else if (isSpace$6(ch)) ; else {
            break;
          }
        }
        res = state.md.helpers.parseLinkDestination(str, pos, max);
        if (!res.ok) {
          return false;
        }
        href = state.md.normalizeLink(res.str);
        if (!state.md.validateLink(href)) {
          return false;
        }
        pos = res.pos;
        lines += res.lines;
        destEndPos = pos;
        destEndLineNo = lines;
        start = pos;
        for (; pos < max; pos++) {
          ch = str.charCodeAt(pos);
          if (ch === 10) {
            lines++;
          } else if (isSpace$6(ch)) ; else {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(str, pos, max);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          lines += res.lines;
        } else {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
        }
        while (pos < max) {
          ch = str.charCodeAt(pos);
          if (!isSpace$6(ch)) {
            break;
          }
          pos++;
        }
        if (pos < max && str.charCodeAt(pos) !== 10) {
          if (title) {
            title = "";
            pos = destEndPos;
            lines = destEndLineNo;
            while (pos < max) {
              ch = str.charCodeAt(pos);
              if (!isSpace$6(ch)) {
                break;
              }
              pos++;
            }
          }
        }
        if (pos < max && str.charCodeAt(pos) !== 10) {
          return false;
        }
        label = normalizeReference$2(str.slice(1, labelEnd));
        if (!label) {
          return false;
        }
        if (silent) {
          return true;
        }
        if (typeof state.env.references === "undefined") {
          state.env.references = {};
        }
        if (typeof state.env.references[label] === "undefined") {
          state.env.references[label] = {
            title: title,
            href: href
          };
        }
        state.parentType = oldParentType;
        state.line = startLine + lines + 1;
        return true;
      };
      var _reference = exports$o;
      var exports$n = {};
      var block_names = _html_blocks;
      var HTML_OPEN_CLOSE_TAG_RE = exports$L.HTML_OPEN_CLOSE_TAG_RE;
      var HTML_SEQUENCES = [
        [
          /^<(script|pre|style|textarea)(?=(\s|>|$))/i,
          /<\/(script|pre|style|textarea)>/i,
          true
        ],
        [
          /^<!--/,
          /-->/,
          true
        ],
        [
          /^<\?/,
          /\?>/,
          true
        ],
        [
          /^<![A-Z]/,
          />/,
          true
        ],
        [
          /^<!\[CDATA\[/,
          /\]\]>/,
          true
        ],
        [
          new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"),
          /^$/,
          true
        ],
        [
          new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"),
          /^$/,
          false
        ]
      ];
      exports$n = function html_block(state, startLine, endLine, silent) {
        var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          return false;
        }
        if (!state.md.options.html) {
          return false;
        }
        if (state.src.charCodeAt(pos) !== 60) {
          return false;
        }
        lineText = state.src.slice(pos, max);
        for (i = 0; i < HTML_SEQUENCES.length; i++) {
          if (HTML_SEQUENCES[i][0].test(lineText)) {
            break;
          }
        }
        if (i === HTML_SEQUENCES.length) {
          return false;
        }
        if (silent) {
          return HTML_SEQUENCES[i][2];
        }
        nextLine = startLine + 1;
        if (!HTML_SEQUENCES[i][1].test(lineText)) {
          for (; nextLine < endLine; nextLine++) {
            if (state.sCount[nextLine] < state.blkIndent) {
              break;
            }
            pos = state.bMarks[nextLine] + state.tShift[nextLine];
            max = state.eMarks[nextLine];
            lineText = state.src.slice(pos, max);
            if (HTML_SEQUENCES[i][1].test(lineText)) {
              if (lineText.length !== 0) {
                nextLine++;
              }
              break;
            }
          }
        }
        state.line = nextLine;
        token = state.push("html_block", "", 0);
        token.map = [
          startLine,
          nextLine
        ];
        token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
        return true;
      };
      var _html_block = exports$n;
      var exports$m = {};
      var isSpace$5 = exports$Q.isSpace;
      exports$m = function heading(state, startLine, endLine, silent) {
        var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          return false;
        }
        ch = state.src.charCodeAt(pos);
        if (ch !== 35 || pos >= max) {
          return false;
        }
        level = 1;
        ch = state.src.charCodeAt(++pos);
        while (ch === 35 && pos < max && level <= 6) {
          level++;
          ch = state.src.charCodeAt(++pos);
        }
        if (level > 6 || pos < max && !isSpace$5(ch)) {
          return false;
        }
        if (silent) {
          return true;
        }
        max = state.skipSpacesBack(max, pos);
        tmp = state.skipCharsBack(max, 35, pos);
        if (tmp > pos && isSpace$5(state.src.charCodeAt(tmp - 1))) {
          max = tmp;
        }
        state.line = startLine + 1;
        token = state.push("heading_open", "h" + String(level), 1);
        token.markup = "########".slice(0, level);
        token.map = [
          startLine,
          state.line
        ];
        token = state.push("inline", "", 0);
        token.content = state.src.slice(pos, max).trim();
        token.map = [
          startLine,
          state.line
        ];
        token.children = [];
        token = state.push("heading_close", "h" + String(level), -1);
        token.markup = "########".slice(0, level);
        return true;
      };
      var _heading = exports$m;
      var exports$l = {};
      exports$l = function lheading(state, startLine, endLine) {
        var content, terminate, i, l, token, pos, max, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          return false;
        }
        oldParentType = state.parentType;
        state.parentType = "paragraph";
        for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
          if (state.sCount[nextLine] - state.blkIndent > 3) {
            continue;
          }
          if (state.sCount[nextLine] >= state.blkIndent) {
            pos = state.bMarks[nextLine] + state.tShift[nextLine];
            max = state.eMarks[nextLine];
            if (pos < max) {
              marker = state.src.charCodeAt(pos);
              if (marker === 45 || marker === 61) {
                pos = state.skipChars(pos, marker);
                pos = state.skipSpaces(pos);
                if (pos >= max) {
                  level = marker === 61 ? 1 : 2;
                  break;
                }
              }
            }
          }
          if (state.sCount[nextLine] < 0) {
            continue;
          }
          terminate = false;
          for (i = 0, l = terminatorRules.length; i < l; i++) {
            if (terminatorRules[i](state, nextLine, endLine, true)) {
              terminate = true;
              break;
            }
          }
          if (terminate) {
            break;
          }
        }
        if (!level) {
          return false;
        }
        content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
        state.line = nextLine + 1;
        token = state.push("heading_open", "h" + String(level), 1);
        token.markup = String.fromCharCode(marker);
        token.map = [
          startLine,
          state.line
        ];
        token = state.push("inline", "", 0);
        token.content = content;
        token.map = [
          startLine,
          state.line - 1
        ];
        token.children = [];
        token = state.push("heading_close", "h" + String(level), -1);
        token.markup = String.fromCharCode(marker);
        state.parentType = oldParentType;
        return true;
      };
      var _lheading = exports$l;
      var exports$k = {};
      exports$k = function paragraph(state, startLine) {
        var content, terminate, i, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
        oldParentType = state.parentType;
        state.parentType = "paragraph";
        for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
          if (state.sCount[nextLine] - state.blkIndent > 3) {
            continue;
          }
          if (state.sCount[nextLine] < 0) {
            continue;
          }
          terminate = false;
          for (i = 0, l = terminatorRules.length; i < l; i++) {
            if (terminatorRules[i](state, nextLine, endLine, true)) {
              terminate = true;
              break;
            }
          }
          if (terminate) {
            break;
          }
        }
        content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
        state.line = nextLine;
        token = state.push("paragraph_open", "p", 1);
        token.map = [
          startLine,
          state.line
        ];
        token = state.push("inline", "", 0);
        token.content = content;
        token.map = [
          startLine,
          state.line
        ];
        token.children = [];
        token = state.push("paragraph_close", "p", -1);
        state.parentType = oldParentType;
        return true;
      };
      var _paragraph = exports$k;
      var exports$j = {};
      var Token = _token;
      var isSpace$4 = exports$Q.isSpace;
      function StateBlock(src, md, env, tokens) {
        var ch, s, start, pos, len, indent, offset, indent_found;
        this.src = src;
        this.md = md;
        this.env = env;
        this.tokens = tokens;
        this.bMarks = [];
        this.eMarks = [];
        this.tShift = [];
        this.sCount = [];
        this.bsCount = [];
        this.blkIndent = 0;
        this.line = 0;
        this.lineMax = 0;
        this.tight = false;
        this.ddIndent = -1;
        this.listIndent = -1;
        this.parentType = "root";
        this.level = 0;
        this.result = "";
        s = this.src;
        indent_found = false;
        for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
          ch = s.charCodeAt(pos);
          if (!indent_found) {
            if (isSpace$4(ch)) {
              indent++;
              if (ch === 9) {
                offset += 4 - offset % 4;
              } else {
                offset++;
              }
              continue;
            } else {
              indent_found = true;
            }
          }
          if (ch === 10 || pos === len - 1) {
            if (ch !== 10) {
              pos++;
            }
            this.bMarks.push(start);
            this.eMarks.push(pos);
            this.tShift.push(indent);
            this.sCount.push(offset);
            this.bsCount.push(0);
            indent_found = false;
            indent = 0;
            offset = 0;
            start = pos + 1;
          }
        }
        this.bMarks.push(s.length);
        this.eMarks.push(s.length);
        this.tShift.push(0);
        this.sCount.push(0);
        this.bsCount.push(0);
        this.lineMax = this.bMarks.length - 1;
      }
      StateBlock.prototype.push = function (type, tag, nesting) {
        var token = new Token(type, tag, nesting);
        token.block = true;
        if (nesting < 0)
          this.level--;
        token.level = this.level;
        if (nesting > 0)
          this.level++;
        this.tokens.push(token);
        return token;
      };
      StateBlock.prototype.isEmpty = function isEmpty(line) {
        return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
      };
      StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
        for (var max = this.lineMax; from < max; from++) {
          if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
            break;
          }
        }
        return from;
      };
      StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
        var ch;
        for (var max = this.src.length; pos < max; pos++) {
          ch = this.src.charCodeAt(pos);
          if (!isSpace$4(ch)) {
            break;
          }
        }
        return pos;
      };
      StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
        if (pos <= min) {
          return pos;
        }
        while (pos > min) {
          if (!isSpace$4(this.src.charCodeAt(--pos))) {
            return pos + 1;
          }
        }
        return pos;
      };
      StateBlock.prototype.skipChars = function skipChars(pos, code) {
        for (var max = this.src.length; pos < max; pos++) {
          if (this.src.charCodeAt(pos) !== code) {
            break;
          }
        }
        return pos;
      };
      StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
        if (pos <= min) {
          return pos;
        }
        while (pos > min) {
          if (code !== this.src.charCodeAt(--pos)) {
            return pos + 1;
          }
        }
        return pos;
      };
      StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
        var i, lineIndent, ch, first, last, queue, lineStart, line = begin;
        if (begin >= end) {
          return "";
        }
        queue = new Array(end - begin);
        for (i = 0; line < end; line++, i++) {
          lineIndent = 0;
          lineStart = first = this.bMarks[line];
          if (line + 1 < end || keepLastLF) {
            last = this.eMarks[line] + 1;
          } else {
            last = this.eMarks[line];
          }
          while (first < last && lineIndent < indent) {
            ch = this.src.charCodeAt(first);
            if (isSpace$4(ch)) {
              if (ch === 9) {
                lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
              } else {
                lineIndent++;
              }
            } else if (first - lineStart < this.tShift[line]) {
              lineIndent++;
            } else {
              break;
            }
            first++;
          }
          if (lineIndent > indent) {
            queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
          } else {
            queue[i] = this.src.slice(first, last);
          }
        }
        return queue.join("");
      };
      StateBlock.prototype.Token = Token;
      exports$j = StateBlock;
      var _state_block = exports$j;
      var exports$i = {};
      var Ruler$1 = _ruler;
      var _rules$1 = [
        [
          "table",
          _table,
          [
            "paragraph",
            "reference"
          ]
        ],
        [
          "code",
          _code
        ],
        [
          "fence",
          _fence,
          [
            "paragraph",
            "reference",
            "blockquote",
            "list"
          ]
        ],
        [
          "blockquote",
          _blockquote,
          [
            "paragraph",
            "reference",
            "blockquote",
            "list"
          ]
        ],
        [
          "hr",
          _hr,
          [
            "paragraph",
            "reference",
            "blockquote",
            "list"
          ]
        ],
        [
          "list",
          _list,
          [
            "paragraph",
            "reference",
            "blockquote"
          ]
        ],
        [
          "reference",
          _reference
        ],
        [
          "html_block",
          _html_block,
          [
            "paragraph",
            "reference",
            "blockquote"
          ]
        ],
        [
          "heading",
          _heading,
          [
            "paragraph",
            "reference",
            "blockquote"
          ]
        ],
        [
          "lheading",
          _lheading
        ],
        [
          "paragraph",
          _paragraph
        ]
      ];
      function ParserBlock$1() {
        this.ruler = new Ruler$1();
        for (var i = 0; i < _rules$1.length; i++) {
          this.ruler.push(_rules$1[i][0], _rules$1[i][1], { alt: (_rules$1[i][2] || []).slice() });
        }
      }
      ParserBlock$1.prototype.tokenize = function (state, startLine, endLine) {
        var ok, i, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
        while (line < endLine) {
          state.line = line = state.skipEmptyLines(line);
          if (line >= endLine) {
            break;
          }
          if (state.sCount[line] < state.blkIndent) {
            break;
          }
          if (state.level >= maxNesting) {
            state.line = endLine;
            break;
          }
          for (i = 0; i < len; i++) {
            ok = rules[i](state, line, endLine, false);
            if (ok) {
              break;
            }
          }
          state.tight = !hasEmptyLines;
          if (state.isEmpty(state.line - 1)) {
            hasEmptyLines = true;
          }
          line = state.line;
          if (line < endLine && state.isEmpty(line)) {
            hasEmptyLines = true;
            line++;
            state.line = line;
          }
        }
      };
      ParserBlock$1.prototype.parse = function (src, md, env, outTokens) {
        var state;
        if (!src) {
          return;
        }
        state = new this.State(src, md, env, outTokens);
        this.tokenize(state, state.line, state.lineMax);
      };
      ParserBlock$1.prototype.State = _state_block;
      exports$i = ParserBlock$1;
      var _parser_block = exports$i;
      var exports$h = {};
      function isTerminatorChar(ch) {
        switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
        }
      }
      exports$h = function text(state, silent) {
        var pos = state.pos;
        while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
          pos++;
        }
        if (pos === state.pos) {
          return false;
        }
        if (!silent) {
          state.pending += state.src.slice(state.pos, pos);
        }
        state.pos = pos;
        return true;
      };
      var _text = exports$h;
      var exports$g = {};
      var isSpace$3 = exports$Q.isSpace;
      exports$g = function newline(state, silent) {
        var pmax, max, ws, pos = state.pos;
        if (state.src.charCodeAt(pos) !== 10) {
          return false;
        }
        pmax = state.pending.length - 1;
        max = state.posMax;
        if (!silent) {
          if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
            if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
              ws = pmax - 1;
              while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
                ws--;
              state.pending = state.pending.slice(0, ws);
              state.push("hardbreak", "br", 0);
            } else {
              state.pending = state.pending.slice(0, -1);
              state.push("softbreak", "br", 0);
            }
          } else {
            state.push("softbreak", "br", 0);
          }
        }
        pos++;
        while (pos < max && isSpace$3(state.src.charCodeAt(pos))) {
          pos++;
        }
        state.pos = pos;
        return true;
      };
      var _newline = exports$g;
      var exports$f = {};
      var isSpace$2 = exports$Q.isSpace;
      var ESCAPED = [];
      for (var i = 0; i < 256; i++) {
        ESCAPED.push(0);
      }
      "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function (ch) {
        ESCAPED[ch.charCodeAt(0)] = 1;
      });
      exports$f = function escape(state, silent) {
        var ch, pos = state.pos, max = state.posMax;
        if (state.src.charCodeAt(pos) !== 92) {
          return false;
        }
        pos++;
        if (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (ch < 256 && ESCAPED[ch] !== 0) {
            if (!silent) {
              state.pending += state.src[pos];
            }
            state.pos += 2;
            return true;
          }
          if (ch === 10) {
            if (!silent) {
              state.push("hardbreak", "br", 0);
            }
            pos++;
            while (pos < max) {
              ch = state.src.charCodeAt(pos);
              if (!isSpace$2(ch)) {
                break;
              }
              pos++;
            }
            state.pos = pos;
            return true;
          }
        }
        if (!silent) {
          state.pending += "\\";
        }
        state.pos++;
        return true;
      };
      var _escape = exports$f;
      var exports$e = {};
      exports$e = function backtick(state, silent) {
        var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
        if (ch !== 96) {
          return false;
        }
        start = pos;
        pos++;
        max = state.posMax;
        while (pos < max && state.src.charCodeAt(pos) === 96) {
          pos++;
        }
        marker = state.src.slice(start, pos);
        openerLength = marker.length;
        if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
          if (!silent)
            state.pending += marker;
          state.pos += openerLength;
          return true;
        }
        matchStart = matchEnd = pos;
        while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
          matchEnd = matchStart + 1;
          while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
            matchEnd++;
          }
          closerLength = matchEnd - matchStart;
          if (closerLength === openerLength) {
            if (!silent) {
              token = state.push("code_inline", "code", 0);
              token.markup = marker;
              token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
            }
            state.pos = matchEnd;
            return true;
          }
          state.backticks[closerLength] = matchStart;
        }
        state.backticksScanned = true;
        if (!silent)
          state.pending += marker;
        state.pos += openerLength;
        return true;
      };
      var _backticks = exports$e;
      var exports$d = {};
      exports$d.tokenize = function strikethrough(state, silent) {
        var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
        if (silent) {
          return false;
        }
        if (marker !== 126) {
          return false;
        }
        scanned = state.scanDelims(state.pos, true);
        len = scanned.length;
        ch = String.fromCharCode(marker);
        if (len < 2) {
          return false;
        }
        if (len % 2) {
          token = state.push("text", "", 0);
          token.content = ch;
          len--;
        }
        for (i = 0; i < len; i += 2) {
          token = state.push("text", "", 0);
          token.content = ch + ch;
          state.delimiters.push({
            marker: marker,
            length: 0,
            token: state.tokens.length - 1,
            end: -1,
            open: scanned.can_open,
            close: scanned.can_close
          });
        }
        state.pos += scanned.length;
        return true;
      };
      function postProcess$1(state, delimiters) {
        var i, j, startDelim, endDelim, token, loneMarkers = [], max = delimiters.length;
        for (i = 0; i < max; i++) {
          startDelim = delimiters[i];
          if (startDelim.marker !== 126) {
            continue;
          }
          if (startDelim.end === -1) {
            continue;
          }
          endDelim = delimiters[startDelim.end];
          token = state.tokens[startDelim.token];
          token.type = "s_open";
          token.tag = "s";
          token.nesting = 1;
          token.markup = "~~";
          token.content = "";
          token = state.tokens[endDelim.token];
          token.type = "s_close";
          token.tag = "s";
          token.nesting = -1;
          token.markup = "~~";
          token.content = "";
          if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
            loneMarkers.push(endDelim.token - 1);
          }
        }
        while (loneMarkers.length) {
          i = loneMarkers.pop();
          j = i + 1;
          while (j < state.tokens.length && state.tokens[j].type === "s_close") {
            j++;
          }
          j--;
          if (i !== j) {
            token = state.tokens[j];
            state.tokens[j] = state.tokens[i];
            state.tokens[i] = token;
          }
        }
      }
      exports$d.postProcess = function strikethrough(state) {
        var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
        postProcess$1(state, state.delimiters);
        for (curr = 0; curr < max; curr++) {
          if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
            postProcess$1(state, tokens_meta[curr].delimiters);
          }
        }
      };
      var exports$c = {};
      exports$c.tokenize = function emphasis(state, silent) {
        var i, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);
        if (silent) {
          return false;
        }
        if (marker !== 95 && marker !== 42) {
          return false;
        }
        scanned = state.scanDelims(state.pos, marker === 42);
        for (i = 0; i < scanned.length; i++) {
          token = state.push("text", "", 0);
          token.content = String.fromCharCode(marker);
          state.delimiters.push({
            marker: marker,
            length: scanned.length,
            token: state.tokens.length - 1,
            end: -1,
            open: scanned.can_open,
            close: scanned.can_close
          });
        }
        state.pos += scanned.length;
        return true;
      };
      function postProcess(state, delimiters) {
        var i, startDelim, endDelim, token, ch, isStrong, max = delimiters.length;
        for (i = max - 1; i >= 0; i--) {
          startDelim = delimiters[i];
          if (startDelim.marker !== 95 && startDelim.marker !== 42) {
            continue;
          }
          if (startDelim.end === -1) {
            continue;
          }
          endDelim = delimiters[startDelim.end];
          isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
          ch = String.fromCharCode(startDelim.marker);
          token = state.tokens[startDelim.token];
          token.type = isStrong ? "strong_open" : "em_open";
          token.tag = isStrong ? "strong" : "em";
          token.nesting = 1;
          token.markup = isStrong ? ch + ch : ch;
          token.content = "";
          token = state.tokens[endDelim.token];
          token.type = isStrong ? "strong_close" : "em_close";
          token.tag = isStrong ? "strong" : "em";
          token.nesting = -1;
          token.markup = isStrong ? ch + ch : ch;
          token.content = "";
          if (isStrong) {
            state.tokens[delimiters[i - 1].token].content = "";
            state.tokens[delimiters[startDelim.end + 1].token].content = "";
            i--;
          }
        }
      }
      exports$c.postProcess = function emphasis(state) {
        var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
        postProcess(state, state.delimiters);
        for (curr = 0; curr < max; curr++) {
          if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
            postProcess(state, tokens_meta[curr].delimiters);
          }
        }
      };
      var exports$b = {};
      var normalizeReference$1 = exports$Q.normalizeReference;
      var isSpace$1 = exports$Q.isSpace;
      exports$b = function link(state, silent) {
        var attrs, code, label, labelEnd, labelStart, pos, res, ref, token, href = "", title = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
        if (state.src.charCodeAt(state.pos) !== 91) {
          return false;
        }
        labelStart = state.pos + 1;
        labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
        if (labelEnd < 0) {
          return false;
        }
        pos = labelEnd + 1;
        if (pos < max && state.src.charCodeAt(pos) === 40) {
          parseReference = false;
          pos++;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace$1(code) && code !== 10) {
              break;
            }
          }
          if (pos >= max) {
            return false;
          }
          start = pos;
          res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
          if (res.ok) {
            href = state.md.normalizeLink(res.str);
            if (state.md.validateLink(href)) {
              pos = res.pos;
            } else {
              href = "";
            }
            start = pos;
            for (; pos < max; pos++) {
              code = state.src.charCodeAt(pos);
              if (!isSpace$1(code) && code !== 10) {
                break;
              }
            }
            res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
            if (pos < max && start !== pos && res.ok) {
              title = res.str;
              pos = res.pos;
              for (; pos < max; pos++) {
                code = state.src.charCodeAt(pos);
                if (!isSpace$1(code) && code !== 10) {
                  break;
                }
              }
            }
          }
          if (pos >= max || state.src.charCodeAt(pos) !== 41) {
            parseReference = true;
          }
          pos++;
        }
        if (parseReference) {
          if (typeof state.env.references === "undefined") {
            return false;
          }
          if (pos < max && state.src.charCodeAt(pos) === 91) {
            start = pos + 1;
            pos = state.md.helpers.parseLinkLabel(state, pos);
            if (pos >= 0) {
              label = state.src.slice(start, pos++);
            } else {
              pos = labelEnd + 1;
            }
          } else {
            pos = labelEnd + 1;
          }
          if (!label) {
            label = state.src.slice(labelStart, labelEnd);
          }
          ref = state.env.references[normalizeReference$1(label)];
          if (!ref) {
            state.pos = oldPos;
            return false;
          }
          href = ref.href;
          title = ref.title;
        }
        if (!silent) {
          state.pos = labelStart;
          state.posMax = labelEnd;
          token = state.push("link_open", "a", 1);
          token.attrs = attrs = [[
              "href",
              href
            ]];
          if (title) {
            attrs.push([
              "title",
              title
            ]);
          }
          state.md.inline.tokenize(state);
          token = state.push("link_close", "a", -1);
        }
        state.pos = pos;
        state.posMax = max;
        return true;
      };
      var _link = exports$b;
      var exports$a = {};
      var normalizeReference = exports$Q.normalizeReference;
      var isSpace = exports$Q.isSpace;
      exports$a = function image(state, silent) {
        var attrs, code, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
        if (state.src.charCodeAt(state.pos) !== 33) {
          return false;
        }
        if (state.src.charCodeAt(state.pos + 1) !== 91) {
          return false;
        }
        labelStart = state.pos + 2;
        labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
        if (labelEnd < 0) {
          return false;
        }
        pos = labelEnd + 1;
        if (pos < max && state.src.charCodeAt(pos) === 40) {
          pos++;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
          if (pos >= max) {
            return false;
          }
          start = pos;
          res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
          if (res.ok) {
            href = state.md.normalizeLink(res.str);
            if (state.md.validateLink(href)) {
              pos = res.pos;
            } else {
              href = "";
            }
          }
          start = pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max && start !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max; pos++) {
              code = state.src.charCodeAt(pos);
              if (!isSpace(code) && code !== 10) {
                break;
              }
            }
          } else {
            title = "";
          }
          if (pos >= max || state.src.charCodeAt(pos) !== 41) {
            state.pos = oldPos;
            return false;
          }
          pos++;
        } else {
          if (typeof state.env.references === "undefined") {
            return false;
          }
          if (pos < max && state.src.charCodeAt(pos) === 91) {
            start = pos + 1;
            pos = state.md.helpers.parseLinkLabel(state, pos);
            if (pos >= 0) {
              label = state.src.slice(start, pos++);
            } else {
              pos = labelEnd + 1;
            }
          } else {
            pos = labelEnd + 1;
          }
          if (!label) {
            label = state.src.slice(labelStart, labelEnd);
          }
          ref = state.env.references[normalizeReference(label)];
          if (!ref) {
            state.pos = oldPos;
            return false;
          }
          href = ref.href;
          title = ref.title;
        }
        if (!silent) {
          content = state.src.slice(labelStart, labelEnd);
          state.md.inline.parse(content, state.md, state.env, tokens = []);
          token = state.push("image", "img", 0);
          token.attrs = attrs = [
            [
              "src",
              href
            ],
            [
              "alt",
              ""
            ]
          ];
          token.children = tokens;
          token.content = content;
          if (title) {
            attrs.push([
              "title",
              title
            ]);
          }
        }
        state.pos = pos;
        state.posMax = max;
        return true;
      };
      var _image = exports$a;
      var exports$9 = {};
      var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
      var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
      exports$9 = function autolink(state, silent) {
        var url, fullUrl, token, ch, start, max, pos = state.pos;
        if (state.src.charCodeAt(pos) !== 60) {
          return false;
        }
        start = state.pos;
        max = state.posMax;
        for (;;) {
          if (++pos >= max)
            return false;
          ch = state.src.charCodeAt(pos);
          if (ch === 60)
            return false;
          if (ch === 62)
            break;
        }
        url = state.src.slice(start + 1, pos);
        if (AUTOLINK_RE.test(url)) {
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            return false;
          }
          if (!silent) {
            token = state.push("link_open", "a", 1);
            token.attrs = [[
                "href",
                fullUrl
              ]];
            token.markup = "autolink";
            token.info = "auto";
            token = state.push("text", "", 0);
            token.content = state.md.normalizeLinkText(url);
            token = state.push("link_close", "a", -1);
            token.markup = "autolink";
            token.info = "auto";
          }
          state.pos += url.length + 2;
          return true;
        }
        if (EMAIL_RE.test(url)) {
          fullUrl = state.md.normalizeLink("mailto:" + url);
          if (!state.md.validateLink(fullUrl)) {
            return false;
          }
          if (!silent) {
            token = state.push("link_open", "a", 1);
            token.attrs = [[
                "href",
                fullUrl
              ]];
            token.markup = "autolink";
            token.info = "auto";
            token = state.push("text", "", 0);
            token.content = state.md.normalizeLinkText(url);
            token = state.push("link_close", "a", -1);
            token.markup = "autolink";
            token.info = "auto";
          }
          state.pos += url.length + 2;
          return true;
        }
        return false;
      };
      var _autolink = exports$9;
      var exports$8$1 = {};
      var HTML_TAG_RE = exports$L.HTML_TAG_RE;
      function isLetter(ch) {
        var lc = ch | 32;
        return lc >= 97 && lc <= 122;
      }
      exports$8$1 = function html_inline(state, silent) {
        var ch, match, max, token, pos = state.pos;
        if (!state.md.options.html) {
          return false;
        }
        max = state.posMax;
        if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
          return false;
        }
        ch = state.src.charCodeAt(pos + 1);
        if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
          return false;
        }
        match = state.src.slice(pos).match(HTML_TAG_RE);
        if (!match) {
          return false;
        }
        if (!silent) {
          token = state.push("html_inline", "", 0);
          token.content = state.src.slice(pos, pos + match[0].length);
        }
        state.pos += match[0].length;
        return true;
      };
      var _html_inline = exports$8$1;
      var exports$7$1 = {};
      var entities = _entities;
      var has = exports$Q.has;
      var isValidEntityCode = exports$Q.isValidEntityCode;
      var fromCodePoint$1 = exports$Q.fromCodePoint;
      var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
      var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
      exports$7$1 = function entity(state, silent) {
        var ch, code, match, pos = state.pos, max = state.posMax;
        if (state.src.charCodeAt(pos) !== 38) {
          return false;
        }
        if (pos + 1 < max) {
          ch = state.src.charCodeAt(pos + 1);
          if (ch === 35) {
            match = state.src.slice(pos).match(DIGITAL_RE);
            if (match) {
              if (!silent) {
                code = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
                state.pending += isValidEntityCode(code) ? fromCodePoint$1(code) : fromCodePoint$1(65533);
              }
              state.pos += match[0].length;
              return true;
            }
          } else {
            match = state.src.slice(pos).match(NAMED_RE);
            if (match) {
              if (has(entities, match[1])) {
                if (!silent) {
                  state.pending += entities[match[1]];
                }
                state.pos += match[0].length;
                return true;
              }
            }
          }
        }
        if (!silent) {
          state.pending += "&";
        }
        state.pos++;
        return true;
      };
      var _entity = exports$7$1;
      var exports$6$1 = {};
      function processDelimiters(state, delimiters) {
        var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
        if (!max)
          return;
        var headerIdx = 0;
        var lastTokenIdx = -2;
        var jumps = [];
        for (closerIdx = 0; closerIdx < max; closerIdx++) {
          closer = delimiters[closerIdx];
          jumps.push(0);
          if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
            headerIdx = closerIdx;
          }
          lastTokenIdx = closer.token;
          closer.length = closer.length || 0;
          if (!closer.close)
            continue;
          if (!openersBottom.hasOwnProperty(closer.marker)) {
            openersBottom[closer.marker] = [
              -1,
              -1,
              -1,
              -1,
              -1,
              -1
            ];
          }
          minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
          openerIdx = headerIdx - jumps[headerIdx] - 1;
          newMinOpenerIdx = openerIdx;
          for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
            opener = delimiters[openerIdx];
            if (opener.marker !== closer.marker)
              continue;
            if (opener.open && opener.end < 0) {
              isOddMatch = false;
              if (opener.close || closer.open) {
                if ((opener.length + closer.length) % 3 === 0) {
                  if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                    isOddMatch = true;
                  }
                }
              }
              if (!isOddMatch) {
                lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
                jumps[closerIdx] = closerIdx - openerIdx + lastJump;
                jumps[openerIdx] = lastJump;
                closer.open = false;
                opener.end = closerIdx;
                opener.close = false;
                newMinOpenerIdx = -1;
                lastTokenIdx = -2;
                break;
              }
            }
          }
          if (newMinOpenerIdx !== -1) {
            openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
          }
        }
      }
      exports$6$1 = function link_pairs(state) {
        var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
        processDelimiters(state, state.delimiters);
        for (curr = 0; curr < max; curr++) {
          if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
            processDelimiters(state, tokens_meta[curr].delimiters);
          }
        }
      };
      var _balance_pairs = exports$6$1;
      var exports$5$1 = {};
      exports$5$1 = function text_collapse(state) {
        var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
        for (curr = last = 0; curr < max; curr++) {
          if (tokens[curr].nesting < 0)
            level--;
          tokens[curr].level = level;
          if (tokens[curr].nesting > 0)
            level++;
          if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
            tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
          } else {
            if (curr !== last) {
              tokens[last] = tokens[curr];
            }
            last++;
          }
        }
        if (curr !== last) {
          tokens.length = last;
        }
      };
      var _text_collapse = exports$5$1;
      var exports$4$1 = {};
      var Ruler = _ruler;
      var _rules = [
        [
          "text",
          _text
        ],
        [
          "newline",
          _newline
        ],
        [
          "escape",
          _escape
        ],
        [
          "backticks",
          _backticks
        ],
        [
          "strikethrough",
          exports$d.tokenize
        ],
        [
          "emphasis",
          exports$c.tokenize
        ],
        [
          "link",
          _link
        ],
        [
          "image",
          _image
        ],
        [
          "autolink",
          _autolink
        ],
        [
          "html_inline",
          _html_inline
        ],
        [
          "entity",
          _entity
        ]
      ];
      var _rules2 = [
        [
          "balance_pairs",
          _balance_pairs
        ],
        [
          "strikethrough",
          exports$d.postProcess
        ],
        [
          "emphasis",
          exports$c.postProcess
        ],
        [
          "text_collapse",
          _text_collapse
        ]
      ];
      function ParserInline$1() {
        var i;
        this.ruler = new Ruler();
        for (i = 0; i < _rules.length; i++) {
          this.ruler.push(_rules[i][0], _rules[i][1]);
        }
        this.ruler2 = new Ruler();
        for (i = 0; i < _rules2.length; i++) {
          this.ruler2.push(_rules2[i][0], _rules2[i][1]);
        }
      }
      ParserInline$1.prototype.skipToken = function (state) {
        var ok, i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
        if (typeof cache[pos] !== "undefined") {
          state.pos = cache[pos];
          return;
        }
        if (state.level < maxNesting) {
          for (i = 0; i < len; i++) {
            state.level++;
            ok = rules[i](state, true);
            state.level--;
            if (ok) {
              break;
            }
          }
        } else {
          state.pos = state.posMax;
        }
        if (!ok) {
          state.pos++;
        }
        cache[pos] = state.pos;
      };
      ParserInline$1.prototype.tokenize = function (state) {
        var ok, i, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
        while (state.pos < end) {
          if (state.level < maxNesting) {
            for (i = 0; i < len; i++) {
              ok = rules[i](state, false);
              if (ok) {
                break;
              }
            }
          }
          if (ok) {
            if (state.pos >= end) {
              break;
            }
            continue;
          }
          state.pending += state.src[state.pos++];
        }
        if (state.pending) {
          state.pushPending();
        }
      };
      ParserInline$1.prototype.parse = function (str, md, env, outTokens) {
        var i, rules, len;
        var state = new this.State(str, md, env, outTokens);
        this.tokenize(state);
        rules = this.ruler2.getRules("");
        len = rules.length;
        for (i = 0; i < len; i++) {
          rules[i](state);
        }
      };
      ParserInline$1.prototype.State = _state_inline;
      exports$4$1 = ParserInline$1;
      var _parser_inline = exports$4$1;
      var exports$3$1 = {};
      exports$3$1 = {
        options: {
          html: false,
          xhtmlOut: false,
          breaks: false,
          langPrefix: "language-",
          linkify: false,
          typographer: false,
          quotes: "\u201C\u201D\u2018\u2019",
          highlight: null,
          maxNesting: 20
        },
        components: {
          core: {
            rules: [
              "normalize",
              "block",
              "inline"
            ]
          },
          block: { rules: ["paragraph"] },
          inline: {
            rules: ["text"],
            rules2: [
              "balance_pairs",
              "text_collapse"
            ]
          }
        }
      };
      var _zero = exports$3$1;
      var exports$2$1 = {};
      exports$2$1 = {
        options: {
          html: true,
          xhtmlOut: true,
          breaks: false,
          langPrefix: "language-",
          linkify: false,
          typographer: false,
          quotes: "\u201C\u201D\u2018\u2019",
          highlight: null,
          maxNesting: 20
        },
        components: {
          core: {
            rules: [
              "normalize",
              "block",
              "inline"
            ]
          },
          block: {
            rules: [
              "blockquote",
              "code",
              "fence",
              "heading",
              "hr",
              "html_block",
              "lheading",
              "list",
              "reference",
              "paragraph"
            ]
          },
          inline: {
            rules: [
              "autolink",
              "backticks",
              "emphasis",
              "entity",
              "escape",
              "html_inline",
              "image",
              "link",
              "newline",
              "text"
            ],
            rules2: [
              "balance_pairs",
              "emphasis",
              "text_collapse"
            ]
          }
        }
      };
      var _commonmark = exports$2$1;
      var _linkifyIt = "default" in _linkifyIt2 ? exports$1$6 : _linkifyIt2;
      var _mdurl = "default" in _mdurl2 ? exports$1$7 : _mdurl2;
      var _punycode = "default" in _punycode2 ? p : _punycode2;
      var exports$H = {};
      var utils$1 = exports$Q;
      var helpers$1 = exports$E;
      var Renderer = _renderer;
      var ParserCore = _parser_core;
      var ParserBlock = _parser_block;
      var ParserInline = _parser_inline;
      var LinkifyIt = _linkifyIt;
      var mdurl = _mdurl;
      var punycode = _punycode;
      var config = {
        default: _default,
        zero: _zero,
        commonmark: _commonmark
      };
      var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
      var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
      function validateLink(url) {
        var str = url.trim().toLowerCase();
        return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
      }
      var RECODE_HOSTNAME_FOR = [
        "http:",
        "https:",
        "mailto:"
      ];
      function normalizeLink(url) {
        var parsed = mdurl.parse(url, true);
        if (parsed.hostname) {
          if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
            try {
              parsed.hostname = punycode.toASCII(parsed.hostname);
            } catch (er) {
            }
          }
        }
        return mdurl.encode(mdurl.format(parsed));
      }
      function normalizeLinkText(url) {
        var parsed = mdurl.parse(url, true);
        if (parsed.hostname) {
          if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
            try {
              parsed.hostname = punycode.toUnicode(parsed.hostname);
            } catch (er) {
            }
          }
        }
        return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
      }
      function MarkdownIt(presetName, options) {
        if (!(this instanceof MarkdownIt)) {
          return new MarkdownIt(presetName, options);
        }
        if (!options) {
          if (!utils$1.isString(presetName)) {
            options = presetName || {};
            presetName = "default";
          }
        }
        this.inline = new ParserInline();
        this.block = new ParserBlock();
        this.core = new ParserCore();
        this.renderer = new Renderer();
        this.linkify = new LinkifyIt();
        this.validateLink = validateLink;
        this.normalizeLink = normalizeLink;
        this.normalizeLinkText = normalizeLinkText;
        this.utils = utils$1;
        this.helpers = utils$1.assign({}, helpers$1);
        this.options = {};
        this.configure(presetName);
        if (options) {
          this.set(options);
        }
      }
      MarkdownIt.prototype.set = function (options) {
        utils$1.assign(this.options, options);
        return this;
      };
      MarkdownIt.prototype.configure = function (presets) {
        var self = this, presetName;
        if (utils$1.isString(presets)) {
          presetName = presets;
          presets = config[presetName];
          if (!presets) {
            throw new Error("Wrong `markdown-it` preset \"" + presetName + "\", check name");
          }
        }
        if (!presets) {
          throw new Error("Wrong `markdown-it` preset, can't be empty");
        }
        if (presets.options) {
          self.set(presets.options);
        }
        if (presets.components) {
          Object.keys(presets.components).forEach(function (name) {
            if (presets.components[name].rules) {
              self[name].ruler.enableOnly(presets.components[name].rules);
            }
            if (presets.components[name].rules2) {
              self[name].ruler2.enableOnly(presets.components[name].rules2);
            }
          });
        }
        return this;
      };
      MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
        var result = [];
        if (!Array.isArray(list)) {
          list = [list];
        }
        [
          "core",
          "block",
          "inline"
        ].forEach(function (chain) {
          result = result.concat(this[chain].ruler.enable(list, true));
        }, this);
        result = result.concat(this.inline.ruler2.enable(list, true));
        var missed = list.filter(function (name) {
          return result.indexOf(name) < 0;
        });
        if (missed.length && !ignoreInvalid) {
          throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
        }
        return this;
      };
      MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
        var result = [];
        if (!Array.isArray(list)) {
          list = [list];
        }
        [
          "core",
          "block",
          "inline"
        ].forEach(function (chain) {
          result = result.concat(this[chain].ruler.disable(list, true));
        }, this);
        result = result.concat(this.inline.ruler2.disable(list, true));
        var missed = list.filter(function (name) {
          return result.indexOf(name) < 0;
        });
        if (missed.length && !ignoreInvalid) {
          throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
        }
        return this;
      };
      MarkdownIt.prototype.use = function (plugin) {
        var args = [this].concat(Array.prototype.slice.call(arguments, 1));
        plugin.apply(plugin, args);
        return this;
      };
      MarkdownIt.prototype.parse = function (src, env) {
        if (typeof src !== "string") {
          throw new Error("Input data should be a String");
        }
        var state = new this.core.State(src, this, env);
        this.core.process(state);
        return state.tokens;
      };
      MarkdownIt.prototype.render = function (src, env) {
        env = env || {};
        return this.renderer.render(this.parse(src, env), this.options, env);
      };
      MarkdownIt.prototype.parseInline = function (src, env) {
        var state = new this.core.State(src, this, env);
        state.inlineMode = true;
        this.core.process(state);
        return state.tokens;
      };
      MarkdownIt.prototype.renderInline = function (src, env) {
        env = env || {};
        return this.renderer.render(this.parseInline(src, env), this.options, env);
      };
      exports$H = MarkdownIt;
      var exports$1$5 = exports$H;

      var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      var exports$8 = {};
      (function (global, factory) {
        exports$8 = factory();
      }(exports$8, function () {
        var VERSION = "1.13.4";
        var root = typeof self == "object" && self.self === self && self || typeof _global == "object" && _global.global === _global && _global || Function("return this")() || {};
        var ArrayProto = Array.prototype, ObjProto = Object.prototype;
        var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
        var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
        var supportsArrayBuffer = typeof ArrayBuffer !== "undefined", supportsDataView = typeof DataView !== "undefined";
        var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create, nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
        var _isNaN = isNaN, _isFinite = isFinite;
        var hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
        var nonEnumerableProps = [
          "valueOf",
          "isPrototypeOf",
          "toString",
          "propertyIsEnumerable",
          "hasOwnProperty",
          "toLocaleString"
        ];
        var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
        function restArguments(func, startIndex) {
          startIndex = startIndex == null ? func.length - 1 : +startIndex;
          return function () {
            var length = Math.max(arguments.length - startIndex, 0), rest = Array(length), index = 0;
            for (; index < length; index++) {
              rest[index] = arguments[index + startIndex];
            }
            switch (startIndex) {
            case 0:
              return func.call(this || _global, rest);
            case 1:
              return func.call(this || _global, arguments[0], rest);
            case 2:
              return func.call(this || _global, arguments[0], arguments[1], rest);
            }
            var args = Array(startIndex + 1);
            for (index = 0; index < startIndex; index++) {
              args[index] = arguments[index];
            }
            args[startIndex] = rest;
            return func.apply(this || _global, args);
          };
        }
        function isObject(obj) {
          var type = typeof obj;
          return type === "function" || type === "object" && !!obj;
        }
        function isNull(obj) {
          return obj === null;
        }
        function isUndefined(obj) {
          return obj === void 0;
        }
        function isBoolean(obj) {
          return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
        }
        function isElement(obj) {
          return !!(obj && obj.nodeType === 1);
        }
        function tagTester(name) {
          var tag = "[object " + name + "]";
          return function (obj) {
            return toString.call(obj) === tag;
          };
        }
        var isString = tagTester("String");
        var isNumber = tagTester("Number");
        var isDate = tagTester("Date");
        var isRegExp = tagTester("RegExp");
        var isError = tagTester("Error");
        var isSymbol = tagTester("Symbol");
        var isArrayBuffer = tagTester("ArrayBuffer");
        var isFunction = tagTester("Function");
        var nodelist = root.document && root.document.childNodes;
        if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
          isFunction = function (obj) {
            return typeof obj == "function" || false;
          };
        }
        var isFunction$1 = isFunction;
        var hasObjectTag = tagTester("Object");
        var hasStringTagBug = supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8))), isIE11 = typeof Map !== "undefined" && hasObjectTag(new Map());
        var isDataView = tagTester("DataView");
        function ie10IsDataView(obj) {
          return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);
        }
        var isDataView$1 = hasStringTagBug ? ie10IsDataView : isDataView;
        var isArray = nativeIsArray || tagTester("Array");
        function has$1(obj, key) {
          return obj != null && hasOwnProperty.call(obj, key);
        }
        var isArguments = tagTester("Arguments");
        (function () {
          if (!isArguments(arguments)) {
            isArguments = function (obj) {
              return has$1(obj, "callee");
            };
          }
        }());
        var isArguments$1 = isArguments;
        function isFinite$1(obj) {
          return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
        }
        function isNaN$1(obj) {
          return isNumber(obj) && _isNaN(obj);
        }
        function constant(value) {
          return function () {
            return value;
          };
        }
        function createSizePropertyCheck(getSizeProperty) {
          return function (collection) {
            var sizeProperty = getSizeProperty(collection);
            return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
          };
        }
        function shallowProperty(key) {
          return function (obj) {
            return obj == null ? void 0 : obj[key];
          };
        }
        var getByteLength = shallowProperty("byteLength");
        var isBufferLike = createSizePropertyCheck(getByteLength);
        var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
        function isTypedArray(obj) {
          return nativeIsView ? nativeIsView(obj) && !isDataView$1(obj) : isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));
        }
        var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);
        var getLength = shallowProperty("length");
        function emulatedSet(keys) {
          var hash = {};
          for (var l = keys.length, i = 0; i < l; ++i)
            hash[keys[i]] = true;
          return {
            contains: function (key) {
              return hash[key] === true;
            },
            push: function (key) {
              hash[key] = true;
              return keys.push(key);
            }
          };
        }
        function collectNonEnumProps(obj, keys) {
          keys = emulatedSet(keys);
          var nonEnumIdx = nonEnumerableProps.length;
          var constructor = obj.constructor;
          var proto = isFunction$1(constructor) && constructor.prototype || ObjProto;
          var prop = "constructor";
          if (has$1(obj, prop) && !keys.contains(prop))
            keys.push(prop);
          while (nonEnumIdx--) {
            prop = nonEnumerableProps[nonEnumIdx];
            if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {
              keys.push(prop);
            }
          }
        }
        function keys(obj) {
          if (!isObject(obj))
            return [];
          if (nativeKeys)
            return nativeKeys(obj);
          var keys = [];
          for (var key in obj)
            if (has$1(obj, key))
              keys.push(key);
          if (hasEnumBug)
            collectNonEnumProps(obj, keys);
          return keys;
        }
        function isEmpty(obj) {
          if (obj == null)
            return true;
          var length = getLength(obj);
          if (typeof length == "number" && (isArray(obj) || isString(obj) || isArguments$1(obj)))
            return length === 0;
          return getLength(keys(obj)) === 0;
        }
        function isMatch(object, attrs) {
          var _keys = keys(attrs), length = _keys.length;
          if (object == null)
            return !length;
          var obj = Object(object);
          for (var i = 0; i < length; i++) {
            var key = _keys[i];
            if (attrs[key] !== obj[key] || !(key in obj))
              return false;
          }
          return true;
        }
        function _$1(obj) {
          if (obj instanceof _$1)
            return obj;
          if (!((this || _global) instanceof _$1))
            return new _$1(obj);
          (this || _global)._wrapped = obj;
        }
        _$1.VERSION = VERSION;
        _$1.prototype.value = function () {
          return (this || _global)._wrapped;
        };
        _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;
        _$1.prototype.toString = function () {
          return String((this || _global)._wrapped);
        };
        function toBufferView(bufferSource) {
          return new Uint8Array(bufferSource.buffer || bufferSource, bufferSource.byteOffset || 0, getByteLength(bufferSource));
        }
        var tagDataView = "[object DataView]";
        function eq(a, b, aStack, bStack) {
          if (a === b)
            return a !== 0 || 1 / a === 1 / b;
          if (a == null || b == null)
            return false;
          if (a !== a)
            return b !== b;
          var type = typeof a;
          if (type !== "function" && type !== "object" && typeof b != "object")
            return false;
          return deepEq(a, b, aStack, bStack);
        }
        function deepEq(a, b, aStack, bStack) {
          if (a instanceof _$1)
            a = a._wrapped;
          if (b instanceof _$1)
            b = b._wrapped;
          var className = toString.call(a);
          if (className !== toString.call(b))
            return false;
          if (hasStringTagBug && className == "[object Object]" && isDataView$1(a)) {
            if (!isDataView$1(b))
              return false;
            className = tagDataView;
          }
          switch (className) {
          case "[object RegExp]":
          case "[object String]":
            return "" + a === "" + b;
          case "[object Number]":
            if (+a !== +a)
              return +b !== +b;
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
          case "[object Date]":
          case "[object Boolean]":
            return +a === +b;
          case "[object Symbol]":
            return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
          case "[object ArrayBuffer]":
          case tagDataView:
            return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
          }
          var areArrays = className === "[object Array]";
          if (!areArrays && isTypedArray$1(a)) {
            var byteLength = getByteLength(a);
            if (byteLength !== getByteLength(b))
              return false;
            if (a.buffer === b.buffer && a.byteOffset === b.byteOffset)
              return true;
            areArrays = true;
          }
          if (!areArrays) {
            if (typeof a != "object" || typeof b != "object")
              return false;
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor && isFunction$1(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
              return false;
            }
          }
          aStack = aStack || [];
          bStack = bStack || [];
          var length = aStack.length;
          while (length--) {
            if (aStack[length] === a)
              return bStack[length] === b;
          }
          aStack.push(a);
          bStack.push(b);
          if (areArrays) {
            length = a.length;
            if (length !== b.length)
              return false;
            while (length--) {
              if (!eq(a[length], b[length], aStack, bStack))
                return false;
            }
          } else {
            var _keys = keys(a), key;
            length = _keys.length;
            if (keys(b).length !== length)
              return false;
            while (length--) {
              key = _keys[length];
              if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack)))
                return false;
            }
          }
          aStack.pop();
          bStack.pop();
          return true;
        }
        function isEqual(a, b) {
          return eq(a, b);
        }
        function allKeys(obj) {
          if (!isObject(obj))
            return [];
          var keys = [];
          for (var key in obj)
            keys.push(key);
          if (hasEnumBug)
            collectNonEnumProps(obj, keys);
          return keys;
        }
        function ie11fingerprint(methods) {
          var length = getLength(methods);
          return function (obj) {
            if (obj == null)
              return false;
            var keys = allKeys(obj);
            if (getLength(keys))
              return false;
            for (var i = 0; i < length; i++) {
              if (!isFunction$1(obj[methods[i]]))
                return false;
            }
            return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);
          };
        }
        var forEachName = "forEach", hasName = "has", commonInit = [
            "clear",
            "delete"
          ], mapTail = [
            "get",
            hasName,
            "set"
          ];
        var mapMethods = commonInit.concat(forEachName, mapTail), weakMapMethods = commonInit.concat(mapTail), setMethods = ["add"].concat(commonInit, forEachName, hasName);
        var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
        var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
        var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
        var isWeakSet = tagTester("WeakSet");
        function values(obj) {
          var _keys = keys(obj);
          var length = _keys.length;
          var values = Array(length);
          for (var i = 0; i < length; i++) {
            values[i] = obj[_keys[i]];
          }
          return values;
        }
        function pairs(obj) {
          var _keys = keys(obj);
          var length = _keys.length;
          var pairs = Array(length);
          for (var i = 0; i < length; i++) {
            pairs[i] = [
              _keys[i],
              obj[_keys[i]]
            ];
          }
          return pairs;
        }
        function invert(obj) {
          var result = {};
          var _keys = keys(obj);
          for (var i = 0, length = _keys.length; i < length; i++) {
            result[obj[_keys[i]]] = _keys[i];
          }
          return result;
        }
        function functions(obj) {
          var names = [];
          for (var key in obj) {
            if (isFunction$1(obj[key]))
              names.push(key);
          }
          return names.sort();
        }
        function createAssigner(keysFunc, defaults) {
          return function (obj) {
            var length = arguments.length;
            if (defaults)
              obj = Object(obj);
            if (length < 2 || obj == null)
              return obj;
            for (var index = 1; index < length; index++) {
              var source = arguments[index], keys = keysFunc(source), l = keys.length;
              for (var i = 0; i < l; i++) {
                var key = keys[i];
                if (!defaults || obj[key] === void 0)
                  obj[key] = source[key];
              }
            }
            return obj;
          };
        }
        var extend = createAssigner(allKeys);
        var extendOwn = createAssigner(keys);
        var defaults = createAssigner(allKeys, true);
        function ctor() {
          return function () {
          };
        }
        function baseCreate(prototype) {
          if (!isObject(prototype))
            return {};
          if (nativeCreate)
            return nativeCreate(prototype);
          var Ctor = ctor();
          Ctor.prototype = prototype;
          var result = new Ctor();
          Ctor.prototype = null;
          return result;
        }
        function create(prototype, props) {
          var result = baseCreate(prototype);
          if (props)
            extendOwn(result, props);
          return result;
        }
        function clone(obj) {
          if (!isObject(obj))
            return obj;
          return isArray(obj) ? obj.slice() : extend({}, obj);
        }
        function tap(obj, interceptor) {
          interceptor(obj);
          return obj;
        }
        function toPath$1(path) {
          return isArray(path) ? path : [path];
        }
        _$1.toPath = toPath$1;
        function toPath(path) {
          return _$1.toPath(path);
        }
        function deepGet(obj, path) {
          var length = path.length;
          for (var i = 0; i < length; i++) {
            if (obj == null)
              return void 0;
            obj = obj[path[i]];
          }
          return length ? obj : void 0;
        }
        function get(object, path, defaultValue) {
          var value = deepGet(object, toPath(path));
          return isUndefined(value) ? defaultValue : value;
        }
        function has(obj, path) {
          path = toPath(path);
          var length = path.length;
          for (var i = 0; i < length; i++) {
            var key = path[i];
            if (!has$1(obj, key))
              return false;
            obj = obj[key];
          }
          return !!length;
        }
        function identity(value) {
          return value;
        }
        function matcher(attrs) {
          attrs = extendOwn({}, attrs);
          return function (obj) {
            return isMatch(obj, attrs);
          };
        }
        function property(path) {
          path = toPath(path);
          return function (obj) {
            return deepGet(obj, path);
          };
        }
        function optimizeCb(func, context, argCount) {
          if (context === void 0)
            return func;
          switch (argCount == null ? 3 : argCount) {
          case 1:
            return function (value) {
              return func.call(context, value);
            };
          case 3:
            return function (value, index, collection) {
              return func.call(context, value, index, collection);
            };
          case 4:
            return function (accumulator, value, index, collection) {
              return func.call(context, accumulator, value, index, collection);
            };
          }
          return function () {
            return func.apply(context, arguments);
          };
        }
        function baseIteratee(value, context, argCount) {
          if (value == null)
            return identity;
          if (isFunction$1(value))
            return optimizeCb(value, context, argCount);
          if (isObject(value) && !isArray(value))
            return matcher(value);
          return property(value);
        }
        function iteratee(value, context) {
          return baseIteratee(value, context, Infinity);
        }
        _$1.iteratee = iteratee;
        function cb(value, context, argCount) {
          if (_$1.iteratee !== iteratee)
            return _$1.iteratee(value, context);
          return baseIteratee(value, context, argCount);
        }
        function mapObject(obj, iteratee, context) {
          iteratee = cb(iteratee, context);
          var _keys = keys(obj), length = _keys.length, results = {};
          for (var index = 0; index < length; index++) {
            var currentKey = _keys[index];
            results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
          }
          return results;
        }
        function noop() {
        }
        function propertyOf(obj) {
          if (obj == null)
            return noop;
          return function (path) {
            return get(obj, path);
          };
        }
        function times(n, iteratee, context) {
          var accum = Array(Math.max(0, n));
          iteratee = optimizeCb(iteratee, context, 1);
          for (var i = 0; i < n; i++)
            accum[i] = iteratee(i);
          return accum;
        }
        function random(min, max) {
          if (max == null) {
            max = min;
            min = 0;
          }
          return min + Math.floor(Math.random() * (max - min + 1));
        }
        var now = Date.now || function () {
          return new Date().getTime();
        };
        function createEscaper(map) {
          var escaper = function (match) {
            return map[match];
          };
          var source = "(?:" + keys(map).join("|") + ")";
          var testRegexp = RegExp(source);
          var replaceRegexp = RegExp(source, "g");
          return function (string) {
            string = string == null ? "" : "" + string;
            return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
          };
        }
        var escapeMap = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          "\"": "&quot;",
          "'": "&#x27;",
          "`": "&#x60;"
        };
        var _escape = createEscaper(escapeMap);
        var unescapeMap = invert(escapeMap);
        var _unescape = createEscaper(unescapeMap);
        var templateSettings = _$1.templateSettings = {
          evaluate: /<%([\s\S]+?)%>/g,
          interpolate: /<%=([\s\S]+?)%>/g,
          escape: /<%-([\s\S]+?)%>/g
        };
        var noMatch = /(.)^/;
        var escapes = {
          "'": "'",
          "\\": "\\",
          "\r": "r",
          "\n": "n",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
        function escapeChar(match) {
          return "\\" + escapes[match];
        }
        var bareIdentifier = /^\s*(\w|\$)+\s*$/;
        function template(text, settings, oldSettings) {
          if (!settings && oldSettings)
            settings = oldSettings;
          settings = defaults({}, settings, _$1.templateSettings);
          var matcher = RegExp([
            (settings.escape || noMatch).source,
            (settings.interpolate || noMatch).source,
            (settings.evaluate || noMatch).source
          ].join("|") + "|$", "g");
          var index = 0;
          var source = "__p+='";
          text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
            source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
            index = offset + match.length;
            if (escape) {
              source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
            } else if (interpolate) {
              source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
            } else if (evaluate) {
              source += "';\n" + evaluate + "\n__p+='";
            }
            return match;
          });
          source += "';\n";
          var argument = settings.variable;
          if (argument) {
            if (!bareIdentifier.test(argument))
              throw new Error("variable is not a bare identifier: " + argument);
          } else {
            source = "with(obj||{}){\n" + source + "}\n";
            argument = "obj";
          }
          source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
          var render;
          try {
            render = new Function(argument, "_", source);
          } catch (e) {
            e.source = source;
            throw e;
          }
          var template = function (data) {
            return render.call(this || _global, data, _$1);
          };
          template.source = "function(" + argument + "){\n" + source + "}";
          return template;
        }
        function result(obj, path, fallback) {
          path = toPath(path);
          var length = path.length;
          if (!length) {
            return isFunction$1(fallback) ? fallback.call(obj) : fallback;
          }
          for (var i = 0; i < length; i++) {
            var prop = obj == null ? void 0 : obj[path[i]];
            if (prop === void 0) {
              prop = fallback;
              i = length;
            }
            obj = isFunction$1(prop) ? prop.call(obj) : prop;
          }
          return obj;
        }
        var idCounter = 0;
        function uniqueId(prefix) {
          var id = ++idCounter + "";
          return prefix ? prefix + id : id;
        }
        function chain(obj) {
          var instance = _$1(obj);
          instance._chain = true;
          return instance;
        }
        function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
          if (!(callingContext instanceof boundFunc))
            return sourceFunc.apply(context, args);
          var self = baseCreate(sourceFunc.prototype);
          var result = sourceFunc.apply(self, args);
          if (isObject(result))
            return result;
          return self;
        }
        var partial = restArguments(function (func, boundArgs) {
          var placeholder = partial.placeholder;
          var bound = function () {
            var position = 0, length = boundArgs.length;
            var args = Array(length);
            for (var i = 0; i < length; i++) {
              args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
            }
            while (position < arguments.length)
              args.push(arguments[position++]);
            return executeBound(func, bound, this || _global, this || _global, args);
          };
          return bound;
        });
        partial.placeholder = _$1;
        var bind = restArguments(function (func, context, args) {
          if (!isFunction$1(func))
            throw new TypeError("Bind must be called on a function");
          var bound = restArguments(function (callArgs) {
            return executeBound(func, bound, context, this || _global, args.concat(callArgs));
          });
          return bound;
        });
        var isArrayLike = createSizePropertyCheck(getLength);
        function flatten$1(input, depth, strict, output) {
          output = output || [];
          if (!depth && depth !== 0) {
            depth = Infinity;
          } else if (depth <= 0) {
            return output.concat(input);
          }
          var idx = output.length;
          for (var i = 0, length = getLength(input); i < length; i++) {
            var value = input[i];
            if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {
              if (depth > 1) {
                flatten$1(value, depth - 1, strict, output);
                idx = output.length;
              } else {
                var j = 0, len = value.length;
                while (j < len)
                  output[idx++] = value[j++];
              }
            } else if (!strict) {
              output[idx++] = value;
            }
          }
          return output;
        }
        var bindAll = restArguments(function (obj, keys) {
          keys = flatten$1(keys, false, false);
          var index = keys.length;
          if (index < 1)
            throw new Error("bindAll must be passed function names");
          while (index--) {
            var key = keys[index];
            obj[key] = bind(obj[key], obj);
          }
          return obj;
        });
        function memoize(func, hasher) {
          var memoize = function (key) {
            var cache = memoize.cache;
            var address = "" + (hasher ? hasher.apply(this || _global, arguments) : key);
            if (!has$1(cache, address))
              cache[address] = func.apply(this || _global, arguments);
            return cache[address];
          };
          memoize.cache = {};
          return memoize;
        }
        var delay = restArguments(function (func, wait, args) {
          return setTimeout(function () {
            return func.apply(null, args);
          }, wait);
        });
        var defer = partial(delay, _$1, 1);
        function throttle(func, wait, options) {
          var timeout, context, args, result;
          var previous = 0;
          if (!options)
            options = {};
          var later = function () {
            previous = options.leading === false ? 0 : now();
            timeout = null;
            result = func.apply(context, args);
            if (!timeout)
              context = args = null;
          };
          var throttled = function () {
            var _now = now();
            if (!previous && options.leading === false)
              previous = _now;
            var remaining = wait - (_now - previous);
            context = this || _global;
            args = arguments;
            if (remaining <= 0 || remaining > wait) {
              if (timeout) {
                clearTimeout(timeout);
                timeout = null;
              }
              previous = _now;
              result = func.apply(context, args);
              if (!timeout)
                context = args = null;
            } else if (!timeout && options.trailing !== false) {
              timeout = setTimeout(later, remaining);
            }
            return result;
          };
          throttled.cancel = function () {
            clearTimeout(timeout);
            previous = 0;
            timeout = context = args = null;
          };
          return throttled;
        }
        function debounce(func, wait, immediate) {
          var timeout, previous, args, result, context;
          var later = function () {
            var passed = now() - previous;
            if (wait > passed) {
              timeout = setTimeout(later, wait - passed);
            } else {
              timeout = null;
              if (!immediate)
                result = func.apply(context, args);
              if (!timeout)
                args = context = null;
            }
          };
          var debounced = restArguments(function (_args) {
            context = this || _global;
            args = _args;
            previous = now();
            if (!timeout) {
              timeout = setTimeout(later, wait);
              if (immediate)
                result = func.apply(context, args);
            }
            return result;
          });
          debounced.cancel = function () {
            clearTimeout(timeout);
            timeout = args = context = null;
          };
          return debounced;
        }
        function wrap(func, wrapper) {
          return partial(wrapper, func);
        }
        function negate(predicate) {
          return function () {
            return !predicate.apply(this || _global, arguments);
          };
        }
        function compose() {
          var args = arguments;
          var start = args.length - 1;
          return function () {
            var i = start;
            var result = args[start].apply(this || _global, arguments);
            while (i--)
              result = args[i].call(this || _global, result);
            return result;
          };
        }
        function after(times, func) {
          return function () {
            if (--times < 1) {
              return func.apply(this || _global, arguments);
            }
          };
        }
        function before(times, func) {
          var memo;
          return function () {
            if (--times > 0) {
              memo = func.apply(this || _global, arguments);
            }
            if (times <= 1)
              func = null;
            return memo;
          };
        }
        var once = partial(before, 2);
        function findKey(obj, predicate, context) {
          predicate = cb(predicate, context);
          var _keys = keys(obj), key;
          for (var i = 0, length = _keys.length; i < length; i++) {
            key = _keys[i];
            if (predicate(obj[key], key, obj))
              return key;
          }
        }
        function createPredicateIndexFinder(dir) {
          return function (array, predicate, context) {
            predicate = cb(predicate, context);
            var length = getLength(array);
            var index = dir > 0 ? 0 : length - 1;
            for (; index >= 0 && index < length; index += dir) {
              if (predicate(array[index], index, array))
                return index;
            }
            return -1;
          };
        }
        var findIndex = createPredicateIndexFinder(1);
        var findLastIndex = createPredicateIndexFinder(-1);
        function sortedIndex(array, obj, iteratee, context) {
          iteratee = cb(iteratee, context, 1);
          var value = iteratee(obj);
          var low = 0, high = getLength(array);
          while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (iteratee(array[mid]) < value)
              low = mid + 1;
            else
              high = mid;
          }
          return low;
        }
        function createIndexFinder(dir, predicateFind, sortedIndex) {
          return function (array, item, idx) {
            var i = 0, length = getLength(array);
            if (typeof idx == "number") {
              if (dir > 0) {
                i = idx >= 0 ? idx : Math.max(idx + length, i);
              } else {
                length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
              }
            } else if (sortedIndex && idx && length) {
              idx = sortedIndex(array, item);
              return array[idx] === item ? idx : -1;
            }
            if (item !== item) {
              idx = predicateFind(slice.call(array, i, length), isNaN$1);
              return idx >= 0 ? idx + i : -1;
            }
            for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
              if (array[idx] === item)
                return idx;
            }
            return -1;
          };
        }
        var indexOf = createIndexFinder(1, findIndex, sortedIndex);
        var lastIndexOf = createIndexFinder(-1, findLastIndex);
        function find(obj, predicate, context) {
          var keyFinder = isArrayLike(obj) ? findIndex : findKey;
          var key = keyFinder(obj, predicate, context);
          if (key !== void 0 && key !== -1)
            return obj[key];
        }
        function findWhere(obj, attrs) {
          return find(obj, matcher(attrs));
        }
        function each(obj, iteratee, context) {
          iteratee = optimizeCb(iteratee, context);
          var i, length;
          if (isArrayLike(obj)) {
            for (i = 0, length = obj.length; i < length; i++) {
              iteratee(obj[i], i, obj);
            }
          } else {
            var _keys = keys(obj);
            for (i = 0, length = _keys.length; i < length; i++) {
              iteratee(obj[_keys[i]], _keys[i], obj);
            }
          }
          return obj;
        }
        function map(obj, iteratee, context) {
          iteratee = cb(iteratee, context);
          var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, results = Array(length);
          for (var index = 0; index < length; index++) {
            var currentKey = _keys ? _keys[index] : index;
            results[index] = iteratee(obj[currentKey], currentKey, obj);
          }
          return results;
        }
        function createReduce(dir) {
          var reducer = function (obj, iteratee, memo, initial) {
            var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, index = dir > 0 ? 0 : length - 1;
            if (!initial) {
              memo = obj[_keys ? _keys[index] : index];
              index += dir;
            }
            for (; index >= 0 && index < length; index += dir) {
              var currentKey = _keys ? _keys[index] : index;
              memo = iteratee(memo, obj[currentKey], currentKey, obj);
            }
            return memo;
          };
          return function (obj, iteratee, memo, context) {
            var initial = arguments.length >= 3;
            return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
          };
        }
        var reduce = createReduce(1);
        var reduceRight = createReduce(-1);
        function filter(obj, predicate, context) {
          var results = [];
          predicate = cb(predicate, context);
          each(obj, function (value, index, list) {
            if (predicate(value, index, list))
              results.push(value);
          });
          return results;
        }
        function reject(obj, predicate, context) {
          return filter(obj, negate(cb(predicate)), context);
        }
        function every(obj, predicate, context) {
          predicate = cb(predicate, context);
          var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length;
          for (var index = 0; index < length; index++) {
            var currentKey = _keys ? _keys[index] : index;
            if (!predicate(obj[currentKey], currentKey, obj))
              return false;
          }
          return true;
        }
        function some(obj, predicate, context) {
          predicate = cb(predicate, context);
          var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length;
          for (var index = 0; index < length; index++) {
            var currentKey = _keys ? _keys[index] : index;
            if (predicate(obj[currentKey], currentKey, obj))
              return true;
          }
          return false;
        }
        function contains(obj, item, fromIndex, guard) {
          if (!isArrayLike(obj))
            obj = values(obj);
          if (typeof fromIndex != "number" || guard)
            fromIndex = 0;
          return indexOf(obj, item, fromIndex) >= 0;
        }
        var invoke = restArguments(function (obj, path, args) {
          var contextPath, func;
          if (isFunction$1(path)) {
            func = path;
          } else {
            path = toPath(path);
            contextPath = path.slice(0, -1);
            path = path[path.length - 1];
          }
          return map(obj, function (context) {
            var method = func;
            if (!method) {
              if (contextPath && contextPath.length) {
                context = deepGet(context, contextPath);
              }
              if (context == null)
                return void 0;
              method = context[path];
            }
            return method == null ? method : method.apply(context, args);
          });
        });
        function pluck(obj, key) {
          return map(obj, property(key));
        }
        function where(obj, attrs) {
          return filter(obj, matcher(attrs));
        }
        function max(obj, iteratee, context) {
          var result = -Infinity, lastComputed = -Infinity, value, computed;
          if (iteratee == null || typeof iteratee == "number" && typeof obj[0] != "object" && obj != null) {
            obj = isArrayLike(obj) ? obj : values(obj);
            for (var i = 0, length = obj.length; i < length; i++) {
              value = obj[i];
              if (value != null && value > result) {
                result = value;
              }
            }
          } else {
            iteratee = cb(iteratee, context);
            each(obj, function (v, index, list) {
              computed = iteratee(v, index, list);
              if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
                result = v;
                lastComputed = computed;
              }
            });
          }
          return result;
        }
        function min(obj, iteratee, context) {
          var result = Infinity, lastComputed = Infinity, value, computed;
          if (iteratee == null || typeof iteratee == "number" && typeof obj[0] != "object" && obj != null) {
            obj = isArrayLike(obj) ? obj : values(obj);
            for (var i = 0, length = obj.length; i < length; i++) {
              value = obj[i];
              if (value != null && value < result) {
                result = value;
              }
            }
          } else {
            iteratee = cb(iteratee, context);
            each(obj, function (v, index, list) {
              computed = iteratee(v, index, list);
              if (computed < lastComputed || computed === Infinity && result === Infinity) {
                result = v;
                lastComputed = computed;
              }
            });
          }
          return result;
        }
        var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
        function toArray(obj) {
          if (!obj)
            return [];
          if (isArray(obj))
            return slice.call(obj);
          if (isString(obj)) {
            return obj.match(reStrSymbol);
          }
          if (isArrayLike(obj))
            return map(obj, identity);
          return values(obj);
        }
        function sample(obj, n, guard) {
          if (n == null || guard) {
            if (!isArrayLike(obj))
              obj = values(obj);
            return obj[random(obj.length - 1)];
          }
          var sample = toArray(obj);
          var length = getLength(sample);
          n = Math.max(Math.min(n, length), 0);
          var last = length - 1;
          for (var index = 0; index < n; index++) {
            var rand = random(index, last);
            var temp = sample[index];
            sample[index] = sample[rand];
            sample[rand] = temp;
          }
          return sample.slice(0, n);
        }
        function shuffle(obj) {
          return sample(obj, Infinity);
        }
        function sortBy(obj, iteratee, context) {
          var index = 0;
          iteratee = cb(iteratee, context);
          return pluck(map(obj, function (value, key, list) {
            return {
              value: value,
              index: index++,
              criteria: iteratee(value, key, list)
            };
          }).sort(function (left, right) {
            var a = left.criteria;
            var b = right.criteria;
            if (a !== b) {
              if (a > b || a === void 0)
                return 1;
              if (a < b || b === void 0)
                return -1;
            }
            return left.index - right.index;
          }), "value");
        }
        function group(behavior, partition) {
          return function (obj, iteratee, context) {
            var result = partition ? [
              [],
              []
            ] : {};
            iteratee = cb(iteratee, context);
            each(obj, function (value, index) {
              var key = iteratee(value, index, obj);
              behavior(result, value, key);
            });
            return result;
          };
        }
        var groupBy = group(function (result, value, key) {
          if (has$1(result, key))
            result[key].push(value);
          else
            result[key] = [value];
        });
        var indexBy = group(function (result, value, key) {
          result[key] = value;
        });
        var countBy = group(function (result, value, key) {
          if (has$1(result, key))
            result[key]++;
          else
            result[key] = 1;
        });
        var partition = group(function (result, value, pass) {
          result[pass ? 0 : 1].push(value);
        }, true);
        function size(obj) {
          if (obj == null)
            return 0;
          return isArrayLike(obj) ? obj.length : keys(obj).length;
        }
        function keyInObj(value, key, obj) {
          return key in obj;
        }
        var pick = restArguments(function (obj, keys) {
          var result = {}, iteratee = keys[0];
          if (obj == null)
            return result;
          if (isFunction$1(iteratee)) {
            if (keys.length > 1)
              iteratee = optimizeCb(iteratee, keys[1]);
            keys = allKeys(obj);
          } else {
            iteratee = keyInObj;
            keys = flatten$1(keys, false, false);
            obj = Object(obj);
          }
          for (var i = 0, length = keys.length; i < length; i++) {
            var key = keys[i];
            var value = obj[key];
            if (iteratee(value, key, obj))
              result[key] = value;
          }
          return result;
        });
        var omit = restArguments(function (obj, keys) {
          var iteratee = keys[0], context;
          if (isFunction$1(iteratee)) {
            iteratee = negate(iteratee);
            if (keys.length > 1)
              context = keys[1];
          } else {
            keys = map(flatten$1(keys, false, false), String);
            iteratee = function (value, key) {
              return !contains(keys, key);
            };
          }
          return pick(obj, iteratee, context);
        });
        function initial(array, n, guard) {
          return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
        }
        function first(array, n, guard) {
          if (array == null || array.length < 1)
            return n == null || guard ? void 0 : [];
          if (n == null || guard)
            return array[0];
          return initial(array, array.length - n);
        }
        function rest(array, n, guard) {
          return slice.call(array, n == null || guard ? 1 : n);
        }
        function last(array, n, guard) {
          if (array == null || array.length < 1)
            return n == null || guard ? void 0 : [];
          if (n == null || guard)
            return array[array.length - 1];
          return rest(array, Math.max(0, array.length - n));
        }
        function compact(array) {
          return filter(array, Boolean);
        }
        function flatten(array, depth) {
          return flatten$1(array, depth, false);
        }
        var difference = restArguments(function (array, rest) {
          rest = flatten$1(rest, true, true);
          return filter(array, function (value) {
            return !contains(rest, value);
          });
        });
        var without = restArguments(function (array, otherArrays) {
          return difference(array, otherArrays);
        });
        function uniq(array, isSorted, iteratee, context) {
          if (!isBoolean(isSorted)) {
            context = iteratee;
            iteratee = isSorted;
            isSorted = false;
          }
          if (iteratee != null)
            iteratee = cb(iteratee, context);
          var result = [];
          var seen = [];
          for (var i = 0, length = getLength(array); i < length; i++) {
            var value = array[i], computed = iteratee ? iteratee(value, i, array) : value;
            if (isSorted && !iteratee) {
              if (!i || seen !== computed)
                result.push(value);
              seen = computed;
            } else if (iteratee) {
              if (!contains(seen, computed)) {
                seen.push(computed);
                result.push(value);
              }
            } else if (!contains(result, value)) {
              result.push(value);
            }
          }
          return result;
        }
        var union = restArguments(function (arrays) {
          return uniq(flatten$1(arrays, true, true));
        });
        function intersection(array) {
          var result = [];
          var argsLength = arguments.length;
          for (var i = 0, length = getLength(array); i < length; i++) {
            var item = array[i];
            if (contains(result, item))
              continue;
            var j;
            for (j = 1; j < argsLength; j++) {
              if (!contains(arguments[j], item))
                break;
            }
            if (j === argsLength)
              result.push(item);
          }
          return result;
        }
        function unzip(array) {
          var length = array && max(array, getLength).length || 0;
          var result = Array(length);
          for (var index = 0; index < length; index++) {
            result[index] = pluck(array, index);
          }
          return result;
        }
        var zip = restArguments(unzip);
        function object(list, values) {
          var result = {};
          for (var i = 0, length = getLength(list); i < length; i++) {
            if (values) {
              result[list[i]] = values[i];
            } else {
              result[list[i][0]] = list[i][1];
            }
          }
          return result;
        }
        function range(start, stop, step) {
          if (stop == null) {
            stop = start || 0;
            start = 0;
          }
          if (!step) {
            step = stop < start ? -1 : 1;
          }
          var length = Math.max(Math.ceil((stop - start) / step), 0);
          var range = Array(length);
          for (var idx = 0; idx < length; idx++, start += step) {
            range[idx] = start;
          }
          return range;
        }
        function chunk(array, count) {
          if (count == null || count < 1)
            return [];
          var result = [];
          var i = 0, length = array.length;
          while (i < length) {
            result.push(slice.call(array, i, i += count));
          }
          return result;
        }
        function chainResult(instance, obj) {
          return instance._chain ? _$1(obj).chain() : obj;
        }
        function mixin(obj) {
          each(functions(obj), function (name) {
            var func = _$1[name] = obj[name];
            _$1.prototype[name] = function () {
              var args = [(this || _global)._wrapped];
              push.apply(args, arguments);
              return chainResult(this || _global, func.apply(_$1, args));
            };
          });
          return _$1;
        }
        each([
          "pop",
          "push",
          "reverse",
          "shift",
          "sort",
          "splice",
          "unshift"
        ], function (name) {
          var method = ArrayProto[name];
          _$1.prototype[name] = function () {
            var obj = (this || _global)._wrapped;
            if (obj != null) {
              method.apply(obj, arguments);
              if ((name === "shift" || name === "splice") && obj.length === 0) {
                delete obj[0];
              }
            }
            return chainResult(this || _global, obj);
          };
        });
        each([
          "concat",
          "join",
          "slice"
        ], function (name) {
          var method = ArrayProto[name];
          _$1.prototype[name] = function () {
            var obj = (this || _global)._wrapped;
            if (obj != null)
              obj = method.apply(obj, arguments);
            return chainResult(this || _global, obj);
          };
        });
        var allExports = {
          __proto__: null,
          VERSION: VERSION,
          restArguments: restArguments,
          isObject: isObject,
          isNull: isNull,
          isUndefined: isUndefined,
          isBoolean: isBoolean,
          isElement: isElement,
          isString: isString,
          isNumber: isNumber,
          isDate: isDate,
          isRegExp: isRegExp,
          isError: isError,
          isSymbol: isSymbol,
          isArrayBuffer: isArrayBuffer,
          isDataView: isDataView$1,
          isArray: isArray,
          isFunction: isFunction$1,
          isArguments: isArguments$1,
          isFinite: isFinite$1,
          isNaN: isNaN$1,
          isTypedArray: isTypedArray$1,
          isEmpty: isEmpty,
          isMatch: isMatch,
          isEqual: isEqual,
          isMap: isMap,
          isWeakMap: isWeakMap,
          isSet: isSet,
          isWeakSet: isWeakSet,
          keys: keys,
          allKeys: allKeys,
          values: values,
          pairs: pairs,
          invert: invert,
          functions: functions,
          methods: functions,
          extend: extend,
          extendOwn: extendOwn,
          assign: extendOwn,
          defaults: defaults,
          create: create,
          clone: clone,
          tap: tap,
          get: get,
          has: has,
          mapObject: mapObject,
          identity: identity,
          constant: constant,
          noop: noop,
          toPath: toPath$1,
          property: property,
          propertyOf: propertyOf,
          matcher: matcher,
          matches: matcher,
          times: times,
          random: random,
          now: now,
          escape: _escape,
          unescape: _unescape,
          templateSettings: templateSettings,
          template: template,
          result: result,
          uniqueId: uniqueId,
          chain: chain,
          iteratee: iteratee,
          partial: partial,
          bind: bind,
          bindAll: bindAll,
          memoize: memoize,
          delay: delay,
          defer: defer,
          throttle: throttle,
          debounce: debounce,
          wrap: wrap,
          negate: negate,
          compose: compose,
          after: after,
          before: before,
          once: once,
          findKey: findKey,
          findIndex: findIndex,
          findLastIndex: findLastIndex,
          sortedIndex: sortedIndex,
          indexOf: indexOf,
          lastIndexOf: lastIndexOf,
          find: find,
          detect: find,
          findWhere: findWhere,
          each: each,
          forEach: each,
          map: map,
          collect: map,
          reduce: reduce,
          foldl: reduce,
          inject: reduce,
          reduceRight: reduceRight,
          foldr: reduceRight,
          filter: filter,
          select: filter,
          reject: reject,
          every: every,
          all: every,
          some: some,
          any: some,
          contains: contains,
          includes: contains,
          include: contains,
          invoke: invoke,
          pluck: pluck,
          where: where,
          max: max,
          min: min,
          shuffle: shuffle,
          sample: sample,
          sortBy: sortBy,
          groupBy: groupBy,
          indexBy: indexBy,
          countBy: countBy,
          partition: partition,
          toArray: toArray,
          size: size,
          pick: pick,
          omit: omit,
          first: first,
          head: first,
          take: first,
          initial: initial,
          last: last,
          rest: rest,
          tail: rest,
          drop: rest,
          compact: compact,
          flatten: flatten,
          without: without,
          uniq: uniq,
          unique: uniq,
          union: union,
          intersection: intersection,
          difference: difference,
          unzip: unzip,
          transpose: unzip,
          zip: zip,
          object: object,
          range: range,
          chunk: chunk,
          mixin: mixin,
          "default": _$1
        };
        var _ = mixin(allExports);
        _._ = _;
        return _;
      }));
      var exports$1$4 = exports$8;
      exports$8.noConflict;

      var exports$7 = {};
      var _, checkboxReplace;
      _ = exports$1$4;
      checkboxReplace = function (md, options, Token) {
        var arrayReplaceAt, createTokens, defaults, lastId, pattern, splitTextToken;
        arrayReplaceAt = md.utils.arrayReplaceAt;
        lastId = 0;
        defaults = {
          divWrap: false,
          divClass: "checkbox",
          idPrefix: "checkbox"
        };
        options = _.extend(defaults, options);
        pattern = /\[(X|\s|\_|\-)\]\s(.*)/i;
        createTokens = function (checked, label, Token) {
          var id, nodes, token;
          nodes = [];
          if (options.divWrap) {
            token = new Token("checkbox_open", "div", 1);
            token.attrs = [[
                "class",
                options.divClass
              ]];
            nodes.push(token);
          }
          id = options.idPrefix + lastId;
          lastId += 1;
          token = new Token("checkbox_input", "input", 0);
          token.attrs = [
            [
              "type",
              "checkbox"
            ],
            [
              "id",
              id
            ]
          ];
          if (checked === true) {
            token.attrs.push([
              "checked",
              "true"
            ]);
          }
          nodes.push(token);
          token = new Token("label_open", "label", 1);
          token.attrs = [[
              "for",
              id
            ]];
          nodes.push(token);
          token = new Token("text", "", 0);
          token.content = label;
          nodes.push(token);
          nodes.push(new Token("label_close", "label", -1));
          if (options.divWrap) {
            nodes.push(new Token("checkbox_close", "div", -1));
          }
          return nodes;
        };
        splitTextToken = function (original, Token) {
          var checked, label, matches, text, value;
          text = original.content;
          matches = text.match(pattern);
          if (matches === null) {
            return original;
          }
          checked = false;
          value = matches[1];
          label = matches[2];
          if (value === "X" || value === "x") {
            checked = true;
          }
          return createTokens(checked, label, Token);
        };
        return function (state) {
          var blockTokens, i, j, l, token, tokens;
          blockTokens = state.tokens;
          j = 0;
          l = blockTokens.length;
          while (j < l) {
            if (blockTokens[j].type !== "inline") {
              j++;
              continue;
            }
            tokens = blockTokens[j].children;
            i = tokens.length - 1;
            while (i >= 0) {
              token = tokens[i];
              blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, splitTextToken(token, state.Token));
              i--;
            }
            j++;
          }
        };
      };
      exports$7 = function (md, options) {
        md.core.ruler.push("checkbox", checkboxReplace(md, options));
      };
      var exports$1$3 = exports$7;

      var exports$6 = {};
      exports$6 = function implicitFiguresPlugin(md, options) {
        options = options || {};
        function implicitFigures(state) {
          var tabIndex = 1;
          for (var i = 1, l = state.tokens.length; i < l - 1; ++i) {
            var token = state.tokens[i];
            if (token.type !== "inline") {
              continue;
            }
            if (!token.children || token.children.length !== 1 && token.children.length !== 3) {
              continue;
            }
            if (token.children.length === 1 && token.children[0].type !== "image") {
              continue;
            }
            if (token.children.length === 3 && (token.children[0].type !== "link_open" || token.children[1].type !== "image" || token.children[2].type !== "link_close")) {
              continue;
            }
            if (i !== 0 && state.tokens[i - 1].type !== "paragraph_open") {
              continue;
            }
            if (i !== l - 1 && state.tokens[i + 1].type !== "paragraph_close") {
              continue;
            }
            var figure = state.tokens[i - 1];
            figure.type = "figure_open";
            figure.tag = "figure";
            state.tokens[i + 1].type = "figure_close";
            state.tokens[i + 1].tag = "figure";
            if (options.dataType == true) {
              state.tokens[i - 1].attrPush([
                "data-type",
                "image"
              ]);
            }
            var image;
            if (options.link == true && token.children.length === 1) {
              image = token.children[0];
              token.children.unshift(new state.Token("link_open", "a", 1));
              token.children[0].attrPush([
                "href",
                image.attrGet("src")
              ]);
              token.children.push(new state.Token("link_close", "a", -1));
            }
            image = token.children.length === 1 ? token.children[0] : token.children[1];
            if (options.figcaption) {
              var captionOptionString = new String(options.figcaption).toLowerCase().trim();
              if (captionOptionString == "title") {
                var figCaption;
                var captionObj = image.attrs.find(function ([k]) {
                  return k === "title";
                });
                if (Array.isArray(captionObj)) {
                  figCaption = captionObj[1];
                }
                if (figCaption) {
                  var captionArray = md.parseInline(figCaption);
                  var captionContent = { children: [] };
                  if (Array.isArray(captionArray) && captionArray.length) {
                    captionContent = captionArray[0];
                  }
                  token.children.push(new state.Token("figcaption_open", "figcaption", 1));
                  token.children.push(...captionContent.children);
                  token.children.push(new state.Token("figcaption_close", "figcaption", -1));
                  if (image.attrs) {
                    image.attrs = image.attrs.filter(function ([k]) {
                      return k !== "title";
                    });
                  }
                }
              } else if (options.figcaption == true || captionOptionString == "alt") {
                if (image.children && image.children.length) {
                  token.children.push(new state.Token("figcaption_open", "figcaption", 1));
                  token.children.splice(token.children.length, 0, ...image.children);
                  token.children.push(new state.Token("figcaption_close", "figcaption", -1));
                  if (!options.keepAlt)
                    image.children.length = 0;
                }
              }
            }
            if (options.copyAttrs && image.attrs) {
              var f = options.copyAttrs === true ? "" : options.copyAttrs;
              figure.attrs = image.attrs.filter(function ([k]) {
                return k.match(f);
              });
            }
            if (options.tabindex == true) {
              state.tokens[i - 1].attrPush([
                "tabindex",
                tabIndex
              ]);
              tabIndex++;
            }
            if (options.lazyLoading == true) {
              image.attrPush([
                "loading",
                "lazy"
              ]);
            }
          }
        }
        md.core.ruler.before("linkify", "implicit_figures", implicitFigures);
      };
      var exports$1$2 = exports$6;

      var exports$5 = {};
      const validAudioExtensions = [
        "aac",
        "m4a",
        "mp3",
        "oga",
        "ogg",
        "wav"
      ];
      const validVideoExtensions = [
        "mp4",
        "m4v",
        "ogv",
        "webm",
        "mpg",
        "mpeg"
      ];
      let messages = {
        en: {
          "html5 video not supported": "Your browser does not support playing HTML5 video.",
          "html5 audio not supported": "Your browser does not support playing HTML5 audio.",
          "html5 media fallback link": "You can <a href=\"%s\" download>download the file</a> instead.",
          "html5 media description": "Here is a description of the content: %s"
        }
      };
      let translate = function (language, messageKey, messageParams) {
        if (!messages[language] || !messages[language][messageKey])
          language = "en";
        if (!messages[language])
          return "";
        let message = messages[language][messageKey] || "";
        if (messageParams)
          for (let param of messageParams)
            message = message.replace("%s", param);
        return message;
      };
      function tokenizeImagesAndMedia(state, silent, md) {
        let attrs, code, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start;
        let href = "", oldPos = state.pos, max = state.posMax;
        if (state.src.charCodeAt(state.pos) !== 33 || state.src.charCodeAt(state.pos + 1) !== 91)
          return false;
        labelStart = state.pos + 2;
        labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
        if (labelEnd < 0)
          return false;
        pos = labelEnd + 1;
        if (pos < max && state.src.charCodeAt(pos) === 40) {
          pos++;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!md.utils.isSpace(code) && code !== 10)
              break;
          }
          if (pos >= max)
            return false;
          start = pos;
          res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
          if (res.ok) {
            href = state.md.normalizeLink(res.str);
            if (state.md.validateLink(href)) {
              pos = res.pos;
            } else {
              href = "";
            }
          }
          start = pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!md.utils.isSpace(code) && code !== 10)
              break;
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max && start !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max; pos++) {
              code = state.src.charCodeAt(pos);
              if (!md.utils.isSpace(code) && code !== 10)
                break;
            }
          } else {
            title = "";
          }
          if (pos >= max || state.src.charCodeAt(pos) !== 41) {
            state.pos = oldPos;
            return false;
          }
          pos++;
        } else {
          if (typeof state.env.references === "undefined")
            return false;
          if (pos < max && state.src.charCodeAt(pos) === 91) {
            start = pos + 1;
            pos = state.md.helpers.parseLinkLabel(state, pos);
            if (pos >= 0) {
              label = state.src.slice(start, pos++);
            } else {
              pos = labelEnd + 1;
            }
          } else {
            pos = labelEnd + 1;
          }
          if (!label)
            label = state.src.slice(labelStart, labelEnd);
          ref = state.env.references[md.utils.normalizeReference(label)];
          if (!ref) {
            state.pos = oldPos;
            return false;
          }
          href = ref.href;
          title = ref.title;
        }
        state.pos = pos;
        state.posMax = max;
        if (silent)
          return true;
        content = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(content, state.md, state.env, tokens = []);
        const mediaType = guessMediaType(href);
        const tag = mediaType == "image" ? "img" : mediaType;
        token = state.push(mediaType, tag, 0);
        token.attrs = attrs = [[
            "src",
            href
          ]];
        if (mediaType == "image")
          attrs.push([
            "alt",
            ""
          ]);
        token.children = tokens;
        token.content = content;
        if (title)
          attrs.push([
            "title",
            title
          ]);
        state.pos = pos;
        state.posMax = max;
        return true;
      }
      function guessMediaType(url) {
        const extensionMatch = url.match(/\.([^/.]+)$/);
        if (extensionMatch === null)
          return "image";
        const extension = extensionMatch[1];
        if (validAudioExtensions.indexOf(extension.toLowerCase()) != -1)
          return "audio";
        else if (validVideoExtensions.indexOf(extension.toLowerCase()) != -1)
          return "video";
        else
          return "image";
      }
      function renderMedia(tokens, idx, options, env, md) {
        const token = tokens[idx];
        const type = token.type;
        if (type !== "video" && type !== "audio")
          return "";
        let attrs = options.html5Media[`${ type }Attrs`].trim();
        if (attrs)
          attrs = " " + attrs;
        const url = token.attrs[token.attrIndex("src")][1];
        const title = token.attrIndex("title") != -1 ? ` title="${ md.utils.escapeHtml(token.attrs[token.attrIndex("title")][1]) }"` : "";
        const fallbackText = translate(env.language, `html5 ${ type } not supported`) + "\n" + translate(env.language, "html5 media fallback link", [url]);
        const description = token.content ? "\n" + translate(env.language, "html5 media description", [md.utils.escapeHtml(token.content)]) : "";
        return `<${ type } src="${ url }"${ title }${ attrs }>\n` + `${ fallbackText }${ description }\n` + `</${ type }>`;
      }
      function html5Media(md, options = {}) {
        if (options.messages)
          messages = options.messages;
        if (options.translateFn)
          translate = options.translateFn;
        const videoAttrs = options.videoAttrs !== undefined ? options.videoAttrs : "controls class=\"html5-video-player\"";
        const audioAttrs = options.audioAttrs !== undefined ? options.audioAttrs : "controls class=\"html5-audio-player\"";
        md.inline.ruler.at("image", (tokens, silent) => tokenizeImagesAndMedia(tokens, silent, md));
        md.renderer.rules.video = md.renderer.rules.audio = (tokens, idx, opt, env) => {
          opt.html5Media = {
            videoAttrs,
            audioAttrs
          };
          return renderMedia(tokens, idx, opt, env, md);
        };
      }
      exports$5 = {
        html5Media,
        messages,
        guessMediaType
      };
      const _html5Media = exports$5.html5Media; exports$5.messages; exports$5.guessMediaType;

      var exports$4 = {};
      exports$4.getAttrs = function (str, start, options) {
        const allowedKeyChars = /[^\t\n\f />"'=]/;
        const pairSeparator = " ";
        const keySeparator = "=";
        const classChar = ".";
        const idChar = "#";
        const attrs = [];
        let key = "";
        let value = "";
        let parsingKey = true;
        let valueInsideQuotes = false;
        for (let i = start + options.leftDelimiter.length; i < str.length; i++) {
          if (str.slice(i, i + options.rightDelimiter.length) === options.rightDelimiter) {
            if (key !== "") {
              attrs.push([
                key,
                value
              ]);
            }
            break;
          }
          const char_ = str.charAt(i);
          if (char_ === keySeparator && parsingKey) {
            parsingKey = false;
            continue;
          }
          if (char_ === classChar && key === "") {
            if (str.charAt(i + 1) === classChar) {
              key = "css-module";
              i += 1;
            } else {
              key = "class";
            }
            parsingKey = false;
            continue;
          }
          if (char_ === idChar && key === "") {
            key = "id";
            parsingKey = false;
            continue;
          }
          if (char_ === "\"" && value === "" && !valueInsideQuotes) {
            valueInsideQuotes = true;
            continue;
          }
          if (char_ === "\"" && valueInsideQuotes) {
            valueInsideQuotes = false;
            continue;
          }
          if (char_ === pairSeparator && !valueInsideQuotes) {
            if (key === "") {
              continue;
            }
            attrs.push([
              key,
              value
            ]);
            key = "";
            value = "";
            parsingKey = true;
            continue;
          }
          if (parsingKey && char_.search(allowedKeyChars) === -1) {
            continue;
          }
          if (parsingKey) {
            key += char_;
            continue;
          }
          value += char_;
        }
        if (options.allowedAttributes && options.allowedAttributes.length) {
          const allowedAttributes = options.allowedAttributes;
          return attrs.filter(function (attrPair) {
            const attr = attrPair[0];
            function isAllowedAttribute(allowedAttribute) {
              return attr === allowedAttribute || allowedAttribute instanceof RegExp && allowedAttribute.test(attr);
            }
            return allowedAttributes.some(isAllowedAttribute);
          });
        }
        return attrs;
      };
      exports$4.addAttrs = function (attrs, token) {
        for (let j = 0, l = attrs.length; j < l; ++j) {
          const key = attrs[j][0];
          if (key === "class") {
            token.attrJoin("class", attrs[j][1]);
          } else if (key === "css-module") {
            token.attrJoin("css-module", attrs[j][1]);
          } else {
            token.attrPush(attrs[j]);
          }
        }
        return token;
      };
      exports$4.hasDelimiters = function (where, options) {
        if (!where) {
          throw new Error("Parameter `where` not passed. Should be \"start\", \"end\" or \"only\".");
        }
        return function (str) {
          const minCurlyLength = options.leftDelimiter.length + 1 + options.rightDelimiter.length;
          if (!str || typeof str !== "string" || str.length < minCurlyLength) {
            return false;
          }
          function validCurlyLength(curly) {
            const isClass = curly.charAt(options.leftDelimiter.length) === ".";
            const isId = curly.charAt(options.leftDelimiter.length) === "#";
            return isClass || isId ? curly.length >= minCurlyLength + 1 : curly.length >= minCurlyLength;
          }
          let start, end, slice, nextChar;
          const rightDelimiterMinimumShift = minCurlyLength - options.rightDelimiter.length;
          switch (where) {
          case "start":
            slice = str.slice(0, options.leftDelimiter.length);
            start = slice === options.leftDelimiter ? 0 : -1;
            end = start === -1 ? -1 : str.indexOf(options.rightDelimiter, rightDelimiterMinimumShift);
            nextChar = str.charAt(end + options.rightDelimiter.length);
            if (nextChar && options.rightDelimiter.indexOf(nextChar) !== -1) {
              end = -1;
            }
            break;
          case "end":
            start = str.lastIndexOf(options.leftDelimiter);
            end = start === -1 ? -1 : str.indexOf(options.rightDelimiter, start + rightDelimiterMinimumShift);
            end = end === str.length - options.rightDelimiter.length ? end : -1;
            break;
          case "only":
            slice = str.slice(0, options.leftDelimiter.length);
            start = slice === options.leftDelimiter ? 0 : -1;
            slice = str.slice(str.length - options.rightDelimiter.length);
            end = slice === options.rightDelimiter ? str.length - options.rightDelimiter.length : -1;
            break;
          default:
            throw new Error(`Unexpected case ${ where }, expected 'start', 'end' or 'only'`);
          }
          return start !== -1 && end !== -1 && validCurlyLength(str.substring(start, end + options.rightDelimiter.length));
        };
      };
      exports$4.removeDelimiter = function (str, options) {
        const start = escapeRegExp(options.leftDelimiter);
        const end = escapeRegExp(options.rightDelimiter);
        const curly = new RegExp("[ \\n]?" + start + "[^" + start + end + "]+" + end + "$");
        const pos = str.search(curly);
        return pos !== -1 ? str.slice(0, pos) : str;
      };
      function escapeRegExp(s) {
        return s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      exports$4.escapeRegExp = escapeRegExp;
      exports$4.getMatchingOpeningToken = function (tokens, i) {
        if (tokens[i].type === "softbreak") {
          return false;
        }
        if (tokens[i].nesting === 0) {
          return tokens[i];
        }
        const level = tokens[i].level;
        const type = tokens[i].type.replace("_close", "_open");
        for (; i >= 0; --i) {
          if (tokens[i].type === type && tokens[i].level === level) {
            return tokens[i];
          }
        }
        return false;
      };
      const HTML_ESCAPE_TEST_RE = /[&<>"]/;
      const HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
      const HTML_REPLACEMENTS = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "\"": "&quot;"
      };
      function replaceUnsafeChar(ch) {
        return HTML_REPLACEMENTS[ch];
      }
      exports$4.escapeHtml = function (str) {
        if (HTML_ESCAPE_TEST_RE.test(str)) {
          return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
        }
        return str;
      };
      exports$4.getAttrs; exports$4.addAttrs; exports$4.hasDelimiters; exports$4.removeDelimiter; exports$4.getMatchingOpeningToken; exports$4.escapeHtml;
      exports$4.escapeRegExp;

      var exports$2 = {};
      const utils = exports$4;
      exports$2 = options => {
        const __hr = new RegExp("^ {0,3}[-*_]{3,} ?" + utils.escapeRegExp(options.leftDelimiter) + "[^" + utils.escapeRegExp(options.rightDelimiter) + "]");
        return [
          {
            name: "fenced code blocks",
            tests: [{
                shift: 0,
                block: true,
                info: utils.hasDelimiters("end", options)
              }],
            transform: (tokens, i) => {
              const token = tokens[i];
              const start = token.info.lastIndexOf(options.leftDelimiter);
              const attrs = utils.getAttrs(token.info, start, options);
              utils.addAttrs(attrs, token);
              token.info = utils.removeDelimiter(token.info, options);
            }
          },
          {
            name: "inline nesting 0",
            tests: [{
                shift: 0,
                type: "inline",
                children: [
                  {
                    shift: -1,
                    type: str => str === "image" || str === "code_inline"
                  },
                  {
                    shift: 0,
                    type: "text",
                    content: utils.hasDelimiters("start", options)
                  }
                ]
              }],
            transform: (tokens, i, j) => {
              const token = tokens[i].children[j];
              const endChar = token.content.indexOf(options.rightDelimiter);
              const attrToken = tokens[i].children[j - 1];
              const attrs = utils.getAttrs(token.content, 0, options);
              utils.addAttrs(attrs, attrToken);
              if (token.content.length === endChar + options.rightDelimiter.length) {
                tokens[i].children.splice(j, 1);
              } else {
                token.content = token.content.slice(endChar + options.rightDelimiter.length);
              }
            }
          },
          {
            name: "tables",
            tests: [
              {
                shift: 0,
                type: "table_close"
              },
              {
                shift: 1,
                type: "paragraph_open"
              },
              {
                shift: 2,
                type: "inline",
                content: utils.hasDelimiters("only", options)
              }
            ],
            transform: (tokens, i) => {
              const token = tokens[i + 2];
              const tableOpen = utils.getMatchingOpeningToken(tokens, i);
              const attrs = utils.getAttrs(token.content, 0, options);
              utils.addAttrs(attrs, tableOpen);
              tokens.splice(i + 1, 3);
            }
          },
          {
            name: "inline attributes",
            tests: [{
                shift: 0,
                type: "inline",
                children: [
                  {
                    shift: -1,
                    nesting: -1
                  },
                  {
                    shift: 0,
                    type: "text",
                    content: utils.hasDelimiters("start", options)
                  }
                ]
              }],
            transform: (tokens, i, j) => {
              const token = tokens[i].children[j];
              const content = token.content;
              const attrs = utils.getAttrs(content, 0, options);
              const openingToken = utils.getMatchingOpeningToken(tokens[i].children, j - 1);
              utils.addAttrs(attrs, openingToken);
              token.content = content.slice(content.indexOf(options.rightDelimiter) + options.rightDelimiter.length);
            }
          },
          {
            name: "list softbreak",
            tests: [
              {
                shift: -2,
                type: "list_item_open"
              },
              {
                shift: 0,
                type: "inline",
                children: [
                  {
                    position: -2,
                    type: "softbreak"
                  },
                  {
                    position: -1,
                    type: "text",
                    content: utils.hasDelimiters("only", options)
                  }
                ]
              }
            ],
            transform: (tokens, i, j) => {
              const token = tokens[i].children[j];
              const content = token.content;
              const attrs = utils.getAttrs(content, 0, options);
              let ii = i - 2;
              while (tokens[ii - 1] && tokens[ii - 1].type !== "ordered_list_open" && tokens[ii - 1].type !== "bullet_list_open") {
                ii--;
              }
              utils.addAttrs(attrs, tokens[ii - 1]);
              tokens[i].children = tokens[i].children.slice(0, -2);
            }
          },
          {
            name: "list double softbreak",
            tests: [
              {
                shift: 0,
                type: str => str === "bullet_list_close" || str === "ordered_list_close"
              },
              {
                shift: 1,
                type: "paragraph_open"
              },
              {
                shift: 2,
                type: "inline",
                content: utils.hasDelimiters("only", options),
                children: arr => arr.length === 1
              },
              {
                shift: 3,
                type: "paragraph_close"
              }
            ],
            transform: (tokens, i) => {
              const token = tokens[i + 2];
              const content = token.content;
              const attrs = utils.getAttrs(content, 0, options);
              const openingToken = utils.getMatchingOpeningToken(tokens, i);
              utils.addAttrs(attrs, openingToken);
              tokens.splice(i + 1, 3);
            }
          },
          {
            name: "list item end",
            tests: [
              {
                shift: -2,
                type: "list_item_open"
              },
              {
                shift: 0,
                type: "inline",
                children: [{
                    position: -1,
                    type: "text",
                    content: utils.hasDelimiters("end", options)
                  }]
              }
            ],
            transform: (tokens, i, j) => {
              const token = tokens[i].children[j];
              const content = token.content;
              const attrs = utils.getAttrs(content, content.lastIndexOf(options.leftDelimiter), options);
              utils.addAttrs(attrs, tokens[i - 2]);
              const trimmed = content.slice(0, content.lastIndexOf(options.leftDelimiter));
              token.content = last$1(trimmed) !== " " ? trimmed : trimmed.slice(0, -1);
            }
          },
          {
            name: "\n{.a} softbreak then curly in start",
            tests: [{
                shift: 0,
                type: "inline",
                children: [
                  {
                    position: -2,
                    type: "softbreak"
                  },
                  {
                    position: -1,
                    type: "text",
                    content: utils.hasDelimiters("only", options)
                  }
                ]
              }],
            transform: (tokens, i, j) => {
              const token = tokens[i].children[j];
              const attrs = utils.getAttrs(token.content, 0, options);
              let ii = i + 1;
              while (tokens[ii + 1] && tokens[ii + 1].nesting === -1) {
                ii++;
              }
              const openingToken = utils.getMatchingOpeningToken(tokens, ii);
              utils.addAttrs(attrs, openingToken);
              tokens[i].children = tokens[i].children.slice(0, -2);
            }
          },
          {
            name: "horizontal rule",
            tests: [
              {
                shift: 0,
                type: "paragraph_open"
              },
              {
                shift: 1,
                type: "inline",
                children: arr => arr.length === 1,
                content: str => str.match(__hr) !== null
              },
              {
                shift: 2,
                type: "paragraph_close"
              }
            ],
            transform: (tokens, i) => {
              const token = tokens[i];
              token.type = "hr";
              token.tag = "hr";
              token.nesting = 0;
              const content = tokens[i + 1].content;
              const start = content.lastIndexOf(options.leftDelimiter);
              const attrs = utils.getAttrs(content, start, options);
              utils.addAttrs(attrs, token);
              token.markup = content;
              tokens.splice(i + 1, 2);
            }
          },
          {
            name: "end of block",
            tests: [{
                shift: 0,
                type: "inline",
                children: [{
                    position: -1,
                    content: utils.hasDelimiters("end", options),
                    type: t => t !== "code_inline" && t !== "math_inline"
                  }]
              }],
            transform: (tokens, i, j) => {
              const token = tokens[i].children[j];
              const content = token.content;
              const attrs = utils.getAttrs(content, content.lastIndexOf(options.leftDelimiter), options);
              let ii = i + 1;
              while (tokens[ii + 1] && tokens[ii + 1].nesting === -1) {
                ii++;
              }
              const openingToken = utils.getMatchingOpeningToken(tokens, ii);
              utils.addAttrs(attrs, openingToken);
              const trimmed = content.slice(0, content.lastIndexOf(options.leftDelimiter));
              token.content = last$1(trimmed) !== " " ? trimmed : trimmed.slice(0, -1);
            }
          }
        ];
      };
      function last$1(arr) {
        return arr.slice(-1)[0];
      }
      var _patterns = exports$2;
      var exports$3 = {};
      const patternsConfig = _patterns;
      const defaultOptions = {
        leftDelimiter: "{",
        rightDelimiter: "}",
        allowedAttributes: []
      };
      exports$3 = function attributes(md, options_) {
        let options = Object.assign({}, defaultOptions);
        options = Object.assign(options, options_);
        const patterns = patternsConfig(options);
        function curlyAttrs(state) {
          const tokens = state.tokens;
          for (let i = 0; i < tokens.length; i++) {
            for (let p = 0; p < patterns.length; p++) {
              const pattern = patterns[p];
              let j = null;
              const match = pattern.tests.every(t => {
                const res = test(tokens, i, t);
                if (res.j !== null) {
                  j = res.j;
                }
                return res.match;
              });
              if (match) {
                pattern.transform(tokens, i, j);
                if (pattern.name === "inline attributes" || pattern.name === "inline nesting 0") {
                  p--;
                }
              }
            }
          }
        }
        md.core.ruler.before("linkify", "curly_attributes", curlyAttrs);
      };
      function test(tokens, i, t) {
        const res = {
          match: false,
          j: null
        };
        const ii = t.shift !== undefined ? i + t.shift : t.position;
        if (t.shift !== undefined && ii < 0) {
          return res;
        }
        const token = get(tokens, ii);
        if (token === undefined) {
          return res;
        }
        for (const key of Object.keys(t)) {
          if (key === "shift" || key === "position") {
            continue;
          }
          if (token[key] === undefined) {
            return res;
          }
          if (key === "children" && isArrayOfObjects(t.children)) {
            if (token.children.length === 0) {
              return res;
            }
            let match;
            const childTests = t.children;
            const children = token.children;
            if (childTests.every(tt => tt.position !== undefined)) {
              match = childTests.every(tt => test(children, tt.position, tt).match);
              if (match) {
                const j = last(childTests).position;
                res.j = j >= 0 ? j : children.length + j;
              }
            } else {
              for (let j = 0; j < children.length; j++) {
                match = childTests.every(tt => test(children, j, tt).match);
                if (match) {
                  res.j = j;
                  break;
                }
              }
            }
            if (match === false) {
              return res;
            }
            continue;
          }
          switch (typeof t[key]) {
          case "boolean":
          case "number":
          case "string":
            if (token[key] !== t[key]) {
              return res;
            }
            break;
          case "function":
            if (!t[key](token[key])) {
              return res;
            }
            break;
          case "object":
            if (isArrayOfFunctions(t[key])) {
              const r = t[key].every(tt => tt(token[key]));
              if (r === false) {
                return res;
              }
              break;
            }
          default:
            throw new Error(`Unknown type of pattern test (key: ${ key }). Test should be of type boolean, number, string, function or array of functions.`);
          }
        }
        res.match = true;
        return res;
      }
      function isArrayOfObjects(arr) {
        return Array.isArray(arr) && arr.length && arr.every(i => typeof i === "object");
      }
      function isArrayOfFunctions(arr) {
        return Array.isArray(arr) && arr.length && arr.every(i => typeof i === "function");
      }
      function get(arr, n) {
        return n >= 0 ? arr[n] : arr[arr.length + n];
      }
      function last(arr) {
        return arr.slice(-1)[0] || {};
      }
      var exports$1$1 = exports$3;

      var __varRecorder__$v = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/md/compiler.js", __contextModule__);
      var __moduleMeta__$e = {
        pathInPackage: function pathInPackage() {
          return "./md/compiler.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var addSourceLineMappingPlugin = __varRecorder__$v["lively.ide/md/compiler.js__define__"]("addSourceLineMappingPlugin", "function", function (md) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        options = Object.assign({}, md.options, {}, options);
        if (!options.addSourceLineMapping) return;

        function injectLineNumbers(tokens, idx, options, env, slf) {
          var mdLine, htmlLine;

          if (tokens[idx].map && tokens[idx].level === 0) {
            var _tokens$idx$map = _slicedToArray(tokens[idx].map, 2),
                mdLine = _tokens$idx$map[0],
                htmlLine = _tokens$idx$map[1];

            tokens[idx].attrJoin("class", "markdown-line-marker");
            tokens[idx].attrSet("data-mdline", String(mdLine));
            tokens[idx].attrSet("data-htmlline", String(htmlLine));
          }

          return slf.renderToken(tokens, idx, options, env, slf);
        }

        md.renderer.rules.paragraph_open = md.renderer.rules.heading_open = injectLineNumbers;
      }, __moduleMeta__$e);

      __varRecorder__$v.addSourceLineMappingPlugin = addSourceLineMappingPlugin;

      var externalizeLinksPlugin = __varRecorder__$v["lively.ide/md/compiler.js__define__"]("externalizeLinksPlugin", "function", function (md) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        options = Object.assign({}, md.options, {}, options);
        if (!options.externalizeLinks) return;
        var _options$externalizeL = options.externalizeLinks,
            _options$externalizeL2 = _options$externalizeL.internalDomains,
            internalDomains = _options$externalizeL2 === void 0 ? [] : _options$externalizeL2,
            _options$externalizeL3 = _options$externalizeL.internalTarget,
            internalTarget = _options$externalizeL3 === void 0 ? "_blank" : _options$externalizeL3,
            _options$externalizeL4 = _options$externalizeL.externalTarget,
            externalTarget = _options$externalizeL4 === void 0 ? "_blank" : _options$externalizeL4,
            _options$externalizeL5 = _options$externalizeL.internalRel,
            internalRel = _options$externalizeL5 === void 0 ? "" : _options$externalizeL5,
            _options$externalizeL6 = _options$externalizeL.externalRel,
            externalRel = _options$externalizeL6 === void 0 ? "" : _options$externalizeL6;

        function externalLinks(state) {
          function getDomain(href) {
            var domain = href.split("//")[1];

            if (domain) {
              domain = domain.split("/")[0].toLowerCase();
              return domain || null;
            }

            return null;
          }

          function isInternalLink(href) {
            var domain = getDomain(href);
            return domain === null || internalDomains.indexOf(domain) !== -1;
          }

          function applyFilterToTokenHierarchy(token) {
            if (token.children) token.children.map(applyFilterToTokenHierarchy);

            if (token.type === "link_open") {
              var href = token.attrGet("href");
              var internal = isInternalLink(href);
              var target = internal ? internalTarget : externalTarget;
              if (target !== "_self") token.attrSet("target", target);
              var rel = internal ? internalRel : externalRel;

              if (rel) {
                var existingRel = token.attrGet("rel") || "";
                if (existingRel !== "") rel = existingRel + " " + rel;
                token.attrSet("rel", rel);
              }
            }
          }

          state.tokens.map(applyFilterToTokenHierarchy);
        }

        md.core.ruler.push("external_links", externalLinks);
      }, __moduleMeta__$e);

      __varRecorder__$v.externalizeLinksPlugin = externalizeLinksPlugin;

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/md/compiler.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("MarkdownCompiler") && typeof __lively_classholder__.MarkdownCompiler === "function" ? __lively_classholder__.MarkdownCompiler : __lively_classholder__.MarkdownCompiler = function MarkdownCompiler(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "compileToHTML",
          value: function MarkdownCompiler_compileToHTML_(src) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var linkedCSS = options.linkedCSS,
                markdownWrapperTemplate = options.markdownWrapperTemplate;
            options.html = true;
            var md = exports$1$5(options).use(__varRecorder__$v.externalizeLinksPlugin).use(__varRecorder__$v.addSourceLineMappingPlugin).use(exports$1$3).use(exports$1$1).use(exports$1$2, {
              dataType: true,
              figcaption: true
            }).use(_html5Media).use(_missingExportShim);
            var html = md.render(src);

            if (markdownWrapperTemplate) {
              html = format$2(markdownWrapperTemplate, html);
            }

            if (linkedCSS) {
              for (var id in linkedCSS) {
                html = "<link type=\"text/css\" rel=\"stylesheet\" id=\"".concat(id, "\" href=\"").concat(linkedCSS[id], "\">") + html;
              }
            }

            return html;
          }
        }, {
          key: "parse",
          value: function MarkdownCompiler_parse_(editor, options) {
            options.html = true;
            var md = exports$1$5(options).use(__varRecorder__$v.externalizeLinksPlugin).use(exports$1$3).use(exports$1$2, {
              dataType: true,
              figcaption: true
            }).use(exports$1$1).use(_html5Media).use(_missingExportShim);
            var src = editor.textString;
            var parsed = md.parse(editor.textString, {});
            var lines = src.split("\n");
            var headings = parsed.filter(function (ea) {
              return ea.type === "heading_open";
            }).map(function (heading, i) {
              var _heading$map = _slicedToArray(heading.map, 1),
                  line = _heading$map[0],
                  level = heading.level;

              return {
                line: line,
                depth: level + 1,
                string: lines[line].trim()
              };
            });
            return {
              parsed: parsed,
              headings: headings
            };
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "MarkdownCompiler";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./md/compiler.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 1098,
          end: 2582
        });
      })(undefined);

      __varRecorder__$v.mdCompiler = new __varRecorder__$v.MarkdownCompiler();
      var mdCompiler = __varRecorder__$v.mdCompiler;
      __varRecorder__$v.mdCompiler = mdCompiler;

      var __varRecorder__$u = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/md/snippets.js", __contextModule__);
      __varRecorder__$u.snippets = [["table", "| $0      | $1      |\n| ----------- | ----------- |\n| $2          | $3          |\n| $4          | $5          |"]];
      var snippets = __varRecorder__$u.snippets;
      __varRecorder__$u.snippets = snippets;

      var __varRecorder__$t = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/css/mode.js", __contextModule__);
      var __moduleMeta__$d = {
        pathInPackage: function pathInPackage() {
          return "./css/mode.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var keySet = __varRecorder__$t["lively.ide/css/mode.js__define__"]("keySet", "function", function (array) {
        var keys = {};

        for (var i = 0; i < array.length; ++i) {
          keys[array[i].toLowerCase()] = true;
        }

        return keys;
      }, __moduleMeta__$d);

      __varRecorder__$t.keySet = keySet;

      var tokenCComment = __varRecorder__$t["lively.ide/css/mode.js__define__"]("tokenCComment", "function", function (stream, state) {
        var maybeEnd = false;
        var ch;

        while ((ch = stream.next()) != null) {
          if (maybeEnd && ch == "/") {
            state.tokenize = null;
            break;
          }

          maybeEnd = ch == "*";
        }

        return ["comment", "comment"];
      }, __moduleMeta__$d);

      __varRecorder__$t.tokenCComment = tokenCComment;
      defineMode("css", function (config, parserConfig) {
        var inline = parserConfig.inline;
        if (!parserConfig.propertyKeywords) parserConfig = Object.assign({}, __varRecorder__$t.defaultParserConfig);
        var indentUnit = config.indentUnit;
        var tokenHooks = parserConfig.tokenHooks;
        var documentTypes = parserConfig.documentTypes || {};
        var mediaTypes = parserConfig.mediaTypes || {};
        var mediaFeatures = parserConfig.mediaFeatures || {};
        var mediaValueKeywords = parserConfig.mediaValueKeywords || {};
        var propertyKeywords = parserConfig.propertyKeywords || {};
        var nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {};
        var fontProperties = parserConfig.fontProperties || {};
        var counterDescriptors = parserConfig.counterDescriptors || {};
        var colorKeywords = parserConfig.colorKeywords || {};
        var valueKeywords = parserConfig.valueKeywords || {};
        var allowNested = parserConfig.allowNested;
        var lineComment = parserConfig.lineComment;
        var supportsAtComponent = parserConfig.supportsAtComponent === true;
        var type, override;

        function ret(style, tp) {
          type = tp;
          return style;
        }

        function tokenBase(stream, state) {
          var ch = stream.next();

          if (tokenHooks[ch]) {
            var result = tokenHooks[ch](stream, state);
            if (result !== false) return result;
          }

          if (ch == "@") {
            stream.eatWhile(/[\w\\\-]/);
            return ret("def", stream.current());
          } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
            return ret(null, "compare");
          } else if (ch == "\"" || ch == "'") {
            state.tokenize = tokenString(ch);
            return state.tokenize(stream, state);
          } else if (ch == "#") {
            stream.eatWhile(/[\w\\\-]/);
            return ret("atom", "hash");
          } else if (ch == "!") {
            stream.match(/^\s*\w*/);
            return ret("keyword", "important");
          } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
            stream.eatWhile(/[\w.%]/);
            return ret("number", "unit");
          } else if (ch === "-") {
            if (/[\d.]/.test(stream.peek())) {
              stream.eatWhile(/[\w.%]/);
              return ret("number", "unit");
            } else if (stream.match(/^-[\w\\\-]+/)) {
              stream.eatWhile(/[\w\\\-]/);

              if (stream.match(/^\s*:/, false)) {
                return ret("variable-2", "variable-definition");
              }

              return ret("variable-2", "variable");
            } else if (stream.match(/^\w+-/)) {
              return ret("meta", "meta");
            }
          } else if (/[,+>*\/]/.test(ch)) {
            return ret(null, "select-op");
          } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
            return ret("qualifier", "qualifier");
          } else if (/[:;{}\[\]\(\)]/.test(ch)) {
            return ret(null, ch);
          } else if (ch == "u" && stream.match(/rl(-prefix)?\(/) || ch == "d" && stream.match("omain(") || ch == "r" && stream.match("egexp(")) {
            stream.backUp(1);
            state.tokenize = tokenParenthesized;
            return ret("property", "word");
          } else if (/[\w\\\-]/.test(ch)) {
            stream.eatWhile(/[\w\\\-]/);
            return ret("property", "word");
          } else {
            return ret(null, null);
          }
        }

        function tokenString(quote) {
          return function (stream, state) {
            var escaped = false;
            var ch;

            while ((ch = stream.next()) != null) {
              if (ch == quote && !escaped) {
                if (quote == ")") stream.backUp(1);
                break;
              }

              escaped = !escaped && ch == "\\";
            }

            if (ch == quote || !escaped && quote != ")") state.tokenize = null;
            return ret("string", "string");
          };
        }

        function tokenParenthesized(stream, state) {
          stream.next();

          if (!stream.match(/\s*[\"\')]/, false)) {
            state.tokenize = tokenString(")");
          } else {
            state.tokenize = null;
          }

          return ret(null, "(");
        }

        function Context(type, indent, prev) {
          this.type = type;
          this.indent = indent;
          this.prev = prev;
        }

        function pushContext(state, stream, type, indent) {
          state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
          return type;
        }

        function popContext(state) {
          if (state.context.prev) {
            state.context = state.context.prev;
          }

          return state.context.type;
        }

        function pass(type, stream, state) {
          return states[state.context.type](type, stream, state);
        }

        function popAndPass(type, stream, state, n) {
          for (var i = n || 1; i > 0; i--) {
            state.context = state.context.prev;
          }

          return pass(type, stream, state);
        }

        function wordAsValue(stream) {
          var word = stream.current().toLowerCase();

          if (valueKeywords.hasOwnProperty(word)) {
            override = "atom";
          } else if (colorKeywords.hasOwnProperty(word)) {
            override = "keyword";
          } else {
            override = "variable";
          }
        }

        var states = {};

        states.top = function (type, stream, state) {
          if (type == "{") {
            return pushContext(state, stream, "block");
          } else if (type == "}" && state.context.prev) {
            return popContext(state);
          } else if (supportsAtComponent && /@component/.test(type)) {
            return pushContext(state, stream, "atComponentBlock");
          } else if (/^@(-moz-)?document$/.test(type)) {
            return pushContext(state, stream, "documentTypes");
          } else if (/^@(media|supports|(-moz-)?document|import)$/.test(type)) {
            return pushContext(state, stream, "atBlock");
          } else if (/^@(font-face|counter-style)/.test(type)) {
            state.stateArg = type;
            return "restricted_atBlock_before";
          } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {
            return "keyframes";
          } else if (type && type.charAt(0) == "@") {
            return pushContext(state, stream, "at");
          } else if (type == "hash") {
            override = "builtin";
          } else if (type == "word") {
            override = "tag";
          } else if (type == "variable-definition") {
            return "maybeprop";
          } else if (type == "interpolation") {
            return pushContext(state, stream, "interpolation");
          } else if (type == ":") {
            return "pseudo";
          } else if (allowNested && type == "(") {
            return pushContext(state, stream, "parens");
          }

          return state.context.type;
        };

        states.block = function (type, stream, state) {
          if (type == "word") {
            var word = stream.current().toLowerCase();

            if (propertyKeywords.hasOwnProperty(word)) {
              override = "property";
              return "maybeprop";
            } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
              override = "string-2";
              return "maybeprop";
            } else if (allowNested) {
              override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
              return "block";
            } else {
              override += " error";
              return "maybeprop";
            }
          } else if (type == "meta") {
            return "block";
          } else if (!allowNested && (type == "hash" || type == "qualifier")) {
            override = "error";
            return "block";
          } else {
            return states.top(type, stream, state);
          }
        };

        states.maybeprop = function (type, stream, state) {
          if (type == ":") return pushContext(state, stream, "prop");
          return pass(type, stream, state);
        };

        states.prop = function (type, stream, state) {
          if (type == ";") return popContext(state);
          if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
          if (type == "}" || type == "{") return popAndPass(type, stream, state);
          if (type == "(") return pushContext(state, stream, "parens");

          if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
            override += " error";
          } else if (type == "word") {
            wordAsValue(stream);
          } else if (type == "interpolation") {
            return pushContext(state, stream, "interpolation");
          }

          return "prop";
        };

        states.propBlock = function (type, _stream, state) {
          if (type == "}") return popContext(state);

          if (type == "word") {
            override = "property";
            return "maybeprop";
          }

          return state.context.type;
        };

        states.parens = function (type, stream, state) {
          if (type == "{" || type == "}") return popAndPass(type, stream, state);
          if (type == ")") return popContext(state);
          if (type == "(") return pushContext(state, stream, "parens");
          if (type == "interpolation") return pushContext(state, stream, "interpolation");
          if (type == "word") wordAsValue(stream);
          return "parens";
        };

        states.pseudo = function (type, stream, state) {
          if (type == "meta") return "pseudo";

          if (type == "word") {
            override = "variable-3";
            return state.context.type;
          }

          return pass(type, stream, state);
        };

        states.documentTypes = function (type, stream, state) {
          if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
            override = "tag";
            return state.context.type;
          } else {
            return states.atBlock(type, stream, state);
          }
        };

        states.atBlock = function (type, stream, state) {
          if (type == "(") return pushContext(state, stream, "atBlock_parens");
          if (type == "}" || type == ";") return popAndPass(type, stream, state);
          if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");
          if (type == "interpolation") return pushContext(state, stream, "interpolation");

          if (type == "word") {
            var word = stream.current().toLowerCase();

            if (word == "only" || word == "not" || word == "and" || word == "or") {
              override = "keyword";
            } else if (mediaTypes.hasOwnProperty(word)) {
              override = "attribute";
            } else if (mediaFeatures.hasOwnProperty(word)) {
              override = "property";
            } else if (mediaValueKeywords.hasOwnProperty(word)) {
              override = "keyword";
            } else if (propertyKeywords.hasOwnProperty(word)) {
              override = "property";
            } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
              override = "string-2";
            } else if (valueKeywords.hasOwnProperty(word)) {
              override = "atom";
            } else if (colorKeywords.hasOwnProperty(word)) {
              override = "keyword";
            } else {
              override = "error";
            }
          }

          return state.context.type;
        };

        states.atComponentBlock = function (type, stream, state) {
          if (type == "}") {
            return popAndPass(type, stream, state);
          }

          if (type == "{") {
            return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
          }

          if (type == "word") {
            override = "error";
          }

          return state.context.type;
        };

        states.atBlock_parens = function (type, stream, state) {
          if (type == ")") return popContext(state);
          if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
          return states.atBlock(type, stream, state);
        };

        states.restricted_atBlock_before = function (type, stream, state) {
          if (type == "{") {
            return pushContext(state, stream, "restricted_atBlock");
          }

          if (type == "word" && state.stateArg == "@counter-style") {
            override = "variable";
            return "restricted_atBlock_before";
          }

          return pass(type, stream, state);
        };

        states.restricted_atBlock = function (type, stream, state) {
          if (type == "}") {
            state.stateArg = null;
            return popContext(state);
          }

          if (type == "word") {
            if (state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase()) || state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())) {
              override = "error";
            } else {
              override = "property";
            }

            return "maybeprop";
          }

          return "restricted_atBlock";
        };

        states.keyframes = function (type, stream, state) {
          if (type == "word") {
            override = "variable";
            return "keyframes";
          }

          if (type == "{") return pushContext(state, stream, "top");
          return pass(type, stream, state);
        };

        states.at = function (type, stream, state) {
          if (type == ";") return popContext(state);
          if (type == "{" || type == "}") return popAndPass(type, stream, state);
          if (type == "word") override = "tag";else if (type == "hash") override = "builtin";
          return "at";
        };

        states.interpolation = function (type, stream, state) {
          if (type == "}") return popContext(state);
          if (type == "{" || type == ";") return popAndPass(type, stream, state);
          if (type == "word") override = "variable";else if (type != "variable" && type != "(" && type != ")") override = "error";
          return "interpolation";
        };

        return {
          startState: function startState(base) {
            return {
              tokenize: null,
              state: inline ? "block" : "top",
              stateArg: null,
              context: new Context(inline ? "block" : "top", base || 0, null)
            };
          },
          token: function token(stream, state) {
            if (!state.tokenize && stream.eatSpace()) return null;
            var style = (state.tokenize || tokenBase)(stream, state);

            if (style && _typeof$1(style) === "object") {
              type = style[1];
              style = style[0];
            }

            override = style;
            state.state = states[state.state](type, stream, state);
            return override;
          },
          indent: function indent(state, textAfter) {
            var cx = state.context;
            var ch = textAfter && textAfter.charAt(0);
            var indent = cx.indent;
            if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;

            if (cx.prev) {
              if (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
                cx = cx.prev;
                indent = cx.indent;
              } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") || ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
                indent = Math.max(0, cx.indent - indentUnit);
                cx = cx.prev;
              }
            }

            return indent;
          },
          electricChars: "}",
          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          lineComment: lineComment,
          fold: "brace"
        };
      });
      __varRecorder__$t.documentTypes_ = ["domain", "regexp", "url", "url-prefix"];
      __varRecorder__$t.documentTypes = __varRecorder__$t.keySet(__varRecorder__$t.documentTypes_);
      __varRecorder__$t.mediaTypes_ = ["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"];
      __varRecorder__$t.mediaTypes = __varRecorder__$t.keySet(__varRecorder__$t.mediaTypes_);
      __varRecorder__$t.mediaFeatures_ = ["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid", "orientation", "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio", "pointer", "any-pointer", "hover", "any-hover"];
      __varRecorder__$t.mediaFeatures = __varRecorder__$t.keySet(__varRecorder__$t.mediaFeatures_);
      __varRecorder__$t.mediaValueKeywords_ = ["landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover", "interlace", "progressive"];
      __varRecorder__$t.mediaValueKeywords = __varRecorder__$t.keySet(__varRecorder__$t.mediaValueKeywords_);
      __varRecorder__$t.propertyKeywords_ = ["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "justify-items", "justify-self", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "z-index", "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "text-anchor", "writing-mode"];
      __varRecorder__$t.propertyKeywords = __varRecorder__$t.keySet(__varRecorder__$t.propertyKeywords_);
      __varRecorder__$t.nonStandardPropertyKeywords_ = ["scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color", "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "zoom"];
      __varRecorder__$t.nonStandardPropertyKeywords = __varRecorder__$t.keySet(__varRecorder__$t.nonStandardPropertyKeywords_);
      __varRecorder__$t.fontProperties_ = ["font-family", "src", "unicode-range", "font-variant", "font-feature-settings", "font-stretch", "font-weight", "font-style"];
      __varRecorder__$t.fontProperties = __varRecorder__$t.keySet(__varRecorder__$t.fontProperties_);
      __varRecorder__$t.counterDescriptors_ = ["additive-symbols", "fallback", "negative", "pad", "prefix", "range", "speak-as", "suffix", "symbols", "system"];
      __varRecorder__$t.counterDescriptors = __varRecorder__$t.keySet(__varRecorder__$t.counterDescriptors_);
      __varRecorder__$t.colorKeywords_ = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"];
      __varRecorder__$t.colorKeywords = __varRecorder__$t.keySet(__varRecorder__$t.colorKeywords_);
      __varRecorder__$t.valueKeywords_ = ["above", "absolute", "activeborder", "additive", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content", "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "difference", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "japanese-formal", "japanese-informal", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal", "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "simp-chinese-formal", "simp-chinese-informal", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "tamil", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "trad-chinese-formal", "trad-chinese-informal", "transform", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"];
      __varRecorder__$t.valueKeywords = __varRecorder__$t.keySet(__varRecorder__$t.valueKeywords_);
      __varRecorder__$t.allWords = __varRecorder__$t.documentTypes_.concat(__varRecorder__$t.mediaTypes_).concat(__varRecorder__$t.mediaFeatures_).concat(__varRecorder__$t.mediaValueKeywords_).concat(__varRecorder__$t.propertyKeywords_).concat(__varRecorder__$t.nonStandardPropertyKeywords_).concat(__varRecorder__$t.colorKeywords_).concat(__varRecorder__$t.valueKeywords_);
      registerHelper("hintWords", "css", __varRecorder__$t.allWords);
      __varRecorder__$t.defaultParserConfig = {
        documentTypes: __varRecorder__$t.documentTypes,
        mediaTypes: __varRecorder__$t.mediaTypes,
        mediaFeatures: __varRecorder__$t.mediaFeatures,
        mediaValueKeywords: __varRecorder__$t.mediaValueKeywords,
        propertyKeywords: __varRecorder__$t.propertyKeywords,
        nonStandardPropertyKeywords: __varRecorder__$t.nonStandardPropertyKeywords,
        fontProperties: __varRecorder__$t.fontProperties,
        counterDescriptors: __varRecorder__$t.counterDescriptors,
        colorKeywords: __varRecorder__$t.colorKeywords,
        valueKeywords: __varRecorder__$t.valueKeywords,
        tokenHooks: {
          "/": function _(stream, state) {
            if (!stream.eat("*")) return false;
            state.tokenize = __varRecorder__$t.tokenCComment;
            return __varRecorder__$t.tokenCComment(stream, state);
          }
        },
        name: "css"
      };
      defineMIME("text/css", __varRecorder__$t.defaultParserConfig);
      defineMIME("text/x-scss", {
        mediaTypes: __varRecorder__$t.mediaTypes,
        mediaFeatures: __varRecorder__$t.mediaFeatures,
        mediaValueKeywords: __varRecorder__$t.mediaValueKeywords,
        propertyKeywords: __varRecorder__$t.propertyKeywords,
        nonStandardPropertyKeywords: __varRecorder__$t.nonStandardPropertyKeywords,
        colorKeywords: __varRecorder__$t.colorKeywords,
        valueKeywords: __varRecorder__$t.valueKeywords,
        fontProperties: __varRecorder__$t.fontProperties,
        allowNested: true,
        lineComment: "//",
        tokenHooks: {
          "/": function _(stream, state) {
            if (stream.eat("/")) {
              stream.skipToEnd();
              return ["comment", "comment"];
            } else if (stream.eat("*")) {
              state.tokenize = __varRecorder__$t.tokenCComment;
              return __varRecorder__$t.tokenCComment(stream, state);
            } else {
              return ["operator", "operator"];
            }
          },
          ":": function _(stream) {
            if (stream.match(/\s*\{/, false)) {
              return [null, null];
            }

            return false;
          },
          $: function $(stream) {
            stream.match(/^[\w-]+/);

            if (stream.match(/^\s*:/, false)) {
              return ["variable-2", "variable-definition"];
            }

            return ["variable-2", "variable"];
          },
          "#": function _(stream) {
            if (!stream.eat("{")) return false;
            return [null, "interpolation"];
          }
        },
        name: "css",
        helperType: "scss"
      });
      defineMIME("text/x-less", {
        mediaTypes: __varRecorder__$t.mediaTypes,
        mediaFeatures: __varRecorder__$t.mediaFeatures,
        mediaValueKeywords: __varRecorder__$t.mediaValueKeywords,
        propertyKeywords: __varRecorder__$t.propertyKeywords,
        nonStandardPropertyKeywords: __varRecorder__$t.nonStandardPropertyKeywords,
        colorKeywords: __varRecorder__$t.colorKeywords,
        valueKeywords: __varRecorder__$t.valueKeywords,
        fontProperties: __varRecorder__$t.fontProperties,
        allowNested: true,
        lineComment: "//",
        tokenHooks: {
          "/": function _(stream, state) {
            if (stream.eat("/")) {
              stream.skipToEnd();
              return ["comment", "comment"];
            } else if (stream.eat("*")) {
              state.tokenize = __varRecorder__$t.tokenCComment;
              return __varRecorder__$t.tokenCComment(stream, state);
            } else {
              return ["operator", "operator"];
            }
          },
          "@": function _(stream) {
            if (stream.eat("{")) return [null, "interpolation"];
            if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/, false)) return false;
            stream.eatWhile(/[\w\\\-]/);

            if (stream.match(/^\s*:/, false)) {
              return ["variable-2", "variable-definition"];
            }

            return ["variable-2", "variable"];
          },
          "&": function _() {
            return ["atom", "atom"];
          }
        },
        name: "css",
        helperType: "less"
      });
      defineMIME("text/x-gss", {
        documentTypes: __varRecorder__$t.documentTypes,
        mediaTypes: __varRecorder__$t.mediaTypes,
        mediaFeatures: __varRecorder__$t.mediaFeatures,
        propertyKeywords: __varRecorder__$t.propertyKeywords,
        nonStandardPropertyKeywords: __varRecorder__$t.nonStandardPropertyKeywords,
        fontProperties: __varRecorder__$t.fontProperties,
        counterDescriptors: __varRecorder__$t.counterDescriptors,
        colorKeywords: __varRecorder__$t.colorKeywords,
        valueKeywords: __varRecorder__$t.valueKeywords,
        supportsAtComponent: true,
        tokenHooks: {
          "/": function _(stream, state) {
            if (!stream.eat("*")) return false;
            state.tokenize = __varRecorder__$t.tokenCComment;
            return __varRecorder__$t.tokenCComment(stream, state);
          }
        },
        name: "css",
        helperType: "gss"
      });

      var __varRecorder__$s = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/html/mode.js", __contextModule__);
      var __moduleMeta__$c = {
        pathInPackage: function pathInPackage() {
          return "./html/mode.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var maybeBackup = __varRecorder__$s["lively.ide/html/mode.js__define__"]("maybeBackup", "function", function (stream, pat, style) {
        var cur = stream.current(),
            close = cur.search(pat);

        if (close > -1) {
          stream.backUp(cur.length - close);
        } else if (cur.match(/<\/?$/)) {
          stream.backUp(cur.length);
          if (!stream.match(pat, false)) stream.match(cur);
        }

        return style;
      }, __moduleMeta__$c);

      __varRecorder__$s.maybeBackup = maybeBackup;

      var getAttrRegexp = __varRecorder__$s["lively.ide/html/mode.js__define__"]("getAttrRegexp", "function", function (attr) {
        var regexp = __varRecorder__$s.attrRegexpCache[attr];
        if (regexp) return regexp;
        return __varRecorder__$s.attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
      }, __moduleMeta__$c);

      __varRecorder__$s.getAttrRegexp = getAttrRegexp;

      var getAttrValue = __varRecorder__$s["lively.ide/html/mode.js__define__"]("getAttrValue", "function", function (text, attr) {
        var match = text.match(__varRecorder__$s.getAttrRegexp(attr));
        return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : "";
      }, __moduleMeta__$c);

      __varRecorder__$s.getAttrValue = getAttrValue;

      var getTagRegexp = __varRecorder__$s["lively.ide/html/mode.js__define__"]("getTagRegexp", "function", function (tagName, anchored) {
        return new RegExp((anchored ? "^" : "") + "</s*" + tagName + "s*>", "i");
      }, __moduleMeta__$c);

      __varRecorder__$s.getTagRegexp = getTagRegexp;

      var addTags = __varRecorder__$s["lively.ide/html/mode.js__define__"]("addTags", "function", function (from, to) {
        for (var tag in from) {
          var dest = to[tag] || (to[tag] = []);
          var source = from[tag];

          for (var i = source.length - 1; i >= 0; i--) {
            dest.unshift(source[i]);
          }
        }
      }, __moduleMeta__$c);

      __varRecorder__$s.addTags = addTags;

      var findMatchingMode = __varRecorder__$s["lively.ide/html/mode.js__define__"]("findMatchingMode", "function", function (tagInfo, tagText) {
        for (var i = 0; i < tagInfo.length; i++) {
          var spec = tagInfo[i];
          if (!spec[0] || spec[1].test(__varRecorder__$s.getAttrValue(tagText, spec[0]))) return spec[2];
        }
      }, __moduleMeta__$c);

      __varRecorder__$s.findMatchingMode = findMatchingMode;
      __varRecorder__$s.defaultTags = {
        script: [["lang", /(javascript|babel)/i, "javascript"], ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"], ["type", /./, "text/plain"], [null, null, "javascript"]],
        style: [["lang", /^css$/i, "css"], ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"], ["type", /./, "text/plain"], [null, null, "css"]]
      };
      __varRecorder__$s.attrRegexpCache = {};
      defineMode("htmlmixed", function (config, parserConfig) {
        var htmlMode = getMode(config, {
          name: "xml",
          htmlMode: true,
          multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
          multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
        });
        var tags = {};
        var configTags = parserConfig && parserConfig.tags,
            configScript = parserConfig && parserConfig.scriptTypes;

        __varRecorder__$s.addTags(__varRecorder__$s.defaultTags, tags);

        if (configTags) __varRecorder__$s.addTags(configTags, tags);
        if (configScript) for (var i = configScript.length - 1; i >= 0; i--) {
          tags.script.unshift(["type", configScript[i].matches, configScript[i].mode]);
        }

        function html(stream, state) {
          var style = htmlMode.token(stream, state.htmlState),
              tag = /\btag\b/.test(style),
              tagName;

          if (tag && !/[<>\s\/]/.test(stream.current()) && (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) && tags.hasOwnProperty(tagName)) {
            state.inTag = tagName + " ";
          } else if (state.inTag && tag && />$/.test(stream.current())) {
            var inTag = /^([\S]+) (.*)/.exec(state.inTag);
            state.inTag = null;

            var modeSpec = stream.current() == ">" && __varRecorder__$s.findMatchingMode(tags[inTag[1]], inTag[2]);

            var mode = getMode(config, modeSpec);

            var endTagA = __varRecorder__$s.getTagRegexp(inTag[1], true),
                endTag = __varRecorder__$s.getTagRegexp(inTag[1], false);

            state.token = function (stream, state) {
              if (stream.match(endTagA, false)) {
                state.token = html;
                state.localState = state.localMode = null;
                return null;
              }

              return __varRecorder__$s.maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
            };

            state.localMode = mode;
            state.localState = startState(mode, htmlMode.indent(state.htmlState, ""));
          } else if (state.inTag) {
            state.inTag += stream.current();
            if (stream.eol()) state.inTag += " ";
          }

          return style;
        }
        return {
          startState: function startState$1() {
            var state = startState(htmlMode);

            return {
              token: html,
              inTag: null,
              localMode: null,
              localState: null,
              htmlState: state
            };
          },
          copyState: function copyState$1(state) {
            var local;

            if (state.localState) {
              local = copyState(state.localMode, state.localState);
            }

            return {
              token: state.token,
              inTag: state.inTag,
              localMode: state.localMode,
              localState: local,
              htmlState: copyState(htmlMode, state.htmlState)
            };
          },
          token: function token(stream, state) {
            return state.token(stream, state);
          },
          indent: function indent(state, textAfter, line) {
            if (!state.localMode || /^\s*<\//.test(textAfter)) return htmlMode.indent(state.htmlState, textAfter);else if (state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line);else return passIndent;
          },
          innerMode: function innerMode(state) {
            return {
              state: state.localState || state.htmlState,
              mode: state.localMode || htmlMode
            };
          },
          electricInput: htmlMode.electricInput,
          blockCommentStart: htmlMode.blockCommentStart,
          blockCommentEnd: htmlMode.blockCommentEnd,
          skipAttribute: htmlMode.skipAttribute
        };
      }, "xml", "javascript", "css");
      defineMIME("text/html", "htmlmixed");

      (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/md/mode.js", __contextModule__);
      defineMode("markdown", function (cmCfg, modeCfg) {
        var htmlMode = getMode(cmCfg, "text/html");
        var htmlModeMissing = htmlMode.name == "null";

        if (modeCfg.highlightFormatting === undefined) {
          modeCfg.highlightFormatting = false;
        }

        if (modeCfg.maxBlockquoteDepth === undefined) {
          modeCfg.maxBlockquoteDepth = 0;
        }

        if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;

        if (modeCfg.strikethrough === undefined) {
          modeCfg.strikethrough = false;
        }

        if (modeCfg.tokenTypeOverrides === undefined) {
          modeCfg.tokenTypeOverrides = {};
        }

        var tokenTypes = {
          header: "header",
          code: "comment",
          quote: "quote",
          list1: "variable-2",
          list2: "variable-3",
          list3: "keyword",
          hr: "hr",
          image: "image",
          imageAltText: "image-alt-text",
          imageMarker: "image-marker",
          formatting: "formatting",
          linkInline: "link",
          linkEmail: "link",
          linkText: "link",
          linkHref: "string",
          em: "em",
          strong: "strong",
          strikethrough: "strikethrough"
        };

        for (var tokenType in tokenTypes) {
          if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {
            tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
          }
        }

        var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/;
        var listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/;
        var taskListRE = /^\[(x| )\](?=\s)/;
        var atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/;
        var setextHeaderRE = /^ *(?:\={1,}|-{1,})\s*$/;
        var textRE = /^[^#!\[\]*_\\<>` "'(~]+/;
        var fencedCodeRE = new RegExp("^(" + (modeCfg.fencedCodeBlocks === true ? "~~~+|```+" : modeCfg.fencedCodeBlocks) + ")[ \\t]*([\\w+#-]*)");
        var punctuation = /[!\"#$%&\'()*+,\-\.\/:;<=>?@\[\\\]^_`{|}~]/;
        var expandedTab = "    ";

        function switchInline(stream, state, f) {
          state.f = state.inline = f;
          return f(stream, state);
        }

        function switchBlock(stream, state, f) {
          state.f = state.block = f;
          return f(stream, state);
        }

        function lineIsEmpty(line) {
          return !line || !/\S/.test(line.string);
        }

        function blankLine(state) {
          state.linkTitle = false;
          state.em = false;
          state.strong = false;
          state.strikethrough = false;
          state.quote = 0;
          state.indentedCode = false;

          if (state.f == htmlBlock) {
            state.f = inlineNormal;
            state.block = blockNormal;
          }

          state.trailingSpace = 0;
          state.trailingSpaceNewLine = false;
          state.prevLine = state.thisLine;
          state.thisLine = null;
          return null;
        }

        function blockNormal(stream, state) {
          var sol = stream.sol();
          var prevLineIsList = state.list !== false;
          var prevLineIsIndentedCode = state.indentedCode;
          state.indentedCode = false;
          var lineIndentation;

          if (state.indentationDiff === null) {
            lineIndentation = state.indentation;
            state.indentationDiff = state.indentation;

            if (prevLineIsList) {
              state.list = null;

              while (lineIndentation < state.listStack[state.listStack.length - 1]) {
                state.listStack.pop();

                if (state.listStack.length) {
                  state.indentation = state.listStack[state.listStack.length - 1];
                } else {
                  state.list = false;
                }
              }

              if (state.list !== false) {
                state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1];
              }
            }
          }

          var match = null;

          if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || lineIsEmpty(state.prevLine))) {
            stream.skipToEnd();
            state.indentedCode = true;
            return tokenTypes.code;
          } else if (stream.eatSpace()) {
            return null;
          } else if ((match = stream.match(atxHeaderRE)) && match[1].length <= 6) {
            state.header = match[1].length;
            if (modeCfg.highlightFormatting) state.formatting = "header";
            state.f = state.inline;
            return getType(state);
          } else if (!lineIsEmpty(state.prevLine) && !state.quote && !prevLineIsList && !prevLineIsIndentedCode && (match = stream.match(setextHeaderRE))) {
            state.header = match[0].charAt(0) == "=" ? 1 : 2;
            if (modeCfg.highlightFormatting) state.formatting = "header";
            state.f = state.inline;
            return getType(state);
          } else if (stream.eat(">")) {
            state.quote = sol ? 1 : state.quote + 1;
            if (modeCfg.highlightFormatting) state.formatting = "quote";
            stream.eatSpace();
            return getType(state);
          } else if (stream.peek() === "[") {
            return switchInline(stream, state, footnoteLink);
          } else if (stream.match(hrRE, true)) {
            state.hr = true;
            return tokenTypes.hr;
          } else if (match = stream.match(listRE)) {
            var listType = match[1] ? "ol" : "ul";
            state.indentation = lineIndentation + stream.current().length;
            state.list = true;
            state.listStack.push(state.indentation);

            if (modeCfg.taskLists && stream.match(taskListRE, false)) {
              state.taskList = true;
            }

            state.f = state.inline;
            if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];
            return getType(state);
          } else if (modeCfg.fencedCodeBlocks && (match = stream.match(fencedCodeRE, true))) {
            state.fencedChars = match[1];
            state.localMode = getMode(match[2]);
            if (state.localMode) state.localState = startState(state.localMode);
            state.f = state.block = local;
            if (modeCfg.highlightFormatting) state.formatting = "code-block";
            state.code = -1;
            return getType(state);
          }

          return switchInline(stream, state, state.inline);
        }

        function htmlBlock(stream, state) {
          var style = htmlMode.token(stream, state.htmlState);

          if (!htmlModeMissing) {
            var inner = innerMode(htmlMode, state.htmlState);

            if (inner.mode.name == "xml" && inner.state.tagStart === null && !inner.state.context && inner.state.tokenize.isInText || state.md_inside && stream.current().indexOf(">") > -1) {
              state.f = inlineNormal;
              state.block = blockNormal;
              state.htmlState = null;
            }
          }

          return style;
        }

        function local(stream, state) {
          if (state.fencedChars && stream.match(state.fencedChars)) {
            if (modeCfg.highlightFormatting) state.formatting = "code-block";
            var returnType = getType(state);
            state.localMode = state.localState = null;
            state.block = blockNormal;
            state.f = inlineNormal;
            state.fencedChars = null;
            state.code = 0;
            return returnType;
          } else if (state.fencedChars && stream.skipTo(state.fencedChars)) {
            return "comment";
          } else if (state.localMode) {
            return state.localMode.token(stream, state.localState);
          } else {
            stream.skipToEnd();
            return tokenTypes.code;
          }
        }

        function getType(state) {
          var styles = [];

          if (state.formatting) {
            styles.push(tokenTypes.formatting);
            if (typeof state.formatting === "string") state.formatting = [state.formatting];

            for (var i = 0; i < state.formatting.length; i++) {
              styles.push(tokenTypes.formatting + "-" + state.formatting[i]);

              if (state.formatting[i] === "header") {
                styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.header);
              }

              if (state.formatting[i] === "quote") {
                if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                  styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.quote);
                } else {
                  styles.push("error");
                }
              }
            }
          }

          if (state.taskOpen) {
            styles.push("meta");
            return styles.length ? styles.join(" ") : null;
          }

          if (state.taskClosed) {
            styles.push("property");
            return styles.length ? styles.join(" ") : null;
          }

          if (state.linkHref) {
            styles.push(tokenTypes.linkHref, "url");
          } else {
            if (state.strong) {
              styles.push(tokenTypes.strong);
            }

            if (state.em) {
              styles.push(tokenTypes.em);
            }

            if (state.strikethrough) {
              styles.push(tokenTypes.strikethrough);
            }

            if (state.linkText) {
              styles.push(tokenTypes.linkText);
            }

            if (state.code) {
              styles.push(tokenTypes.code);
            }

            if (state.image) {
              styles.push(tokenTypes.image);
            }

            if (state.imageAltText) {
              styles.push(tokenTypes.imageAltText, "link");
            }

            if (state.imageMarker) {
              styles.push(tokenTypes.imageMarker);
            }
          }

          if (state.header) {
            styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header);
          }

          if (state.quote) {
            styles.push(tokenTypes.quote);

            if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
              styles.push(tokenTypes.quote + "-" + state.quote);
            } else {
              styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
            }
          }

          if (state.list !== false) {
            var listMod = (state.listStack.length - 1) % 3;

            if (!listMod) {
              styles.push(tokenTypes.list1);
            } else if (listMod === 1) {
              styles.push(tokenTypes.list2);
            } else {
              styles.push(tokenTypes.list3);
            }
          }

          if (state.trailingSpaceNewLine) {
            styles.push("trailing-space-new-line");
          } else if (state.trailingSpace) {
            styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
          }

          return styles.length ? styles.join(" ") : null;
        }

        function handleText(stream, state) {
          if (stream.match(textRE, true)) {
            return getType(state);
          }

          return undefined;
        }

        function inlineNormal(stream, state) {
          var style = state.text(stream, state);

          if (typeof style !== "undefined") {
            return style;
          }

          if (state.list) {
            state.list = null;
            return getType(state);
          }

          if (state.taskList) {
            var taskOpen = stream.match(taskListRE, true)[1] !== "x";
            if (taskOpen) state.taskOpen = true;else state.taskClosed = true;
            if (modeCfg.highlightFormatting) state.formatting = "task";
            state.taskList = false;
            return getType(state);
          }

          state.taskOpen = false;
          state.taskClosed = false;

          if (state.header && stream.match(/^#+$/, true)) {
            if (modeCfg.highlightFormatting) state.formatting = "header";
            return getType(state);
          }

          var ch = stream.next();

          if (state.linkTitle) {
            state.linkTitle = false;
            var matchCh = ch;

            if (ch === "(") {
              matchCh = ")";
            }

            matchCh = (matchCh + "").replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1");
            var regex = "^\\s*(?:[^" + matchCh + "\\\\]+|\\\\\\\\|\\\\.)" + matchCh;

            if (stream.match(new RegExp(regex), true)) {
              return tokenTypes.linkHref;
            }
          }

          if (ch === "`") {
            var previousFormatting = state.formatting;
            if (modeCfg.highlightFormatting) state.formatting = "code";
            stream.eatWhile("`");
            var count = stream.current().length;

            if (state.code == 0) {
              state.code = count;
              return getType(state);
            } else if (count == state.code) {
              var t = getType(state);
              state.code = 0;
              return t;
            } else {
              state.formatting = previousFormatting;
              return getType(state);
            }
          } else if (state.code) {
            return getType(state);
          }

          if (ch === "\\") {
            stream.next();

            if (modeCfg.highlightFormatting) {
              var type = getType(state);
              var formattingEscape = tokenTypes.formatting + "-escape";
              return type ? type + " " + formattingEscape : formattingEscape;
            }
          }

          if (ch === "!" && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
            state.imageMarker = true;
            state.image = true;
            if (modeCfg.highlightFormatting) state.formatting = "image";
            return getType(state);
          }

          if (ch === "[" && state.imageMarker && stream.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, false)) {
            state.imageMarker = false;
            state.imageAltText = true;
            if (modeCfg.highlightFormatting) state.formatting = "image";
            return getType(state);
          }

          if (ch === "]" && state.imageAltText) {
            if (modeCfg.highlightFormatting) state.formatting = "image";
            var type = getType(state);
            state.imageAltText = false;
            state.image = false;
            state.inline = state.f = linkHref;
            return type;
          }

          if (ch === "[" && !state.image) {
            state.linkText = true;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            return getType(state);
          }

          if (ch === "]" && state.linkText) {
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var type = getType(state);
            state.linkText = false;
            state.inline = state.f = stream.match(/\(.*?\)| ?\[.*?\]/, false) ? linkHref : inlineNormal;
            return type;
          }

          if (ch === "<" && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
            state.f = state.inline = linkInline;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var type = getType(state);

            if (type) {
              type += " ";
            } else {
              type = "";
            }

            return type + tokenTypes.linkInline;
          }

          if (ch === "<" && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
            state.f = state.inline = linkInline;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var type = getType(state);

            if (type) {
              type += " ";
            } else {
              type = "";
            }

            return type + tokenTypes.linkEmail;
          }

          if (ch === "<" && stream.match(/^(!--|[a-z]+(?:\s+[a-z_:.\-]+(?:\s*=\s*[^ >]+)?)*\s*>)/i, false)) {
            var end = stream.string.indexOf(">", stream.pos);

            if (end != -1) {
              var atts = stream.string.substring(stream.start, end);
              if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) state.md_inside = true;
            }

            stream.backUp(1);
            state.htmlState = startState(htmlMode);
            return switchBlock(stream, state, htmlBlock);
          }

          if (ch === "<" && stream.match(/^\/\w*?>/)) {
            state.md_inside = false;
            return "tag";
          } else if (ch === "*" || ch === "_") {
            var len = 1;
            var before = stream.pos == 1 ? " " : stream.string.charAt(stream.pos - 2);

            while (len < 3 && stream.eat(ch)) {
              len++;
            }

            var after = stream.peek() || " ";
            var leftFlanking = !/\s/.test(after) && (!punctuation.test(after) || /\s/.test(before) || punctuation.test(before));
            var rightFlanking = !/\s/.test(before) && (!punctuation.test(before) || /\s/.test(after) || punctuation.test(after));
            var setEm = null;
            var setStrong = null;

            if (len % 2) {
              if (!state.em && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before))) {
                setEm = true;
              } else if (state.em == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after))) {
                setEm = false;
              }
            }

            if (len > 1) {
              if (!state.strong && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before))) {
                setStrong = true;
              } else if (state.strong == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after))) {
                setStrong = false;
              }
            }

            if (setStrong != null || setEm != null) {
              if (modeCfg.highlightFormatting) state.formatting = setEm == null ? "strong" : setStrong == null ? "em" : "strong em";
              if (setEm === true) state.em = ch;
              if (setStrong === true) state.strong = ch;
              var t = getType(state);
              if (setEm === false) state.em = false;
              if (setStrong === false) state.strong = false;
              return t;
            }
          } else if (ch === " ") {
            if (stream.eat("*") || stream.eat("_")) {
              if (stream.peek() === " ") {
                return getType(state);
              } else {
                stream.backUp(1);
              }
            }
          }

          if (modeCfg.strikethrough) {
            if (ch === "~" && stream.eatWhile(ch)) {
              if (state.strikethrough) {
                if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
                var t = getType(state);
                state.strikethrough = false;
                return t;
              } else if (stream.match(/^[^\s]/, false)) {
                state.strikethrough = true;
                if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
                return getType(state);
              }
            } else if (ch === " ") {
              if (stream.match(/^~~/, true)) {
                if (stream.peek() === " ") {
                  return getType(state);
                } else {
                  stream.backUp(2);
                }
              }
            }
          }

          if (ch === " ") {
            if (stream.match(/ +$/, false)) {
              state.trailingSpace++;
            } else if (state.trailingSpace) {
              state.trailingSpaceNewLine = true;
            }
          }

          return getType(state);
        }

        function linkInline(stream, state) {
          var ch = stream.next();

          if (ch === ">") {
            state.f = state.inline = inlineNormal;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var type = getType(state);

            if (type) {
              type += " ";
            } else {
              type = "";
            }

            return type + tokenTypes.linkInline;
          }

          stream.match(/^[^>]+/, true);
          return tokenTypes.linkInline;
        }

        function linkHref(stream, state) {
          if (stream.eatSpace()) {
            return null;
          }

          var ch = stream.next();

          if (ch === "(" || ch === "[") {
            state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
            if (modeCfg.highlightFormatting) state.formatting = "link-string";
            state.linkHref = true;
            return getType(state);
          }

          return "error";
        }

        var linkRE = {
          ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
          "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/
        };

        function getLinkHrefInside(endChar) {
          return function (stream, state) {
            var ch = stream.next();

            if (ch === endChar) {
              state.f = state.inline = inlineNormal;
              if (modeCfg.highlightFormatting) state.formatting = "link-string";
              var returnState = getType(state);
              state.linkHref = false;
              return returnState;
            }

            stream.match(linkRE[endChar]);
            state.linkHref = true;
            return getType(state);
          };
        }

        function footnoteLink(stream, state) {
          if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {
            state.f = footnoteLinkInside;
            stream.next();
            if (modeCfg.highlightFormatting) state.formatting = "link";
            state.linkText = true;
            return getType(state);
          }

          return switchInline(stream, state, inlineNormal);
        }

        function footnoteLinkInside(stream, state) {
          if (stream.match(/^\]:/, true)) {
            state.f = state.inline = footnoteUrl;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var returnType = getType(state);
            state.linkText = false;
            return returnType;
          }

          stream.match(/^([^\]\\]|\\.)+/, true);
          return tokenTypes.linkText;
        }

        function footnoteUrl(stream, state) {
          if (stream.eatSpace()) {
            return null;
          }

          stream.match(/^[^\s]+/, true);

          if (stream.peek() === undefined) {
            state.linkTitle = true;
          } else {
            stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
          }

          state.f = state.inline = inlineNormal;
          return tokenTypes.linkHref + " url";
        }

        var mode = {
          startState: function startState() {
            return {
              f: blockNormal,
              prevLine: null,
              thisLine: null,
              block: blockNormal,
              htmlState: null,
              indentation: 0,
              inline: inlineNormal,
              text: handleText,
              formatting: false,
              linkText: false,
              linkHref: false,
              linkTitle: false,
              code: 0,
              em: false,
              strong: false,
              header: 0,
              hr: false,
              taskList: false,
              list: false,
              listStack: [],
              quote: 0,
              trailingSpace: 0,
              trailingSpaceNewLine: false,
              strikethrough: false,
              fencedChars: null
            };
          },
          copyState: function copyState$1(s) {
            return {
              f: s.f,
              prevLine: s.prevLine,
              thisLine: s.thisLine,
              block: s.block,
              htmlState: s.htmlState && copyState(htmlMode, s.htmlState),
              indentation: s.indentation,
              localMode: s.localMode,
              localState: s.localMode ? copyState(s.localMode, s.localState) : null,
              inline: s.inline,
              text: s.text,
              formatting: false,
              linkText: s.linkText,
              linkTitle: s.linkTitle,
              code: s.code,
              em: s.em,
              strong: s.strong,
              strikethrough: s.strikethrough,
              header: s.header,
              hr: s.hr,
              taskList: s.taskList,
              list: s.list,
              listStack: s.listStack.slice(0),
              quote: s.quote,
              indentedCode: s.indentedCode,
              trailingSpace: s.trailingSpace,
              trailingSpaceNewLine: s.trailingSpaceNewLine,
              md_inside: s.md_inside,
              fencedChars: s.fencedChars
            };
          },
          token: function token(stream, state) {
            state.formatting = false;

            if (stream != state.thisLine) {
              state.header = 0;
              state.hr = false;

              if (stream.match(/^\s*$/, true)) {
                blankLine(state);
                return state;
              }

              state.prevLine = state.thisLine;
              state.thisLine = stream;
              state.taskList = false;
              state.trailingSpace = 0;
              state.trailingSpaceNewLine = false;
              state.f = state.block;

              if (state.f != htmlBlock) {
                var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, expandedTab).length;
                state.indentation = indentation;
                state.indentationDiff = null;
                if (indentation > 0) return null;
              }
            }

            return state.f(stream, state);
          },
          innerMode: function innerMode(state) {
            if (state.block == htmlBlock) return {
              state: state.htmlState,
              mode: htmlMode
            };
            if (state.localState) return {
              state: state.localState,
              mode: state.localMode
            };
            return {
              state: state,
              mode: mode
            };
          },
          indent: function indent(state, textAfter, line) {
            if (state.block == htmlBlock) return htmlMode.indent(state.htmlState, textAfter, line);
            if (state.localState) return state.localMode.indent(state.localState, textAfter, line);
            return passIndent;
          },
          blankLine: blankLine,
          getType: getType,
          closeBrackets: "()[]{}''\"\"``",
          fold: "markdown",
          blockCommentStart: "<!--",
          blockCommentEnd: "-->"
        };
        return mode;
      }, "xml");
      defineMIME("text/x-markdown", "markdown");

      var __varRecorder__$r = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/md/navigator.js", __contextModule__);

      var MarkdownNavigator = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/md/navigator.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("MarkdownNavigator") && typeof __lively_classholder__.MarkdownNavigator === "function" ? __lively_classholder__.MarkdownNavigator : __lively_classholder__.MarkdownNavigator = function MarkdownNavigator(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "ensureAST",
          value: function MarkdownNavigator_ensureAST_(ed) {
            return ed.editorPlugin.parsedMarkdown();
          }
        }, {
          key: "moveToHeading",
          value: function MarkdownNavigator_moveToHeading_(ed, heading) {
            if (!heading) return;
            ed.cursorPosition = {
              row: heading.line,
              column: 0
            };
            ed.scrollCursorIntoView();
          }
        }, {
          key: "backwardSexp",
          value: function MarkdownNavigator_backwardSexp_(ed) {
            var src = ed.textString,
                _this$ensureAST = this.ensureAST(ed),
                headings = _this$ensureAST.headings,
                pos = ed.cursorPosition,
                h = this.headingOfLine(headings, pos.row);

            if (h && h.line === pos.row && pos.column === 0) {
              var siblings = this.siblingsBefore(src, headings, h);
              h = last$2(siblings);
            }

            this.moveToHeading(ed, h);
          }
        }, {
          key: "forwardSexp",
          value: function MarkdownNavigator_forwardSexp_(ed) {
            var src = ed.textString,
                _this$ensureAST2 = this.ensureAST(ed),
                headings = _this$ensureAST2.headings,
                h = this.headingOfLine(headings, ed.cursorPosition.row),
                siblings = this.siblingsAfter(src, headings, h);

            this.moveToHeading(ed, siblings[0]);
          }
        }, {
          key: "backwardUpSexp",
          value: function MarkdownNavigator_backwardUpSexp_(ed) {
            var _this$ensureAST3 = this.ensureAST(ed),
                headings = _this$ensureAST3.headings,
                heading = this.headingOfLine(headings, ed.cursorPosition.row),
                owners = this.ownerHeadings(headings, heading);

            this.moveToHeading(ed, last$2(owners));
          }
        }, {
          key: "forwardDownSexp",
          value: function MarkdownNavigator_forwardDownSexp_(ed) {
            var _this$ensureAST4 = this.ensureAST(ed),
                headings = _this$ensureAST4.headings,
                heading = this.headingOfLine(headings, ed.cursorPosition.row),
                sub = this.rangeOfHeading(ed.textString, headings, heading);

            this.moveToHeading(ed, sub.subheadings[1]);
          }
        }, {
          key: "expandRegion",
          value: function MarkdownNavigator_expandRegion_(ed, src, ast, expandState) {
            var pos = ed.cursorPosition,
                _this$ensureAST5 = this.ensureAST(ed),
                headings = _this$ensureAST5.headings,
                heading = this.headingOfLine(headings, pos.row);

            if (!heading) return expandState;

            if (heading && heading.line === pos.row && pos.column === 0 && expandState.range[0] !== expandState.range[1]) {
              var owners = this.ownerHeadings(headings, heading);
              heading = last$2(owners);
              if (!heading) return expandState;
            }

            var newRange = this.rangeOfHeading(src, headings, heading);
            if (!newRange) return expandState;
            return {
              range: [ed.positionToIndex(newRange.range.end), ed.positionToIndex(newRange.range.start)],
              prev: expandState
            };
          }
        }, {
          key: "contractRegion",
          value: function MarkdownNavigator_contractRegion_(ed, src, ast, expandState) {
            return expandState.prev || expandState;
          }
        }, {
          key: "ownerHeadings",
          value: function MarkdownNavigator_ownerHeadings_(headings, heading) {
            if (heading.depth <= 1) return [];
            var before = headings.slice(0, headings.indexOf(heading));
            if (!before.length) return [];
            var owner = before.reverse().find(function (ea) {
              return ea.depth < heading.depth;
            });
            return this.ownerHeadings(headings, owner).concat([owner]);
          }
        }, {
          key: "withSiblings",
          value: function MarkdownNavigator_withSiblings_(markdownSrcOrLines, headings, heading) {
            if (heading.depth === 1) return headings.filter(function (ea) {
              return ea.depth === 1;
            });
            var owners = this.ownerHeadings(headings, heading),
                sub = this.rangeOfHeading(markdownSrcOrLines, headings, last$2(owners));
            return sub.subheadings.filter(function (ea) {
              return ea.depth === heading.depth;
            });
          }
        }, {
          key: "siblingsBefore",
          value: function MarkdownNavigator_siblingsBefore_(markdownSrcOrLines, headings, heading) {
            var sibs = this.withSiblings(markdownSrcOrLines, headings, heading);
            return sibs.slice(0, sibs.indexOf(heading));
          }
        }, {
          key: "siblingsAfter",
          value: function MarkdownNavigator_siblingsAfter_(markdownSrcOrLines, headings, heading) {
            var sibs = this.withSiblings(markdownSrcOrLines, headings, heading);
            return sibs.slice(sibs.indexOf(heading) + 1);
          }
        }, {
          key: "headingOfLine",
          value: function MarkdownNavigator_headingOfLine_(headings, line) {
            var found;

            for (var i = 0; i < headings.length; i++) {
              if (headings[i].line > line) break;
              found = headings[i];
            }

            return found;
          }
        }, {
          key: "rangeOfHeading",
          value: function MarkdownNavigator_rangeOfHeading_(markdownSrcOrLines, headings, heading) {
            var lines$1 = Array.isArray(markdownSrcOrLines) ? markdownSrcOrLines : lines(markdownSrcOrLines),
                start = headings.find(function (ea) {
              return heading && ea.line === heading.line;
            }),
                startIndex = headings.indexOf(start),
                end = headings.slice(startIndex + 1).find(function (ea) {
              return ea.depth <= heading.depth;
            }),
                subheadings = headings.slice(headings.indexOf(start), end ? headings.indexOf(end) : headings.length);
            return {
              range: {
                start: {
                  row: start.line,
                  column: 0
                },
                end: end ? {
                  row: end.line - 1,
                  column: lines$1[end.line - 1].length
                } : {
                  row: lines$1.length - 1,
                  column: lines$1[lines$1.length - 1].length
                }
              },
              subheadings: subheadings
            };
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "MarkdownNavigator";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./md/navigator.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 59,
          end: 4581
        });
      }(undefined);
      __varRecorder__$r["default"] = MarkdownNavigator;

      var exports$1 = {};
      function deepFreeze(obj) {
        if (obj instanceof Map) {
          obj.clear = obj.delete = obj.set = function () {
            throw new Error("map is read-only");
          };
        } else if (obj instanceof Set) {
          obj.add = obj.clear = obj.delete = function () {
            throw new Error("set is read-only");
          };
        }
        Object.freeze(obj);
        Object.getOwnPropertyNames(obj).forEach(name => {
          const prop = obj[name];
          const type = typeof prop;
          if ((type === "object" || type === "function") && !Object.isFrozen(prop)) {
            deepFreeze(prop);
          }
        });
        return obj;
      }
      class Response {
        constructor(mode) {
          if (mode.data === undefined)
            mode.data = {};
          this.data = mode.data;
          this.isMatchIgnored = false;
        }
        ignoreMatch() {
          this.isMatchIgnored = true;
        }
      }
      function escapeHTML(value) {
        return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
      }
      function inherit$1(original, ...objects) {
        const result = Object.create(null);
        for (const key in original) {
          result[key] = original[key];
        }
        objects.forEach(function (obj) {
          for (const key in obj) {
            result[key] = obj[key];
          }
        });
        return result;
      }
      const SPAN_CLOSE = "</span>";
      const emitsWrappingTags = node => {
        return !!node.scope;
      };
      const scopeToCSSClass = (name, {prefix}) => {
        if (name.startsWith("language:")) {
          return name.replace("language:", "language-");
        }
        if (name.includes(".")) {
          const pieces = name.split(".");
          return [
            `${ prefix }${ pieces.shift() }`,
            ...pieces.map((x, i) => `${ x }${ "_".repeat(i + 1) }`)
          ].join(" ");
        }
        return `${ prefix }${ name }`;
      };
      class HTMLRenderer {
        constructor(parseTree, options) {
          this.buffer = "";
          this.classPrefix = options.classPrefix;
          parseTree.walk(this);
        }
        addText(text) {
          this.buffer += escapeHTML(text);
        }
        openNode(node) {
          if (!emitsWrappingTags(node))
            return;
          const className = scopeToCSSClass(node.scope, { prefix: this.classPrefix });
          this.span(className);
        }
        closeNode(node) {
          if (!emitsWrappingTags(node))
            return;
          this.buffer += SPAN_CLOSE;
        }
        value() {
          return this.buffer;
        }
        span(className) {
          this.buffer += `<span class="${ className }">`;
        }
      }
      const newNode = (opts = {}) => {
        const result = { children: [] };
        Object.assign(result, opts);
        return result;
      };
      class TokenTree {
        constructor() {
          this.rootNode = newNode();
          this.stack = [this.rootNode];
        }
        get top() {
          return this.stack[this.stack.length - 1];
        }
        get root() {
          return this.rootNode;
        }
        add(node) {
          this.top.children.push(node);
        }
        openNode(scope) {
          const node = newNode({ scope });
          this.add(node);
          this.stack.push(node);
        }
        closeNode() {
          if (this.stack.length > 1) {
            return this.stack.pop();
          }
          return undefined;
        }
        closeAllNodes() {
          while (this.closeNode());
        }
        toJSON() {
          return JSON.stringify(this.rootNode, null, 4);
        }
        walk(builder) {
          return this.constructor._walk(builder, this.rootNode);
        }
        static _walk(builder, node) {
          if (typeof node === "string") {
            builder.addText(node);
          } else if (node.children) {
            builder.openNode(node);
            node.children.forEach(child => this._walk(builder, child));
            builder.closeNode(node);
          }
          return builder;
        }
        static _collapse(node) {
          if (typeof node === "string")
            return;
          if (!node.children)
            return;
          if (node.children.every(el => typeof el === "string")) {
            node.children = [node.children.join("")];
          } else {
            node.children.forEach(child => {
              TokenTree._collapse(child);
            });
          }
        }
      }
      class TokenTreeEmitter extends TokenTree {
        constructor(options) {
          super();
          this.options = options;
        }
        addText(text) {
          if (text === "") {
            return;
          }
          this.add(text);
        }
        startScope(scope) {
          this.openNode(scope);
        }
        endScope() {
          this.closeNode();
        }
        __addSublanguage(emitter, name) {
          const node = emitter.root;
          if (name)
            node.scope = `language:${ name }`;
          this.add(node);
        }
        toHTML() {
          const renderer = new HTMLRenderer(this, this.options);
          return renderer.value();
        }
        finalize() {
          this.closeAllNodes();
          return true;
        }
      }
      function source(re) {
        if (!re)
          return null;
        if (typeof re === "string")
          return re;
        return re.source;
      }
      function lookahead(re) {
        return concat("(?=", re, ")");
      }
      function anyNumberOfTimes(re) {
        return concat("(?:", re, ")*");
      }
      function optional(re) {
        return concat("(?:", re, ")?");
      }
      function concat(...args) {
        const joined = args.map(x => source(x)).join("");
        return joined;
      }
      function stripOptionsFromArgs(args) {
        const opts = args[args.length - 1];
        if (typeof opts === "object" && opts.constructor === Object) {
          args.splice(args.length - 1, 1);
          return opts;
        } else {
          return {};
        }
      }
      function either(...args) {
        const opts = stripOptionsFromArgs(args);
        const joined = "(" + (opts.capture ? "" : "?:") + args.map(x => source(x)).join("|") + ")";
        return joined;
      }
      function countMatchGroups(re) {
        return new RegExp(re.toString() + "|").exec("").length - 1;
      }
      function startsWith(re, lexeme) {
        const match = re && re.exec(lexeme);
        return match && match.index === 0;
      }
      const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
      function _rewriteBackreferences(regexps, {joinWith}) {
        let numCaptures = 0;
        return regexps.map(regex => {
          numCaptures += 1;
          const offset = numCaptures;
          let re = source(regex);
          let out = "";
          while (re.length > 0) {
            const match = BACKREF_RE.exec(re);
            if (!match) {
              out += re;
              break;
            }
            out += re.substring(0, match.index);
            re = re.substring(match.index + match[0].length);
            if (match[0][0] === "\\" && match[1]) {
              out += "\\" + String(Number(match[1]) + offset);
            } else {
              out += match[0];
              if (match[0] === "(") {
                numCaptures++;
              }
            }
          }
          return out;
        }).map(re => `(${ re })`).join(joinWith);
      }
      const MATCH_NOTHING_RE = /\b\B/;
      const IDENT_RE$1 = "[a-zA-Z]\\w*";
      const UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
      const NUMBER_RE = "\\b\\d+(\\.\\d+)?";
      const C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
      const BINARY_NUMBER_RE = "\\b(0b[01]+)";
      const RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
      const SHEBANG = (opts = {}) => {
        const beginShebang = /^#![ ]*\//;
        if (opts.binary) {
          opts.begin = concat(beginShebang, /.*\b/, opts.binary, /\b.*/);
        }
        return inherit$1({
          scope: "meta",
          begin: beginShebang,
          end: /$/,
          relevance: 0,
          "on:begin": (m, resp) => {
            if (m.index !== 0)
              resp.ignoreMatch();
          }
        }, opts);
      };
      const BACKSLASH_ESCAPE = {
        begin: "\\\\[\\s\\S]",
        relevance: 0
      };
      const APOS_STRING_MODE = {
        scope: "string",
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE]
      };
      const QUOTE_STRING_MODE = {
        scope: "string",
        begin: "\"",
        end: "\"",
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE]
      };
      const PHRASAL_WORDS_MODE = { begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/ };
      const COMMENT = function (begin, end, modeOptions = {}) {
        const mode = inherit$1({
          scope: "comment",
          begin,
          end,
          contains: []
        }, modeOptions);
        mode.contains.push({
          scope: "doctag",
          begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
          end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
          excludeBegin: true,
          relevance: 0
        });
        const ENGLISH_WORD = either("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
        mode.contains.push({ begin: concat(/[ ]+/, "(", ENGLISH_WORD, /[.]?[:]?([.][ ]|[ ])/, "){3}") });
        return mode;
      };
      const C_LINE_COMMENT_MODE = COMMENT("//", "$");
      const C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
      const HASH_COMMENT_MODE = COMMENT("#", "$");
      const NUMBER_MODE = {
        scope: "number",
        begin: NUMBER_RE,
        relevance: 0
      };
      const C_NUMBER_MODE = {
        scope: "number",
        begin: C_NUMBER_RE,
        relevance: 0
      };
      const BINARY_NUMBER_MODE = {
        scope: "number",
        begin: BINARY_NUMBER_RE,
        relevance: 0
      };
      const REGEXP_MODE = {
        scope: "regexp",
        begin: /\/(?=[^/\n]*\/)/,
        end: /\/[gimuy]*/,
        contains: [
          BACKSLASH_ESCAPE,
          {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [BACKSLASH_ESCAPE]
          }
        ]
      };
      const TITLE_MODE = {
        scope: "title",
        begin: IDENT_RE$1,
        relevance: 0
      };
      const UNDERSCORE_TITLE_MODE = {
        scope: "title",
        begin: UNDERSCORE_IDENT_RE,
        relevance: 0
      };
      const METHOD_GUARD = {
        begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
        relevance: 0
      };
      const END_SAME_AS_BEGIN = function (mode) {
        return Object.assign(mode, {
          "on:begin": (m, resp) => {
            resp.data._beginMatch = m[1];
          },
          "on:end": (m, resp) => {
            if (resp.data._beginMatch !== m[1])
              resp.ignoreMatch();
          }
        });
      };
      var MODES = Object.freeze({
        __proto__: null,
        APOS_STRING_MODE: APOS_STRING_MODE,
        BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,
        BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,
        BINARY_NUMBER_RE: BINARY_NUMBER_RE,
        COMMENT: COMMENT,
        C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,
        C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,
        C_NUMBER_MODE: C_NUMBER_MODE,
        C_NUMBER_RE: C_NUMBER_RE,
        END_SAME_AS_BEGIN: END_SAME_AS_BEGIN,
        HASH_COMMENT_MODE: HASH_COMMENT_MODE,
        IDENT_RE: IDENT_RE$1,
        MATCH_NOTHING_RE: MATCH_NOTHING_RE,
        METHOD_GUARD: METHOD_GUARD,
        NUMBER_MODE: NUMBER_MODE,
        NUMBER_RE: NUMBER_RE,
        PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,
        QUOTE_STRING_MODE: QUOTE_STRING_MODE,
        REGEXP_MODE: REGEXP_MODE,
        RE_STARTERS_RE: RE_STARTERS_RE,
        SHEBANG: SHEBANG,
        TITLE_MODE: TITLE_MODE,
        UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,
        UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE
      });
      function skipIfHasPrecedingDot(match, response) {
        const before = match.input[match.index - 1];
        if (before === ".") {
          response.ignoreMatch();
        }
      }
      function scopeClassName(mode, _parent) {
        if (mode.className !== undefined) {
          mode.scope = mode.className;
          delete mode.className;
        }
      }
      function beginKeywords(mode, parent) {
        if (!parent)
          return;
        if (!mode.beginKeywords)
          return;
        mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
        mode.__beforeBegin = skipIfHasPrecedingDot;
        mode.keywords = mode.keywords || mode.beginKeywords;
        delete mode.beginKeywords;
        if (mode.relevance === undefined)
          mode.relevance = 0;
      }
      function compileIllegal(mode, _parent) {
        if (!Array.isArray(mode.illegal))
          return;
        mode.illegal = either(...mode.illegal);
      }
      function compileMatch(mode, _parent) {
        if (!mode.match)
          return;
        if (mode.begin || mode.end)
          throw new Error("begin & end are not supported with match");
        mode.begin = mode.match;
        delete mode.match;
      }
      function compileRelevance(mode, _parent) {
        if (mode.relevance === undefined)
          mode.relevance = 1;
      }
      const beforeMatchExt = (mode, parent) => {
        if (!mode.beforeMatch)
          return;
        if (mode.starts)
          throw new Error("beforeMatch cannot be used with starts");
        const originalMode = Object.assign({}, mode);
        Object.keys(mode).forEach(key => {
          delete mode[key];
        });
        mode.keywords = originalMode.keywords;
        mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
        mode.starts = {
          relevance: 0,
          contains: [Object.assign(originalMode, { endsParent: true })]
        };
        mode.relevance = 0;
        delete originalMode.beforeMatch;
      };
      const COMMON_KEYWORDS = [
        "of",
        "and",
        "for",
        "in",
        "not",
        "or",
        "if",
        "then",
        "parent",
        "list",
        "value"
      ];
      const DEFAULT_KEYWORD_SCOPE = "keyword";
      function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
        const compiledKeywords = Object.create(null);
        if (typeof rawKeywords === "string") {
          compileList(scopeName, rawKeywords.split(" "));
        } else if (Array.isArray(rawKeywords)) {
          compileList(scopeName, rawKeywords);
        } else {
          Object.keys(rawKeywords).forEach(function (scopeName) {
            Object.assign(compiledKeywords, compileKeywords(rawKeywords[scopeName], caseInsensitive, scopeName));
          });
        }
        return compiledKeywords;
        function compileList(scopeName, keywordList) {
          if (caseInsensitive) {
            keywordList = keywordList.map(x => x.toLowerCase());
          }
          keywordList.forEach(function (keyword) {
            const pair = keyword.split("|");
            compiledKeywords[pair[0]] = [
              scopeName,
              scoreForKeyword(pair[0], pair[1])
            ];
          });
        }
      }
      function scoreForKeyword(keyword, providedScore) {
        if (providedScore) {
          return Number(providedScore);
        }
        return commonKeyword(keyword) ? 0 : 1;
      }
      function commonKeyword(keyword) {
        return COMMON_KEYWORDS.includes(keyword.toLowerCase());
      }
      const seenDeprecations = {};
      const error = message => {
        console.error(message);
      };
      const warn = (message, ...args) => {
        console.log(`WARN: ${ message }`, ...args);
      };
      const deprecated = (version, message) => {
        if (seenDeprecations[`${ version }/${ message }`])
          return;
        console.log(`Deprecated as of ${ version }. ${ message }`);
        seenDeprecations[`${ version }/${ message }`] = true;
      };
      const MultiClassError = new Error();
      function remapScopeNames(mode, regexes, {key}) {
        let offset = 0;
        const scopeNames = mode[key];
        const emit = {};
        const positions = {};
        for (let i = 1; i <= regexes.length; i++) {
          positions[i + offset] = scopeNames[i];
          emit[i + offset] = true;
          offset += countMatchGroups(regexes[i - 1]);
        }
        mode[key] = positions;
        mode[key]._emit = emit;
        mode[key]._multi = true;
      }
      function beginMultiClass(mode) {
        if (!Array.isArray(mode.begin))
          return;
        if (mode.skip || mode.excludeBegin || mode.returnBegin) {
          error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
          throw MultiClassError;
        }
        if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
          error("beginScope must be object");
          throw MultiClassError;
        }
        remapScopeNames(mode, mode.begin, { key: "beginScope" });
        mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
      }
      function endMultiClass(mode) {
        if (!Array.isArray(mode.end))
          return;
        if (mode.skip || mode.excludeEnd || mode.returnEnd) {
          error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
          throw MultiClassError;
        }
        if (typeof mode.endScope !== "object" || mode.endScope === null) {
          error("endScope must be object");
          throw MultiClassError;
        }
        remapScopeNames(mode, mode.end, { key: "endScope" });
        mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
      }
      function scopeSugar(mode) {
        if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
          mode.beginScope = mode.scope;
          delete mode.scope;
        }
      }
      function MultiClass(mode) {
        scopeSugar(mode);
        if (typeof mode.beginScope === "string") {
          mode.beginScope = { _wrap: mode.beginScope };
        }
        if (typeof mode.endScope === "string") {
          mode.endScope = { _wrap: mode.endScope };
        }
        beginMultiClass(mode);
        endMultiClass(mode);
      }
      function compileLanguage(language) {
        function langRe(value, global) {
          return new RegExp(source(value), "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global ? "g" : ""));
        }
        class MultiRegex {
          constructor() {
            this.matchIndexes = {};
            this.regexes = [];
            this.matchAt = 1;
            this.position = 0;
          }
          addRule(re, opts) {
            opts.position = this.position++;
            this.matchIndexes[this.matchAt] = opts;
            this.regexes.push([
              opts,
              re
            ]);
            this.matchAt += countMatchGroups(re) + 1;
          }
          compile() {
            if (this.regexes.length === 0) {
              this.exec = () => null;
            }
            const terminators = this.regexes.map(el => el[1]);
            this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
            this.lastIndex = 0;
          }
          exec(s) {
            this.matcherRe.lastIndex = this.lastIndex;
            const match = this.matcherRe.exec(s);
            if (!match) {
              return null;
            }
            const i = match.findIndex((el, i) => i > 0 && el !== undefined);
            const matchData = this.matchIndexes[i];
            match.splice(0, i);
            return Object.assign(match, matchData);
          }
        }
        class ResumableMultiRegex {
          constructor() {
            this.rules = [];
            this.multiRegexes = [];
            this.count = 0;
            this.lastIndex = 0;
            this.regexIndex = 0;
          }
          getMatcher(index) {
            if (this.multiRegexes[index])
              return this.multiRegexes[index];
            const matcher = new MultiRegex();
            this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
            matcher.compile();
            this.multiRegexes[index] = matcher;
            return matcher;
          }
          resumingScanAtSamePosition() {
            return this.regexIndex !== 0;
          }
          considerAll() {
            this.regexIndex = 0;
          }
          addRule(re, opts) {
            this.rules.push([
              re,
              opts
            ]);
            if (opts.type === "begin")
              this.count++;
          }
          exec(s) {
            const m = this.getMatcher(this.regexIndex);
            m.lastIndex = this.lastIndex;
            let result = m.exec(s);
            if (this.resumingScanAtSamePosition()) {
              if (result && result.index === this.lastIndex);
              else {
                const m2 = this.getMatcher(0);
                m2.lastIndex = this.lastIndex + 1;
                result = m2.exec(s);
              }
            }
            if (result) {
              this.regexIndex += result.position + 1;
              if (this.regexIndex === this.count) {
                this.considerAll();
              }
            }
            return result;
          }
        }
        function buildModeRegex(mode) {
          const mm = new ResumableMultiRegex();
          mode.contains.forEach(term => mm.addRule(term.begin, {
            rule: term,
            type: "begin"
          }));
          if (mode.terminatorEnd) {
            mm.addRule(mode.terminatorEnd, { type: "end" });
          }
          if (mode.illegal) {
            mm.addRule(mode.illegal, { type: "illegal" });
          }
          return mm;
        }
        function compileMode(mode, parent) {
          const cmode = mode;
          if (mode.isCompiled)
            return cmode;
          [
            scopeClassName,
            compileMatch,
            MultiClass,
            beforeMatchExt
          ].forEach(ext => ext(mode, parent));
          language.compilerExtensions.forEach(ext => ext(mode, parent));
          mode.__beforeBegin = null;
          [
            beginKeywords,
            compileIllegal,
            compileRelevance
          ].forEach(ext => ext(mode, parent));
          mode.isCompiled = true;
          let keywordPattern = null;
          if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
            mode.keywords = Object.assign({}, mode.keywords);
            keywordPattern = mode.keywords.$pattern;
            delete mode.keywords.$pattern;
          }
          keywordPattern = keywordPattern || /\w+/;
          if (mode.keywords) {
            mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
          }
          cmode.keywordPatternRe = langRe(keywordPattern, true);
          if (parent) {
            if (!mode.begin)
              mode.begin = /\B|\b/;
            cmode.beginRe = langRe(cmode.begin);
            if (!mode.end && !mode.endsWithParent)
              mode.end = /\B|\b/;
            if (mode.end)
              cmode.endRe = langRe(cmode.end);
            cmode.terminatorEnd = source(cmode.end) || "";
            if (mode.endsWithParent && parent.terminatorEnd) {
              cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
            }
          }
          if (mode.illegal)
            cmode.illegalRe = langRe(mode.illegal);
          if (!mode.contains)
            mode.contains = [];
          mode.contains = [].concat(...mode.contains.map(function (c) {
            return expandOrCloneMode(c === "self" ? mode : c);
          }));
          mode.contains.forEach(function (c) {
            compileMode(c, cmode);
          });
          if (mode.starts) {
            compileMode(mode.starts, parent);
          }
          cmode.matcher = buildModeRegex(cmode);
          return cmode;
        }
        if (!language.compilerExtensions)
          language.compilerExtensions = [];
        if (language.contains && language.contains.includes("self")) {
          throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
        }
        language.classNameAliases = inherit$1(language.classNameAliases || {});
        return compileMode(language);
      }
      function dependencyOnParent(mode) {
        if (!mode)
          return false;
        return mode.endsWithParent || dependencyOnParent(mode.starts);
      }
      function expandOrCloneMode(mode) {
        if (mode.variants && !mode.cachedVariants) {
          mode.cachedVariants = mode.variants.map(function (variant) {
            return inherit$1(mode, { variants: null }, variant);
          });
        }
        if (mode.cachedVariants) {
          return mode.cachedVariants;
        }
        if (dependencyOnParent(mode)) {
          return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
        }
        if (Object.isFrozen(mode)) {
          return inherit$1(mode);
        }
        return mode;
      }
      var version = "11.9.0";
      class HTMLInjectionError extends Error {
        constructor(reason, html) {
          super(reason);
          this.name = "HTMLInjectionError";
          this.html = html;
        }
      }
      const escape = escapeHTML;
      const inherit = inherit$1;
      const NO_MATCH = Symbol("nomatch");
      const MAX_KEYWORD_HITS = 7;
      const HLJS = function (hljs) {
        const languages = Object.create(null);
        const aliases = Object.create(null);
        const plugins = [];
        let SAFE_MODE = true;
        const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
        const PLAINTEXT_LANGUAGE = {
          disableAutodetect: true,
          name: "Plain text",
          contains: []
        };
        let options = {
          ignoreUnescapedHTML: false,
          throwUnescapedHTML: false,
          noHighlightRe: /^(no-?highlight)$/i,
          languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
          classPrefix: "hljs-",
          cssSelector: "pre code",
          languages: null,
          __emitter: TokenTreeEmitter
        };
        function shouldNotHighlight(languageName) {
          return options.noHighlightRe.test(languageName);
        }
        function blockLanguage(block) {
          let classes = block.className + " ";
          classes += block.parentNode ? block.parentNode.className : "";
          const match = options.languageDetectRe.exec(classes);
          if (match) {
            const language = getLanguage(match[1]);
            if (!language) {
              warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
              warn("Falling back to no-highlight mode for this block.", block);
            }
            return language ? match[1] : "no-highlight";
          }
          return classes.split(/\s+/).find(_class => shouldNotHighlight(_class) || getLanguage(_class));
        }
        function highlight(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
          let code = "";
          let languageName = "";
          if (typeof optionsOrCode === "object") {
            code = codeOrLanguageName;
            ignoreIllegals = optionsOrCode.ignoreIllegals;
            languageName = optionsOrCode.language;
          } else {
            deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
            deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
            languageName = codeOrLanguageName;
            code = optionsOrCode;
          }
          if (ignoreIllegals === undefined) {
            ignoreIllegals = true;
          }
          const context = {
            code,
            language: languageName
          };
          fire("before:highlight", context);
          const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
          result.code = context.code;
          fire("after:highlight", result);
          return result;
        }
        function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
          const keywordHits = Object.create(null);
          function keywordData(mode, matchText) {
            return mode.keywords[matchText];
          }
          function processKeywords() {
            if (!top.keywords) {
              emitter.addText(modeBuffer);
              return;
            }
            let lastIndex = 0;
            top.keywordPatternRe.lastIndex = 0;
            let match = top.keywordPatternRe.exec(modeBuffer);
            let buf = "";
            while (match) {
              buf += modeBuffer.substring(lastIndex, match.index);
              const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
              const data = keywordData(top, word);
              if (data) {
                const [kind, keywordRelevance] = data;
                emitter.addText(buf);
                buf = "";
                keywordHits[word] = (keywordHits[word] || 0) + 1;
                if (keywordHits[word] <= MAX_KEYWORD_HITS)
                  relevance += keywordRelevance;
                if (kind.startsWith("_")) {
                  buf += match[0];
                } else {
                  const cssClass = language.classNameAliases[kind] || kind;
                  emitKeyword(match[0], cssClass);
                }
              } else {
                buf += match[0];
              }
              lastIndex = top.keywordPatternRe.lastIndex;
              match = top.keywordPatternRe.exec(modeBuffer);
            }
            buf += modeBuffer.substring(lastIndex);
            emitter.addText(buf);
          }
          function processSubLanguage() {
            if (modeBuffer === "")
              return;
            let result = null;
            if (typeof top.subLanguage === "string") {
              if (!languages[top.subLanguage]) {
                emitter.addText(modeBuffer);
                return;
              }
              result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
              continuations[top.subLanguage] = result._top;
            } else {
              result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
            }
            if (top.relevance > 0) {
              relevance += result.relevance;
            }
            emitter.__addSublanguage(result._emitter, result.language);
          }
          function processBuffer() {
            if (top.subLanguage != null) {
              processSubLanguage();
            } else {
              processKeywords();
            }
            modeBuffer = "";
          }
          function emitKeyword(keyword, scope) {
            if (keyword === "")
              return;
            emitter.startScope(scope);
            emitter.addText(keyword);
            emitter.endScope();
          }
          function emitMultiClass(scope, match) {
            let i = 1;
            const max = match.length - 1;
            while (i <= max) {
              if (!scope._emit[i]) {
                i++;
                continue;
              }
              const klass = language.classNameAliases[scope[i]] || scope[i];
              const text = match[i];
              if (klass) {
                emitKeyword(text, klass);
              } else {
                modeBuffer = text;
                processKeywords();
                modeBuffer = "";
              }
              i++;
            }
          }
          function startNewMode(mode, match) {
            if (mode.scope && typeof mode.scope === "string") {
              emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
            }
            if (mode.beginScope) {
              if (mode.beginScope._wrap) {
                emitKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
                modeBuffer = "";
              } else if (mode.beginScope._multi) {
                emitMultiClass(mode.beginScope, match);
                modeBuffer = "";
              }
            }
            top = Object.create(mode, { parent: { value: top } });
            return top;
          }
          function endOfMode(mode, match, matchPlusRemainder) {
            let matched = startsWith(mode.endRe, matchPlusRemainder);
            if (matched) {
              if (mode["on:end"]) {
                const resp = new Response(mode);
                mode["on:end"](match, resp);
                if (resp.isMatchIgnored)
                  matched = false;
              }
              if (matched) {
                while (mode.endsParent && mode.parent) {
                  mode = mode.parent;
                }
                return mode;
              }
            }
            if (mode.endsWithParent) {
              return endOfMode(mode.parent, match, matchPlusRemainder);
            }
          }
          function doIgnore(lexeme) {
            if (top.matcher.regexIndex === 0) {
              modeBuffer += lexeme[0];
              return 1;
            } else {
              resumeScanAtSamePosition = true;
              return 0;
            }
          }
          function doBeginMatch(match) {
            const lexeme = match[0];
            const newMode = match.rule;
            const resp = new Response(newMode);
            const beforeCallbacks = [
              newMode.__beforeBegin,
              newMode["on:begin"]
            ];
            for (const cb of beforeCallbacks) {
              if (!cb)
                continue;
              cb(match, resp);
              if (resp.isMatchIgnored)
                return doIgnore(lexeme);
            }
            if (newMode.skip) {
              modeBuffer += lexeme;
            } else {
              if (newMode.excludeBegin) {
                modeBuffer += lexeme;
              }
              processBuffer();
              if (!newMode.returnBegin && !newMode.excludeBegin) {
                modeBuffer = lexeme;
              }
            }
            startNewMode(newMode, match);
            return newMode.returnBegin ? 0 : lexeme.length;
          }
          function doEndMatch(match) {
            const lexeme = match[0];
            const matchPlusRemainder = codeToHighlight.substring(match.index);
            const endMode = endOfMode(top, match, matchPlusRemainder);
            if (!endMode) {
              return NO_MATCH;
            }
            const origin = top;
            if (top.endScope && top.endScope._wrap) {
              processBuffer();
              emitKeyword(lexeme, top.endScope._wrap);
            } else if (top.endScope && top.endScope._multi) {
              processBuffer();
              emitMultiClass(top.endScope, match);
            } else if (origin.skip) {
              modeBuffer += lexeme;
            } else {
              if (!(origin.returnEnd || origin.excludeEnd)) {
                modeBuffer += lexeme;
              }
              processBuffer();
              if (origin.excludeEnd) {
                modeBuffer = lexeme;
              }
            }
            do {
              if (top.scope) {
                emitter.closeNode();
              }
              if (!top.skip && !top.subLanguage) {
                relevance += top.relevance;
              }
              top = top.parent;
            } while (top !== endMode.parent);
            if (endMode.starts) {
              startNewMode(endMode.starts, match);
            }
            return origin.returnEnd ? 0 : lexeme.length;
          }
          function processContinuations() {
            const list = [];
            for (let current = top; current !== language; current = current.parent) {
              if (current.scope) {
                list.unshift(current.scope);
              }
            }
            list.forEach(item => emitter.openNode(item));
          }
          let lastMatch = {};
          function processLexeme(textBeforeMatch, match) {
            const lexeme = match && match[0];
            modeBuffer += textBeforeMatch;
            if (lexeme == null) {
              processBuffer();
              return 0;
            }
            if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
              modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
              if (!SAFE_MODE) {
                const err = new Error(`0 width match regex (${ languageName })`);
                err.languageName = languageName;
                err.badRule = lastMatch.rule;
                throw err;
              }
              return 1;
            }
            lastMatch = match;
            if (match.type === "begin") {
              return doBeginMatch(match);
            } else if (match.type === "illegal" && !ignoreIllegals) {
              const err = new Error("Illegal lexeme \"" + lexeme + "\" for mode \"" + (top.scope || "<unnamed>") + "\"");
              err.mode = top;
              throw err;
            } else if (match.type === "end") {
              const processed = doEndMatch(match);
              if (processed !== NO_MATCH) {
                return processed;
              }
            }
            if (match.type === "illegal" && lexeme === "") {
              return 1;
            }
            if (iterations > 100000 && iterations > match.index * 3) {
              const err = new Error("potential infinite loop, way more iterations than matches");
              throw err;
            }
            modeBuffer += lexeme;
            return lexeme.length;
          }
          const language = getLanguage(languageName);
          if (!language) {
            error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
            throw new Error("Unknown language: \"" + languageName + "\"");
          }
          const md = compileLanguage(language);
          let result = "";
          let top = continuation || md;
          const continuations = {};
          const emitter = new options.__emitter(options);
          processContinuations();
          let modeBuffer = "";
          let relevance = 0;
          let index = 0;
          let iterations = 0;
          let resumeScanAtSamePosition = false;
          try {
            if (!language.__emitTokens) {
              top.matcher.considerAll();
              for (;;) {
                iterations++;
                if (resumeScanAtSamePosition) {
                  resumeScanAtSamePosition = false;
                } else {
                  top.matcher.considerAll();
                }
                top.matcher.lastIndex = index;
                const match = top.matcher.exec(codeToHighlight);
                if (!match)
                  break;
                const beforeMatch = codeToHighlight.substring(index, match.index);
                const processedCount = processLexeme(beforeMatch, match);
                index = match.index + processedCount;
              }
              processLexeme(codeToHighlight.substring(index));
            } else {
              language.__emitTokens(codeToHighlight, emitter);
            }
            emitter.finalize();
            result = emitter.toHTML();
            return {
              language: languageName,
              value: result,
              relevance,
              illegal: false,
              _emitter: emitter,
              _top: top
            };
          } catch (err) {
            if (err.message && err.message.includes("Illegal")) {
              return {
                language: languageName,
                value: escape(codeToHighlight),
                illegal: true,
                relevance: 0,
                _illegalBy: {
                  message: err.message,
                  index,
                  context: codeToHighlight.slice(index - 100, index + 100),
                  mode: err.mode,
                  resultSoFar: result
                },
                _emitter: emitter
              };
            } else if (SAFE_MODE) {
              return {
                language: languageName,
                value: escape(codeToHighlight),
                illegal: false,
                relevance: 0,
                errorRaised: err,
                _emitter: emitter,
                _top: top
              };
            } else {
              throw err;
            }
          }
        }
        function justTextHighlightResult(code) {
          const result = {
            value: escape(code),
            illegal: false,
            relevance: 0,
            _top: PLAINTEXT_LANGUAGE,
            _emitter: new options.__emitter(options)
          };
          result._emitter.addText(code);
          return result;
        }
        function highlightAuto(code, languageSubset) {
          languageSubset = languageSubset || options.languages || Object.keys(languages);
          const plaintext = justTextHighlightResult(code);
          const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name => _highlight(name, code, false));
          results.unshift(plaintext);
          const sorted = results.sort((a, b) => {
            if (a.relevance !== b.relevance)
              return b.relevance - a.relevance;
            if (a.language && b.language) {
              if (getLanguage(a.language).supersetOf === b.language) {
                return 1;
              } else if (getLanguage(b.language).supersetOf === a.language) {
                return -1;
              }
            }
            return 0;
          });
          const [best, secondBest] = sorted;
          const result = best;
          result.secondBest = secondBest;
          return result;
        }
        function updateClassName(element, currentLang, resultLang) {
          const language = currentLang && aliases[currentLang] || resultLang;
          element.classList.add("hljs");
          element.classList.add(`language-${ language }`);
        }
        function highlightElement(element) {
          let node = null;
          const language = blockLanguage(element);
          if (shouldNotHighlight(language))
            return;
          fire("before:highlightElement", {
            el: element,
            language
          });
          if (element.dataset.highlighted) {
            console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", element);
            return;
          }
          if (element.children.length > 0) {
            if (!options.ignoreUnescapedHTML) {
              console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
              console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
              console.warn("The element with unescaped HTML:");
              console.warn(element);
            }
            if (options.throwUnescapedHTML) {
              const err = new HTMLInjectionError("One of your code blocks includes unescaped HTML.", element.innerHTML);
              throw err;
            }
          }
          node = element;
          const text = node.textContent;
          const result = language ? highlight(text, {
            language,
            ignoreIllegals: true
          }) : highlightAuto(text);
          element.innerHTML = result.value;
          element.dataset.highlighted = "yes";
          updateClassName(element, language, result.language);
          element.result = {
            language: result.language,
            re: result.relevance,
            relevance: result.relevance
          };
          if (result.secondBest) {
            element.secondBest = {
              language: result.secondBest.language,
              relevance: result.secondBest.relevance
            };
          }
          fire("after:highlightElement", {
            el: element,
            result,
            text
          });
        }
        function configure(userOptions) {
          options = inherit(options, userOptions);
        }
        const initHighlighting = () => {
          highlightAll();
          deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
        };
        function initHighlightingOnLoad() {
          highlightAll();
          deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
        }
        let wantsHighlight = false;
        function highlightAll() {
          if (document.readyState === "loading") {
            wantsHighlight = true;
            return;
          }
          const blocks = document.querySelectorAll(options.cssSelector);
          blocks.forEach(highlightElement);
        }
        function boot() {
          if (wantsHighlight)
            highlightAll();
        }
        if (typeof window !== "undefined" && window.addEventListener) {
          window.addEventListener("DOMContentLoaded", boot, false);
        }
        function registerLanguage(languageName, languageDefinition) {
          let lang = null;
          try {
            lang = languageDefinition(hljs);
          } catch (error$1) {
            error("Language definition for '{}' could not be registered.".replace("{}", languageName));
            if (!SAFE_MODE) {
              throw error$1;
            } else {
              error(error$1);
            }
            lang = PLAINTEXT_LANGUAGE;
          }
          if (!lang.name)
            lang.name = languageName;
          languages[languageName] = lang;
          lang.rawDefinition = languageDefinition.bind(null, hljs);
          if (lang.aliases) {
            registerAliases(lang.aliases, { languageName });
          }
        }
        function unregisterLanguage(languageName) {
          delete languages[languageName];
          for (const alias of Object.keys(aliases)) {
            if (aliases[alias] === languageName) {
              delete aliases[alias];
            }
          }
        }
        function listLanguages() {
          return Object.keys(languages);
        }
        function getLanguage(name) {
          name = (name || "").toLowerCase();
          return languages[name] || languages[aliases[name]];
        }
        function registerAliases(aliasList, {languageName}) {
          if (typeof aliasList === "string") {
            aliasList = [aliasList];
          }
          aliasList.forEach(alias => {
            aliases[alias.toLowerCase()] = languageName;
          });
        }
        function autoDetection(name) {
          const lang = getLanguage(name);
          return lang && !lang.disableAutodetect;
        }
        function upgradePluginAPI(plugin) {
          if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
            plugin["before:highlightElement"] = data => {
              plugin["before:highlightBlock"](Object.assign({ block: data.el }, data));
            };
          }
          if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
            plugin["after:highlightElement"] = data => {
              plugin["after:highlightBlock"](Object.assign({ block: data.el }, data));
            };
          }
        }
        function addPlugin(plugin) {
          upgradePluginAPI(plugin);
          plugins.push(plugin);
        }
        function removePlugin(plugin) {
          const index = plugins.indexOf(plugin);
          if (index !== -1) {
            plugins.splice(index, 1);
          }
        }
        function fire(event, args) {
          const cb = event;
          plugins.forEach(function (plugin) {
            if (plugin[cb]) {
              plugin[cb](args);
            }
          });
        }
        function deprecateHighlightBlock(el) {
          deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
          deprecated("10.7.0", "Please use highlightElement now.");
          return highlightElement(el);
        }
        Object.assign(hljs, {
          highlight,
          highlightAuto,
          highlightAll,
          highlightElement,
          highlightBlock: deprecateHighlightBlock,
          configure,
          initHighlighting,
          initHighlightingOnLoad,
          registerLanguage,
          unregisterLanguage,
          listLanguages,
          getLanguage,
          registerAliases,
          autoDetection,
          inherit,
          addPlugin,
          removePlugin
        });
        hljs.debugMode = function () {
          SAFE_MODE = false;
        };
        hljs.safeMode = function () {
          SAFE_MODE = true;
        };
        hljs.versionString = version;
        hljs.regex = {
          concat: concat,
          lookahead: lookahead,
          either: either,
          optional: optional,
          anyNumberOfTimes: anyNumberOfTimes
        };
        for (const key in MODES) {
          if (typeof MODES[key] === "object") {
            deepFreeze(MODES[key]);
          }
        }
        Object.assign(hljs, MODES);
        return hljs;
      };
      const highlight = HLJS({});
      highlight.newInstance = () => HLJS({});
      exports$1 = highlight;
      highlight.HighlightJS = highlight;
      highlight.default = highlight;
      var HighlightJS = exports$1;

      const IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
      const KEYWORDS = [
        "as",
        "in",
        "of",
        "if",
        "for",
        "while",
        "finally",
        "var",
        "new",
        "function",
        "do",
        "return",
        "void",
        "else",
        "break",
        "catch",
        "instanceof",
        "with",
        "throw",
        "case",
        "default",
        "try",
        "switch",
        "continue",
        "typeof",
        "delete",
        "let",
        "yield",
        "const",
        "class",
        "debugger",
        "async",
        "await",
        "static",
        "import",
        "from",
        "export",
        "extends"
      ];
      const LITERALS = [
        "true",
        "false",
        "null",
        "undefined",
        "NaN",
        "Infinity"
      ];
      const TYPES = [
        "Object",
        "Function",
        "Boolean",
        "Symbol",
        "Math",
        "Date",
        "Number",
        "BigInt",
        "String",
        "RegExp",
        "Array",
        "Float32Array",
        "Float64Array",
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Int32Array",
        "Uint16Array",
        "Uint32Array",
        "BigInt64Array",
        "BigUint64Array",
        "Set",
        "Map",
        "WeakSet",
        "WeakMap",
        "ArrayBuffer",
        "SharedArrayBuffer",
        "Atomics",
        "DataView",
        "JSON",
        "Promise",
        "Generator",
        "GeneratorFunction",
        "AsyncFunction",
        "Reflect",
        "Proxy",
        "Intl",
        "WebAssembly"
      ];
      const ERROR_TYPES = [
        "Error",
        "EvalError",
        "InternalError",
        "RangeError",
        "ReferenceError",
        "SyntaxError",
        "TypeError",
        "URIError"
      ];
      const BUILT_IN_GLOBALS = [
        "setInterval",
        "setTimeout",
        "clearInterval",
        "clearTimeout",
        "require",
        "exports",
        "eval",
        "isFinite",
        "isNaN",
        "parseFloat",
        "parseInt",
        "decodeURI",
        "decodeURIComponent",
        "encodeURI",
        "encodeURIComponent",
        "escape",
        "unescape"
      ];
      const BUILT_IN_VARIABLES = [
        "arguments",
        "this",
        "super",
        "console",
        "window",
        "document",
        "localStorage",
        "sessionStorage",
        "module",
        "global"
      ];
      const BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);
      function javascript(hljs) {
        const regex = hljs.regex;
        const hasClosingTag = (match, {after}) => {
          const tag = "</" + match[0].slice(1);
          const pos = match.input.indexOf(tag, after);
          return pos !== -1;
        };
        const IDENT_RE$1 = IDENT_RE;
        const FRAGMENT = {
          begin: "<>",
          end: "</>"
        };
        const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
        const XML_TAG = {
          begin: /<[A-Za-z0-9\\._:-]+/,
          end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
          isTrulyOpeningTag: (match, response) => {
            const afterMatchIndex = match[0].length + match.index;
            const nextChar = match.input[afterMatchIndex];
            if (nextChar === "<" || nextChar === ",") {
              response.ignoreMatch();
              return;
            }
            if (nextChar === ">") {
              if (!hasClosingTag(match, { after: afterMatchIndex })) {
                response.ignoreMatch();
              }
            }
            let m;
            const afterMatch = match.input.substring(afterMatchIndex);
            if (m = afterMatch.match(/^\s*=/)) {
              response.ignoreMatch();
              return;
            }
            if (m = afterMatch.match(/^\s+extends\s+/)) {
              if (m.index === 0) {
                response.ignoreMatch();
                return;
              }
            }
          }
        };
        const KEYWORDS$1 = {
          $pattern: IDENT_RE,
          keyword: KEYWORDS,
          literal: LITERALS,
          built_in: BUILT_INS,
          "variable.language": BUILT_IN_VARIABLES
        };
        const decimalDigits = "[0-9](_?[0-9])*";
        const frac = `\\.(${ decimalDigits })`;
        const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
        const NUMBER = {
          className: "number",
          variants: [
            { begin: `(\\b(${ decimalInteger })((${ frac })|\\.)?|(${ frac }))` + `[eE][+-]?(${ decimalDigits })\\b` },
            { begin: `\\b(${ decimalInteger })\\b((${ frac })\\b|\\.)?|(${ frac })\\b` },
            { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
            { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
            { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
            { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
            { begin: "\\b0[0-7]+n?\\b" }
          ],
          relevance: 0
        };
        const SUBST = {
          className: "subst",
          begin: "\\$\\{",
          end: "\\}",
          keywords: KEYWORDS$1,
          contains: []
        };
        const HTML_TEMPLATE = {
          begin: "html`",
          end: "",
          starts: {
            end: "`",
            returnEnd: false,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST
            ],
            subLanguage: "xml"
          }
        };
        const CSS_TEMPLATE = {
          begin: "css`",
          end: "",
          starts: {
            end: "`",
            returnEnd: false,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST
            ],
            subLanguage: "css"
          }
        };
        const GRAPHQL_TEMPLATE = {
          begin: "gql`",
          end: "",
          starts: {
            end: "`",
            returnEnd: false,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST
            ],
            subLanguage: "graphql"
          }
        };
        const TEMPLATE_STRING = {
          className: "string",
          begin: "`",
          end: "`",
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ]
        };
        const JSDOC_COMMENT = hljs.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
          relevance: 0,
          contains: [{
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: true,
                  excludeBegin: true,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: IDENT_RE$1 + "(?=\\s*(-)|$)",
                  endsParent: true,
                  relevance: 0
                },
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }]
        });
        const COMMENT = {
          className: "comment",
          variants: [
            JSDOC_COMMENT,
            hljs.C_BLOCK_COMMENT_MODE,
            hljs.C_LINE_COMMENT_MODE
          ]
        };
        const SUBST_INTERNALS = [
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          HTML_TEMPLATE,
          CSS_TEMPLATE,
          GRAPHQL_TEMPLATE,
          TEMPLATE_STRING,
          { match: /\$\d+/ },
          NUMBER
        ];
        SUBST.contains = SUBST_INTERNALS.concat({
          begin: /\{/,
          end: /\}/,
          keywords: KEYWORDS$1,
          contains: ["self"].concat(SUBST_INTERNALS)
        });
        const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
        const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([{
            begin: /\(/,
            end: /\)/,
            keywords: KEYWORDS$1,
            contains: ["self"].concat(SUBST_AND_COMMENTS)
          }]);
        const PARAMS = {
          className: "params",
          begin: /\(/,
          end: /\)/,
          excludeBegin: true,
          excludeEnd: true,
          keywords: KEYWORDS$1,
          contains: PARAMS_CONTAINS
        };
        const CLASS_OR_EXTENDS = {
          variants: [
            {
              match: [
                /class/,
                /\s+/,
                IDENT_RE$1,
                /\s+/,
                /extends/,
                /\s+/,
                regex.concat(IDENT_RE$1, "(", regex.concat(/\./, IDENT_RE$1), ")*")
              ],
              scope: {
                1: "keyword",
                3: "title.class",
                5: "keyword",
                7: "title.class.inherited"
              }
            },
            {
              match: [
                /class/,
                /\s+/,
                IDENT_RE$1
              ],
              scope: {
                1: "keyword",
                3: "title.class"
              }
            }
          ]
        };
        const CLASS_REFERENCE = {
          relevance: 0,
          match: regex.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/, /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),
          className: "title.class",
          keywords: {
            _: [
              ...TYPES,
              ...ERROR_TYPES
            ]
          }
        };
        const USE_STRICT = {
          label: "use_strict",
          className: "meta",
          relevance: 10,
          begin: /^\s*['"]use (strict|asm)['"]/
        };
        const FUNCTION_DEFINITION = {
          variants: [
            {
              match: [
                /function/,
                /\s+/,
                IDENT_RE$1,
                /(?=\s*\()/
              ]
            },
            {
              match: [
                /function/,
                /\s*(?=\()/
              ]
            }
          ],
          className: {
            1: "keyword",
            3: "title.function"
          },
          label: "func.def",
          contains: [PARAMS],
          illegal: /%/
        };
        const UPPER_CASE_CONSTANT = {
          relevance: 0,
          match: /\b[A-Z][A-Z_0-9]+\b/,
          className: "variable.constant"
        };
        function noneOf(list) {
          return regex.concat("(?!", list.join("|"), ")");
        }
        const FUNCTION_CALL = {
          match: regex.concat(/\b/, noneOf([
            ...BUILT_IN_GLOBALS,
            "super",
            "import"
          ]), IDENT_RE$1, regex.lookahead(/\(/)),
          className: "title.function",
          relevance: 0
        };
        const PROPERTY_ACCESS = {
          begin: regex.concat(/\./, regex.lookahead(regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/))),
          end: IDENT_RE$1,
          excludeBegin: true,
          keywords: "prototype",
          className: "property",
          relevance: 0
        };
        const GETTER_OR_SETTER = {
          match: [
            /get|set/,
            /\s+/,
            IDENT_RE$1,
            /(?=\()/
          ],
          className: {
            1: "keyword",
            3: "title.function"
          },
          contains: [
            { begin: /\(\)/ },
            PARAMS
          ]
        };
        const FUNC_LEAD_IN_RE = "(\\(" + "[^()]*(\\(" + "[^()]*(\\(" + "[^()]*" + "\\)[^()]*)*" + "\\)[^()]*)*" + "\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
        const FUNCTION_VARIABLE = {
          match: [
            /const|var|let/,
            /\s+/,
            IDENT_RE$1,
            /\s*/,
            /=\s*/,
            /(async\s*)?/,
            regex.lookahead(FUNC_LEAD_IN_RE)
          ],
          keywords: "async",
          className: {
            1: "keyword",
            3: "title.function"
          },
          contains: [PARAMS]
        };
        return {
          name: "JavaScript",
          aliases: [
            "js",
            "jsx",
            "mjs",
            "cjs"
          ],
          keywords: KEYWORDS$1,
          exports: {
            PARAMS_CONTAINS,
            CLASS_REFERENCE
          },
          illegal: /#(?![$_A-z])/,
          contains: [
            hljs.SHEBANG({
              label: "shebang",
              binary: "node",
              relevance: 5
            }),
            USE_STRICT,
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE,
            HTML_TEMPLATE,
            CSS_TEMPLATE,
            GRAPHQL_TEMPLATE,
            TEMPLATE_STRING,
            COMMENT,
            { match: /\$\d+/ },
            NUMBER,
            CLASS_REFERENCE,
            {
              className: "attr",
              begin: IDENT_RE$1 + regex.lookahead(":"),
              relevance: 0
            },
            FUNCTION_VARIABLE,
            {
              begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
              keywords: "return throw case",
              relevance: 0,
              contains: [
                COMMENT,
                hljs.REGEXP_MODE,
                {
                  className: "function",
                  begin: FUNC_LEAD_IN_RE,
                  returnBegin: true,
                  end: "\\s*=>",
                  contains: [{
                      className: "params",
                      variants: [
                        {
                          begin: hljs.UNDERSCORE_IDENT_RE,
                          relevance: 0
                        },
                        {
                          className: null,
                          begin: /\(\s*\)/,
                          skip: true
                        },
                        {
                          begin: /\(/,
                          end: /\)/,
                          excludeBegin: true,
                          excludeEnd: true,
                          keywords: KEYWORDS$1,
                          contains: PARAMS_CONTAINS
                        }
                      ]
                    }]
                },
                {
                  begin: /,/,
                  relevance: 0
                },
                {
                  match: /\s+/,
                  relevance: 0
                },
                {
                  variants: [
                    {
                      begin: FRAGMENT.begin,
                      end: FRAGMENT.end
                    },
                    { match: XML_SELF_CLOSING },
                    {
                      begin: XML_TAG.begin,
                      "on:begin": XML_TAG.isTrulyOpeningTag,
                      end: XML_TAG.end
                    }
                  ],
                  subLanguage: "xml",
                  contains: [{
                      begin: XML_TAG.begin,
                      end: XML_TAG.end,
                      skip: true,
                      contains: ["self"]
                    }]
                }
              ]
            },
            FUNCTION_DEFINITION,
            { beginKeywords: "while if switch catch for" },
            {
              begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\(" + "[^()]*(\\(" + "[^()]*(\\(" + "[^()]*" + "\\)[^()]*)*" + "\\)[^()]*)*" + "\\)\\s*\\{",
              returnBegin: true,
              label: "func.def",
              contains: [
                PARAMS,
                hljs.inherit(hljs.TITLE_MODE, {
                  begin: IDENT_RE$1,
                  className: "title.function"
                })
              ]
            },
            {
              match: /\.\.\./,
              relevance: 0
            },
            PROPERTY_ACCESS,
            {
              match: "\\$" + IDENT_RE$1,
              relevance: 0
            },
            {
              match: [/\bconstructor(?=\s*\()/],
              className: { 1: "title.function" },
              contains: [PARAMS]
            },
            FUNCTION_CALL,
            UPPER_CASE_CONSTANT,
            CLASS_OR_EXTENDS,
            GETTER_OR_SETTER,
            { match: /\$[(.]/ }
          ]
        };
      }

      function shell(hljs) {
        return {
          name: "Shell Session",
          aliases: [
            "console",
            "shellsession"
          ],
          contains: [{
              className: "meta.prompt",
              begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
              starts: {
                end: /[^\\](?=\s*$)/,
                subLanguage: "bash"
              }
            }]
        };
      }

      var __varRecorder__$q = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/md/morphs.js", __contextModule__);
      HighlightJS.registerLanguage("javascript", javascript);
      HighlightJS.registerLanguage("shell", shell);
      var MarkdownPreviewMorph = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/md/morphs.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("MarkdownPreviewMorph") && typeof __lively_classholder__.MarkdownPreviewMorph === "function" ? __lively_classholder__.MarkdownPreviewMorph : __lively_classholder__.MarkdownPreviewMorph = function MarkdownPreviewMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "reset",
          value: function MarkdownPreviewMorph_reset_() {
            this.disconnectMarkdownScrollToHTMLScroll();
            this.disconnectHTMLScrollToMarkdownScroll();
            this.connectMarkdownScrollToHTMLScroll(true);
            this.connectHTMLScrollToMarkdownScroll(true);
          }
        }, {
          key: "___",
          value: function MarkdownPreviewMorph_____() {
            this.markdownToHTMLPositionMap.map(function (ea, i) {
              return "".concat(i, ": ").concat(Math.round(ea));
            }).join("\n");
          }
        }, {
          key: "smoothScrollStart",
          value: function MarkdownPreviewMorph_smoothScrollStart_(morph, scrollToY, scrollDeltaY) {
            var startTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Date.now();
            this.debug && console.log("[smoothScroll] start", scrollToY);
            if (!this._smoothScroll) this._smoothScroll = [];

            for (var i = this._smoothScroll.length; i--;) {
              if (this._smoothScroll[i][0] === morph) {
                this._smoothScroll.splice(i, 1);
              }
            }

            this._smoothScroll.push([morph, scrollToY, scrollDeltaY, startTime]);

            this.startStepping("smoothScrollStep");
          }
        }, {
          key: "smoothScrollStep",
          value: function MarkdownPreviewMorph_smoothScrollStep_() {
            if (!this._smoothScroll) {
              this.debug && console.log("[smoothScroll] stop");
              this.stopSteppingScriptNamed("smoothScrollStep");
              return;
            }

            var maxTime = 1000;

            for (var i = this._smoothScroll.length; i--;) {
              var spec = this._smoothScroll[i];

              var _spec = _slicedToArray(spec, 4),
                  m = _spec[0],
                  scrollToY = _spec[1],
                  scrollDeltaY = _spec[2],
                  startTime = _spec[3];

              var node = m.env.renderer.getNodeForMorph(m);
              var deltaY = Math.abs(node.scrollTop - scrollToY);

              if (deltaY < 1 || Date.now() - startTime > maxTime) {
                this._smoothScroll.splice(i, 1);

                continue;
              }

              if (!scrollDeltaY) scrollDeltaY = spec[2] = deltaY / 10;
              if (deltaY < scrollDeltaY) scrollDeltaY = deltaY;
              if (node.scrollTop > scrollToY) scrollDeltaY = -scrollDeltaY;
              node.scrollTop = node.scrollTop + scrollDeltaY;
              this.debug && console.log("[smoothScroll] step", node.scrollTop + scrollDeltaY);
            }

            if (!this._smoothScroll.length) this._smoothScroll = null;
          }
        }, {
          key: "computeMarkdownToHTMLPositionMap",
          value: function MarkdownPreviewMorph_computeMarkdownToHTMLPositionMap_() {
            var lineEls = this.domNode.querySelectorAll(".markdown-line-marker");
            if (!lineEls.length) return [];
            var lastMdLine = this.markdownSource.split("\n").length;
            var parent = lineEls[0].parentElement;

            var _parent$getBoundingCl = parent.getBoundingClientRect(),
                parentTop = _parent$getBoundingCl.top,
                parentHeight = _parent$getBoundingCl.height;

            var lineElsByMdLines = Array.from(lineEls).reduce(function (heightMap, el) {
              var line = Number(el.getAttribute("data-mdline"));
              heightMap[line] = el.getBoundingClientRect().top - parentTop;
              return heightMap;
            }, []);
            lineElsByMdLines[lastMdLine] = parentHeight;
            lineElsByMdLines.join("\n");
            lineElsByMdLines.slice(-15).join("\n");

            for (var nextMdLine, mdLine = 0; mdLine < lineElsByMdLines.length - 1; mdLine++) {
              for (var j = mdLine + 1; j < lineElsByMdLines.length; j++) {
                if (undefined !== lineElsByMdLines[j]) {
                  nextMdLine = j;
                  break;
                }
              }

              var steps = nextMdLine - mdLine;
              var heightDiff = lineElsByMdLines[nextMdLine] - lineElsByMdLines[mdLine];
              var step = heightDiff / steps;

              for (var _j = mdLine + 1; _j < nextMdLine; _j++) {
                lineElsByMdLines[_j] = (lineElsByMdLines[_j - 1] || 0) + step;
              }

              mdLine = nextMdLine - 1;
            }

            return lineElsByMdLines;
          }
        }, {
          key: "syncMarkdownScrollToHTMLScroll",
          value: function MarkdownPreviewMorph_syncMarkdownScrollToHTMLScroll_() {
            var _this = this;

            var editor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.markdownEditor;
            if (!editor) return;
            var _editor$whatsVisible = editor.whatsVisible,
                startRow = _editor$whatsVisible.startRow,
                endRow = _editor$whatsVisible.endRow;
            var nLines = editor.lineCount();
            var nRowsVisible = endRow - startRow;
            var centerRow = Math.round(startRow + (endRow - startRow) / 2);
            var markdownToHTMLPositionMap = this.markdownToHTMLPositionMap;
            var debug = this.debug;
            var targetRow;

            function sigmoid(x) {
              var L = nRowsVisible;
              var k = 0.7;
              var x0 = nLines / 2;
              return L / (1 + Math.pow(Math.E, -k * (x - x0)));
            }

            if (startRow < nRowsVisible / 2) {
              targetRow = startRow * 2;
              debug && console.log("[start] ".concat(centerRow, " => ").concat(targetRow));
            } else if (centerRow < nLines / 2 - nRowsVisible / 4 || centerRow > nLines / 2 + nRowsVisible / 4) {
              targetRow = centerRow;
              debug && console.log("[just centerRow] ".concat(centerRow, " => ").concat(targetRow));
            } else {
              targetRow = Math.round(nLines / 2 - nRowsVisible / 4 + sigmoid(centerRow));
              debug && console.log("[sigmoid center] ".concat(centerRow, " => ").concat(targetRow));
            }

            if (typeof markdownToHTMLPositionMap[targetRow] !== "number") return;
            this.htmlScrollToMarkdownScrollConnections().forEach(function (ea) {
              return ea.deactivate();
            });
            this.smoothScrollStart(this, markdownToHTMLPositionMap[targetRow]);
            waitFor$1(function () {
              return !_this._smoothScroll;
            }, function () {
              return _this.htmlScrollToMarkdownScrollConnections().forEach(function (ea) {
                return ea.activate();
              });
            });
          }
        }, {
          key: "syncHTMLScrollToMarkdownScroll",
          value: function MarkdownPreviewMorph_syncHTMLScrollToMarkdownScroll_() {
            var _this2 = this;

            var editor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.markdownEditor;
            if (!editor) return;
            var markdownToHTMLPositionMap = this.markdownToHTMLPositionMap;
            var t = this.domNode.parentNode.scrollTop;
            var mdLineClosest = markdownToHTMLPositionMap.reduce(function (min, height, i) {
              var delta = Math.abs(height - t);
              if (min.delta < delta) return min;
              return {
                delta: delta,
                height: height,
                line: i
              };
            }, {
              delta: Infinity,
              line: -1
            });
            this.markdownScrollToHTMLScrollConnections(editor).forEach(function (ea) {
              return ea.activate();
            });

            var _editor$charBoundsFro = editor.charBoundsFromTextPosition({
              row: mdLineClosest.line,
              column: 0
            }),
                y = _editor$charBoundsFro.y;

            this.smoothScrollStart(editor, y);
            waitFor$1(function () {
              return !_this2._smoothScroll;
            }, function () {
              return _this2.markdownScrollToHTMLScrollConnections(editor).forEach(function (ea) {
                return ea.deactivate();
              });
            });
          }
        }, {
          key: "syncHTMLScrollToMarkdownScrollDebounced",
          value: function MarkdownPreviewMorph_syncHTMLScrollToMarkdownScrollDebounced_(editor) {
            var _this3 = this;

            requestAnimationFrame(function () {
              return _this3.syncHTMLScrollToMarkdownScroll(editor);
            });
          }
        }, {
          key: "syncMarkdownScrollToHTMLScrollDebounced",
          value: function MarkdownPreviewMorph_syncMarkdownScrollToHTMLScrollDebounced_(editor) {
            var _this4 = this;

            requestAnimationFrame(function () {
              return _this4.syncMarkdownScrollToHTMLScroll(editor);
            });
          }
        }, {
          key: "htmlScrollToMarkdownScrollConnections",
          value: function MarkdownPreviewMorph_htmlScrollToMarkdownScrollConnections_() {
            if (!this.attributeConnections) return [];
            return this.attributeConnections.filter(function (ea) {
              return ea.targetMethodName.startsWith("syncHTMLScrollToMarkdownScroll");
            });
          }
        }, {
          key: "markdownScrollToHTMLScrollConnections",
          value: function MarkdownPreviewMorph_markdownScrollToHTMLScrollConnections_() {
            var editor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.markdownEditor;
            if (!editor.attributeConnections) return [];
            return editor.attributeConnections.filter(function (ea) {
              return ea.targetMethodName.startsWith("syncMarkdownScrollToHTMLScroll");
            });
          }
        }, {
          key: "autoRenderConnections",
          value: function MarkdownPreviewMorph_autoRenderConnections_() {
            var editor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.markdownEditor;
            if (!editor.attributeConnections) return [];
            return editor.attributeConnections.filter(function (ea) {
              return ea.targetMethodName.startsWith("autoRender");
            });
          }
        }, {
          key: "connectHTMLScrollToMarkdownScroll",
          value: function MarkdownPreviewMorph_connectHTMLScrollToMarkdownScroll_() {
            var debounced = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            connect(this, "scroll", this, "syncHTMLScrollToMarkdownScroll" + (debounced ? "Debounced" : ""), {
              converter: function converter() {
                return undefined;
              }
            });
          }
        }, {
          key: "disconnectHTMLScrollToMarkdownScroll",
          value: function MarkdownPreviewMorph_disconnectHTMLScrollToMarkdownScroll_() {
            this.htmlScrollToMarkdownScrollConnections().forEach(function (ea) {
              return ea.disconnect();
            });
          }
        }, {
          key: "connectMarkdownScrollToHTMLScroll",
          value: function MarkdownPreviewMorph_connectMarkdownScrollToHTMLScroll_() {
            var debounced = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var editor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.markdownEditor;
            connect(editor, "scroll", this, "syncMarkdownScrollToHTMLScroll" + (debounced ? "Debounced" : ""), {
              converter: function converter() {
                return undefined;
              }
            });
          }
        }, {
          key: "disconnectMarkdownScrollToHTMLScroll",
          value: function MarkdownPreviewMorph_disconnectMarkdownScrollToHTMLScroll_() {
            var editor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.markdownEditor;
            this.markdownScrollToHTMLScrollConnections(editor).forEach(function (ea) {
              return ea.disconnect();
            });
          }
        }, {
          key: "enableAutoRender",
          value: function MarkdownPreviewMorph_enableAutoRender_() {
            var editor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.markdownEditor;
            connect(editor, "textChange", this, "autoRender", {
              converter: function converter() {
                return undefined;
              }
            });
          }
        }, {
          key: "disableAutoRender",
          value: function MarkdownPreviewMorph_disableAutoRender_() {
            var editor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.markdownEditor;
            this.autoRenderConnections(editor).forEach(function (ea) {
              return ea.disconnect();
            });
          }
        }, {
          key: "autoRender",
          value: function MarkdownPreviewMorph_autoRender_() {
            var _this5 = this;

            throttleNamed("autoRender" + this.id, 300, function () {
              return _this5.renderMarkdown();
            })();
          }
        }, {
          key: "renderMarkdown",
          value: function () {
            var _MarkdownPreviewMorph_renderMarkdown_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
              var _this6 = this;

              var editor,
                  ed,
                  markdownSource,
                  markdownOptions,
                  interactiveMorphs,
                  sections,
                  blocks,
                  exprSerializer,
                  expr,
                  exprObj,
                  html,
                  _this$submorphs$,
                  scrollBefore,
                  res,
                  _args2 = arguments;

              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      editor = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : this.markdownEditor;

                      if (!module$1("lively.ide/md/compiler.js")._frozenModule) {
                        _context2.next = 7;
                        break;
                      }

                      _context2.next = 4;
                      return module$1("lively.ide/md/compiler.js").revive();

                    case 4:
                      _context2.next = 6;
                      return this.renderMarkdown(editor);

                    case 6:
                      return _context2.abrupt("return", _context2.sent);

                    case 7:
                      this.markdownToHTMLPositionMap = null;
                      ed = this.markdownEditor;
                      markdownSource = this.markdownSource, markdownOptions = this.markdownOptions;
                      interactiveMorphs = _toConsumableArray$1(markdownSource.matchAll(/<!--.*__lv_expr__.*-->/g));
                      sections = markdownSource.split(/<!--.*__lv_expr__.*-->/);

                      if (!(ed && !interactiveMorphs.length > 0)) {
                        _context2.next = 21;
                        break;
                      }

                      this.layout = null;
                      this.env.forceUpdate(this);
                      this.submorphs = [];
                      this.env.forceUpdate(this);
                      this.html = ed.editorPlugin.renderedMarkdown(markdownOptions);
                      setTimeout(function () {
                        return HighlightJS.highlightAll();
                      });
                      _context2.next = 50;
                      break;

                    case 21:
                      blocks = [];
                      exprSerializer = new ExpressionSerializer();

                    case 23:
                      if (!(sections.length > 1 && interactiveMorphs.length > 0)) {
                        _context2.next = 31;
                        break;
                      }

                      expr = interactiveMorphs.shift()[0].match(/(__lv_expr__.*)-->/)[1];
                      exprObj = exprSerializer.exprStringDecode(expr);
                      _context2.next = 28;
                      return exprSerializer.ensureAllBindingsLoaded(exprObj);

                    case 28:
                      blocks.push(sections.shift(), exprSerializer.deserializeExprObj(exprObj));
                      _context2.next = 23;
                      break;

                    case 31:
                      blocks.push(sections.shift());

                      if (!(blocks.length < 2)) {
                        _context2.next = 42;
                        break;
                      }

                      html = mdCompiler.compileToHTML(markdownSource, markdownOptions);
                      this.html = html;
                      this._smoothScroll = null;
                      this.layout = null;
                      this.env.forceUpdate(this);
                      this.submorphs = [];
                      setTimeout(function () {
                        HighlightJS.highlightAll();
                      });
                      _context2.next = 50;
                      break;

                    case 42:
                      scrollBefore = (_this$submorphs$ = this.submorphs[0]) === null || _this$submorphs$ === void 0 ? void 0 : _this$submorphs$.scroll;
                      this.html = "";
                      this.layout = new TilingLayout({
                        axis: "column"
                      });
                      this.submorphs = [{
                        fill: Color.transparent,
                        clipMode: this.disableInternalScroll ? "visible" : "auto",
                        layout: new TilingLayout({
                          axis: "column",
                          padding: 15,
                          spacing: 15
                        }),
                        submorphs: blocks.map(function (elem, i) {
                          if (elem.isMorph) {
                            elem.name = "embedded " + i;
                            return elem;
                          } else return morph({
                            name: "markdown " + i,
                            type: "html",
                            fixedHeight: false,
                            html: mdCompiler.compileToHTML(elem, markdownOptions)
                          });
                        })
                      }];
                      this.layout.setResizePolicyFor(this.submorphs[0], {
                        width: "fill",
                        height: "fill"
                      });
                      res = deferred();
                      setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                        var wrapper, _iterator, _step, m;

                        return regeneratorRuntime.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                wrapper = _this6.submorphs[0];
                                _iterator = _createForOfIteratorHelper(wrapper.submorphs);

                                try {
                                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                    m = _step.value;
                                    wrapper.layout.setResizePolicyFor(m, {
                                      width: "fill",
                                      height: "fixed"
                                    });
                                  }
                                } catch (err) {
                                  _iterator.e(err);
                                } finally {
                                  _iterator.f();
                                }

                                HighlightJS.highlightAll();
                                if (scrollBefore) wrapper.scroll = scrollBefore;
                                res.resolve(_this6.html);

                              case 6:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      })));
                      return _context2.abrupt("return", res.promise);

                    case 50:
                      return _context2.abrupt("return", this.html);

                    case 51:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function MarkdownPreviewMorph_renderMarkdown_() {
              return _MarkdownPreviewMorph_renderMarkdown_.apply(this, arguments);
            }

            return MarkdownPreviewMorph_renderMarkdown_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "MarkdownPreviewMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              markdownEditor: {},
              disableInternalScroll: {
                defaultValue: false
              },
              markdownSource: {
                after: ["markdownEditor"],
                get: function get() {
                  var _this$markdownEditor;

                  return ((_this$markdownEditor = this.markdownEditor) === null || _this$markdownEditor === void 0 ? void 0 : _this$markdownEditor.textString) || this.getProperty("markdownSource");
                },
                set: function set(src) {
                  this.setProperty("markdownSource", src);
                  var ed = this.markdownEditor;
                  if (ed) this.markdownEditor.textString = src;
                }
              },
              markdownOptions: {
                after: ["markdownEditor"],
                get: function get() {
                  var ed = this.markdownEditor;
                  return ed && ed.editorPlugin.markdownOptions || this.getProperty("markdownOptions");
                },
                set: function set(options) {
                  var ed = this.markdownEditor;

                  if (ed) {
                    ed.editorPlugin.markdownOptions = options;
                    this.setProperty("markdownOptions", null);
                  } else {
                    this.setProperty("markdownOptions", options);
                  }
                }
              },
              markdownToHTMLPositionMap: {
                get: function get() {
                  var map = this.getProperty("markdownToHTMLPositionMap");
                  if (map) return map;
                  this.setProperty("markdownToHTMLPositionMap", map = this.computeMarkdownToHTMLPositionMap());
                  return map;
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./md/morphs.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 732,
          end: 14710
        });
      }({
        referencedAs: "HTMLMorph",
        value: HTMLMorph
      });
      __varRecorder__$q.MarkdownPreviewMorph = MarkdownPreviewMorph;
      __varRecorder__$q.MarkdownPreviewMorph = MarkdownPreviewMorph;
      var MarkdownEditor = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/md/morphs.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("MarkdownEditor") && typeof __lively_classholder__.MarkdownEditor === "function" ? __lively_classholder__.MarkdownEditor : __lively_classholder__.MarkdownEditor = function MarkdownEditor(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onFocus",
          value: function MarkdownEditor_onFocus_() {
            this.mdEditorMorph.focus();
          }
        }, {
          key: "reset",
          value: function MarkdownEditor_reset_() {
            connect(this.get("edit css button"), "fire", this, "editCSS");
            connect(this.get("link scroll checkbox"), "checked", this, "linkScroll");
            connect(this.get("render while typing checkbox"), "checked", this, "autoRender");
            connect(this.get("show preview checkbox"), "checked", this, "showPreview");
            this.showPreview = false;
            this.showPreview = true;
            this.mdPreviewMorph.show();
          }
        }, {
          key: "mdEditorMorph",
          get: function get() {
            return this.getSubmorphNamed("editor");
          }
        }, {
          key: "mdPreviewMorph",
          get: function get() {
            return this.getSubmorphNamed(/markdown preview .*/);
          }
        }, {
          key: "addPreview",
          value: function () {
            var _MarkdownEditor_addPreview_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
              var preview;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      if (!this.mdPreviewMorph) {
                        _context3.next = 2;
                        break;
                      }

                      return _context3.abrupt("return");

                    case 2:
                      _context3.next = 4;
                      return this.mdEditorMorph.execCommand("[markdown] convert to html", {
                        openInWorld: false
                      });

                    case 4:
                      preview = _context3.sent;
                      this.addMorph(preview);
                      preview.border = this.mdEditorMorph.border;
                      this.mdEditorMorph.setBounds(rect(this.get("show preview checkbox").bottomLeft.addXY(0, 5), this.innerBounds().bottomCenter().addXY(-2, -5)));
                      preview.setBounds(rect(this.mdEditorMorph.topRight.addXY(4, 0), this.innerBounds().bottomRight().addXY(-5, -5)));
                      this.autoRender = this.autoRender;
                      this.linkScroll = this.linkScroll;
                      preview.cssDeclaration = this.css || "";

                    case 12:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function MarkdownEditor_addPreview_() {
              return _MarkdownEditor_addPreview_.apply(this, arguments);
            }

            return MarkdownEditor_addPreview_;
          }()
        }, {
          key: "removePreview",
          value: function MarkdownEditor_removePreview_() {
            var p = this.mdPreviewMorph;
            p && p.remove();
            this.mdEditorMorph.setBounds(rect(this.get("show preview checkbox").bottomLeft.addXY(0, 5), this.innerBounds().bottomRight().addXY(-5, -5)));
          }
        }, {
          key: "editCSS",
          value: function () {
            var _MarkdownEditor_editCSS_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
              var result;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      _context4.next = 2;
                      return $world.editPrompt("edit css for markdown", {
                        requester: this,
                        input: this.css || "",
                        historyId: "markdowneditor-css-history",
                        mode: "css"
                      });

                    case 2:
                      result = _context4.sent;

                      if (!(result === undefined)) {
                        _context4.next = 5;
                        break;
                      }

                      return _context4.abrupt("return");

                    case 5:
                      this.css = result;

                    case 6:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function MarkdownEditor_editCSS_() {
              return _MarkdownEditor_editCSS_.apply(this, arguments);
            }

            return MarkdownEditor_editCSS_;
          }()
        }, {
          key: "keybindings",
          get: function get() {
            return [{
              keys: {
                mac: "Meta-S",
                win: "Control-S"
              },
              command: "save"
            }];
          }
        }, {
          key: "commands",
          get: function get() {
            var _this7 = this;

            return [{
              name: "save",
              exec: function exec() {
                var p = _this7.mdPreviewMorph;
                p && p.renderMarkdown();
                return true;
              }
            }];
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "MarkdownEditor";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              showPreview: {
                derived: true,
                set: function set(val) {
                  this.get("show preview checkbox").checked = val;
                  if (!val) this.removePreview();else this.addPreview();
                },
                get: function get() {
                  return !!this.mdPreviewMorph;
                }
              },
              linkScroll: {
                after: ["showPreview"],
                derived: true,
                set: function set(val) {
                  this.get("link scroll checkbox").checked = val;
                  var p = this.mdPreviewMorph;
                  if (!p) return;

                  if (val) {
                    p.connectHTMLScrollToMarkdownScroll();
                    p.connectMarkdownScrollToHTMLScroll();
                  } else {
                    p.disconnectHTMLScrollToMarkdownScroll();
                    p.disconnectMarkdownScrollToHTMLScroll();
                  }
                },
                get: function get() {
                  return this.get("link scroll checkbox").checked;
                }
              },
              autoRender: {
                after: ["showPreview"],
                derived: true,
                set: function set(val) {
                  this.get("render while typing checkbox").checked = val;
                  var p = this.mdPreviewMorph;
                  if (!p) return;
                  if (val) p.enableAutoRender();else p.disableAutoRender();
                },
                get: function get() {
                  return this.get("render while typing checkbox").checked;
                }
              },
              css: {
                after: ["showPreview"],
                set: function set(val) {
                  this.setProperty("css", val);
                  var p = this.mdPreviewMorph;
                  if (p) p.cssDeclaration = val;
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./md/morphs.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 14719,
          end: 18397
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$q.MarkdownEditor = MarkdownEditor;
      __varRecorder__$q.MarkdownEditor = MarkdownEditor;

      var __varRecorder__$p = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/md/editor-plugin.js", __contextModule__);
      __varRecorder__$p.commands = [{
        name: "[markdown] convert to html",
        exec: function () {
          var _exec = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(mdText) {
            var options,
                preview,
                world,
                previewName,
                _args2 = arguments;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
                    options = Object.assign({
                      extent: pt(500, 800),
                      openInWorld: {
                        title: "markdown rendering"
                      },
                      markdownPreviewMorphName: null,
                      markdownPreviewMorph: null
                    }, options);
                    preview = options.markdownPreviewMorph || mdText._mdPreviewMorph;
                    world = mdText.world() || preview && preview.world();
                    previewName = options.markdownPreviewMorphName || "markdown preview for \"".concat(mdText.name, "\"");

                    if (!preview && world) {
                      preview = mdText._mdPreviewMorph = world.get(previewName);
                    }

                    if (!preview) {
                      preview = mdText._mdPreviewMorph = new MarkdownPreviewMorph({
                        name: previewName,
                        markdownEditor: mdText,
                        extent: options.extent,
                        clipMode: "auto"
                      });
                    }

                    if (options.openInWorld && !preview.world()) {
                      preview.openInWindow(options.openInWorld).activate();
                    }

                    if (preview.getWindow() && preview.world()) {
                      $world.addMorph(preview.getWindow()).activate();
                      $world.withRequesterDo(preview.getWindow(), /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                        return regeneratorRuntime.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                _context.next = 2;
                                return $world.withLoadingIndicatorDo(function () {
                                  return preview.renderMarkdown();
                                }, preview.getWindow(), "rendering markdown");

                              case 2:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      })));
                    }

                    return _context2.abrupt("return", preview);

                  case 10:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function exec(_x) {
            return _exec.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "[markdown] scroll to cursor position in preview",
        exec: function () {
          var _exec2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(mdText) {
            var p,
                nav,
                _p$parsedMarkdown,
                headings,
                heading,
                range,
                srcInRange,
                html,
                preview;

            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    p = mdText.editorPlugin;
                    nav = p.getNavigator();
                    _p$parsedMarkdown = p.parsedMarkdown(), headings = _p$parsedMarkdown.headings;
                    heading = nav.headingOfLine(headings, mdText.cursorPosition.row);
                    range = nav.rangeOfHeading(mdText.textString, headings, heading);
                    srcInRange = mdText.textInRange(range.range);
                    html = mdCompiler.compileToHTML(srcInRange, Object.assign({}, p.markdownOptions, {
                      markdownWrapperTemplate: null
                    }));
                    preview = mdText._mdPreviewMorph;
                    preview.html.indexOf(html);

                  case 10:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));

          function exec(_x2) {
            return _exec2.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "[markdown] goto heading",
        exec: function () {
          var _exec3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(mdText) {
            var opts,
                row,
                _mdText$editorPlugin$,
                headings,
                nextHeadingI,
                items,
                choice,
                _varRecorder__$__int,
                _varRecorder__$__int2,
                _args4 = arguments;

            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    opts = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
                    row = mdText.cursorPosition.row;
                    _mdText$editorPlugin$ = mdText.editorPlugin.parsedMarkdown(), headings = _mdText$editorPlugin$.headings;

                    if (headings.length) {
                      _context4.next = 5;
                      break;
                    }

                    return _context4.abrupt("return", true);

                  case 5:
                    nextHeadingI = row >= last$2(headings).line ? headings.length : headings.findIndex(function (ea) {
                      return ea.line > row;
                    });
                    if (nextHeadingI === -1) nextHeadingI = 0;
                    items = headings.map(function (ea) {
                      return {
                        isListItem: true,
                        string: ea.line + ":" + indent(ea.string, " ", ea.depth),
                        value: ea
                      };
                    });
                    choice = opts.choice;

                    if (choice) {
                      _context4.next = 15;
                      break;
                    }

                    _context4.next = 12;
                    return mdText.world().filterableListPrompt("jump to heading", items, {
                      requester: mdText,
                      preselect: nextHeadingI - 1,
                      multiSelect: false
                    });

                  case 12:
                    __varRecorder__$p.__inter0__ = _context4.sent;
                    _varRecorder__$__int = __varRecorder__$p.__inter0__.selected, _varRecorder__$__int2 = _slicedToArray(_varRecorder__$__int, 1), choice = _varRecorder__$__int2[0];
                    __varRecorder__$p.__inter0__;

                  case 15:
                    if (choice) {
                      mdText.saveMark();
                      mdText.cursorPosition = {
                        row: choice.line,
                        column: 0
                      };
                      mdText.flash(mdText.lineRange(choice.line), {
                        id: "md heading",
                        time: 1000,
                        fill: Color.rgb(200, 235, 255)
                      });
                    }

                    return _context4.abrupt("return", true);

                  case 17:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));

          function exec(_x3) {
            return _exec3.apply(this, arguments);
          }

          return exec;
        }()
      }];
      __varRecorder__$p.defaultMarkdownOptions = {
        html: true,
        linkify: true,
        typographer: true,
        linkedCSS: {
          "github-markdown": "/lively.ide/md/github-markdown.css"
        },
        markdownWrapperTemplate: "<div class=\"markdown-body\" style=\"margin: 5px\">\n%s\n</div>",
        addSourceLineMapping: true,
        externalizeLinks: {}
      };
      var defaultMarkdownOptions = __varRecorder__$p.defaultMarkdownOptions;
      __varRecorder__$p.defaultMarkdownOptions = defaultMarkdownOptions;

      var MarkdownEditorPlugin = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/md/editor-plugin.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("MarkdownEditorPlugin") && typeof __lively_classholder__.MarkdownEditorPlugin === "function" ? __lively_classholder__.MarkdownEditorPlugin : __lively_classholder__.MarkdownEditorPlugin = function MarkdownEditorPlugin(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function MarkdownEditorPlugin_initialize_() {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this);
            this._markdownOptions = Object.assign({}, __varRecorder__$p.defaultMarkdownOptions);
            this._html = "";
            return _this;
          }
        }, {
          key: "markdownOptions",
          get: function get() {
            return this._markdownOptions;
          }
        }, {
          key: "markdownOptions",
          set: function set(options) {
            this._ast = null;
            return this._markdownOptions = options;
          }
        }, {
          key: "isMarkdownEditorPlugin",
          get: function get() {
            return true;
          }
        }, {
          key: "shortName",
          get: function get() {
            return "md";
          }
        }, {
          key: "longName",
          get: function get() {
            return "markdown";
          }
        }, {
          key: "openPairs",
          get: function get() {
            return {
              "{": "}",
              "[": "]",
              "(": ")",
              "\"": "\"",
              "'": "'",
              "`": "`"
            };
          }
        }, {
          key: "closePairs",
          get: function get() {
            return {
              "}": "{",
              "]": "[",
              ")": "(",
              "\"": "\"",
              "'": "'",
              "`": "`"
            };
          }
        }, {
          key: "getNavigator",
          value: function MarkdownEditorPlugin_getNavigator_() {
            return new MarkdownNavigator();
          }
        }, {
          key: "getCommands",
          value: function MarkdownEditorPlugin_getCommands_(otherCommands) {
            return [].concat(_toConsumableArray$1(initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "getCommands", this).call(this, otherCommands)), _toConsumableArray$1(otherCommands.concat(__varRecorder__$p.commands)));
          }
        }, {
          key: "getKeyBindings",
          value: function MarkdownEditorPlugin_getKeyBindings_(other) {
            return other.concat([{
              keys: "Alt-G",
              command: "[markdown] convert to html"
            }, {
              keys: "Alt-J",
              command: "[markdown] goto heading"
            }]);
          }
        }, {
          key: "getMenuItems",
          value: function () {
            var _MarkdownEditorPlugin_getMenuItems_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(items) {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      return _context5.abrupt("return", [{
                        command: "[markdown] convert to html",
                        alias: "convert to html",
                        target: this.textMorph
                      }, {
                        command: "[markdown] goto heading",
                        alias: "goto heading",
                        target: this.textMorph
                      }, {
                        isDivider: true
                      }].concat(items));

                    case 1:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function MarkdownEditorPlugin_getMenuItems_(_x4) {
              return _MarkdownEditorPlugin_getMenuItems_.apply(this, arguments);
            }

            return MarkdownEditorPlugin_getMenuItems_;
          }()
        }, {
          key: "getSnippets",
          value: function MarkdownEditorPlugin_getSnippets_() {
            return snippets.map(function (_ref2) {
              var _ref3 = _slicedToArray(_ref2, 2),
                  trigger = _ref3[0],
                  expansion = _ref3[1];

              return new Snippet({
                trigger: trigger,
                expansion: expansion
              });
            });
          }
        }, {
          key: "onTextChange",
          value: function MarkdownEditorPlugin_onTextChange_(change) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onTextChange", this).call(this, change);

            this._html = "";
          }
        }, {
          key: "highlight",
          value: function MarkdownEditorPlugin_highlight_() {
            var textMorph = this.textMorph,
                theme = this.theme,
                mode = this.mode,
                _tokenizerValidBefore = this._tokenizerValidBefore;
            if (!theme || !textMorph || !textMorph.document || !mode) return;
            textMorph.fill = theme.background;
            var _textMorph$renderingS = textMorph.renderingState,
                firstVisibleRow = _textMorph$renderingS.firstVisibleRow,
                lastVisibleRow = _textMorph$renderingS.lastVisibleRow;

            var _tokenizeDocument = tokenizeDocument(mode, textMorph.document, firstVisibleRow, lastVisibleRow, _tokenizerValidBefore),
                lines = _tokenizeDocument.lines,
                tokens = _tokenizeDocument.tokens;

            if (lines.length) {
              var row = lines[0].row;
              var attributes = [];

              for (var i = 0; i < tokens.length; row++, i++) {
                var lineTokens = tokens[i];

                for (var _i = 0; _i < lineTokens.length; _i = _i + 5) {
                  var _tokens2;

                  var startColumn = lineTokens[_i];
                  var endColumn = lineTokens[_i + 1];
                  var _tokens = lineTokens[_i + 2];
                  _tokens = ((_tokens2 = _tokens) === null || _tokens2 === void 0 ? void 0 : _tokens2.split) ? _tokens : "";
                  _tokens = _tokens.split(" ");
                  var style = void 0;

                  for (var _i2 = 0; _i2 < _tokens.length; _i2++) {
                    var token = _tokens[_i2];
                    if (token) style = Object.assign({}, style, theme[token]);
                  }

                  if (!style) style = theme["default"];
                  style && attributes.push({
                    start: {
                      row: row,
                      column: startColumn
                    },
                    end: {
                      row: row,
                      column: endColumn
                    }
                  }, style);
                }
              }

              textMorph.setTextAttributesWithSortedRanges(attributes);
              this._tokenizerValidBefore = {
                row: last$2(lines).row + 1,
                column: 0
              };
            }

            if (this.checker) {
              this.checker.onDocumentChange({}, textMorph, this);
            }
          }
        }, {
          key: "parsedMarkdown",
          value: function MarkdownEditorPlugin_parsedMarkdown_() {
            return this._ast || (this._ast = this.parse());
          }
        }, {
          key: "renderedMarkdown",
          value: function MarkdownEditorPlugin_renderedMarkdown_() {
            return this._html || (this._html = this.render());
          }
        }, {
          key: "parse",
          value: function MarkdownEditorPlugin_parse_(opts) {
            opts = opts ? Object.assign({}, this._markdownOptions, {}, opts) : this._markdownOptions;
            return mdCompiler.parse(this.textMorph, opts);
          }
        }, {
          key: "render",
          value: function MarkdownEditorPlugin_render_(opts) {
            opts = opts ? Object.assign({}, this._markdownOptions, {}, opts) : this._markdownOptions;

            if (opts.linkedCSS) {
              for (var id in opts.linkedCSS) {
                addOrChangeLinkedCSS(id, opts.linkedCSS[id]);
              }
            }

            var markdownSource = this.textMorph.textString;
            return mdCompiler.compileToHTML(markdownSource, opts);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "MarkdownEditorPlugin";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./md/editor-plugin.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 4075,
          end: 7936
        });
      }({
        referencedAs: "CodeMirrorEnabledEditorPlugin",
        value: CodeMirrorEnabledEditorPlugin
      });
      __varRecorder__$p["default"] = MarkdownEditorPlugin;

      var __varRecorder__$o = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/css/editor-plugin.js", __contextModule__);

      var CSSEditorPlugin = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/css/editor-plugin.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("CSSEditorPlugin") && typeof __lively_classholder__.CSSEditorPlugin === "function" ? __lively_classholder__.CSSEditorPlugin : __lively_classholder__.CSSEditorPlugin = function CSSEditorPlugin(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "shortName",
          get: function get() {
            return "css";
          }
        }, {
          key: "isCSSEditorPlugin",
          get: function get() {
            return true;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "CSSEditorPlugin";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./css/editor-plugin.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 151,
          end: 296
        });
      }({
        referencedAs: "CodeMirrorEnabledEditorPlugin",
        value: CodeMirrorEnabledEditorPlugin
      });
      __varRecorder__$o["default"] = CSSEditorPlugin;

      var __varRecorder__$n = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/html/navigator.js", __contextModule__);
      var __moduleMeta__$b = {
        pathInPackage: function pathInPackage() {
          return "./html/navigator.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var nodesAt = __varRecorder__$n["lively.ide/html/navigator.js__define__"]("nodesAt", "function", function (index, node) {
        var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        if (!node) return result;
        var l = node.__location;

        if (l) {
          if (index < l.startOffset || l.endOffset < index) return result;
          result.push(node);

          if (l.attrs) {
            var attrName = Object.keys(l.attrs).find(function (name) {
              var _l$attrs$name = l.attrs[name],
                  startOffset = _l$attrs$name.startOffset,
                  endOffset = _l$attrs$name.endOffset;
              return startOffset <= index && index <= endOffset;
            });

            if (attrName) {
              var attr = node.attrs.find(function (ea) {
                return ea.name === attrName;
              });
              attr.__location = l.attrs[attrName];
              result.push(attr);
            }
          }
        }

        if (node.childNodes) node.childNodes.forEach(function (childNode) {
          return nodesAt(index, childNode, result);
        });
        return result;
      }, __moduleMeta__$b);

      __varRecorder__$n.nodesAt = nodesAt;

      var expandOnToken = __varRecorder__$n["lively.ide/html/navigator.js__define__"]("expandOnToken", "function", function (ed, t, prevExpandState) {
        return {
          range: [__varRecorder__$n.posToIdx(ed, t.start), __varRecorder__$n.posToIdx(ed, t.end)],
          prev: prevExpandState
        };
      }, __moduleMeta__$b);

      __varRecorder__$n.expandOnToken = expandOnToken;

      var tokenPosition = __varRecorder__$n["lively.ide/html/navigator.js__define__"]("tokenPosition", "function", function (ed, row, token) {
        var offset = __varRecorder__$n.posToIdx(ed, {
          column: 0,
          row: row
        });

        return {
          tokenStart: offset + token.start,
          tokenEnd: offset + token.start + token.value.length
        };
      }, __moduleMeta__$b);

      __varRecorder__$n.tokenPosition = tokenPosition;

      var posToIdx = __varRecorder__$n["lively.ide/html/navigator.js__define__"]("posToIdx", "function", function (ed, pos) {
        return ed.positionToIndex(pos);
      }, __moduleMeta__$b);

      __varRecorder__$n.posToIdx = posToIdx;

      var idxToPos = __varRecorder__$n["lively.ide/html/navigator.js__define__"]("idxToPos", "function", function (ed, idx) {
        return ed.indexToPosition(idx);
      }, __moduleMeta__$b);

      __varRecorder__$n.idxToPos = idxToPos;

      var HTMLNavigator = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/html/navigator.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("HTMLNavigator") && typeof __lively_classholder__.HTMLNavigator === "function" ? __lively_classholder__.HTMLNavigator : __lively_classholder__.HTMLNavigator = function HTMLNavigator(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "ensureAST",
          value: function HTMLNavigator_ensureAST_(ed) {
            return ed.editorPlugin.parse();
          }
        }, {
          key: "rangesForStartAndEndTag",
          value: function HTMLNavigator_rangesForStartAndEndTag_(ed, pos, ast) {
            var index = __varRecorder__$n.posToIdx(ed, ed.cursorPosition),
                node = last$2(__varRecorder__$n.nodesAt(index, ast));

            if (!node) return null;
            var _node$__location = node.__location,
                startTag = _node$__location.startTag,
                endTag = _node$__location.endTag;
            if (!startTag) return null;
            return {
              startTag: {
                start: __varRecorder__$n.idxToPos(ed, startTag.startOffset),
                end: __varRecorder__$n.idxToPos(ed, startTag.endOffset)
              },
              endTag: endTag ? {
                start: __varRecorder__$n.idxToPos(ed, endTag.startOffset),
                end: __varRecorder__$n.idxToPos(ed, endTag.endOffset)
              } : null
            };
          }
        }, {
          key: "move",
          value: function HTMLNavigator_move_(selector, ed) {
            var select = !!ed.activeMark || !ed.selection.isEmpty(),
                sel = ed.selection,
                pos = sel.lead,
                idx = ed.positionToIndex(pos),
                newIdx = this[selector](ed, idx),
                newPos = ed.indexToPosition(newIdx);
                sel.isBackwards;
            if (!newPos) return;
            sel.lead = newPos;
            if (!select) sel.anchor = newPos;
            ed.scrollCursorIntoView();
          }
        }, {
          key: "forwardSexp",
          value: function HTMLNavigator_forwardSexp_(ed) {
            this.move("_forwardSexp", ed);
          }
        }, {
          key: "backwardSexp",
          value: function HTMLNavigator_backwardSexp_(ed) {
            this.move("_backwardSexp", ed);
          }
        }, {
          key: "backwardUpSexp",
          value: function HTMLNavigator_backwardUpSexp_(ed) {
            this.move("_backwardUpSexp", ed);
          }
        }, {
          key: "forwardDownSexp",
          value: function HTMLNavigator_forwardDownSexp_(ed) {
            this.move("_forwardDownSexp", ed);
          }
        }, {
          key: "_forwardSexp",
          value: function HTMLNavigator__forwardSexp_(ed, fromIndex) {
            var ast = ed.editorPlugin.parse(),
                node = last$2(__varRecorder__$n.nodesAt(fromIndex, ast));
            return node && node.__location.endOffset || fromIndex;
          }
        }, {
          key: "_backwardSexp",
          value: function HTMLNavigator__backwardSexp_(ed, fromIndex) {
            var ast = ed.editorPlugin.parse(),
                node = last$2(__varRecorder__$n.nodesAt(fromIndex, ast));
            if (!node) return fromIndex;
            if (node.__location.startOffset === fromIndex) node = last$2(__varRecorder__$n.nodesAt(fromIndex - 1, ast));
            return node && node.__location.startOffset || fromIndex;
          }
        }, {
          key: "_forwardDownSexp",
          value: function HTMLNavigator__forwardDownSexp_(ed, fromIndex) {
            var ast = ed.editorPlugin.parse(),
                node = last$2(__varRecorder__$n.nodesAt(fromIndex, ast));
            return node && node.childNodes && node.childNodes[0] && node.childNodes[0].__location && node.childNodes[0].__location.startOffset || fromIndex;
          }
        }, {
          key: "_backwardUpSexp",
          value: function HTMLNavigator__backwardUpSexp_(ed, fromIndex) {
            var ast = ed.editorPlugin.parse(),
                node = last$2(__varRecorder__$n.nodesAt(fromIndex, ast).slice(0, -1));
            return node && node.__location.startOffset || fromIndex;
          }
        }, {
          key: "expandRegion",
          value: function HTMLNavigator_expandRegion_(ed, src, ast, expandState) {
            var _expandState$range = _slicedToArray(expandState.range, 2),
                from = _expandState$range[0],
                to = _expandState$range[1],
                hasSelection = from !== to,
                p = ed.indexToPosition(from),
                token = ed.tokenAt(p);

            if (!hasSelection && token && token.start.column + 1 < token.end.column) return __varRecorder__$n.expandOnToken(ed, token, expandState);
            var containingNode = hasSelection ? lively.lang.arr.intersect(__varRecorder__$n.nodesAt(from, ast), __varRecorder__$n.nodesAt(to, ast)).reverse().find(function (ea) {
              var l = ea.__location;
              return l && l.startOffset < from || l.endOffset > to;
            }) : last$2(__varRecorder__$n.nodesAt(from, ast));
            if (!containingNode) return expandState;
            var _containingNode$__loc = containingNode.__location,
                startOffset = _containingNode$__loc.startOffset,
                endOffset = _containingNode$__loc.endOffset;
            return {
              range: [startOffset, endOffset],
              prev: expandState
            };
          }
        }, {
          key: "contractRegion",
          value: function HTMLNavigator_contractRegion_(ed, src, ast, expandState) {
            return expandState.prev || expandState;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "HTMLNavigator";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./html/navigator.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 1280,
          end: 4637
        });
      }(undefined);
      __varRecorder__$n["default"] = HTMLNavigator;

      var __varRecorder__$m = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/html/checker.js", __contextModule__);
      __varRecorder__$m.warnStyle = {
        "border-bottom": "2px dotted orange"
      };
      __varRecorder__$m.errorStyle = {
        "background-color": "red"
      };

      var HTMLChecker = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/html/checker.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("HTMLChecker") && typeof __lively_classholder__.HTMLChecker === "function" ? __lively_classholder__.HTMLChecker : __lively_classholder__.HTMLChecker = function HTMLChecker(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onDocumentChange",
          value: function HTMLChecker_onDocumentChange_(change, morph, htmlPlugin) {
            var parsed;
            morph.document;

            try {
              parsed = htmlPlugin.parse();
            } catch (e) {
              parsed = e;
            }
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "HTMLChecker";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./html/checker.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 122,
          end: 1487
        });
      }(undefined);
      __varRecorder__$m["default"] = HTMLChecker;

      var htmlDecodeTree = new Uint16Array("\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\uD835\uDD04rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\uD835\uDD38plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\uD835\uDC9Cign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\uD835\uDD05pf;\uC000\uD835\uDD39eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\uD835\uDC9Ep\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\uD835\uDD07\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\uD835\uDD3B\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\uD835\uDC9Frok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\uD835\uDD08rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\uD835\uDD3Csilon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\uD835\uDD09lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\uD835\uDD3DAll;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\uD835\uDD0A;\u62D9pf;\uC000\uD835\uDD3Eeater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\uD835\uDCA2;\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\uD835\uDD40a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\uD835\uDD0Dpf;\uC000\uD835\uDD41\u01E3\u07C7\0\u07CCr;\uC000\uD835\uDCA5rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\uD835\uDD0Epf;\uC000\uD835\uDD42cr;\uC000\uD835\uDCA6\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\uD835\uDD0F\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\uD835\uDD43er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\uD835\uDD10nusPlus;\u6213pf;\uC000\uD835\uDD44c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\uD835\uDD11\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\uD835\uDCA9ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\uD835\uDD12rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\uD835\uDD46enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\uD835\uDCAAash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\uD835\uDD13i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\uD835\uDCAB;\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B\"\u4022r;\uC000\uD835\uDD14pf;\u611Acr;\uC000\uD835\uDCAC\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\uD835\uDD16ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\uD835\uDD4A\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\uD835\uDCAEar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\uD835\uDD17\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\uD835\uDD4BipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\uD835\uDCAFrok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\uD835\uDD18rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\uD835\uDD4C\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\uD835\uDCB0ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\uD835\uDD19pf;\uC000\uD835\uDD4Dcr;\uC000\uD835\uDCB1dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\uD835\uDD1Apf;\uC000\uD835\uDD4Ecr;\uC000\uD835\uDCB2\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\uD835\uDD1B;\u439Epf;\uC000\uD835\uDD4Fcr;\uC000\uD835\uDCB3\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\uD835\uDD1Cpf;\uC000\uD835\uDD50cr;\uC000\uD835\uDCB4ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\uD835\uDCB5\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\uD835\uDD1Erave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\uD835\uDD52\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\uD835\uDCB6;\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\uD835\uDD1Fg\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\uD835\uDD53\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\uD835\uDCB7mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\uD835\uDD20\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\uD835\uDD54o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\uD835\uDCB8\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\uD835\uDD21ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\uD835\uDD55\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\uD835\uDCB9;\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\uD835\uDD22\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\uD835\uDD56\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\uD835\uDD23lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\uD835\uDD57\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\uD835\uDCBB\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\uD835\uDD24\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\uD835\uDD58\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\uD835\uDD25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\uD835\uDD59bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\uD835\uDCBDas\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\uD835\uDD26rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\uD835\uDD5Aa;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\uD835\uDCBEn\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\uD835\uDD27ath;\u4237pf;\uC000\uD835\uDD5B\u01E3\u23EC\0\u23F1r;\uC000\uD835\uDCBFrcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\uD835\uDD28reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\uD835\uDD5Ccr;\uC000\uD835\uDCC0\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\uD835\uDD29\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\uD835\uDD5Dus;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\uD835\uDCC1m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\uD835\uDD2Ao;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\uD835\uDD5E\u0100ct\u28F8\u28FDr;\uC000\uD835\uDCC2pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\uD835\uDD2B\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\uD835\uDD5F\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\uD835\uDCC3ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\uD835\uDD2C\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\uD835\uDD60\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\uD835\uDD2D\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\uD835\uDD61nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\uD835\uDCC5;\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\uD835\uDD2Epf;\uC000\uD835\uDD62rime;\u6057cr;\uC000\uD835\uDCC6\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\uD835\uDD2F\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\uD835\uDD63us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\uD835\uDCC7\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\uD835\uDD30\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\uD835\uDD64a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\uD835\uDCC8tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\uD835\uDD31\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\uD835\uDD65rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\uD835\uDCC9;\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\uD835\uDD32rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\uD835\uDD66\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\uD835\uDCCA\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\uD835\uDD33tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\uD835\uDD67ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\uD835\uDCCB\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\uD835\uDD34pf;\uC000\uD835\uDD68\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\uD835\uDCCC\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\uD835\uDD35\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\uD835\uDD69im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\uD835\uDCCD\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\uD835\uDD36cy;\u4457pf;\uC000\uD835\uDD6Acr;\uC000\uD835\uDCCE\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\uD835\uDD37cy;\u4436grarr;\u61DDpf;\uC000\uD835\uDD6Bcr;\uC000\uD835\uDCCF\u0100jn\u3B85\u3B87;\u600Dj;\u600C".split("").map(function (c) {
        return c.charCodeAt(0);
      }));
      var xmlDecodeTree = new Uint16Array("aglq\t\x15\x18\x1B\x0F\0\0\x12p;os;t;t;uot;".split("").map(function (c) {
        return c.charCodeAt(0);
      }));

      var _a;

      var decodeMap = new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]);
      var fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
        var output = "";

        if (codePoint > 65535) {
          codePoint -= 65536;
          output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }

        output += String.fromCharCode(codePoint);
        return output;
      };

      function replaceCodePoint(codePoint) {
        var _a;

        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          return 65533;
        }

        return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
      }

      var CharCodes;

      (function (CharCodes) {
        CharCodes[CharCodes["NUM"] = 35] = "NUM";
        CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
        CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
        CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
        CharCodes[CharCodes["NINE"] = 57] = "NINE";
        CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
        CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
        CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
        CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
        CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
        CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
        CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
      })(CharCodes || (CharCodes = {}));

      var TO_LOWER_BIT = 32;
      var BinTrieFlags;

      (function (BinTrieFlags) {
        BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
        BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
        BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
      })(BinTrieFlags || (BinTrieFlags = {}));

      function isNumber(code) {
        return code >= CharCodes.ZERO && code <= CharCodes.NINE;
      }

      function isHexadecimalCharacter(code) {
        return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
      }

      function isAsciiAlphaNumeric$1(code) {
        return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
      }

      function isEntityInAttributeInvalidEnd$1(code) {
        return code === CharCodes.EQUALS || isAsciiAlphaNumeric$1(code);
      }

      var EntityDecoderState;

      (function (EntityDecoderState) {
        EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
        EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
        EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
        EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
        EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
      })(EntityDecoderState || (EntityDecoderState = {}));

      var DecodingMode;

      (function (DecodingMode) {
        DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
        DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
        DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
      })(DecodingMode || (DecodingMode = {}));

      var EntityDecoder = /*#__PURE__*/function () {
        function EntityDecoder(decodeTree, emitCodePoint, errors) {
          _classCallCheck(this, EntityDecoder);

          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }

        _createClass(EntityDecoder, [{
          key: "startEntity",
          value: function startEntity(decodeMode) {
            this.decodeMode = decodeMode;
            this.state = EntityDecoderState.EntityStart;
            this.result = 0;
            this.treeIndex = 0;
            this.excess = 1;
            this.consumed = 1;
          }
        }, {
          key: "write",
          value: function write(str, offset) {
            switch (this.state) {
              case EntityDecoderState.EntityStart:
                {
                  if (str.charCodeAt(offset) === CharCodes.NUM) {
                    this.state = EntityDecoderState.NumericStart;
                    this.consumed += 1;
                    return this.stateNumericStart(str, offset + 1);
                  }

                  this.state = EntityDecoderState.NamedEntity;
                  return this.stateNamedEntity(str, offset);
                }

              case EntityDecoderState.NumericStart:
                {
                  return this.stateNumericStart(str, offset);
                }

              case EntityDecoderState.NumericDecimal:
                {
                  return this.stateNumericDecimal(str, offset);
                }

              case EntityDecoderState.NumericHex:
                {
                  return this.stateNumericHex(str, offset);
                }

              case EntityDecoderState.NamedEntity:
                {
                  return this.stateNamedEntity(str, offset);
                }
            }
          }
        }, {
          key: "stateNumericStart",
          value: function stateNumericStart(str, offset) {
            if (offset >= str.length) {
              return -1;
            }

            if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
              this.state = EntityDecoderState.NumericHex;
              this.consumed += 1;
              return this.stateNumericHex(str, offset + 1);
            }

            this.state = EntityDecoderState.NumericDecimal;
            return this.stateNumericDecimal(str, offset);
          }
        }, {
          key: "addToNumericResult",
          value: function addToNumericResult(str, start, end, base) {
            if (start !== end) {
              var digitCount = end - start;
              this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
              this.consumed += digitCount;
            }
          }
        }, {
          key: "stateNumericHex",
          value: function stateNumericHex(str, offset) {
            var startIdx = offset;

            while (offset < str.length) {
              var _char = str.charCodeAt(offset);

              if (isNumber(_char) || isHexadecimalCharacter(_char)) {
                offset += 1;
              } else {
                this.addToNumericResult(str, startIdx, offset, 16);
                return this.emitNumericEntity(_char, 3);
              }
            }

            this.addToNumericResult(str, startIdx, offset, 16);
            return -1;
          }
        }, {
          key: "stateNumericDecimal",
          value: function stateNumericDecimal(str, offset) {
            var startIdx = offset;

            while (offset < str.length) {
              var _char2 = str.charCodeAt(offset);

              if (isNumber(_char2)) {
                offset += 1;
              } else {
                this.addToNumericResult(str, startIdx, offset, 10);
                return this.emitNumericEntity(_char2, 2);
              }
            }

            this.addToNumericResult(str, startIdx, offset, 10);
            return -1;
          }
        }, {
          key: "emitNumericEntity",
          value: function emitNumericEntity(lastCp, expectedLength) {
            var _a;

            if (this.consumed <= expectedLength) {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }

            if (lastCp === CharCodes.SEMI) {
              this.consumed += 1;
            } else if (this.decodeMode === DecodingMode.Strict) {
              return 0;
            }

            this.emitCodePoint(replaceCodePoint(this.result), this.consumed);

            if (this.errors) {
              if (lastCp !== CharCodes.SEMI) {
                this.errors.missingSemicolonAfterCharacterReference();
              }

              this.errors.validateNumericCharacterReference(this.result);
            }

            return this.consumed;
          }
        }, {
          key: "stateNamedEntity",
          value: function stateNamedEntity(str, offset) {
            var decodeTree = this.decodeTree;
            var current = decodeTree[this.treeIndex];
            var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;

            for (; offset < str.length; offset++, this.excess++) {
              var _char3 = str.charCodeAt(offset);

              this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), _char3);

              if (this.treeIndex < 0) {
                return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd$1(_char3)) ? 0 : this.emitNotTerminatedNamedEntity();
              }

              current = decodeTree[this.treeIndex];
              valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;

              if (valueLength !== 0) {
                if (_char3 === CharCodes.SEMI) {
                  return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
                }

                if (this.decodeMode !== DecodingMode.Strict) {
                  this.result = this.treeIndex;
                  this.consumed += this.excess;
                  this.excess = 0;
                }
              }
            }

            return -1;
          }
        }, {
          key: "emitNotTerminatedNamedEntity",
          value: function emitNotTerminatedNamedEntity() {
            var _a;

            var result = this.result,
                decodeTree = this.decodeTree;
            var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
            this.emitNamedEntityData(result, valueLength, this.consumed);
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
            return this.consumed;
          }
        }, {
          key: "emitNamedEntityData",
          value: function emitNamedEntityData(result, valueLength, consumed) {
            var decodeTree = this.decodeTree;
            this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);

            if (valueLength === 3) {
              this.emitCodePoint(decodeTree[result + 2], consumed);
            }

            return consumed;
          }
        }, {
          key: "end",
          value: function end() {
            var _a;

            switch (this.state) {
              case EntityDecoderState.NamedEntity:
                {
                  return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
                }

              case EntityDecoderState.NumericDecimal:
                {
                  return this.emitNumericEntity(0, 2);
                }

              case EntityDecoderState.NumericHex:
                {
                  return this.emitNumericEntity(0, 3);
                }

              case EntityDecoderState.NumericStart:
                {
                  (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                  return 0;
                }

              case EntityDecoderState.EntityStart:
                {
                  return 0;
                }
            }
          }
        }]);

        return EntityDecoder;
      }();

      function getDecoder(decodeTree) {
        var ret = "";
        var decoder = new EntityDecoder(decodeTree, function (str) {
          return ret += fromCodePoint(str);
        });
        return function decodeWithTrie(str, decodeMode) {
          var lastIndex = 0;
          var offset = 0;

          while ((offset = str.indexOf("&", offset)) >= 0) {
            ret += str.slice(lastIndex, offset);
            decoder.startEntity(decodeMode);
            var len = decoder.write(str, offset + 1);

            if (len < 0) {
              lastIndex = offset + decoder.end();
              break;
            }

            lastIndex = offset + len;
            offset = len === 0 ? lastIndex + 1 : lastIndex;
          }

          var result = ret + str.slice(lastIndex);
          ret = "";
          return result;
        };
      }

      function determineBranch(decodeTree, current, nodeIdx, _char4) {
        var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
        var jumpOffset = current & BinTrieFlags.JUMP_TABLE;

        if (branchCount === 0) {
          return jumpOffset !== 0 && _char4 === jumpOffset ? nodeIdx : -1;
        }

        if (jumpOffset) {
          var value = _char4 - jumpOffset;
          return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
        }

        var lo = nodeIdx;
        var hi = lo + branchCount - 1;

        while (lo <= hi) {
          var mid = lo + hi >>> 1;
          var midVal = decodeTree[mid];

          if (midVal < _char4) {
            lo = mid + 1;
          } else if (midVal > _char4) {
            hi = mid - 1;
          } else {
            return decodeTree[mid + branchCount];
          }
        }

        return -1;
      }

      getDecoder(htmlDecodeTree);
      getDecoder(xmlDecodeTree);

      function getEscaper(regex, map) {
        return function escape(data) {
          var match;
          var lastIdx = 0;
          var result = "";

          while (match = regex.exec(data)) {
            if (lastIdx !== match.index) {
              result += data.substring(lastIdx, match.index);
            }

            result += map.get(match[0].charCodeAt(0));
            lastIdx = match.index + 1;
          }

          return result + data.substring(lastIdx);
        };
      }
      var escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([[34, "&quot;"], [38, "&amp;"], [160, "&nbsp;"]]));
      var escapeText = getEscaper(/[&<>\u00A0]/g, new Map([[38, "&amp;"], [60, "&lt;"], [62, "&gt;"], [160, "&nbsp;"]]));

      const UNDEFINED_CODE_POINTS = new Set([
        65534,
        65535,
        131070,
        131071,
        196606,
        196607,
        262142,
        262143,
        327678,
        327679,
        393214,
        393215,
        458750,
        458751,
        524286,
        524287,
        589822,
        589823,
        655358,
        655359,
        720894,
        720895,
        786430,
        786431,
        851966,
        851967,
        917502,
        917503,
        983038,
        983039,
        1048574,
        1048575,
        1114110,
        1114111
      ]);
      const REPLACEMENT_CHARACTER = "\uFFFD";
      var CODE_POINTS;
      (function (CODE_POINTS) {
        CODE_POINTS[CODE_POINTS["EOF"] = -1] = "EOF";
        CODE_POINTS[CODE_POINTS["NULL"] = 0] = "NULL";
        CODE_POINTS[CODE_POINTS["TABULATION"] = 9] = "TABULATION";
        CODE_POINTS[CODE_POINTS["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
        CODE_POINTS[CODE_POINTS["LINE_FEED"] = 10] = "LINE_FEED";
        CODE_POINTS[CODE_POINTS["FORM_FEED"] = 12] = "FORM_FEED";
        CODE_POINTS[CODE_POINTS["SPACE"] = 32] = "SPACE";
        CODE_POINTS[CODE_POINTS["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
        CODE_POINTS[CODE_POINTS["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
        CODE_POINTS[CODE_POINTS["NUMBER_SIGN"] = 35] = "NUMBER_SIGN";
        CODE_POINTS[CODE_POINTS["AMPERSAND"] = 38] = "AMPERSAND";
        CODE_POINTS[CODE_POINTS["APOSTROPHE"] = 39] = "APOSTROPHE";
        CODE_POINTS[CODE_POINTS["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
        CODE_POINTS[CODE_POINTS["SOLIDUS"] = 47] = "SOLIDUS";
        CODE_POINTS[CODE_POINTS["DIGIT_0"] = 48] = "DIGIT_0";
        CODE_POINTS[CODE_POINTS["DIGIT_9"] = 57] = "DIGIT_9";
        CODE_POINTS[CODE_POINTS["SEMICOLON"] = 59] = "SEMICOLON";
        CODE_POINTS[CODE_POINTS["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
        CODE_POINTS[CODE_POINTS["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
        CODE_POINTS[CODE_POINTS["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
        CODE_POINTS[CODE_POINTS["QUESTION_MARK"] = 63] = "QUESTION_MARK";
        CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
        CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_F"] = 70] = "LATIN_CAPITAL_F";
        CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_X"] = 88] = "LATIN_CAPITAL_X";
        CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
        CODE_POINTS[CODE_POINTS["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
        CODE_POINTS[CODE_POINTS["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
        CODE_POINTS[CODE_POINTS["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
        CODE_POINTS[CODE_POINTS["LATIN_SMALL_F"] = 102] = "LATIN_SMALL_F";
        CODE_POINTS[CODE_POINTS["LATIN_SMALL_X"] = 120] = "LATIN_SMALL_X";
        CODE_POINTS[CODE_POINTS["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
        CODE_POINTS[CODE_POINTS["REPLACEMENT_CHARACTER"] = 65533] = "REPLACEMENT_CHARACTER";
      }(CODE_POINTS || (CODE_POINTS = {})));
      const SEQUENCES = {
        DASH_DASH: "--",
        CDATA_START: "[CDATA[",
        DOCTYPE: "doctype",
        SCRIPT: "script",
        PUBLIC: "public",
        SYSTEM: "system"
      };
      function isSurrogate(cp) {
        return cp >= 55296 && cp <= 57343;
      }
      function isSurrogatePair(cp) {
        return cp >= 56320 && cp <= 57343;
      }
      function getSurrogatePairCodePoint(cp1, cp2) {
        return (cp1 - 55296) * 1024 + 9216 + cp2;
      }
      function isControlCodePoint(cp) {
        return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
      }
      function isUndefinedCodePoint(cp) {
        return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.has(cp);
      }
      var ERR;
      (function (ERR) {
        ERR["controlCharacterInInputStream"] = "control-character-in-input-stream";
        ERR["noncharacterInInputStream"] = "noncharacter-in-input-stream";
        ERR["surrogateInInputStream"] = "surrogate-in-input-stream";
        ERR["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
        ERR["endTagWithAttributes"] = "end-tag-with-attributes";
        ERR["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
        ERR["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
        ERR["unexpectedNullCharacter"] = "unexpected-null-character";
        ERR["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
        ERR["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
        ERR["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
        ERR["missingEndTagName"] = "missing-end-tag-name";
        ERR["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
        ERR["unknownNamedCharacterReference"] = "unknown-named-character-reference";
        ERR["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
        ERR["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
        ERR["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
        ERR["eofBeforeTagName"] = "eof-before-tag-name";
        ERR["eofInTag"] = "eof-in-tag";
        ERR["missingAttributeValue"] = "missing-attribute-value";
        ERR["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
        ERR["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
        ERR["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
        ERR["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
        ERR["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
        ERR["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
        ERR["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
        ERR["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
        ERR["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
        ERR["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
        ERR["cdataInHtmlContent"] = "cdata-in-html-content";
        ERR["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
        ERR["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
        ERR["eofInDoctype"] = "eof-in-doctype";
        ERR["nestedComment"] = "nested-comment";
        ERR["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
        ERR["eofInComment"] = "eof-in-comment";
        ERR["incorrectlyClosedComment"] = "incorrectly-closed-comment";
        ERR["eofInCdata"] = "eof-in-cdata";
        ERR["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
        ERR["nullCharacterReference"] = "null-character-reference";
        ERR["surrogateCharacterReference"] = "surrogate-character-reference";
        ERR["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
        ERR["controlCharacterReference"] = "control-character-reference";
        ERR["noncharacterCharacterReference"] = "noncharacter-character-reference";
        ERR["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
        ERR["missingDoctypeName"] = "missing-doctype-name";
        ERR["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
        ERR["duplicateAttribute"] = "duplicate-attribute";
        ERR["nonConformingDoctype"] = "non-conforming-doctype";
        ERR["missingDoctype"] = "missing-doctype";
        ERR["misplacedDoctype"] = "misplaced-doctype";
        ERR["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
        ERR["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
        ERR["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
        ERR["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
        ERR["abandonedHeadElementChild"] = "abandoned-head-element-child";
        ERR["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
        ERR["nestedNoscriptInHead"] = "nested-noscript-in-head";
        ERR["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
      }(ERR || (ERR = {})));
      const DEFAULT_BUFFER_WATERLINE = 1 << 16;
      class Preprocessor {
        constructor(handler) {
          this.handler = handler;
          this.html = "";
          this.pos = -1;
          this.lastGapPos = -2;
          this.gapStack = [];
          this.skipNextNewLine = false;
          this.lastChunkWritten = false;
          this.endOfChunkHit = false;
          this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
          this.isEol = false;
          this.lineStartPos = 0;
          this.droppedBufferSize = 0;
          this.line = 1;
          this.lastErrOffset = -1;
        }
        get col() {
          return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
        }
        get offset() {
          return this.droppedBufferSize + this.pos;
        }
        getError(code) {
          const {line, col, offset} = this;
          return {
            code,
            startLine: line,
            endLine: line,
            startCol: col,
            endCol: col,
            startOffset: offset,
            endOffset: offset
          };
        }
        _err(code) {
          if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
            this.lastErrOffset = this.offset;
            this.handler.onParseError(this.getError(code));
          }
        }
        _addGap() {
          this.gapStack.push(this.lastGapPos);
          this.lastGapPos = this.pos;
        }
        _processSurrogate(cp) {
          if (this.pos !== this.html.length - 1) {
            const nextCp = this.html.charCodeAt(this.pos + 1);
            if (isSurrogatePair(nextCp)) {
              this.pos++;
              this._addGap();
              return getSurrogatePairCodePoint(cp, nextCp);
            }
          } else if (!this.lastChunkWritten) {
            this.endOfChunkHit = true;
            return CODE_POINTS.EOF;
          }
          this._err(ERR.surrogateInInputStream);
          return cp;
        }
        willDropParsedChunk() {
          return this.pos > this.bufferWaterline;
        }
        dropParsedChunk() {
          if (this.willDropParsedChunk()) {
            this.html = this.html.substring(this.pos);
            this.lineStartPos -= this.pos;
            this.droppedBufferSize += this.pos;
            this.pos = 0;
            this.lastGapPos = -2;
            this.gapStack.length = 0;
          }
        }
        write(chunk, isLastChunk) {
          if (this.html.length > 0) {
            this.html += chunk;
          } else {
            this.html = chunk;
          }
          this.endOfChunkHit = false;
          this.lastChunkWritten = isLastChunk;
        }
        insertHtmlAtCurrentPos(chunk) {
          this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
          this.endOfChunkHit = false;
        }
        startsWith(pattern, caseSensitive) {
          if (this.pos + pattern.length > this.html.length) {
            this.endOfChunkHit = !this.lastChunkWritten;
            return false;
          }
          if (caseSensitive) {
            return this.html.startsWith(pattern, this.pos);
          }
          for (let i = 0; i < pattern.length; i++) {
            const cp = this.html.charCodeAt(this.pos + i) | 32;
            if (cp !== pattern.charCodeAt(i)) {
              return false;
            }
          }
          return true;
        }
        peek(offset) {
          const pos = this.pos + offset;
          if (pos >= this.html.length) {
            this.endOfChunkHit = !this.lastChunkWritten;
            return CODE_POINTS.EOF;
          }
          return this.html.charCodeAt(pos);
        }
        advance() {
          this.pos++;
          if (this.isEol) {
            this.isEol = false;
            this.line++;
            this.lineStartPos = this.pos;
          }
          if (this.pos >= this.html.length) {
            this.endOfChunkHit = !this.lastChunkWritten;
            return CODE_POINTS.EOF;
          }
          let cp = this.html.charCodeAt(this.pos);
          if (cp === CODE_POINTS.CARRIAGE_RETURN) {
            this.isEol = true;
            this.skipNextNewLine = true;
            return CODE_POINTS.LINE_FEED;
          }
          if (cp === CODE_POINTS.LINE_FEED) {
            this.isEol = true;
            if (this.skipNextNewLine) {
              this.line--;
              this.skipNextNewLine = false;
              this._addGap();
              return this.advance();
            }
          }
          this.skipNextNewLine = false;
          if (isSurrogate(cp)) {
            cp = this._processSurrogate(cp);
          }
          const isCommonValidRange = this.handler.onParseError === null || cp > 31 && cp < 127 || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.CARRIAGE_RETURN || cp > 159 && cp < 64976;
          if (!isCommonValidRange) {
            this._checkForProblematicCharacters(cp);
          }
          return cp;
        }
        _checkForProblematicCharacters(cp) {
          if (isControlCodePoint(cp)) {
            this._err(ERR.controlCharacterInInputStream);
          } else if (isUndefinedCodePoint(cp)) {
            this._err(ERR.noncharacterInInputStream);
          }
        }
        retreat(count) {
          this.pos -= count;
          while (this.pos < this.lastGapPos) {
            this.lastGapPos = this.gapStack.pop();
            this.pos--;
          }
          this.isEol = false;
        }
      }
      var TokenType;
      (function (TokenType) {
        TokenType[TokenType["CHARACTER"] = 0] = "CHARACTER";
        TokenType[TokenType["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
        TokenType[TokenType["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
        TokenType[TokenType["START_TAG"] = 3] = "START_TAG";
        TokenType[TokenType["END_TAG"] = 4] = "END_TAG";
        TokenType[TokenType["COMMENT"] = 5] = "COMMENT";
        TokenType[TokenType["DOCTYPE"] = 6] = "DOCTYPE";
        TokenType[TokenType["EOF"] = 7] = "EOF";
        TokenType[TokenType["HIBERNATION"] = 8] = "HIBERNATION";
      }(TokenType || (TokenType = {})));
      function getTokenAttr(token, attrName) {
        for (let i = token.attrs.length - 1; i >= 0; i--) {
          if (token.attrs[i].name === attrName) {
            return token.attrs[i].value;
          }
        }
        return null;
      }
      var token = Object.freeze(Object.defineProperty({
        __proto__: null,
        get TokenType() {
          return TokenType;
        },
        getTokenAttr: getTokenAttr
      }, Symbol.toStringTag, { value: "Module" }));
      var NS;
      (function (NS) {
        NS["HTML"] = "http://www.w3.org/1999/xhtml";
        NS["MATHML"] = "http://www.w3.org/1998/Math/MathML";
        NS["SVG"] = "http://www.w3.org/2000/svg";
        NS["XLINK"] = "http://www.w3.org/1999/xlink";
        NS["XML"] = "http://www.w3.org/XML/1998/namespace";
        NS["XMLNS"] = "http://www.w3.org/2000/xmlns/";
      }(NS || (NS = {})));
      var ATTRS;
      (function (ATTRS) {
        ATTRS["TYPE"] = "type";
        ATTRS["ACTION"] = "action";
        ATTRS["ENCODING"] = "encoding";
        ATTRS["PROMPT"] = "prompt";
        ATTRS["NAME"] = "name";
        ATTRS["COLOR"] = "color";
        ATTRS["FACE"] = "face";
        ATTRS["SIZE"] = "size";
      }(ATTRS || (ATTRS = {})));
      var DOCUMENT_MODE;
      (function (DOCUMENT_MODE) {
        DOCUMENT_MODE["NO_QUIRKS"] = "no-quirks";
        DOCUMENT_MODE["QUIRKS"] = "quirks";
        DOCUMENT_MODE["LIMITED_QUIRKS"] = "limited-quirks";
      }(DOCUMENT_MODE || (DOCUMENT_MODE = {})));
      var TAG_NAMES;
      (function (TAG_NAMES) {
        TAG_NAMES["A"] = "a";
        TAG_NAMES["ADDRESS"] = "address";
        TAG_NAMES["ANNOTATION_XML"] = "annotation-xml";
        TAG_NAMES["APPLET"] = "applet";
        TAG_NAMES["AREA"] = "area";
        TAG_NAMES["ARTICLE"] = "article";
        TAG_NAMES["ASIDE"] = "aside";
        TAG_NAMES["B"] = "b";
        TAG_NAMES["BASE"] = "base";
        TAG_NAMES["BASEFONT"] = "basefont";
        TAG_NAMES["BGSOUND"] = "bgsound";
        TAG_NAMES["BIG"] = "big";
        TAG_NAMES["BLOCKQUOTE"] = "blockquote";
        TAG_NAMES["BODY"] = "body";
        TAG_NAMES["BR"] = "br";
        TAG_NAMES["BUTTON"] = "button";
        TAG_NAMES["CAPTION"] = "caption";
        TAG_NAMES["CENTER"] = "center";
        TAG_NAMES["CODE"] = "code";
        TAG_NAMES["COL"] = "col";
        TAG_NAMES["COLGROUP"] = "colgroup";
        TAG_NAMES["DD"] = "dd";
        TAG_NAMES["DESC"] = "desc";
        TAG_NAMES["DETAILS"] = "details";
        TAG_NAMES["DIALOG"] = "dialog";
        TAG_NAMES["DIR"] = "dir";
        TAG_NAMES["DIV"] = "div";
        TAG_NAMES["DL"] = "dl";
        TAG_NAMES["DT"] = "dt";
        TAG_NAMES["EM"] = "em";
        TAG_NAMES["EMBED"] = "embed";
        TAG_NAMES["FIELDSET"] = "fieldset";
        TAG_NAMES["FIGCAPTION"] = "figcaption";
        TAG_NAMES["FIGURE"] = "figure";
        TAG_NAMES["FONT"] = "font";
        TAG_NAMES["FOOTER"] = "footer";
        TAG_NAMES["FOREIGN_OBJECT"] = "foreignObject";
        TAG_NAMES["FORM"] = "form";
        TAG_NAMES["FRAME"] = "frame";
        TAG_NAMES["FRAMESET"] = "frameset";
        TAG_NAMES["H1"] = "h1";
        TAG_NAMES["H2"] = "h2";
        TAG_NAMES["H3"] = "h3";
        TAG_NAMES["H4"] = "h4";
        TAG_NAMES["H5"] = "h5";
        TAG_NAMES["H6"] = "h6";
        TAG_NAMES["HEAD"] = "head";
        TAG_NAMES["HEADER"] = "header";
        TAG_NAMES["HGROUP"] = "hgroup";
        TAG_NAMES["HR"] = "hr";
        TAG_NAMES["HTML"] = "html";
        TAG_NAMES["I"] = "i";
        TAG_NAMES["IMG"] = "img";
        TAG_NAMES["IMAGE"] = "image";
        TAG_NAMES["INPUT"] = "input";
        TAG_NAMES["IFRAME"] = "iframe";
        TAG_NAMES["KEYGEN"] = "keygen";
        TAG_NAMES["LABEL"] = "label";
        TAG_NAMES["LI"] = "li";
        TAG_NAMES["LINK"] = "link";
        TAG_NAMES["LISTING"] = "listing";
        TAG_NAMES["MAIN"] = "main";
        TAG_NAMES["MALIGNMARK"] = "malignmark";
        TAG_NAMES["MARQUEE"] = "marquee";
        TAG_NAMES["MATH"] = "math";
        TAG_NAMES["MENU"] = "menu";
        TAG_NAMES["META"] = "meta";
        TAG_NAMES["MGLYPH"] = "mglyph";
        TAG_NAMES["MI"] = "mi";
        TAG_NAMES["MO"] = "mo";
        TAG_NAMES["MN"] = "mn";
        TAG_NAMES["MS"] = "ms";
        TAG_NAMES["MTEXT"] = "mtext";
        TAG_NAMES["NAV"] = "nav";
        TAG_NAMES["NOBR"] = "nobr";
        TAG_NAMES["NOFRAMES"] = "noframes";
        TAG_NAMES["NOEMBED"] = "noembed";
        TAG_NAMES["NOSCRIPT"] = "noscript";
        TAG_NAMES["OBJECT"] = "object";
        TAG_NAMES["OL"] = "ol";
        TAG_NAMES["OPTGROUP"] = "optgroup";
        TAG_NAMES["OPTION"] = "option";
        TAG_NAMES["P"] = "p";
        TAG_NAMES["PARAM"] = "param";
        TAG_NAMES["PLAINTEXT"] = "plaintext";
        TAG_NAMES["PRE"] = "pre";
        TAG_NAMES["RB"] = "rb";
        TAG_NAMES["RP"] = "rp";
        TAG_NAMES["RT"] = "rt";
        TAG_NAMES["RTC"] = "rtc";
        TAG_NAMES["RUBY"] = "ruby";
        TAG_NAMES["S"] = "s";
        TAG_NAMES["SCRIPT"] = "script";
        TAG_NAMES["SECTION"] = "section";
        TAG_NAMES["SELECT"] = "select";
        TAG_NAMES["SOURCE"] = "source";
        TAG_NAMES["SMALL"] = "small";
        TAG_NAMES["SPAN"] = "span";
        TAG_NAMES["STRIKE"] = "strike";
        TAG_NAMES["STRONG"] = "strong";
        TAG_NAMES["STYLE"] = "style";
        TAG_NAMES["SUB"] = "sub";
        TAG_NAMES["SUMMARY"] = "summary";
        TAG_NAMES["SUP"] = "sup";
        TAG_NAMES["TABLE"] = "table";
        TAG_NAMES["TBODY"] = "tbody";
        TAG_NAMES["TEMPLATE"] = "template";
        TAG_NAMES["TEXTAREA"] = "textarea";
        TAG_NAMES["TFOOT"] = "tfoot";
        TAG_NAMES["TD"] = "td";
        TAG_NAMES["TH"] = "th";
        TAG_NAMES["THEAD"] = "thead";
        TAG_NAMES["TITLE"] = "title";
        TAG_NAMES["TR"] = "tr";
        TAG_NAMES["TRACK"] = "track";
        TAG_NAMES["TT"] = "tt";
        TAG_NAMES["U"] = "u";
        TAG_NAMES["UL"] = "ul";
        TAG_NAMES["SVG"] = "svg";
        TAG_NAMES["VAR"] = "var";
        TAG_NAMES["WBR"] = "wbr";
        TAG_NAMES["XMP"] = "xmp";
      }(TAG_NAMES || (TAG_NAMES = {})));
      var TAG_ID;
      (function (TAG_ID) {
        TAG_ID[TAG_ID["UNKNOWN"] = 0] = "UNKNOWN";
        TAG_ID[TAG_ID["A"] = 1] = "A";
        TAG_ID[TAG_ID["ADDRESS"] = 2] = "ADDRESS";
        TAG_ID[TAG_ID["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
        TAG_ID[TAG_ID["APPLET"] = 4] = "APPLET";
        TAG_ID[TAG_ID["AREA"] = 5] = "AREA";
        TAG_ID[TAG_ID["ARTICLE"] = 6] = "ARTICLE";
        TAG_ID[TAG_ID["ASIDE"] = 7] = "ASIDE";
        TAG_ID[TAG_ID["B"] = 8] = "B";
        TAG_ID[TAG_ID["BASE"] = 9] = "BASE";
        TAG_ID[TAG_ID["BASEFONT"] = 10] = "BASEFONT";
        TAG_ID[TAG_ID["BGSOUND"] = 11] = "BGSOUND";
        TAG_ID[TAG_ID["BIG"] = 12] = "BIG";
        TAG_ID[TAG_ID["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
        TAG_ID[TAG_ID["BODY"] = 14] = "BODY";
        TAG_ID[TAG_ID["BR"] = 15] = "BR";
        TAG_ID[TAG_ID["BUTTON"] = 16] = "BUTTON";
        TAG_ID[TAG_ID["CAPTION"] = 17] = "CAPTION";
        TAG_ID[TAG_ID["CENTER"] = 18] = "CENTER";
        TAG_ID[TAG_ID["CODE"] = 19] = "CODE";
        TAG_ID[TAG_ID["COL"] = 20] = "COL";
        TAG_ID[TAG_ID["COLGROUP"] = 21] = "COLGROUP";
        TAG_ID[TAG_ID["DD"] = 22] = "DD";
        TAG_ID[TAG_ID["DESC"] = 23] = "DESC";
        TAG_ID[TAG_ID["DETAILS"] = 24] = "DETAILS";
        TAG_ID[TAG_ID["DIALOG"] = 25] = "DIALOG";
        TAG_ID[TAG_ID["DIR"] = 26] = "DIR";
        TAG_ID[TAG_ID["DIV"] = 27] = "DIV";
        TAG_ID[TAG_ID["DL"] = 28] = "DL";
        TAG_ID[TAG_ID["DT"] = 29] = "DT";
        TAG_ID[TAG_ID["EM"] = 30] = "EM";
        TAG_ID[TAG_ID["EMBED"] = 31] = "EMBED";
        TAG_ID[TAG_ID["FIELDSET"] = 32] = "FIELDSET";
        TAG_ID[TAG_ID["FIGCAPTION"] = 33] = "FIGCAPTION";
        TAG_ID[TAG_ID["FIGURE"] = 34] = "FIGURE";
        TAG_ID[TAG_ID["FONT"] = 35] = "FONT";
        TAG_ID[TAG_ID["FOOTER"] = 36] = "FOOTER";
        TAG_ID[TAG_ID["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
        TAG_ID[TAG_ID["FORM"] = 38] = "FORM";
        TAG_ID[TAG_ID["FRAME"] = 39] = "FRAME";
        TAG_ID[TAG_ID["FRAMESET"] = 40] = "FRAMESET";
        TAG_ID[TAG_ID["H1"] = 41] = "H1";
        TAG_ID[TAG_ID["H2"] = 42] = "H2";
        TAG_ID[TAG_ID["H3"] = 43] = "H3";
        TAG_ID[TAG_ID["H4"] = 44] = "H4";
        TAG_ID[TAG_ID["H5"] = 45] = "H5";
        TAG_ID[TAG_ID["H6"] = 46] = "H6";
        TAG_ID[TAG_ID["HEAD"] = 47] = "HEAD";
        TAG_ID[TAG_ID["HEADER"] = 48] = "HEADER";
        TAG_ID[TAG_ID["HGROUP"] = 49] = "HGROUP";
        TAG_ID[TAG_ID["HR"] = 50] = "HR";
        TAG_ID[TAG_ID["HTML"] = 51] = "HTML";
        TAG_ID[TAG_ID["I"] = 52] = "I";
        TAG_ID[TAG_ID["IMG"] = 53] = "IMG";
        TAG_ID[TAG_ID["IMAGE"] = 54] = "IMAGE";
        TAG_ID[TAG_ID["INPUT"] = 55] = "INPUT";
        TAG_ID[TAG_ID["IFRAME"] = 56] = "IFRAME";
        TAG_ID[TAG_ID["KEYGEN"] = 57] = "KEYGEN";
        TAG_ID[TAG_ID["LABEL"] = 58] = "LABEL";
        TAG_ID[TAG_ID["LI"] = 59] = "LI";
        TAG_ID[TAG_ID["LINK"] = 60] = "LINK";
        TAG_ID[TAG_ID["LISTING"] = 61] = "LISTING";
        TAG_ID[TAG_ID["MAIN"] = 62] = "MAIN";
        TAG_ID[TAG_ID["MALIGNMARK"] = 63] = "MALIGNMARK";
        TAG_ID[TAG_ID["MARQUEE"] = 64] = "MARQUEE";
        TAG_ID[TAG_ID["MATH"] = 65] = "MATH";
        TAG_ID[TAG_ID["MENU"] = 66] = "MENU";
        TAG_ID[TAG_ID["META"] = 67] = "META";
        TAG_ID[TAG_ID["MGLYPH"] = 68] = "MGLYPH";
        TAG_ID[TAG_ID["MI"] = 69] = "MI";
        TAG_ID[TAG_ID["MO"] = 70] = "MO";
        TAG_ID[TAG_ID["MN"] = 71] = "MN";
        TAG_ID[TAG_ID["MS"] = 72] = "MS";
        TAG_ID[TAG_ID["MTEXT"] = 73] = "MTEXT";
        TAG_ID[TAG_ID["NAV"] = 74] = "NAV";
        TAG_ID[TAG_ID["NOBR"] = 75] = "NOBR";
        TAG_ID[TAG_ID["NOFRAMES"] = 76] = "NOFRAMES";
        TAG_ID[TAG_ID["NOEMBED"] = 77] = "NOEMBED";
        TAG_ID[TAG_ID["NOSCRIPT"] = 78] = "NOSCRIPT";
        TAG_ID[TAG_ID["OBJECT"] = 79] = "OBJECT";
        TAG_ID[TAG_ID["OL"] = 80] = "OL";
        TAG_ID[TAG_ID["OPTGROUP"] = 81] = "OPTGROUP";
        TAG_ID[TAG_ID["OPTION"] = 82] = "OPTION";
        TAG_ID[TAG_ID["P"] = 83] = "P";
        TAG_ID[TAG_ID["PARAM"] = 84] = "PARAM";
        TAG_ID[TAG_ID["PLAINTEXT"] = 85] = "PLAINTEXT";
        TAG_ID[TAG_ID["PRE"] = 86] = "PRE";
        TAG_ID[TAG_ID["RB"] = 87] = "RB";
        TAG_ID[TAG_ID["RP"] = 88] = "RP";
        TAG_ID[TAG_ID["RT"] = 89] = "RT";
        TAG_ID[TAG_ID["RTC"] = 90] = "RTC";
        TAG_ID[TAG_ID["RUBY"] = 91] = "RUBY";
        TAG_ID[TAG_ID["S"] = 92] = "S";
        TAG_ID[TAG_ID["SCRIPT"] = 93] = "SCRIPT";
        TAG_ID[TAG_ID["SECTION"] = 94] = "SECTION";
        TAG_ID[TAG_ID["SELECT"] = 95] = "SELECT";
        TAG_ID[TAG_ID["SOURCE"] = 96] = "SOURCE";
        TAG_ID[TAG_ID["SMALL"] = 97] = "SMALL";
        TAG_ID[TAG_ID["SPAN"] = 98] = "SPAN";
        TAG_ID[TAG_ID["STRIKE"] = 99] = "STRIKE";
        TAG_ID[TAG_ID["STRONG"] = 100] = "STRONG";
        TAG_ID[TAG_ID["STYLE"] = 101] = "STYLE";
        TAG_ID[TAG_ID["SUB"] = 102] = "SUB";
        TAG_ID[TAG_ID["SUMMARY"] = 103] = "SUMMARY";
        TAG_ID[TAG_ID["SUP"] = 104] = "SUP";
        TAG_ID[TAG_ID["TABLE"] = 105] = "TABLE";
        TAG_ID[TAG_ID["TBODY"] = 106] = "TBODY";
        TAG_ID[TAG_ID["TEMPLATE"] = 107] = "TEMPLATE";
        TAG_ID[TAG_ID["TEXTAREA"] = 108] = "TEXTAREA";
        TAG_ID[TAG_ID["TFOOT"] = 109] = "TFOOT";
        TAG_ID[TAG_ID["TD"] = 110] = "TD";
        TAG_ID[TAG_ID["TH"] = 111] = "TH";
        TAG_ID[TAG_ID["THEAD"] = 112] = "THEAD";
        TAG_ID[TAG_ID["TITLE"] = 113] = "TITLE";
        TAG_ID[TAG_ID["TR"] = 114] = "TR";
        TAG_ID[TAG_ID["TRACK"] = 115] = "TRACK";
        TAG_ID[TAG_ID["TT"] = 116] = "TT";
        TAG_ID[TAG_ID["U"] = 117] = "U";
        TAG_ID[TAG_ID["UL"] = 118] = "UL";
        TAG_ID[TAG_ID["SVG"] = 119] = "SVG";
        TAG_ID[TAG_ID["VAR"] = 120] = "VAR";
        TAG_ID[TAG_ID["WBR"] = 121] = "WBR";
        TAG_ID[TAG_ID["XMP"] = 122] = "XMP";
      }(TAG_ID || (TAG_ID = {})));
      const TAG_NAME_TO_ID = new Map([
        [
          TAG_NAMES.A,
          TAG_ID.A
        ],
        [
          TAG_NAMES.ADDRESS,
          TAG_ID.ADDRESS
        ],
        [
          TAG_NAMES.ANNOTATION_XML,
          TAG_ID.ANNOTATION_XML
        ],
        [
          TAG_NAMES.APPLET,
          TAG_ID.APPLET
        ],
        [
          TAG_NAMES.AREA,
          TAG_ID.AREA
        ],
        [
          TAG_NAMES.ARTICLE,
          TAG_ID.ARTICLE
        ],
        [
          TAG_NAMES.ASIDE,
          TAG_ID.ASIDE
        ],
        [
          TAG_NAMES.B,
          TAG_ID.B
        ],
        [
          TAG_NAMES.BASE,
          TAG_ID.BASE
        ],
        [
          TAG_NAMES.BASEFONT,
          TAG_ID.BASEFONT
        ],
        [
          TAG_NAMES.BGSOUND,
          TAG_ID.BGSOUND
        ],
        [
          TAG_NAMES.BIG,
          TAG_ID.BIG
        ],
        [
          TAG_NAMES.BLOCKQUOTE,
          TAG_ID.BLOCKQUOTE
        ],
        [
          TAG_NAMES.BODY,
          TAG_ID.BODY
        ],
        [
          TAG_NAMES.BR,
          TAG_ID.BR
        ],
        [
          TAG_NAMES.BUTTON,
          TAG_ID.BUTTON
        ],
        [
          TAG_NAMES.CAPTION,
          TAG_ID.CAPTION
        ],
        [
          TAG_NAMES.CENTER,
          TAG_ID.CENTER
        ],
        [
          TAG_NAMES.CODE,
          TAG_ID.CODE
        ],
        [
          TAG_NAMES.COL,
          TAG_ID.COL
        ],
        [
          TAG_NAMES.COLGROUP,
          TAG_ID.COLGROUP
        ],
        [
          TAG_NAMES.DD,
          TAG_ID.DD
        ],
        [
          TAG_NAMES.DESC,
          TAG_ID.DESC
        ],
        [
          TAG_NAMES.DETAILS,
          TAG_ID.DETAILS
        ],
        [
          TAG_NAMES.DIALOG,
          TAG_ID.DIALOG
        ],
        [
          TAG_NAMES.DIR,
          TAG_ID.DIR
        ],
        [
          TAG_NAMES.DIV,
          TAG_ID.DIV
        ],
        [
          TAG_NAMES.DL,
          TAG_ID.DL
        ],
        [
          TAG_NAMES.DT,
          TAG_ID.DT
        ],
        [
          TAG_NAMES.EM,
          TAG_ID.EM
        ],
        [
          TAG_NAMES.EMBED,
          TAG_ID.EMBED
        ],
        [
          TAG_NAMES.FIELDSET,
          TAG_ID.FIELDSET
        ],
        [
          TAG_NAMES.FIGCAPTION,
          TAG_ID.FIGCAPTION
        ],
        [
          TAG_NAMES.FIGURE,
          TAG_ID.FIGURE
        ],
        [
          TAG_NAMES.FONT,
          TAG_ID.FONT
        ],
        [
          TAG_NAMES.FOOTER,
          TAG_ID.FOOTER
        ],
        [
          TAG_NAMES.FOREIGN_OBJECT,
          TAG_ID.FOREIGN_OBJECT
        ],
        [
          TAG_NAMES.FORM,
          TAG_ID.FORM
        ],
        [
          TAG_NAMES.FRAME,
          TAG_ID.FRAME
        ],
        [
          TAG_NAMES.FRAMESET,
          TAG_ID.FRAMESET
        ],
        [
          TAG_NAMES.H1,
          TAG_ID.H1
        ],
        [
          TAG_NAMES.H2,
          TAG_ID.H2
        ],
        [
          TAG_NAMES.H3,
          TAG_ID.H3
        ],
        [
          TAG_NAMES.H4,
          TAG_ID.H4
        ],
        [
          TAG_NAMES.H5,
          TAG_ID.H5
        ],
        [
          TAG_NAMES.H6,
          TAG_ID.H6
        ],
        [
          TAG_NAMES.HEAD,
          TAG_ID.HEAD
        ],
        [
          TAG_NAMES.HEADER,
          TAG_ID.HEADER
        ],
        [
          TAG_NAMES.HGROUP,
          TAG_ID.HGROUP
        ],
        [
          TAG_NAMES.HR,
          TAG_ID.HR
        ],
        [
          TAG_NAMES.HTML,
          TAG_ID.HTML
        ],
        [
          TAG_NAMES.I,
          TAG_ID.I
        ],
        [
          TAG_NAMES.IMG,
          TAG_ID.IMG
        ],
        [
          TAG_NAMES.IMAGE,
          TAG_ID.IMAGE
        ],
        [
          TAG_NAMES.INPUT,
          TAG_ID.INPUT
        ],
        [
          TAG_NAMES.IFRAME,
          TAG_ID.IFRAME
        ],
        [
          TAG_NAMES.KEYGEN,
          TAG_ID.KEYGEN
        ],
        [
          TAG_NAMES.LABEL,
          TAG_ID.LABEL
        ],
        [
          TAG_NAMES.LI,
          TAG_ID.LI
        ],
        [
          TAG_NAMES.LINK,
          TAG_ID.LINK
        ],
        [
          TAG_NAMES.LISTING,
          TAG_ID.LISTING
        ],
        [
          TAG_NAMES.MAIN,
          TAG_ID.MAIN
        ],
        [
          TAG_NAMES.MALIGNMARK,
          TAG_ID.MALIGNMARK
        ],
        [
          TAG_NAMES.MARQUEE,
          TAG_ID.MARQUEE
        ],
        [
          TAG_NAMES.MATH,
          TAG_ID.MATH
        ],
        [
          TAG_NAMES.MENU,
          TAG_ID.MENU
        ],
        [
          TAG_NAMES.META,
          TAG_ID.META
        ],
        [
          TAG_NAMES.MGLYPH,
          TAG_ID.MGLYPH
        ],
        [
          TAG_NAMES.MI,
          TAG_ID.MI
        ],
        [
          TAG_NAMES.MO,
          TAG_ID.MO
        ],
        [
          TAG_NAMES.MN,
          TAG_ID.MN
        ],
        [
          TAG_NAMES.MS,
          TAG_ID.MS
        ],
        [
          TAG_NAMES.MTEXT,
          TAG_ID.MTEXT
        ],
        [
          TAG_NAMES.NAV,
          TAG_ID.NAV
        ],
        [
          TAG_NAMES.NOBR,
          TAG_ID.NOBR
        ],
        [
          TAG_NAMES.NOFRAMES,
          TAG_ID.NOFRAMES
        ],
        [
          TAG_NAMES.NOEMBED,
          TAG_ID.NOEMBED
        ],
        [
          TAG_NAMES.NOSCRIPT,
          TAG_ID.NOSCRIPT
        ],
        [
          TAG_NAMES.OBJECT,
          TAG_ID.OBJECT
        ],
        [
          TAG_NAMES.OL,
          TAG_ID.OL
        ],
        [
          TAG_NAMES.OPTGROUP,
          TAG_ID.OPTGROUP
        ],
        [
          TAG_NAMES.OPTION,
          TAG_ID.OPTION
        ],
        [
          TAG_NAMES.P,
          TAG_ID.P
        ],
        [
          TAG_NAMES.PARAM,
          TAG_ID.PARAM
        ],
        [
          TAG_NAMES.PLAINTEXT,
          TAG_ID.PLAINTEXT
        ],
        [
          TAG_NAMES.PRE,
          TAG_ID.PRE
        ],
        [
          TAG_NAMES.RB,
          TAG_ID.RB
        ],
        [
          TAG_NAMES.RP,
          TAG_ID.RP
        ],
        [
          TAG_NAMES.RT,
          TAG_ID.RT
        ],
        [
          TAG_NAMES.RTC,
          TAG_ID.RTC
        ],
        [
          TAG_NAMES.RUBY,
          TAG_ID.RUBY
        ],
        [
          TAG_NAMES.S,
          TAG_ID.S
        ],
        [
          TAG_NAMES.SCRIPT,
          TAG_ID.SCRIPT
        ],
        [
          TAG_NAMES.SECTION,
          TAG_ID.SECTION
        ],
        [
          TAG_NAMES.SELECT,
          TAG_ID.SELECT
        ],
        [
          TAG_NAMES.SOURCE,
          TAG_ID.SOURCE
        ],
        [
          TAG_NAMES.SMALL,
          TAG_ID.SMALL
        ],
        [
          TAG_NAMES.SPAN,
          TAG_ID.SPAN
        ],
        [
          TAG_NAMES.STRIKE,
          TAG_ID.STRIKE
        ],
        [
          TAG_NAMES.STRONG,
          TAG_ID.STRONG
        ],
        [
          TAG_NAMES.STYLE,
          TAG_ID.STYLE
        ],
        [
          TAG_NAMES.SUB,
          TAG_ID.SUB
        ],
        [
          TAG_NAMES.SUMMARY,
          TAG_ID.SUMMARY
        ],
        [
          TAG_NAMES.SUP,
          TAG_ID.SUP
        ],
        [
          TAG_NAMES.TABLE,
          TAG_ID.TABLE
        ],
        [
          TAG_NAMES.TBODY,
          TAG_ID.TBODY
        ],
        [
          TAG_NAMES.TEMPLATE,
          TAG_ID.TEMPLATE
        ],
        [
          TAG_NAMES.TEXTAREA,
          TAG_ID.TEXTAREA
        ],
        [
          TAG_NAMES.TFOOT,
          TAG_ID.TFOOT
        ],
        [
          TAG_NAMES.TD,
          TAG_ID.TD
        ],
        [
          TAG_NAMES.TH,
          TAG_ID.TH
        ],
        [
          TAG_NAMES.THEAD,
          TAG_ID.THEAD
        ],
        [
          TAG_NAMES.TITLE,
          TAG_ID.TITLE
        ],
        [
          TAG_NAMES.TR,
          TAG_ID.TR
        ],
        [
          TAG_NAMES.TRACK,
          TAG_ID.TRACK
        ],
        [
          TAG_NAMES.TT,
          TAG_ID.TT
        ],
        [
          TAG_NAMES.U,
          TAG_ID.U
        ],
        [
          TAG_NAMES.UL,
          TAG_ID.UL
        ],
        [
          TAG_NAMES.SVG,
          TAG_ID.SVG
        ],
        [
          TAG_NAMES.VAR,
          TAG_ID.VAR
        ],
        [
          TAG_NAMES.WBR,
          TAG_ID.WBR
        ],
        [
          TAG_NAMES.XMP,
          TAG_ID.XMP
        ]
      ]);
      function getTagID(tagName) {
        var _a;
        return (_a = TAG_NAME_TO_ID.get(tagName)) !== null && _a !== void 0 ? _a : TAG_ID.UNKNOWN;
      }
      const $ = TAG_ID;
      const SPECIAL_ELEMENTS = {
        [NS.HTML]: new Set([
          $.ADDRESS,
          $.APPLET,
          $.AREA,
          $.ARTICLE,
          $.ASIDE,
          $.BASE,
          $.BASEFONT,
          $.BGSOUND,
          $.BLOCKQUOTE,
          $.BODY,
          $.BR,
          $.BUTTON,
          $.CAPTION,
          $.CENTER,
          $.COL,
          $.COLGROUP,
          $.DD,
          $.DETAILS,
          $.DIR,
          $.DIV,
          $.DL,
          $.DT,
          $.EMBED,
          $.FIELDSET,
          $.FIGCAPTION,
          $.FIGURE,
          $.FOOTER,
          $.FORM,
          $.FRAME,
          $.FRAMESET,
          $.H1,
          $.H2,
          $.H3,
          $.H4,
          $.H5,
          $.H6,
          $.HEAD,
          $.HEADER,
          $.HGROUP,
          $.HR,
          $.HTML,
          $.IFRAME,
          $.IMG,
          $.INPUT,
          $.LI,
          $.LINK,
          $.LISTING,
          $.MAIN,
          $.MARQUEE,
          $.MENU,
          $.META,
          $.NAV,
          $.NOEMBED,
          $.NOFRAMES,
          $.NOSCRIPT,
          $.OBJECT,
          $.OL,
          $.P,
          $.PARAM,
          $.PLAINTEXT,
          $.PRE,
          $.SCRIPT,
          $.SECTION,
          $.SELECT,
          $.SOURCE,
          $.STYLE,
          $.SUMMARY,
          $.TABLE,
          $.TBODY,
          $.TD,
          $.TEMPLATE,
          $.TEXTAREA,
          $.TFOOT,
          $.TH,
          $.THEAD,
          $.TITLE,
          $.TR,
          $.TRACK,
          $.UL,
          $.WBR,
          $.XMP
        ]),
        [NS.MATHML]: new Set([
          $.MI,
          $.MO,
          $.MN,
          $.MS,
          $.MTEXT,
          $.ANNOTATION_XML
        ]),
        [NS.SVG]: new Set([
          $.TITLE,
          $.FOREIGN_OBJECT,
          $.DESC
        ]),
        [NS.XLINK]: new Set(),
        [NS.XML]: new Set(),
        [NS.XMLNS]: new Set()
      };
      function isNumberedHeader(tn) {
        return tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6;
      }
      const UNESCAPED_TEXT = new Set([
        TAG_NAMES.STYLE,
        TAG_NAMES.SCRIPT,
        TAG_NAMES.XMP,
        TAG_NAMES.IFRAME,
        TAG_NAMES.NOEMBED,
        TAG_NAMES.NOFRAMES,
        TAG_NAMES.PLAINTEXT
      ]);
      function hasUnescapedText(tn, scriptingEnabled) {
        return UNESCAPED_TEXT.has(tn) || scriptingEnabled && tn === TAG_NAMES.NOSCRIPT;
      }
      var html$1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        get NS() {
          return NS;
        },
        get ATTRS() {
          return ATTRS;
        },
        get DOCUMENT_MODE() {
          return DOCUMENT_MODE;
        },
        get TAG_NAMES() {
          return TAG_NAMES;
        },
        get TAG_ID() {
          return TAG_ID;
        },
        getTagID: getTagID,
        SPECIAL_ELEMENTS: SPECIAL_ELEMENTS,
        isNumberedHeader: isNumberedHeader,
        hasUnescapedText: hasUnescapedText
      }, Symbol.toStringTag, { value: "Module" }));
      const C1_CONTROLS_REFERENCE_REPLACEMENTS = new Map([
        [
          128,
          8364
        ],
        [
          130,
          8218
        ],
        [
          131,
          402
        ],
        [
          132,
          8222
        ],
        [
          133,
          8230
        ],
        [
          134,
          8224
        ],
        [
          135,
          8225
        ],
        [
          136,
          710
        ],
        [
          137,
          8240
        ],
        [
          138,
          352
        ],
        [
          139,
          8249
        ],
        [
          140,
          338
        ],
        [
          142,
          381
        ],
        [
          145,
          8216
        ],
        [
          146,
          8217
        ],
        [
          147,
          8220
        ],
        [
          148,
          8221
        ],
        [
          149,
          8226
        ],
        [
          150,
          8211
        ],
        [
          151,
          8212
        ],
        [
          152,
          732
        ],
        [
          153,
          8482
        ],
        [
          154,
          353
        ],
        [
          155,
          8250
        ],
        [
          156,
          339
        ],
        [
          158,
          382
        ],
        [
          159,
          376
        ]
      ]);
      var State;
      (function (State) {
        State[State["DATA"] = 0] = "DATA";
        State[State["RCDATA"] = 1] = "RCDATA";
        State[State["RAWTEXT"] = 2] = "RAWTEXT";
        State[State["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
        State[State["PLAINTEXT"] = 4] = "PLAINTEXT";
        State[State["TAG_OPEN"] = 5] = "TAG_OPEN";
        State[State["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
        State[State["TAG_NAME"] = 7] = "TAG_NAME";
        State[State["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
        State[State["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
        State[State["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
        State[State["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
        State[State["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
        State[State["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
        State[State["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
        State[State["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
        State[State["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
        State[State["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
        State[State["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
        State[State["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
        State[State["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
        State[State["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
        State[State["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
        State[State["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
        State[State["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
        State[State["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
        State[State["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
        State[State["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
        State[State["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
        State[State["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
        State[State["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
        State[State["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
        State[State["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
        State[State["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
        State[State["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
        State[State["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
        State[State["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
        State[State["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
        State[State["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
        State[State["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
        State[State["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
        State[State["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
        State[State["COMMENT_START"] = 42] = "COMMENT_START";
        State[State["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
        State[State["COMMENT"] = 44] = "COMMENT";
        State[State["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
        State[State["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
        State[State["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
        State[State["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
        State[State["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
        State[State["COMMENT_END"] = 50] = "COMMENT_END";
        State[State["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
        State[State["DOCTYPE"] = 52] = "DOCTYPE";
        State[State["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
        State[State["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
        State[State["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
        State[State["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
        State[State["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
        State[State["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
        State[State["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
        State[State["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
        State[State["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
        State[State["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
        State[State["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
        State[State["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
        State[State["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
        State[State["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
        State[State["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
        State[State["CDATA_SECTION"] = 68] = "CDATA_SECTION";
        State[State["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
        State[State["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
        State[State["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
        State[State["NAMED_CHARACTER_REFERENCE"] = 72] = "NAMED_CHARACTER_REFERENCE";
        State[State["AMBIGUOUS_AMPERSAND"] = 73] = "AMBIGUOUS_AMPERSAND";
        State[State["NUMERIC_CHARACTER_REFERENCE"] = 74] = "NUMERIC_CHARACTER_REFERENCE";
        State[State["HEXADEMICAL_CHARACTER_REFERENCE_START"] = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START";
        State[State["DECIMAL_CHARACTER_REFERENCE_START"] = 76] = "DECIMAL_CHARACTER_REFERENCE_START";
        State[State["HEXADEMICAL_CHARACTER_REFERENCE"] = 77] = "HEXADEMICAL_CHARACTER_REFERENCE";
        State[State["DECIMAL_CHARACTER_REFERENCE"] = 78] = "DECIMAL_CHARACTER_REFERENCE";
        State[State["NUMERIC_CHARACTER_REFERENCE_END"] = 79] = "NUMERIC_CHARACTER_REFERENCE_END";
      }(State || (State = {})));
      const TokenizerMode = {
        DATA: State.DATA,
        RCDATA: State.RCDATA,
        RAWTEXT: State.RAWTEXT,
        SCRIPT_DATA: State.SCRIPT_DATA,
        PLAINTEXT: State.PLAINTEXT,
        CDATA_SECTION: State.CDATA_SECTION
      };
      function isAsciiDigit(cp) {
        return cp >= CODE_POINTS.DIGIT_0 && cp <= CODE_POINTS.DIGIT_9;
      }
      function isAsciiUpper(cp) {
        return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_Z;
      }
      function isAsciiLower(cp) {
        return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_Z;
      }
      function isAsciiLetter(cp) {
        return isAsciiLower(cp) || isAsciiUpper(cp);
      }
      function isAsciiAlphaNumeric(cp) {
        return isAsciiLetter(cp) || isAsciiDigit(cp);
      }
      function isAsciiUpperHexDigit(cp) {
        return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_F;
      }
      function isAsciiLowerHexDigit(cp) {
        return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_F;
      }
      function isAsciiHexDigit(cp) {
        return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
      }
      function toAsciiLower(cp) {
        return cp + 32;
      }
      function isWhitespace(cp) {
        return cp === CODE_POINTS.SPACE || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.TABULATION || cp === CODE_POINTS.FORM_FEED;
      }
      function isEntityInAttributeInvalidEnd(nextCp) {
        return nextCp === CODE_POINTS.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
      }
      function isScriptDataDoubleEscapeSequenceEnd(cp) {
        return isWhitespace(cp) || cp === CODE_POINTS.SOLIDUS || cp === CODE_POINTS.GREATER_THAN_SIGN;
      }
      class Tokenizer {
        constructor(options, handler) {
          this.options = options;
          this.handler = handler;
          this.paused = false;
          this.inLoop = false;
          this.inForeignNode = false;
          this.lastStartTagName = "";
          this.active = false;
          this.state = State.DATA;
          this.returnState = State.DATA;
          this.charRefCode = -1;
          this.consumedAfterSnapshot = -1;
          this.currentCharacterToken = null;
          this.currentToken = null;
          this.currentAttr = {
            name: "",
            value: ""
          };
          this.preprocessor = new Preprocessor(handler);
          this.currentLocation = this.getCurrentLocation(-1);
        }
        _err(code) {
          var _a, _b;
          (_b = (_a = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a, this.preprocessor.getError(code));
        }
        getCurrentLocation(offset) {
          if (!this.options.sourceCodeLocationInfo) {
            return null;
          }
          return {
            startLine: this.preprocessor.line,
            startCol: this.preprocessor.col - offset,
            startOffset: this.preprocessor.offset - offset,
            endLine: -1,
            endCol: -1,
            endOffset: -1
          };
        }
        _runParsingLoop() {
          if (this.inLoop)
            return;
          this.inLoop = true;
          while (this.active && !this.paused) {
            this.consumedAfterSnapshot = 0;
            const cp = this._consume();
            if (!this._ensureHibernation()) {
              this._callState(cp);
            }
          }
          this.inLoop = false;
        }
        pause() {
          this.paused = true;
        }
        resume(writeCallback) {
          if (!this.paused) {
            throw new Error("Parser was already resumed");
          }
          this.paused = false;
          if (this.inLoop)
            return;
          this._runParsingLoop();
          if (!this.paused) {
            writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
          }
        }
        write(chunk, isLastChunk, writeCallback) {
          this.active = true;
          this.preprocessor.write(chunk, isLastChunk);
          this._runParsingLoop();
          if (!this.paused) {
            writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
          }
        }
        insertHtmlAtCurrentPos(chunk) {
          this.active = true;
          this.preprocessor.insertHtmlAtCurrentPos(chunk);
          this._runParsingLoop();
        }
        _ensureHibernation() {
          if (this.preprocessor.endOfChunkHit) {
            this._unconsume(this.consumedAfterSnapshot);
            this.active = false;
            return true;
          }
          return false;
        }
        _consume() {
          this.consumedAfterSnapshot++;
          return this.preprocessor.advance();
        }
        _unconsume(count) {
          this.consumedAfterSnapshot -= count;
          this.preprocessor.retreat(count);
        }
        _reconsumeInState(state) {
          this.state = state;
          this._unconsume(1);
        }
        _advanceBy(count) {
          this.consumedAfterSnapshot += count;
          for (let i = 0; i < count; i++) {
            this.preprocessor.advance();
          }
        }
        _consumeSequenceIfMatch(pattern, caseSensitive) {
          if (this.preprocessor.startsWith(pattern, caseSensitive)) {
            this._advanceBy(pattern.length - 1);
            return true;
          }
          return false;
        }
        _createStartTagToken() {
          this.currentToken = {
            type: TokenType.START_TAG,
            tagName: "",
            tagID: TAG_ID.UNKNOWN,
            selfClosing: false,
            ackSelfClosing: false,
            attrs: [],
            location: this.getCurrentLocation(1)
          };
        }
        _createEndTagToken() {
          this.currentToken = {
            type: TokenType.END_TAG,
            tagName: "",
            tagID: TAG_ID.UNKNOWN,
            selfClosing: false,
            ackSelfClosing: false,
            attrs: [],
            location: this.getCurrentLocation(2)
          };
        }
        _createCommentToken(offset) {
          this.currentToken = {
            type: TokenType.COMMENT,
            data: "",
            location: this.getCurrentLocation(offset)
          };
        }
        _createDoctypeToken(initialName) {
          this.currentToken = {
            type: TokenType.DOCTYPE,
            name: initialName,
            forceQuirks: false,
            publicId: null,
            systemId: null,
            location: this.currentLocation
          };
        }
        _createCharacterToken(type, chars) {
          this.currentCharacterToken = {
            type,
            chars,
            location: this.currentLocation
          };
        }
        _createAttr(attrNameFirstCh) {
          this.currentAttr = {
            name: attrNameFirstCh,
            value: ""
          };
          this.currentLocation = this.getCurrentLocation(0);
        }
        _leaveAttrName() {
          var _a;
          var _b;
          const token = this.currentToken;
          if (getTokenAttr(token, this.currentAttr.name) === null) {
            token.attrs.push(this.currentAttr);
            if (token.location && this.currentLocation) {
              const attrLocations = (_a = (_b = token.location).attrs) !== null && _a !== void 0 ? _a : _b.attrs = Object.create(null);
              attrLocations[this.currentAttr.name] = this.currentLocation;
              this._leaveAttrValue();
            }
          } else {
            this._err(ERR.duplicateAttribute);
          }
        }
        _leaveAttrValue() {
          if (this.currentLocation) {
            this.currentLocation.endLine = this.preprocessor.line;
            this.currentLocation.endCol = this.preprocessor.col;
            this.currentLocation.endOffset = this.preprocessor.offset;
          }
        }
        prepareToken(ct) {
          this._emitCurrentCharacterToken(ct.location);
          this.currentToken = null;
          if (ct.location) {
            ct.location.endLine = this.preprocessor.line;
            ct.location.endCol = this.preprocessor.col + 1;
            ct.location.endOffset = this.preprocessor.offset + 1;
          }
          this.currentLocation = this.getCurrentLocation(-1);
        }
        emitCurrentTagToken() {
          const ct = this.currentToken;
          this.prepareToken(ct);
          ct.tagID = getTagID(ct.tagName);
          if (ct.type === TokenType.START_TAG) {
            this.lastStartTagName = ct.tagName;
            this.handler.onStartTag(ct);
          } else {
            if (ct.attrs.length > 0) {
              this._err(ERR.endTagWithAttributes);
            }
            if (ct.selfClosing) {
              this._err(ERR.endTagWithTrailingSolidus);
            }
            this.handler.onEndTag(ct);
          }
          this.preprocessor.dropParsedChunk();
        }
        emitCurrentComment(ct) {
          this.prepareToken(ct);
          this.handler.onComment(ct);
          this.preprocessor.dropParsedChunk();
        }
        emitCurrentDoctype(ct) {
          this.prepareToken(ct);
          this.handler.onDoctype(ct);
          this.preprocessor.dropParsedChunk();
        }
        _emitCurrentCharacterToken(nextLocation) {
          if (this.currentCharacterToken) {
            if (nextLocation && this.currentCharacterToken.location) {
              this.currentCharacterToken.location.endLine = nextLocation.startLine;
              this.currentCharacterToken.location.endCol = nextLocation.startCol;
              this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
            }
            switch (this.currentCharacterToken.type) {
            case TokenType.CHARACTER: {
                this.handler.onCharacter(this.currentCharacterToken);
                break;
              }
            case TokenType.NULL_CHARACTER: {
                this.handler.onNullCharacter(this.currentCharacterToken);
                break;
              }
            case TokenType.WHITESPACE_CHARACTER: {
                this.handler.onWhitespaceCharacter(this.currentCharacterToken);
                break;
              }
            }
            this.currentCharacterToken = null;
          }
        }
        _emitEOFToken() {
          const location = this.getCurrentLocation(0);
          if (location) {
            location.endLine = location.startLine;
            location.endCol = location.startCol;
            location.endOffset = location.startOffset;
          }
          this._emitCurrentCharacterToken(location);
          this.handler.onEof({
            type: TokenType.EOF,
            location
          });
          this.active = false;
        }
        _appendCharToCurrentCharacterToken(type, ch) {
          if (this.currentCharacterToken) {
            if (this.currentCharacterToken.type !== type) {
              this.currentLocation = this.getCurrentLocation(0);
              this._emitCurrentCharacterToken(this.currentLocation);
              this.preprocessor.dropParsedChunk();
            } else {
              this.currentCharacterToken.chars += ch;
              return;
            }
          }
          this._createCharacterToken(type, ch);
        }
        _emitCodePoint(cp) {
          let type = TokenType.CHARACTER;
          if (isWhitespace(cp)) {
            type = TokenType.WHITESPACE_CHARACTER;
          } else if (cp === CODE_POINTS.NULL) {
            type = TokenType.NULL_CHARACTER;
          }
          this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
        }
        _emitChars(ch) {
          this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);
        }
        _matchNamedCharacterReference(cp) {
          let result = null;
          let excess = 0;
          let withoutSemicolon = false;
          for (let i = 0, current = htmlDecodeTree[0]; i >= 0; cp = this._consume()) {
            i = determineBranch(htmlDecodeTree, current, i + 1, cp);
            if (i < 0)
              break;
            excess += 1;
            current = htmlDecodeTree[i];
            const masked = current & BinTrieFlags.VALUE_LENGTH;
            if (masked) {
              const valueLength = (masked >> 14) - 1;
              if (cp !== CODE_POINTS.SEMICOLON && this._isCharacterReferenceInAttribute() && isEntityInAttributeInvalidEnd(this.preprocessor.peek(1))) {
                result = [CODE_POINTS.AMPERSAND];
                i += valueLength;
              } else {
                result = valueLength === 0 ? [htmlDecodeTree[i] & ~BinTrieFlags.VALUE_LENGTH] : valueLength === 1 ? [htmlDecodeTree[++i]] : [
                  htmlDecodeTree[++i],
                  htmlDecodeTree[++i]
                ];
                excess = 0;
                withoutSemicolon = cp !== CODE_POINTS.SEMICOLON;
              }
              if (valueLength === 0) {
                this._consume();
                break;
              }
            }
          }
          this._unconsume(excess);
          if (withoutSemicolon && !this.preprocessor.endOfChunkHit) {
            this._err(ERR.missingSemicolonAfterCharacterReference);
          }
          this._unconsume(1);
          return result;
        }
        _isCharacterReferenceInAttribute() {
          return this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED;
        }
        _flushCodePointConsumedAsCharacterReference(cp) {
          if (this._isCharacterReferenceInAttribute()) {
            this.currentAttr.value += String.fromCodePoint(cp);
          } else {
            this._emitCodePoint(cp);
          }
        }
        _callState(cp) {
          switch (this.state) {
          case State.DATA: {
              this._stateData(cp);
              break;
            }
          case State.RCDATA: {
              this._stateRcdata(cp);
              break;
            }
          case State.RAWTEXT: {
              this._stateRawtext(cp);
              break;
            }
          case State.SCRIPT_DATA: {
              this._stateScriptData(cp);
              break;
            }
          case State.PLAINTEXT: {
              this._statePlaintext(cp);
              break;
            }
          case State.TAG_OPEN: {
              this._stateTagOpen(cp);
              break;
            }
          case State.END_TAG_OPEN: {
              this._stateEndTagOpen(cp);
              break;
            }
          case State.TAG_NAME: {
              this._stateTagName(cp);
              break;
            }
          case State.RCDATA_LESS_THAN_SIGN: {
              this._stateRcdataLessThanSign(cp);
              break;
            }
          case State.RCDATA_END_TAG_OPEN: {
              this._stateRcdataEndTagOpen(cp);
              break;
            }
          case State.RCDATA_END_TAG_NAME: {
              this._stateRcdataEndTagName(cp);
              break;
            }
          case State.RAWTEXT_LESS_THAN_SIGN: {
              this._stateRawtextLessThanSign(cp);
              break;
            }
          case State.RAWTEXT_END_TAG_OPEN: {
              this._stateRawtextEndTagOpen(cp);
              break;
            }
          case State.RAWTEXT_END_TAG_NAME: {
              this._stateRawtextEndTagName(cp);
              break;
            }
          case State.SCRIPT_DATA_LESS_THAN_SIGN: {
              this._stateScriptDataLessThanSign(cp);
              break;
            }
          case State.SCRIPT_DATA_END_TAG_OPEN: {
              this._stateScriptDataEndTagOpen(cp);
              break;
            }
          case State.SCRIPT_DATA_END_TAG_NAME: {
              this._stateScriptDataEndTagName(cp);
              break;
            }
          case State.SCRIPT_DATA_ESCAPE_START: {
              this._stateScriptDataEscapeStart(cp);
              break;
            }
          case State.SCRIPT_DATA_ESCAPE_START_DASH: {
              this._stateScriptDataEscapeStartDash(cp);
              break;
            }
          case State.SCRIPT_DATA_ESCAPED: {
              this._stateScriptDataEscaped(cp);
              break;
            }
          case State.SCRIPT_DATA_ESCAPED_DASH: {
              this._stateScriptDataEscapedDash(cp);
              break;
            }
          case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {
              this._stateScriptDataEscapedDashDash(cp);
              break;
            }
          case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
              this._stateScriptDataEscapedLessThanSign(cp);
              break;
            }
          case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
              this._stateScriptDataEscapedEndTagOpen(cp);
              break;
            }
          case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
              this._stateScriptDataEscapedEndTagName(cp);
              break;
            }
          case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
              this._stateScriptDataDoubleEscapeStart(cp);
              break;
            }
          case State.SCRIPT_DATA_DOUBLE_ESCAPED: {
              this._stateScriptDataDoubleEscaped(cp);
              break;
            }
          case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
              this._stateScriptDataDoubleEscapedDash(cp);
              break;
            }
          case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
              this._stateScriptDataDoubleEscapedDashDash(cp);
              break;
            }
          case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
              this._stateScriptDataDoubleEscapedLessThanSign(cp);
              break;
            }
          case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
              this._stateScriptDataDoubleEscapeEnd(cp);
              break;
            }
          case State.BEFORE_ATTRIBUTE_NAME: {
              this._stateBeforeAttributeName(cp);
              break;
            }
          case State.ATTRIBUTE_NAME: {
              this._stateAttributeName(cp);
              break;
            }
          case State.AFTER_ATTRIBUTE_NAME: {
              this._stateAfterAttributeName(cp);
              break;
            }
          case State.BEFORE_ATTRIBUTE_VALUE: {
              this._stateBeforeAttributeValue(cp);
              break;
            }
          case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
              this._stateAttributeValueDoubleQuoted(cp);
              break;
            }
          case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
              this._stateAttributeValueSingleQuoted(cp);
              break;
            }
          case State.ATTRIBUTE_VALUE_UNQUOTED: {
              this._stateAttributeValueUnquoted(cp);
              break;
            }
          case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {
              this._stateAfterAttributeValueQuoted(cp);
              break;
            }
          case State.SELF_CLOSING_START_TAG: {
              this._stateSelfClosingStartTag(cp);
              break;
            }
          case State.BOGUS_COMMENT: {
              this._stateBogusComment(cp);
              break;
            }
          case State.MARKUP_DECLARATION_OPEN: {
              this._stateMarkupDeclarationOpen(cp);
              break;
            }
          case State.COMMENT_START: {
              this._stateCommentStart(cp);
              break;
            }
          case State.COMMENT_START_DASH: {
              this._stateCommentStartDash(cp);
              break;
            }
          case State.COMMENT: {
              this._stateComment(cp);
              break;
            }
          case State.COMMENT_LESS_THAN_SIGN: {
              this._stateCommentLessThanSign(cp);
              break;
            }
          case State.COMMENT_LESS_THAN_SIGN_BANG: {
              this._stateCommentLessThanSignBang(cp);
              break;
            }
          case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
              this._stateCommentLessThanSignBangDash(cp);
              break;
            }
          case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
              this._stateCommentLessThanSignBangDashDash(cp);
              break;
            }
          case State.COMMENT_END_DASH: {
              this._stateCommentEndDash(cp);
              break;
            }
          case State.COMMENT_END: {
              this._stateCommentEnd(cp);
              break;
            }
          case State.COMMENT_END_BANG: {
              this._stateCommentEndBang(cp);
              break;
            }
          case State.DOCTYPE: {
              this._stateDoctype(cp);
              break;
            }
          case State.BEFORE_DOCTYPE_NAME: {
              this._stateBeforeDoctypeName(cp);
              break;
            }
          case State.DOCTYPE_NAME: {
              this._stateDoctypeName(cp);
              break;
            }
          case State.AFTER_DOCTYPE_NAME: {
              this._stateAfterDoctypeName(cp);
              break;
            }
          case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
              this._stateAfterDoctypePublicKeyword(cp);
              break;
            }
          case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
              this._stateBeforeDoctypePublicIdentifier(cp);
              break;
            }
          case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
              this._stateDoctypePublicIdentifierDoubleQuoted(cp);
              break;
            }
          case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
              this._stateDoctypePublicIdentifierSingleQuoted(cp);
              break;
            }
          case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
              this._stateAfterDoctypePublicIdentifier(cp);
              break;
            }
          case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
              this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
              break;
            }
          case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
              this._stateAfterDoctypeSystemKeyword(cp);
              break;
            }
          case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
              this._stateBeforeDoctypeSystemIdentifier(cp);
              break;
            }
          case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
              this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
              break;
            }
          case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
              this._stateDoctypeSystemIdentifierSingleQuoted(cp);
              break;
            }
          case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
              this._stateAfterDoctypeSystemIdentifier(cp);
              break;
            }
          case State.BOGUS_DOCTYPE: {
              this._stateBogusDoctype(cp);
              break;
            }
          case State.CDATA_SECTION: {
              this._stateCdataSection(cp);
              break;
            }
          case State.CDATA_SECTION_BRACKET: {
              this._stateCdataSectionBracket(cp);
              break;
            }
          case State.CDATA_SECTION_END: {
              this._stateCdataSectionEnd(cp);
              break;
            }
          case State.CHARACTER_REFERENCE: {
              this._stateCharacterReference(cp);
              break;
            }
          case State.NAMED_CHARACTER_REFERENCE: {
              this._stateNamedCharacterReference(cp);
              break;
            }
          case State.AMBIGUOUS_AMPERSAND: {
              this._stateAmbiguousAmpersand(cp);
              break;
            }
          case State.NUMERIC_CHARACTER_REFERENCE: {
              this._stateNumericCharacterReference(cp);
              break;
            }
          case State.HEXADEMICAL_CHARACTER_REFERENCE_START: {
              this._stateHexademicalCharacterReferenceStart(cp);
              break;
            }
          case State.DECIMAL_CHARACTER_REFERENCE_START: {
              this._stateDecimalCharacterReferenceStart(cp);
              break;
            }
          case State.HEXADEMICAL_CHARACTER_REFERENCE: {
              this._stateHexademicalCharacterReference(cp);
              break;
            }
          case State.DECIMAL_CHARACTER_REFERENCE: {
              this._stateDecimalCharacterReference(cp);
              break;
            }
          case State.NUMERIC_CHARACTER_REFERENCE_END: {
              this._stateNumericCharacterReferenceEnd();
              break;
            }
          default: {
              throw new Error("Unknown state");
            }
          }
        }
        _stateData(cp) {
          switch (cp) {
          case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.TAG_OPEN;
              break;
            }
          case CODE_POINTS.AMPERSAND: {
              this.returnState = State.DATA;
              this.state = State.CHARACTER_REFERENCE;
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this._emitCodePoint(cp);
              break;
            }
          case CODE_POINTS.EOF: {
              this._emitEOFToken();
              break;
            }
          default: {
              this._emitCodePoint(cp);
            }
          }
        }
        _stateRcdata(cp) {
          switch (cp) {
          case CODE_POINTS.AMPERSAND: {
              this.returnState = State.RCDATA;
              this.state = State.CHARACTER_REFERENCE;
              break;
            }
          case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.RCDATA_LESS_THAN_SIGN;
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
          case CODE_POINTS.EOF: {
              this._emitEOFToken();
              break;
            }
          default: {
              this._emitCodePoint(cp);
            }
          }
        }
        _stateRawtext(cp) {
          switch (cp) {
          case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.RAWTEXT_LESS_THAN_SIGN;
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
          case CODE_POINTS.EOF: {
              this._emitEOFToken();
              break;
            }
          default: {
              this._emitCodePoint(cp);
            }
          }
        }
        _stateScriptData(cp) {
          switch (cp) {
          case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
          case CODE_POINTS.EOF: {
              this._emitEOFToken();
              break;
            }
          default: {
              this._emitCodePoint(cp);
            }
          }
        }
        _statePlaintext(cp) {
          switch (cp) {
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
          case CODE_POINTS.EOF: {
              this._emitEOFToken();
              break;
            }
          default: {
              this._emitCodePoint(cp);
            }
          }
        }
        _stateTagOpen(cp) {
          if (isAsciiLetter(cp)) {
            this._createStartTagToken();
            this.state = State.TAG_NAME;
            this._stateTagName(cp);
          } else
            switch (cp) {
            case CODE_POINTS.EXCLAMATION_MARK: {
                this.state = State.MARKUP_DECLARATION_OPEN;
                break;
              }
            case CODE_POINTS.SOLIDUS: {
                this.state = State.END_TAG_OPEN;
                break;
              }
            case CODE_POINTS.QUESTION_MARK: {
                this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
                this._createCommentToken(1);
                this.state = State.BOGUS_COMMENT;
                this._stateBogusComment(cp);
                break;
              }
            case CODE_POINTS.EOF: {
                this._err(ERR.eofBeforeTagName);
                this._emitChars("<");
                this._emitEOFToken();
                break;
              }
            default: {
                this._err(ERR.invalidFirstCharacterOfTagName);
                this._emitChars("<");
                this.state = State.DATA;
                this._stateData(cp);
              }
            }
        }
        _stateEndTagOpen(cp) {
          if (isAsciiLetter(cp)) {
            this._createEndTagToken();
            this.state = State.TAG_NAME;
            this._stateTagName(cp);
          } else
            switch (cp) {
            case CODE_POINTS.GREATER_THAN_SIGN: {
                this._err(ERR.missingEndTagName);
                this.state = State.DATA;
                break;
              }
            case CODE_POINTS.EOF: {
                this._err(ERR.eofBeforeTagName);
                this._emitChars("</");
                this._emitEOFToken();
                break;
              }
            default: {
                this._err(ERR.invalidFirstCharacterOfTagName);
                this._createCommentToken(2);
                this.state = State.BOGUS_COMMENT;
                this._stateBogusComment(cp);
              }
            }
        }
        _stateTagName(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              this.state = State.BEFORE_ATTRIBUTE_NAME;
              break;
            }
          case CODE_POINTS.SOLIDUS: {
              this.state = State.SELF_CLOSING_START_TAG;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              this.emitCurrentTagToken();
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.tagName += REPLACEMENT_CHARACTER;
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInTag);
              this._emitEOFToken();
              break;
            }
          default: {
              token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
            }
          }
        }
        _stateRcdataLessThanSign(cp) {
          if (cp === CODE_POINTS.SOLIDUS) {
            this.state = State.RCDATA_END_TAG_OPEN;
          } else {
            this._emitChars("<");
            this.state = State.RCDATA;
            this._stateRcdata(cp);
          }
        }
        _stateRcdataEndTagOpen(cp) {
          if (isAsciiLetter(cp)) {
            this.state = State.RCDATA_END_TAG_NAME;
            this._stateRcdataEndTagName(cp);
          } else {
            this._emitChars("</");
            this.state = State.RCDATA;
            this._stateRcdata(cp);
          }
        }
        handleSpecialEndTag(_cp) {
          if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
            return !this._ensureHibernation();
          }
          this._createEndTagToken();
          const token = this.currentToken;
          token.tagName = this.lastStartTagName;
          const cp = this.preprocessor.peek(this.lastStartTagName.length);
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              this._advanceBy(this.lastStartTagName.length);
              this.state = State.BEFORE_ATTRIBUTE_NAME;
              return false;
            }
          case CODE_POINTS.SOLIDUS: {
              this._advanceBy(this.lastStartTagName.length);
              this.state = State.SELF_CLOSING_START_TAG;
              return false;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._advanceBy(this.lastStartTagName.length);
              this.emitCurrentTagToken();
              this.state = State.DATA;
              return false;
            }
          default: {
              return !this._ensureHibernation();
            }
          }
        }
        _stateRcdataEndTagName(cp) {
          if (this.handleSpecialEndTag(cp)) {
            this._emitChars("</");
            this.state = State.RCDATA;
            this._stateRcdata(cp);
          }
        }
        _stateRawtextLessThanSign(cp) {
          if (cp === CODE_POINTS.SOLIDUS) {
            this.state = State.RAWTEXT_END_TAG_OPEN;
          } else {
            this._emitChars("<");
            this.state = State.RAWTEXT;
            this._stateRawtext(cp);
          }
        }
        _stateRawtextEndTagOpen(cp) {
          if (isAsciiLetter(cp)) {
            this.state = State.RAWTEXT_END_TAG_NAME;
            this._stateRawtextEndTagName(cp);
          } else {
            this._emitChars("</");
            this.state = State.RAWTEXT;
            this._stateRawtext(cp);
          }
        }
        _stateRawtextEndTagName(cp) {
          if (this.handleSpecialEndTag(cp)) {
            this._emitChars("</");
            this.state = State.RAWTEXT;
            this._stateRawtext(cp);
          }
        }
        _stateScriptDataLessThanSign(cp) {
          switch (cp) {
          case CODE_POINTS.SOLIDUS: {
              this.state = State.SCRIPT_DATA_END_TAG_OPEN;
              break;
            }
          case CODE_POINTS.EXCLAMATION_MARK: {
              this.state = State.SCRIPT_DATA_ESCAPE_START;
              this._emitChars("<!");
              break;
            }
          default: {
              this._emitChars("<");
              this.state = State.SCRIPT_DATA;
              this._stateScriptData(cp);
            }
          }
        }
        _stateScriptDataEndTagOpen(cp) {
          if (isAsciiLetter(cp)) {
            this.state = State.SCRIPT_DATA_END_TAG_NAME;
            this._stateScriptDataEndTagName(cp);
          } else {
            this._emitChars("</");
            this.state = State.SCRIPT_DATA;
            this._stateScriptData(cp);
          }
        }
        _stateScriptDataEndTagName(cp) {
          if (this.handleSpecialEndTag(cp)) {
            this._emitChars("</");
            this.state = State.SCRIPT_DATA;
            this._stateScriptData(cp);
          }
        }
        _stateScriptDataEscapeStart(cp) {
          if (cp === CODE_POINTS.HYPHEN_MINUS) {
            this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;
            this._emitChars("-");
          } else {
            this.state = State.SCRIPT_DATA;
            this._stateScriptData(cp);
          }
        }
        _stateScriptDataEscapeStartDash(cp) {
          if (cp === CODE_POINTS.HYPHEN_MINUS) {
            this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
            this._emitChars("-");
          } else {
            this.state = State.SCRIPT_DATA;
            this._stateScriptData(cp);
          }
        }
        _stateScriptDataEscaped(cp) {
          switch (cp) {
          case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.SCRIPT_DATA_ESCAPED_DASH;
              this._emitChars("-");
              break;
            }
          case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInScriptHtmlCommentLikeText);
              this._emitEOFToken();
              break;
            }
          default: {
              this._emitCodePoint(cp);
            }
          }
        }
        _stateScriptDataEscapedDash(cp) {
          switch (cp) {
          case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
              this._emitChars("-");
              break;
            }
          case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.state = State.SCRIPT_DATA_ESCAPED;
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInScriptHtmlCommentLikeText);
              this._emitEOFToken();
              break;
            }
          default: {
              this.state = State.SCRIPT_DATA_ESCAPED;
              this._emitCodePoint(cp);
            }
          }
        }
        _stateScriptDataEscapedDashDash(cp) {
          switch (cp) {
          case CODE_POINTS.HYPHEN_MINUS: {
              this._emitChars("-");
              break;
            }
          case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.SCRIPT_DATA;
              this._emitChars(">");
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.state = State.SCRIPT_DATA_ESCAPED;
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInScriptHtmlCommentLikeText);
              this._emitEOFToken();
              break;
            }
          default: {
              this.state = State.SCRIPT_DATA_ESCAPED;
              this._emitCodePoint(cp);
            }
          }
        }
        _stateScriptDataEscapedLessThanSign(cp) {
          if (cp === CODE_POINTS.SOLIDUS) {
            this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
          } else if (isAsciiLetter(cp)) {
            this._emitChars("<");
            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;
            this._stateScriptDataDoubleEscapeStart(cp);
          } else {
            this._emitChars("<");
            this.state = State.SCRIPT_DATA_ESCAPED;
            this._stateScriptDataEscaped(cp);
          }
        }
        _stateScriptDataEscapedEndTagOpen(cp) {
          if (isAsciiLetter(cp)) {
            this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
            this._stateScriptDataEscapedEndTagName(cp);
          } else {
            this._emitChars("</");
            this.state = State.SCRIPT_DATA_ESCAPED;
            this._stateScriptDataEscaped(cp);
          }
        }
        _stateScriptDataEscapedEndTagName(cp) {
          if (this.handleSpecialEndTag(cp)) {
            this._emitChars("</");
            this.state = State.SCRIPT_DATA_ESCAPED;
            this._stateScriptDataEscaped(cp);
          }
        }
        _stateScriptDataDoubleEscapeStart(cp) {
          if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
            this._emitCodePoint(cp);
            for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
              this._emitCodePoint(this._consume());
            }
            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
          } else if (!this._ensureHibernation()) {
            this.state = State.SCRIPT_DATA_ESCAPED;
            this._stateScriptDataEscaped(cp);
          }
        }
        _stateScriptDataDoubleEscaped(cp) {
          switch (cp) {
          case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
              this._emitChars("-");
              break;
            }
          case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
              this._emitChars("<");
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInScriptHtmlCommentLikeText);
              this._emitEOFToken();
              break;
            }
          default: {
              this._emitCodePoint(cp);
            }
          }
        }
        _stateScriptDataDoubleEscapedDash(cp) {
          switch (cp) {
          case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
              this._emitChars("-");
              break;
            }
          case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
              this._emitChars("<");
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInScriptHtmlCommentLikeText);
              this._emitEOFToken();
              break;
            }
          default: {
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
              this._emitCodePoint(cp);
            }
          }
        }
        _stateScriptDataDoubleEscapedDashDash(cp) {
          switch (cp) {
          case CODE_POINTS.HYPHEN_MINUS: {
              this._emitChars("-");
              break;
            }
          case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
              this._emitChars("<");
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.SCRIPT_DATA;
              this._emitChars(">");
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInScriptHtmlCommentLikeText);
              this._emitEOFToken();
              break;
            }
          default: {
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
              this._emitCodePoint(cp);
            }
          }
        }
        _stateScriptDataDoubleEscapedLessThanSign(cp) {
          if (cp === CODE_POINTS.SOLIDUS) {
            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;
            this._emitChars("/");
          } else {
            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
            this._stateScriptDataDoubleEscaped(cp);
          }
        }
        _stateScriptDataDoubleEscapeEnd(cp) {
          if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
            this._emitCodePoint(cp);
            for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
              this._emitCodePoint(this._consume());
            }
            this.state = State.SCRIPT_DATA_ESCAPED;
          } else if (!this._ensureHibernation()) {
            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
            this._stateScriptDataDoubleEscaped(cp);
          }
        }
        _stateBeforeAttributeName(cp) {
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              break;
            }
          case CODE_POINTS.SOLIDUS:
          case CODE_POINTS.GREATER_THAN_SIGN:
          case CODE_POINTS.EOF: {
              this.state = State.AFTER_ATTRIBUTE_NAME;
              this._stateAfterAttributeName(cp);
              break;
            }
          case CODE_POINTS.EQUALS_SIGN: {
              this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
              this._createAttr("=");
              this.state = State.ATTRIBUTE_NAME;
              break;
            }
          default: {
              this._createAttr("");
              this.state = State.ATTRIBUTE_NAME;
              this._stateAttributeName(cp);
            }
          }
        }
        _stateAttributeName(cp) {
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED:
          case CODE_POINTS.SOLIDUS:
          case CODE_POINTS.GREATER_THAN_SIGN:
          case CODE_POINTS.EOF: {
              this._leaveAttrName();
              this.state = State.AFTER_ATTRIBUTE_NAME;
              this._stateAfterAttributeName(cp);
              break;
            }
          case CODE_POINTS.EQUALS_SIGN: {
              this._leaveAttrName();
              this.state = State.BEFORE_ATTRIBUTE_VALUE;
              break;
            }
          case CODE_POINTS.QUOTATION_MARK:
          case CODE_POINTS.APOSTROPHE:
          case CODE_POINTS.LESS_THAN_SIGN: {
              this._err(ERR.unexpectedCharacterInAttributeName);
              this.currentAttr.name += String.fromCodePoint(cp);
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.currentAttr.name += REPLACEMENT_CHARACTER;
              break;
            }
          default: {
              this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
            }
          }
        }
        _stateAfterAttributeName(cp) {
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              break;
            }
          case CODE_POINTS.SOLIDUS: {
              this.state = State.SELF_CLOSING_START_TAG;
              break;
            }
          case CODE_POINTS.EQUALS_SIGN: {
              this.state = State.BEFORE_ATTRIBUTE_VALUE;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              this.emitCurrentTagToken();
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInTag);
              this._emitEOFToken();
              break;
            }
          default: {
              this._createAttr("");
              this.state = State.ATTRIBUTE_NAME;
              this._stateAttributeName(cp);
            }
          }
        }
        _stateBeforeAttributeValue(cp) {
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              break;
            }
          case CODE_POINTS.QUOTATION_MARK: {
              this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
              break;
            }
          case CODE_POINTS.APOSTROPHE: {
              this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.missingAttributeValue);
              this.state = State.DATA;
              this.emitCurrentTagToken();
              break;
            }
          default: {
              this.state = State.ATTRIBUTE_VALUE_UNQUOTED;
              this._stateAttributeValueUnquoted(cp);
            }
          }
        }
        _stateAttributeValueDoubleQuoted(cp) {
          switch (cp) {
          case CODE_POINTS.QUOTATION_MARK: {
              this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
              break;
            }
          case CODE_POINTS.AMPERSAND: {
              this.returnState = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
              this.state = State.CHARACTER_REFERENCE;
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.currentAttr.value += REPLACEMENT_CHARACTER;
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInTag);
              this._emitEOFToken();
              break;
            }
          default: {
              this.currentAttr.value += String.fromCodePoint(cp);
            }
          }
        }
        _stateAttributeValueSingleQuoted(cp) {
          switch (cp) {
          case CODE_POINTS.APOSTROPHE: {
              this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
              break;
            }
          case CODE_POINTS.AMPERSAND: {
              this.returnState = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
              this.state = State.CHARACTER_REFERENCE;
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.currentAttr.value += REPLACEMENT_CHARACTER;
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInTag);
              this._emitEOFToken();
              break;
            }
          default: {
              this.currentAttr.value += String.fromCodePoint(cp);
            }
          }
        }
        _stateAttributeValueUnquoted(cp) {
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              this._leaveAttrValue();
              this.state = State.BEFORE_ATTRIBUTE_NAME;
              break;
            }
          case CODE_POINTS.AMPERSAND: {
              this.returnState = State.ATTRIBUTE_VALUE_UNQUOTED;
              this.state = State.CHARACTER_REFERENCE;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._leaveAttrValue();
              this.state = State.DATA;
              this.emitCurrentTagToken();
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.currentAttr.value += REPLACEMENT_CHARACTER;
              break;
            }
          case CODE_POINTS.QUOTATION_MARK:
          case CODE_POINTS.APOSTROPHE:
          case CODE_POINTS.LESS_THAN_SIGN:
          case CODE_POINTS.EQUALS_SIGN:
          case CODE_POINTS.GRAVE_ACCENT: {
              this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
              this.currentAttr.value += String.fromCodePoint(cp);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInTag);
              this._emitEOFToken();
              break;
            }
          default: {
              this.currentAttr.value += String.fromCodePoint(cp);
            }
          }
        }
        _stateAfterAttributeValueQuoted(cp) {
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              this._leaveAttrValue();
              this.state = State.BEFORE_ATTRIBUTE_NAME;
              break;
            }
          case CODE_POINTS.SOLIDUS: {
              this._leaveAttrValue();
              this.state = State.SELF_CLOSING_START_TAG;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._leaveAttrValue();
              this.state = State.DATA;
              this.emitCurrentTagToken();
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInTag);
              this._emitEOFToken();
              break;
            }
          default: {
              this._err(ERR.missingWhitespaceBetweenAttributes);
              this.state = State.BEFORE_ATTRIBUTE_NAME;
              this._stateBeforeAttributeName(cp);
            }
          }
        }
        _stateSelfClosingStartTag(cp) {
          switch (cp) {
          case CODE_POINTS.GREATER_THAN_SIGN: {
              const token = this.currentToken;
              token.selfClosing = true;
              this.state = State.DATA;
              this.emitCurrentTagToken();
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInTag);
              this._emitEOFToken();
              break;
            }
          default: {
              this._err(ERR.unexpectedSolidusInTag);
              this.state = State.BEFORE_ATTRIBUTE_NAME;
              this._stateBeforeAttributeName(cp);
            }
          }
        }
        _stateBogusComment(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              this.emitCurrentComment(token);
              break;
            }
          case CODE_POINTS.EOF: {
              this.emitCurrentComment(token);
              this._emitEOFToken();
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.data += REPLACEMENT_CHARACTER;
              break;
            }
          default: {
              token.data += String.fromCodePoint(cp);
            }
          }
        }
        _stateMarkupDeclarationOpen(cp) {
          if (this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, true)) {
            this._createCommentToken(SEQUENCES.DASH_DASH.length + 1);
            this.state = State.COMMENT_START;
          } else if (this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, false)) {
            this.currentLocation = this.getCurrentLocation(SEQUENCES.DOCTYPE.length + 1);
            this.state = State.DOCTYPE;
          } else if (this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, true)) {
            if (this.inForeignNode) {
              this.state = State.CDATA_SECTION;
            } else {
              this._err(ERR.cdataInHtmlContent);
              this._createCommentToken(SEQUENCES.CDATA_START.length + 1);
              this.currentToken.data = "[CDATA[";
              this.state = State.BOGUS_COMMENT;
            }
          } else if (!this._ensureHibernation()) {
            this._err(ERR.incorrectlyOpenedComment);
            this._createCommentToken(2);
            this.state = State.BOGUS_COMMENT;
            this._stateBogusComment(cp);
          }
        }
        _stateCommentStart(cp) {
          switch (cp) {
          case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.COMMENT_START_DASH;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.abruptClosingOfEmptyComment);
              this.state = State.DATA;
              const token = this.currentToken;
              this.emitCurrentComment(token);
              break;
            }
          default: {
              this.state = State.COMMENT;
              this._stateComment(cp);
            }
          }
        }
        _stateCommentStartDash(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.COMMENT_END;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.abruptClosingOfEmptyComment);
              this.state = State.DATA;
              this.emitCurrentComment(token);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInComment);
              this.emitCurrentComment(token);
              this._emitEOFToken();
              break;
            }
          default: {
              token.data += "-";
              this.state = State.COMMENT;
              this._stateComment(cp);
            }
          }
        }
        _stateComment(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.COMMENT_END_DASH;
              break;
            }
          case CODE_POINTS.LESS_THAN_SIGN: {
              token.data += "<";
              this.state = State.COMMENT_LESS_THAN_SIGN;
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.data += REPLACEMENT_CHARACTER;
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInComment);
              this.emitCurrentComment(token);
              this._emitEOFToken();
              break;
            }
          default: {
              token.data += String.fromCodePoint(cp);
            }
          }
        }
        _stateCommentLessThanSign(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.EXCLAMATION_MARK: {
              token.data += "!";
              this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
              break;
            }
          case CODE_POINTS.LESS_THAN_SIGN: {
              token.data += "<";
              break;
            }
          default: {
              this.state = State.COMMENT;
              this._stateComment(cp);
            }
          }
        }
        _stateCommentLessThanSignBang(cp) {
          if (cp === CODE_POINTS.HYPHEN_MINUS) {
            this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;
          } else {
            this.state = State.COMMENT;
            this._stateComment(cp);
          }
        }
        _stateCommentLessThanSignBangDash(cp) {
          if (cp === CODE_POINTS.HYPHEN_MINUS) {
            this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
          } else {
            this.state = State.COMMENT_END_DASH;
            this._stateCommentEndDash(cp);
          }
        }
        _stateCommentLessThanSignBangDashDash(cp) {
          if (cp !== CODE_POINTS.GREATER_THAN_SIGN && cp !== CODE_POINTS.EOF) {
            this._err(ERR.nestedComment);
          }
          this.state = State.COMMENT_END;
          this._stateCommentEnd(cp);
        }
        _stateCommentEndDash(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.COMMENT_END;
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInComment);
              this.emitCurrentComment(token);
              this._emitEOFToken();
              break;
            }
          default: {
              token.data += "-";
              this.state = State.COMMENT;
              this._stateComment(cp);
            }
          }
        }
        _stateCommentEnd(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              this.emitCurrentComment(token);
              break;
            }
          case CODE_POINTS.EXCLAMATION_MARK: {
              this.state = State.COMMENT_END_BANG;
              break;
            }
          case CODE_POINTS.HYPHEN_MINUS: {
              token.data += "-";
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInComment);
              this.emitCurrentComment(token);
              this._emitEOFToken();
              break;
            }
          default: {
              token.data += "--";
              this.state = State.COMMENT;
              this._stateComment(cp);
            }
          }
        }
        _stateCommentEndBang(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.HYPHEN_MINUS: {
              token.data += "--!";
              this.state = State.COMMENT_END_DASH;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.incorrectlyClosedComment);
              this.state = State.DATA;
              this.emitCurrentComment(token);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInComment);
              this.emitCurrentComment(token);
              this._emitEOFToken();
              break;
            }
          default: {
              token.data += "--!";
              this.state = State.COMMENT;
              this._stateComment(cp);
            }
          }
        }
        _stateDoctype(cp) {
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              this.state = State.BEFORE_DOCTYPE_NAME;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.BEFORE_DOCTYPE_NAME;
              this._stateBeforeDoctypeName(cp);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              this._createDoctypeToken(null);
              const token = this.currentToken;
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          default: {
              this._err(ERR.missingWhitespaceBeforeDoctypeName);
              this.state = State.BEFORE_DOCTYPE_NAME;
              this._stateBeforeDoctypeName(cp);
            }
          }
        }
        _stateBeforeDoctypeName(cp) {
          if (isAsciiUpper(cp)) {
            this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
            this.state = State.DOCTYPE_NAME;
          } else
            switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
                break;
              }
            case CODE_POINTS.NULL: {
                this._err(ERR.unexpectedNullCharacter);
                this._createDoctypeToken(REPLACEMENT_CHARACTER);
                this.state = State.DOCTYPE_NAME;
                break;
              }
            case CODE_POINTS.GREATER_THAN_SIGN: {
                this._err(ERR.missingDoctypeName);
                this._createDoctypeToken(null);
                const token = this.currentToken;
                token.forceQuirks = true;
                this.emitCurrentDoctype(token);
                this.state = State.DATA;
                break;
              }
            case CODE_POINTS.EOF: {
                this._err(ERR.eofInDoctype);
                this._createDoctypeToken(null);
                const token = this.currentToken;
                token.forceQuirks = true;
                this.emitCurrentDoctype(token);
                this._emitEOFToken();
                break;
              }
            default: {
                this._createDoctypeToken(String.fromCodePoint(cp));
                this.state = State.DOCTYPE_NAME;
              }
            }
        }
        _stateDoctypeName(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              this.state = State.AFTER_DOCTYPE_NAME;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              this.emitCurrentDoctype(token);
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.name += REPLACEMENT_CHARACTER;
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          default: {
              token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
            }
          }
        }
        _stateAfterDoctypeName(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              this.emitCurrentDoctype(token);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          default:
            if (this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, false)) {
              this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;
            } else if (this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, false)) {
              this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;
            } else if (!this._ensureHibernation()) {
              this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
              token.forceQuirks = true;
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        _stateAfterDoctypePublicKeyword(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
              break;
            }
          case CODE_POINTS.QUOTATION_MARK: {
              this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
              token.publicId = "";
              this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
              break;
            }
          case CODE_POINTS.APOSTROPHE: {
              this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
              token.publicId = "";
              this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.missingDoctypePublicIdentifier);
              token.forceQuirks = true;
              this.state = State.DATA;
              this.emitCurrentDoctype(token);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          default: {
              this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
              token.forceQuirks = true;
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        _stateBeforeDoctypePublicIdentifier(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              break;
            }
          case CODE_POINTS.QUOTATION_MARK: {
              token.publicId = "";
              this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
              break;
            }
          case CODE_POINTS.APOSTROPHE: {
              token.publicId = "";
              this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.missingDoctypePublicIdentifier);
              token.forceQuirks = true;
              this.state = State.DATA;
              this.emitCurrentDoctype(token);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          default: {
              this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
              token.forceQuirks = true;
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        _stateDoctypePublicIdentifierDoubleQuoted(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.QUOTATION_MARK: {
              this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.publicId += REPLACEMENT_CHARACTER;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.abruptDoctypePublicIdentifier);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this.state = State.DATA;
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          default: {
              token.publicId += String.fromCodePoint(cp);
            }
          }
        }
        _stateDoctypePublicIdentifierSingleQuoted(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.APOSTROPHE: {
              this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.publicId += REPLACEMENT_CHARACTER;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.abruptDoctypePublicIdentifier);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this.state = State.DATA;
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          default: {
              token.publicId += String.fromCodePoint(cp);
            }
          }
        }
        _stateAfterDoctypePublicIdentifier(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              this.emitCurrentDoctype(token);
              break;
            }
          case CODE_POINTS.QUOTATION_MARK: {
              this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
              break;
            }
          case CODE_POINTS.APOSTROPHE: {
              this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          default: {
              this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this.emitCurrentDoctype(token);
              this.state = State.DATA;
              break;
            }
          case CODE_POINTS.QUOTATION_MARK: {
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
              break;
            }
          case CODE_POINTS.APOSTROPHE: {
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          default: {
              this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        _stateAfterDoctypeSystemKeyword(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
              break;
            }
          case CODE_POINTS.QUOTATION_MARK: {
              this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
              break;
            }
          case CODE_POINTS.APOSTROPHE: {
              this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.missingDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.state = State.DATA;
              this.emitCurrentDoctype(token);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          default: {
              this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        _stateBeforeDoctypeSystemIdentifier(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              break;
            }
          case CODE_POINTS.QUOTATION_MARK: {
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
              break;
            }
          case CODE_POINTS.APOSTROPHE: {
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.missingDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.state = State.DATA;
              this.emitCurrentDoctype(token);
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          default: {
              this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.QUOTATION_MARK: {
              this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.systemId += REPLACEMENT_CHARACTER;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.abruptDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this.state = State.DATA;
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          default: {
              token.systemId += String.fromCodePoint(cp);
            }
          }
        }
        _stateDoctypeSystemIdentifierSingleQuoted(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.APOSTROPHE: {
              this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.systemId += REPLACEMENT_CHARACTER;
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.abruptDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this.state = State.DATA;
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          default: {
              token.systemId += String.fromCodePoint(cp);
            }
          }
        }
        _stateAfterDoctypeSystemIdentifier(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
              break;
            }
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this.emitCurrentDoctype(token);
              this.state = State.DATA;
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          default: {
              this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        _stateBogusDoctype(cp) {
          const token = this.currentToken;
          switch (cp) {
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this.emitCurrentDoctype(token);
              this.state = State.DATA;
              break;
            }
          case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              break;
            }
          case CODE_POINTS.EOF: {
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
          }
        }
        _stateCdataSection(cp) {
          switch (cp) {
          case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
              this.state = State.CDATA_SECTION_BRACKET;
              break;
            }
          case CODE_POINTS.EOF: {
              this._err(ERR.eofInCdata);
              this._emitEOFToken();
              break;
            }
          default: {
              this._emitCodePoint(cp);
            }
          }
        }
        _stateCdataSectionBracket(cp) {
          if (cp === CODE_POINTS.RIGHT_SQUARE_BRACKET) {
            this.state = State.CDATA_SECTION_END;
          } else {
            this._emitChars("]");
            this.state = State.CDATA_SECTION;
            this._stateCdataSection(cp);
          }
        }
        _stateCdataSectionEnd(cp) {
          switch (cp) {
          case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              break;
            }
          case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
              this._emitChars("]");
              break;
            }
          default: {
              this._emitChars("]]");
              this.state = State.CDATA_SECTION;
              this._stateCdataSection(cp);
            }
          }
        }
        _stateCharacterReference(cp) {
          if (cp === CODE_POINTS.NUMBER_SIGN) {
            this.state = State.NUMERIC_CHARACTER_REFERENCE;
          } else if (isAsciiAlphaNumeric(cp)) {
            this.state = State.NAMED_CHARACTER_REFERENCE;
            this._stateNamedCharacterReference(cp);
          } else {
            this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
            this._reconsumeInState(this.returnState);
          }
        }
        _stateNamedCharacterReference(cp) {
          const matchResult = this._matchNamedCharacterReference(cp);
          if (this._ensureHibernation()) ; else if (matchResult) {
            for (let i = 0; i < matchResult.length; i++) {
              this._flushCodePointConsumedAsCharacterReference(matchResult[i]);
            }
            this.state = this.returnState;
          } else {
            this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
            this.state = State.AMBIGUOUS_AMPERSAND;
          }
        }
        _stateAmbiguousAmpersand(cp) {
          if (isAsciiAlphaNumeric(cp)) {
            this._flushCodePointConsumedAsCharacterReference(cp);
          } else {
            if (cp === CODE_POINTS.SEMICOLON) {
              this._err(ERR.unknownNamedCharacterReference);
            }
            this._reconsumeInState(this.returnState);
          }
        }
        _stateNumericCharacterReference(cp) {
          this.charRefCode = 0;
          if (cp === CODE_POINTS.LATIN_SMALL_X || cp === CODE_POINTS.LATIN_CAPITAL_X) {
            this.state = State.HEXADEMICAL_CHARACTER_REFERENCE_START;
          } else {
            this.state = State.DECIMAL_CHARACTER_REFERENCE_START;
            this._stateDecimalCharacterReferenceStart(cp);
          }
        }
        _stateHexademicalCharacterReferenceStart(cp) {
          if (isAsciiHexDigit(cp)) {
            this.state = State.HEXADEMICAL_CHARACTER_REFERENCE;
            this._stateHexademicalCharacterReference(cp);
          } else {
            this._err(ERR.absenceOfDigitsInNumericCharacterReference);
            this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
            this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
            this._unconsume(2);
            this.state = this.returnState;
          }
        }
        _stateDecimalCharacterReferenceStart(cp) {
          if (isAsciiDigit(cp)) {
            this.state = State.DECIMAL_CHARACTER_REFERENCE;
            this._stateDecimalCharacterReference(cp);
          } else {
            this._err(ERR.absenceOfDigitsInNumericCharacterReference);
            this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
            this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
            this._reconsumeInState(this.returnState);
          }
        }
        _stateHexademicalCharacterReference(cp) {
          if (isAsciiUpperHexDigit(cp)) {
            this.charRefCode = this.charRefCode * 16 + cp - 55;
          } else if (isAsciiLowerHexDigit(cp)) {
            this.charRefCode = this.charRefCode * 16 + cp - 87;
          } else if (isAsciiDigit(cp)) {
            this.charRefCode = this.charRefCode * 16 + cp - 48;
          } else if (cp === CODE_POINTS.SEMICOLON) {
            this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
          } else {
            this._err(ERR.missingSemicolonAfterCharacterReference);
            this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
            this._stateNumericCharacterReferenceEnd();
          }
        }
        _stateDecimalCharacterReference(cp) {
          if (isAsciiDigit(cp)) {
            this.charRefCode = this.charRefCode * 10 + cp - 48;
          } else if (cp === CODE_POINTS.SEMICOLON) {
            this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
          } else {
            this._err(ERR.missingSemicolonAfterCharacterReference);
            this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
            this._stateNumericCharacterReferenceEnd();
          }
        }
        _stateNumericCharacterReferenceEnd() {
          if (this.charRefCode === CODE_POINTS.NULL) {
            this._err(ERR.nullCharacterReference);
            this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
          } else if (this.charRefCode > 1114111) {
            this._err(ERR.characterReferenceOutsideUnicodeRange);
            this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
          } else if (isSurrogate(this.charRefCode)) {
            this._err(ERR.surrogateCharacterReference);
            this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
          } else if (isUndefinedCodePoint(this.charRefCode)) {
            this._err(ERR.noncharacterCharacterReference);
          } else if (isControlCodePoint(this.charRefCode) || this.charRefCode === CODE_POINTS.CARRIAGE_RETURN) {
            this._err(ERR.controlCharacterReference);
            const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS.get(this.charRefCode);
            if (replacement !== undefined) {
              this.charRefCode = replacement;
            }
          }
          this._flushCodePointConsumedAsCharacterReference(this.charRefCode);
          this._reconsumeInState(this.returnState);
        }
      }
      const IMPLICIT_END_TAG_REQUIRED = new Set([
        TAG_ID.DD,
        TAG_ID.DT,
        TAG_ID.LI,
        TAG_ID.OPTGROUP,
        TAG_ID.OPTION,
        TAG_ID.P,
        TAG_ID.RB,
        TAG_ID.RP,
        TAG_ID.RT,
        TAG_ID.RTC
      ]);
      const IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = new Set([
        ...IMPLICIT_END_TAG_REQUIRED,
        TAG_ID.CAPTION,
        TAG_ID.COLGROUP,
        TAG_ID.TBODY,
        TAG_ID.TD,
        TAG_ID.TFOOT,
        TAG_ID.TH,
        TAG_ID.THEAD,
        TAG_ID.TR
      ]);
      const SCOPING_ELEMENT_NS = new Map([
        [
          TAG_ID.APPLET,
          NS.HTML
        ],
        [
          TAG_ID.CAPTION,
          NS.HTML
        ],
        [
          TAG_ID.HTML,
          NS.HTML
        ],
        [
          TAG_ID.MARQUEE,
          NS.HTML
        ],
        [
          TAG_ID.OBJECT,
          NS.HTML
        ],
        [
          TAG_ID.TABLE,
          NS.HTML
        ],
        [
          TAG_ID.TD,
          NS.HTML
        ],
        [
          TAG_ID.TEMPLATE,
          NS.HTML
        ],
        [
          TAG_ID.TH,
          NS.HTML
        ],
        [
          TAG_ID.ANNOTATION_XML,
          NS.MATHML
        ],
        [
          TAG_ID.MI,
          NS.MATHML
        ],
        [
          TAG_ID.MN,
          NS.MATHML
        ],
        [
          TAG_ID.MO,
          NS.MATHML
        ],
        [
          TAG_ID.MS,
          NS.MATHML
        ],
        [
          TAG_ID.MTEXT,
          NS.MATHML
        ],
        [
          TAG_ID.DESC,
          NS.SVG
        ],
        [
          TAG_ID.FOREIGN_OBJECT,
          NS.SVG
        ],
        [
          TAG_ID.TITLE,
          NS.SVG
        ]
      ]);
      const NAMED_HEADERS = [
        TAG_ID.H1,
        TAG_ID.H2,
        TAG_ID.H3,
        TAG_ID.H4,
        TAG_ID.H5,
        TAG_ID.H6
      ];
      const TABLE_ROW_CONTEXT = [
        TAG_ID.TR,
        TAG_ID.TEMPLATE,
        TAG_ID.HTML
      ];
      const TABLE_BODY_CONTEXT = [
        TAG_ID.TBODY,
        TAG_ID.TFOOT,
        TAG_ID.THEAD,
        TAG_ID.TEMPLATE,
        TAG_ID.HTML
      ];
      const TABLE_CONTEXT = [
        TAG_ID.TABLE,
        TAG_ID.TEMPLATE,
        TAG_ID.HTML
      ];
      const TABLE_CELLS = [
        TAG_ID.TD,
        TAG_ID.TH
      ];
      class OpenElementStack {
        constructor(document, treeAdapter, handler) {
          this.treeAdapter = treeAdapter;
          this.handler = handler;
          this.items = [];
          this.tagIDs = [];
          this.stackTop = -1;
          this.tmplCount = 0;
          this.currentTagId = TAG_ID.UNKNOWN;
          this.current = document;
        }
        get currentTmplContentOrNode() {
          return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
        }
        _indexOf(element) {
          return this.items.lastIndexOf(element, this.stackTop);
        }
        _isInTemplate() {
          return this.currentTagId === TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
        }
        _updateCurrentElement() {
          this.current = this.items[this.stackTop];
          this.currentTagId = this.tagIDs[this.stackTop];
        }
        push(element, tagID) {
          this.stackTop++;
          this.items[this.stackTop] = element;
          this.current = element;
          this.tagIDs[this.stackTop] = tagID;
          this.currentTagId = tagID;
          if (this._isInTemplate()) {
            this.tmplCount++;
          }
          this.handler.onItemPush(element, tagID, true);
        }
        pop() {
          const popped = this.current;
          if (this.tmplCount > 0 && this._isInTemplate()) {
            this.tmplCount--;
          }
          this.stackTop--;
          this._updateCurrentElement();
          this.handler.onItemPop(popped, true);
        }
        replace(oldElement, newElement) {
          const idx = this._indexOf(oldElement);
          this.items[idx] = newElement;
          if (idx === this.stackTop) {
            this.current = newElement;
          }
        }
        insertAfter(referenceElement, newElement, newElementID) {
          const insertionIdx = this._indexOf(referenceElement) + 1;
          this.items.splice(insertionIdx, 0, newElement);
          this.tagIDs.splice(insertionIdx, 0, newElementID);
          this.stackTop++;
          if (insertionIdx === this.stackTop) {
            this._updateCurrentElement();
          }
          this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
        }
        popUntilTagNamePopped(tagName) {
          let targetIdx = this.stackTop + 1;
          do {
            targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
          } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML);
          this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);
        }
        shortenToLength(idx) {
          while (this.stackTop >= idx) {
            const popped = this.current;
            if (this.tmplCount > 0 && this._isInTemplate()) {
              this.tmplCount -= 1;
            }
            this.stackTop--;
            this._updateCurrentElement();
            this.handler.onItemPop(popped, this.stackTop < idx);
          }
        }
        popUntilElementPopped(element) {
          const idx = this._indexOf(element);
          this.shortenToLength(idx < 0 ? 0 : idx);
        }
        popUntilPopped(tagNames, targetNS) {
          const idx = this._indexOfTagNames(tagNames, targetNS);
          this.shortenToLength(idx < 0 ? 0 : idx);
        }
        popUntilNumberedHeaderPopped() {
          this.popUntilPopped(NAMED_HEADERS, NS.HTML);
        }
        popUntilTableCellPopped() {
          this.popUntilPopped(TABLE_CELLS, NS.HTML);
        }
        popAllUpToHtmlElement() {
          this.tmplCount = 0;
          this.shortenToLength(1);
        }
        _indexOfTagNames(tagNames, namespace) {
          for (let i = this.stackTop; i >= 0; i--) {
            if (tagNames.includes(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {
              return i;
            }
          }
          return -1;
        }
        clearBackTo(tagNames, targetNS) {
          const idx = this._indexOfTagNames(tagNames, targetNS);
          this.shortenToLength(idx + 1);
        }
        clearBackToTableContext() {
          this.clearBackTo(TABLE_CONTEXT, NS.HTML);
        }
        clearBackToTableBodyContext() {
          this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);
        }
        clearBackToTableRowContext() {
          this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);
        }
        remove(element) {
          const idx = this._indexOf(element);
          if (idx >= 0) {
            if (idx === this.stackTop) {
              this.pop();
            } else {
              this.items.splice(idx, 1);
              this.tagIDs.splice(idx, 1);
              this.stackTop--;
              this._updateCurrentElement();
              this.handler.onItemPop(element, false);
            }
          }
        }
        tryPeekProperlyNestedBodyElement() {
          return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY ? this.items[1] : null;
        }
        contains(element) {
          return this._indexOf(element) > -1;
        }
        getCommonAncestor(element) {
          const elementIdx = this._indexOf(element) - 1;
          return elementIdx >= 0 ? this.items[elementIdx] : null;
        }
        isRootHtmlElementCurrent() {
          return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
        }
        hasInScope(tagName) {
          for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.tagIDs[i];
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
            if (tn === tagName && ns === NS.HTML) {
              return true;
            }
            if (SCOPING_ELEMENT_NS.get(tn) === ns) {
              return false;
            }
          }
          return true;
        }
        hasNumberedHeaderInScope() {
          for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.tagIDs[i];
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
            if (isNumberedHeader(tn) && ns === NS.HTML) {
              return true;
            }
            if (SCOPING_ELEMENT_NS.get(tn) === ns) {
              return false;
            }
          }
          return true;
        }
        hasInListItemScope(tagName) {
          for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.tagIDs[i];
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
            if (tn === tagName && ns === NS.HTML) {
              return true;
            }
            if ((tn === TAG_ID.UL || tn === TAG_ID.OL) && ns === NS.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
              return false;
            }
          }
          return true;
        }
        hasInButtonScope(tagName) {
          for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.tagIDs[i];
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
            if (tn === tagName && ns === NS.HTML) {
              return true;
            }
            if (tn === TAG_ID.BUTTON && ns === NS.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
              return false;
            }
          }
          return true;
        }
        hasInTableScope(tagName) {
          for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.tagIDs[i];
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
            if (ns !== NS.HTML) {
              continue;
            }
            if (tn === tagName) {
              return true;
            }
            if (tn === TAG_ID.TABLE || tn === TAG_ID.TEMPLATE || tn === TAG_ID.HTML) {
              return false;
            }
          }
          return true;
        }
        hasTableBodyContextInTableScope() {
          for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.tagIDs[i];
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
            if (ns !== NS.HTML) {
              continue;
            }
            if (tn === TAG_ID.TBODY || tn === TAG_ID.THEAD || tn === TAG_ID.TFOOT) {
              return true;
            }
            if (tn === TAG_ID.TABLE || tn === TAG_ID.HTML) {
              return false;
            }
          }
          return true;
        }
        hasInSelectScope(tagName) {
          for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.tagIDs[i];
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
            if (ns !== NS.HTML) {
              continue;
            }
            if (tn === tagName) {
              return true;
            }
            if (tn !== TAG_ID.OPTION && tn !== TAG_ID.OPTGROUP) {
              return false;
            }
          }
          return true;
        }
        generateImpliedEndTags() {
          while (IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
            this.pop();
          }
        }
        generateImpliedEndTagsThoroughly() {
          while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
            this.pop();
          }
        }
        generateImpliedEndTagsWithExclusion(exclusionId) {
          while (this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
            this.pop();
          }
        }
      }
      const NOAH_ARK_CAPACITY = 3;
      var EntryType;
      (function (EntryType) {
        EntryType[EntryType["Marker"] = 0] = "Marker";
        EntryType[EntryType["Element"] = 1] = "Element";
      }(EntryType || (EntryType = {})));
      const MARKER = { type: EntryType.Marker };
      class FormattingElementList {
        constructor(treeAdapter) {
          this.treeAdapter = treeAdapter;
          this.entries = [];
          this.bookmark = null;
        }
        _getNoahArkConditionCandidates(newElement, neAttrs) {
          const candidates = [];
          const neAttrsLength = neAttrs.length;
          const neTagName = this.treeAdapter.getTagName(newElement);
          const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
          for (let i = 0; i < this.entries.length; i++) {
            const entry = this.entries[i];
            if (entry.type === EntryType.Marker) {
              break;
            }
            const {element} = entry;
            if (this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {
              const elementAttrs = this.treeAdapter.getAttrList(element);
              if (elementAttrs.length === neAttrsLength) {
                candidates.push({
                  idx: i,
                  attrs: elementAttrs
                });
              }
            }
          }
          return candidates;
        }
        _ensureNoahArkCondition(newElement) {
          if (this.entries.length < NOAH_ARK_CAPACITY)
            return;
          const neAttrs = this.treeAdapter.getAttrList(newElement);
          const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
          if (candidates.length < NOAH_ARK_CAPACITY)
            return;
          const neAttrsMap = new Map(neAttrs.map(neAttr => [
            neAttr.name,
            neAttr.value
          ]));
          let validCandidates = 0;
          for (let i = 0; i < candidates.length; i++) {
            const candidate = candidates[i];
            if (candidate.attrs.every(cAttr => neAttrsMap.get(cAttr.name) === cAttr.value)) {
              validCandidates += 1;
              if (validCandidates >= NOAH_ARK_CAPACITY) {
                this.entries.splice(candidate.idx, 1);
              }
            }
          }
        }
        insertMarker() {
          this.entries.unshift(MARKER);
        }
        pushElement(element, token) {
          this._ensureNoahArkCondition(element);
          this.entries.unshift({
            type: EntryType.Element,
            element,
            token
          });
        }
        insertElementAfterBookmark(element, token) {
          const bookmarkIdx = this.entries.indexOf(this.bookmark);
          this.entries.splice(bookmarkIdx, 0, {
            type: EntryType.Element,
            element,
            token
          });
        }
        removeEntry(entry) {
          const entryIndex = this.entries.indexOf(entry);
          if (entryIndex >= 0) {
            this.entries.splice(entryIndex, 1);
          }
        }
        clearToLastMarker() {
          const markerIdx = this.entries.indexOf(MARKER);
          if (markerIdx >= 0) {
            this.entries.splice(0, markerIdx + 1);
          } else {
            this.entries.length = 0;
          }
        }
        getElementEntryInScopeWithTagName(tagName) {
          const entry = this.entries.find(entry => entry.type === EntryType.Marker || this.treeAdapter.getTagName(entry.element) === tagName);
          return entry && entry.type === EntryType.Element ? entry : null;
        }
        getElementEntry(element) {
          return this.entries.find(entry => entry.type === EntryType.Element && entry.element === element);
        }
      }
      var NodeType;
      (function (NodeType) {
        NodeType["Document"] = "#document";
        NodeType["DocumentFragment"] = "#document-fragment";
        NodeType["Comment"] = "#comment";
        NodeType["Text"] = "#text";
        NodeType["DocumentType"] = "#documentType";
      }(NodeType || (NodeType = {})));
      function createTextNode(value) {
        return {
          nodeName: NodeType.Text,
          value,
          parentNode: null
        };
      }
      const defaultTreeAdapter = {
        createDocument() {
          return {
            nodeName: NodeType.Document,
            mode: DOCUMENT_MODE.NO_QUIRKS,
            childNodes: []
          };
        },
        createDocumentFragment() {
          return {
            nodeName: NodeType.DocumentFragment,
            childNodes: []
          };
        },
        createElement(tagName, namespaceURI, attrs) {
          return {
            nodeName: tagName,
            tagName,
            attrs,
            namespaceURI,
            childNodes: [],
            parentNode: null
          };
        },
        createCommentNode(data) {
          return {
            nodeName: NodeType.Comment,
            data,
            parentNode: null
          };
        },
        appendChild(parentNode, newNode) {
          parentNode.childNodes.push(newNode);
          newNode.parentNode = parentNode;
        },
        insertBefore(parentNode, newNode, referenceNode) {
          const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
          parentNode.childNodes.splice(insertionIdx, 0, newNode);
          newNode.parentNode = parentNode;
        },
        setTemplateContent(templateElement, contentElement) {
          templateElement.content = contentElement;
        },
        getTemplateContent(templateElement) {
          return templateElement.content;
        },
        setDocumentType(document, name, publicId, systemId) {
          const doctypeNode = document.childNodes.find(node => node.nodeName === NodeType.DocumentType);
          if (doctypeNode) {
            doctypeNode.name = name;
            doctypeNode.publicId = publicId;
            doctypeNode.systemId = systemId;
          } else {
            const node = {
              nodeName: NodeType.DocumentType,
              name,
              publicId,
              systemId,
              parentNode: null
            };
            defaultTreeAdapter.appendChild(document, node);
          }
        },
        setDocumentMode(document, mode) {
          document.mode = mode;
        },
        getDocumentMode(document) {
          return document.mode;
        },
        detachNode(node) {
          if (node.parentNode) {
            const idx = node.parentNode.childNodes.indexOf(node);
            node.parentNode.childNodes.splice(idx, 1);
            node.parentNode = null;
          }
        },
        insertText(parentNode, text) {
          if (parentNode.childNodes.length > 0) {
            const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
            if (defaultTreeAdapter.isTextNode(prevNode)) {
              prevNode.value += text;
              return;
            }
          }
          defaultTreeAdapter.appendChild(parentNode, createTextNode(text));
        },
        insertTextBefore(parentNode, text, referenceNode) {
          const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
          if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) {
            prevNode.value += text;
          } else {
            defaultTreeAdapter.insertBefore(parentNode, createTextNode(text), referenceNode);
          }
        },
        adoptAttributes(recipient, attrs) {
          const recipientAttrsMap = new Set(recipient.attrs.map(attr => attr.name));
          for (let j = 0; j < attrs.length; j++) {
            if (!recipientAttrsMap.has(attrs[j].name)) {
              recipient.attrs.push(attrs[j]);
            }
          }
        },
        getFirstChild(node) {
          return node.childNodes[0];
        },
        getChildNodes(node) {
          return node.childNodes;
        },
        getParentNode(node) {
          return node.parentNode;
        },
        getAttrList(element) {
          return element.attrs;
        },
        getTagName(element) {
          return element.tagName;
        },
        getNamespaceURI(element) {
          return element.namespaceURI;
        },
        getTextNodeContent(textNode) {
          return textNode.value;
        },
        getCommentNodeContent(commentNode) {
          return commentNode.data;
        },
        getDocumentTypeNodeName(doctypeNode) {
          return doctypeNode.name;
        },
        getDocumentTypeNodePublicId(doctypeNode) {
          return doctypeNode.publicId;
        },
        getDocumentTypeNodeSystemId(doctypeNode) {
          return doctypeNode.systemId;
        },
        isTextNode(node) {
          return node.nodeName === "#text";
        },
        isCommentNode(node) {
          return node.nodeName === "#comment";
        },
        isDocumentTypeNode(node) {
          return node.nodeName === NodeType.DocumentType;
        },
        isElementNode(node) {
          return Object.prototype.hasOwnProperty.call(node, "tagName");
        },
        setNodeSourceCodeLocation(node, location) {
          node.sourceCodeLocation = location;
        },
        getNodeSourceCodeLocation(node) {
          return node.sourceCodeLocation;
        },
        updateNodeSourceCodeLocation(node, endLocation) {
          node.sourceCodeLocation = {
            ...node.sourceCodeLocation,
            ...endLocation
          };
        }
      };
      const VALID_DOCTYPE_NAME = "html";
      const VALID_SYSTEM_ID = "about:legacy-compat";
      const QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
      const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
        "+//silmaril//dtd html pro v0r11 19970101//",
        "-//as//dtd html 3.0 aswedit + extensions//",
        "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
        "-//ietf//dtd html 2.0 level 1//",
        "-//ietf//dtd html 2.0 level 2//",
        "-//ietf//dtd html 2.0 strict level 1//",
        "-//ietf//dtd html 2.0 strict level 2//",
        "-//ietf//dtd html 2.0 strict//",
        "-//ietf//dtd html 2.0//",
        "-//ietf//dtd html 2.1e//",
        "-//ietf//dtd html 3.0//",
        "-//ietf//dtd html 3.2 final//",
        "-//ietf//dtd html 3.2//",
        "-//ietf//dtd html 3//",
        "-//ietf//dtd html level 0//",
        "-//ietf//dtd html level 1//",
        "-//ietf//dtd html level 2//",
        "-//ietf//dtd html level 3//",
        "-//ietf//dtd html strict level 0//",
        "-//ietf//dtd html strict level 1//",
        "-//ietf//dtd html strict level 2//",
        "-//ietf//dtd html strict level 3//",
        "-//ietf//dtd html strict//",
        "-//ietf//dtd html//",
        "-//metrius//dtd metrius presentational//",
        "-//microsoft//dtd internet explorer 2.0 html strict//",
        "-//microsoft//dtd internet explorer 2.0 html//",
        "-//microsoft//dtd internet explorer 2.0 tables//",
        "-//microsoft//dtd internet explorer 3.0 html strict//",
        "-//microsoft//dtd internet explorer 3.0 html//",
        "-//microsoft//dtd internet explorer 3.0 tables//",
        "-//netscape comm. corp.//dtd html//",
        "-//netscape comm. corp.//dtd strict html//",
        "-//o'reilly and associates//dtd html 2.0//",
        "-//o'reilly and associates//dtd html extended 1.0//",
        "-//o'reilly and associates//dtd html extended relaxed 1.0//",
        "-//sq//dtd html 2.0 hotmetal + extensions//",
        "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
        "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
        "-//spyglass//dtd html 2.0 extended//",
        "-//sun microsystems corp.//dtd hotjava html//",
        "-//sun microsystems corp.//dtd hotjava strict html//",
        "-//w3c//dtd html 3 1995-03-24//",
        "-//w3c//dtd html 3.2 draft//",
        "-//w3c//dtd html 3.2 final//",
        "-//w3c//dtd html 3.2//",
        "-//w3c//dtd html 3.2s draft//",
        "-//w3c//dtd html 4.0 frameset//",
        "-//w3c//dtd html 4.0 transitional//",
        "-//w3c//dtd html experimental 19960712//",
        "-//w3c//dtd html experimental 970421//",
        "-//w3c//dtd w3 html//",
        "-//w3o//dtd w3 html 3.0//",
        "-//webtechs//dtd mozilla html 2.0//",
        "-//webtechs//dtd mozilla html//"
      ];
      const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
        ...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
        "-//w3c//dtd html 4.01 frameset//",
        "-//w3c//dtd html 4.01 transitional//"
      ];
      const QUIRKS_MODE_PUBLIC_IDS = new Set([
        "-//w3o//dtd w3 html strict 3.0//en//",
        "-/w3c/dtd html 4.0 transitional/en",
        "html"
      ]);
      const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = [
        "-//w3c//dtd xhtml 1.0 frameset//",
        "-//w3c//dtd xhtml 1.0 transitional//"
      ];
      const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
        ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
        "-//w3c//dtd html 4.01 frameset//",
        "-//w3c//dtd html 4.01 transitional//"
      ];
      function hasPrefix(publicId, prefixes) {
        return prefixes.some(prefix => publicId.startsWith(prefix));
      }
      function isConforming(token) {
        return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
      }
      function getDocumentMode(token) {
        if (token.name !== VALID_DOCTYPE_NAME) {
          return DOCUMENT_MODE.QUIRKS;
        }
        const {systemId} = token;
        if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
          return DOCUMENT_MODE.QUIRKS;
        }
        let {publicId} = token;
        if (publicId !== null) {
          publicId = publicId.toLowerCase();
          if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
            return DOCUMENT_MODE.QUIRKS;
          }
          let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
          if (hasPrefix(publicId, prefixes)) {
            return DOCUMENT_MODE.QUIRKS;
          }
          prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
          if (hasPrefix(publicId, prefixes)) {
            return DOCUMENT_MODE.LIMITED_QUIRKS;
          }
        }
        return DOCUMENT_MODE.NO_QUIRKS;
      }
      const MIME_TYPES = {
        TEXT_HTML: "text/html",
        APPLICATION_XML: "application/xhtml+xml"
      };
      const DEFINITION_URL_ATTR = "definitionurl";
      const ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
      const SVG_ATTRS_ADJUSTMENT_MAP = new Map([
        "attributeName",
        "attributeType",
        "baseFrequency",
        "baseProfile",
        "calcMode",
        "clipPathUnits",
        "diffuseConstant",
        "edgeMode",
        "filterUnits",
        "glyphRef",
        "gradientTransform",
        "gradientUnits",
        "kernelMatrix",
        "kernelUnitLength",
        "keyPoints",
        "keySplines",
        "keyTimes",
        "lengthAdjust",
        "limitingConeAngle",
        "markerHeight",
        "markerUnits",
        "markerWidth",
        "maskContentUnits",
        "maskUnits",
        "numOctaves",
        "pathLength",
        "patternContentUnits",
        "patternTransform",
        "patternUnits",
        "pointsAtX",
        "pointsAtY",
        "pointsAtZ",
        "preserveAlpha",
        "preserveAspectRatio",
        "primitiveUnits",
        "refX",
        "refY",
        "repeatCount",
        "repeatDur",
        "requiredExtensions",
        "requiredFeatures",
        "specularConstant",
        "specularExponent",
        "spreadMethod",
        "startOffset",
        "stdDeviation",
        "stitchTiles",
        "surfaceScale",
        "systemLanguage",
        "tableValues",
        "targetX",
        "targetY",
        "textLength",
        "viewBox",
        "viewTarget",
        "xChannelSelector",
        "yChannelSelector",
        "zoomAndPan"
      ].map(attr => [
        attr.toLowerCase(),
        attr
      ]));
      const XML_ATTRS_ADJUSTMENT_MAP = new Map([
        [
          "xlink:actuate",
          {
            prefix: "xlink",
            name: "actuate",
            namespace: NS.XLINK
          }
        ],
        [
          "xlink:arcrole",
          {
            prefix: "xlink",
            name: "arcrole",
            namespace: NS.XLINK
          }
        ],
        [
          "xlink:href",
          {
            prefix: "xlink",
            name: "href",
            namespace: NS.XLINK
          }
        ],
        [
          "xlink:role",
          {
            prefix: "xlink",
            name: "role",
            namespace: NS.XLINK
          }
        ],
        [
          "xlink:show",
          {
            prefix: "xlink",
            name: "show",
            namespace: NS.XLINK
          }
        ],
        [
          "xlink:title",
          {
            prefix: "xlink",
            name: "title",
            namespace: NS.XLINK
          }
        ],
        [
          "xlink:type",
          {
            prefix: "xlink",
            name: "type",
            namespace: NS.XLINK
          }
        ],
        [
          "xml:base",
          {
            prefix: "xml",
            name: "base",
            namespace: NS.XML
          }
        ],
        [
          "xml:lang",
          {
            prefix: "xml",
            name: "lang",
            namespace: NS.XML
          }
        ],
        [
          "xml:space",
          {
            prefix: "xml",
            name: "space",
            namespace: NS.XML
          }
        ],
        [
          "xmlns",
          {
            prefix: "",
            name: "xmlns",
            namespace: NS.XMLNS
          }
        ],
        [
          "xmlns:xlink",
          {
            prefix: "xmlns",
            name: "xlink",
            namespace: NS.XMLNS
          }
        ]
      ]);
      const SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "clipPath",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "foreignObject",
        "glyphRef",
        "linearGradient",
        "radialGradient",
        "textPath"
      ].map(tn => [
        tn.toLowerCase(),
        tn
      ]));
      const EXITS_FOREIGN_CONTENT = new Set([
        TAG_ID.B,
        TAG_ID.BIG,
        TAG_ID.BLOCKQUOTE,
        TAG_ID.BODY,
        TAG_ID.BR,
        TAG_ID.CENTER,
        TAG_ID.CODE,
        TAG_ID.DD,
        TAG_ID.DIV,
        TAG_ID.DL,
        TAG_ID.DT,
        TAG_ID.EM,
        TAG_ID.EMBED,
        TAG_ID.H1,
        TAG_ID.H2,
        TAG_ID.H3,
        TAG_ID.H4,
        TAG_ID.H5,
        TAG_ID.H6,
        TAG_ID.HEAD,
        TAG_ID.HR,
        TAG_ID.I,
        TAG_ID.IMG,
        TAG_ID.LI,
        TAG_ID.LISTING,
        TAG_ID.MENU,
        TAG_ID.META,
        TAG_ID.NOBR,
        TAG_ID.OL,
        TAG_ID.P,
        TAG_ID.PRE,
        TAG_ID.RUBY,
        TAG_ID.S,
        TAG_ID.SMALL,
        TAG_ID.SPAN,
        TAG_ID.STRONG,
        TAG_ID.STRIKE,
        TAG_ID.SUB,
        TAG_ID.SUP,
        TAG_ID.TABLE,
        TAG_ID.TT,
        TAG_ID.U,
        TAG_ID.UL,
        TAG_ID.VAR
      ]);
      function causesExit(startTagToken) {
        const tn = startTagToken.tagID;
        const isFontWithAttrs = tn === TAG_ID.FONT && startTagToken.attrs.some(({name}) => name === ATTRS.COLOR || name === ATTRS.SIZE || name === ATTRS.FACE);
        return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
      }
      function adjustTokenMathMLAttrs(token) {
        for (let i = 0; i < token.attrs.length; i++) {
          if (token.attrs[i].name === DEFINITION_URL_ATTR) {
            token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
            break;
          }
        }
      }
      function adjustTokenSVGAttrs(token) {
        for (let i = 0; i < token.attrs.length; i++) {
          const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
          if (adjustedAttrName != null) {
            token.attrs[i].name = adjustedAttrName;
          }
        }
      }
      function adjustTokenXMLAttrs(token) {
        for (let i = 0; i < token.attrs.length; i++) {
          const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
          if (adjustedAttrEntry) {
            token.attrs[i].prefix = adjustedAttrEntry.prefix;
            token.attrs[i].name = adjustedAttrEntry.name;
            token.attrs[i].namespace = adjustedAttrEntry.namespace;
          }
        }
      }
      function adjustTokenSVGTagName(token) {
        const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
        if (adjustedTagName != null) {
          token.tagName = adjustedTagName;
          token.tagID = getTagID(token.tagName);
        }
      }
      function isMathMLTextIntegrationPoint(tn, ns) {
        return ns === NS.MATHML && (tn === TAG_ID.MI || tn === TAG_ID.MO || tn === TAG_ID.MN || tn === TAG_ID.MS || tn === TAG_ID.MTEXT);
      }
      function isHtmlIntegrationPoint(tn, ns, attrs) {
        if (ns === NS.MATHML && tn === TAG_ID.ANNOTATION_XML) {
          for (let i = 0; i < attrs.length; i++) {
            if (attrs[i].name === ATTRS.ENCODING) {
              const value = attrs[i].value.toLowerCase();
              return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
            }
          }
        }
        return ns === NS.SVG && (tn === TAG_ID.FOREIGN_OBJECT || tn === TAG_ID.DESC || tn === TAG_ID.TITLE);
      }
      function isIntegrationPoint(tn, ns, attrs, foreignNS) {
        return (!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs) || (!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns);
      }
      var foreignContent$1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        SVG_TAG_NAMES_ADJUSTMENT_MAP: SVG_TAG_NAMES_ADJUSTMENT_MAP,
        causesExit: causesExit,
        adjustTokenMathMLAttrs: adjustTokenMathMLAttrs,
        adjustTokenSVGAttrs: adjustTokenSVGAttrs,
        adjustTokenXMLAttrs: adjustTokenXMLAttrs,
        adjustTokenSVGTagName: adjustTokenSVGTagName,
        isIntegrationPoint: isIntegrationPoint
      }, Symbol.toStringTag, { value: "Module" }));
      const HIDDEN_INPUT_TYPE = "hidden";
      const AA_OUTER_LOOP_ITER = 8;
      const AA_INNER_LOOP_ITER = 3;
      var InsertionMode;
      (function (InsertionMode) {
        InsertionMode[InsertionMode["INITIAL"] = 0] = "INITIAL";
        InsertionMode[InsertionMode["BEFORE_HTML"] = 1] = "BEFORE_HTML";
        InsertionMode[InsertionMode["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
        InsertionMode[InsertionMode["IN_HEAD"] = 3] = "IN_HEAD";
        InsertionMode[InsertionMode["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
        InsertionMode[InsertionMode["AFTER_HEAD"] = 5] = "AFTER_HEAD";
        InsertionMode[InsertionMode["IN_BODY"] = 6] = "IN_BODY";
        InsertionMode[InsertionMode["TEXT"] = 7] = "TEXT";
        InsertionMode[InsertionMode["IN_TABLE"] = 8] = "IN_TABLE";
        InsertionMode[InsertionMode["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
        InsertionMode[InsertionMode["IN_CAPTION"] = 10] = "IN_CAPTION";
        InsertionMode[InsertionMode["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
        InsertionMode[InsertionMode["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
        InsertionMode[InsertionMode["IN_ROW"] = 13] = "IN_ROW";
        InsertionMode[InsertionMode["IN_CELL"] = 14] = "IN_CELL";
        InsertionMode[InsertionMode["IN_SELECT"] = 15] = "IN_SELECT";
        InsertionMode[InsertionMode["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
        InsertionMode[InsertionMode["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
        InsertionMode[InsertionMode["AFTER_BODY"] = 18] = "AFTER_BODY";
        InsertionMode[InsertionMode["IN_FRAMESET"] = 19] = "IN_FRAMESET";
        InsertionMode[InsertionMode["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
        InsertionMode[InsertionMode["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
        InsertionMode[InsertionMode["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
      }(InsertionMode || (InsertionMode = {})));
      const BASE_LOC = {
        startLine: -1,
        startCol: -1,
        startOffset: -1,
        endLine: -1,
        endCol: -1,
        endOffset: -1
      };
      const TABLE_STRUCTURE_TAGS = new Set([
        TAG_ID.TABLE,
        TAG_ID.TBODY,
        TAG_ID.TFOOT,
        TAG_ID.THEAD,
        TAG_ID.TR
      ]);
      const defaultParserOptions = {
        scriptingEnabled: true,
        sourceCodeLocationInfo: false,
        treeAdapter: defaultTreeAdapter,
        onParseError: null
      };
      class Parser {
        constructor(options, document, fragmentContext = null, scriptHandler = null) {
          this.fragmentContext = fragmentContext;
          this.scriptHandler = scriptHandler;
          this.currentToken = null;
          this.stopped = false;
          this.insertionMode = InsertionMode.INITIAL;
          this.originalInsertionMode = InsertionMode.INITIAL;
          this.headElement = null;
          this.formElement = null;
          this.currentNotInHTML = false;
          this.tmplInsertionModeStack = [];
          this.pendingCharacterTokens = [];
          this.hasNonWhitespacePendingCharacterToken = false;
          this.framesetOk = true;
          this.skipNextNewLine = false;
          this.fosterParentingEnabled = false;
          this.options = {
            ...defaultParserOptions,
            ...options
          };
          this.treeAdapter = this.options.treeAdapter;
          this.onParseError = this.options.onParseError;
          if (this.onParseError) {
            this.options.sourceCodeLocationInfo = true;
          }
          this.document = document !== null && document !== void 0 ? document : this.treeAdapter.createDocument();
          this.tokenizer = new Tokenizer(this.options, this);
          this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
          this.fragmentContextID = fragmentContext ? getTagID(this.treeAdapter.getTagName(fragmentContext)) : TAG_ID.UNKNOWN;
          this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
          this.openElements = new OpenElementStack(this.document, this.treeAdapter, this);
        }
        static parse(html, options) {
          const parser = new this(options);
          parser.tokenizer.write(html, true);
          return parser.document;
        }
        static getFragmentParser(fragmentContext, options) {
          const opts = {
            ...defaultParserOptions,
            ...options
          };
          fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : fragmentContext = opts.treeAdapter.createElement(TAG_NAMES.TEMPLATE, NS.HTML, []);
          const documentMock = opts.treeAdapter.createElement("documentmock", NS.HTML, []);
          const parser = new this(opts, documentMock, fragmentContext);
          if (parser.fragmentContextID === TAG_ID.TEMPLATE) {
            parser.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
          }
          parser._initTokenizerForFragmentParsing();
          parser._insertFakeRootElement();
          parser._resetInsertionMode();
          parser._findFormInFragmentContext();
          return parser;
        }
        getFragment() {
          const rootElement = this.treeAdapter.getFirstChild(this.document);
          const fragment = this.treeAdapter.createDocumentFragment();
          this._adoptNodes(rootElement, fragment);
          return fragment;
        }
        _err(token, code, beforeToken) {
          var _a;
          if (!this.onParseError)
            return;
          const loc = (_a = token.location) !== null && _a !== void 0 ? _a : BASE_LOC;
          const err = {
            code,
            startLine: loc.startLine,
            startCol: loc.startCol,
            startOffset: loc.startOffset,
            endLine: beforeToken ? loc.startLine : loc.endLine,
            endCol: beforeToken ? loc.startCol : loc.endCol,
            endOffset: beforeToken ? loc.startOffset : loc.endOffset
          };
          this.onParseError(err);
        }
        onItemPush(node, tid, isTop) {
          var _a, _b;
          (_b = (_a = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a, node);
          if (isTop && this.openElements.stackTop > 0)
            this._setContextModes(node, tid);
        }
        onItemPop(node, isTop) {
          var _a, _b;
          if (this.options.sourceCodeLocationInfo) {
            this._setEndLocation(node, this.currentToken);
          }
          (_b = (_a = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a, node, this.openElements.current);
          if (isTop) {
            let current;
            let currentTagId;
            if (this.openElements.stackTop === 0 && this.fragmentContext) {
              current = this.fragmentContext;
              currentTagId = this.fragmentContextID;
            } else {
              ({current, currentTagId} = this.openElements);
            }
            this._setContextModes(current, currentTagId);
          }
        }
        _setContextModes(current, tid) {
          const isHTML = current === this.document || this.treeAdapter.getNamespaceURI(current) === NS.HTML;
          this.currentNotInHTML = !isHTML;
          this.tokenizer.inForeignNode = !isHTML && !this._isIntegrationPoint(tid, current);
        }
        _switchToTextParsing(currentToken, nextTokenizerState) {
          this._insertElement(currentToken, NS.HTML);
          this.tokenizer.state = nextTokenizerState;
          this.originalInsertionMode = this.insertionMode;
          this.insertionMode = InsertionMode.TEXT;
        }
        switchToPlaintextParsing() {
          this.insertionMode = InsertionMode.TEXT;
          this.originalInsertionMode = InsertionMode.IN_BODY;
          this.tokenizer.state = TokenizerMode.PLAINTEXT;
        }
        _getAdjustedCurrentElement() {
          return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
        }
        _findFormInFragmentContext() {
          let node = this.fragmentContext;
          while (node) {
            if (this.treeAdapter.getTagName(node) === TAG_NAMES.FORM) {
              this.formElement = node;
              break;
            }
            node = this.treeAdapter.getParentNode(node);
          }
        }
        _initTokenizerForFragmentParsing() {
          if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS.HTML) {
            return;
          }
          switch (this.fragmentContextID) {
          case TAG_ID.TITLE:
          case TAG_ID.TEXTAREA: {
              this.tokenizer.state = TokenizerMode.RCDATA;
              break;
            }
          case TAG_ID.STYLE:
          case TAG_ID.XMP:
          case TAG_ID.IFRAME:
          case TAG_ID.NOEMBED:
          case TAG_ID.NOFRAMES:
          case TAG_ID.NOSCRIPT: {
              this.tokenizer.state = TokenizerMode.RAWTEXT;
              break;
            }
          case TAG_ID.SCRIPT: {
              this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
              break;
            }
          case TAG_ID.PLAINTEXT: {
              this.tokenizer.state = TokenizerMode.PLAINTEXT;
              break;
            }
          }
        }
        _setDocumentType(token) {
          const name = token.name || "";
          const publicId = token.publicId || "";
          const systemId = token.systemId || "";
          this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
          if (token.location) {
            const documentChildren = this.treeAdapter.getChildNodes(this.document);
            const docTypeNode = documentChildren.find(node => this.treeAdapter.isDocumentTypeNode(node));
            if (docTypeNode) {
              this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
            }
          }
        }
        _attachElementToTree(element, location) {
          if (this.options.sourceCodeLocationInfo) {
            const loc = location && {
              ...location,
              startTag: location
            };
            this.treeAdapter.setNodeSourceCodeLocation(element, loc);
          }
          if (this._shouldFosterParentOnInsertion()) {
            this._fosterParentElement(element);
          } else {
            const parent = this.openElements.currentTmplContentOrNode;
            this.treeAdapter.appendChild(parent, element);
          }
        }
        _appendElement(token, namespaceURI) {
          const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
          this._attachElementToTree(element, token.location);
        }
        _insertElement(token, namespaceURI) {
          const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
          this._attachElementToTree(element, token.location);
          this.openElements.push(element, token.tagID);
        }
        _insertFakeElement(tagName, tagID) {
          const element = this.treeAdapter.createElement(tagName, NS.HTML, []);
          this._attachElementToTree(element, null);
          this.openElements.push(element, tagID);
        }
        _insertTemplate(token) {
          const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
          const content = this.treeAdapter.createDocumentFragment();
          this.treeAdapter.setTemplateContent(tmpl, content);
          this._attachElementToTree(tmpl, token.location);
          this.openElements.push(tmpl, token.tagID);
          if (this.options.sourceCodeLocationInfo)
            this.treeAdapter.setNodeSourceCodeLocation(content, null);
        }
        _insertFakeRootElement() {
          const element = this.treeAdapter.createElement(TAG_NAMES.HTML, NS.HTML, []);
          if (this.options.sourceCodeLocationInfo)
            this.treeAdapter.setNodeSourceCodeLocation(element, null);
          this.treeAdapter.appendChild(this.openElements.current, element);
          this.openElements.push(element, TAG_ID.HTML);
        }
        _appendCommentNode(token, parent) {
          const commentNode = this.treeAdapter.createCommentNode(token.data);
          this.treeAdapter.appendChild(parent, commentNode);
          if (this.options.sourceCodeLocationInfo) {
            this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
          }
        }
        _insertCharacters(token) {
          let parent;
          let beforeElement;
          if (this._shouldFosterParentOnInsertion()) {
            ({parent, beforeElement} = this._findFosterParentingLocation());
            if (beforeElement) {
              this.treeAdapter.insertTextBefore(parent, token.chars, beforeElement);
            } else {
              this.treeAdapter.insertText(parent, token.chars);
            }
          } else {
            parent = this.openElements.currentTmplContentOrNode;
            this.treeAdapter.insertText(parent, token.chars);
          }
          if (!token.location)
            return;
          const siblings = this.treeAdapter.getChildNodes(parent);
          const textNodeIdx = beforeElement ? siblings.lastIndexOf(beforeElement) : siblings.length;
          const textNode = siblings[textNodeIdx - 1];
          const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
          if (tnLoc) {
            const {endLine, endCol, endOffset} = token.location;
            this.treeAdapter.updateNodeSourceCodeLocation(textNode, {
              endLine,
              endCol,
              endOffset
            });
          } else if (this.options.sourceCodeLocationInfo) {
            this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
          }
        }
        _adoptNodes(donor, recipient) {
          for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
            this.treeAdapter.detachNode(child);
            this.treeAdapter.appendChild(recipient, child);
          }
        }
        _setEndLocation(element, closingToken) {
          if (this.treeAdapter.getNodeSourceCodeLocation(element) && closingToken.location) {
            const ctLoc = closingToken.location;
            const tn = this.treeAdapter.getTagName(element);
            const endLoc = closingToken.type === TokenType.END_TAG && tn === closingToken.tagName ? {
              endTag: { ...ctLoc },
              endLine: ctLoc.endLine,
              endCol: ctLoc.endCol,
              endOffset: ctLoc.endOffset
            } : {
              endLine: ctLoc.startLine,
              endCol: ctLoc.startCol,
              endOffset: ctLoc.startOffset
            };
            this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
          }
        }
        shouldProcessStartTagTokenInForeignContent(token) {
          if (!this.currentNotInHTML)
            return false;
          let current;
          let currentTagId;
          if (this.openElements.stackTop === 0 && this.fragmentContext) {
            current = this.fragmentContext;
            currentTagId = this.fragmentContextID;
          } else {
            ({current, currentTagId} = this.openElements);
          }
          if (token.tagID === TAG_ID.SVG && this.treeAdapter.getTagName(current) === TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === NS.MATHML) {
            return false;
          }
          return this.tokenizer.inForeignNode || (token.tagID === TAG_ID.MGLYPH || token.tagID === TAG_ID.MALIGNMARK) && !this._isIntegrationPoint(currentTagId, current, NS.HTML);
        }
        _processToken(token) {
          switch (token.type) {
          case TokenType.CHARACTER: {
              this.onCharacter(token);
              break;
            }
          case TokenType.NULL_CHARACTER: {
              this.onNullCharacter(token);
              break;
            }
          case TokenType.COMMENT: {
              this.onComment(token);
              break;
            }
          case TokenType.DOCTYPE: {
              this.onDoctype(token);
              break;
            }
          case TokenType.START_TAG: {
              this._processStartTag(token);
              break;
            }
          case TokenType.END_TAG: {
              this.onEndTag(token);
              break;
            }
          case TokenType.EOF: {
              this.onEof(token);
              break;
            }
          case TokenType.WHITESPACE_CHARACTER: {
              this.onWhitespaceCharacter(token);
              break;
            }
          }
        }
        _isIntegrationPoint(tid, element, foreignNS) {
          const ns = this.treeAdapter.getNamespaceURI(element);
          const attrs = this.treeAdapter.getAttrList(element);
          return isIntegrationPoint(tid, ns, attrs, foreignNS);
        }
        _reconstructActiveFormattingElements() {
          const listLength = this.activeFormattingElements.entries.length;
          if (listLength) {
            const endIndex = this.activeFormattingElements.entries.findIndex(entry => entry.type === EntryType.Marker || this.openElements.contains(entry.element));
            const unopenIdx = endIndex < 0 ? listLength - 1 : endIndex - 1;
            for (let i = unopenIdx; i >= 0; i--) {
              const entry = this.activeFormattingElements.entries[i];
              this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
              entry.element = this.openElements.current;
            }
          }
        }
        _closeTableCell() {
          this.openElements.generateImpliedEndTags();
          this.openElements.popUntilTableCellPopped();
          this.activeFormattingElements.clearToLastMarker();
          this.insertionMode = InsertionMode.IN_ROW;
        }
        _closePElement() {
          this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P);
          this.openElements.popUntilTagNamePopped(TAG_ID.P);
        }
        _resetInsertionMode() {
          for (let i = this.openElements.stackTop; i >= 0; i--) {
            switch (i === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i]) {
            case TAG_ID.TR:
              this.insertionMode = InsertionMode.IN_ROW;
              return;
            case TAG_ID.TBODY:
            case TAG_ID.THEAD:
            case TAG_ID.TFOOT:
              this.insertionMode = InsertionMode.IN_TABLE_BODY;
              return;
            case TAG_ID.CAPTION:
              this.insertionMode = InsertionMode.IN_CAPTION;
              return;
            case TAG_ID.COLGROUP:
              this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
              return;
            case TAG_ID.TABLE:
              this.insertionMode = InsertionMode.IN_TABLE;
              return;
            case TAG_ID.BODY:
              this.insertionMode = InsertionMode.IN_BODY;
              return;
            case TAG_ID.FRAMESET:
              this.insertionMode = InsertionMode.IN_FRAMESET;
              return;
            case TAG_ID.SELECT:
              this._resetInsertionModeForSelect(i);
              return;
            case TAG_ID.TEMPLATE:
              this.insertionMode = this.tmplInsertionModeStack[0];
              return;
            case TAG_ID.HTML:
              this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
              return;
            case TAG_ID.TD:
            case TAG_ID.TH:
              if (i > 0) {
                this.insertionMode = InsertionMode.IN_CELL;
                return;
              }
              break;
            case TAG_ID.HEAD:
              if (i > 0) {
                this.insertionMode = InsertionMode.IN_HEAD;
                return;
              }
              break;
            }
          }
          this.insertionMode = InsertionMode.IN_BODY;
        }
        _resetInsertionModeForSelect(selectIdx) {
          if (selectIdx > 0) {
            for (let i = selectIdx - 1; i > 0; i--) {
              const tn = this.openElements.tagIDs[i];
              if (tn === TAG_ID.TEMPLATE) {
                break;
              } else if (tn === TAG_ID.TABLE) {
                this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
                return;
              }
            }
          }
          this.insertionMode = InsertionMode.IN_SELECT;
        }
        _isElementCausesFosterParenting(tn) {
          return TABLE_STRUCTURE_TAGS.has(tn);
        }
        _shouldFosterParentOnInsertion() {
          return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
        }
        _findFosterParentingLocation() {
          for (let i = this.openElements.stackTop; i >= 0; i--) {
            const openElement = this.openElements.items[i];
            switch (this.openElements.tagIDs[i]) {
            case TAG_ID.TEMPLATE:
              if (this.treeAdapter.getNamespaceURI(openElement) === NS.HTML) {
                return {
                  parent: this.treeAdapter.getTemplateContent(openElement),
                  beforeElement: null
                };
              }
              break;
            case TAG_ID.TABLE: {
                const parent = this.treeAdapter.getParentNode(openElement);
                if (parent) {
                  return {
                    parent,
                    beforeElement: openElement
                  };
                }
                return {
                  parent: this.openElements.items[i - 1],
                  beforeElement: null
                };
              }
            }
          }
          return {
            parent: this.openElements.items[0],
            beforeElement: null
          };
        }
        _fosterParentElement(element) {
          const location = this._findFosterParentingLocation();
          if (location.beforeElement) {
            this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
          } else {
            this.treeAdapter.appendChild(location.parent, element);
          }
        }
        _isSpecialElement(element, id) {
          const ns = this.treeAdapter.getNamespaceURI(element);
          return SPECIAL_ELEMENTS[ns].has(id);
        }
        onCharacter(token) {
          this.skipNextNewLine = false;
          if (this.tokenizer.inForeignNode) {
            characterInForeignContent(this, token);
            return;
          }
          switch (this.insertionMode) {
          case InsertionMode.INITIAL:
            tokenInInitialMode(this, token);
            break;
          case InsertionMode.BEFORE_HTML:
            tokenBeforeHtml(this, token);
            break;
          case InsertionMode.BEFORE_HEAD:
            tokenBeforeHead(this, token);
            break;
          case InsertionMode.IN_HEAD:
            tokenInHead(this, token);
            break;
          case InsertionMode.IN_HEAD_NO_SCRIPT:
            tokenInHeadNoScript(this, token);
            break;
          case InsertionMode.AFTER_HEAD:
            tokenAfterHead(this, token);
            break;
          case InsertionMode.IN_BODY:
          case InsertionMode.IN_CAPTION:
          case InsertionMode.IN_CELL:
          case InsertionMode.IN_TEMPLATE:
            characterInBody(this, token);
            break;
          case InsertionMode.TEXT:
          case InsertionMode.IN_SELECT:
          case InsertionMode.IN_SELECT_IN_TABLE:
            this._insertCharacters(token);
            break;
          case InsertionMode.IN_TABLE:
          case InsertionMode.IN_TABLE_BODY:
          case InsertionMode.IN_ROW:
            characterInTable(this, token);
            break;
          case InsertionMode.IN_TABLE_TEXT:
            characterInTableText(this, token);
            break;
          case InsertionMode.IN_COLUMN_GROUP:
            tokenInColumnGroup(this, token);
            break;
          case InsertionMode.AFTER_BODY:
            tokenAfterBody(this, token);
            break;
          case InsertionMode.AFTER_AFTER_BODY:
            tokenAfterAfterBody(this, token);
            break;
          }
        }
        onNullCharacter(token) {
          this.skipNextNewLine = false;
          if (this.tokenizer.inForeignNode) {
            nullCharacterInForeignContent(this, token);
            return;
          }
          switch (this.insertionMode) {
          case InsertionMode.INITIAL:
            tokenInInitialMode(this, token);
            break;
          case InsertionMode.BEFORE_HTML:
            tokenBeforeHtml(this, token);
            break;
          case InsertionMode.BEFORE_HEAD:
            tokenBeforeHead(this, token);
            break;
          case InsertionMode.IN_HEAD:
            tokenInHead(this, token);
            break;
          case InsertionMode.IN_HEAD_NO_SCRIPT:
            tokenInHeadNoScript(this, token);
            break;
          case InsertionMode.AFTER_HEAD:
            tokenAfterHead(this, token);
            break;
          case InsertionMode.TEXT:
            this._insertCharacters(token);
            break;
          case InsertionMode.IN_TABLE:
          case InsertionMode.IN_TABLE_BODY:
          case InsertionMode.IN_ROW:
            characterInTable(this, token);
            break;
          case InsertionMode.IN_COLUMN_GROUP:
            tokenInColumnGroup(this, token);
            break;
          case InsertionMode.AFTER_BODY:
            tokenAfterBody(this, token);
            break;
          case InsertionMode.AFTER_AFTER_BODY:
            tokenAfterAfterBody(this, token);
            break;
          }
        }
        onComment(token) {
          this.skipNextNewLine = false;
          if (this.currentNotInHTML) {
            appendComment(this, token);
            return;
          }
          switch (this.insertionMode) {
          case InsertionMode.INITIAL:
          case InsertionMode.BEFORE_HTML:
          case InsertionMode.BEFORE_HEAD:
          case InsertionMode.IN_HEAD:
          case InsertionMode.IN_HEAD_NO_SCRIPT:
          case InsertionMode.AFTER_HEAD:
          case InsertionMode.IN_BODY:
          case InsertionMode.IN_TABLE:
          case InsertionMode.IN_CAPTION:
          case InsertionMode.IN_COLUMN_GROUP:
          case InsertionMode.IN_TABLE_BODY:
          case InsertionMode.IN_ROW:
          case InsertionMode.IN_CELL:
          case InsertionMode.IN_SELECT:
          case InsertionMode.IN_SELECT_IN_TABLE:
          case InsertionMode.IN_TEMPLATE:
          case InsertionMode.IN_FRAMESET:
          case InsertionMode.AFTER_FRAMESET:
            appendComment(this, token);
            break;
          case InsertionMode.IN_TABLE_TEXT:
            tokenInTableText(this, token);
            break;
          case InsertionMode.AFTER_BODY:
            appendCommentToRootHtmlElement(this, token);
            break;
          case InsertionMode.AFTER_AFTER_BODY:
          case InsertionMode.AFTER_AFTER_FRAMESET:
            appendCommentToDocument(this, token);
            break;
          }
        }
        onDoctype(token) {
          this.skipNextNewLine = false;
          switch (this.insertionMode) {
          case InsertionMode.INITIAL:
            doctypeInInitialMode(this, token);
            break;
          case InsertionMode.BEFORE_HEAD:
          case InsertionMode.IN_HEAD:
          case InsertionMode.IN_HEAD_NO_SCRIPT:
          case InsertionMode.AFTER_HEAD:
            this._err(token, ERR.misplacedDoctype);
            break;
          case InsertionMode.IN_TABLE_TEXT:
            tokenInTableText(this, token);
            break;
          }
        }
        onStartTag(token) {
          this.skipNextNewLine = false;
          this.currentToken = token;
          this._processStartTag(token);
          if (token.selfClosing && !token.ackSelfClosing) {
            this._err(token, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
          }
        }
        _processStartTag(token) {
          if (this.shouldProcessStartTagTokenInForeignContent(token)) {
            startTagInForeignContent(this, token);
          } else {
            this._startTagOutsideForeignContent(token);
          }
        }
        _startTagOutsideForeignContent(token) {
          switch (this.insertionMode) {
          case InsertionMode.INITIAL:
            tokenInInitialMode(this, token);
            break;
          case InsertionMode.BEFORE_HTML:
            startTagBeforeHtml(this, token);
            break;
          case InsertionMode.BEFORE_HEAD:
            startTagBeforeHead(this, token);
            break;
          case InsertionMode.IN_HEAD:
            startTagInHead(this, token);
            break;
          case InsertionMode.IN_HEAD_NO_SCRIPT:
            startTagInHeadNoScript(this, token);
            break;
          case InsertionMode.AFTER_HEAD:
            startTagAfterHead(this, token);
            break;
          case InsertionMode.IN_BODY:
            startTagInBody(this, token);
            break;
          case InsertionMode.IN_TABLE:
            startTagInTable(this, token);
            break;
          case InsertionMode.IN_TABLE_TEXT:
            tokenInTableText(this, token);
            break;
          case InsertionMode.IN_CAPTION:
            startTagInCaption(this, token);
            break;
          case InsertionMode.IN_COLUMN_GROUP:
            startTagInColumnGroup(this, token);
            break;
          case InsertionMode.IN_TABLE_BODY:
            startTagInTableBody(this, token);
            break;
          case InsertionMode.IN_ROW:
            startTagInRow(this, token);
            break;
          case InsertionMode.IN_CELL:
            startTagInCell(this, token);
            break;
          case InsertionMode.IN_SELECT:
            startTagInSelect(this, token);
            break;
          case InsertionMode.IN_SELECT_IN_TABLE:
            startTagInSelectInTable(this, token);
            break;
          case InsertionMode.IN_TEMPLATE:
            startTagInTemplate(this, token);
            break;
          case InsertionMode.AFTER_BODY:
            startTagAfterBody(this, token);
            break;
          case InsertionMode.IN_FRAMESET:
            startTagInFrameset(this, token);
            break;
          case InsertionMode.AFTER_FRAMESET:
            startTagAfterFrameset(this, token);
            break;
          case InsertionMode.AFTER_AFTER_BODY:
            startTagAfterAfterBody(this, token);
            break;
          case InsertionMode.AFTER_AFTER_FRAMESET:
            startTagAfterAfterFrameset(this, token);
            break;
          }
        }
        onEndTag(token) {
          this.skipNextNewLine = false;
          this.currentToken = token;
          if (this.currentNotInHTML) {
            endTagInForeignContent(this, token);
          } else {
            this._endTagOutsideForeignContent(token);
          }
        }
        _endTagOutsideForeignContent(token) {
          switch (this.insertionMode) {
          case InsertionMode.INITIAL:
            tokenInInitialMode(this, token);
            break;
          case InsertionMode.BEFORE_HTML:
            endTagBeforeHtml(this, token);
            break;
          case InsertionMode.BEFORE_HEAD:
            endTagBeforeHead(this, token);
            break;
          case InsertionMode.IN_HEAD:
            endTagInHead(this, token);
            break;
          case InsertionMode.IN_HEAD_NO_SCRIPT:
            endTagInHeadNoScript(this, token);
            break;
          case InsertionMode.AFTER_HEAD:
            endTagAfterHead(this, token);
            break;
          case InsertionMode.IN_BODY:
            endTagInBody(this, token);
            break;
          case InsertionMode.TEXT:
            endTagInText(this, token);
            break;
          case InsertionMode.IN_TABLE:
            endTagInTable(this, token);
            break;
          case InsertionMode.IN_TABLE_TEXT:
            tokenInTableText(this, token);
            break;
          case InsertionMode.IN_CAPTION:
            endTagInCaption(this, token);
            break;
          case InsertionMode.IN_COLUMN_GROUP:
            endTagInColumnGroup(this, token);
            break;
          case InsertionMode.IN_TABLE_BODY:
            endTagInTableBody(this, token);
            break;
          case InsertionMode.IN_ROW:
            endTagInRow(this, token);
            break;
          case InsertionMode.IN_CELL:
            endTagInCell(this, token);
            break;
          case InsertionMode.IN_SELECT:
            endTagInSelect(this, token);
            break;
          case InsertionMode.IN_SELECT_IN_TABLE:
            endTagInSelectInTable(this, token);
            break;
          case InsertionMode.IN_TEMPLATE:
            endTagInTemplate(this, token);
            break;
          case InsertionMode.AFTER_BODY:
            endTagAfterBody(this, token);
            break;
          case InsertionMode.IN_FRAMESET:
            endTagInFrameset(this, token);
            break;
          case InsertionMode.AFTER_FRAMESET:
            endTagAfterFrameset(this, token);
            break;
          case InsertionMode.AFTER_AFTER_BODY:
            tokenAfterAfterBody(this, token);
            break;
          }
        }
        onEof(token) {
          switch (this.insertionMode) {
          case InsertionMode.INITIAL:
            tokenInInitialMode(this, token);
            break;
          case InsertionMode.BEFORE_HTML:
            tokenBeforeHtml(this, token);
            break;
          case InsertionMode.BEFORE_HEAD:
            tokenBeforeHead(this, token);
            break;
          case InsertionMode.IN_HEAD:
            tokenInHead(this, token);
            break;
          case InsertionMode.IN_HEAD_NO_SCRIPT:
            tokenInHeadNoScript(this, token);
            break;
          case InsertionMode.AFTER_HEAD:
            tokenAfterHead(this, token);
            break;
          case InsertionMode.IN_BODY:
          case InsertionMode.IN_TABLE:
          case InsertionMode.IN_CAPTION:
          case InsertionMode.IN_COLUMN_GROUP:
          case InsertionMode.IN_TABLE_BODY:
          case InsertionMode.IN_ROW:
          case InsertionMode.IN_CELL:
          case InsertionMode.IN_SELECT:
          case InsertionMode.IN_SELECT_IN_TABLE:
            eofInBody(this, token);
            break;
          case InsertionMode.TEXT:
            eofInText(this, token);
            break;
          case InsertionMode.IN_TABLE_TEXT:
            tokenInTableText(this, token);
            break;
          case InsertionMode.IN_TEMPLATE:
            eofInTemplate(this, token);
            break;
          case InsertionMode.AFTER_BODY:
          case InsertionMode.IN_FRAMESET:
          case InsertionMode.AFTER_FRAMESET:
          case InsertionMode.AFTER_AFTER_BODY:
          case InsertionMode.AFTER_AFTER_FRAMESET:
            stopParsing(this, token);
            break;
          }
        }
        onWhitespaceCharacter(token) {
          if (this.skipNextNewLine) {
            this.skipNextNewLine = false;
            if (token.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED) {
              if (token.chars.length === 1) {
                return;
              }
              token.chars = token.chars.substr(1);
            }
          }
          if (this.tokenizer.inForeignNode) {
            this._insertCharacters(token);
            return;
          }
          switch (this.insertionMode) {
          case InsertionMode.IN_HEAD:
          case InsertionMode.IN_HEAD_NO_SCRIPT:
          case InsertionMode.AFTER_HEAD:
          case InsertionMode.TEXT:
          case InsertionMode.IN_COLUMN_GROUP:
          case InsertionMode.IN_SELECT:
          case InsertionMode.IN_SELECT_IN_TABLE:
          case InsertionMode.IN_FRAMESET:
          case InsertionMode.AFTER_FRAMESET:
            this._insertCharacters(token);
            break;
          case InsertionMode.IN_BODY:
          case InsertionMode.IN_CAPTION:
          case InsertionMode.IN_CELL:
          case InsertionMode.IN_TEMPLATE:
          case InsertionMode.AFTER_BODY:
          case InsertionMode.AFTER_AFTER_BODY:
          case InsertionMode.AFTER_AFTER_FRAMESET:
            whitespaceCharacterInBody(this, token);
            break;
          case InsertionMode.IN_TABLE:
          case InsertionMode.IN_TABLE_BODY:
          case InsertionMode.IN_ROW:
            characterInTable(this, token);
            break;
          case InsertionMode.IN_TABLE_TEXT:
            whitespaceCharacterInTableText(this, token);
            break;
          }
        }
      }
      function aaObtainFormattingElementEntry(p, token) {
        let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
        if (formattingElementEntry) {
          if (!p.openElements.contains(formattingElementEntry.element)) {
            p.activeFormattingElements.removeEntry(formattingElementEntry);
            formattingElementEntry = null;
          } else if (!p.openElements.hasInScope(token.tagID)) {
            formattingElementEntry = null;
          }
        } else {
          genericEndTagInBody(p, token);
        }
        return formattingElementEntry;
      }
      function aaObtainFurthestBlock(p, formattingElementEntry) {
        let furthestBlock = null;
        let idx = p.openElements.stackTop;
        for (; idx >= 0; idx--) {
          const element = p.openElements.items[idx];
          if (element === formattingElementEntry.element) {
            break;
          }
          if (p._isSpecialElement(element, p.openElements.tagIDs[idx])) {
            furthestBlock = element;
          }
        }
        if (!furthestBlock) {
          p.openElements.shortenToLength(idx < 0 ? 0 : idx);
          p.activeFormattingElements.removeEntry(formattingElementEntry);
        }
        return furthestBlock;
      }
      function aaInnerLoop(p, furthestBlock, formattingElement) {
        let lastElement = furthestBlock;
        let nextElement = p.openElements.getCommonAncestor(furthestBlock);
        for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
          nextElement = p.openElements.getCommonAncestor(element);
          const elementEntry = p.activeFormattingElements.getElementEntry(element);
          const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
          const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
          if (shouldRemoveFromOpenElements) {
            if (counterOverflow) {
              p.activeFormattingElements.removeEntry(elementEntry);
            }
            p.openElements.remove(element);
          } else {
            element = aaRecreateElementFromEntry(p, elementEntry);
            if (lastElement === furthestBlock) {
              p.activeFormattingElements.bookmark = elementEntry;
            }
            p.treeAdapter.detachNode(lastElement);
            p.treeAdapter.appendChild(element, lastElement);
            lastElement = element;
          }
        }
        return lastElement;
      }
      function aaRecreateElementFromEntry(p, elementEntry) {
        const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
        const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
        p.openElements.replace(elementEntry.element, newElement);
        elementEntry.element = newElement;
        return newElement;
      }
      function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
        const tn = p.treeAdapter.getTagName(commonAncestor);
        const tid = getTagID(tn);
        if (p._isElementCausesFosterParenting(tid)) {
          p._fosterParentElement(lastElement);
        } else {
          const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
          if (tid === TAG_ID.TEMPLATE && ns === NS.HTML) {
            commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
          }
          p.treeAdapter.appendChild(commonAncestor, lastElement);
        }
      }
      function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
        const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
        const {token} = formattingElementEntry;
        const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
        p._adoptNodes(furthestBlock, newElement);
        p.treeAdapter.appendChild(furthestBlock, newElement);
        p.activeFormattingElements.insertElementAfterBookmark(newElement, token);
        p.activeFormattingElements.removeEntry(formattingElementEntry);
        p.openElements.remove(formattingElementEntry.element);
        p.openElements.insertAfter(furthestBlock, newElement, token.tagID);
      }
      function callAdoptionAgency(p, token) {
        for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
          const formattingElementEntry = aaObtainFormattingElementEntry(p, token);
          if (!formattingElementEntry) {
            break;
          }
          const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);
          if (!furthestBlock) {
            break;
          }
          p.activeFormattingElements.bookmark = formattingElementEntry;
          const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
          const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
          p.treeAdapter.detachNode(lastElement);
          if (commonAncestor)
            aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
          aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
        }
      }
      function appendComment(p, token) {
        p._appendCommentNode(token, p.openElements.currentTmplContentOrNode);
      }
      function appendCommentToRootHtmlElement(p, token) {
        p._appendCommentNode(token, p.openElements.items[0]);
      }
      function appendCommentToDocument(p, token) {
        p._appendCommentNode(token, p.document);
      }
      function stopParsing(p, token) {
        p.stopped = true;
        if (token.location) {
          const target = p.fragmentContext ? 0 : 2;
          for (let i = p.openElements.stackTop; i >= target; i--) {
            p._setEndLocation(p.openElements.items[i], token);
          }
          if (!p.fragmentContext && p.openElements.stackTop >= 0) {
            const htmlElement = p.openElements.items[0];
            const htmlLocation = p.treeAdapter.getNodeSourceCodeLocation(htmlElement);
            if (htmlLocation && !htmlLocation.endTag) {
              p._setEndLocation(htmlElement, token);
              if (p.openElements.stackTop >= 1) {
                const bodyElement = p.openElements.items[1];
                const bodyLocation = p.treeAdapter.getNodeSourceCodeLocation(bodyElement);
                if (bodyLocation && !bodyLocation.endTag) {
                  p._setEndLocation(bodyElement, token);
                }
              }
            }
          }
        }
      }
      function doctypeInInitialMode(p, token) {
        p._setDocumentType(token);
        const mode = token.forceQuirks ? DOCUMENT_MODE.QUIRKS : getDocumentMode(token);
        if (!isConforming(token)) {
          p._err(token, ERR.nonConformingDoctype);
        }
        p.treeAdapter.setDocumentMode(p.document, mode);
        p.insertionMode = InsertionMode.BEFORE_HTML;
      }
      function tokenInInitialMode(p, token) {
        p._err(token, ERR.missingDoctype, true);
        p.treeAdapter.setDocumentMode(p.document, DOCUMENT_MODE.QUIRKS);
        p.insertionMode = InsertionMode.BEFORE_HTML;
        p._processToken(token);
      }
      function startTagBeforeHtml(p, token) {
        if (token.tagID === TAG_ID.HTML) {
          p._insertElement(token, NS.HTML);
          p.insertionMode = InsertionMode.BEFORE_HEAD;
        } else {
          tokenBeforeHtml(p, token);
        }
      }
      function endTagBeforeHtml(p, token) {
        const tn = token.tagID;
        if (tn === TAG_ID.HTML || tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.BR) {
          tokenBeforeHtml(p, token);
        }
      }
      function tokenBeforeHtml(p, token) {
        p._insertFakeRootElement();
        p.insertionMode = InsertionMode.BEFORE_HEAD;
        p._processToken(token);
      }
      function startTagBeforeHead(p, token) {
        switch (token.tagID) {
        case TAG_ID.HTML: {
            startTagInBody(p, token);
            break;
          }
        case TAG_ID.HEAD: {
            p._insertElement(token, NS.HTML);
            p.headElement = p.openElements.current;
            p.insertionMode = InsertionMode.IN_HEAD;
            break;
          }
        default: {
            tokenBeforeHead(p, token);
          }
        }
      }
      function endTagBeforeHead(p, token) {
        const tn = token.tagID;
        if (tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.HTML || tn === TAG_ID.BR) {
          tokenBeforeHead(p, token);
        } else {
          p._err(token, ERR.endTagWithoutMatchingOpenElement);
        }
      }
      function tokenBeforeHead(p, token) {
        p._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD);
        p.headElement = p.openElements.current;
        p.insertionMode = InsertionMode.IN_HEAD;
        p._processToken(token);
      }
      function startTagInHead(p, token) {
        switch (token.tagID) {
        case TAG_ID.HTML: {
            startTagInBody(p, token);
            break;
          }
        case TAG_ID.BASE:
        case TAG_ID.BASEFONT:
        case TAG_ID.BGSOUND:
        case TAG_ID.LINK:
        case TAG_ID.META: {
            p._appendElement(token, NS.HTML);
            token.ackSelfClosing = true;
            break;
          }
        case TAG_ID.TITLE: {
            p._switchToTextParsing(token, TokenizerMode.RCDATA);
            break;
          }
        case TAG_ID.NOSCRIPT: {
            if (p.options.scriptingEnabled) {
              p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
            } else {
              p._insertElement(token, NS.HTML);
              p.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
            }
            break;
          }
        case TAG_ID.NOFRAMES:
        case TAG_ID.STYLE: {
            p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
            break;
          }
        case TAG_ID.SCRIPT: {
            p._switchToTextParsing(token, TokenizerMode.SCRIPT_DATA);
            break;
          }
        case TAG_ID.TEMPLATE: {
            p._insertTemplate(token);
            p.activeFormattingElements.insertMarker();
            p.framesetOk = false;
            p.insertionMode = InsertionMode.IN_TEMPLATE;
            p.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
            break;
          }
        case TAG_ID.HEAD: {
            p._err(token, ERR.misplacedStartTagForHeadElement);
            break;
          }
        default: {
            tokenInHead(p, token);
          }
        }
      }
      function endTagInHead(p, token) {
        switch (token.tagID) {
        case TAG_ID.HEAD: {
            p.openElements.pop();
            p.insertionMode = InsertionMode.AFTER_HEAD;
            break;
          }
        case TAG_ID.BODY:
        case TAG_ID.BR:
        case TAG_ID.HTML: {
            tokenInHead(p, token);
            break;
          }
        case TAG_ID.TEMPLATE: {
            if (p.openElements.tmplCount > 0) {
              p.openElements.generateImpliedEndTagsThoroughly();
              if (p.openElements.currentTagId !== TAG_ID.TEMPLATE) {
                p._err(token, ERR.closingOfElementWithOpenChildElements);
              }
              p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
              p.activeFormattingElements.clearToLastMarker();
              p.tmplInsertionModeStack.shift();
              p._resetInsertionMode();
            } else {
              p._err(token, ERR.endTagWithoutMatchingOpenElement);
            }
            break;
          }
        default: {
            p._err(token, ERR.endTagWithoutMatchingOpenElement);
          }
        }
      }
      function tokenInHead(p, token) {
        p.openElements.pop();
        p.insertionMode = InsertionMode.AFTER_HEAD;
        p._processToken(token);
      }
      function startTagInHeadNoScript(p, token) {
        switch (token.tagID) {
        case TAG_ID.HTML: {
            startTagInBody(p, token);
            break;
          }
        case TAG_ID.BASEFONT:
        case TAG_ID.BGSOUND:
        case TAG_ID.HEAD:
        case TAG_ID.LINK:
        case TAG_ID.META:
        case TAG_ID.NOFRAMES:
        case TAG_ID.STYLE: {
            startTagInHead(p, token);
            break;
          }
        case TAG_ID.NOSCRIPT: {
            p._err(token, ERR.nestedNoscriptInHead);
            break;
          }
        default: {
            tokenInHeadNoScript(p, token);
          }
        }
      }
      function endTagInHeadNoScript(p, token) {
        switch (token.tagID) {
        case TAG_ID.NOSCRIPT: {
            p.openElements.pop();
            p.insertionMode = InsertionMode.IN_HEAD;
            break;
          }
        case TAG_ID.BR: {
            tokenInHeadNoScript(p, token);
            break;
          }
        default: {
            p._err(token, ERR.endTagWithoutMatchingOpenElement);
          }
        }
      }
      function tokenInHeadNoScript(p, token) {
        const errCode = token.type === TokenType.EOF ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
        p._err(token, errCode);
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_HEAD;
        p._processToken(token);
      }
      function startTagAfterHead(p, token) {
        switch (token.tagID) {
        case TAG_ID.HTML: {
            startTagInBody(p, token);
            break;
          }
        case TAG_ID.BODY: {
            p._insertElement(token, NS.HTML);
            p.framesetOk = false;
            p.insertionMode = InsertionMode.IN_BODY;
            break;
          }
        case TAG_ID.FRAMESET: {
            p._insertElement(token, NS.HTML);
            p.insertionMode = InsertionMode.IN_FRAMESET;
            break;
          }
        case TAG_ID.BASE:
        case TAG_ID.BASEFONT:
        case TAG_ID.BGSOUND:
        case TAG_ID.LINK:
        case TAG_ID.META:
        case TAG_ID.NOFRAMES:
        case TAG_ID.SCRIPT:
        case TAG_ID.STYLE:
        case TAG_ID.TEMPLATE:
        case TAG_ID.TITLE: {
            p._err(token, ERR.abandonedHeadElementChild);
            p.openElements.push(p.headElement, TAG_ID.HEAD);
            startTagInHead(p, token);
            p.openElements.remove(p.headElement);
            break;
          }
        case TAG_ID.HEAD: {
            p._err(token, ERR.misplacedStartTagForHeadElement);
            break;
          }
        default: {
            tokenAfterHead(p, token);
          }
        }
      }
      function endTagAfterHead(p, token) {
        switch (token.tagID) {
        case TAG_ID.BODY:
        case TAG_ID.HTML:
        case TAG_ID.BR: {
            tokenAfterHead(p, token);
            break;
          }
        case TAG_ID.TEMPLATE: {
            endTagInHead(p, token);
            break;
          }
        default: {
            p._err(token, ERR.endTagWithoutMatchingOpenElement);
          }
        }
      }
      function tokenAfterHead(p, token) {
        p._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY);
        p.insertionMode = InsertionMode.IN_BODY;
        modeInBody(p, token);
      }
      function modeInBody(p, token) {
        switch (token.type) {
        case TokenType.CHARACTER: {
            characterInBody(p, token);
            break;
          }
        case TokenType.WHITESPACE_CHARACTER: {
            whitespaceCharacterInBody(p, token);
            break;
          }
        case TokenType.COMMENT: {
            appendComment(p, token);
            break;
          }
        case TokenType.START_TAG: {
            startTagInBody(p, token);
            break;
          }
        case TokenType.END_TAG: {
            endTagInBody(p, token);
            break;
          }
        case TokenType.EOF: {
            eofInBody(p, token);
            break;
          }
        }
      }
      function whitespaceCharacterInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._insertCharacters(token);
      }
      function characterInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._insertCharacters(token);
        p.framesetOk = false;
      }
      function htmlStartTagInBody(p, token) {
        if (p.openElements.tmplCount === 0) {
          p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
        }
      }
      function bodyStartTagInBody(p, token) {
        const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
        if (bodyElement && p.openElements.tmplCount === 0) {
          p.framesetOk = false;
          p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
        }
      }
      function framesetStartTagInBody(p, token) {
        const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
        if (p.framesetOk && bodyElement) {
          p.treeAdapter.detachNode(bodyElement);
          p.openElements.popAllUpToHtmlElement();
          p._insertElement(token, NS.HTML);
          p.insertionMode = InsertionMode.IN_FRAMESET;
        }
      }
      function addressStartTagInBody(p, token) {
        if (p.openElements.hasInButtonScope(TAG_ID.P)) {
          p._closePElement();
        }
        p._insertElement(token, NS.HTML);
      }
      function numberedHeaderStartTagInBody(p, token) {
        if (p.openElements.hasInButtonScope(TAG_ID.P)) {
          p._closePElement();
        }
        if (isNumberedHeader(p.openElements.currentTagId)) {
          p.openElements.pop();
        }
        p._insertElement(token, NS.HTML);
      }
      function preStartTagInBody(p, token) {
        if (p.openElements.hasInButtonScope(TAG_ID.P)) {
          p._closePElement();
        }
        p._insertElement(token, NS.HTML);
        p.skipNextNewLine = true;
        p.framesetOk = false;
      }
      function formStartTagInBody(p, token) {
        const inTemplate = p.openElements.tmplCount > 0;
        if (!p.formElement || inTemplate) {
          if (p.openElements.hasInButtonScope(TAG_ID.P)) {
            p._closePElement();
          }
          p._insertElement(token, NS.HTML);
          if (!inTemplate) {
            p.formElement = p.openElements.current;
          }
        }
      }
      function listItemStartTagInBody(p, token) {
        p.framesetOk = false;
        const tn = token.tagID;
        for (let i = p.openElements.stackTop; i >= 0; i--) {
          const elementId = p.openElements.tagIDs[i];
          if (tn === TAG_ID.LI && elementId === TAG_ID.LI || (tn === TAG_ID.DD || tn === TAG_ID.DT) && (elementId === TAG_ID.DD || elementId === TAG_ID.DT)) {
            p.openElements.generateImpliedEndTagsWithExclusion(elementId);
            p.openElements.popUntilTagNamePopped(elementId);
            break;
          }
          if (elementId !== TAG_ID.ADDRESS && elementId !== TAG_ID.DIV && elementId !== TAG_ID.P && p._isSpecialElement(p.openElements.items[i], elementId)) {
            break;
          }
        }
        if (p.openElements.hasInButtonScope(TAG_ID.P)) {
          p._closePElement();
        }
        p._insertElement(token, NS.HTML);
      }
      function plaintextStartTagInBody(p, token) {
        if (p.openElements.hasInButtonScope(TAG_ID.P)) {
          p._closePElement();
        }
        p._insertElement(token, NS.HTML);
        p.tokenizer.state = TokenizerMode.PLAINTEXT;
      }
      function buttonStartTagInBody(p, token) {
        if (p.openElements.hasInScope(TAG_ID.BUTTON)) {
          p.openElements.generateImpliedEndTags();
          p.openElements.popUntilTagNamePopped(TAG_ID.BUTTON);
        }
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
        p.framesetOk = false;
      }
      function aStartTagInBody(p, token) {
        const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
        if (activeElementEntry) {
          callAdoptionAgency(p, token);
          p.openElements.remove(activeElementEntry.element);
          p.activeFormattingElements.removeEntry(activeElementEntry);
        }
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
        p.activeFormattingElements.pushElement(p.openElements.current, token);
      }
      function bStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
        p.activeFormattingElements.pushElement(p.openElements.current, token);
      }
      function nobrStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        if (p.openElements.hasInScope(TAG_ID.NOBR)) {
          callAdoptionAgency(p, token);
          p._reconstructActiveFormattingElements();
        }
        p._insertElement(token, NS.HTML);
        p.activeFormattingElements.pushElement(p.openElements.current, token);
      }
      function appletStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
        p.activeFormattingElements.insertMarker();
        p.framesetOk = false;
      }
      function tableStartTagInBody(p, token) {
        if (p.treeAdapter.getDocumentMode(p.document) !== DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope(TAG_ID.P)) {
          p._closePElement();
        }
        p._insertElement(token, NS.HTML);
        p.framesetOk = false;
        p.insertionMode = InsertionMode.IN_TABLE;
      }
      function areaStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._appendElement(token, NS.HTML);
        p.framesetOk = false;
        token.ackSelfClosing = true;
      }
      function isHiddenInput(token) {
        const inputType = getTokenAttr(token, ATTRS.TYPE);
        return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
      }
      function inputStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._appendElement(token, NS.HTML);
        if (!isHiddenInput(token)) {
          p.framesetOk = false;
        }
        token.ackSelfClosing = true;
      }
      function paramStartTagInBody(p, token) {
        p._appendElement(token, NS.HTML);
        token.ackSelfClosing = true;
      }
      function hrStartTagInBody(p, token) {
        if (p.openElements.hasInButtonScope(TAG_ID.P)) {
          p._closePElement();
        }
        p._appendElement(token, NS.HTML);
        p.framesetOk = false;
        token.ackSelfClosing = true;
      }
      function imageStartTagInBody(p, token) {
        token.tagName = TAG_NAMES.IMG;
        token.tagID = TAG_ID.IMG;
        areaStartTagInBody(p, token);
      }
      function textareaStartTagInBody(p, token) {
        p._insertElement(token, NS.HTML);
        p.skipNextNewLine = true;
        p.tokenizer.state = TokenizerMode.RCDATA;
        p.originalInsertionMode = p.insertionMode;
        p.framesetOk = false;
        p.insertionMode = InsertionMode.TEXT;
      }
      function xmpStartTagInBody(p, token) {
        if (p.openElements.hasInButtonScope(TAG_ID.P)) {
          p._closePElement();
        }
        p._reconstructActiveFormattingElements();
        p.framesetOk = false;
        p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      }
      function iframeStartTagInBody(p, token) {
        p.framesetOk = false;
        p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      }
      function noembedStartTagInBody(p, token) {
        p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      }
      function selectStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
        p.framesetOk = false;
        p.insertionMode = p.insertionMode === InsertionMode.IN_TABLE || p.insertionMode === InsertionMode.IN_CAPTION || p.insertionMode === InsertionMode.IN_TABLE_BODY || p.insertionMode === InsertionMode.IN_ROW || p.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
      }
      function optgroupStartTagInBody(p, token) {
        if (p.openElements.currentTagId === TAG_ID.OPTION) {
          p.openElements.pop();
        }
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
      }
      function rbStartTagInBody(p, token) {
        if (p.openElements.hasInScope(TAG_ID.RUBY)) {
          p.openElements.generateImpliedEndTags();
        }
        p._insertElement(token, NS.HTML);
      }
      function rtStartTagInBody(p, token) {
        if (p.openElements.hasInScope(TAG_ID.RUBY)) {
          p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC);
        }
        p._insertElement(token, NS.HTML);
      }
      function mathStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        adjustTokenMathMLAttrs(token);
        adjustTokenXMLAttrs(token);
        if (token.selfClosing) {
          p._appendElement(token, NS.MATHML);
        } else {
          p._insertElement(token, NS.MATHML);
        }
        token.ackSelfClosing = true;
      }
      function svgStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        adjustTokenSVGAttrs(token);
        adjustTokenXMLAttrs(token);
        if (token.selfClosing) {
          p._appendElement(token, NS.SVG);
        } else {
          p._insertElement(token, NS.SVG);
        }
        token.ackSelfClosing = true;
      }
      function genericStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
      }
      function startTagInBody(p, token) {
        switch (token.tagID) {
        case TAG_ID.I:
        case TAG_ID.S:
        case TAG_ID.B:
        case TAG_ID.U:
        case TAG_ID.EM:
        case TAG_ID.TT:
        case TAG_ID.BIG:
        case TAG_ID.CODE:
        case TAG_ID.FONT:
        case TAG_ID.SMALL:
        case TAG_ID.STRIKE:
        case TAG_ID.STRONG: {
            bStartTagInBody(p, token);
            break;
          }
        case TAG_ID.A: {
            aStartTagInBody(p, token);
            break;
          }
        case TAG_ID.H1:
        case TAG_ID.H2:
        case TAG_ID.H3:
        case TAG_ID.H4:
        case TAG_ID.H5:
        case TAG_ID.H6: {
            numberedHeaderStartTagInBody(p, token);
            break;
          }
        case TAG_ID.P:
        case TAG_ID.DL:
        case TAG_ID.OL:
        case TAG_ID.UL:
        case TAG_ID.DIV:
        case TAG_ID.DIR:
        case TAG_ID.NAV:
        case TAG_ID.MAIN:
        case TAG_ID.MENU:
        case TAG_ID.ASIDE:
        case TAG_ID.CENTER:
        case TAG_ID.FIGURE:
        case TAG_ID.FOOTER:
        case TAG_ID.HEADER:
        case TAG_ID.HGROUP:
        case TAG_ID.DIALOG:
        case TAG_ID.DETAILS:
        case TAG_ID.ADDRESS:
        case TAG_ID.ARTICLE:
        case TAG_ID.SECTION:
        case TAG_ID.SUMMARY:
        case TAG_ID.FIELDSET:
        case TAG_ID.BLOCKQUOTE:
        case TAG_ID.FIGCAPTION: {
            addressStartTagInBody(p, token);
            break;
          }
        case TAG_ID.LI:
        case TAG_ID.DD:
        case TAG_ID.DT: {
            listItemStartTagInBody(p, token);
            break;
          }
        case TAG_ID.BR:
        case TAG_ID.IMG:
        case TAG_ID.WBR:
        case TAG_ID.AREA:
        case TAG_ID.EMBED:
        case TAG_ID.KEYGEN: {
            areaStartTagInBody(p, token);
            break;
          }
        case TAG_ID.HR: {
            hrStartTagInBody(p, token);
            break;
          }
        case TAG_ID.RB:
        case TAG_ID.RTC: {
            rbStartTagInBody(p, token);
            break;
          }
        case TAG_ID.RT:
        case TAG_ID.RP: {
            rtStartTagInBody(p, token);
            break;
          }
        case TAG_ID.PRE:
        case TAG_ID.LISTING: {
            preStartTagInBody(p, token);
            break;
          }
        case TAG_ID.XMP: {
            xmpStartTagInBody(p, token);
            break;
          }
        case TAG_ID.SVG: {
            svgStartTagInBody(p, token);
            break;
          }
        case TAG_ID.HTML: {
            htmlStartTagInBody(p, token);
            break;
          }
        case TAG_ID.BASE:
        case TAG_ID.LINK:
        case TAG_ID.META:
        case TAG_ID.STYLE:
        case TAG_ID.TITLE:
        case TAG_ID.SCRIPT:
        case TAG_ID.BGSOUND:
        case TAG_ID.BASEFONT:
        case TAG_ID.TEMPLATE: {
            startTagInHead(p, token);
            break;
          }
        case TAG_ID.BODY: {
            bodyStartTagInBody(p, token);
            break;
          }
        case TAG_ID.FORM: {
            formStartTagInBody(p, token);
            break;
          }
        case TAG_ID.NOBR: {
            nobrStartTagInBody(p, token);
            break;
          }
        case TAG_ID.MATH: {
            mathStartTagInBody(p, token);
            break;
          }
        case TAG_ID.TABLE: {
            tableStartTagInBody(p, token);
            break;
          }
        case TAG_ID.INPUT: {
            inputStartTagInBody(p, token);
            break;
          }
        case TAG_ID.PARAM:
        case TAG_ID.TRACK:
        case TAG_ID.SOURCE: {
            paramStartTagInBody(p, token);
            break;
          }
        case TAG_ID.IMAGE: {
            imageStartTagInBody(p, token);
            break;
          }
        case TAG_ID.BUTTON: {
            buttonStartTagInBody(p, token);
            break;
          }
        case TAG_ID.APPLET:
        case TAG_ID.OBJECT:
        case TAG_ID.MARQUEE: {
            appletStartTagInBody(p, token);
            break;
          }
        case TAG_ID.IFRAME: {
            iframeStartTagInBody(p, token);
            break;
          }
        case TAG_ID.SELECT: {
            selectStartTagInBody(p, token);
            break;
          }
        case TAG_ID.OPTION:
        case TAG_ID.OPTGROUP: {
            optgroupStartTagInBody(p, token);
            break;
          }
        case TAG_ID.NOEMBED: {
            noembedStartTagInBody(p, token);
            break;
          }
        case TAG_ID.FRAMESET: {
            framesetStartTagInBody(p, token);
            break;
          }
        case TAG_ID.TEXTAREA: {
            textareaStartTagInBody(p, token);
            break;
          }
        case TAG_ID.NOSCRIPT: {
            if (p.options.scriptingEnabled) {
              noembedStartTagInBody(p, token);
            } else {
              genericStartTagInBody(p, token);
            }
            break;
          }
        case TAG_ID.PLAINTEXT: {
            plaintextStartTagInBody(p, token);
            break;
          }
        case TAG_ID.COL:
        case TAG_ID.TH:
        case TAG_ID.TD:
        case TAG_ID.TR:
        case TAG_ID.HEAD:
        case TAG_ID.FRAME:
        case TAG_ID.TBODY:
        case TAG_ID.TFOOT:
        case TAG_ID.THEAD:
        case TAG_ID.CAPTION:
        case TAG_ID.COLGROUP: {
            break;
          }
        default: {
            genericStartTagInBody(p, token);
          }
        }
      }
      function bodyEndTagInBody(p, token) {
        if (p.openElements.hasInScope(TAG_ID.BODY)) {
          p.insertionMode = InsertionMode.AFTER_BODY;
          if (p.options.sourceCodeLocationInfo) {
            const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
            if (bodyElement) {
              p._setEndLocation(bodyElement, token);
            }
          }
        }
      }
      function htmlEndTagInBody(p, token) {
        if (p.openElements.hasInScope(TAG_ID.BODY)) {
          p.insertionMode = InsertionMode.AFTER_BODY;
          endTagAfterBody(p, token);
        }
      }
      function addressEndTagInBody(p, token) {
        const tn = token.tagID;
        if (p.openElements.hasInScope(tn)) {
          p.openElements.generateImpliedEndTags();
          p.openElements.popUntilTagNamePopped(tn);
        }
      }
      function formEndTagInBody(p) {
        const inTemplate = p.openElements.tmplCount > 0;
        const {formElement} = p;
        if (!inTemplate) {
          p.formElement = null;
        }
        if ((formElement || inTemplate) && p.openElements.hasInScope(TAG_ID.FORM)) {
          p.openElements.generateImpliedEndTags();
          if (inTemplate) {
            p.openElements.popUntilTagNamePopped(TAG_ID.FORM);
          } else if (formElement) {
            p.openElements.remove(formElement);
          }
        }
      }
      function pEndTagInBody(p) {
        if (!p.openElements.hasInButtonScope(TAG_ID.P)) {
          p._insertFakeElement(TAG_NAMES.P, TAG_ID.P);
        }
        p._closePElement();
      }
      function liEndTagInBody(p) {
        if (p.openElements.hasInListItemScope(TAG_ID.LI)) {
          p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI);
          p.openElements.popUntilTagNamePopped(TAG_ID.LI);
        }
      }
      function ddEndTagInBody(p, token) {
        const tn = token.tagID;
        if (p.openElements.hasInScope(tn)) {
          p.openElements.generateImpliedEndTagsWithExclusion(tn);
          p.openElements.popUntilTagNamePopped(tn);
        }
      }
      function numberedHeaderEndTagInBody(p) {
        if (p.openElements.hasNumberedHeaderInScope()) {
          p.openElements.generateImpliedEndTags();
          p.openElements.popUntilNumberedHeaderPopped();
        }
      }
      function appletEndTagInBody(p, token) {
        const tn = token.tagID;
        if (p.openElements.hasInScope(tn)) {
          p.openElements.generateImpliedEndTags();
          p.openElements.popUntilTagNamePopped(tn);
          p.activeFormattingElements.clearToLastMarker();
        }
      }
      function brEndTagInBody(p) {
        p._reconstructActiveFormattingElements();
        p._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR);
        p.openElements.pop();
        p.framesetOk = false;
      }
      function genericEndTagInBody(p, token) {
        const tn = token.tagName;
        const tid = token.tagID;
        for (let i = p.openElements.stackTop; i > 0; i--) {
          const element = p.openElements.items[i];
          const elementId = p.openElements.tagIDs[i];
          if (tid === elementId && (tid !== TAG_ID.UNKNOWN || p.treeAdapter.getTagName(element) === tn)) {
            p.openElements.generateImpliedEndTagsWithExclusion(tid);
            if (p.openElements.stackTop >= i)
              p.openElements.shortenToLength(i);
            break;
          }
          if (p._isSpecialElement(element, elementId)) {
            break;
          }
        }
      }
      function endTagInBody(p, token) {
        switch (token.tagID) {
        case TAG_ID.A:
        case TAG_ID.B:
        case TAG_ID.I:
        case TAG_ID.S:
        case TAG_ID.U:
        case TAG_ID.EM:
        case TAG_ID.TT:
        case TAG_ID.BIG:
        case TAG_ID.CODE:
        case TAG_ID.FONT:
        case TAG_ID.NOBR:
        case TAG_ID.SMALL:
        case TAG_ID.STRIKE:
        case TAG_ID.STRONG: {
            callAdoptionAgency(p, token);
            break;
          }
        case TAG_ID.P: {
            pEndTagInBody(p);
            break;
          }
        case TAG_ID.DL:
        case TAG_ID.UL:
        case TAG_ID.OL:
        case TAG_ID.DIR:
        case TAG_ID.DIV:
        case TAG_ID.NAV:
        case TAG_ID.PRE:
        case TAG_ID.MAIN:
        case TAG_ID.MENU:
        case TAG_ID.ASIDE:
        case TAG_ID.CENTER:
        case TAG_ID.FIGURE:
        case TAG_ID.FOOTER:
        case TAG_ID.HEADER:
        case TAG_ID.HGROUP:
        case TAG_ID.DIALOG:
        case TAG_ID.ADDRESS:
        case TAG_ID.ARTICLE:
        case TAG_ID.DETAILS:
        case TAG_ID.SECTION:
        case TAG_ID.SUMMARY:
        case TAG_ID.LISTING:
        case TAG_ID.FIELDSET:
        case TAG_ID.BLOCKQUOTE:
        case TAG_ID.FIGCAPTION: {
            addressEndTagInBody(p, token);
            break;
          }
        case TAG_ID.LI: {
            liEndTagInBody(p);
            break;
          }
        case TAG_ID.DD:
        case TAG_ID.DT: {
            ddEndTagInBody(p, token);
            break;
          }
        case TAG_ID.H1:
        case TAG_ID.H2:
        case TAG_ID.H3:
        case TAG_ID.H4:
        case TAG_ID.H5:
        case TAG_ID.H6: {
            numberedHeaderEndTagInBody(p);
            break;
          }
        case TAG_ID.BR: {
            brEndTagInBody(p);
            break;
          }
        case TAG_ID.BODY: {
            bodyEndTagInBody(p, token);
            break;
          }
        case TAG_ID.HTML: {
            htmlEndTagInBody(p, token);
            break;
          }
        case TAG_ID.FORM: {
            formEndTagInBody(p);
            break;
          }
        case TAG_ID.APPLET:
        case TAG_ID.OBJECT:
        case TAG_ID.MARQUEE: {
            appletEndTagInBody(p, token);
            break;
          }
        case TAG_ID.TEMPLATE: {
            endTagInHead(p, token);
            break;
          }
        default: {
            genericEndTagInBody(p, token);
          }
        }
      }
      function eofInBody(p, token) {
        if (p.tmplInsertionModeStack.length > 0) {
          eofInTemplate(p, token);
        } else {
          stopParsing(p, token);
        }
      }
      function endTagInText(p, token) {
        var _a;
        if (token.tagID === TAG_ID.SCRIPT) {
          (_a = p.scriptHandler) === null || _a === void 0 ? void 0 : _a.call(p, p.openElements.current);
        }
        p.openElements.pop();
        p.insertionMode = p.originalInsertionMode;
      }
      function eofInText(p, token) {
        p._err(token, ERR.eofInElementThatCanContainOnlyText);
        p.openElements.pop();
        p.insertionMode = p.originalInsertionMode;
        p.onEof(token);
      }
      function characterInTable(p, token) {
        if (TABLE_STRUCTURE_TAGS.has(p.openElements.currentTagId)) {
          p.pendingCharacterTokens.length = 0;
          p.hasNonWhitespacePendingCharacterToken = false;
          p.originalInsertionMode = p.insertionMode;
          p.insertionMode = InsertionMode.IN_TABLE_TEXT;
          switch (token.type) {
          case TokenType.CHARACTER: {
              characterInTableText(p, token);
              break;
            }
          case TokenType.WHITESPACE_CHARACTER: {
              whitespaceCharacterInTableText(p, token);
              break;
            }
          }
        } else {
          tokenInTable(p, token);
        }
      }
      function captionStartTagInTable(p, token) {
        p.openElements.clearBackToTableContext();
        p.activeFormattingElements.insertMarker();
        p._insertElement(token, NS.HTML);
        p.insertionMode = InsertionMode.IN_CAPTION;
      }
      function colgroupStartTagInTable(p, token) {
        p.openElements.clearBackToTableContext();
        p._insertElement(token, NS.HTML);
        p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
      }
      function colStartTagInTable(p, token) {
        p.openElements.clearBackToTableContext();
        p._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP);
        p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
        startTagInColumnGroup(p, token);
      }
      function tbodyStartTagInTable(p, token) {
        p.openElements.clearBackToTableContext();
        p._insertElement(token, NS.HTML);
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
      }
      function tdStartTagInTable(p, token) {
        p.openElements.clearBackToTableContext();
        p._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY);
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody(p, token);
      }
      function tableStartTagInTable(p, token) {
        if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
          p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
          p._resetInsertionMode();
          p._processStartTag(token);
        }
      }
      function inputStartTagInTable(p, token) {
        if (isHiddenInput(token)) {
          p._appendElement(token, NS.HTML);
        } else {
          tokenInTable(p, token);
        }
        token.ackSelfClosing = true;
      }
      function formStartTagInTable(p, token) {
        if (!p.formElement && p.openElements.tmplCount === 0) {
          p._insertElement(token, NS.HTML);
          p.formElement = p.openElements.current;
          p.openElements.pop();
        }
      }
      function startTagInTable(p, token) {
        switch (token.tagID) {
        case TAG_ID.TD:
        case TAG_ID.TH:
        case TAG_ID.TR: {
            tdStartTagInTable(p, token);
            break;
          }
        case TAG_ID.STYLE:
        case TAG_ID.SCRIPT:
        case TAG_ID.TEMPLATE: {
            startTagInHead(p, token);
            break;
          }
        case TAG_ID.COL: {
            colStartTagInTable(p, token);
            break;
          }
        case TAG_ID.FORM: {
            formStartTagInTable(p, token);
            break;
          }
        case TAG_ID.TABLE: {
            tableStartTagInTable(p, token);
            break;
          }
        case TAG_ID.TBODY:
        case TAG_ID.TFOOT:
        case TAG_ID.THEAD: {
            tbodyStartTagInTable(p, token);
            break;
          }
        case TAG_ID.INPUT: {
            inputStartTagInTable(p, token);
            break;
          }
        case TAG_ID.CAPTION: {
            captionStartTagInTable(p, token);
            break;
          }
        case TAG_ID.COLGROUP: {
            colgroupStartTagInTable(p, token);
            break;
          }
        default: {
            tokenInTable(p, token);
          }
        }
      }
      function endTagInTable(p, token) {
        switch (token.tagID) {
        case TAG_ID.TABLE: {
            if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
              p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
              p._resetInsertionMode();
            }
            break;
          }
        case TAG_ID.TEMPLATE: {
            endTagInHead(p, token);
            break;
          }
        case TAG_ID.BODY:
        case TAG_ID.CAPTION:
        case TAG_ID.COL:
        case TAG_ID.COLGROUP:
        case TAG_ID.HTML:
        case TAG_ID.TBODY:
        case TAG_ID.TD:
        case TAG_ID.TFOOT:
        case TAG_ID.TH:
        case TAG_ID.THEAD:
        case TAG_ID.TR: {
            break;
          }
        default: {
            tokenInTable(p, token);
          }
        }
      }
      function tokenInTable(p, token) {
        const savedFosterParentingState = p.fosterParentingEnabled;
        p.fosterParentingEnabled = true;
        modeInBody(p, token);
        p.fosterParentingEnabled = savedFosterParentingState;
      }
      function whitespaceCharacterInTableText(p, token) {
        p.pendingCharacterTokens.push(token);
      }
      function characterInTableText(p, token) {
        p.pendingCharacterTokens.push(token);
        p.hasNonWhitespacePendingCharacterToken = true;
      }
      function tokenInTableText(p, token) {
        let i = 0;
        if (p.hasNonWhitespacePendingCharacterToken) {
          for (; i < p.pendingCharacterTokens.length; i++) {
            tokenInTable(p, p.pendingCharacterTokens[i]);
          }
        } else {
          for (; i < p.pendingCharacterTokens.length; i++) {
            p._insertCharacters(p.pendingCharacterTokens[i]);
          }
        }
        p.insertionMode = p.originalInsertionMode;
        p._processToken(token);
      }
      const TABLE_VOID_ELEMENTS = new Set([
        TAG_ID.CAPTION,
        TAG_ID.COL,
        TAG_ID.COLGROUP,
        TAG_ID.TBODY,
        TAG_ID.TD,
        TAG_ID.TFOOT,
        TAG_ID.TH,
        TAG_ID.THEAD,
        TAG_ID.TR
      ]);
      function startTagInCaption(p, token) {
        const tn = token.tagID;
        if (TABLE_VOID_ELEMENTS.has(tn)) {
          if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
            p.activeFormattingElements.clearToLastMarker();
            p.insertionMode = InsertionMode.IN_TABLE;
            startTagInTable(p, token);
          }
        } else {
          startTagInBody(p, token);
        }
      }
      function endTagInCaption(p, token) {
        const tn = token.tagID;
        switch (tn) {
        case TAG_ID.CAPTION:
        case TAG_ID.TABLE: {
            if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
              p.openElements.generateImpliedEndTags();
              p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
              p.activeFormattingElements.clearToLastMarker();
              p.insertionMode = InsertionMode.IN_TABLE;
              if (tn === TAG_ID.TABLE) {
                endTagInTable(p, token);
              }
            }
            break;
          }
        case TAG_ID.BODY:
        case TAG_ID.COL:
        case TAG_ID.COLGROUP:
        case TAG_ID.HTML:
        case TAG_ID.TBODY:
        case TAG_ID.TD:
        case TAG_ID.TFOOT:
        case TAG_ID.TH:
        case TAG_ID.THEAD:
        case TAG_ID.TR: {
            break;
          }
        default: {
            endTagInBody(p, token);
          }
        }
      }
      function startTagInColumnGroup(p, token) {
        switch (token.tagID) {
        case TAG_ID.HTML: {
            startTagInBody(p, token);
            break;
          }
        case TAG_ID.COL: {
            p._appendElement(token, NS.HTML);
            token.ackSelfClosing = true;
            break;
          }
        case TAG_ID.TEMPLATE: {
            startTagInHead(p, token);
            break;
          }
        default: {
            tokenInColumnGroup(p, token);
          }
        }
      }
      function endTagInColumnGroup(p, token) {
        switch (token.tagID) {
        case TAG_ID.COLGROUP: {
            if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
              p.openElements.pop();
              p.insertionMode = InsertionMode.IN_TABLE;
            }
            break;
          }
        case TAG_ID.TEMPLATE: {
            endTagInHead(p, token);
            break;
          }
        case TAG_ID.COL: {
            break;
          }
        default: {
            tokenInColumnGroup(p, token);
          }
        }
      }
      function tokenInColumnGroup(p, token) {
        if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE;
          p._processToken(token);
        }
      }
      function startTagInTableBody(p, token) {
        switch (token.tagID) {
        case TAG_ID.TR: {
            p.openElements.clearBackToTableBodyContext();
            p._insertElement(token, NS.HTML);
            p.insertionMode = InsertionMode.IN_ROW;
            break;
          }
        case TAG_ID.TH:
        case TAG_ID.TD: {
            p.openElements.clearBackToTableBodyContext();
            p._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR);
            p.insertionMode = InsertionMode.IN_ROW;
            startTagInRow(p, token);
            break;
          }
        case TAG_ID.CAPTION:
        case TAG_ID.COL:
        case TAG_ID.COLGROUP:
        case TAG_ID.TBODY:
        case TAG_ID.TFOOT:
        case TAG_ID.THEAD: {
            if (p.openElements.hasTableBodyContextInTableScope()) {
              p.openElements.clearBackToTableBodyContext();
              p.openElements.pop();
              p.insertionMode = InsertionMode.IN_TABLE;
              startTagInTable(p, token);
            }
            break;
          }
        default: {
            startTagInTable(p, token);
          }
        }
      }
      function endTagInTableBody(p, token) {
        const tn = token.tagID;
        switch (token.tagID) {
        case TAG_ID.TBODY:
        case TAG_ID.TFOOT:
        case TAG_ID.THEAD: {
            if (p.openElements.hasInTableScope(tn)) {
              p.openElements.clearBackToTableBodyContext();
              p.openElements.pop();
              p.insertionMode = InsertionMode.IN_TABLE;
            }
            break;
          }
        case TAG_ID.TABLE: {
            if (p.openElements.hasTableBodyContextInTableScope()) {
              p.openElements.clearBackToTableBodyContext();
              p.openElements.pop();
              p.insertionMode = InsertionMode.IN_TABLE;
              endTagInTable(p, token);
            }
            break;
          }
        case TAG_ID.BODY:
        case TAG_ID.CAPTION:
        case TAG_ID.COL:
        case TAG_ID.COLGROUP:
        case TAG_ID.HTML:
        case TAG_ID.TD:
        case TAG_ID.TH:
        case TAG_ID.TR: {
            break;
          }
        default: {
            endTagInTable(p, token);
          }
        }
      }
      function startTagInRow(p, token) {
        switch (token.tagID) {
        case TAG_ID.TH:
        case TAG_ID.TD: {
            p.openElements.clearBackToTableRowContext();
            p._insertElement(token, NS.HTML);
            p.insertionMode = InsertionMode.IN_CELL;
            p.activeFormattingElements.insertMarker();
            break;
          }
        case TAG_ID.CAPTION:
        case TAG_ID.COL:
        case TAG_ID.COLGROUP:
        case TAG_ID.TBODY:
        case TAG_ID.TFOOT:
        case TAG_ID.THEAD:
        case TAG_ID.TR: {
            if (p.openElements.hasInTableScope(TAG_ID.TR)) {
              p.openElements.clearBackToTableRowContext();
              p.openElements.pop();
              p.insertionMode = InsertionMode.IN_TABLE_BODY;
              startTagInTableBody(p, token);
            }
            break;
          }
        default: {
            startTagInTable(p, token);
          }
        }
      }
      function endTagInRow(p, token) {
        switch (token.tagID) {
        case TAG_ID.TR: {
            if (p.openElements.hasInTableScope(TAG_ID.TR)) {
              p.openElements.clearBackToTableRowContext();
              p.openElements.pop();
              p.insertionMode = InsertionMode.IN_TABLE_BODY;
            }
            break;
          }
        case TAG_ID.TABLE: {
            if (p.openElements.hasInTableScope(TAG_ID.TR)) {
              p.openElements.clearBackToTableRowContext();
              p.openElements.pop();
              p.insertionMode = InsertionMode.IN_TABLE_BODY;
              endTagInTableBody(p, token);
            }
            break;
          }
        case TAG_ID.TBODY:
        case TAG_ID.TFOOT:
        case TAG_ID.THEAD: {
            if (p.openElements.hasInTableScope(token.tagID) || p.openElements.hasInTableScope(TAG_ID.TR)) {
              p.openElements.clearBackToTableRowContext();
              p.openElements.pop();
              p.insertionMode = InsertionMode.IN_TABLE_BODY;
              endTagInTableBody(p, token);
            }
            break;
          }
        case TAG_ID.BODY:
        case TAG_ID.CAPTION:
        case TAG_ID.COL:
        case TAG_ID.COLGROUP:
        case TAG_ID.HTML:
        case TAG_ID.TD:
        case TAG_ID.TH: {
            break;
          }
        default:
          endTagInTable(p, token);
        }
      }
      function startTagInCell(p, token) {
        const tn = token.tagID;
        if (TABLE_VOID_ELEMENTS.has(tn)) {
          if (p.openElements.hasInTableScope(TAG_ID.TD) || p.openElements.hasInTableScope(TAG_ID.TH)) {
            p._closeTableCell();
            startTagInRow(p, token);
          }
        } else {
          startTagInBody(p, token);
        }
      }
      function endTagInCell(p, token) {
        const tn = token.tagID;
        switch (tn) {
        case TAG_ID.TD:
        case TAG_ID.TH: {
            if (p.openElements.hasInTableScope(tn)) {
              p.openElements.generateImpliedEndTags();
              p.openElements.popUntilTagNamePopped(tn);
              p.activeFormattingElements.clearToLastMarker();
              p.insertionMode = InsertionMode.IN_ROW;
            }
            break;
          }
        case TAG_ID.TABLE:
        case TAG_ID.TBODY:
        case TAG_ID.TFOOT:
        case TAG_ID.THEAD:
        case TAG_ID.TR: {
            if (p.openElements.hasInTableScope(tn)) {
              p._closeTableCell();
              endTagInRow(p, token);
            }
            break;
          }
        case TAG_ID.BODY:
        case TAG_ID.CAPTION:
        case TAG_ID.COL:
        case TAG_ID.COLGROUP:
        case TAG_ID.HTML: {
            break;
          }
        default: {
            endTagInBody(p, token);
          }
        }
      }
      function startTagInSelect(p, token) {
        switch (token.tagID) {
        case TAG_ID.HTML: {
            startTagInBody(p, token);
            break;
          }
        case TAG_ID.OPTION: {
            if (p.openElements.currentTagId === TAG_ID.OPTION) {
              p.openElements.pop();
            }
            p._insertElement(token, NS.HTML);
            break;
          }
        case TAG_ID.OPTGROUP: {
            if (p.openElements.currentTagId === TAG_ID.OPTION) {
              p.openElements.pop();
            }
            if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
              p.openElements.pop();
            }
            p._insertElement(token, NS.HTML);
            break;
          }
        case TAG_ID.INPUT:
        case TAG_ID.KEYGEN:
        case TAG_ID.TEXTAREA:
        case TAG_ID.SELECT: {
            if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
              p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
              p._resetInsertionMode();
              if (token.tagID !== TAG_ID.SELECT) {
                p._processStartTag(token);
              }
            }
            break;
          }
        case TAG_ID.SCRIPT:
        case TAG_ID.TEMPLATE: {
            startTagInHead(p, token);
            break;
          }
        }
      }
      function endTagInSelect(p, token) {
        switch (token.tagID) {
        case TAG_ID.OPTGROUP: {
            if (p.openElements.stackTop > 0 && p.openElements.currentTagId === TAG_ID.OPTION && p.openElements.tagIDs[p.openElements.stackTop - 1] === TAG_ID.OPTGROUP) {
              p.openElements.pop();
            }
            if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
              p.openElements.pop();
            }
            break;
          }
        case TAG_ID.OPTION: {
            if (p.openElements.currentTagId === TAG_ID.OPTION) {
              p.openElements.pop();
            }
            break;
          }
        case TAG_ID.SELECT: {
            if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
              p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
              p._resetInsertionMode();
            }
            break;
          }
        case TAG_ID.TEMPLATE: {
            endTagInHead(p, token);
            break;
          }
        }
      }
      function startTagInSelectInTable(p, token) {
        const tn = token.tagID;
        if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
          p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
          p._resetInsertionMode();
          p._processStartTag(token);
        } else {
          startTagInSelect(p, token);
        }
      }
      function endTagInSelectInTable(p, token) {
        const tn = token.tagID;
        if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
          if (p.openElements.hasInTableScope(tn)) {
            p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
            p._resetInsertionMode();
            p.onEndTag(token);
          }
        } else {
          endTagInSelect(p, token);
        }
      }
      function startTagInTemplate(p, token) {
        switch (token.tagID) {
        case TAG_ID.BASE:
        case TAG_ID.BASEFONT:
        case TAG_ID.BGSOUND:
        case TAG_ID.LINK:
        case TAG_ID.META:
        case TAG_ID.NOFRAMES:
        case TAG_ID.SCRIPT:
        case TAG_ID.STYLE:
        case TAG_ID.TEMPLATE:
        case TAG_ID.TITLE:
          startTagInHead(p, token);
          break;
        case TAG_ID.CAPTION:
        case TAG_ID.COLGROUP:
        case TAG_ID.TBODY:
        case TAG_ID.TFOOT:
        case TAG_ID.THEAD:
          p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
          p.insertionMode = InsertionMode.IN_TABLE;
          startTagInTable(p, token);
          break;
        case TAG_ID.COL:
          p.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
          p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
          startTagInColumnGroup(p, token);
          break;
        case TAG_ID.TR:
          p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
          p.insertionMode = InsertionMode.IN_TABLE_BODY;
          startTagInTableBody(p, token);
          break;
        case TAG_ID.TD:
        case TAG_ID.TH:
          p.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
          p.insertionMode = InsertionMode.IN_ROW;
          startTagInRow(p, token);
          break;
        default:
          p.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
          p.insertionMode = InsertionMode.IN_BODY;
          startTagInBody(p, token);
        }
      }
      function endTagInTemplate(p, token) {
        if (token.tagID === TAG_ID.TEMPLATE) {
          endTagInHead(p, token);
        }
      }
      function eofInTemplate(p, token) {
        if (p.openElements.tmplCount > 0) {
          p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
          p.activeFormattingElements.clearToLastMarker();
          p.tmplInsertionModeStack.shift();
          p._resetInsertionMode();
          p.onEof(token);
        } else {
          stopParsing(p, token);
        }
      }
      function startTagAfterBody(p, token) {
        if (token.tagID === TAG_ID.HTML) {
          startTagInBody(p, token);
        } else {
          tokenAfterBody(p, token);
        }
      }
      function endTagAfterBody(p, token) {
        var _a;
        if (token.tagID === TAG_ID.HTML) {
          if (!p.fragmentContext) {
            p.insertionMode = InsertionMode.AFTER_AFTER_BODY;
          }
          if (p.options.sourceCodeLocationInfo && p.openElements.tagIDs[0] === TAG_ID.HTML) {
            p._setEndLocation(p.openElements.items[0], token);
            const bodyElement = p.openElements.items[1];
            if (bodyElement && !((_a = p.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a === void 0 ? void 0 : _a.endTag)) {
              p._setEndLocation(bodyElement, token);
            }
          }
        } else {
          tokenAfterBody(p, token);
        }
      }
      function tokenAfterBody(p, token) {
        p.insertionMode = InsertionMode.IN_BODY;
        modeInBody(p, token);
      }
      function startTagInFrameset(p, token) {
        switch (token.tagID) {
        case TAG_ID.HTML: {
            startTagInBody(p, token);
            break;
          }
        case TAG_ID.FRAMESET: {
            p._insertElement(token, NS.HTML);
            break;
          }
        case TAG_ID.FRAME: {
            p._appendElement(token, NS.HTML);
            token.ackSelfClosing = true;
            break;
          }
        case TAG_ID.NOFRAMES: {
            startTagInHead(p, token);
            break;
          }
        }
      }
      function endTagInFrameset(p, token) {
        if (token.tagID === TAG_ID.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
          p.openElements.pop();
          if (!p.fragmentContext && p.openElements.currentTagId !== TAG_ID.FRAMESET) {
            p.insertionMode = InsertionMode.AFTER_FRAMESET;
          }
        }
      }
      function startTagAfterFrameset(p, token) {
        switch (token.tagID) {
        case TAG_ID.HTML: {
            startTagInBody(p, token);
            break;
          }
        case TAG_ID.NOFRAMES: {
            startTagInHead(p, token);
            break;
          }
        }
      }
      function endTagAfterFrameset(p, token) {
        if (token.tagID === TAG_ID.HTML) {
          p.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
        }
      }
      function startTagAfterAfterBody(p, token) {
        if (token.tagID === TAG_ID.HTML) {
          startTagInBody(p, token);
        } else {
          tokenAfterAfterBody(p, token);
        }
      }
      function tokenAfterAfterBody(p, token) {
        p.insertionMode = InsertionMode.IN_BODY;
        modeInBody(p, token);
      }
      function startTagAfterAfterFrameset(p, token) {
        switch (token.tagID) {
        case TAG_ID.HTML: {
            startTagInBody(p, token);
            break;
          }
        case TAG_ID.NOFRAMES: {
            startTagInHead(p, token);
            break;
          }
        }
      }
      function nullCharacterInForeignContent(p, token) {
        token.chars = REPLACEMENT_CHARACTER;
        p._insertCharacters(token);
      }
      function characterInForeignContent(p, token) {
        p._insertCharacters(token);
        p.framesetOk = false;
      }
      function popUntilHtmlOrIntegrationPoint(p) {
        while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML && !p._isIntegrationPoint(p.openElements.currentTagId, p.openElements.current)) {
          p.openElements.pop();
        }
      }
      function startTagInForeignContent(p, token) {
        if (causesExit(token)) {
          popUntilHtmlOrIntegrationPoint(p);
          p._startTagOutsideForeignContent(token);
        } else {
          const current = p._getAdjustedCurrentElement();
          const currentNs = p.treeAdapter.getNamespaceURI(current);
          if (currentNs === NS.MATHML) {
            adjustTokenMathMLAttrs(token);
          } else if (currentNs === NS.SVG) {
            adjustTokenSVGTagName(token);
            adjustTokenSVGAttrs(token);
          }
          adjustTokenXMLAttrs(token);
          if (token.selfClosing) {
            p._appendElement(token, currentNs);
          } else {
            p._insertElement(token, currentNs);
          }
          token.ackSelfClosing = true;
        }
      }
      function endTagInForeignContent(p, token) {
        if (token.tagID === TAG_ID.P || token.tagID === TAG_ID.BR) {
          popUntilHtmlOrIntegrationPoint(p);
          p._endTagOutsideForeignContent(token);
          return;
        }
        for (let i = p.openElements.stackTop; i > 0; i--) {
          const element = p.openElements.items[i];
          if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {
            p._endTagOutsideForeignContent(token);
            break;
          }
          const tagName = p.treeAdapter.getTagName(element);
          if (tagName.toLowerCase() === token.tagName) {
            token.tagName = tagName;
            p.openElements.shortenToLength(i);
            break;
          }
        }
      }
      const VOID_ELEMENTS = new Set([
        TAG_NAMES.AREA,
        TAG_NAMES.BASE,
        TAG_NAMES.BASEFONT,
        TAG_NAMES.BGSOUND,
        TAG_NAMES.BR,
        TAG_NAMES.COL,
        TAG_NAMES.EMBED,
        TAG_NAMES.FRAME,
        TAG_NAMES.HR,
        TAG_NAMES.IMG,
        TAG_NAMES.INPUT,
        TAG_NAMES.KEYGEN,
        TAG_NAMES.LINK,
        TAG_NAMES.META,
        TAG_NAMES.PARAM,
        TAG_NAMES.SOURCE,
        TAG_NAMES.TRACK,
        TAG_NAMES.WBR
      ]);
      function isVoidElement(node, options) {
        return options.treeAdapter.isElementNode(node) && options.treeAdapter.getNamespaceURI(node) === NS.HTML && VOID_ELEMENTS.has(options.treeAdapter.getTagName(node));
      }
      const defaultOpts = {
        treeAdapter: defaultTreeAdapter,
        scriptingEnabled: true
      };
      function serialize(node, options) {
        const opts = {
          ...defaultOpts,
          ...options
        };
        if (isVoidElement(node, opts)) {
          return "";
        }
        return serializeChildNodes(node, opts);
      }
      function serializeOuter(node, options) {
        const opts = {
          ...defaultOpts,
          ...options
        };
        return serializeNode(node, opts);
      }
      function serializeChildNodes(parentNode, options) {
        let html = "";
        const container = options.treeAdapter.isElementNode(parentNode) && options.treeAdapter.getTagName(parentNode) === TAG_NAMES.TEMPLATE && options.treeAdapter.getNamespaceURI(parentNode) === NS.HTML ? options.treeAdapter.getTemplateContent(parentNode) : parentNode;
        const childNodes = options.treeAdapter.getChildNodes(container);
        if (childNodes) {
          for (const currentNode of childNodes) {
            html += serializeNode(currentNode, options);
          }
        }
        return html;
      }
      function serializeNode(node, options) {
        if (options.treeAdapter.isElementNode(node)) {
          return serializeElement(node, options);
        }
        if (options.treeAdapter.isTextNode(node)) {
          return serializeTextNode(node, options);
        }
        if (options.treeAdapter.isCommentNode(node)) {
          return serializeCommentNode(node, options);
        }
        if (options.treeAdapter.isDocumentTypeNode(node)) {
          return serializeDocumentTypeNode(node, options);
        }
        return "";
      }
      function serializeElement(node, options) {
        const tn = options.treeAdapter.getTagName(node);
        return `<${ tn }${ serializeAttributes(node, options) }>${ isVoidElement(node, options) ? "" : `${ serializeChildNodes(node, options) }</${ tn }>` }`;
      }
      function serializeAttributes(node, {treeAdapter}) {
        let html = "";
        for (const attr of treeAdapter.getAttrList(node)) {
          html += " ";
          if (!attr.namespace) {
            html += attr.name;
          } else
            switch (attr.namespace) {
            case NS.XML: {
                html += `xml:${ attr.name }`;
                break;
              }
            case NS.XMLNS: {
                if (attr.name !== "xmlns") {
                  html += "xmlns:";
                }
                html += attr.name;
                break;
              }
            case NS.XLINK: {
                html += `xlink:${ attr.name }`;
                break;
              }
            default: {
                html += `${ attr.prefix }:${ attr.name }`;
              }
            }
          html += `="${ escapeAttribute(attr.value) }"`;
        }
        return html;
      }
      function serializeTextNode(node, options) {
        const {treeAdapter} = options;
        const content = treeAdapter.getTextNodeContent(node);
        const parent = treeAdapter.getParentNode(node);
        const parentTn = parent && treeAdapter.isElementNode(parent) && treeAdapter.getTagName(parent);
        return parentTn && treeAdapter.getNamespaceURI(parent) === NS.HTML && hasUnescapedText(parentTn, options.scriptingEnabled) ? content : escapeText(content);
      }
      function serializeCommentNode(node, {treeAdapter}) {
        return `<!--${ treeAdapter.getCommentNodeContent(node) }-->`;
      }
      function serializeDocumentTypeNode(node, {treeAdapter}) {
        return `<!DOCTYPE ${ treeAdapter.getDocumentTypeNodeName(node) }>`;
      }
      function parse(html, options) {
        return Parser.parse(html, options);
      }
      function parseFragment(fragmentContext, html, options) {
        if (typeof fragmentContext === "string") {
          options = html;
          html = fragmentContext;
          fragmentContext = null;
        }
        const parser = Parser.getFragmentParser(fragmentContext, options);
        parser.tokenizer.write(html, true);
        return parser.getFragment();
      }

      var parse5 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Parser: Parser,
        Token: token,
        Tokenizer: Tokenizer,
        TokenizerMode: TokenizerMode,
        defaultTreeAdapter: defaultTreeAdapter,
        foreignContent: foreignContent$1,
        html: html$1,
        parse: parse,
        parseFragment: parseFragment,
        serialize: serialize,
        serializeOuter: serializeOuter
      });

      var __varRecorder__$l = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/html/editor-plugin.js", __contextModule__);
      var __moduleMeta__$a = {
        pathInPackage: function pathInPackage() {
          return "./html/editor-plugin.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var tidyHtml = __varRecorder__$l["lively.ide/html/editor-plugin.js__define__"]("tidyHtml", "function", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(htmlSrc) {
          var beautify;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.next = 3;
                  return lively.modules.module("esm://cache/js-beautify").load({
                    format: "global"
                  });

                case 3:
                  __varRecorder__$l.__inter0__ = _context.sent;
                  beautify = __varRecorder__$l.__inter0__["default"];
                  __varRecorder__$l.__inter0__;
                  _context.next = 15;
                  break;

                case 8:
                  _context.prev = 8;
                  _context.t0 = _context["catch"](0);
                  _context.next = 12;
                  return lively.modules.module("esm://cache/js-beautify").load({
                    format: "global"
                  });

                case 12:
                  __varRecorder__$l.__inter1__ = _context.sent;
                  beautify = __varRecorder__$l.__inter1__["default"];
                  __varRecorder__$l.__inter1__;

                case 15:
                  return _context.abrupt("return", beautify.html(htmlSrc));

                case 16:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[0, 8]]);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }(), __moduleMeta__$a);

      __varRecorder__$l.tidyHtml = tidyHtml;
      __varRecorder__$l.tidyHtml = tidyHtml;
      __varRecorder__$l.commands = [{
        name: "[HTML] cleanup",
        exec: function () {
          var _exec = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(text) {
            var undo;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    undo = text.undoManager.ensureNewGroup(text, "[HTML] cleanup");
                    _context3.next = 3;
                    return text.saveExcursion( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                      return regeneratorRuntime.wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              if (text.selection.isEmpty()) text.selectAll();
                              _context2.next = 3;
                              return __varRecorder__$l.tidyHtml(text.textString);

                            case 3:
                              text.textString = _context2.sent;
                              text.selectAll();
                              text.execCommand("indent according to mode");

                            case 6:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2);
                    })));

                  case 3:
                    text.undoManager.group(undo);
                    return _context3.abrupt("return", true);

                  case 5:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));

          function exec(_x2) {
            return _exec.apply(this, arguments);
          }

          return exec;
        }()
      }, {
        name: "[HTML] select open and close tag",
        exec: function exec(text) {
          var plugin = text.editorPlugin;
          var sel = text._multiSelection || text.selection;
          var nav = plugin.getNavigator();
          var ranges = nav.rangesForStartAndEndTag(text, text.cursorPosition, plugin.parse());

          if (ranges) {
            if (ranges.startTag) {
              ranges.startTag.start.column += 1;
              ranges.startTag.end = text.document.scanForward(ranges.startTag.start, function (_char, p) {
                return (_char === " " || _char === ">") && p;
              });
              sel.addRange(ranges.startTag);
            }

            if (ranges.endTag) {
              ranges.endTag.start.column += 2;
              ranges.endTag.end.column -= 1;
              sel.addRange(ranges.endTag);
            }
          }

          return true;
        }
      }, {
        name: "[HTML] render in iframe",
        exec: function exec(text) {
          var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var url;
          var win = text.getWindow();
          var iframeMorph = (args.iframe && args.iframe.isIFrameMorph ? args.iframe : null) || win && win.isHTMLWorkspace && win.target || text._iframeMorph;
          if (iframeMorph && !iframeMorph.isIFrameMorph) iframeMorph = null;

          if (!iframeMorph || !iframeMorph.world()) {
            iframeMorph = new IFrameMorph();
            iframeMorph.openInWindow({
              title: "rendered HTML"
            });
            if (win && win.isHTMLWorkspace) win.target = iframeMorph;else text._iframeMorph = iframeMorph;
          }

          if (win && win.isHTMLWorkspace && win.file) url = win.file.url;else if (text.owner && text.owner.isTextEditor) url = text.owner.location;

          if (url) {
            iframeMorph.loadURL(url);
          } else iframeMorph.displayHTML(text.textString);

          return iframeMorph;
        }
      }, {
        name: "[HTML] interactively select HTML node",
        exec: function () {
          var _exec2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(editor) {
            var args,
                currentIndex,
                src,
                p,
                parsed,
                nodes,
                currentNodeIndex,
                printedTree,
                lines,
                interstingNodes,
                counter,
                items,
                choice,
                _ref5,
                startOffset,
                endOffset,
                filterNodes,
                _args5 = arguments;

            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    filterNodes = function _filterNodes(node) {
                      if (node.nodeName !== "#document" && !node.__location) return null;
                      if (node.nodeName === "#text" && !node.value.trim()) return null;
                      var copy = lively.lang.obj.clone(node);

                      if (node.childNodes) {
                        copy.childNodes = node.childNodes.slice().map(function (ea) {
                          return filterNodes(ea);
                        }).filter(Boolean);
                      }

                      return copy;
                    };

                    args = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};
                    currentIndex = editor.positionToIndex(args.startPos || editor.cursorPosition);
                    src = editor.textString;
                    p = editor.editorPlugin;
                    parsed = filterNodes(p.parse());
                    nodes = [];
                    currentNodeIndex = 0;
                    printedTree = printTree(parsed, function (n) {
                      nodes.push(n);
                      return "".concat(n.nodeName);
                    }, function (n) {
                      return n.childNodes;
                    });
                    lines = printedTree.split("\n");
                    interstingNodes = nodes;
                    counter = 0;
                    items = interstingNodes.map(function (n, i) {
                      var index = "".concat(i, "\u2003\u2003\u2003").slice(0, String(lines.length).length);
                      var preview;

                      var _ref3 = n.__location || {},
                          startOffset = _ref3.startOffset,
                          endOffset = _ref3.endOffset;

                      if (typeof startOffset !== "number") {
                        preview = " [virtual]";
                      } else {
                        if (startOffset <= currentIndex && currentIndex <= endOffset) currentNodeIndex = counter;
                        preview = n.nodeName === "#text" ? n.value.trim() || "<empty>" : src.slice(startOffset, endOffset).replace(/\n/g, "");
                      }

                      counter++;
                      return {
                        isListItem: true,
                        value: n,
                        label: ["".concat(index), {
                          fontSize: "80%",
                          textStyleClasses: ["v-center-text"],
                          paddingRight: "10px"
                        }, lines[i], null],
                        annotation: [preview, {
                          fontSize: "80%",
                          textStyleClasses: ["truncated-text"],
                          maxWidth: 180
                        }]
                      };
                    });
                    _context5.next = 15;
                    return editor.saveExcursion( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                      var _varRecorder__$__int, _varRecorder__$__int2;

                      return regeneratorRuntime.wrap(function _callee4$(_context4) {
                        while (1) {
                          switch (_context4.prev = _context4.next) {
                            case 0:
                              _context4.next = 2;
                              return $world.filterableListPrompt("Select node", items, {
                                onSelection: function onSelection(node) {
                                  if (!node.__location) return;
                                  var _node$__location = node.__location,
                                      startOffset = _node$__location.startOffset,
                                      endOffset = _node$__location.endOffset;
                                  editor.removeMarker("selected tag");
                                  editor.flash({
                                    start: editor.indexToPosition(startOffset),
                                    end: editor.indexToPosition(endOffset)
                                  }, {
                                    id: "selected tag",
                                    time: 1000,
                                    fill: Color.rgb(200, 235, 255)
                                  });
                                },
                                preselect: currentNodeIndex,
                                historyId: "lively.morphic-ide-html-select-html-node"
                              });

                            case 2:
                              __varRecorder__$l.__inter2__ = _context4.sent;
                              _varRecorder__$__int = __varRecorder__$l.__inter2__.selected, _varRecorder__$__int2 = _slicedToArray(_varRecorder__$__int, 1), choice = _varRecorder__$__int2[0];
                              __varRecorder__$l.__inter2__;

                            case 5:
                            case "end":
                              return _context4.stop();
                          }
                        }
                      }, _callee4);
                    })));

                  case 15:
                    if (!(typeof args.action === "function")) {
                      _context5.next = 18;
                      break;
                    }

                    args.action(choice);
                    return _context5.abrupt("return", choice);

                  case 18:
                    editor.focus();

                    if (choice) {
                      _context5.next = 21;
                      break;
                    }

                    return _context5.abrupt("return", null);

                  case 21:
                    _ref5 = choice.__location || {}, startOffset = _ref5.startOffset, endOffset = _ref5.endOffset;

                    if (typeof startOffset === "number") {
                      editor.saveMark();
                      editor.selection = {
                        end: editor.indexToPosition(startOffset),
                        start: editor.indexToPosition(endOffset)
                      };
                      editor.scrollCursorIntoView();
                    }

                    return _context5.abrupt("return", choice);

                  case 24:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5);
          }));

          function exec(_x3) {
            return _exec2.apply(this, arguments);
          }

          return exec;
        }()
      }];

      var HTMLEditorPlugin = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/html/editor-plugin.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("HTMLEditorPlugin") && typeof __lively_classholder__.HTMLEditorPlugin === "function" ? __lively_classholder__.HTMLEditorPlugin : __lively_classholder__.HTMLEditorPlugin = function HTMLEditorPlugin(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function HTMLEditorPlugin_initialize_() {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this);
            this.checker = new HTMLChecker();
            this.evalEnvironment = {
              format: "esm",
              targetModule: "lively://lively.next-html-workspace",
              context: null
            };
            return _this;
          }
        }, {
          key: "isHTMLEditorPlugin",
          get: function get() {
            return true;
          }
        }, {
          key: "isJSEditorPlugin",
          get: function get() {
            return true;
          }
        }, {
          key: "shortName",
          get: function get() {
            return "html";
          }
        }, {
          key: "longName",
          get: function get() {
            return "htmlmixed";
          }
        }, {
          key: "cmd_insertstring",
          value: function HTMLEditorPlugin_cmd_insertstring_(string) {
            var morph = this.textMorph;

            var handled = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "cmd_insertstring", this).call(this, string);

            var closeBracket = string === ">";

            if (closeBracket) {
              var pos = Object.assign({}, morph.cursorPosition);

              if (!handled) {
                morph.insertText(">", pos);
                pos.column++;
                handled = true;
              }

              var matching = morph.findMatchingBackward(pos, "left", {
                ">": "<"
              });

              if (matching) {
                var textInBetween = morph.textInRange({
                  start: matching,
                  end: pos
                });
                var match = textInBetween.match(/^\<([a-z0-9\$\!#_\-]+)\>$/i);

                if (match) {
                  morph.insertText("</".concat(match[1], ">"), pos);
                  morph.cursorPosition = pos;
                }
              }

              return true;
            }

            return handled;
          }
        }, {
          key: "openPairs",
          get: function get() {
            return Object.assign({}, initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "openPairs", this), {
              "<": ">"
            });
          }
        }, {
          key: "closePairs",
          get: function get() {
            return Object.assign({}, initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "closePairs", this), {
              ">": "<"
            });
          }
        }, {
          key: "getNavigator",
          value: function HTMLEditorPlugin_getNavigator_() {
            return new HTMLNavigator();
          }
        }, {
          key: "getCompleters",
          value: function HTMLEditorPlugin_getCompleters_(otherCompleters) {
            return completers.concat(otherCompleters);
          }
        }, {
          key: "getCommands",
          value: function HTMLEditorPlugin_getCommands_(otherCommands) {
            return [].concat(_toConsumableArray$1(otherCommands), _toConsumableArray$1(jsIdeCommands), _toConsumableArray$1(jsEditorCommands), _toConsumableArray$1(__varRecorder__$l.commands));
          }
        }, {
          key: "getKeyBindings",
          value: function HTMLEditorPlugin_getKeyBindings_(other) {
            return [].concat(_toConsumableArray$1(other), [{
              command: "[HTML] cleanup",
              keys: "Shift-Tab"
            }, {
              command: "[HTML] select open and close tag",
              keys: "Ctrl-Shift-'"
            }, {
              command: "[HTML] render in iframe",
              keys: "Alt-G"
            }, {
              command: "[HTML] interactively select HTML node",
              keys: "Alt-J"
            }]);
          }
        }, {
          key: "getMenuItems",
          value: function () {
            var _HTMLEditorPlugin_getMenuItems_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(items) {
              var editor, htmlItems;
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      editor = this.textMorph;
                      htmlItems = [{
                        command: "[HTML] render in iframe",
                        alias: "render in iframe",
                        target: editor
                      }, ["selection", [{
                        command: "expandRegion",
                        alias: "expand",
                        target: editor
                      }, {
                        command: "contractRegion",
                        alias: "contract",
                        target: editor
                      }, {
                        command: "[HTML] select open and close tag",
                        alias: "select open/end tag",
                        target: editor
                      }, {
                        command: "[HTML] interactively select HTML node",
                        alias: "select html node...",
                        target: editor
                      }]], {
                        isDivider: true
                      }];
                      return _context6.abrupt("return", htmlItems.concat(items));

                    case 3:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function HTMLEditorPlugin_getMenuItems_(_x4) {
              return _HTMLEditorPlugin_getMenuItems_.apply(this, arguments);
            }

            return HTMLEditorPlugin_getMenuItems_;
          }()
        }, {
          key: "sanatizedJsEnv",
          value: function HTMLEditorPlugin_sanatizedJsEnv_(envMixin) {
            var env = this.evalEnvironment;
            if (!env.systemInterface) env.systemInterface = localInterface;
            return Object.assign({}, env, {}, envMixin);
          }
        }, {
          key: "systemInterface",
          value: function HTMLEditorPlugin_systemInterface_(envMixin) {
            var env = this.sanatizedJsEnv(envMixin);
            return env.systemInterface || localInterface;
          }
        }, {
          key: "setSystemInterface",
          value: function HTMLEditorPlugin_setSystemInterface_(systemInterface) {
            return this.evalEnvironment.systemInterface = systemInterface;
          }
        }, {
          key: "setSystemInterfaceNamed",
          value: function HTMLEditorPlugin_setSystemInterfaceNamed_(interfaceSpec) {
            return this.setSystemInterface(systemInterfaceNamed(interfaceSpec));
          }
        }, {
          key: "runEval",
          value: function HTMLEditorPlugin_runEval_(code, opts) {
            var env = this.sanatizedJsEnv(opts);
            var endpoint = this.systemInterface(env);
            return endpoint.runEval(code, env);
          }
        }, {
          key: "parser",
          get: function get() {
            return parse5;
          }
        }, {
          key: "parse",
          value: function HTMLEditorPlugin_parse_() {
            if (this._ast) return this._ast;
            var parser = this.parser,
                src = this.textMorph.textString;
            return parser ? this._ast = parser.parse(src, {
              locationInfo: true
            }) : null;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "HTMLEditorPlugin";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./html/editor-plugin.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 6947,
          end: 11468
        });
      }({
        referencedAs: "CodeMirrorEnabledEditorPlugin",
        value: CodeMirrorEnabledEditorPlugin
      });
      __varRecorder__$l["default"] = HTMLEditorPlugin;

      var __varRecorder__$k = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/components/helpers.js", __contextModule__);
      var __moduleMeta__$9 = {
        pathInPackage: function pathInPackage() {
          return "./components/helpers.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var getComponentDeclsFromScope = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getComponentDeclsFromScope", "function", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(modId, scope) {
          var mod, componentDecls, _iterator, _step, _decl$declarations$, _decl$declarations$$i, decl, varName, val;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  mod = module$1(modId);

                  if (scope) {
                    _context.next = 5;
                    break;
                  }

                  _context.next = 4;
                  return mod.scope();

                case 4:
                  scope = _context.sent;

                case 5:
                  componentDecls = [];
                  _iterator = _createForOfIteratorHelper(scope.varDecls);
                  _context.prev = 7;

                  _iterator.s();

                case 9:
                  if ((_step = _iterator.n()).done) {
                    _context.next = 18;
                    break;
                  }

                  decl = _step.value;
                  varName = (_decl$declarations$ = decl.declarations[0]) === null || _decl$declarations$ === void 0 ? void 0 : (_decl$declarations$$i = _decl$declarations$.id) === null || _decl$declarations$$i === void 0 ? void 0 : _decl$declarations$$i.name;

                  if (varName) {
                    _context.next = 14;
                    break;
                  }

                  return _context.abrupt("continue", 16);

                case 14:
                  val = mod.recorder[varName];

                  if (val === null || val === void 0 ? void 0 : val.isComponentDescriptor) {
                    componentDecls.push([val, decl]);
                  }

                case 16:
                  _context.next = 9;
                  break;

                case 18:
                  _context.next = 23;
                  break;

                case 20:
                  _context.prev = 20;
                  _context.t0 = _context["catch"](7);

                  _iterator.e(_context.t0);

                case 23:
                  _context.prev = 23;

                  _iterator.f();

                  return _context.finish(23);

                case 26:
                  return _context.abrupt("return", componentDecls);

                case 27:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[7, 20, 23, 26]]);
        }));

        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }(), __moduleMeta__$9);

      __varRecorder__$k.getComponentDeclsFromScope = getComponentDeclsFromScope;

      var getEligibleSourceEditorsFor = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getEligibleSourceEditorsFor", "function", function (modId, modSource) {
        var qualifiedEditors = $world.withAllSubmorphsSelect(function (m) {
          var _m$editorPlugin, _m$editorPlugin$evalE;

          return m.isText && ((_m$editorPlugin = m.editorPlugin) === null || _m$editorPlugin === void 0 ? void 0 : (_m$editorPlugin$evalE = _m$editorPlugin.evalEnvironment) === null || _m$editorPlugin$evalE === void 0 ? void 0 : _m$editorPlugin$evalE.targetModule) === modId;
        });
        return qualifiedEditors.filter(function (editor) {
          if (editor.owner.isBrowser && modSource) return !editor.owner.hasUnsavedChanges(modSource);
          return true;
        });
      }, __moduleMeta__$9);

      __varRecorder__$k.getEligibleSourceEditorsFor = getEligibleSourceEditorsFor;

      var getPathFromScopeMaster = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getPathFromScopeMaster", "function", function (m) {
        if (m.isComponent) return [];
        return takeWhile(m.ownerChain(), function (m) {
          return !m.isComponent;
        }).map(function (m) {
          return m.name;
        });
      }, __moduleMeta__$9);

      __varRecorder__$k.getPathFromScopeMaster = getPathFromScopeMaster;

      var getPathFromMorphToMaster = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getPathFromMorphToMaster", "function", function (m) {
        var path = [];
        if (!m.isComponent) path.push(m.name);
        path.push.apply(path, _toConsumableArray$1(__varRecorder__$k.getPathFromScopeMaster(m)));
        return path;
      }, __moduleMeta__$9);

      __varRecorder__$k.getPathFromMorphToMaster = getPathFromMorphToMaster;

      var standardValueTransform = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("standardValueTransform", "function", function (key, val, aMorph) {
        if (val && val.isPoint) return val.roundTo(0.1);

        if (key === "label" || key === "textAndAttributes") {
          var hit;

          if (Array.isArray(val) && (hit = Object.entries(Icons).find(function (_ref2) {
            var _ref3 = _slicedToArray(_ref2, 2);
                _ref3[0];
                var iconValue = _ref3[1];

            return iconValue.code === val[0];
          }))) {
            return {
              __serialize__: function __serialize__() {
                return {
                  __expr__: "Icon.textAttribute(\"".concat(hit[0], "\")"),
                  bindings: {
                    "lively.morphic/text/icons.js": ["Icon"]
                  }
                };
              }
            };
          }
        }

        return val;
      }, __moduleMeta__$9);

      __varRecorder__$k.standardValueTransform = standardValueTransform;

      var convertToExpression = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("convertToExpression", "function", function (aMorph) {
        var _expr$match;

        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var _ref4 = serializeSpec(aMorph, Object.assign({
          asExpression: true,
          keepFunctions: false,
          exposeMasterRefs: true,
          dropMorphsWithNameOnly: true,
          skipUnchangedFromDefault: true,
          skipUnchangedFromMaster: true,
          onlyIncludeStyleProps: true,
          skipAttributes: __varRecorder__$k.DEFAULT_SKIPPED_ATTRIBUTES,
          valueTransform: __varRecorder__$k.standardValueTransform
        }, opts)) || {
          __expr__: false
        },
            expr = _ref4.__expr__,
            bindings = _ref4.bindings;

        if (!expr) return;
        return {
          bindings: bindings,
          __expr__: "".concat(((_expr$match = expr.match(/^(morph|part)\(([^]*)\)/)) === null || _expr$match === void 0 ? void 0 : _expr$match[2]) || expr)
        };
      }, __moduleMeta__$9);

      __varRecorder__$k.convertToExpression = convertToExpression;

      var getTextAttributesExpr = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getTextAttributesExpr", "function", function (textMorph) {
        if (textMorph.textString === "") {
          return {
            __expr__: "['', null]",
            bindings: {}
          };
        }

        var expr = __varRecorder__$k.convertToExpression(textMorph);

        var rootPropNode = __varRecorder__$k.getPropertiesNode(parse$2("(" + expr.__expr__ + ")"));

        var _varRecorder__$getPr = __varRecorder__$k.getProp(rootPropNode, "textAndAttributes").value,
            start = _varRecorder__$getPr.start,
            end = _varRecorder__$getPr.end;

        if (expr.__expr__[end - 1] === ",") end--;
        expr.__expr__ = expr.__expr__.slice(start - 1, end);
        return expr;
      }, __moduleMeta__$9);

      __varRecorder__$k.getTextAttributesExpr = getTextAttributesExpr;

      var indentExpression = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("indentExpression", "function", function (expr, depth) {
        var braceLength = 1;
        var indentLength = depth * 2;
        return indent(System.lint("(".concat(expr, ")"))[0], "  ", depth).slice(indentLength + braceLength, -braceLength - indentLength - 2);
      }, __moduleMeta__$9);

      __varRecorder__$k.indentExpression = indentExpression;

      var getValueExpr = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getValueExpr", "function", function (prop, value) {
        var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var valueAsExpr;
        var bindings = {};
        if (value && value.isPoint) value = value.roundTo(0.1);
        if (isString$3(value) || isBoolean$1(value)) value = JSON.stringify(value);

        if (prop === "rotation") {
          value = "num.toRadians(".concat(toDegrees(value).toFixed(1), ")");
          bindings["lively.lang"] = ["num"];
        }

        if (prop === "blur") {
          value = "{ backdrop: ".concat(value.backdrop ? "true" : "false", ", value: ").concat(value.value, " }");
        }

        if (prop === "imageUrl" && $world.openedProject && value.includes($world.openedProject.name)) {
          value = value.replaceAll("\"", "");
          value = "projectAsset('".concat(value.split("/").pop(), "')");
          bindings["lively.project"] = ["projectAsset"];
        }

        if (prop === "master" && value) {
          valueAsExpr = value.getConfigAsExpression();
          if (valueAsExpr) valueAsExpr.__expr__ = __varRecorder__$k.indentExpression(valueAsExpr.__expr__, depth);
          return valueAsExpr;
        }

        if (prop === "layout" && value) {
          valueAsExpr = value.__serialize__();
          valueAsExpr.__expr__ = __varRecorder__$k.indentExpression(valueAsExpr.__expr__, depth);
          return valueAsExpr;
        }

        if (value && !value.isMorph && value.__serialize__) {
          return value.__serialize__();
        } else if (["borderColor", "borderWidth", "borderStyle", "borderRadius"].includes(prop)) {
          var nested = {};
          value = serializeNestedProp(prop, value, {
            exprSerializer: __varRecorder__$k.exprSerializer,
            nestedExpressions: nested,
            asExpression: true
          }, prop === "borderRadius" ? ["topLeft", "topRight", "bottomLeft", "bottomRight"] : ["top", "left", "right", "bottom"]);
          value = inspect$1(value, {}, depth);

          for (var uuid in nested) {
            var subExpr = nested[uuid];
            value = value.replace(JSON.stringify(uuid), subExpr.__expr__);
            Object.assign(bindings, subExpr.bindings);
          }
        }

        valueAsExpr = {
          __expr__: String(value),
          bindings: bindings
        };
        return valueAsExpr;
      }, __moduleMeta__$9);

      __varRecorder__$k.getValueExpr = getValueExpr;

      var getFoldableValueExpr = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getFoldableValueExpr", "function", function (prop, foldableValue, members, depth) {
        var withoutValueGetter = extract(foldableValue, members);

        if (new Set(values(withoutValueGetter)).size > 1) {
          return __varRecorder__$k.getValueExpr(prop, withoutValueGetter, depth);
        }

        return __varRecorder__$k.getValueExpr(prop, foldableValue.valueOf());
      }, __moduleMeta__$9);

      __varRecorder__$k.getFoldableValueExpr = getFoldableValueExpr;

      var getProp = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getProp", "function", function (propsNode, prop) {
        if (!propsNode) return null;

        if (propsNode.type === "CallExpression") {
          propsNode = propsNode.arguments[0];
        }

        var _query$queryNodes = queryNodes(propsNode, "\n  / Property [\n    /:key Identifier [ @name == '".concat(prop, "' ]\n   ]\n ")),
            _query$queryNodes2 = _slicedToArray(_query$queryNodes, 1),
            propNode = _query$queryNodes2[0];

        return propNode;
      }, __moduleMeta__$9);

      __varRecorder__$k.getProp = getProp;

      var getParentRef = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getParentRef", "function", function (parsedComponent) {
        var _query$queryNodes3 = queryNodes(parsedComponent, "\n   // CallExpression [\n         /:callee Identifier [ @name == 'component']\n      ]\n "),
            _query$queryNodes4 = _slicedToArray(_query$queryNodes3, 1),
            parentNode = _query$queryNodes4[0];

        if (parentNode.arguments.length > 1) return parentNode.arguments[0];
      }, __moduleMeta__$9);

      __varRecorder__$k.getParentRef = getParentRef;

      var getComponentNode = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getComponentNode", "function", function (parsedModuleContent, componentName) {
        var _query$queryNodes5 = queryNodes(parsedModuleContent, "\n  // VariableDeclarator [\n        /:id Identifier [ @name == '".concat(componentName, "' ]\n  ]")),
            _query$queryNodes6 = _slicedToArray(_query$queryNodes5, 1),
            parsedComponent = _query$queryNodes6[0];

        return parsedComponent;
      }, __moduleMeta__$9);

      __varRecorder__$k.getComponentNode = getComponentNode;

      var findComponentDef = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("findComponentDef", "function", function (parsedModuleContent, componentName) {
        return queryNodes(parsedModuleContent, "// VariableDeclaration [\n          @kind == \"const\"\n          && /:declarations '*' [\n            VariableDeclarator [\n              /:id Identifier [ @name == \"".concat(componentName, "\"]\n            ]\n         ]\n      ]"))[0];
      }, __moduleMeta__$9);

      __varRecorder__$k.findComponentDef = findComponentDef;

      var getPropertiesNode = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getPropertiesNode", "function", function (parsedComponent, aMorphOrName) {
        var name, aMorph;

        if (!aMorphOrName || aMorphOrName.isComponent) {
          return queryNodes(parsedComponent, "\n  .//  ObjectExpression\n  ")[0];
        }

        if (isString$3(aMorphOrName)) name = aMorphOrName;else {
          aMorph = aMorphOrName;
          name = aMorph.name;
        }
        var morphDefs = queryNodes(parsedComponent, "\n  .//  ObjectExpression [\n         /:properties \"*\" [\n           Property [\n              /:key Identifier [ @name == 'name' ]\n           && /:value Literal [ @value == '".concat(name, "']\n           ]\n         ]\n       ]\n  "));
        return morphDefs[0];
      }, __moduleMeta__$9);

      __varRecorder__$k.getPropertiesNode = getPropertiesNode;

      var getNodeFromSubmorphs = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getNodeFromSubmorphs", "function", function (submorphsNode, morphName) {
        var _query$queryNodes7 = queryNodes(submorphsNode, "\n    ./  CallExpression [\n         /:callee Identifier [ @name == 'part' || @name == 'add' ]\n      && /:arguments \"*\" [\n           CallExpression [\n             /:callee Identifier [ @name == 'part' ]\n          && /:arguments \"*\" [\n            ObjectExpression [\n               /:properties \"*\" [\n                   Property [\n                      /:key Identifier [ @name == 'name' ]\n                   && /:value Literal [ @value == '".concat(morphName, "']\n                   ]\n                 ]\n               ]\n             ]\n           ]\n           || ObjectExpression [\n               /:properties \"*\" [\n                 Property [\n                    /:key Identifier [ @name == 'name' ]\n                 && /:value Literal [ @value == '").concat(morphName, "']\n                 ]\n               ]\n             ]\n           ]\n         ]\n    ")),
            _query$queryNodes8 = _slicedToArray(_query$queryNodes7, 1),
            partOrAddRef = _query$queryNodes8[0];

        if (partOrAddRef) return partOrAddRef;

        var _query$queryNodes9 = queryNodes(submorphsNode, "\n    ./  CallExpression [\n         /:callee Identifier [ @name == 'replace' ]\n       && /:arguments \"*\" [ Literal [ @value == '".concat(morphName, "']]\n       ]\n    ")),
            _query$queryNodes10 = _slicedToArray(_query$queryNodes9, 1),
            replaceRef = _query$queryNodes10[0];

        if (replaceRef) return replaceRef;

        var _query$queryNodes11 = queryNodes(submorphsNode, "\n  ./  ObjectExpression [\n         /:properties \"*\" [\n           Property [\n              /:key Identifier [ @name == 'name' ]\n           && /:value Literal [ @value == '".concat(morphName, "']\n           ]\n         ]\n       ]\n  ")),
            _query$queryNodes12 = _slicedToArray(_query$queryNodes11, 1),
            propNode = _query$queryNodes12[0];

        return propNode;
      }, __moduleMeta__$9);

      __varRecorder__$k.getNodeFromSubmorphs = getNodeFromSubmorphs;

      var drillDownPath = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("drillDownPath", "function", function (startNode, path) {
        var _varRecorder__$getPr2;

        if (path.length === 0) return startNode;
        path = _toConsumableArray$1(path);
        var curr = startNode;
        if (curr.type !== "ArrayExpression") curr = (_varRecorder__$getPr2 = __varRecorder__$k.getProp(curr, "submorphs")) === null || _varRecorder__$getPr2 === void 0 ? void 0 : _varRecorder__$getPr2.value;

        while (path.length > 0 && curr) {
          var name = path.shift();
          curr = __varRecorder__$k.getNodeFromSubmorphs(curr, name);

          if (path.length > 0 && curr) {
            var _varRecorder__$getPr3;

            if (curr.type !== "ObjectExpression") {
              curr = __varRecorder__$k.getPropertiesNode(curr);
            }

            curr = (_varRecorder__$getPr3 = __varRecorder__$k.getProp(curr, "submorphs")) === null || _varRecorder__$getPr3 === void 0 ? void 0 : _varRecorder__$getPr3.value;
          } else break;
        }

        return curr;
      }, __moduleMeta__$9);

      __varRecorder__$k.drillDownPath = drillDownPath;

      var getMorphNode = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getMorphNode", "function", function (componentScope, aMorph) {
        var path = __varRecorder__$k.getPathFromMorphToMaster(aMorph).reverse();

        return __varRecorder__$k.drillDownPath(__varRecorder__$k.getPropertiesNode(componentScope), path);
      }, __moduleMeta__$9);

      __varRecorder__$k.getMorphNode = getMorphNode;

      var getWithoutCall = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getWithoutCall", "function", function (submorphsNode, aMorph) {
        var _query$queryNodes13 = queryNodes(submorphsNode, "\n    ./  CallExpression [\n         /:callee Identifier [ @name == 'without' ]\n      && /:arguments \"*\" [ Literal [ @value == '".concat(aMorph.name, "'] ]\n     ]\n    ")),
            _query$queryNodes14 = _slicedToArray(_query$queryNodes13, 1),
            withoutCall = _query$queryNodes14[0];

        return withoutCall;
      }, __moduleMeta__$9);

      __varRecorder__$k.getWithoutCall = getWithoutCall;

      var getAddCallReferencing = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getAddCallReferencing", "function", function (submorphsNode, aMorph) {
        var _query$queryNodes15 = queryNodes(submorphsNode, "\n    ./  CallExpression [\n         /:callee Identifier [ @name == 'add' ]\n      && /:arguments \"*\" [ Literal [ @value == '".concat(aMorph.name, "'] ]\n     ]\n    ")),
            _query$queryNodes16 = _slicedToArray(_query$queryNodes15, 1),
            addCall = _query$queryNodes16[0];

        return addCall;
      }, __moduleMeta__$9);

      __varRecorder__$k.getAddCallReferencing = getAddCallReferencing;

      var preserveFormatting = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("preserveFormatting", "function", function (sourceCode, nodeToRemove) {
        if (!nodeToRemove) return nodeToRemove;
        var commaRemoved = false;

        while (sourceCode[nodeToRemove.end].match(/\,/)) {
          commaRemoved = true;
          nodeToRemove.end++;
        }

        while (!sourceCode[nodeToRemove.start].match(/\,|\n/) && !sourceCode[nodeToRemove.start - 1].match(/\[/)) {
          var aboutToRemoveCommaTwice = commaRemoved && sourceCode[nodeToRemove.start - 1].match(/\,/);
          if (aboutToRemoveCommaTwice) break;
          nodeToRemove.start--;
        }

        return nodeToRemove;
      }, __moduleMeta__$9);

      __varRecorder__$k.preserveFormatting = preserveFormatting;

      var applySourceChanges = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("applySourceChanges", "function", function (sourceCode, changes) {
        var _iterator2 = _createForOfIteratorHelper(changes),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var change = _step2.value;

            if (change.action === "remove") {
              change = __varRecorder__$k.preserveFormatting(sourceCode, change);
            }

            sourceCode = applyChange(sourceCode, change);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return sourceCode;
      }, __moduleMeta__$9);

      __varRecorder__$k.applySourceChanges = applySourceChanges;

      var applyChangesToTextMorph = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("applyChangesToTextMorph", "function", function (aText, changes) {
        var _iterator3 = _createForOfIteratorHelper(changes),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var change = _step3.value;

            switch (change.action) {
              case "insert":
                aText.insertText(change.lines.join("\n"), aText.indexToPosition(change.start));
                break;

              case "remove":
                change = __varRecorder__$k.preserveFormatting(aText.textString, change);
                aText.replace({
                  start: aText.indexToPosition(change.start),
                  end: aText.indexToPosition(change.end)
                }, "");
                break;

              case "replace":
                aText.replace({
                  start: aText.indexToPosition(change.start),
                  end: aText.indexToPosition(change.end)
                }, change.lines.join("\n"));
                break;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return aText.textString;
      }, __moduleMeta__$9);

      __varRecorder__$k.applyChangesToTextMorph = applyChangesToTextMorph;

      var scanForNamesInGenerator = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("scanForNamesInGenerator", "function", function (closure) {
        return queryNodes(parse$2("(".concat(closure.toString(), ")")), "\n    //  Property [ /:key Identifier [ @name == 'name' ]]\n  ").map(function (hit) {
          var _hit$value;

          return (_hit$value = hit.value) === null || _hit$value === void 0 ? void 0 : _hit$value.value;
        });
      }, __moduleMeta__$9);

      __varRecorder__$k.scanForNamesInGenerator = scanForNamesInGenerator;

      var getAnonymousSpecs = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getAnonymousSpecs", "function", function (parsedComponent) {
        return queryNodes(parsedComponent, "\n    // ObjectExpression [\n       count(/ Property [\n        /:key Identifier [ @name == 'name' ]\n       ]) == 0\n     ]");
      }, __moduleMeta__$9);

      __varRecorder__$k.getAnonymousSpecs = getAnonymousSpecs;

      var getAnonymousAddedParts = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getAnonymousAddedParts", "function", function (parsedComponent) {
        return queryNodes(parsedComponent, "\n    //  CallExpression [\n         /:callee Identifier [ @name == 'add' ]\n      && /:arguments \"*\" [\n           CallExpression [\n             /:callee Identifier [ @name == 'part' ]\n          &&\n            count(/ ObjectExpression [\n               /:properties \"*\" [\n                   Property [\n                      /:key Identifier [ @name == 'name' ]\n                   ]\n                 ]\n               ]) == 0\n             \n           ]\n         ]\n       ]\n    ");
      }, __moduleMeta__$9);

      __varRecorder__$k.getAnonymousAddedParts = getAnonymousAddedParts;

      var getAnonymousParts = __varRecorder__$k["lively.ide/components/helpers.js__define__"]("getAnonymousParts", "function", function (parsedComponent) {
        return queryNodes(parsedComponent, "\n     // CallExpression [\n         /:callee Identifier [ @name == 'part' ]\n      && count(/ ObjectExpression [\n         /:properties \"*\" [\n             Property [\n                /:key Identifier [ @name == 'name' ]\n             ]\n           ]\n         ]) == 0\n       ]\n    ");
      }, __moduleMeta__$9);

      __varRecorder__$k.getAnonymousParts = getAnonymousParts;
      __varRecorder__$k.DEFAULT_SKIPPED_ATTRIBUTES = ["metadata", "styleClasses", "isComponent", "viewModel", "activeMark", "positionOnCanvas", "selectionMode", "acceptsDrops"];
      var DEFAULT_SKIPPED_ATTRIBUTES = __varRecorder__$k.DEFAULT_SKIPPED_ATTRIBUTES;
      __varRecorder__$k.DEFAULT_SKIPPED_ATTRIBUTES = DEFAULT_SKIPPED_ATTRIBUTES;
      __varRecorder__$k.COMPONENTS_CORE_MODULE = "lively.morphic/components/core.js";
      var COMPONENTS_CORE_MODULE = __varRecorder__$k.COMPONENTS_CORE_MODULE;
      __varRecorder__$k.COMPONENTS_CORE_MODULE = COMPONENTS_CORE_MODULE;
      __varRecorder__$k.exprSerializer = new ExpressionSerializer();
      __varRecorder__$k.getComponentDeclsFromScope = getComponentDeclsFromScope;
      __varRecorder__$k.getEligibleSourceEditorsFor = getEligibleSourceEditorsFor;
      __varRecorder__$k.getPathFromScopeMaster = getPathFromScopeMaster;
      __varRecorder__$k.getPathFromMorphToMaster = getPathFromMorphToMaster;
      __varRecorder__$k.standardValueTransform = standardValueTransform;
      __varRecorder__$k.convertToExpression = convertToExpression;
      __varRecorder__$k.getTextAttributesExpr = getTextAttributesExpr;
      __varRecorder__$k.getValueExpr = getValueExpr;
      __varRecorder__$k.getFoldableValueExpr = getFoldableValueExpr;
      __varRecorder__$k.getProp = getProp;
      __varRecorder__$k.getParentRef = getParentRef;
      __varRecorder__$k.getComponentNode = getComponentNode;
      __varRecorder__$k.findComponentDef = findComponentDef;
      __varRecorder__$k.getPropertiesNode = getPropertiesNode;
      __varRecorder__$k.drillDownPath = drillDownPath;
      __varRecorder__$k.getMorphNode = getMorphNode;
      __varRecorder__$k.getWithoutCall = getWithoutCall;
      __varRecorder__$k.getAddCallReferencing = getAddCallReferencing;
      __varRecorder__$k.preserveFormatting = preserveFormatting;
      __varRecorder__$k.applySourceChanges = applySourceChanges;
      __varRecorder__$k.applyChangesToTextMorph = applyChangesToTextMorph;
      __varRecorder__$k.scanForNamesInGenerator = scanForNamesInGenerator;
      __varRecorder__$k.getAnonymousSpecs = getAnonymousSpecs;
      __varRecorder__$k.getAnonymousAddedParts = getAnonymousAddedParts;
      __varRecorder__$k.getAnonymousParts = getAnonymousParts;
      __varRecorder__$k.getNodeFromSubmorphs = getNodeFromSubmorphs;

      var helpers = /*#__PURE__*/Object.freeze({
        __proto__: null,
        DEFAULT_SKIPPED_ATTRIBUTES: DEFAULT_SKIPPED_ATTRIBUTES,
        COMPONENTS_CORE_MODULE: COMPONENTS_CORE_MODULE,
        getComponentDeclsFromScope: getComponentDeclsFromScope,
        getEligibleSourceEditorsFor: getEligibleSourceEditorsFor,
        getPathFromScopeMaster: getPathFromScopeMaster,
        getPathFromMorphToMaster: getPathFromMorphToMaster,
        standardValueTransform: standardValueTransform,
        convertToExpression: convertToExpression,
        getTextAttributesExpr: getTextAttributesExpr,
        getValueExpr: getValueExpr,
        getFoldableValueExpr: getFoldableValueExpr,
        getProp: getProp,
        getParentRef: getParentRef,
        getComponentNode: getComponentNode,
        findComponentDef: findComponentDef,
        getPropertiesNode: getPropertiesNode,
        drillDownPath: drillDownPath,
        getMorphNode: getMorphNode,
        getWithoutCall: getWithoutCall,
        getAddCallReferencing: getAddCallReferencing,
        preserveFormatting: preserveFormatting,
        applySourceChanges: applySourceChanges,
        applyChangesToTextMorph: applyChangesToTextMorph,
        scanForNamesInGenerator: scanForNamesInGenerator,
        getAnonymousSpecs: getAnonymousSpecs,
        getAnonymousAddedParts: getAnonymousAddedParts,
        getAnonymousParts: getAnonymousParts,
        getNodeFromSubmorphs: getNodeFromSubmorphs
      });

      var __varRecorder__$j = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/service-worker.js", __contextModule__);
      var __moduleMeta__$8 = {
        pathInPackage: function pathInPackage() {
          return "./service-worker.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var startWorker = __varRecorder__$j["lively.ide/service-worker.js__define__"]("startWorker", "function", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var res, objectPackages, key;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                System.set("@lively-worker", System.newModule(__varRecorder__$j.initWorker()));

              case 1:
                _context.next = 3;
                return delay(1000);

              case 3:
                objectPackages = {};

                for (key in System._loader.modules) {
                  if (key.includes("local://") || key.includes("lively://")) {
                    objectPackages[key] = module$1(key)._source;
                  }
                }

                _context.next = 7;
                return __varRecorder__$j.callService("ensureModules", {
                  loadedModules: Object.keys(System._loader.modules).filter(function (url) {
                    return !url.includes("@");
                  }),
                  sources: objectPackages
                }, false);

              case 7:
                res = _context.sent;

              case 8:
                if (res.error) {
                  _context.next = 1;
                  break;
                }

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })), __moduleMeta__$8);

      __varRecorder__$j.startWorker = startWorker;

      var initWorker = __varRecorder__$j["lively.ide/service-worker.js__define__"]("initWorker", "function", function () {
        var w = create({
          workerId: "@lively-worker",
          scriptsToLoad: ["lively.next-node_modules/babel-standalone/babel.js", "lively.next-node_modules/systemjs/dist/system.src.js", "lively.modules/dist/lively.modules.js", "lively.ide/jsdom.worker.js"].map(function (url) {
            return System.baseURL + url;
          })
        });
        w.eval("(" + stringifyFunctionWithoutToplevelRecorder( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
          var _yield$import, resource, _yield$import2, module$1, registerPackage, coldImport, _coldImport;

          return regeneratorRuntime.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  _coldImport = function _coldImport3() {
                    _coldImport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(moduleId, source) {
                      var rec;
                      return regeneratorRuntime.wrap(function _callee8$(_context8) {
                        while (1) {
                          switch (_context8.prev = _context8.next) {
                            case 0:
                              rec = resource(moduleId);
                              _context8.next = 3;
                              return rec.exists();

                            case 3:
                              _context8.t0 = !_context8.sent;

                              if (!_context8.t0) {
                                _context8.next = 6;
                                break;
                              }

                              _context8.t0 = rec.localBackend;

                            case 6:
                              if (!_context8.t0) {
                                _context8.next = 20;
                                break;
                              }

                              if (source) {
                                _context8.next = 14;
                                break;
                              }

                              _context8.next = 10;
                              return System._livelyModulesTranslationCache.fetchStoredModuleSource(moduleId);

                            case 10:
                              _context8.t1 = _context8.sent;

                              if (_context8.t1) {
                                _context8.next = 13;
                                break;
                              }

                              _context8.t1 = {};

                            case 13:
                              source = _context8.t1.source;

                            case 14:
                              if (!source) {
                                _context8.next = 19;
                                break;
                              }

                              _context8.next = 17;
                              return rec.write(source);

                            case 17:
                              _context8.next = 20;
                              break;

                            case 19:
                              console.log("No source available for ", moduleId);

                            case 20:
                              _context8.prev = 20;

                              if (moduleId.includes("/package.json")) {
                                registerPackage(moduleId.replace("/package.json", ""));
                              }

                              _context8.next = 24;
                              return module$1(moduleId).source();

                            case 24:
                              _context8.next = 28;
                              break;

                            case 26:
                              _context8.prev = 26;
                              _context8.t2 = _context8["catch"](20);

                            case 28:
                            case "end":
                              return _context8.stop();
                          }
                        }
                      }, _callee8, null, [[20, 26]]);
                    }));
                    return _coldImport.apply(this, arguments);
                  };

                  coldImport = function _coldImport2(_x, _x2) {
                    return _coldImport.apply(this, arguments);
                  };

                  _context9.next = 4;
                  return lively.lang.promise.waitFor(5000, function () {
                    return self.initialized;
                  });

                case 4:
                  _context9.next = 6;
                  return Promise.resolve().then(function () { return index$2; });

                case 6:
                  _context9.next = 8;
                  return Promise.resolve().then(function () { return serviceWorker; });

                case 8:
                  _context9.next = 10;
                  return module.import('./__rootModule___commonjs-entry-039abf1b.js').then(function (n) { return n.gM; });

                case 10:
                  _yield$import = _context9.sent;
                  resource = _yield$import.resource;
                  _context9.next = 14;
                  return module.import('./index-d97f22af.js').then(function (n) { return n.m; });

                case 14:
                  _yield$import2 = _context9.sent;
                  module$1 = _yield$import2.module;
                  registerPackage = _yield$import2.registerPackage;
                  self.messenger.addServices({
                    ensureModules: function () {
                      var _ensureModules = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(msg, messenger) {
                        var _msg$data, loadedModules, _msg$data$sources, sources, _iterator, _step, moduleId;

                        return regeneratorRuntime.wrap(function _callee2$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                _msg$data = msg.data, loadedModules = _msg$data.loadedModules, _msg$data$sources = _msg$data.sources, sources = _msg$data$sources === void 0 ? {} : _msg$data$sources;
                                _iterator = _createForOfIteratorHelper(loadedModules);
                                _context2.prev = 2;

                                _iterator.s();

                              case 4:
                                if ((_step = _iterator.n()).done) {
                                  _context2.next = 11;
                                  break;
                                }

                                moduleId = _step.value;

                                if (System._loader.modules[moduleId]) {
                                  _context2.next = 9;
                                  break;
                                }

                                _context2.next = 9;
                                return coldImport(moduleId, sources[moduleId]);

                              case 9:
                                _context2.next = 4;
                                break;

                              case 11:
                                _context2.next = 16;
                                break;

                              case 13:
                                _context2.prev = 13;
                                _context2.t0 = _context2["catch"](2);

                                _iterator.e(_context2.t0);

                              case 16:
                                _context2.prev = 16;

                                _iterator.f();

                                return _context2.finish(16);

                              case 19:
                                messenger.answer(msg, true);

                              case 20:
                              case "end":
                                return _context2.stop();
                            }
                          }
                        }, _callee2, null, [[2, 13, 16, 19]]);
                      }));

                      function ensureModules(_x3, _x4) {
                        return _ensureModules.apply(this, arguments);
                      }

                      return ensureModules;
                    }(),
                    updateModule: function () {
                      var _updateModule = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(msg, messenger) {
                        var _yield$import3, module$1, _msg$data2, moduleId, newSource;

                        return regeneratorRuntime.wrap(function _callee3$(_context3) {
                          while (1) {
                            switch (_context3.prev = _context3.next) {
                              case 0:
                                _context3.next = 2;
                                return module.import('./index-d97f22af.js').then(function (n) { return n.m; });

                              case 2:
                                _yield$import3 = _context3.sent;
                                module$1 = _yield$import3.module;
                                _msg$data2 = msg.data, moduleId = _msg$data2.module, newSource = _msg$data2.newSource;

                                if (System._loader.modules[moduleId]) {
                                  _context3.next = 11;
                                  break;
                                }

                                _context3.next = 8;
                                return coldImport(moduleId, newSource);

                              case 8:
                                messenger.answer(msg, true);
                                _context3.next = 14;
                                break;

                              case 11:
                                _context3.next = 13;
                                return module$1(moduleId).changeSource(newSource);

                              case 13:
                                messenger.answer(msg, true);

                              case 14:
                              case "end":
                                return _context3.stop();
                            }
                          }
                        }, _callee3);
                      }));

                      function updateModule(_x5, _x6) {
                        return _updateModule.apply(this, arguments);
                      }

                      return updateModule;
                    }(),
                    loadModule: function () {
                      var _loadModule = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(msg, messenger) {
                        var _msg$data3, moduleId, source;

                        return regeneratorRuntime.wrap(function _callee4$(_context4) {
                          while (1) {
                            switch (_context4.prev = _context4.next) {
                              case 0:
                                _msg$data3 = msg.data, moduleId = _msg$data3.module, source = _msg$data3.source;

                                if (System._loader.modules[moduleId]) {
                                  _context4.next = 4;
                                  break;
                                }

                                _context4.next = 4;
                                return coldImport(moduleId, source);

                              case 4:
                                messenger.answer(msg, true);

                              case 5:
                              case "end":
                                return _context4.stop();
                            }
                          }
                        }, _callee4);
                      }));

                      function loadModule(_x7, _x8) {
                        return _loadModule.apply(this, arguments);
                      }

                      return loadModule;
                    }(),
                    freezeSnapshot: function () {
                      var _freezeSnapshot = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(msg, messenger) {
                        return regeneratorRuntime.wrap(function _callee5$(_context5) {
                          while (1) {
                            switch (_context5.prev = _context5.next) {
                              case 0:
                              case "end":
                                return _context5.stop();
                            }
                          }
                        }, _callee5);
                      }));

                      function freezeSnapshot(_x9, _x10) {
                        return _freezeSnapshot.apply(this, arguments);
                      }

                      return freezeSnapshot;
                    }(),
                    exportsOfModules: function () {
                      var _exportsOfModules = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(msg, messenger) {
                        var _yield$import4, localInterface, _yield$import5, deserialize, _deserialize, _deserialize$livelySy, livelySystem, _deserialize$excluded, excludedPackages, progress;

                        return regeneratorRuntime.wrap(function _callee6$(_context6) {
                          while (1) {
                            switch (_context6.prev = _context6.next) {
                              case 0:
                                _context6.next = 2;
                                return Promise.resolve().then(function () { return index$2; });

                              case 2:
                                _yield$import4 = _context6.sent;
                                localInterface = _yield$import4.localInterface;
                                _context6.next = 6;
                                return module.import('./__rootModule___commonjs-entry-039abf1b.js').then(function (n) { return n.gL; });

                              case 6:
                                _yield$import5 = _context6.sent;
                                deserialize = _yield$import5.deserialize;
                                _deserialize = deserialize(msg.data), _deserialize$livelySy = _deserialize.livelySystem, livelySystem = _deserialize$livelySy === void 0 ? localInterface : _deserialize$livelySy, _deserialize$excluded = _deserialize.excludedPackages, excludedPackages = _deserialize$excluded === void 0 ? [] : _deserialize$excluded, progress = _deserialize.progress;
                                _context6.next = 11;
                                return lively.lang.promise.waitFor(5000, function () {
                                  return !self.loadingModules;
                                });

                              case 11:
                                _context6.t0 = messenger;
                                _context6.t1 = msg;
                                _context6.next = 15;
                                return livelySystem.exportsOfModules({
                                  excludedPackages: excludedPackages,
                                  progress: progress && progress.asWorkerEndpoint(msg)
                                });

                              case 15:
                                _context6.t2 = _context6.sent;

                                _context6.t0.answer.call(_context6.t0, _context6.t1, _context6.t2);

                              case 17:
                              case "end":
                                return _context6.stop();
                            }
                          }
                        }, _callee6);
                      }));

                      function exportsOfModules(_x11, _x12) {
                        return _exportsOfModules.apply(this, arguments);
                      }

                      return exportsOfModules;
                    }(),
                    doSearch: function () {
                      var _doSearch = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(msg, messenger) {
                        var _yield$import6, deserialize, _yield$import7, doSearch, _deserialize2, excludedModules, excludedPackages, livelySystem, searchTerm, includeUnloaded, caseSensitive, progress, res;

                        return regeneratorRuntime.wrap(function _callee7$(_context7) {
                          while (1) {
                            switch (_context7.prev = _context7.next) {
                              case 0:
                                _context7.next = 2;
                                return module.import('./__rootModule___commonjs-entry-039abf1b.js').then(function (n) { return n.gL; });

                              case 2:
                                _yield$import6 = _context7.sent;
                                deserialize = _yield$import6.deserialize;
                                _context7.next = 6;
                                return module.import('./code-search.cp-3e624062.js');

                              case 6:
                                _yield$import7 = _context7.sent;
                                doSearch = _yield$import7.doSearch;
                                _deserialize2 = deserialize(msg.data), excludedModules = _deserialize2.excludedModules, excludedPackages = _deserialize2.excludedPackages, livelySystem = _deserialize2.livelySystem, searchTerm = _deserialize2.searchTerm, includeUnloaded = _deserialize2.includeUnloaded, caseSensitive = _deserialize2.caseSensitive, progress = _deserialize2.progress;
                                _context7.next = 11;
                                return doSearch(livelySystem, searchTerm, excludedModules, excludedPackages, includeUnloaded, caseSensitive, progress && progress.asWorkerEndpoint(msg));

                              case 11:
                                res = _context7.sent;
                                messenger.answer(msg, res);

                              case 13:
                              case "end":
                                return _context7.stop();
                            }
                          }
                        }, _callee7);
                      }));

                      function doSearch(_x13, _x14) {
                        return _doSearch.apply(this, arguments);
                      }

                      return doSearch;
                    }()
                  });

                case 18:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9);
        }))) + ")()", function () {});
        subscribe("lively.modules/moduleloaded", /*#__PURE__*/function () {
          var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(evt) {
            return regeneratorRuntime.wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    _context10.t0 = __varRecorder__$j;
                    _context10.t1 = evt.module;
                    _context10.next = 4;
                    return module$1(evt.module).source();

                  case 4:
                    _context10.t2 = _context10.sent;
                    _context10.t3 = {
                      module: _context10.t1,
                      source: _context10.t2
                    };

                    _context10.t0.callService.call(_context10.t0, "loadModule", _context10.t3, false);

                  case 7:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10);
          }));

          return function (_x15) {
            return _ref3.apply(this, arguments);
          };
        }());
        subscribe("lively.modules/modulechanged", function (evt) {
          return __varRecorder__$j.callService("updateModule", evt, false);
        });
        return w;
      }, __moduleMeta__$8);

      __varRecorder__$j.initWorker = initWorker;

      var callService = exports('Z', __varRecorder__$j["lively.ide/service-worker.js__define__"]("callService", "function", /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(service, args) {
          var objectsInArguments,
              preparedArgs,
              progressMonitor,
              _args11 = arguments;
          return regeneratorRuntime.wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  objectsInArguments = _args11.length > 2 && _args11[2] !== undefined ? _args11[2] : true;
                  preparedArgs = objectsInArguments ? __varRecorder__$j.prepareArguments(args) : args;
                  progressMonitor = __varRecorder__$j.detectProgressMonitor(args);
                  return _context11.abrupt("return", new Promise(function (resolve, reject) {
                    return System.get("@lively-worker").sendTo("@lively-worker", service, preparedArgs, function (err, answer) {
                      if (progressMonitor && answer.expectMoreResponses) {
                        progressMonitor.step(answer.data.stepName, answer.data.progress);
                      } else {
                        resolve(answer.data);
                      }
                    });
                  }));

                case 4:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11);
        }));

        return function (_x16, _x17) {
          return _ref4.apply(this, arguments);
        };
      }(), __moduleMeta__$8));

      __varRecorder__$j.callService = callService;

      var detectProgressMonitor = __varRecorder__$j["lively.ide/service-worker.js__define__"]("detectProgressMonitor", "function", function (args) {
        if (args && args.isProgressMonitor) return args;
        if (isObject$2(args)) return values(args).find(function (arg) {
          return arg && arg.isProgressMonitor;
        });
      }, __moduleMeta__$8);

      __varRecorder__$j.detectProgressMonitor = detectProgressMonitor;

      var prepareArguments = __varRecorder__$j["lively.ide/service-worker.js__define__"]("prepareArguments", "function", function (args) {
        return serialize$1(args, {
          plugins: [{
            serializeObject: function serializeObject(realObj, isProperty, pool, serializedObjMap, path) {
              if (isRegExp$2(realObj)) {
                return pool.expressionSerializer.exprStringEncode({
                  __expr__: String(realObj)
                });
              }

              if (isFunction$2(realObj)) {
                return pool.expressionSerializer.exprStringEncode({
                  __expr__: String(realObj).replace("function ", "function " + "_lambda_")
                });
              }
            }
          }].concat(_toConsumableArray$1(allPlugins))
        });
      }, __moduleMeta__$8);

      __varRecorder__$j.prepareArguments = prepareArguments;
      !System.get("@system-env").worker && config$2.ide.workerEnabled && !System.get("@lively-worker") && __varRecorder__$j.startWorker();
      __varRecorder__$j.callService = callService;
      var ProgressMonitor = exports('_', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/service-worker.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ProgressMonitor") && typeof __lively_classholder__.ProgressMonitor === "function" ? __lively_classholder__.ProgressMonitor : __lively_classholder__.ProgressMonitor = function ProgressMonitor(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function ProgressMonitor_initialize_() {
            var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                _ref5$id = _ref5.id,
                id = _ref5$id === void 0 ? newUUID() : _ref5$id,
                _ref5$handlers = _ref5.handlers,
                handlers = _ref5$handlers === void 0 ? {} : _ref5$handlers;

            this.id = id;
            this.handlers = handlers;
          }
        }, {
          key: "isProgressMonitor",
          get: function get() {
            return true;
          }
        }, {
          key: "step",
          value: function ProgressMonitor_step_(stepName, progress) {
            for (var handlerName in this.handlers) {
              this.handlers[handlerName](stepName, progress);
            }
          }
        }, {
          key: "disconnectFromWorker",
          value: function ProgressMonitor_disconnectFromWorker_() {
            System.get("@lively-worker").removeAllListeners(this.id);
          }
        }, {
          key: "asWorkerEndpoint",
          value: function ProgressMonitor_asWorkerEndpoint_(msg) {
            var pm = new __varRecorder__$j.WorkerProgressMonitor({
              id: this.id
            });
            pm.workerMessageObj = msg;
            return pm;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ProgressMonitor";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./service-worker.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 6515,
          end: 7127
        });
      }(undefined));
      __varRecorder__$j.ProgressMonitor = ProgressMonitor;
      __varRecorder__$j.ProgressMonitor = ProgressMonitor;
      var WorkerProgressMonitor = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/service-worker.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("WorkerProgressMonitor") && typeof __lively_classholder__.WorkerProgressMonitor === "function" ? __lively_classholder__.WorkerProgressMonitor : __lively_classholder__.WorkerProgressMonitor = function WorkerProgressMonitor(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "isWorkerEndpoint",
          get: function get() {
            return true;
          }
        }, {
          key: "step",
          value: function WorkerProgressMonitor_step_(stepName, progress) {
            self.messenger.answer(this.workerMessageObj, {
              stepName: stepName,
              progress: progress
            }, true);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "WorkerProgressMonitor";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./service-worker.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 7195,
          end: 7408
        });
      }(__varRecorder__$j.ProgressMonitor);
      __varRecorder__$j.WorkerProgressMonitor = WorkerProgressMonitor;
      __varRecorder__$j.WorkerProgressMonitor = WorkerProgressMonitor;

      var serviceWorker = /*#__PURE__*/Object.freeze({
        __proto__: null,
        callService: callService,
        ProgressMonitor: ProgressMonitor,
        WorkerProgressMonitor: WorkerProgressMonitor
      });

      var __varRecorder__$i = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/import-helper.js", __contextModule__);
      var __moduleMeta__$7 = {
        pathInPackage: function pathInPackage() {
          return "./js/import-helper.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var declareVarNamesAsGlobals = __varRecorder__$i["lively.ide/js/import-helper.js__define__"]("declareVarNamesAsGlobals", "function", function (textMorph, varNames, opts) {
        var _ref = opts || {},
            _ref$recordUndo = _ref.recordUndo,
            recordUndo = _ref$recordUndo === void 0 ? true : _ref$recordUndo;

        var src = textMorph.textString;
        var parsed = textMorph.editorPlugin.parse();

        var _GlobalInjector$run = GlobalInjector.run(src, varNames, parsed),
            status = _GlobalInjector$run.status,
            generated = _GlobalInjector$run.generated,
            from = _GlobalInjector$run.from;
            _GlobalInjector$run.to;

        var pos = textMorph.indexToPosition(from);
        var range;
        if (status === "not modified") return null;
        if (recordUndo) textMorph.undoManager.group();
        range = textMorph.insertText(generated, pos);
        if (recordUndo) textMorph.undoManager.group();
        return range;
      }, __moduleMeta__$7);

      __varRecorder__$i.declareVarNamesAsGlobals = declareVarNamesAsGlobals;

      var injectImportsIntoText = __varRecorder__$i["lively.ide/js/import-helper.js__define__"]("injectImportsIntoText", "function", /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(textMorph, imports, opts) {
          var _Object$assign, gotoImport, insertImportAtCursor, recordUndo, S, undeclared, jsPlugin, moduleId, intoPackage, to, pos, importedVarNames, ranges, choice, source, _ImportInjector$run, status, generated, _from, standaloneImport, importedVarName, _source, _pos;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _Object$assign = Object.assign({
                    gotoImport: true,
                    insertImportAtCursor: false,
                    recordUndo: true,
                    System: System
                  }, opts), gotoImport = _Object$assign.gotoImport, insertImportAtCursor = _Object$assign.insertImportAtCursor, recordUndo = _Object$assign.recordUndo, S = _Object$assign.System, undeclared = _Object$assign.undeclared;
                  jsPlugin = textMorph.pluginFind(function (p) {
                    return p.isJSEditorPlugin;
                  });

                  if (jsPlugin) {
                    _context.next = 4;
                    break;
                  }

                  throw new Error("cannot find js plugin of ".concat(textMorph));

                case 4:
                  moduleId = jsPlugin.evalEnvironment.targetModule;
                  _context.next = 7;
                  return jsPlugin.systemInterface().getPackageForModule(moduleId);

                case 7:
                  intoPackage = _context.sent;
                  importedVarNames = [];
                  ranges = [];

                  if (gotoImport) {
                    textMorph.saveMark();
                  }

                  if (recordUndo) textMorph.undoManager.group();
                  imports = imports.slice();

                case 13:
                  if (!imports.length) {
                    _context.next = 32;
                    break;
                  }

                  choice = imports.shift();
                  source = textMorph.textString;
                  _ImportInjector$run = ImportInjector.run(S, moduleId, intoPackage, source, choice), status = _ImportInjector$run.status, generated = _ImportInjector$run.generated, _from = _ImportInjector$run.from, standaloneImport = _ImportInjector$run.standaloneImport, importedVarName = _ImportInjector$run.importedVarName;

                  if (status === "not modified" && importedVarName) {
                    textMorph.replace({
                      start: textMorph.indexToPosition(undeclared.start),
                      end: textMorph.indexToPosition(undeclared.end)
                    }, importedVarName);
                  }

                  pos = textMorph.indexToPosition(_from);
                  if (generated) ranges.push(textMorph.insertText(generated, pos));
                  if (importedVarName) importedVarNames.push(importedVarName);

                  if (!standaloneImport) {
                    _context.next = 30;
                    break;
                  }

                  _context.prev = 22;
                  _context.next = 25;
                  return jsPlugin.runEval(standaloneImport);

                case 25:
                  _context.next = 30;
                  break;

                case 27:
                  _context.prev = 27;
                  _context.t0 = _context["catch"](22);
                  console.error("Error when trying to import ".concat(standaloneImport, ": ").concat(_context.t0.stack));

                case 30:
                  _context.next = 13;
                  break;

                case 32:
                  if (insertImportAtCursor) {
                    _source = importedVarNames.join("\n");
                    _pos = textMorph.cursorPosition;
                    textMorph.getLine(_pos.row).slice(0, _pos.col);
                    textMorph.selection.text = _source;

                    if (!gotoImport) {
                      textMorph.scrollCursorIntoView();
                      textMorph.focus();
                    }
                  }

                  if (recordUndo) textMorph.undoManager.group();

                  if (gotoImport) {
                    textMorph.selection = ranges.length ? last$2(ranges) : {
                      start: pos,
                      end: textMorph.indexToPosition(to)
                    };
                    textMorph.scrollCursorIntoView();
                    textMorph.focus();
                  }

                  return _context.abrupt("return", {
                    ranges: ranges
                  });

                case 36:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[22, 27]]);
        }));

        return function (_x, _x2, _x3) {
          return _ref2.apply(this, arguments);
        };
      }(), __moduleMeta__$7);

      __varRecorder__$i.injectImportsIntoText = injectImportsIntoText;

      var interactivelyInjectImportIntoText = __varRecorder__$i["lively.ide/js/import-helper.js__define__"]("interactivelyInjectImportIntoText", "function", /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(textMorph, opts) {
          var jsPlugin, choices;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  jsPlugin = textMorph.pluginFind(function (p) {
                    return p.isJSEditorPlugin;
                  });

                  if (jsPlugin) {
                    _context2.next = 3;
                    break;
                  }

                  throw new Error("cannot find js plugin of ".concat(textMorph));

                case 3:
                  _context2.t0 = __varRecorder__$i;
                  _context2.next = 6;
                  return jsPlugin.systemInterface();

                case 6:
                  _context2.t1 = _context2.sent;
                  _context2.t2 = {
                    world: textMorph.world(),
                    progress: opts.progress,
                    requester: opts.requester
                  };
                  _context2.next = 10;
                  return _context2.t0.interactivelyChooseImports.call(_context2.t0, _context2.t1, _context2.t2);

                case 10:
                  choices = _context2.sent;
                  return _context2.abrupt("return", choices ? __varRecorder__$i.injectImportsIntoText(textMorph, choices, opts) : null);

                case 12:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function (_x4, _x5) {
          return _ref3.apply(this, arguments);
        };
      }(), __moduleMeta__$7);

      __varRecorder__$i.interactivelyInjectImportIntoText = interactivelyInjectImportIntoText;

      var interactivelyChooseImports = exports('a9', __varRecorder__$i["lively.ide/js/import-helper.js__define__"]("interactivelyChooseImports", "function", /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(livelySystem, opts) {
          var exports$1, choices;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  opts = Object.assign({
                    System: System,
                    world: $world
                  }, opts);
                  _context3.next = 3;
                  return runFn(function (li) {
                    var progress = new ProgressMonitor({
                      handlers: {
                        searchProgress: function searchProgress(stepName, progress) {
                          li.progress = progress;
                          li.label = stepName;
                        }
                      }
                    });
                    return config$2.ide.workerEnabled ? callService("exportsOfModules", {
                      excludedPackages: config$2.ide.js.ignoredPackages,
                      livelySystem: livelySystem,
                      progress: new ProgressMonitor({
                        handlers: {
                          workerProgress: function workerProgress(stepName, progress) {
                            li.progress = progress;
                            li.label = stepName;
                          }
                        }
                      })
                    }) : livelySystem.exportsOfModules({
                      excludedPackages: config$2.ide.js.ignoredPackages,
                      progress: progress
                    });
                  }, "computing imports...");

                case 3:
                  exports$1 = _context3.sent;
                  _context3.next = 6;
                  return __varRecorder__$i.ExportPrompt.run(opts.world, exports$1, opts.requester);

                case 6:
                  choices = _context3.sent;
                  return _context3.abrupt("return", !choices.length ? null : choices);

                case 8:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function (_x6, _x7) {
          return _ref4.apply(this, arguments);
        };
      }(), __moduleMeta__$7));

      __varRecorder__$i.interactivelyChooseImports = interactivelyChooseImports;

      var labelForExport = __varRecorder__$i["lively.ide/js/import-helper.js__define__"]("labelForExport", "function", function (exportSpec) {
        var type = exportSpec.type,
            exported = exportSpec.exported,
            local = exportSpec.local,
            fromModule = exportSpec.fromModule,
            pathInPackage = exportSpec.pathInPackage,
            packageName = exportSpec.packageName,
            packageVersion = exportSpec.packageVersion;
        var exportName = exported === "default" ? "".concat(local, " (default)") : exported;
        if (fromModule) var reexportString = " rexported from ".concat(fromModule);
        var annotationString = " [".concat(packageName, "/").concat(pathInPackage);
        if (packageVersion) annotationString += " ".concat(packageVersion);
        annotationString += "]";
        return [exportName, {}, "".concat(type, " ").concat(reexportString || "", " ").concat(annotationString), {
          paddingLeft: "5px",
          fontSize: "70%",
          textStyleClasses: ["truncated-text", "annotation"]
        }];
      }, __moduleMeta__$7);

      __varRecorder__$i.labelForExport = labelForExport;

      var ensureFullModuleIdOfFromModule = __varRecorder__$i["lively.ide/js/import-helper.js__define__"]("ensureFullModuleIdOfFromModule", "function", function (exported) {
        var fromModule = exported.fromModule,
            packageURL = exported.packageURL;
        if (!fromModule) return null;
        if (!fromModule.startsWith(".")) return fromModule;
        var baseURL = packageURL || System.baseURL;
        return joinPath(baseURL, fromModule);
      }, __moduleMeta__$7);

      __varRecorder__$i.ensureFullModuleIdOfFromModule = ensureFullModuleIdOfFromModule;

      var matchingExportsForUndeclared = __varRecorder__$i["lively.ide/js/import-helper.js__define__"]("matchingExportsForUndeclared", "function", function (undeclaredVar, allExports) {
        var preferReExported = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var matching = allExports.filter(function (ea) {
          var isDefault = ea.exported === "default";
          var name = isDefault ? ea.local : ea.exported;
          return name === undeclaredVar.name;
        });
        var reExported = matching.filter(function (export1) {
          if (export1.fromModule) return true;
          return !matching.some(function (export2) {
            if (export1 === export2 || !export2.fromModule) return false;

            var fullFrom = __varRecorder__$i.ensureFullModuleIdOfFromModule(export2);

            return fullFrom === export1.moduleId;
          });
        });
        return preferReExported ? reExported : withoutAll(matching, reExported);
      }, __moduleMeta__$7);

      __varRecorder__$i.matchingExportsForUndeclared = matchingExportsForUndeclared;

      var undeclaredVariables = __varRecorder__$i["lively.ide/js/import-helper.js__define__"]("undeclaredVariables", "function", function (source, knownGlobals) {
        knownGlobals = knownGlobals || [];
        var parsed = fuzzyParse(source, {
          withComments: true
        });
        return findGlobalVarRefs(parsed, {
          jslintGlobalComment: true
        }).filter(function (ea) {
          return !knownGlobals.includes(ea.name);
        });
      }, __moduleMeta__$7);

      __varRecorder__$i.undeclaredVariables = undeclaredVariables;

      var interactivlyFixUndeclaredVariables = exports('a8', __varRecorder__$i["lively.ide/js/import-helper.js__define__"]("interactivlyFixUndeclaredVariables", "function", /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(textMorph, opts) {
          var _ref6, sourceUpdater, sourceRetriever, highlightUndeclared, requester, _ref6$keepTextPositio, keepTextPosition, _ref6$ignore, ignore, _ref6$autoApplyIfSing, autoApplyIfSingleChoice, _ref6$knownGlobals, knownGlobals, allUndeclared, changes, jsPlugin, livelySystem, exports, scroll, cursorPosition, anchor, canceled, undeclared, name, imports, choices, choice, _varRecorder__$__int, _varRecorder__$__int2, updateUndeclared, _updateUndeclared;

          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _updateUndeclared = function _updateUndeclared3() {
                    _updateUndeclared = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                      return regeneratorRuntime.wrap(function _callee4$(_context4) {
                        while (1) {
                          switch (_context4.prev = _context4.next) {
                            case 0:
                              _context4.t0 = __varRecorder__$i;
                              _context4.next = 3;
                              return sourceRetriever();

                            case 3:
                              _context4.t1 = _context4.sent;
                              _context4.t2 = knownGlobals;

                              _context4.t3 = function (ea) {
                                return !ignore.includes(ea.name);
                              };

                              return _context4.abrupt("return", allUndeclared = _context4.t0.undeclaredVariables.call(_context4.t0, _context4.t1, _context4.t2).filter(_context4.t3));

                            case 7:
                            case "end":
                              return _context4.stop();
                          }
                        }
                      }, _callee4);
                    }));
                    return _updateUndeclared.apply(this, arguments);
                  };

                  updateUndeclared = function _updateUndeclared2() {
                    return _updateUndeclared.apply(this, arguments);
                  };

                  _ref6 = opts || {}, sourceUpdater = _ref6.sourceUpdater, sourceRetriever = _ref6.sourceRetriever, highlightUndeclared = _ref6.highlightUndeclared, requester = _ref6.requester, _ref6$keepTextPositio = _ref6.keepTextPosition, keepTextPosition = _ref6$keepTextPositio === void 0 ? true : _ref6$keepTextPositio, _ref6$ignore = _ref6.ignore, ignore = _ref6$ignore === void 0 ? [] : _ref6$ignore, _ref6$autoApplyIfSing = _ref6.autoApplyIfSingleChoice, autoApplyIfSingleChoice = _ref6$autoApplyIfSing === void 0 ? false : _ref6$autoApplyIfSing, _ref6$knownGlobals = _ref6.knownGlobals, knownGlobals = _ref6$knownGlobals === void 0 ? textMorph.evalEnvironment.knownGlobals || [] : _ref6$knownGlobals;

                  if (typeof sourceRetriever !== "function") {
                    sourceRetriever = function sourceRetriever() {
                      return textMorph.textString;
                    };
                  }

                  if (typeof highlightUndeclared !== "function") {
                    highlightUndeclared = function highlightUndeclared(undeclared) {
                      var start = undeclared.start,
                          end = undeclared.end;
                      var range = {
                        start: textMorph.indexToPosition(start),
                        end: textMorph.indexToPosition(end)
                      };
                      textMorph.selection = range;
                      textMorph.centerRange(range);
                    };
                  }

                  changes = [];
                  _context5.next = 8;
                  return updateUndeclared();

                case 8:
                  if (allUndeclared.length) {
                    _context5.next = 10;
                    break;
                  }

                  return _context5.abrupt("return", changes);

                case 10:
                  ignore = ignore.slice();
                  jsPlugin = textMorph.pluginFind(function (p) {
                    return p.isJSEditorPlugin;
                  });

                  if (jsPlugin) {
                    _context5.next = 14;
                    break;
                  }

                  throw new Error("cannot find js plugin of ".concat(textMorph));

                case 14:
                  _context5.next = 16;
                  return jsPlugin.systemInterface();

                case 16:
                  livelySystem = _context5.sent;
                  _context5.next = 19;
                  return livelySystem.exportsOfModules({
                    excludedPackages: config$2.ide.js.ignoredPackages
                  });

                case 19:
                  exports = _context5.sent;
                  textMorph.collapseSelection();

                  if (keepTextPosition) {
                    scroll = textMorph.scroll, cursorPosition = textMorph.cursorPosition;
                    anchor = textMorph.addAnchor(Object.assign({}, cursorPosition, {
                      id: "fix-undeclared-vars"
                    }));
                  }

                  canceled = false;

                case 23:

                  _context5.next = 26;
                  return updateUndeclared();

                case 26:
                  if (allUndeclared.length) {
                    _context5.next = 28;
                    break;
                  }

                  return _context5.abrupt("break", 70);

                case 28:
                  undeclared = allUndeclared[0];
                  name = undeclared.name;
                  imports = __varRecorder__$i.matchingExportsForUndeclared(undeclared, exports);
                  choices = ["ignore for now", "declare as global"].concat(imports.map(function (ea) {
                    return {
                      isListItem: true,
                      value: ea,
                      label: __varRecorder__$i.labelForExport(ea)
                    };
                  }));
                  choice = void 0;
                  _context5.next = 35;
                  return highlightUndeclared(undeclared);

                case 35:
                  if (!(autoApplyIfSingleChoice && imports.length === 1)) {
                    _context5.next = 39;
                    break;
                  }

                  choice = imports[0];
                  _context5.next = 47;
                  break;

                case 39:
                  _context5.next = 41;
                  return $world.filterableListPrompt("Found undeclared variable ".concat(name, ".  How should it be handled?"), choices, {
                    requester: requester,
                    theme: "dark",
                    preselect: choices.length > 2 ? 2 : 0
                  });

                case 41:
                  __varRecorder__$i.__inter0__ = _context5.sent;
                  _varRecorder__$__int = __varRecorder__$i.__inter0__.selected, _varRecorder__$__int2 = _slicedToArray(_varRecorder__$__int, 1), choice = _varRecorder__$__int2[0];
                  __varRecorder__$i.__inter0__;

                  if (choice) {
                    _context5.next = 47;
                    break;
                  }

                  canceled = true;
                  return _context5.abrupt("break", 70);

                case 47:
                  if (!(choice === choices[0])) {
                    _context5.next = 50;
                    break;
                  }

                  ignore.push(name);
                  return _context5.abrupt("continue", 23);

                case 50:
                  if (!(choice === choices[1])) {
                    _context5.next = 60;
                    break;
                  }

                  changes.push({
                    type: "global",
                    name: name
                  });

                  if (!(typeof sourceUpdater === "function")) {
                    _context5.next = 57;
                    break;
                  }

                  _context5.next = 55;
                  return sourceUpdater("global", [name]);

                case 55:
                  _context5.next = 59;
                  break;

                case 57:
                  _context5.next = 59;
                  return __varRecorder__$i.declareVarNamesAsGlobals(textMorph, [name], {
                    recordUndo: true,
                    sourceUpdater: sourceUpdater
                  });

                case 59:
                  return _context5.abrupt("continue", 23);

                case 60:
                  changes.push({
                    type: "import",
                    imported: choice
                  });

                  if (!(typeof sourceUpdater === "function")) {
                    _context5.next = 66;
                    break;
                  }

                  _context5.next = 64;
                  return sourceUpdater("import", [choice]);

                case 64:
                  _context5.next = 68;
                  break;

                case 66:
                  _context5.next = 68;
                  return __varRecorder__$i.injectImportsIntoText(textMorph, [choice], {
                    gotoImport: false,
                    insertImportAtCursor: false,
                    recordUndo: true,
                    undeclared: undeclared
                  });

                case 68:
                  _context5.next = 23;
                  break;

                case 70:
                  if (keepTextPosition) {
                    textMorph.scroll = scroll;
                    textMorph.cursorPosition = anchor.position;
                    textMorph.removeAnchor(anchor);
                  }

                  return _context5.abrupt("return", canceled ? null : changes);

                case 72:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        return function (_x8, _x9) {
          return _ref5.apply(this, arguments);
        };
      }(), __moduleMeta__$7));

      __varRecorder__$i.interactivlyFixUndeclaredVariables = interactivlyFixUndeclaredVariables;

      var cleanupUnusedImports = __varRecorder__$i["lively.ide/js/import-helper.js__define__"]("cleanupUnusedImports", "function", /*#__PURE__*/function () {
        var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(textMorph, opts) {
          var source, toRemove, _iterator, _step, _step$value, replacement, start, end, range;

          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  opts = Object.assign({
                    world: textMorph.world()
                  }, opts);
                  source = textMorph.textString;
                  _context6.next = 4;
                  return __varRecorder__$i.chooseUnusedImports(source, opts);

                case 4:
                  toRemove = _context6.sent;

                  if (toRemove) {
                    _context6.next = 7;
                    break;
                  }

                  return _context6.abrupt("return", "canceled");

                case 7:
                  if (!(!toRemove.changes || !toRemove.changes.length)) {
                    _context6.next = 9;
                    break;
                  }

                  return _context6.abrupt("return", "nothing to remove");

                case 9:
                  textMorph.undoManager.group();
                  _iterator = _createForOfIteratorHelper(toRemove.changes);

                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                      _step$value = _step.value, replacement = _step$value.replacement, start = _step$value.start, end = _step$value.end;
                      range = {
                        start: textMorph.indexToPosition(start),
                        end: textMorph.indexToPosition(end)
                      };
                      textMorph.replace(range, replacement);
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }

                  textMorph.undoManager.group();
                  return _context6.abrupt("return", "imports removed");

                case 14:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        return function (_x10, _x11) {
          return _ref7.apply(this, arguments);
        };
      }(), __moduleMeta__$7);

      __varRecorder__$i.cleanupUnusedImports = cleanupUnusedImports;

      var chooseUnusedImports = exports('a2', __varRecorder__$i["lively.ide/js/import-helper.js__define__"]("chooseUnusedImports", "function", /*#__PURE__*/function () {
        var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(source, opts) {
          var unused, items, _yield$opts$world$edi, importsToRemove;

          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  opts = Object.assign({
                    world: $world
                  }, opts);
                  unused = ImportRemover.findUnusedImports(source);

                  if (!(!unused || !unused.length)) {
                    _context7.next = 4;
                    break;
                  }

                  return _context7.abrupt("return", null);

                case 4:
                  items = unused.map(function (ea) {
                    var local = ea.local,
                        from = ea.from;
                    var label = ["".concat(local), {
                      fontWeight: "bold"
                    }, " from ", {}, "".concat(from, "\n"), {
                      fontStyle: "italic"
                    }];
                    return {
                      isListItem: true,
                      label: label,
                      value: ea
                    };
                  });
                  _context7.next = 7;
                  return opts.world.editListPrompt("Which imports should be removed?", items, {
                    multiSelect: true,
                    requester: opts.requester
                  });

                case 7:
                  _yield$opts$world$edi = _context7.sent;
                  importsToRemove = _yield$opts$world$edi.list;

                  if (!(!importsToRemove || !importsToRemove.length)) {
                    _context7.next = 11;
                    break;
                  }

                  return _context7.abrupt("return", []);

                case 11:
                  return _context7.abrupt("return", ImportRemover.removeImports(source, importsToRemove));

                case 12:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7);
        }));

        return function (_x12, _x13) {
          return _ref8.apply(this, arguments);
        };
      }(), __moduleMeta__$7));

      __varRecorder__$i.chooseUnusedImports = chooseUnusedImports;
      __varRecorder__$i.declareVarNamesAsGlobals = declareVarNamesAsGlobals;
      __varRecorder__$i.injectImportsIntoText = injectImportsIntoText;
      __varRecorder__$i.interactivelyInjectImportIntoText = interactivelyInjectImportIntoText;
      __varRecorder__$i.interactivelyChooseImports = interactivelyChooseImports;

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/import-helper.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ExportPrompt") && typeof __lively_classholder__.ExportPrompt === "function" ? __lively_classholder__.ExportPrompt : __lively_classholder__.ExportPrompt = function ExportPrompt(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "run",
          value: function () {
            var _ExportPrompt_run_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(world, exportData) {
              var requester,
                  _yield$world$filterab,
                  choices,
                  _args8 = arguments;

              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      requester = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : world;
                      _context8.next = 3;
                      return world.filterableListPrompt("Select import", exportData.map(function (ea) {
                        return {
                          isListItem: true,
                          value: ea,
                          label: __varRecorder__$i.labelForExport(ea)
                        };
                      }), {
                        multiSelect: true,
                        historyId: "lively.ide/js-interactively-import",
                        extent: pt(800, 500),
                        fuzzy: "value.exported",
                        requester: requester,
                        sortFunction: function sortFunction(parsedInput, item) {
                          var _item$value = item.value,
                              exported = _item$value.exported,
                              isMain = _item$value.isMain;
                          var exported = (exported || "").toLowerCase();
                          var base = isMain ? -1 : 0;
                          parsedInput.lowercasedTokens.forEach(function (t) {
                            return base -= exported.startsWith(t) ? 10 : exported.includes(t) ? 5 : 0;
                          });
                          return sum(parsedInput.lowercasedTokens.map(function (token) {
                            return levenshtein(exported.toLowerCase(), token);
                          })) + base;
                        }
                      });

                    case 3:
                      _yield$world$filterab = _context8.sent;
                      choices = _yield$world$filterab.selected;
                      return _context8.abrupt("return", choices);

                    case 6:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8);
            }));

            function ExportPrompt_run_(_x14, _x15) {
              return _ExportPrompt_run_.apply(this, arguments);
            }

            return ExportPrompt_run_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ExportPrompt";
          }
        }, {
          key: "run",
          value: function ExportPrompt_run_(world, exportData) {
            var requester = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : world;
            return new this().run(world, exportData, requester);
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/import-helper.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 6081,
          end: 7267
        });
      })(undefined);
      __varRecorder__$i.undeclaredVariables = undeclaredVariables;
      __varRecorder__$i.interactivlyFixUndeclaredVariables = interactivlyFixUndeclaredVariables;
      __varRecorder__$i.cleanupUnusedImports = cleanupUnusedImports;
      __varRecorder__$i.chooseUnusedImports = chooseUnusedImports;

      var importHelper = /*#__PURE__*/Object.freeze({
        __proto__: null,
        declareVarNamesAsGlobals: declareVarNamesAsGlobals,
        injectImportsIntoText: injectImportsIntoText,
        interactivelyInjectImportIntoText: interactivelyInjectImportIntoText,
        interactivelyChooseImports: interactivelyChooseImports,
        undeclaredVariables: undeclaredVariables,
        interactivlyFixUndeclaredVariables: interactivlyFixUndeclaredVariables,
        cleanupUnusedImports: cleanupUnusedImports,
        chooseUnusedImports: chooseUnusedImports
      });

      var __varRecorder__$h = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/components/reconciliation.js", __contextModule__);
      var __moduleMeta__$6 = {
        pathInPackage: function pathInPackage() {
          return "./components/reconciliation.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var isWithinDerivedComponent = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("isWithinDerivedComponent", "function", function (aMorph, includeSelf) {
        var _aMorph$master;

        if (includeSelf && ((_aMorph$master = aMorph.master) === null || _aMorph$master === void 0 ? void 0 : _aMorph$master.parent)) return true;
        if (aMorph.__wasAddedToDerived__) return false;

        var _iterator = _createForOfIteratorHelper(aMorph.ownerChain()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _each$master;

            var each = _step.value;
            if ((_each$master = each.master) === null || _each$master === void 0 ? void 0 : _each$master.parent) return true;
            if (each.__wasAddedToDerived__) return false;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return false;
      }, __moduleMeta__$6);

      __varRecorder__$h.isWithinDerivedComponent = isWithinDerivedComponent;

      var createInitialComponentDefinition = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("createInitialComponentDefinition", "function", function (aComponent) {
        var asExprObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var _convertToExpression = convertToExpression(aComponent, {
          skipAttributes: [].concat(_toConsumableArray$1(DEFAULT_SKIPPED_ATTRIBUTES), ["treeData"])
        }),
            __expr__ = _convertToExpression.__expr__,
            bindings = _convertToExpression.bindings;

        __expr__ = "component(" + __expr__ + ")";

        if (asExprObject) {
          if (bindings["lively.morphic"]) {
            pushIfNotIncluded(bindings["lively.morphic"], "component");
          } else {
            bindings["lively.morphic"] = ["component"];
          }

          return {
            __expr__: __expr__,
            bindings: bindings
          };
        }

        return __expr__;
      }, __moduleMeta__$6);

      __varRecorder__$h.createInitialComponentDefinition = createInitialComponentDefinition;

      var insertMorphChange = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("insertMorphChange", "function", function (submorphsArrayNode, addedMorphExpr) {
        var nextSibling = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var insertPos = last$2(submorphsArrayNode.elements).end;
        var action = {
          action: "insert",
          start: insertPos,
          lines: ["," + addedMorphExpr]
        };

        if (nextSibling) {
          var siblingNode = getNodeFromSubmorphs(submorphsArrayNode, nextSibling.name);
          if (!siblingNode) return action;
          action.start = siblingNode.start;
          action.lines = [addedMorphExpr + ","];
        }

        return action;
      }, __moduleMeta__$6);

      __varRecorder__$h.insertMorphChange = insertMorphChange;

      var determineNodeToRemoveSubmorphs = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("determineNodeToRemoveSubmorphs", "function", function (nodeToRemove, parsedComponent, fromMorph) {
        var ignoredProps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ["name", "submorphs"];
        var curr = fromMorph;
        var propNode = getPropertiesNode(parsedComponent, curr);
        var ignoreQuery = "\n  / Property [\n    /:key Identifier [ ".concat(ignoredProps.map(function (prop) {
          return "@name != '".concat(prop, "'");
        }).join(" && "), " ]\n   ]");
        var submorphsNode = getProp(propNode, "submorphs");

        while (queryNodes(propNode, ignoreQuery).length === 0 && (((_submorphsNode = submorphsNode) === null || _submorphsNode === void 0 ? void 0 : _submorphsNode.value.elements.length) || 0) < 2) {
          var _submorphsNode, _curr, _submorphsNode2;

          if (!curr.owner) break;

          var withinDerived = __varRecorder__$h.isWithinDerivedComponent(curr);

          nodeToRemove = withinDerived ? propNode : submorphsNode;
          if (withinDerived && queryNodes(propNode, ignoreQuery).length === 0) nodeToRemove = propNode;
          curr = curr.owner;
          propNode = getPropertiesNode(parsedComponent, ((_curr = curr) === null || _curr === void 0 ? void 0 : _curr.isComponent) ? null : curr);
          submorphsNode = getProp(propNode, "submorphs");
          if (((_submorphsNode2 = submorphsNode) === null || _submorphsNode2 === void 0 ? void 0 : _submorphsNode2.value.elements.length) < 2) nodeToRemove = submorphsNode;
          if (curr.isWorld) break;
        }

        return nodeToRemove;
      }, __moduleMeta__$6);

      __varRecorder__$h.determineNodeToRemoveSubmorphs = determineNodeToRemoveSubmorphs;

      var insertPropChange = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("insertPropChange", "function", function (sourceCode, propertiesNode, key, valueExpr) {
        var nameProp = propertiesNode.properties.findIndex(function (prop) {
          return prop.key.name === "name";
        });
        var typeProp = propertiesNode.properties.findIndex(function (prop) {
          return prop.key.name === "type";
        });
        var submorphsProp = propertiesNode.properties.findIndex(function (prop) {
          return prop.key.name === "submorphs";
        });
        var modelProp = propertiesNode.properties.findIndex(function (prop) {
          var _prop$key$name;

          return (_prop$key$name = prop.key.name) === null || _prop$key$name === void 0 ? void 0 : _prop$key$name.match(/viewModelClass|defaultViewModel/);
        });
        var isVeryFirst = propertiesNode.properties.length === 0;
        var afterPropNode = propertiesNode.properties[Math.max(typeProp, nameProp, modelProp)];
        var keyValueExpr = "\n" + key + ": " + valueExpr;
        var insertationPoint;

        if (!afterPropNode || key === "submorphs") {
          if (isVeryFirst) insertationPoint = propertiesNode.start + 1;else afterPropNode = last$2(propertiesNode.properties);
        }

        if (submorphsProp > -1) {
          var ia = afterPropNode ? propertiesNode.properties.indexOf(afterPropNode) : 0;
          afterPropNode = propertiesNode.properties[Math.min(ia, submorphsProp - 1)];

          if (!afterPropNode) {
            insertationPoint = propertiesNode.start + 1;
            keyValueExpr = keyValueExpr + ",";
          }
        }

        if (afterPropNode) {
          keyValueExpr = "," + keyValueExpr;
        }

        if (afterPropNode && !insertationPoint) {
          insertationPoint = afterPropNode.end;
        }

        var changes = [];

        if (isVeryFirst) {
          keyValueExpr = "{".concat(keyValueExpr, "\n}");
          changes = [Object.assign({
            action: "replace"
          }, propertiesNode, {
            lines: [keyValueExpr]
          })];
        } else {
          changes = [{
            action: "insert",
            start: insertationPoint,
            lines: [keyValueExpr]
          }];
        }

        return changes;
      }, __moduleMeta__$6);

      __varRecorder__$h.insertPropChange = insertPropChange;

      var deleteProp = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("deleteProp", "function", function (sourceCode, parsedComponent, morphDef, propName, target, eraseIfEmpty) {
        var propNode = getProp(morphDef, propName);

        if (!propNode) {
          return {
            needsLinting: false,
            changes: []
          };
        }

        if (eraseIfEmpty && morphDef.properties.length < 3) {
          var nodeToRemove = __varRecorder__$h.determineNodeToRemoveSubmorphs(morphDef, parsedComponent, target, ["name", "submorphs", propName]);

          return {
            needsLinting: true,
            changes: [Object.assign({
              action: "remove"
            }, nodeToRemove)]
          };
        }

        var patchPos = propNode;

        while (sourceCode[patchPos.end].match(/,| |\n/)) {
          patchPos.end++;
        }

        return {
          needsLinting: true,
          changes: [Object.assign({
            action: "remove"
          }, patchPos)]
        };
      }, __moduleMeta__$6);

      __varRecorder__$h.deleteProp = deleteProp;

      var fixUndeclaredVars = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("fixUndeclaredVars", "function", function (sourceCode, requiredBindings, mod) {
        var S = mod.System;
        var knownGlobals = mod.dontTransform;
        var undeclared = undeclaredVariables(sourceCode, knownGlobals).map(function (n) {
          return n.name;
        });
        var updatedSource = sourceCode;
        var changes = [];
        if (undeclared.length === 0) return {
          updatedSource: sourceCode,
          changes: changes
        };

        var _iterator2 = _createForOfIteratorHelper(requiredBindings),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _slicedToArray(_step2.value, 2),
                importedModuleId = _step2$value[0],
                exportedIds = _step2$value[1];

            var _iterator3 = _createForOfIteratorHelper(exportedIds),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var _module$package;

                var exportedId = _step3.value;
                if (!undeclared.includes(exportedId)) continue;
                remove(undeclared, exportedId);
                var generated = void 0,
                    from = void 0;
                __varRecorder__$h.__inter0__ = ImportInjector.run(System, mod.id, mod["package"](), updatedSource, {
                  exported: exportedId,
                  moduleId: module$2(S, importedModuleId).id,
                  pathInPackage: module$2(S, importedModuleId).pathInPackage(),
                  packageName: (_module$package = module$2(S, importedModuleId)["package"]()) === null || _module$package === void 0 ? void 0 : _module$package.name
                }), generated = __varRecorder__$h.__inter0__.generated, from = __varRecorder__$h.__inter0__.from, updatedSource = __varRecorder__$h.__inter0__.newSource, __varRecorder__$h.__inter0__;
                changes.push({
                  action: "insert",
                  start: from,
                  lines: [generated]
                });
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return {
          updatedSource: updatedSource,
          changes: changes
        };
      }, __moduleMeta__$6);

      __varRecorder__$h.fixUndeclaredVars = fixUndeclaredVars;

      var removeComponentDefinition = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("removeComponentDefinition", "function", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(entityName, mod) {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return mod.changeSourceAction(function (oldSource) {
                    var parsed = parse$2(oldSource);
                    var exportSpecs = queryNodes(parsed, "// ExportSpecifier [\n         /:local Identifier [@name == \"".concat(entityName, "\"]\n       ],\n      // ExportDefaultDeclaration [\n         /:declaration Identifier [@name == \"").concat(entityName, "\"]\n       ]\n      "));
                    var rangesToRemove = [];

                    var _iterator4 = _createForOfIteratorHelper(exportSpecs),
                        _step4;

                    try {
                      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                        var exportSpec = _step4.value;

                        while (oldSource[exportSpec.start - 1].match(/ /)) {
                          exportSpec.start--;
                        }

                        while (oldSource[exportSpec.end].match(/\,|\n/)) {
                          exportSpec.end++;
                        }

                        rangesToRemove.push(Object.assign({
                          action: "remove"
                        }, exportSpec));
                      }
                    } catch (err) {
                      _iterator4.e(err);
                    } finally {
                      _iterator4.f();
                    }

                    var componentDef = findComponentDef(parsed, entityName);

                    while (oldSource[componentDef.end].match(/\,|\n/)) {
                      componentDef.end++;
                    }

                    rangesToRemove.push(Object.assign({
                      action: "remove"
                    }, componentDef));
                    return ImportRemover.removeUnusedImports(applyChanges(oldSource, sortBy(rangesToRemove, function (range) {
                      return -range.start;
                    }))).source;
                  });

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }(), __moduleMeta__$6);

      __varRecorder__$h.removeComponentDefinition = removeComponentDefinition;

      var replaceComponentDefinition = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("replaceComponentDefinition", "function", /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(defAsCode, entityName, mod) {
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return mod.changeSourceAction(function (oldSource) {
                    var _findComponentDef = findComponentDef(parse$2(oldSource), entityName),
                        start = _findComponentDef.start,
                        end = _findComponentDef.end;

                    return ImportRemover.removeUnusedImports(applyChanges(oldSource, [{
                      start: start,
                      end: end,
                      action: "replace",
                      lines: [defAsCode]
                    }])).source;
                  });

                case 2:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function (_x3, _x4, _x5) {
          return _ref2.apply(this, arguments);
        };
      }(), __moduleMeta__$6);

      __varRecorder__$h.replaceComponentDefinition = replaceComponentDefinition;

      var insertComponentDefinition = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("insertComponentDefinition", "function", /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(protoMorph, entityName, mod) {
          var scope;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return mod.scope();

                case 2:
                  scope = _context3.sent;
                  _context3.next = 5;
                  return mod.changeSourceAction(function (oldSource) {
                    var _varRecorder__$creat = __varRecorder__$h.createInitialComponentDefinition(protoMorph, true),
                        compCall = _varRecorder__$creat.__expr__,
                        requiredBindings = _varRecorder__$creat.bindings;

                    var decl = "\nconst ".concat(entityName, " = ").concat(compCall, ";\n\n");
                    var finalExports = last$2(scope.exportDecls);

                    if (!finalExports) {
                      return __varRecorder__$h.fixUndeclaredVars(oldSource + decl, Object.entries(requiredBindings), mod).updatedSource + "\n\nexport { ".concat(entityName, " }");
                    }

                    var updatedExports = Object.assign({}, finalExports, {
                      specifiers: [].concat(_toConsumableArray$1(finalExports.specifiers), [id(entityName)])
                    });
                    return System.lint(__varRecorder__$h.fixUndeclaredVars(applyChanges(oldSource, [Object.assign({
                      action: "replace"
                    }, finalExports, {
                      lines: [decl, stringify(updatedExports)]
                    })]), Object.entries(requiredBindings), mod).updatedSource)[0];
                  });

                case 5:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function (_x6, _x7, _x8) {
          return _ref3.apply(this, arguments);
        };
      }(), __moduleMeta__$6);

      __varRecorder__$h.insertComponentDefinition = insertComponentDefinition;

      var canBeRenamed = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("canBeRenamed", "function", function (mod, oldName, newName) {
        if (camelCaseString(newName) in mod.recorder) return false;
        return true;
      }, __moduleMeta__$6);

      __varRecorder__$h.canBeRenamed = canBeRenamed;

      var renameComponent = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("renameComponent", "function", /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(protoMorph, newName, system) {
          var _exports$find;

          var meta, mod, exports, oldName, parsedModule, descr, moduleNeedsRename, _findComponentDef2, _findComponentDef2$de, decl, references, _ref5, exportedEntity, newModuleName, oldModuleName, newId;

          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  meta = protoMorph[Symbol["for"]("lively-module-meta")];

                  if (!(!(meta === null || meta === void 0 ? void 0 : meta.moduleId) || !(meta === null || meta === void 0 ? void 0 : meta.exportedName))) {
                    _context5.next = 3;
                    break;
                  }

                  return _context5.abrupt("return");

                case 3:
                  mod = module$2(system, meta.moduleId);
                  _context5.next = 6;
                  return mod.exports();

                case 6:
                  exports = _context5.sent;
                  oldName = meta.exportedName;
                  _context5.next = 10;
                  return mod.ast();

                case 10:
                  parsedModule = _context5.sent;
                  descr = mod.recorder[oldName];
                  moduleNeedsRename = !descr.stylePolicy.parent;
                  _findComponentDef2 = findComponentDef(parsedModule, meta.exportedName), _findComponentDef2$de = _slicedToArray(_findComponentDef2.declarations, 1), decl = _findComponentDef2$de[0].id;
                  _context5.t0 = arr;
                  _context5.t1 = getComponentDeclsFromScope;
                  _context5.t2 = mod.id;
                  _context5.next = 19;
                  return mod.scope();

                case 19:
                  _context5.t3 = _context5.sent;
                  _context5.next = 22;
                  return (0, _context5.t1)(_context5.t2, _context5.t3);

                case 22:
                  _context5.t4 = function (ref) {
                    return getParentRef(ref[1]);
                  };

                  _context5.t5 = _context5.sent.map(_context5.t4);
                  references = _context5.t0.compact.call(_context5.t0, _context5.t5);
                  _ref5 = ((_exports$find = exports.find(function (exp) {
                    return exp.local === oldName;
                  })) === null || _exports$find === void 0 ? void 0 : _exports$find.node) || {}, exportedEntity = _ref5.local;
                  oldModuleName = mod.shortName();

                  if (!moduleNeedsRename) {
                    _context5.next = 33;
                    break;
                  }

                  newModuleName = decamelize(newName).split(" ").join("-") + ".cp.js";
                  newId = resource(mod.id).parent().join(newModuleName).url;
                  _context5.next = 32;
                  return mod.renameTo(newId, {
                    unload: true,
                    removeFile: true,
                    updateDependants: true
                  });

                case 32:
                  mod = _context5.sent;

                case 33:
                  _context5.next = 35;
                  return mod.ensureRecord();

                case 35:
                  _context5.next = 37;
                  return mod.changeSourceAction(function (oldSource) {
                    if (exportedEntity) {
                      oldSource = applyChange(oldSource, Object.assign({
                        action: "replace"
                      }, exportedEntity, {
                        lines: [newName]
                      }));
                    }

                    var changes = sortBy([Object.assign({
                      action: "replace"
                    }, decl, {
                      lines: [newName]
                    })].concat(_toConsumableArray$1(references.map(function (ref) {
                      return Object.assign({
                        action: "replace"
                      }, ref, {
                        lines: [newName]
                      });
                    }))), function (action) {
                      return -action.start;
                    });
                    return applyChanges(oldSource, changes);
                  });

                case 37:
                  _context5.next = 39;
                  return mod.recorder[meta.exportedName].withDerivedComponentsDo( /*#__PURE__*/function () {
                    var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(descr) {
                      var meta, _imports$find, _mod, _parsedModule, imports, _findComponentDef3, _findComponentDef3$de, _findComponentDef3$de2, ref, importedEntity;

                      return regeneratorRuntime.wrap(function _callee4$(_context4) {
                        while (1) {
                          switch (_context4.prev = _context4.next) {
                            case 0:
                              meta = descr[Symbol["for"]("lively-module-meta")];

                              if (!(meta.exportedName && meta.moduleId !== oldModuleName)) {
                                _context4.next = 13;
                                break;
                              }

                              _mod = descr.targetModule;
                              _context4.next = 5;
                              return _mod.ast();

                            case 5:
                              _parsedModule = _context4.sent;
                              _context4.next = 8;
                              return _mod.imports();

                            case 8:
                              imports = _context4.sent;
                              _findComponentDef3 = findComponentDef(_parsedModule, meta.exportedName), _findComponentDef3$de = _slicedToArray(_findComponentDef3.declarations, 1), _findComponentDef3$de2 = _slicedToArray(_findComponentDef3$de[0].init.arguments, 1), ref = _findComponentDef3$de2[0];
                              importedEntity = ((_imports$find = imports.find(function (imp) {
                                return imp.imported === oldName;
                              })) === null || _imports$find === void 0 ? void 0 : _imports$find.node) || {};
                              _context4.next = 13;
                              return _mod.changeSourceAction(function (oldSource) {
                                oldSource = applyChange(oldSource, Object.assign({
                                  action: "replace"
                                }, ref, {
                                  lines: [newName]
                                }));

                                if (importedEntity) {
                                  if (moduleNeedsRename) {
                                    var source = importedEntity.source;
                                    oldSource = applyChange(oldSource, Object.assign({
                                      action: "replace"
                                    }, source, {
                                      lines: ["'".concat(source.value.split("/").slice(0, -1).concat(newModuleName).join("/"), "'")]
                                    }));
                                  }

                                  var imp = importedEntity.specifiers.find(function (spec) {
                                    return spec.imported.name === oldName;
                                  });
                                  oldSource = applyChange(oldSource, Object.assign({
                                    action: "replace"
                                  }, imp, {
                                    lines: [newName]
                                  }));
                                }

                                return oldSource;
                              });

                            case 13:
                            case "end":
                              return _context4.stop();
                          }
                        }
                      }, _callee4);
                    }));

                    return function (_x12) {
                      return _ref6.apply(this, arguments);
                    };
                  }());

                case 39:
                  _context5.next = 41;
                  return mod.recorder[newName].edit();

                case 41:
                  return _context5.abrupt("return", _context5.sent);

                case 42:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        return function (_x9, _x10, _x11) {
          return _ref4.apply(this, arguments);
        };
      }(), __moduleMeta__$6);

      __varRecorder__$h.renameComponent = renameComponent;

      var insertMorphExpression = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("insertMorphExpression", "function", function (parsedComponent, sourceCode, newOwner, addedMorphExpr) {
        var _getProp;

        var nextSibling = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        var morphNode = getMorphNode(parsedComponent, newOwner);
        var propsNode = morphNode && getPropertiesNode(morphNode);
        var submorphsArrayNode = propsNode && ((_getProp = getProp(propsNode, "submorphs")) === null || _getProp === void 0 ? void 0 : _getProp.value);

        if (!submorphsArrayNode) {
          if (!propsNode) {
            return __varRecorder__$h.uncollapseSubmorphHierarchy(sourceCode, parsedComponent, newOwner, addedMorphExpr);
          }

          return {
            needsLinting: true,
            bindings: addedMorphExpr.bindings,
            changes: __varRecorder__$h.insertPropChange(sourceCode, propsNode, "submorphs", "[".concat(addedMorphExpr.__expr__, "]"))
          };
        } else {
          return {
            needsLinting: true,
            bindings: addedMorphExpr.bindings,
            changes: [__varRecorder__$h.insertMorphChange(submorphsArrayNode, addedMorphExpr.__expr__, nextSibling)]
          };
        }
      }, __moduleMeta__$6);

      __varRecorder__$h.insertMorphExpression = insertMorphExpression;

      var uncollapseSubmorphHierarchy = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("uncollapseSubmorphHierarchy", "function", function (sourceCode, parsedComponent, hiddenMorph) {
        var hiddenSubmorphExpr = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var nextVisibleParent = hiddenMorph;
        var idx = hiddenMorph.owner.submorphs.indexOf(hiddenMorph);
        var nextSibling = idx !== -1 && hiddenMorph.owner.submorphs[idx + 1];
        var ownerChain = [hiddenMorph];
        var propertiesNode, morphToExpand;

        do {
          morphToExpand = nextVisibleParent;
          nextVisibleParent = nextVisibleParent.owner;
          ownerChain.push(nextVisibleParent);
          propertiesNode = getPropertiesNode(parsedComponent, nextVisibleParent);
        } while (!propertiesNode);

        var masterInScope = findAndGet(morphToExpand.ownerChain(), function (m) {
          return m.master;
        });
        var uncollapsedHierarchyExpr = convertToExpression(morphToExpand, {
          onlyInclude: ownerChain,
          exposeMasterRefs: false,
          uncollapseHierarchy: true,
          masterInScope: masterInScope,
          skipAttributes: [].concat(_toConsumableArray$1(DEFAULT_SKIPPED_ATTRIBUTES), ["master", "type"]),
          valueTransform: function valueTransform(key, val, aMorph) {
            if (hiddenSubmorphExpr && aMorph === hiddenMorph && key === "submorphs") {
              return [hiddenSubmorphExpr];
            }

            return standardValueTransform(key, val, aMorph);
          }
        });
        if (!uncollapsedHierarchyExpr) return {
          changes: [],
          needsLinting: false,
          bindings: []
        };
        return __varRecorder__$h.insertMorphExpression(parsedComponent, sourceCode, nextVisibleParent, uncollapsedHierarchyExpr, nextSibling);
      }, __moduleMeta__$6);

      __varRecorder__$h.uncollapseSubmorphHierarchy = uncollapseSubmorphHierarchy;

      var applyModuleChanges = __varRecorder__$h["lively.ide/components/reconciliation.js__define__"]("applyModuleChanges", "function", function (reconciliation, scope, system) {
        var _sourceEditor$editorP;

        var sourceEditor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var changesByModule = reconciliation.changesByModule,
            modulesToLint = reconciliation.modulesToLint,
            requiredBindingsByModule = reconciliation.requiredBindingsByModule;
        var focusedModuleId = sourceEditor === null || sourceEditor === void 0 ? void 0 : (_sourceEditor$editorP = sourceEditor.editorPlugin) === null || _sourceEditor$editorP === void 0 ? void 0 : _sourceEditor$editorP.evalEnvironment.targetModule;
        changesByModule = groupBy(changesByModule, first);

        var _loop = function _loop(moduleName) {
          var mod = module$2(system, moduleName);
          var sourceCode = mod._source,
              id = mod.id;
          if (!sourceCode) return "continue";
          var requiredBindingsForChanges = requiredBindingsByModule.get(id);
          var runLint = modulesToLint.has(mod.fullName());
          var patchTextMorph = id === focusedModuleId;
          if (patchTextMorph && !runLint) sourceCode = sourceEditor.textString;
          var changes = changesByModule[moduleName].map(function (l) {
            return l[1];
          }).flat();
          changes = sortBy(changes, function (change) {
            return change.start;
          }).reverse();
          var updatedSource = patchTextMorph && !runLint ? applyChangesToTextMorph(sourceEditor, changes) : applySourceChanges(sourceCode, changes);
          var hasUndefinedVariables = false;
          var importedRefs = new Set(scope.importSpecifiers.map(function (spec) {
            return spec.name;
          }));

          var _iterator5 = _createForOfIteratorHelper(requiredBindingsForChanges),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var _step5$value = _slicedToArray(_step5.value, 2),
                  _ = _step5$value[0],
                  refs = _step5$value[1];

              if (!refs.every(function (ref) {
                return importedRefs.has(ref);
              })) {
                hasUndefinedVariables = true;
                break;
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }

          if (hasUndefinedVariables) {
            __varRecorder__$h.__inter1__ = __varRecorder__$h.fixUndeclaredVars(updatedSource, requiredBindingsForChanges, mod), changes = __varRecorder__$h.__inter1__.changes, __varRecorder__$h.__inter1__;
            updatedSource = patchTextMorph && !runLint ? applyChangesToTextMorph(sourceEditor, changes) : applySourceChanges(updatedSource, changes);
          }

          if (runLint) {
            var _System$lint = System.lint(updatedSource);

            var _System$lint2 = _slicedToArray(_System$lint, 1);

            updatedSource = _System$lint2[0];

            if (patchTextMorph) {
              sourceEditor.textString = updatedSource;
            }
          }

          if (patchTextMorph) {
            var browser = sourceEditor.owner;
            if (browser === null || browser === void 0 ? void 0 : browser.isBrowser) browser.resetChangedContentIndicator();
          }

          mod.setSource(updatedSource);
        };

        for (var moduleName in changesByModule) {
          var _ret = _loop(moduleName);

          if (_ret === "continue") continue;
        }
      }, __moduleMeta__$6);

      __varRecorder__$h.applyModuleChanges = applyModuleChanges;
      __varRecorder__$h.exprSerializer = new ExpressionSerializer();
      var exprSerializer = __varRecorder__$h.exprSerializer;
      __varRecorder__$h.exprSerializer = exprSerializer;
      __varRecorder__$h.createInitialComponentDefinition = createInitialComponentDefinition;
      __varRecorder__$h.insertMorphChange = insertMorphChange;
      __varRecorder__$h.insertPropChange = insertPropChange;
      __varRecorder__$h.deleteProp = deleteProp;
      __varRecorder__$h.fixUndeclaredVars = fixUndeclaredVars;
      __varRecorder__$h.removeComponentDefinition = removeComponentDefinition;
      __varRecorder__$h.replaceComponentDefinition = replaceComponentDefinition;
      __varRecorder__$h.insertComponentDefinition = insertComponentDefinition;
      __varRecorder__$h.canBeRenamed = canBeRenamed;
      __varRecorder__$h.renameComponent = renameComponent;
      __varRecorder__$h.insertMorphExpression = insertMorphExpression;
      __varRecorder__$h.uncollapseSubmorphHierarchy = uncollapseSubmorphHierarchy;
      __varRecorder__$h.applyModuleChanges = applyModuleChanges;
      var Reconciliation = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/components/reconciliation.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("Reconciliation") && typeof __lively_classholder__.Reconciliation === "function" ? __lively_classholder__.Reconciliation : __lively_classholder__.Reconciliation = function Reconciliation(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function Reconciliation_initialize_(componentDescriptor, change) {
            this.changesByModule = [];
            this.requiredBindingsByModule = new Map();
            this.descriptor = componentDescriptor;
            this.modulesToLint = new Set();
            this.change = change;
          }
        }, {
          key: "isOrigin",
          value: function Reconciliation_isOrigin_(descriptor) {
            return this.descriptor === descriptor;
          }
        }, {
          key: "target",
          get: function get() {
            var _this$change;

            return (_this$change = this.change) === null || _this$change === void 0 ? void 0 : _this$change.target;
          }
        }, {
          key: "System",
          get: function get() {
            return this.descriptor.System;
          }
        }, {
          key: "isDerived",
          get: function get() {
            return this.withinDerivedComponent(this.target);
          }
        }, {
          key: "getEligibleSourceEditors",
          value: function Reconciliation_getEligibleSourceEditors_(modId, modSource) {
            return getEligibleSourceEditorsFor(modId, modSource);
          }
        }, {
          key: "recoverRemovedMorphMetaIn",
          value: function Reconciliation_recoverRemovedMorphMetaIn_(interactiveDescriptor) {
            var _this$policyToSpecAnd;

            return (_this$policyToSpecAnd = this.policyToSpecAndSubExpressions) === null || _this$policyToSpecAnd === void 0 ? void 0 : _this$policyToSpecAnd.get(__varRecorder__$h.exprSerializer.exprStringEncode(interactiveDescriptor.__serialize__()));
          }
        }, {
          key: "getDescriptorContext",
          value: function Reconciliation_getDescriptorContext_() {
            var descr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.descriptor;
            if (!this._context) this._context = new Map();
            if (this._context.has(descr)) return this._context.get(descr);
            var modId = System.decanonicalize(descr.moduleName);
            var sourceCode = descr.getModuleSource();
            var openEditors;

            var _openEditors = openEditors = this.getEligibleSourceEditors(modId, sourceCode),
                _openEditors2 = _slicedToArray(_openEditors, 1),
                openEditor = _openEditors2[0];

            if (openEditor) sourceCode = openEditor.textString;
            var parsedModule = parse$2(sourceCode);
            var scope = topLevelDeclsAndRefs(parsedModule).scope;
            var parsedComponent = descr.getASTNode(parsedModule);
            var requiredBindings = this.requiredBindingsByModule.get(modId) || [];
            if (!this.requiredBindingsByModule.has(modId)) this.requiredBindingsByModule.set(modId, requiredBindings);
            var ctx = {
              modId: modId,
              parsedComponent: parsedComponent,
              sourceCode: sourceCode,
              requiredBindings: requiredBindings,
              openEditor: openEditor,
              openEditors: openEditors,
              scope: scope
            };

            this._context.set(descr, ctx);

            return ctx;
          }
        }, {
          key: "withinDerivedComponent",
          value: function Reconciliation_withinDerivedComponent_(aMorph) {
            var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            return __varRecorder__$h.isWithinDerivedComponent(aMorph, includeSelf);
          }
        }, {
          key: "addChangesToModule",
          value: function Reconciliation_addChangesToModule_(moduleName, newChanges) {
            this.changesByModule.push([moduleName, newChanges]);
          }
        }, {
          key: "uncollapseSubmorphHierarchy",
          value: function Reconciliation_uncollapseSubmorphHierarchy_() {
            var hiddenSubmorphExpr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var hiddenMorph = this.target;

            var _this$getDescriptorCo = this.getDescriptorContext(),
                modId = _this$getDescriptorCo.modId,
                sourceCode = _this$getDescriptorCo.sourceCode,
                parsedComponent = _this$getDescriptorCo.parsedComponent,
                requiredBindings = _this$getDescriptorCo.requiredBindings;

            var _varRecorder__$uncol = __varRecorder__$h.uncollapseSubmorphHierarchy(sourceCode, parsedComponent, hiddenMorph, hiddenSubmorphExpr),
                changes = _varRecorder__$uncol.changes,
                needsLinting = _varRecorder__$uncol.needsLinting,
                bindings = _varRecorder__$uncol.bindings;

            requiredBindings.push.apply(requiredBindings, _toConsumableArray$1(Object.entries(bindings)));
            if (needsLinting) this.modulesToLint.add(modId);
            this.addChangesToModule(modId, changes);
            return this;
          }
        }, {
          key: "applyChanges",
          value: function Reconciliation_applyChanges_() {
            var _this2 = this;

            var _this$getDescriptorCo2 = this.getDescriptorContext(),
                openEditors = _this$getDescriptorCo2.openEditors,
                scope = _this$getDescriptorCo2.scope;

            if (openEditors.length > 0) {
              openEditors.map(function (ed) {
                return __varRecorder__$h.applyModuleChanges(_this2, scope, _this2.System, ed);
              });
            } else {
              __varRecorder__$h.applyModuleChanges(this, scope, this.System);
            }

            return this;
          }
        }, {
          key: "reconcile",
          value: function Reconciliation_reconcile_() {
            notYetImplemented(this.constructor.name + ".reconcile()");
            return this;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "Reconciliation";
          }
        }, {
          key: "ensureNamesInSourceCode",
          value: function Reconciliation_ensureNamesInSourceCode_(componentDescriptor) {
            new __varRecorder__$h.EnsureNamesReconciliation(componentDescriptor).reconcile().applyChanges();
          }
        }, {
          key: "perform",
          value: function Reconciliation_perform_(componentDescriptor, change) {
            var klass;
            componentDescriptor.ensureNamesInSourceCode();

            if (change.prop) {
              klass = change.prop === "name" ? __varRecorder__$h.RenameReconciliation : __varRecorder__$h.PropChangeReconciliation;
            }

            if (change.selector === "addMorphAt") {
              klass = __varRecorder__$h.MorphIntroductionReconciliation;
            }

            if (change.selector === "removeMorph") {
              klass = __varRecorder__$h.MorphRemovalReconciliation;
            }

            if (change.prop === "textAndAttributes" || change.selector === "replace" || change.selector === "addTextAttribute") {
              klass = __varRecorder__$h.TextChangeReconciliation;
            }

            return new klass(componentDescriptor, change).reconcile().applyChanges();
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./components/reconciliation.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 24595,
          end: 29584
        });
      }(undefined);
      __varRecorder__$h.Reconciliation = Reconciliation;
      __varRecorder__$h.Reconciliation = Reconciliation;

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/components/reconciliation.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("EnsureNamesReconciliation") && typeof __lively_classholder__.EnsureNamesReconciliation === "function" ? __lively_classholder__.EnsureNamesReconciliation : __lively_classholder__.EnsureNamesReconciliation = function EnsureNamesReconciliation(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "spec",
          get: function get() {
            return this.descriptor.stylePolicy.spec;
          }
        }, {
          key: "target",
          get: function get() {
            return this.descriptor._cachedComponent;
          }
        }, {
          key: "reconcile",
          value: function EnsureNamesReconciliation_reconcile_() {
            var _this3 = this;

            var _this$getDescriptorCo3 = this.getDescriptorContext(),
                modId = _this$getDescriptorCo3.modId,
                sourceCode = _this$getDescriptorCo3.sourceCode,
                parsedComponent = _this$getDescriptorCo3.parsedComponent;

            var anonymousSpecs = getAnonymousSpecs(parsedComponent);
            var anonymousParts = getAnonymousParts(parsedComponent);
            var anonymousAddedParts = getAnonymousAddedParts(parsedComponent);
            var rootNode = getPropertiesNode(parsedComponent);
            mapTree([this.spec, rootNode], function (_ref7) {
              var _currentSpec$props;

              var _ref8 = _slicedToArray(_ref7, 2),
                  currentSpec = _ref8[0],
                  currentNode = _ref8[1];

              if (currentNode === rootNode) return;
              var propNode = getPropertiesNode(currentNode);
              var generatedName = ((_currentSpec$props = currentSpec.props) === null || _currentSpec$props === void 0 ? void 0 : _currentSpec$props.name) || currentSpec.name;

              if (propNode && anonymousSpecs.includes(propNode) && generatedName) {
                _this3.addChangesToModule(modId, __varRecorder__$h.insertPropChange(sourceCode, propNode, "name", "'".concat(generatedName, "'")));

                return;
              }

              if (anonymousParts.includes(currentNode)) {
                _this3.addChangesToModule(modId, [{
                  action: "insert",
                  start: currentNode.arguments[0].end,
                  lines: [", { name: '".concat(generatedName, "' }")]
                }]);
              }

              if (anonymousAddedParts.includes(currentNode)) {
                _this3.addChangesToModule(modId, [{
                  action: "insert",
                  start: currentNode.arguments[0].arguments[0].end,
                  lines: [", { name: '".concat(generatedName, "' }")]
                }]);
              }
            }, function (_ref9) {
              var _getProp2, _getProp2$value, _specOrPolicy$props;

              var _ref10 = _slicedToArray(_ref9, 2),
                  specOrPolicy = _ref10[0],
                  node = _ref10[1];

              var subNodes = node && ((_getProp2 = getProp(getPropertiesNode(node), "submorphs")) === null || _getProp2 === void 0 ? void 0 : (_getProp2$value = _getProp2.value) === null || _getProp2$value === void 0 ? void 0 : _getProp2$value.elements);

              var subSpecs = _toConsumableArray$1(specOrPolicy.isPolicy ? specOrPolicy.spec.submorphs : ((_specOrPolicy$props = specOrPolicy.props) === null || _specOrPolicy$props === void 0 ? void 0 : _specOrPolicy$props.submorphs) || specOrPolicy.submorphs);

              if (subNodes && subSpecs) {
                var specToNodeMapping = new Map();

                var _iterator6 = _createForOfIteratorHelper(subSpecs),
                    _step6;

                try {
                  var _loop2 = function _loop2() {
                    var spec = _step6.value;

                    if (spec.COMMAND !== "add" && spec.name) {
                      var match = subNodes.find(function (node) {
                        var _getProp3;

                        return ((_getProp3 = getProp(getPropertiesNode(node), "name")) === null || _getProp3 === void 0 ? void 0 : _getProp3.value.value) === spec.name;
                      });

                      if (match) {
                        specToNodeMapping.set(spec, match);
                        remove(subNodes, match);
                        remove(subSpecs, spec);
                      }

                      if (_this3.withinDerivedComponent(_this3.target.getSubmorphNamed(spec.name))) {
                        remove(subSpecs, spec);
                      }
                    }
                  };

                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                    _loop2();
                  }
                } catch (err) {
                  _iterator6.e(err);
                } finally {
                  _iterator6.f();
                }

                var _iterator7 = _createForOfIteratorHelper(subSpecs),
                    _step7;

                try {
                  var _loop3 = function _loop3() {
                    var _spec$props;

                    var spec = _step7.value;

                    if ((_spec$props = spec.props) === null || _spec$props === void 0 ? void 0 : _spec$props.name) {
                      var match = subNodes.find(function (node) {
                        var _getProp4;

                        return ((_getProp4 = getProp(node, "name")) === null || _getProp4 === void 0 ? void 0 : _getProp4.value.value) === spec.props.name;
                      });

                      if (match) {
                        specToNodeMapping.set(spec, match);
                        remove(subNodes, match);
                      }

                      remove(subSpecs, spec);
                    }
                  };

                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                    _loop3();
                  }
                } catch (err) {
                  _iterator7.e(err);
                } finally {
                  _iterator7.f();
                }

                return [].concat(_toConsumableArray$1(specToNodeMapping.entries()), _toConsumableArray$1(zip(subSpecs, subNodes)));
              }

              return null;
            });
            return this;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "EnsureNamesReconciliation";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./components/reconciliation.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 29586,
          end: 33577
        });
      })(__varRecorder__$h.Reconciliation);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/components/reconciliation.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("MorphRemovalReconciliation") && typeof __lively_classholder__.MorphRemovalReconciliation === "function" ? __lively_classholder__.MorphRemovalReconciliation : __lively_classholder__.MorphRemovalReconciliation = function MorphRemovalReconciliation(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function MorphRemovalReconciliation_initialize_(componentDescriptor, change) {
            var _this$descriptor$prev;

            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this, componentDescriptor, change);
            this.policyToSpecAndSubExpressions = ((_this$descriptor$prev = this.descriptor.previouslyRemovedMorphs) === null || _this$descriptor$prev === void 0 ? void 0 : _this$descriptor$prev.get(this.removedMorph)) || new Map();
            return _this;
          }
        }, {
          key: "reconcile",
          value: function MorphRemovalReconciliation_reconcile_() {
            this.descriptor.recordRemovedMorph(this.removedMorph, this.policyToSpecAndSubExpressions);
            this.removeSpec(this.descriptor);
            return this;
          }
        }, {
          key: "removedMorph",
          get: function get() {
            return this.change.args[0];
          }
        }, {
          key: "previousOwner",
          get: function get() {
            return this.target;
          }
        }, {
          key: "isDerived",
          get: function get() {
            return this.withinDerivedComponent(this.target, true);
          }
        }, {
          key: "insertWithoutCall",
          value: function MorphRemovalReconciliation_insertWithoutCall_(interactiveDescriptor) {
            var previousOwner = this.previousOwner,
                removedMorph = this.removedMorph;

            var _this$getDescriptorCo4 = this.getDescriptorContext(interactiveDescriptor),
                modId = _this$getDescriptorCo4.modId,
                sourceCode = _this$getDescriptorCo4.sourceCode,
                parsedComponent = _this$getDescriptorCo4.parsedComponent,
                requiredBindings = _this$getDescriptorCo4.requiredBindings;

            var closestSubmorphsNode = getProp(getMorphNode(parsedComponent, previousOwner), "submorphs");
            var nodeToRemove = closestSubmorphsNode && getNodeFromSubmorphs(closestSubmorphsNode.value, removedMorph.name);
            var removeMorphExpr = {
              __expr__: "without('".concat(removedMorph.name, "')"),
              bindings: _defineProperty({}, COMPONENTS_CORE_MODULE, ["without"])
            };
            requiredBindings.push.apply(requiredBindings, _toConsumableArray$1(Object.entries(removeMorphExpr.bindings)));
            var changes = [];
            var needsLinting = false;

            if (nodeToRemove) {
              changes.push(Object.assign({
                action: "replace"
              }, nodeToRemove, {
                lines: [removeMorphExpr.__expr__]
              }));
            } else {
              __varRecorder__$h.__inter2__ = __varRecorder__$h.insertMorphExpression(parsedComponent, sourceCode, previousOwner, removeMorphExpr), needsLinting = __varRecorder__$h.__inter2__.needsLinting, changes = __varRecorder__$h.__inter2__.changes, __varRecorder__$h.__inter2__;
            }

            var addCallToAdjust = closestSubmorphsNode && getAddCallReferencing(closestSubmorphsNode.value, removedMorph);

            if (addCallToAdjust) {
              var nameToRemove = addCallToAdjust.arguments[1];
              var start = nameToRemove.start;

              while (sourceCode[start] !== ",") {
                start--;
              }

              changes.push({
                action: "remove",
                start: start,
                end: nameToRemove.end
              });
            }

            if (needsLinting) this.modulesToLint.add(modId);
            return changes;
          }
        }, {
          key: "dropSpec",
          value: function MorphRemovalReconciliation_dropSpec_(interactiveDescriptor) {
            var previousOwner = this.previousOwner,
                removedMorph = this.removedMorph;

            var _this$getDescriptorCo5 = this.getDescriptorContext(interactiveDescriptor),
                modId = _this$getDescriptorCo5.modId,
                parsedComponent = _this$getDescriptorCo5.parsedComponent;

            var closestSubmorphsNode = getProp(getMorphNode(parsedComponent, previousOwner), "submorphs");
            var nodeToRemove = closestSubmorphsNode && getNodeFromSubmorphs(closestSubmorphsNode.value, removedMorph.name);
            var removedExpr = nodeToRemove && this.getRemovedExpression(nodeToRemove);
            var changes = [];

            if (nodeToRemove && (closestSubmorphsNode === null || closestSubmorphsNode === void 0 ? void 0 : closestSubmorphsNode.value.elements.length) < 2) {
              this.modulesToLint.add(modId);
              changes.push(Object.assign({
                action: "remove"
              }, __varRecorder__$h.determineNodeToRemoveSubmorphs(closestSubmorphsNode, parsedComponent, previousOwner)));
            } else if (nodeToRemove) {
              changes.push(Object.assign({
                action: "remove"
              }, nodeToRemove));
            }

            return [changes, removedExpr];
          }
        }, {
          key: "applyRemovalToOrigin",
          value: function MorphRemovalReconciliation_applyRemovalToOrigin_(interactiveDescriptor) {
            if (this.removedMorphWasInherited) return [this.insertWithoutCall(interactiveDescriptor)];else return this.dropSpec(interactiveDescriptor);
          }
        }, {
          key: "removedFromOriginalContext",
          get: function get() {
            var meta = this.recoverRemovedMorphMetaIn(this.descriptor);
            return (meta === null || meta === void 0 ? void 0 : meta.wasInherited) && this.previousOwner === meta.previousOwner;
          }
        }, {
          key: "removedMorphWasInherited",
          get: function get() {
            return this.isDerived && (!this.removedMorph.__wasAddedToDerived__ || this.removedFromOriginalContext);
          }
        }, {
          key: "applyRemovalToDependant",
          value: function MorphRemovalReconciliation_applyRemovalToDependant_(interactiveDescriptor) {
            return this.dropSpec(interactiveDescriptor);
          }
        }, {
          key: "getRemovedExpression",
          value: function MorphRemovalReconciliation_getRemovedExpression_(removeExprChange) {
            var subExpr = this.descriptor.getModuleSource().slice(removeExprChange.start, removeExprChange.end);

            try {
              var _parse$body = _slicedToArray(parse$2(subExpr.startsWith("{") ? "(".concat(subExpr, ")") : subExpr).body, 1),
                  exprBody = _parse$body[0];

              if (exprBody.type === "LabeledStatement") {
                var _exprBody$body$expres = _slicedToArray(exprBody.body.expression.elements, 1),
                    removedSpec = _exprBody$body$expres[0];

                subExpr = subExpr.slice(removedSpec.start, removedSpec.end);
              }

              if (subExpr.startsWith("add")) {
                var _exprBody$expression$ = _slicedToArray(exprBody.expression.arguments, 1),
                    _removedSpec = _exprBody$expression$[0];

                subExpr = subExpr.slice(_removedSpec.start, _removedSpec.end);
              }
            } finally {
              return {
                __expr__: subExpr,
                bindings: []
              };
            }
          }
        }, {
          key: "removeSpec",
          value: function MorphRemovalReconciliation_removeSpec_(interactiveDescriptor) {
            var _this4 = this;

            var changes, subExpr;
            var isChangeOrigin = this.isOrigin(interactiveDescriptor);
            var insertWithoutCall = isChangeOrigin && this.removedMorphWasInherited;

            if (isChangeOrigin) {
              var _this$applyRemovalToO = this.applyRemovalToOrigin(interactiveDescriptor);

              var _this$applyRemovalToO2 = _slicedToArray(_this$applyRemovalToO, 2);

              changes = _this$applyRemovalToO2[0];
              subExpr = _this$applyRemovalToO2[1];
            } else {
              var _this$applyRemovalToD = this.applyRemovalToDependant(interactiveDescriptor);

              var _this$applyRemovalToD2 = _slicedToArray(_this$applyRemovalToD, 2);

              changes = _this$applyRemovalToD2[0];
              subExpr = _this$applyRemovalToD2[1];
            }

            var subSpec = interactiveDescriptor.stylePolicy.removeSpecInResponseTo(this.change, insertWithoutCall);
            var activeInstance = interactiveDescriptor._cachedComponent;
            var meta = this.recoverRemovedMorphMetaIn(interactiveDescriptor) || {
              wasInherited: this.removedMorphWasInherited
            };

            if (activeInstance) {
              activeInstance.withMetaDo({
                reconcileChanges: false
              }, function () {
                interactiveDescriptor.stylePolicy.withSubmorphsInScopeDo(activeInstance, function (m) {
                  if (m.name === _this4.removedMorph.name) {
                    m.remove();
                    meta.removedMorph = m;
                  }
                });
              });
            }

            if (!this.removedMorph.__wasAddedToDerived__) meta.previousOwner = this.previousOwner;
            if (subSpec) meta.subSpec = subSpec;
            if (subExpr) meta.subExpr = subExpr;

            if (!isEmpty(meta)) {
              this.policyToSpecAndSubExpressions.set(__varRecorder__$h.exprSerializer.exprStringEncode(interactiveDescriptor.__serialize__()), meta);
            }

            this.addChangesToModule(interactiveDescriptor.moduleName, changes);
            interactiveDescriptor.withDerivedComponentsDo(function (derivedDescr) {
              _this4.removeSpec(derivedDescr);
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "MorphRemovalReconciliation";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./components/reconciliation.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 33866,
          end: 41573
        });
      })(__varRecorder__$h.Reconciliation);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/components/reconciliation.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("MorphIntroductionReconciliation") && typeof __lively_classholder__.MorphIntroductionReconciliation === "function" ? __lively_classholder__.MorphIntroductionReconciliation : __lively_classholder__.MorphIntroductionReconciliation = function MorphIntroductionReconciliation(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "reconcile",
          value: function MorphIntroductionReconciliation_reconcile_() {
            var _this5 = this;

            var descriptor = this.descriptor,
                addedMorph = this.addedMorph;
            this.fixNameCollisions(descriptor, addedMorph);

            if (this.isReintroduction(descriptor)) {
              this.reintroduceMorph(descriptor);
            } else {
              this.addNewMorph(descriptor);
              descriptor.withDerivedComponentsDo(function (derivedDescr) {
                _this5.updateActiveSessionsFor(derivedDescr);
              });
            }

            return this;
          }
        }, {
          key: "adjustNameIfNeeded",
          value: function MorphIntroductionReconciliation_adjustNameIfNeeded_(aMorph, newName) {
            if (newName !== aMorph.name) {
              aMorph.withMetaDo({
                reconcileChanges: false
              }, function () {
                aMorph.name = newName;
              });
            }
          }
        }, {
          key: "fixNameCollisions",
          value: function MorphIntroductionReconciliation_fixNameCollisions_(stylePolicyOrDescriptor, rootMorph) {
            var _this6 = this;

            rootMorph.withAllSubmorphsDoExcluding(function (m) {
              var safeName = stylePolicyOrDescriptor.ensureNoNameCollisionInDerived(m.name);

              if (m.master && m.master !== stylePolicyOrDescriptor) {
                m.withAllSubmorphsDo(function (sub) {
                  if (sub.__wasAddedToDerived__) {
                    _this6.adjustNameIfNeeded(sub, m.master.ensureNoNameCollisionInDerived(sub.name));
                  }
                });
              }

              _this6.adjustNameIfNeeded(m, safeName);
            }, function (m) {
              return m.master;
            });
          }
        }, {
          key: "isDerived",
          get: function get() {
            return this.withinDerivedComponent(this.target, true);
          }
        }, {
          key: "addedMorph",
          get: function get() {
            return this.change.args[0];
          }
        }, {
          key: "newOwner",
          get: function get() {
            return this.target;
          }
        }, {
          key: "nextSibling",
          get: function get() {
            return this.newOwner.submorphs[this.newOwner.submorphs.indexOf(this.addedMorph) + 1];
          }
        }, {
          key: "policyToSpecAndSubExpressions",
          get: function get() {
            var _this$descriptor$prev2;

            return (_this$descriptor$prev2 = this.descriptor.previouslyRemovedMorphs) === null || _this$descriptor$prev2 === void 0 ? void 0 : _this$descriptor$prev2.get(this.addedMorph);
          }
        }, {
          key: "isReintroduction",
          value: function MorphIntroductionReconciliation_isReintroduction_(interactiveDescriptor) {
            if (!this.policyToSpecAndSubExpressions) return false;
            var meta = this.recoverRemovedMorphMetaIn(interactiveDescriptor);
            if (!meta.subExpr) return meta.previousOwner === this.newOwner;
            return true;
          }
        }, {
          key: "generateAddedMorphExpression",
          value: function MorphIntroductionReconciliation_generateAddedMorphExpression_(addedMorph, nextSibling, requiredBindings) {
            var expr = convertToExpression(addedMorph, {
              dropMorphsWithNameOnly: false
            });

            if (addedMorph.master) {
              var _Object$assign;

              var metaInfo = addedMorph.master.parent[Symbol["for"]("lively-module-meta")];
              expr = convertToExpression(addedMorph, {
                exposeMasterRefs: false,
                skipAttributes: [].concat(_toConsumableArray$1(DEFAULT_SKIPPED_ATTRIBUTES), ["type"])
              });
              expr = {
                __expr__: "part(".concat(metaInfo.exportedName, ", ").concat(expr.__expr__, ")"),
                bindings: Object.assign({}, expr.bindings, (_Object$assign = {}, _defineProperty(_Object$assign, COMPONENTS_CORE_MODULE, ["part"]), _defineProperty(_Object$assign, metaInfo.moduleId, [metaInfo.exportedName]), _Object$assign))
              };
            }

            if (this.isDerived) {
              addedMorph.__wasAddedToDerived__ = true;
              expr.__expr__ = "add(".concat(expr.__expr__).concat(nextSibling ? ", \"".concat(nextSibling.name, "\"") : "", ")");
              var b = expr.bindings[COMPONENTS_CORE_MODULE] || [];
              b.push("add");
              expr.bindings[COMPONENTS_CORE_MODULE] = b;
            }

            requiredBindings.push.apply(requiredBindings, _toConsumableArray$1(Object.entries(expr.bindings)));
            return expr;
          }
        }, {
          key: "reintroduceSpec",
          value: function MorphIntroductionReconciliation_reintroduceSpec_(interactiveDescriptor, spec) {
            var insertedSpec = interactiveDescriptor.stylePolicy.ensureSubSpecFor(this.addedMorph);
            Object.assign(insertedSpec, spec);
          }
        }, {
          key: "reintroduceExpression",
          value: function MorphIntroductionReconciliation_reintroduceExpression_(interactiveDescriptor, expr) {
            this.addNewMorph(interactiveDescriptor, expr);
          }
        }, {
          key: "insertMorphInOpenSession",
          value: function MorphIntroductionReconciliation_insertMorphInOpenSession_(interactiveDescriptor, morphToAdd) {
            var _this7 = this;

            var activeInstance = interactiveDescriptor._cachedComponent;
            if (!activeInstance) return;
            activeInstance.withMetaDo({
              reconcileChanges: false
            }, function () {
              interactiveDescriptor.stylePolicy.withSubmorphsInScopeDo(activeInstance, function (m) {
                if (equals(getPathFromMorphToMaster(m), getPathFromMorphToMaster(_this7.newOwner))) {
                  m.addMorph(morphToAdd, _this7.nextSibling ? m.getSubmorphNamed(_this7.nextSibling.name) : null);
                }
              });
            });
          }
        }, {
          key: "clearWithoutCallIfNeeded",
          value: function MorphIntroductionReconciliation_clearWithoutCallIfNeeded_(interactiveDescriptor) {
            var _this$getDescriptorCo6 = this.getDescriptorContext(interactiveDescriptor),
                modId = _this$getDescriptorCo6.modId,
                parsedComponent = _this$getDescriptorCo6.parsedComponent;

            var closestSubmorphsNode = getProp(getMorphNode(parsedComponent, this.newOwner), "submorphs");
            var nodeToRemove;

            if ((closestSubmorphsNode === null || closestSubmorphsNode === void 0 ? void 0 : closestSubmorphsNode.value.elements.length) < 2) {
              this.modulesToLint.add(modId);
              nodeToRemove = __varRecorder__$h.determineNodeToRemoveSubmorphs(closestSubmorphsNode, parsedComponent, this.newOwner.isComponent ? null : this.newOwner);
            } else {
              nodeToRemove = closestSubmorphsNode && getWithoutCall(closestSubmorphsNode.value, this.addedMorph);
            }

            interactiveDescriptor.stylePolicy.removeWithoutCall(this.addedMorph);

            if (nodeToRemove) {
              if (nodeToRemove === getPropertiesNode(parsedComponent)) {
                this.addChangesToModule(modId, Object.assign(Object.assign({
                  action: "replace"
                }, nodeToRemove, {
                  lines: ["{}"]
                })));
              } else {
                this.addChangesToModule(modId, Object.assign({
                  action: "remove"
                }, nodeToRemove));
              }
            }
          }
        }, {
          key: "reintroduceMorph",
          value: function MorphIntroductionReconciliation_reintroduceMorph_(interactiveDescriptor) {
            var _this8 = this;

            var meta = this.recoverRemovedMorphMetaIn(interactiveDescriptor);

            if (meta) {
              var removedSpec = meta.subSpec,
                  removedExpr = meta.subExpr,
                  removedMorph = meta.removedMorph,
                  previousOwner = meta.previousOwner,
                  wasInherited = meta.wasInherited;

              if ((removedSpec === null || removedSpec === void 0 ? void 0 : removedSpec.__wasAddedToDerived__) && previousOwner !== this.newOwner) {
                removedExpr = this.generateAddedMorphExpression(this.addedMorph, this.nextSibling, []);
              }

              if (wasInherited && this.newOwner === previousOwner) {
                this.clearWithoutCallIfNeeded(interactiveDescriptor);
              }

              this.reintroduceSpec(interactiveDescriptor, removedSpec);

              if ((previousOwner !== this.newOwner || !wasInherited) && removedExpr) {
                this.reintroduceExpression(interactiveDescriptor, removedExpr);
              }

              if (removedMorph) {
                this.insertMorphInOpenSession(interactiveDescriptor, removedMorph);
              }
            }

            interactiveDescriptor.withDerivedComponentsDo(function (derivedDescr) {
              _this8.reintroduceMorph(derivedDescr);
            });
          }
        }, {
          key: "addNewMorph",
          value: function MorphIntroductionReconciliation_addNewMorph_(interactiveDescriptor, addedMorphExpr) {
            var newOwner = this.newOwner,
                addedMorph = this.addedMorph,
                nextSibling = this.nextSibling;

            var _this$getDescriptorCo7 = this.getDescriptorContext(interactiveDescriptor),
                modId = _this$getDescriptorCo7.modId,
                parsedComponent = _this$getDescriptorCo7.parsedComponent,
                sourceCode = _this$getDescriptorCo7.sourceCode,
                requiredBindings = _this$getDescriptorCo7.requiredBindings;

            if (!addedMorphExpr) {
              addedMorphExpr = this.generateAddedMorphExpression(addedMorph, nextSibling, requiredBindings);
            }

            var _varRecorder__$inser = __varRecorder__$h.insertMorphExpression(parsedComponent, sourceCode, newOwner, addedMorphExpr, nextSibling),
                changes = _varRecorder__$inser.changes,
                needsLinting = _varRecorder__$inser.needsLinting;

            if (needsLinting) this.modulesToLint.add(modId);
            this.addChangesToModule(modId, changes);
            var policyForScope = interactiveDescriptor.stylePolicy.getSubPolicyFor(addedMorph.owner) || interactiveDescriptor.stylePolicy;

            if (addedMorph.owner.master === interactiveDescriptor.stylePolicy) {
              policyForScope = interactiveDescriptor.stylePolicy;
            }

            var subSpec = policyForScope.ensureSubSpecFor(addedMorph, this.isDerived);
            if (nextSibling) subSpec.before = nextSibling.name;
          }
        }, {
          key: "updateActiveSessionsFor",
          value: function MorphIntroductionReconciliation_updateActiveSessionsFor_(interactiveDescriptor) {
            var _this9 = this;

            this.insertMorphInOpenSession(interactiveDescriptor, this.addedMorph.copy());
            interactiveDescriptor.stylePolicy.ensureSubSpecFor(this.addedMorph);
            interactiveDescriptor.withDerivedComponentsDo(function (derivedDescr) {
              _this9.updateActiveSessionsFor(derivedDescr);
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "MorphIntroductionReconciliation";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./components/reconciliation.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 41783,
          end: 50161
        });
      })(__varRecorder__$h.Reconciliation);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/components/reconciliation.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PropChangeReconciliation") && typeof __lively_classholder__.PropChangeReconciliation === "function" ? __lively_classholder__.PropChangeReconciliation : __lively_classholder__.PropChangeReconciliation = function PropChangeReconciliation(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "newValue",
          get: function get() {
            return this.change.value;
          }
        }, {
          key: "isResizedVertically",
          value: function PropChangeReconciliation_isResizedVertically_(aMorph) {
            var l = aMorph.isLayoutable && aMorph.owner && aMorph.owner.layout;
            return l && l.resizesMorphVertically(aMorph);
          }
        }, {
          key: "isResizedHorizontally",
          value: function PropChangeReconciliation_isResizedHorizontally_(aMorph) {
            var l = aMorph.isLayoutable && aMorph.owner && aMorph.owner.layout;
            return l && l.resizesMorphHorizontally(aMorph);
          }
        }, {
          key: "handleExtentChange",
          value: function PropChangeReconciliation_handleExtentChange_(subSpec, specNode) {
            var newValue = this.newValue,
                target = this.target;
            var changedProp = "extent";
            var deleteWidth = false;
            var deleteHeight = false;
            var valueExpr = this.getExpressionOfValue();

            if (this.isResizedVertically(target)) {
              changedProp = "width";
              valueExpr = String(newValue.x);
              deleteHeight = true;
            }

            if (this.isResizedHorizontally(target)) {
              changedProp = "height";
              valueExpr = String(newValue.y);
              deleteWidth = true;
            }

            if (deleteHeight) {
              this.deletePropIn(specNode, "height");
            }

            if (deleteWidth) {
              this.deletePropIn(specNode, "width");
            }

            if (deleteWidth || deleteHeight) {
              this.deletePropIn(specNode, "extent");
            }

            this.patchPropIn(specNode, changedProp, valueExpr);
            subSpec.extent = newValue;
            return this;
          }
        }, {
          key: "getSubSpecForTarget",
          value: function PropChangeReconciliation_getSubSpecForTarget_() {
            var policy = this.descriptor.stylePolicy;
            if (this.target.master === policy || this.target.isComponent) return policy.spec;
            var scopePolicy = this.getResponsiblePolicyFor(this.target);
            var spec = scopePolicy.getSubSpecFor(this.target.name);
            if (spec.isPolicy) return spec.spec;
            return spec;
          }
        }, {
          key: "getNodeForTargetInSource",
          value: function PropChangeReconciliation_getNodeForTargetInSource_() {
            var interactiveDescriptor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.descriptor;

            var _this$getDescriptorCo8 = this.getDescriptorContext(interactiveDescriptor),
                parsedComponent = _this$getDescriptorCo8.parsedComponent;

            var morphNode = getMorphNode(parsedComponent, this.target);
            return morphNode && getPropertiesNode(morphNode);
          }
        }, {
          key: "patchPropIn",
          value: function PropChangeReconciliation_patchPropIn_(specNode, prop, valueAsExpr) {
            if (!valueAsExpr) return this;

            var _this$getDescriptorCo9 = this.getDescriptorContext(),
                modId = _this$getDescriptorCo9.modId,
                sourceCode = _this$getDescriptorCo9.sourceCode;

            if (valueAsExpr.__expr__) valueAsExpr = valueAsExpr.__expr__;
            var propNode = getProp(specNode, prop);

            if (!propNode) {
              this.modulesToLint.add(modId);
              this.addChangesToModule(modId, __varRecorder__$h.insertPropChange(sourceCode, specNode, prop, valueAsExpr));
              return this;
            }

            var patchPos = propNode.value;
            this.addChangesToModule(modId, [Object.assign({
              action: "replace"
            }, patchPos, {
              lines: [valueAsExpr]
            })]);
            return this;
          }
        }, {
          key: "deletePropIn",
          value: function PropChangeReconciliation_deletePropIn_(subSpec, prop) {
            var eraseIfEmpty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.isDerived;

            var _this$getDescriptorCo10 = this.getDescriptorContext(),
                modId = _this$getDescriptorCo10.modId,
                sourceCode = _this$getDescriptorCo10.sourceCode,
                parsedComponent = _this$getDescriptorCo10.parsedComponent;

            var _varRecorder__$delet = __varRecorder__$h.deleteProp(sourceCode, parsedComponent, subSpec, prop, this.target, eraseIfEmpty),
                changes = _varRecorder__$delet.changes,
                needsLinting = _varRecorder__$delet.needsLinting;

            if (needsLinting) this.modulesToLint.add(modId);
            this.addChangesToModule(modId, changes);
            return this;
          }
        }, {
          key: "getResponsiblePolicyFor",
          value: function PropChangeReconciliation_getResponsiblePolicyFor_(target) {
            var policy = this.descriptor.stylePolicy.getSubPolicyFor(target) || this.descriptor.stylePolicy;
            if (!policy.isPolicy) return this.descriptor.stylePolicy;
            return policy;
          }
        }, {
          key: "propValueDiffersFromParent",
          get: function get() {
            var _this$change2 = this.change,
                target = _this$change2.target,
                prop = _this$change2.prop;
            var policy = this.getResponsiblePolicyFor(target);
            var parent = policy.parent,
                targetMorph = policy.targetMorph;
            var val;

            if (parent) {
              var synthesized = parent.synthesizeSubSpec(target === targetMorph ? null : target.name);
              if (synthesized.isPolicy) synthesized = synthesized.synthesizeSubSpec();
              val = synthesized[prop];
            }

            if (typeof val === "undefined") {
              var _this$getSubSpecForTa = this.getSubSpecForTarget(),
                  type = _this$getSubSpecForTa.type;

              val = getDefaultValueFor(type, prop);
            }

            return !equals(val, this.newValue);
          }
        }, {
          key: "getExpressionOfValue",
          value: function PropChangeReconciliation_getExpressionOfValue_() {
            var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var _this$change3 = this.change,
                target = _this$change3.target,
                prop = _this$change3.prop,
                value = _this$change3.value;

            var _this$getDescriptorCo11 = this.getDescriptorContext(),
                requiredBindings = _this$getDescriptorCo11.requiredBindings;

            var valueAsExpr, members;

            if (members = isFoldableProp(target.constructor, prop)) {
              valueAsExpr = getFoldableValueExpr(prop, value, members, target.ownerChain().length);
            } else {
              valueAsExpr = getValueExpr(prop, value, depth);
            }

            if (valueAsExpr) {
              requiredBindings.push.apply(requiredBindings, _toConsumableArray$1(Object.entries(valueAsExpr.bindings)));
            }

            return valueAsExpr;
          }
        }, {
          key: "handleMasterChange",
          value: function PropChangeReconciliation_handleMasterChange_(subSpec, specNode, depth) {
            var target = this.target,
                newValue = this.newValue;
            var responsiblePolicy = this.getResponsiblePolicyFor(target);

            if (!newValue) {
              if (subSpec === responsiblePolicy.spec) responsiblePolicy.reset();
            }

            if (newValue) {
              if (subSpec === responsiblePolicy.spec) {
                responsiblePolicy.applyConfiguration(newValue);
              } else {
                var parentSpec = responsiblePolicy.getSubSpecCorrespondingTo(target.owner);
                if (parentSpec.isPolicy) parentSpec = parentSpec.spec;
                parentSpec.submorphs[parentSpec.submorphs.indexOf(subSpec)] = PolicyApplicator["for"](target, Object.assign({}, subSpec, {
                  master: newValue
                }));
              }

              if (this.propValueDiffersFromParent) {
                return this.patchPropIn(specNode, "master", this.getExpressionOfValue(depth));
              }
            }

            return this.deletePropIn(specNode, "master");
          }
        }, {
          key: "reconcile",
          value: function PropChangeReconciliation_reconcile_() {
            var _this$change4 = this.change,
                prop = _this$change4.prop;
                _this$change4.target;
            var specNode = this.getNodeForTargetInSource();

            if (prop === "name") {
              throw new Error("Cannot handle renaming in a policy reconciliation, since it consitutes a structural change. Use the RenameReconcilation instead.");
            }

            if (!specNode) {
              if (!this.isDerived) return this;
              return this.uncollapseSubmorphHierarchy();
            }

            var tabSize = 2;
            var indentDepth = specNode.properties.length > 0 ? (specNode.properties[0].start - specNode.start - 2) / tabSize : 1;
            var subSpec = this.getSubSpecForTarget();

            if (prop === "master") {
              return this.handleMasterChange(subSpec, specNode, indentDepth);
            }

            if (prop === "extent") {
              return this.handleExtentChange(subSpec, specNode);
            }

            subSpec[prop] = this.change.value;
            this.propagateChangeAmongActiveEditSessions(this.descriptor);

            if (this.propValueDiffersFromParent) {
              return this.patchPropIn(specNode, prop, this.getExpressionOfValue(indentDepth));
            }

            delete subSpec[prop];
            return this.deletePropIn(specNode, prop);
          }
        }, {
          key: "propagateChangeAmongActiveEditSessions",
          value: function PropChangeReconciliation_propagateChangeAmongActiveEditSessions_(interactiveDescriptor) {
            var _this10 = this;

            var activeInstance;
            interactiveDescriptor.withDerivedComponentsDo(function (descr) {
              if (activeInstance = descr._cachedComponent) {
                activeInstance.withMetaDo({
                  reconcileChanges: false
                }, function () {
                  activeInstance.master.applyIfNeeded(true);
                });
              }

              _this10.propagateChangeAmongActiveEditSessions(descr);
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PropChangeReconciliation";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./components/reconciliation.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 50275,
          end: 58423
        });
      })(__varRecorder__$h.Reconciliation);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/components/reconciliation.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("RenameReconciliation") && typeof __lively_classholder__.RenameReconciliation === "function" ? __lively_classholder__.RenameReconciliation : __lively_classholder__.RenameReconciliation = function RenameReconciliation(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "oldName",
          get: function get() {
            return this.change.prevValue;
          }
        }, {
          key: "newName",
          get: function get() {
            return camelCaseString(this.newValue);
          }
        }, {
          key: "renamedMorph",
          get: function get() {
            return this.change.target;
          }
        }, {
          key: "renameComponent",
          get: function get() {
            return this.target.master === this.descriptor.stylePolicy || this.target.isComponent;
          }
        }, {
          key: "getSubSpecForTarget",
          value: function RenameReconciliation_getSubSpecForTarget_(interactiveDescriptor) {
            return interactiveDescriptor.stylePolicy.getSubSpecFor(this.oldName);
          }
        }, {
          key: "getNodeForTargetInSource",
          value: function RenameReconciliation_getNodeForTargetInSource_(interactiveDescriptor) {
            var _this$getDescriptorCo12 = this.getDescriptorContext(interactiveDescriptor),
                parsedComponent = _this$getDescriptorCo12.parsedComponent;

            var affectedPolicy = getMorphNode(parsedComponent, this.target.owner);
            return getPropertiesNode(affectedPolicy, this.oldName);
          }
        }, {
          key: "handleRenaming",
          value: function RenameReconciliation_handleRenaming_(interactiveDescriptor) {
            var _this11 = this;

            var local = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

            this._backups.push(interactiveDescriptor.ensureComponentDefBackup());

            var subSpec = this.getSubSpecForTarget(interactiveDescriptor);

            if (!local) {
              var _subSpec;

              if ((_subSpec = subSpec) === null || _subSpec === void 0 ? void 0 : _subSpec.__wasAddedToDerived__) subSpec = false;
            }

            if (subSpec) {
              subSpec.name = decamelize(this.newName);
              var specNode = this.getNodeForTargetInSource(interactiveDescriptor);
              if (specNode) this.patchPropIn(specNode, "name", this.getExpressionOfValue());
            }

            this.patchOwnerLayoutIfNeeded(interactiveDescriptor);
            interactiveDescriptor.withDerivedComponentsDo(function (derivedDescr) {
              _this11.handleRenaming(derivedDescr, false);
            });
            return this;
          }
        }, {
          key: "patchOwnerLayoutIfNeeded",
          value: function RenameReconciliation_patchOwnerLayoutIfNeeded_(interactiveDescriptor) {
            var _this$target$owner;

            var _this$getDescriptorCo13 = this.getDescriptorContext(interactiveDescriptor),
                parsedComponent = _this$getDescriptorCo13.parsedComponent;

            var affectedPolicy = getMorphNode(parsedComponent, this.target.owner);
            var parentNode = getPropertiesNode(affectedPolicy, this.target.owner);
            var parentSpec = interactiveDescriptor.stylePolicy.getSubSpecFor(!((_this$target$owner = this.target.owner) === null || _this$target$owner === void 0 ? void 0 : _this$target$owner.isComponent) ? this.target.owner : null);

            if ((parentSpec === null || parentSpec === void 0 ? void 0 : parentSpec.layout) && parentNode) {
              parentSpec.layout.handleRenamingOf(this.oldName, this.newValue);
              this.patchPropIn(parentNode, "layout", parentSpec.layout.__serialize__());
            }
          }
        }, {
          key: "reconcile",
          value: function RenameReconciliation_reconcile_() {
            this._backups = [];

            if (this.withinDerivedComponent(this.renamedMorph)) {
              throw new Error("Cannot rename a morph that has not been introduced in this component! Please rename the morph in the component it originated from.");
            }

            if (this.renameComponent) {
              return this;
            }

            this.handleRenaming(this.descriptor);
            return this;
          }
        }, {
          key: "applyChanges",
          value: function () {
            var _RenameReconciliation_applyChanges_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
              var _this12 = this;

              var _newMorph$Symbol$for, _this$renamedMorph$Sy, _newMorph$Symbol$for2, newMorph, _this$getDescriptorCo14, openEditors, newModId;

              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      _context6.next = 2;
                      return Promise.all(this._backups);

                    case 2:
                      initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "applyChanges", this).call(this);

                      if (!this.renameComponent) {
                        _context6.next = 18;
                        break;
                      }

                      _context6.next = 6;
                      return __varRecorder__$h.renameComponent(this.renamedMorph, this.newName, this.System);

                    case 6:
                      newMorph = _context6.sent;

                      if (this.renamedMorph.world()) {
                        _context6.next = 9;
                        break;
                      }

                      return _context6.abrupt("return");

                    case 9:
                      newMorph.openInWorld();
                      newMorph.position = this.renamedMorph.position;
                      if ($world.halos().find(function (h) {
                        return h.target === _this12.renamedMorph;
                      })) $world.showHaloFor(newMorph);
                      this.renamedMorph.remove();

                      if (!(((_newMorph$Symbol$for = newMorph[Symbol["for"]("lively-module-meta")]) === null || _newMorph$Symbol$for === void 0 ? void 0 : _newMorph$Symbol$for.moduleId) === ((_this$renamedMorph$Sy = this.renamedMorph[Symbol["for"]("lively-module-meta")]) === null || _this$renamedMorph$Sy === void 0 ? void 0 : _this$renamedMorph$Sy.moduleId))) {
                        _context6.next = 15;
                        break;
                      }

                      return _context6.abrupt("return");

                    case 15:
                      _this$getDescriptorCo14 = this.getDescriptorContext(), openEditors = _this$getDescriptorCo14.openEditors;
                      newModId = System.decanonicalize((_newMorph$Symbol$for2 = newMorph[Symbol["for"]("lively-module-meta")]) === null || _newMorph$Symbol$for2 === void 0 ? void 0 : _newMorph$Symbol$for2.moduleId);
                      openEditors.forEach(function (ed) {
                        var browser = ed.owner;
                        browser.searchForModuleAndSelect(newModId);
                      });

                    case 18:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function RenameReconciliation_applyChanges_() {
              return _RenameReconciliation_applyChanges_.apply(this, arguments);
            }

            return RenameReconciliation_applyChanges_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "RenameReconciliation";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./components/reconciliation.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 58756,
          end: 62826
        });
      })(__varRecorder__$h.PropChangeReconciliation);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/components/reconciliation.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("TextChangeReconciliation") && typeof __lively_classholder__.TextChangeReconciliation === "function" ? __lively_classholder__.TextChangeReconciliation : __lively_classholder__.TextChangeReconciliation = function TextChangeReconciliation(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "reconcile",
          value: function TextChangeReconciliation_reconcile_() {
            var textMorph = this.change.target;

            var _this$getDescriptorCo15 = this.getDescriptorContext(),
                requiredBindings = _this$getDescriptorCo15.requiredBindings,
                modId = _this$getDescriptorCo15.modId;

            var specNode = this.getNodeForTargetInSource();
            var styleSpec = this.getSubSpecForTarget();
            styleSpec.textAndAttributes = textMorph.textAndAttributes;

            if (!specNode) {
              this.uncollapseSubmorphHierarchy();
              return this;
            }

            var textAttrsAsExpr = getTextAttributesExpr(textMorph);
            requiredBindings.push.apply(requiredBindings, _toConsumableArray$1(Object.entries(textAttrsAsExpr.bindings)));
            var textStringProp = getProp(specNode, "textString");
            var valueProp = getProp(specNode, "value");
            if (textStringProp || valueProp) this.modulesToLint.add(modId);
            if (textStringProp) this.deletePropIn(specNode, "textString", false);
            if (valueProp) this.deletePropIn(specNode, "value", false);
            this.patchPropIn(specNode, "textAndAttributes", textAttrsAsExpr);
            return this;
          }
        }, {
          key: "getAstNodeAndAttributePositionInRange",
          value: function TextChangeReconciliation_getAstNodeAndAttributePositionInRange_(specNode, pos, textAndAttributes) {
            var textAttrProp = getProp(specNode, "textAndAttributes");
            if (!textAttrProp) return {};
            if (this.target.textAndAttributes.length !== textAndAttributes.length) return {};
            if (this.target.textString.length === 0) return {};
            var attributeStart = 0;
            var j = 0;
            var startIndex = this.target.positionToIndex(pos);

            while (j < textAndAttributes.length && startIndex > attributeStart + textAndAttributes[j].length) {
              attributeStart += textAndAttributes[j].length;
              j += 2;
            }

            var stringNode = textAttrProp.value.elements[j];
            return {
              attributeStart: attributeStart,
              stringNode: stringNode
            };
          }
        }, {
          key: "patchPropIn",
          value: function TextChangeReconciliation_patchPropIn_(specNode, propName, textAttrsAsExpr) {
            var _this13 = this;

            var _this$getDescriptorCo16 = this.getDescriptorContext(),
                modId = _this$getDescriptorCo16.modId;

            var _this$change5 = this.change,
                args = _this$change5.args,
                selector = _this$change5.selector,
                undo = _this$change5.undo,
                meta = _this$change5.meta;
            var prevTextAndAttributes = meta.prevTextAndAttributes;
            delete meta.prevTextAndAttributes;

            var defaultPatch = function defaultPatch() {
              _this13.modulesToLint.add(modId);

              return initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "patchPropIn", _this13).call(_this13, specNode, propName, textAttrsAsExpr);
            };

            if (!args) return defaultPatch();

            if (selector === "replace") {
              var _args7 = _slicedToArray(args, 2),
                  changedRange = _args7[0],
                  attrReplacement = _args7[1];

              changedRange = Range.fromPositions(changedRange.start, changedRange.end);
              var isDeletion = attrReplacement.length === 0 || attrReplacement[0] === "" && attrReplacement[1] === null;
              var isReplacement = !isDeletion && !changedRange.isEmpty() && attrReplacement[0].length > 0;
              var isInsertion = !isDeletion && !isReplacement && attrReplacement[0].length > 0;

              var _this$getAstNodeAndAt = this.getAstNodeAndAttributePositionInRange(specNode, isDeletion ? changedRange.end : changedRange.start, prevTextAndAttributes),
                  attributeStart = _this$getAstNodeAndAt.attributeStart,
                  stringNode = _this$getAstNodeAndAt.stringNode;

              if (!stringNode) return defaultPatch();
              var manipulationStartIndex = this.target.positionToIndex(changedRange.start);

              if (isDeletion) {
                var deletionIndexInSource = stringNode.start + manipulationStartIndex - attributeStart + 1;
                var deletedTextAndAttrs = undo.args[1];

                if (deletedTextAndAttrs.length > 2) {
                  return defaultPatch();
                }

                var lineBreakOffset = (stringNode.value.slice(0, manipulationStartIndex - attributeStart).match(/\n|\"|\'/g) || []).length;
                deletionIndexInSource += lineBreakOffset;
                var deleteCharacters = JSON.stringify(deletedTextAndAttrs[0]).slice(1, -1).replaceAll("'", "\\'").length;
                this.addChangesToModule(modId, [{
                  action: "replace",
                  start: deletionIndexInSource,
                  end: deletionIndexInSource + deleteCharacters,
                  lines: [""]
                }]);
                return this;
              }

              if (isReplacement) {
                return defaultPatch();
              }

              if (isInsertion) {
                var insertionIndexInSource = stringNode.start + manipulationStartIndex - attributeStart + 1;
                var _lineBreakOffset = (stringNode.value.slice(0, manipulationStartIndex - attributeStart).match(/\n|\"|\'/g) || []).length;
                insertionIndexInSource += _lineBreakOffset;
                this.addChangesToModule(modId, [{
                  action: "insert",
                  start: insertionIndexInSource,
                  lines: [JSON.stringify(attrReplacement[0]).slice(1, -1).replaceAll("'", "\\'")]
                }]);
                return this;
              }
            }

            return defaultPatch();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "TextChangeReconciliation";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./components/reconciliation.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 63120,
          end: 68283
        });
      })(__varRecorder__$h.PropChangeReconciliation);

      var reconciliation = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exprSerializer: exprSerializer,
        createInitialComponentDefinition: createInitialComponentDefinition,
        insertMorphChange: insertMorphChange,
        insertPropChange: insertPropChange,
        deleteProp: deleteProp,
        fixUndeclaredVars: fixUndeclaredVars,
        removeComponentDefinition: removeComponentDefinition,
        replaceComponentDefinition: replaceComponentDefinition,
        insertComponentDefinition: insertComponentDefinition,
        canBeRenamed: canBeRenamed,
        renameComponent: renameComponent,
        insertMorphExpression: insertMorphExpression,
        uncollapseSubmorphHierarchy: uncollapseSubmorphHierarchy,
        applyModuleChanges: applyModuleChanges,
        Reconciliation: Reconciliation
      });

      var __varRecorder__$g = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/components/change-tracker.js", __contextModule__);
      var ComponentChangeTracker = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/components/change-tracker.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ComponentChangeTracker") && typeof __lively_classholder__.ComponentChangeTracker === "function" ? __lively_classholder__.ComponentChangeTracker : __lively_classholder__.ComponentChangeTracker = function ComponentChangeTracker(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function ComponentChangeTracker_initialize_(aComponent, descriptor) {
            var S = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : System;
            this.trackedComponent = aComponent;
            this.componentModuleId = aComponent[Symbol["for"]("lively-module-meta")].moduleId;
            this.componentModule = module$2(S, this.componentModuleId);
            this.componentDescriptor = descriptor;
            connect(aComponent, "onSubmorphChange", this, "processChangeInComponent", {
              garbageCollect: true
            });
            connect(aComponent, "onChange", this, "processChangeInComponent", {
              garbageCollect: true
            });
            aComponent._changeTracker = this;
          }
        }, {
          key: "componentPolicy",
          get: function get() {
            return this.componentDescriptor.stylePolicy;
          }
        }, {
          key: "currentModuleSource",
          get: function get() {
            return this.componentModule._source;
          }
        }, {
          key: "whenReady",
          value: function ComponentChangeTracker_whenReady_() {
            return !!this.componentModule.source();
          }
        }, {
          key: "onceChangesProcessed",
          value: function ComponentChangeTracker_onceChangesProcessed_() {
            return this._finishPromise ? this._finishPromise.promise : Promise.resolve(true);
          }
        }, {
          key: "equals",
          value: function ComponentChangeTracker_equals_(otherTracker, componentName) {
            return this.componentModuleId === otherTracker.componentModuleId && otherTracker.trackedComponent.name === componentName;
          }
        }, {
          key: "isPositionedByLayout",
          value: function ComponentChangeTracker_isPositionedByLayout_(aMorph) {
            var _l$name, _aMorph$owner, _aMorph$owner$textAnd;

            var l = aMorph.isLayoutable && aMorph.owner && aMorph.owner.layout;
            if ((l === null || l === void 0 ? void 0 : (_l$name = l.name) === null || _l$name === void 0 ? void 0 : _l$name.call()) === "Constraint") return false;
            if ((_aMorph$owner = aMorph.owner) === null || _aMorph$owner === void 0 ? void 0 : (_aMorph$owner$textAnd = _aMorph$owner.textAndAttributes) === null || _aMorph$owner$textAnd === void 0 ? void 0 : _aMorph$owner$textAnd.includes(aMorph)) return true;
            return l && l.layoutableSubmorphs.includes(aMorph);
          }
        }, {
          key: "ignoreChange",
          value: function ComponentChangeTracker_ignoreChange_(change) {
            var _change$meta, _change$prop, _change$target$textAn;

            if (!((_change$meta = change.meta) === null || _change$meta === void 0 ? void 0 : _change$meta.reconcileChanges)) return true;
            if (change.prop === "name") return false;
            if ((_change$prop = change.prop) === null || _change$prop === void 0 ? void 0 : _change$prop.startsWith("_")) return true;
            if (change.prop === "position" && (change.target === this.trackedComponent || this.isPositionedByLayout(change.target))) return true;
            if (change.prop && change.prop !== "textAndAttributes" && change.prop !== "vertices" && change.prop !== "master" && !change.target.styleProperties.includes(change.prop)) return true;
            if (change.target.epiMorph) return true;
            if (["addMorphAt", "removeMorph"].includes(change.selector) && change.args.some(function (m) {
              return m.epiMorph;
            })) return true;
            if (!["addMorphAt", "removeMorph"].includes(change.selector) && change.meta && change.meta.isLayoutAction) return true;
            if (change.selector === "addMorphAt" && ((_change$target$textAn = change.target.textAndAttributes) === null || _change$target$textAn === void 0 ? void 0 : _change$target$textAn.includes(change.args[0]))) return true;
            if (!change.selector && change.prop !== "layout" && change.prop !== "vertices" && equals(change.prevValue, change.value)) return true;
            return false;
          }
        }, {
          key: "adjournChange",
          value: function ComponentChangeTracker_adjournChange_(change) {
            var isReplaceChange = change.selector === "replace";
            if (!isReplaceChange) return false;
            var insertsMorph = change.args[1].find(function (m) {
              return m === null || m === void 0 ? void 0 : m.isMorph;
            });
            var removesMorph = change.undo.args[1].find(function (m) {
              return m === null || m === void 0 ? void 0 : m.isMorph;
            });
            return !insertsMorph && !removesMorph;
          }
        }, {
          key: "processChangeInComponent",
          value: function () {
            var _ComponentChangeTracker_processChangeInComponent_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(change) {
              var _this = this;

              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (!this.ignoreChange(change)) {
                        _context.next = 2;
                        break;
                      }

                      return _context.abrupt("return");

                    case 2:
                      this._finishPromise = deferred();
                      Promise.resolve(Reconciliation.perform(this.componentDescriptor, change)).then(function () {
                        return _this._finishPromise.resolve();
                      });
                      this.componentDescriptor.makeDirty();
                      this.componentDescriptor.refreshDependants();

                    case 6:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function ComponentChangeTracker_processChangeInComponent_(_x) {
              return _ComponentChangeTracker_processChangeInComponent_.apply(this, arguments);
            }

            return ComponentChangeTracker_processChangeInComponent_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ComponentChangeTracker";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./components/change-tracker.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 606,
          end: 6033
        });
      }(undefined);
      __varRecorder__$g.ComponentChangeTracker = ComponentChangeTracker;
      __varRecorder__$g.ComponentChangeTracker = ComponentChangeTracker;

      var __varRecorder__$f = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/components/editor.js", __contextModule__);
      __varRecorder__$f.metaSymbol = Symbol["for"]("lively-module-meta");
      __varRecorder__$f.exprSerializer = new ExpressionSerializer();
      var InteractiveComponentDescriptor = exports('I', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/components/editor.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("InteractiveComponentDescriptor") && typeof __lively_classholder__.InteractiveComponentDescriptor === "function" ? __lively_classholder__.InteractiveComponentDescriptor : __lively_classholder__.InteractiveComponentDescriptor = function InteractiveComponentDescriptor(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "moduleName",
          get: function get() {
            return this[__varRecorder__$f.metaSymbol].moduleId;
          }
        }, {
          key: "targetModule",
          get: function get() {
            return module$2(this.System, this.moduleName);
          }
        }, {
          key: "componentName",
          get: function get() {
            return this[__varRecorder__$f.metaSymbol].exportedName;
          }
        }, {
          key: "isInteractive",
          get: function get() {
            return true;
          }
        }, {
          key: "isScoped",
          get: function get() {
            return !!this[__varRecorder__$f.metaSymbol].path;
          }
        }, {
          key: "init",
          value: function InteractiveComponentDescriptor_init_(generatorFunctionOrInlinePolicy) {
            var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
              moduleId: {
                url: {
                  pathInPackage: function pathInPackage() {
                    return "./components/editor.js";
                  },
                  unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
                    return function () {};
                  },
                  subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
                    return function () {};
                  },
                  "package": function _package() {
                    return {
                      name: "lively.ide",
                      version: "0.1.0"
                    };
                  }
                }.id
              }.url
            };

            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "init", this).call(this, generatorFunctionOrInlinePolicy, meta);

            this.subscribeToParent();
            this.refreshDependants();
            this.previouslyRemovedMorphs = new WeakMap();
            this.checkForGeneratedNames();
            return this;
          }
        }, {
          key: "ensureNamesInSourceCode",
          value: function InteractiveComponentDescriptor_ensureNamesInSourceCode_() {
            if (this._hasGeneratedNames) {
              this._hasGeneratedNames = false;
              Reconciliation.ensureNamesInSourceCode(this);
            }
          }
        }, {
          key: "checkForGeneratedNames",
          value: function InteractiveComponentDescriptor_checkForGeneratedNames_() {
            var _morph$usedNames, _morph$usedNames2;

            this._hasGeneratedNames = ((_morph$usedNames = morph.usedNames) === null || _morph$usedNames === void 0 ? void 0 : _morph$usedNames.size) > ((_morph$usedNames2 = morph.usedNames) === null || _morph$usedNames2 === void 0 ? void 0 : _morph$usedNames2.initialSize);
          }
        }, {
          key: "getModuleSource",
          value: function InteractiveComponentDescriptor_getModuleSource_() {
            return this.targetModule._source;
          }
        }, {
          key: "getASTNode",
          value: function InteractiveComponentDescriptor_getASTNode_() {
            var sourceCode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.moduleSource;
            if (isString$3(sourceCode)) sourceCode = parse$2(sourceCode);
            return getComponentNode(sourceCode, this.componentName);
          }
        }, {
          key: "recordRemovedMorph",
          value: function InteractiveComponentDescriptor_recordRemovedMorph_(removedMorph, meta) {
            var _this = this;

            this.previouslyRemovedMorphs.set(removedMorph, meta);
            once$1(removedMorph, "removeMorph", function () {
              _this.previouslyRemovedMorphs["delete"](removedMorph);
            });
          }
        }, {
          key: "getComponentMorph",
          value: function InteractiveComponentDescriptor_getComponentMorph_() {
            var alive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var c = this._cachedComponent;
            if (c) return c;
            c = morph(this.stylePolicy.asBuildSpec(true));
            c.hasFixedPosition = false;
            c[__varRecorder__$f.metaSymbol] = this[__varRecorder__$f.metaSymbol];
            c.isComponent = true;
            c._context = $world;
            alive && withAllViewModelsDo(c, function (m) {
              return m.viewModel.attach(m);
            });
            c.name = decamelize(this.componentName);
            return this._cachedComponent = c;
          }
        }, {
          key: "ensureComponentMorphUpToDate",
          value: function InteractiveComponentDescriptor_ensureComponentMorphUpToDate_(c) {
            if (c === null || c === void 0 ? void 0 : c.world()) {
              var sceneGraph = c.world().sceneGraph;
              var pos = c.position;
              var prevOwner = c.owner;
              c.remove();
              if (sceneGraph) sceneGraph.refresh();
              var updatedComponentMorph = prevOwner.addMorph(this.getComponentMorph());
              updatedComponentMorph.position = pos;

              if (!updatedComponentMorph._changeTracker) {
                new ComponentChangeTracker(updatedComponentMorph, this);
              }
            }
          }
        }, {
          key: "ensureComponentDefBackup",
          value: function () {
            var _InteractiveComponentDescriptor_ensureComponentDefBackup_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var _this$__varRecorder__, exportedName, source, _findComponentDef, start, end;

              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (!this._backupComponentDef) {
                        _context.next = 2;
                        break;
                      }

                      return _context.abrupt("return");

                    case 2:
                      _this$__varRecorder__ = this[__varRecorder__$f.metaSymbol], exportedName = _this$__varRecorder__.exportedName;
                      _context.next = 5;
                      return this.targetModule.source();

                    case 5:
                      source = _context.sent;
                      _context.t0 = findComponentDef;
                      _context.next = 9;
                      return this.targetModule.ast();

                    case 9:
                      _context.t1 = _context.sent;
                      _context.t2 = exportedName;
                      _findComponentDef = (0, _context.t0)(_context.t1, _context.t2);
                      start = _findComponentDef.start;
                      end = _findComponentDef.end;
                      this._backupComponentDef = source.slice(start, end);

                    case 15:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function InteractiveComponentDescriptor_ensureComponentDefBackup_() {
              return _InteractiveComponentDescriptor_ensureComponentDefBackup_.apply(this, arguments);
            }

            return InteractiveComponentDescriptor_ensureComponentDefBackup_;
          }()
        }, {
          key: "reset",
          value: function () {
            var _InteractiveComponentDescriptor_reset_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
              var dependants;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      dependants = this.stylePolicy._dependants;

                      if (!this._backupComponentDef) {
                        _context3.next = 4;
                        break;
                      }

                      _context3.next = 4;
                      return replaceComponentDefinition(this._backupComponentDef, this.componentName, this.targetModule);

                    case 4:
                      delete this._backupComponentDef;
                      this._dirty = false;
                      this.stylePolicy._dependants = dependants;
                      _context3.next = 9;
                      return this.withDerivedComponentsDo( /*#__PURE__*/function () {
                        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(cb) {
                          return regeneratorRuntime.wrap(function _callee2$(_context2) {
                            while (1) {
                              switch (_context2.prev = _context2.next) {
                                case 0:
                                  _context2.next = 2;
                                  return cb.reset();

                                case 2:
                                case "end":
                                  return _context2.stop();
                              }
                            }
                          }, _callee2);
                        }));

                        return function (_x) {
                          return _ref.apply(this, arguments);
                        };
                      }());

                    case 9:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function InteractiveComponentDescriptor_reset_() {
              return _InteractiveComponentDescriptor_reset_.apply(this, arguments);
            }

            return InteractiveComponentDescriptor_reset_;
          }()
        }, {
          key: "edit",
          value: function () {
            var _InteractiveComponentDescriptor_edit_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
              var alive,
                  c,
                  _args4 = arguments;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      alive = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : false;
                      c = this.getComponentMorph(alive);
                      this.ensureComponentDefBackup();

                      if (!c._changeTracker) {
                        new ComponentChangeTracker(c, this);
                      }

                      _context4.next = 6;
                      return c._changeTracker.whenReady();

                    case 6:
                      _context4.t0 = _context4.sent;

                      if (!_context4.t0) {
                        _context4.next = 9;
                        break;
                      }

                      _context4.t0 = c;

                    case 9:
                      return _context4.abrupt("return", _context4.t0);

                    case 10:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function InteractiveComponentDescriptor_edit_() {
              return _InteractiveComponentDescriptor_edit_.apply(this, arguments);
            }

            return InteractiveComponentDescriptor_edit_;
          }()
        }, {
          key: "stopEditSession",
          value: function InteractiveComponentDescriptor_stopEditSession_() {
            this._backupComponentDef = null;
            this._cachedComponent = null;
          }
        }, {
          key: "subscribeToParent",
          value: function InteractiveComponentDescriptor_subscribeToParent_() {
            var parent = this.stylePolicy.parent;

            if (parent) {
              var dependants = parent._dependants || new Set();
              dependants.add(__varRecorder__$f.exprSerializer.exprStringEncode(this.stylePolicy.__serialize__({
                expressionSerializer: __varRecorder__$f.exprSerializer
              })));
              parent._dependants = dependants;
            }
          }
        }, {
          key: "getDependants",
          value: function InteractiveComponentDescriptor_getDependants_() {
            var _this2 = this;

            var immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            return $world.withAllSubmorphsSelect(function (m) {
              var _m$master;

              return (_m$master = m.master) === null || _m$master === void 0 ? void 0 : _m$master.uses(_this2.stylePolicy, immediate);
            });
          }
        }, {
          key: "refreshDependants",
          value: function InteractiveComponentDescriptor_refreshDependants_() {
            var dependants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDependants();
            dependants.forEach(function (m) {
              var _m$master2;

              return (_m$master2 = m.master) === null || _m$master2 === void 0 ? void 0 : _m$master2.applyIfNeeded(true);
            });
          }
        }, {
          key: "withDerivedComponentsDo",
          value: function () {
            var _InteractiveComponentDescriptor_withDerivedComponentsDo_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(cb) {
              var _i, _arr, _policyOrDescr$__varR, _policyOrDescr$__varR2, expr, policyOrDescr, descr;

              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      if (this.stylePolicy._dependants) {
                        _context5.next = 2;
                        break;
                      }

                      return _context5.abrupt("return");

                    case 2:
                      _i = 0, _arr = _toConsumableArray$1(this.stylePolicy._dependants.values());

                    case 3:
                      if (!(_i < _arr.length)) {
                        _context5.next = 14;
                        break;
                      }

                      expr = _arr[_i];
                      policyOrDescr = __varRecorder__$f.exprSerializer.deserializeExpr(expr);
                      descr = void 0;

                      if (((_policyOrDescr$__varR = policyOrDescr[__varRecorder__$f.metaSymbol]) === null || _policyOrDescr$__varR === void 0 ? void 0 : (_policyOrDescr$__varR2 = _policyOrDescr$__varR.path) === null || _policyOrDescr$__varR2 === void 0 ? void 0 : _policyOrDescr$__varR2.length) > 0) {
                        descr = module$2(this.System, policyOrDescr[__varRecorder__$f.metaSymbol].moduleId).recorder[policyOrDescr[__varRecorder__$f.metaSymbol].exportedName];
                      } else descr = policyOrDescr;

                      if (!descr) {
                        _context5.next = 11;
                        break;
                      }

                      _context5.next = 11;
                      return cb(__varRecorder__$f.InteractiveComponentDescriptor.ensureInteractive(descr));

                    case 11:
                      _i++;
                      _context5.next = 3;
                      break;

                    case 14:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function InteractiveComponentDescriptor_withDerivedComponentsDo_(_x2) {
              return _InteractiveComponentDescriptor_withDerivedComponentsDo_.apply(this, arguments);
            }

            return InteractiveComponentDescriptor_withDerivedComponentsDo_;
          }()
        }, {
          key: "ensureNoNameCollisionInDerived",
          value: function InteractiveComponentDescriptor_ensureNoNameCollisionInDerived_(nameCandidate) {
            var skip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            return this.stylePolicy.ensureNoNameCollisionInDerived(nameCandidate, this, skip);
          }
        }, {
          key: "getSourceCode",
          value: function InteractiveComponentDescriptor_getSourceCode_() {
            this._cachedComponent = null;
            return System.lint(createInitialComponentDefinition(this.getComponentMorph()))[0];
          }
        }, {
          key: "makeDirty",
          value: function InteractiveComponentDescriptor_makeDirty_() {
            this.ensureComponentDefBackup();
            this._dirty = true;
          }
        }, {
          key: "isDirty",
          value: function InteractiveComponentDescriptor_isDirty_() {
            return this._dirty;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "InteractiveComponentDescriptor";
          }
        }, {
          key: "prepareUsedNamesSet",
          value: function InteractiveComponentDescriptor_prepareUsedNamesSet_(generatorFunction) {
            var usedNames = new Set(scanForNamesInGenerator(generatorFunction));
            usedNames.initialSize = usedNames.size;
            return usedNames;
          }
        }, {
          key: "for",
          value: function InteractiveComponentDescriptor_for_(generatorFunction, meta, system, recorder, declaredName) {
            var newDescr = initializeClass._get(Object.getPrototypeOf(__lively_class__), "for", this).call(this, generatorFunction, meta, system);

            if (recorder === null || recorder === void 0 ? void 0 : recorder.__revived__) {
              return newDescr;
            }

            var prev = recorder === null || recorder === void 0 ? void 0 : recorder[declaredName];

            if ((prev === null || prev === void 0 ? void 0 : prev.isComponentDescriptor) && !(recorder === null || recorder === void 0 ? void 0 : recorder.__module_hash__)) {
              if (prev.constructor !== this) {
                adoptObject(prev, this);
              }

              var dependants = prev.getDependants(true);
              prev.stylePolicy = newDescr.stylePolicy;
              var c;

              if (c = prev._cachedComponent) {
                delete prev._cachedComponent;
                prev.ensureComponentMorphUpToDate(c);
              }

              dependants.forEach(function (m) {
                evalAsSpec(function () {
                  m.master = __varRecorder__$f.exprSerializer.deserializeExprObj(m.master.__serialize__());
                });
              });
              newDescr.refreshDependants(dependants);
              prev.checkForGeneratedNames();
              return prev;
            }

            return newDescr;
          }
        }, {
          key: "ensureInteractive",
          value: function InteractiveComponentDescriptor_ensureInteractive_(descr) {
            if (!this._descriptorCache) {
              this._descriptorCache = new WeakMap();
            }

            if (descr.isPolicy) {
              return this._descriptorCache.get(descr) || this._descriptorCache.set(descr, new __varRecorder__$f.InteractiveComponentDescriptor(descr, descr[__varRecorder__$f.metaSymbol])).get(descr);
            }

            adoptObject(descr, __varRecorder__$f.InteractiveComponentDescriptor);
            if (!descr.previouslyRemovedMorphs) descr.previouslyRemovedMorphs = new WeakMap();
            return descr;
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./components/editor.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 1081,
          end: 10107
        });
      }({
        referencedAs: "ComponentDescriptor",
        value: ComponentDescriptor
      }));
      __varRecorder__$f.InteractiveComponentDescriptor = InteractiveComponentDescriptor;
      __varRecorder__$f.InteractiveComponentDescriptor = InteractiveComponentDescriptor;

      var editor = /*#__PURE__*/Object.freeze({
        __proto__: null,
        InteractiveComponentDescriptor: InteractiveComponentDescriptor
      });

      var __varRecorder__$e = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/browser/index.js", __contextModule__);

      if (!lively.FreezerRuntime) {
        component.DescriptorClass = InteractiveComponentDescriptor;
      }

      __varRecorder__$e.COLORS = {
        js: Color.rgb(46, 204, 113),
        json: Color.rgb(128, 139, 150),
        md: Color.rgb(142, 68, 173),
        css: Color.rgbHex("1D365E"),
        cp: Color.rgbHex("E67E22"),
        html: Color.rgbHex("0091EA")
      };
      var COLORS = exports('h', __varRecorder__$e.COLORS);
      __varRecorder__$e.COLORS = COLORS;
      var PackageControls = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/browser/index.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PackageControls") && typeof __lively_classholder__.PackageControls === "function" ? __lively_classholder__.PackageControls : __lively_classholder__.PackageControls = function PackageControls(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "focusOn",
          value: function PackageControls_focusOn_(browser) {
            this._browser = browser;
          }
        }, {
          key: "onMouseUp",
          value: function PackageControls_onMouseUp_(evt) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onMouseUp", this).call(this, evt);

            switch (evt.targetMorph.name) {
              case "run all pkg tests":
                this._browser.execCommand("run all tests in package");

                break;

              case "add pkg":
                this._browser.execCommand("add package");

                break;

              case "remove pkg":
                this._browser.execCommand("remove package");

                break;
            }
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PackageControls";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/browser/index.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 2200,
          end: 2677
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$e.PackageControls = PackageControls;
      __varRecorder__$e.PackageControls = PackageControls;
      var DirectoryControls = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/browser/index.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DirectoryControls") && typeof __lively_classholder__.DirectoryControls === "function" ? __lively_classholder__.DirectoryControls : __lively_classholder__.DirectoryControls = function DirectoryControls(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "focusOn",
          value: function DirectoryControls_focusOn_(browser, dir) {
            this._browser = browser;
            this._dir = dir;
          }
        }, {
          key: "onMouseUp",
          value: function DirectoryControls_onMouseUp_(evt) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onMouseUp", this).call(this, evt);

            if (evt.targetMorph.name === "remove selected") {
              this.removeSelected();
            }

            if (evt.targetMorph.name === "add file") {
              this.addFile(evt);
            }

            if (evt.targetMorph.name === "add folder") {
              this.addFolder();
            }
          }
        }, {
          key: "addFolder",
          value: function DirectoryControls_addFolder_() {
            this._browser.execCommand("create new folder", {
              dir: this._dir
            });
          }
        }, {
          key: "addFile",
          value: function () {
            var _DirectoryControls_addFile_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(evt) {
              var type, style, menu;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      style = {
                        paddingTop: "4px",
                        fontSize: 14
                      };
                      _context.next = 3;
                      return this.world().openWorldMenu(evt, [{
                        title: "Select file type:"
                      }, {
                        isDivider: true
                      }, [[].concat(_toConsumableArray$1(Icon.textAttribute("js-square", Object.assign({}, style, {
                        fontColor: __varRecorder__$e.COLORS.js,
                        fontWeight: "400"
                      }))), ["  Javascript"]), function () {
                        type = "js";
                      }], [[].concat(_toConsumableArray$1(Icon.textAttribute("shapes", Object.assign({}, style, {
                        fontColor: __varRecorder__$e.COLORS.cp,
                        fontWeight: "900"
                      }))), ["  Component"]), function () {
                        type = "cp.js";
                      }], [[].concat(_toConsumableArray$1(Icon.textAttribute("gear", Object.assign({}, style, {
                        fontColor: __varRecorder__$e.COLORS.json,
                        fontWeight: "900"
                      }))), [" JSON"]), function () {
                        type = "json";
                      }], [[].concat(_toConsumableArray$1(Icon.textAttribute("markdown", Object.assign({}, style, {
                        fontColor: __varRecorder__$e.COLORS.md,
                        fontWeight: "400"
                      }))), [" Markdown"]), function () {
                        type = "md";
                      }]]);

                    case 3:
                      menu = _context.sent;
                      _context.next = 6;
                      return menu.whenFinished();

                    case 6:
                      if (type) {
                        _context.next = 8;
                        break;
                      }

                      return _context.abrupt("return");

                    case 8:
                      this._browser.execCommand("create new module", {
                        dir: this._dir,
                        type: type
                      });

                    case 9:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function DirectoryControls_addFile_(_x) {
              return _DirectoryControls_addFile_.apply(this, arguments);
            }

            return DirectoryControls_addFile_;
          }()
        }, {
          key: "removeSelected",
          value: function DirectoryControls_removeSelected_() {
            this._browser.execCommand("remove selected entity", {
              dir: this._dir
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DirectoryControls";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/browser/index.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 2686,
          end: 4388
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$e.DirectoryControls = DirectoryControls;
      __varRecorder__$e.DirectoryControls = DirectoryControls;
      var PackageTreeData = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/browser/index.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PackageTreeData") && typeof __lively_classholder__.PackageTreeData === "function" ? __lively_classholder__.PackageTreeData : __lively_classholder__.PackageTreeData = function PackageTreeData(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function PackageTreeData_initialize_(root) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var _this;

            var _opts$showPkgVersion = opts.showPkgVersion,
                showPkgVersion = _opts$showPkgVersion === void 0 ? false : _opts$showPkgVersion,
                _opts$showDependencyP = opts.showDependencyPackages,
                showDependencyPackages = _opts$showDependencyP === void 0 ? false : _opts$showDependencyP,
                _opts$showHiddenFolde = opts.showHiddenFolders,
                showHiddenFolders = _opts$showHiddenFolde === void 0 ? false : _opts$showHiddenFolde;
            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this, root);
            this.showPkgVersion = showPkgVersion;
            this.showDependencyPackages = showDependencyPackages;
            this.showHiddenFolders = showHiddenFolders;
            return _this;
          }
        }, {
          key: "columnView",
          get: function get() {
            return this.root.browser.ui.columnView;
          }
        }, {
          key: "systemInterface",
          get: function get() {
            return this.root.browser.systemInterface;
          }
        }, {
          key: "editorPlugin",
          get: function get() {
            return this.root.browser.editorPlugin;
          }
        }, {
          key: "display",
          value: function PackageTreeData_display_(node) {
            var type = node.type,
                pkg = node.pkg,
                isCollapsed = node.isCollapsed,
                isDeclaration = node.isDeclaration,
                name = node.name;

            if (type === "package") {
              return this.displayPackage(pkg);
            } else if (isDeclaration) {
              return this.displayDeclaration(node);
            } else {
              var displayedName;
              var isSelected = this.columnView.isSelected(node);

              switch (type) {
                case "md":
                  displayedName = this.displayMarkdown(name, isSelected);
                  break;

                case "js":
                case "mjs":
                case "cjs":
                  displayedName = this.displayModule(name, isSelected, node.isLoaded);
                  break;

                case "json":
                  displayedName = this.displayJson(name, isSelected);
                  break;

                case "directory":
                  displayedName = this.displayDirectory(name, !isCollapsed);
                  break;

                case "css":
                  displayedName = this.displayCSS(name, isSelected);
                  break;

                case "html":
                  displayedName = this.displayHTML(name, isSelected);
                  break;
              }

              return _toConsumableArray$1(displayedName);
            }
          }
        }, {
          key: "displayDeclaration",
          value: function PackageTreeData_displayDeclaration_(decl) {
            var icon = [];

            switch (decl.type) {
              case "class-class-method":
                icon = ["static ", {}];
                break;

              case "class-instance-method":
              case "function-decl":
                icon = Icon.textAttribute("dice-d6", {
                  paddingLeft: "3px",
                  paddingRight: "3px"
                });
                break;

              case "class-decl":
                icon = Icon.textAttribute("sitemap");
                break;

              case "object-decl":
                icon = Icon.textAttribute("atom", {
                  paddingLeft: "2px",
                  paddingRight: "2px"
                });
                break;

              case "array-decl":
                icon = Icon.textAttribute("list-ol", {
                  paddingLeft: "2px",
                  paddingRight: "2px"
                });
                break;

              case "var-decl":
                icon = Icon.textAttribute("asterisk", {
                  paddingLeft: "2px",
                  paddingRight: "2px"
                });
                break;

              case "class-class-getter":
                icon = Icon.textAttribute("arrow-right", {
                  paddingLeft: "2px",
                  paddingRight: "2px"
                });
                break;

              case "class-instance-getter":
                icon = ["get ", null];
                break;

              case "class-instance-setter":
                icon = ["set ", null];
                break;

              case "describe":
                icon = Icon.textAttribute("vials");
                break;

              case "xdescribe":
                icon = Icon.textAttribute("vials", {
                  opacity: 0.5
                });
                break;

              case "it":
                icon = Icon.textAttribute("vial");
                break;

              case "xit":
                icon = Icon.textAttribute("vial", {
                  opacity: 0.5
                });
                break;

              case "before":
              case "beforeEach":
              case "after":
              case "afterEach":
                icon = Icon.textAttribute("hammer");
                break;
            }

            return [].concat(_toConsumableArray$1(icon), [" " + truncate(decl.name || "[PARSE_ERROR]", 18, "\u2026"), null]);
          }
        }, {
          key: "formatPackageName",
          value: function PackageTreeData_formatPackageName_(pkg) {
            return this.root.browser.formatPackageName(pkg);
          }
        }, {
          key: "displayPackage",
          value: function PackageTreeData_displayPackage_(pkg) {
            var pkgNameString = pkg.name;

            if (pkg.kind === "project") {
              pkgNameString = this.formatPackageName(pkg);
            }

            return [].concat(_toConsumableArray$1(pkg.kind === "project" ? Icon.textAttribute("paintbrush") : Icon.textAttribute("cube")), [" " + truncate(this.showPkgVersion ? "".concat(pkgNameString, "@").concat(pkg.version) : pkgNameString, 26, "\u2026"), {
              fontStyle: pkg.kind === "git" ? "italic" : "normal"
            }, "\t".concat(pkg.kind), {
              paddingTop: "3px",
              opacity: 0.5,
              fontSize: "70%",
              textStyleClasses: ["annotation"]
            }]);
          }
        }, {
          key: "displayDirectory",
          value: function PackageTreeData_displayDirectory_(dir, isOpen) {
            return [].concat(_toConsumableArray$1(Icon.textAttribute(isOpen ? "folder-open" : "folder", {
              fontWeight: "400"
            })), [" " + dir, null]);
          }
        }, {
          key: "displayModule",
          value: function PackageTreeData_displayModule_(mod, isSelected, isLoaded) {
            return [].concat(_toConsumableArray$1(Icon.textAttribute(mod.endsWith(".cp.js") ? "shapes" : "js-square", {
              fontColor: isSelected ? Color.white : mod.endsWith(".cp.js") ? __varRecorder__$e.COLORS.cp : __varRecorder__$e.COLORS.js,
              opacity: isLoaded ? 1 : 0.5,
              fontWeight: mod.endsWith(".cp.js") ? 900 : 400
            })), [" " + truncate(mod, 24, "\u2026"), null]);
          }
        }, {
          key: "displayJson",
          value: function PackageTreeData_displayJson_(json, isSelected) {
            return [].concat(_toConsumableArray$1(Icon.textAttribute("gear", {
              fontColor: isSelected ? Color.white : __varRecorder__$e.COLORS.json,
              fontWeight: "900"
            })), [" " + json, null]);
          }
        }, {
          key: "displayMarkdown",
          value: function PackageTreeData_displayMarkdown_(md, isSelected) {
            return [].concat(_toConsumableArray$1(Icon.textAttribute("markdown", {
              fontColor: isSelected ? Color.white : __varRecorder__$e.COLORS.md
            })), [" " + md, null]);
          }
        }, {
          key: "displayCSS",
          value: function PackageTreeData_displayCSS_(css, isSelected) {
            return [].concat(_toConsumableArray$1(Icon.textAttribute("css3-alt", {
              fontColor: isSelected ? Color.white : __varRecorder__$e.COLORS.css
            })), [" " + css, null]);
          }
        }, {
          key: "displayHTML",
          value: function PackageTreeData_displayHTML_(html, isSelected) {
            return [].concat(_toConsumableArray$1(Icon.textAttribute("file-code", {
              fontColor: isSelected ? Color.white : __varRecorder__$e.COLORS.html,
              fontWeight: "900"
            })), [" " + html + " ", null]);
          }
        }, {
          key: "listModuleScope",
          value: function () {
            var _PackageTreeData_listModuleScope_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(moduleName) {
              var source, parsed;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return this.systemInterface.moduleRead(moduleName);

                    case 2:
                      source = _context2.sent;
                      parsed = fuzzyParse(source);
                      return _context2.abrupt("return", findDecls(parsed).filter(function (ea) {
                        return !ea.parent && ea.name;
                      }).map(function (ea) {
                        ea.isDeclaration = true;
                        ea.isCollapsed = true;
                        return ea;
                      }));

                    case 5:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function PackageTreeData_listModuleScope_(_x2) {
              return _PackageTreeData_listModuleScope_.apply(this, arguments);
            }

            return PackageTreeData_listModuleScope_;
          }()
        }, {
          key: "listJSONScope",
          value: function () {
            var _PackageTreeData_listJSONScope_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(jsonLocation) {
              var targetModule;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      targetModule = "lively.ide/js/browser/tree.js";
                      _context3.next = 3;
                      return module$1(targetModule).revive();

                    case 3:
                      _context3.next = 5;
                      return this.systemInterface.runEval("\n      await listJSONScope('".concat(jsonLocation, "');\n    "), {
                        targetModule: targetModule,
                        ackTimeout: 30 * 1000
                      });

                    case 5:
                      return _context3.abrupt("return", _context3.sent.value);

                    case 6:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function PackageTreeData_listJSONScope_(_x3) {
              return _PackageTreeData_listJSONScope_.apply(this, arguments);
            }

            return PackageTreeData_listJSONScope_;
          }()
        }, {
          key: "listMarkdownHeadings",
          value: function () {
            var _PackageTreeData_listMarkdownHeadings_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(mdFile) {
              var _mdCompiler$parse, headings;

              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      _context4.t0 = mdCompiler;
                      _context4.next = 3;
                      return this.systemInterface.moduleRead(mdFile);

                    case 3:
                      _context4.t1 = _context4.sent;
                      _context4.t2 = {
                        textString: _context4.t1
                      };
                      _mdCompiler$parse = _context4.t0.parse.call(_context4.t0, _context4.t2);
                      headings = _mdCompiler$parse.headings;
                      return _context4.abrupt("return", headings.map(function (heading) {
                        heading.isDeclaration = true;
                        heading.isCollapsed = true;
                        heading.name = heading.string.replace(/^#+\s?/, "");
                        return heading;
                      }));

                    case 8:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function PackageTreeData_listMarkdownHeadings_(_x4) {
              return _PackageTreeData_listMarkdownHeadings_.apply(this, arguments);
            }

            return PackageTreeData_listMarkdownHeadings_;
          }()
        }, {
          key: "listAllPackages",
          value: function () {
            var _PackageTreeData_listAllPackages_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
              var pkgs;
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.next = 2;
                      return this.systemInterface.getPackages();

                    case 2:
                      pkgs = _context5.sent;
                      pkgs = sortBy(pkgs.map(function (pkg) {
                        var kind = "git";
                        if (pkg.url.includes("node_modules")) kind = "dependency";
                        if (pkg.url.startsWith("local")) kind = "local";
                        if (pkg.name.startsWith("lively")) kind = "core";
                        if (pkg.url.includes("projects")) kind = "project";
                        pkg.kind = kind;
                        return {
                          url: pkg.url + (pkg.url.endsWith("/") ? "" : "/"),
                          isCollapsed: true,
                          type: "package",
                          name: pkg.name,
                          tooltip: pkg.name,
                          pkg: pkg
                        };
                      }), function (_ref) {
                        var pkg = _ref.pkg;
                        return {
                          core: 1,
                          local: 2,
                          git: 3,
                          dependency: 4
                        }[pkg.kind];
                      });
                      if (!this.showDependencyPackages) pkgs = pkgs.filter(function (p) {
                        return p.pkg.kind !== "dependency";
                      });
                      pkgs = pkgs.filter(function (p) {
                        var modulesOfPkg = PackageRegistry.ofSystem(System).lookup(p.name).modules();
                        return p.pkg.kind !== "project" || modulesOfPkg.length > 1 || modulesOfPkg.length === 1 && !modulesOfPkg[0].id.endsWith("package.json");
                      });
                      return _context5.abrupt("return", pkgs);

                    case 7:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function PackageTreeData_listAllPackages_() {
              return _PackageTreeData_listAllPackages_.apply(this, arguments);
            }

            return PackageTreeData_listAllPackages_;
          }()
        }, {
          key: "listEditableFilesInPackage",
          value: function () {
            var _PackageTreeData_listEditableFilesInPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(pkg) {
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      _context6.next = 2;
                      return this.listEditableFilesInDir(pkg);

                    case 2:
                      return _context6.abrupt("return", _context6.sent);

                    case 3:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function PackageTreeData_listEditableFilesInPackage_(_x5) {
              return _PackageTreeData_listEditableFilesInPackage_.apply(this, arguments);
            }

            return PackageTreeData_listEditableFilesInPackage_;
          }()
        }, {
          key: "evalInContext",
          value: function () {
            var _PackageTreeData_evalInContext_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(source) {
              var targetModule;
              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      targetModule = "lively.ide/js/browser/tree.js";
                      _context7.next = 3;
                      return module$1(targetModule).revive();

                    case 3:
                      _context7.next = 5;
                      return this.systemInterface.runEval(source, {
                        targetModule: targetModule,
                        ackTimeout: 30 * 1000
                      });

                    case 5:
                      return _context7.abrupt("return", _context7.sent.value);

                    case 6:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7, this);
            }));

            function PackageTreeData_evalInContext_(_x6) {
              return _PackageTreeData_evalInContext_.apply(this, arguments);
            }

            return PackageTreeData_evalInContext_;
          }()
        }, {
          key: "getLoadedModuleUrls",
          value: function () {
            var _PackageTreeData_getLoadedModuleUrls_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(gitIgnoreExists) {
              var selectedPkg, gitignore, gitIgnoreContents, files, loadedModules;
              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      selectedPkg = this.root.subNodes.find(function (pkg) {
                        return !pkg.isCollapsed;
                      });
                      gitignore = [];

                      if (!gitIgnoreExists) {
                        _context8.next = 7;
                        break;
                      }

                      _context8.next = 5;
                      return this.evalInContext("\n        (await resource('".concat(selectedPkg.url, "').join('.gitignore').read())\n    "));

                    case 5:
                      gitIgnoreContents = _context8.sent;

                      if (gitIgnoreContents) {
                        gitignore.push.apply(gitignore, _toConsumableArray$1(gitIgnoreContents.split("\n")));
                      }

                    case 7:
                      _context8.next = 9;
                      return this.systemInterface.resourcesOfPackage(selectedPkg.url, ["node_modules", "build", "assets", "objectdb", ".git"].concat(gitignore));

                    case 9:
                      files = _context8.sent;
                      _context8.next = 12;
                      return this.systemInterface.getPackage(selectedPkg.url);

                    case 12:
                      loadedModules = {};
                      files.forEach(function (file) {
                        loadedModules[file.url] = file;
                      });
                      return _context8.abrupt("return", loadedModules);

                    case 15:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, this);
            }));

            function PackageTreeData_getLoadedModuleUrls_(_x7) {
              return _PackageTreeData_getLoadedModuleUrls_.apply(this, arguments);
            }

            return PackageTreeData_getLoadedModuleUrls_;
          }()
        }, {
          key: "listEditableFilesInDir",
          value: function () {
            var _PackageTreeData_listEditableFilesInDir_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(folderLocation) {
              var _this2 = this;

              var files, gitIgnoreExists, loadedModules;
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      _context9.next = 2;
                      return this.evalInContext("\n      await listEditableFilesInDir('".concat(folderLocation, "');\n    "));

                    case 2:
                      files = _context9.sent;
                      _context9.next = 5;
                      return this.evalInContext("\n      !!(await resource('".concat(folderLocation, "').dirList()).find(f => f.url.includes('").concat(folderLocation + ".gitignore", "'));\n    "));

                    case 5:
                      gitIgnoreExists = _context9.sent;
                      _context9.next = 8;
                      return this.getLoadedModuleUrls(gitIgnoreExists);

                    case 8:
                      loadedModules = _context9.sent;
                      return _context9.abrupt("return", files.map(function (file) {
                        if (!_this2.showHiddenFolders && file.type === "directory" && file.name[0] === ".") return false;
                        Object.assign(file, loadedModules[file.url] || {}, {
                          isDirty: true
                        });
                        return file;
                      }).filter(Boolean));

                    case 10:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, this);
            }));

            function PackageTreeData_listEditableFilesInDir_(_x8) {
              return _PackageTreeData_listEditableFilesInDir_.apply(this, arguments);
            }

            return PackageTreeData_listEditableFilesInDir_;
          }()
        }, {
          key: "isCollapsed",
          value: function PackageTreeData_isCollapsed_(_ref2) {
            var isCollapsed = _ref2.isCollapsed;
            return isCollapsed;
          }
        }, {
          key: "collapse",
          value: function () {
            var _PackageTreeData_collapse_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(node, bool) {
              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      if (!(node === this.root)) {
                        _context10.next = 12;
                        break;
                      }

                      bool = false;
                      _context10.next = 4;
                      return this.listAllPackages();

                    case 4:
                      node.subNodes = _context10.sent;
                      _context10.t0 = node.listControl;

                      if (_context10.t0) {
                        _context10.next = 10;
                        break;
                      }

                      _context10.next = 9;
                      return Promise.resolve().then(function () { return ui_cp$1; }).then(function (b) {
                        return part(b.BrowserPackageControls);
                      });

                    case 9:
                      _context10.t0 = _context10.sent;

                    case 10:
                      node.listControl = _context10.t0;
                      node.listControl.focusOn(this.root.browser);

                    case 12:
                      node.isCollapsed = bool;
                      node.isDirty = true;

                      if (bool) {
                        _context10.next = 56;
                        break;
                      }

                      if (!(node.type === "package")) {
                        _context10.next = 26;
                        break;
                      }

                      _context10.next = 18;
                      return this.listEditableFilesInPackage(node.url);

                    case 18:
                      node.subNodes = _context10.sent;
                      _context10.t1 = node.listControl;

                      if (_context10.t1) {
                        _context10.next = 24;
                        break;
                      }

                      _context10.next = 23;
                      return Promise.resolve().then(function () { return ui_cp$1; }).then(function (b) {
                        return part(b.BrowserDirectoryControls);
                      });

                    case 23:
                      _context10.t1 = _context10.sent;

                    case 24:
                      node.listControl = _context10.t1;
                      node.listControl.focusOn(this.root.browser, node.url);

                    case 26:
                      if (node.children) {
                        node.children.forEach(function (child) {
                          child.isDeclaration = true;
                          child.isCollapsed = true;
                          child.parent = node;
                        });
                        node.subNodes = node.children;
                      }

                      if (!(node.type === "directory")) {
                        _context10.next = 38;
                        break;
                      }

                      _context10.next = 30;
                      return this.listEditableFilesInDir(node.url);

                    case 30:
                      node.subNodes = _context10.sent;
                      _context10.t2 = node.listControl;

                      if (_context10.t2) {
                        _context10.next = 36;
                        break;
                      }

                      _context10.next = 35;
                      return Promise.resolve().then(function () { return ui_cp$1; }).then(function (b) {
                        return part(b.BrowserDirectoryControls);
                      });

                    case 35:
                      _context10.t2 = _context10.sent;

                    case 36:
                      node.listControl = _context10.t2;
                      node.listControl.focusOn(this.root.browser, node.url);

                    case 38:
                      if (!(node.type === "js")) {
                        _context10.next = 42;
                        break;
                      }

                      _context10.next = 41;
                      return this.listModuleScope(node.url);

                    case 41:
                      node.subNodes = _context10.sent;

                    case 42:
                      if (!(node.type === "md")) {
                        _context10.next = 52;
                        break;
                      }

                      _context10.prev = 43;
                      _context10.next = 46;
                      return this.listMarkdownHeadings(node.url);

                    case 46:
                      node.subNodes = _context10.sent;
                      _context10.next = 52;
                      break;

                    case 49:
                      _context10.prev = 49;
                      _context10.t3 = _context10["catch"](43);
                      node.subNodes = [];

                    case 52:
                      if (!(node.type === "json")) {
                        _context10.next = 56;
                        break;
                      }

                      _context10.next = 55;
                      return this.listJSONScope(node.url);

                    case 55:
                      node.subNodes = _context10.sent;

                    case 56:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, this, [[43, 49]]);
            }));

            function PackageTreeData_collapse_(_x9, _x10) {
              return _PackageTreeData_collapse_.apply(this, arguments);
            }

            return PackageTreeData_collapse_;
          }()
        }, {
          key: "getChildren",
          value: function PackageTreeData_getChildren_(parent) {
            var _this3 = this;

            var subNodes = parent.subNodes;
            var result = subNodes || [];
            result && result.forEach(function (n) {
              return _this3.parentMap.set(n, parent);
            });
            return result;
          }
        }, {
          key: "isLeaf",
          value: function PackageTreeData_isLeaf_(_ref3) {
            var type = _ref3.type,
                isDeclaration = _ref3.isDeclaration,
                children = _ref3.children;
            if (isDeclaration) return !children;
            return !["package", "directory", "js", "json", "md"].includes(type);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PackageTreeData";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/browser/index.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 4397,
          end: 16557
        });
      }({
        referencedAs: "TreeData",
        value: TreeData
      });
      __varRecorder__$e.PackageTreeData = PackageTreeData;
      __varRecorder__$e.PackageTreeData = PackageTreeData;
      var CodeDefTreeData = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/browser/index.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("CodeDefTreeData") && typeof __lively_classholder__.CodeDefTreeData === "function" ? __lively_classholder__.CodeDefTreeData : __lively_classholder__.CodeDefTreeData = function CodeDefTreeData(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function CodeDefTreeData_initialize_(defs) {
            var _this;

            defs.forEach(function (ea) {
              return ea.children && (ea.isCollapsed = true);
            });
            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this, {
              name: "root",
              isCollapsed: false,
              children: defs.filter(function (ea) {
                return !ea.parent;
              })
            });
            this.defs = defs;
            return _this;
          }
        }, {
          key: "display",
          value: function CodeDefTreeData_display_(node) {
            var string = String(node.name);
            if (node.type === "class-instance-getter") string = "get " + string;
            if (node.type === "class-instance-setter") string = "set " + string;
            return string;
          }
        }, {
          key: "isLeaf",
          value: function CodeDefTreeData_isLeaf_(node) {
            return !node.children;
          }
        }, {
          key: "isCollapsed",
          value: function CodeDefTreeData_isCollapsed_(node) {
            return node.isCollapsed;
          }
        }, {
          key: "collapse",
          value: function CodeDefTreeData_collapse_(node, bool) {
            node.isCollapsed = bool;
          }
        }, {
          key: "getChildren",
          value: function CodeDefTreeData_getChildren_(node) {
            return this.isLeaf(node) ? null : this.isCollapsed(node) ? [] : node.children;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "CodeDefTreeData";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/browser/index.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 16566,
          end: 17400
        });
      }({
        referencedAs: "TreeData",
        value: TreeData
      });
      __varRecorder__$e.CodeDefTreeData = CodeDefTreeData;
      __varRecorder__$e.CodeDefTreeData = CodeDefTreeData;
      var BrowserModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/browser/index.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("BrowserModel") && typeof __lively_classholder__.BrowserModel === "function" ? __lively_classholder__.BrowserModel : __lively_classholder__.BrowserModel = function BrowserModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "serializeBrowser",
          value: function BrowserModel_serializeBrowser_($serialize) {
            var browserSpec = this.browserSpec();
            var scrollPlaceholder = "__LIVELY-SCROLL-PLACEHOLDER__";
            var interfacePlaceholder = "__LIVELY-INTERFACE-PLACEHOLDER__";
            var stringifiedSpec = browserSpec.map(function (spec) {
              return JSON.stringify(spec, function (key, value) {
                if (key === "systemInterface") return interfacePlaceholder;
                if (key === "scroll") return scrollPlaceholder;
                if (key === "module") return select(value, ["pathInModule", "packageName", "name"]);
                return value;
              }).replace(JSON.stringify(scrollPlaceholder), spec.content.spec.scroll.toString()).replace(JSON.stringify(interfacePlaceholder), "localInterface");
            });
            stringifiedSpec = "[" + stringifiedSpec.join(",") + "]";
            return {
              __expr__: "let b = part(SystemBrowser); b.browserFromConfig(".concat(stringifiedSpec, "); b;"),
              bindings: {
                "lively.morphic": ["part"],
                "lively.ide/js/browser/ui.cp.js": ["SystemBrowser"],
                "lively-system-interface": ["localInterface"],
                "lively.graphics": ["pt"]
              }
            };
          }
        }, {
          key: "ensureColumnViewData",
          value: function () {
            var _BrowserModel_ensureColumnViewData_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
              var columnView;
              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      columnView = this.ui.columnView;

                      if (columnView.treeData) {
                        _context11.next = 4;
                        break;
                      }

                      _context11.next = 4;
                      return columnView.setTreeData(new __varRecorder__$e.PackageTreeData({
                        browser: this
                      }));

                    case 4:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11, this);
            }));

            function BrowserModel_ensureColumnViewData_() {
              return _BrowserModel_ensureColumnViewData_.apply(this, arguments);
            }

            return BrowserModel_ensureColumnViewData_;
          }()
        }, {
          key: "viewDidLoad",
          value: function () {
            var _BrowserModel_viewDidLoad_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
              var ed, s;
              return regeneratorRuntime.wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      this.state = {
                        packageUpdateInProgress: null,
                        moduleUpdateInProgress: null,
                        selectedPackage: null,
                        sourceHash: hashCode(""),
                        moduleChangeWarning: null,
                        isSaving: false,
                        history: {
                          left: [],
                          right: [],
                          navigationInProgress: null
                        }
                      };
                      this.refreshHistoryButtons();
                      this.relayout();
                      this.view.doNotAcceptDropsForThisAndSubmorphs();
                      this.ui.metaInfoText.reset();
                      ed = this.ui.sourceEditor;

                      if (!ed.plugins.length) {
                        ed.addPlugin(new JavaScriptEditorPlugin(config$2.codeEditor.defaultTheme));
                      }

                      if (!this._serializedState) {
                        _context12.next = 12;
                        break;
                      }

                      s = this._serializedState;
                      delete this._serializedState;
                      _context12.next = 12;
                      return this.browse(s);

                    case 12:
                      this.ui.evalBackendButton.target = this.view;
                      new EvalBackendChooser().buildEvalBackendDropdownFor(this, this.ui.evalBackendButton);
                      this.ui.tabs.addTab("Browser Tab", null);
                      this.ui.verticalResizer.movedVerticallyBy(0);

                    case 16:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12, this);
            }));

            function BrowserModel_viewDidLoad_() {
              return _BrowserModel_viewDidLoad_.apply(this, arguments);
            }

            return BrowserModel_viewDidLoad_;
          }()
        }, {
          key: "relayout",
          value: function BrowserModel_relayout_() {
            var _this$ui = this.ui,
                columnView = _this$ui.columnView,
                sourceEditor = _this$ui.sourceEditor,
                headerButtons = _this$ui.headerButtons,
                verticalResizer = _this$ui.verticalResizer,
                smiley = _this$ui.smiley,
                tabs = _this$ui.tabs;
            var view = this.view;
            var headerButtonsVisibleThreshhold = 400;
            var headerButtonsHeight = Math.ceil(headerButtons.height);
            var tabsOffset = tabs.visible ? tabs.height : 0;
            headerButtons.visible = view.width > headerButtonsVisibleThreshhold;

            if (!headerButtons.visible) {
              columnView.top = tabs.visible ? tabs.height : 0;
              if (tabs.visible) tabs.top = 0;
              columnView.height = verticalResizer.top - tabsOffset;
            } else {
              columnView.top = tabs.visible ? headerButtonsHeight + tabs.height : headerButtonsHeight;
              if (tabs.visible) tabs.top = headerButtonsHeight;
              columnView.height = verticalResizer.top - headerButtonsHeight - tabsOffset;
            }

            tabs.applyLayoutIfNeeded();
            smiley.center = sourceEditor.center;
            this.repositionComponentEditButtons();
          }
        }, {
          key: "isBrowser",
          get: function get() {
            return true;
          }
        }, {
          key: "selectedModule",
          get: function get() {
            var _this4 = this;

            return this.ui.columnView.getExpandedPath().find(function (node) {
              return _this4.isModule(node);
            });
          }
        }, {
          key: "selectedModule",
          set: function set(m) {
            var mlist = this.ui.columnView;
            if (!m) mlist.setExpandedPath();else this.selectModuleNamed(typeof m === "string" ? m : m.url || m.id);
          }
        }, {
          key: "selectedPackage",
          get: function get() {
            return this.state && this.state.selectedPackage;
          }
        }, {
          key: "selectedPackage",
          set: function set(p) {
            this.selectPackageNamed(!p ? null : typeof p === "string" ? p : p.url || p.address);
          }
        }, {
          key: "selectedCodeEntity",
          get: function get() {
            var entities = this.ui.columnView.getExpandedPath().filter(function (n) {
              return n.isDeclaration;
            });

            if (entities.length > 1) {
              var _arr$last$children;

              if (((_arr$last$children = last$2(entities).children) === null || _arr$last$children === void 0 ? void 0 : _arr$last$children.length) > 0) {
                return this.determineCodeEntityFromViewPort();
              }

              return entities;
            }

            var entity = last$2(entities);

            if (!entity) {
              return this.determineCodeEntityFromViewPort();
            }

            return entity;
          }
        }, {
          key: "determineCodeEntityFromViewPort",
          value: function BrowserModel_determineCodeEntityFromViewPort_() {
            var defs = this.renderedCodeEntities();
            var yCenter = this.ui.sourceEditor.scroll.y + this.ui.sourceEditor.height / 2;
            var textPos = this.ui.sourceEditor.textPositionFromPoint(pt(0, yCenter));
            var idx = this.ui.sourceEditor.positionToIndex(textPos);
            return min(defs, function (def) {
              return Math.abs(def.node.start - idx);
            });
          }
        }, {
          key: "selectedDirectory",
          get: function get() {
            return this.ui.columnView.getExpandedPath().reverse().find(function (m) {
              return ["package", "directory"].includes(m.type);
            });
          }
        }, {
          key: "isModule",
          value: function BrowserModel_isModule_(node) {
            return node && editableFiles.includes(node.type);
          }
        }, {
          key: "formatPackageName",
          value: function BrowserModel_formatPackageName_(pkg) {
            var ownerAndNameExtraction = pkg.name.match(/([a-zA-Z\d]*)--(.*)/);
            if (!ownerAndNameExtraction) return pkg.name;
            var actualName = ownerAndNameExtraction[2];
            var ownerName = ownerAndNameExtraction[1];
            var allPackages = keys$1(PackageRegistry.ofSystem(System).packageMap);
            var noConflict = allPackages.filter(function (n) {
              return n.endsWith("--" + actualName);
            }).length == 1;
            if (noConflict) return actualName;
            return "".concat(actualName, " by ").concat(ownerName);
          }
        }, {
          key: "resetChangedContentIndicator",
          value: function BrowserModel_resetChangedContentIndicator_() {
            this.state.sourceHash = hashCode(this.ui.sourceEditor.textString);
            this.indicateNoUnsavedChanges();
          }
        }, {
          key: "updateSource",
          value: function BrowserModel_updateSource_(source, cursorPos) {
            var ed = this.ui.sourceEditor;
            source = source.split(objectReplacementChar).join("");
            source = source.replaceAll(/\r\n/g, "\n");

            if (ed.textString !== source) {
              ed.textString = source;
            }

            this.resetChangedContentIndicator();
            this.state.moduleChangeWarning = null;
            if (cursorPos) ed.cursorPosition = cursorPos;
          }
        }, {
          key: "ensureNoEditSessionActive",
          value: function () {
            var _BrowserModel_ensureNoEditSessionActive_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
              var openSessions, plural, proceed;
              return regeneratorRuntime.wrap(function _callee13$(_context13) {
                while (1) {
                  switch (_context13.prev = _context13.next) {
                    case 0:
                      openSessions = this.activeComponentEditSessions();

                      if (!(openSessions.length > 0)) {
                        _context13.next = 10;
                        break;
                      }

                      plural = openSessions.length > 1;
                      _context13.next = 5;
                      return $world.confirm(["Active Component Edit Sessions", {
                        fontWeight: "bold"
                      }, "\nThere" + (plural ? " are " : " is ") + openSessions.length + " active edit session".concat(plural ? "s" : "", " that need").concat(plural ? "" : "s", " to be closed before you can proceed with entering custom code."), {
                        fontWeight: "normal",
                        fontSize: 18
                      }], {
                        requester: this.view
                      });

                    case 5:
                      proceed = _context13.sent;

                      if (proceed) {
                        _context13.next = 8;
                        break;
                      }

                      return _context13.abrupt("return", false);

                    case 8:
                      _context13.next = 10;
                      return Promise.all(openSessions.map(function (m) {
                        return m.terminateEditSession();
                      }));

                    case 10:
                      return _context13.abrupt("return", true);

                    case 11:
                    case "end":
                      return _context13.stop();
                  }
                }
              }, _callee13, this);
            }));

            function BrowserModel_ensureNoEditSessionActive_() {
              return _BrowserModel_ensureNoEditSessionActive_.apply(this, arguments);
            }

            return BrowserModel_ensureNoEditSessionActive_;
          }()
        }, {
          key: "indicateUnsavedChanges",
          value: function () {
            var _BrowserModel_indicateUnsavedChanges_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
              return regeneratorRuntime.wrap(function _callee14$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      this.prohibitKeyboardNavigation();
                      _context14.next = 3;
                      return this.ensureNoEditSessionActive();

                    case 3:
                      if (_context14.sent) {
                        _context14.next = 9;
                        break;
                      }

                      _context14.next = 6;
                      return this.systemInterface.moduleRead(this.state.selectedModule.url);

                    case 6:
                      this.ui.sourceEditor.textString = _context14.sent;
                      this.relayout();
                      return _context14.abrupt("return");

                    case 9:
                      this.hideComponentEditButtons();
                      Object.assign(this.ui.sourceEditor, {
                        padding: Rectangle.inset(2, 60 - 2, 2, 0),
                        border: {
                          width: 2,
                          color: Color.red
                        }
                      });

                    case 11:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee14, this);
            }));

            function BrowserModel_indicateUnsavedChanges_() {
              return _BrowserModel_indicateUnsavedChanges_.apply(this, arguments);
            }

            return BrowserModel_indicateUnsavedChanges_;
          }()
        }, {
          key: "indicateNoUnsavedChanges",
          value: function BrowserModel_indicateNoUnsavedChanges_() {
            this.allowKeyboardNavigation();
            this.showComponentEditButtons();
            Object.assign(this.ui.sourceEditor, {
              padding: Rectangle.inset(4, 60, 4, 0),
              border: {
                width: 0,
                color: Color.transparent
              }
            });
          }
        }, {
          key: "hasUnsavedChanges",
          value: function BrowserModel_hasUnsavedChanges_(compareToSource) {
            var content = this.ui.sourceEditor.textString;
            content = content.split(objectReplacementChar).join("");

            if (compareToSource && content !== compareToSource) {
              return true;
            }

            return this.state.sourceHash !== hashCode(content);
          }
        }, {
          key: "updateUnsavedChangeIndicatorDebounced",
          value: function BrowserModel_updateUnsavedChangeIndicatorDebounced_() {
            var _this5 = this;

            debounceNamed(this.id + "-updateUnsavedChangeIndicatorDebounced", 20, function () {
              return _this5.updateUnsavedChangeIndicator();
            })();
          }
        }, {
          key: "updateUnsavedChangeIndicator",
          value: function BrowserModel_updateUnsavedChangeIndicator_() {
            this[this.hasUnsavedChanges() ? "indicateUnsavedChanges" : "indicateNoUnsavedChanges"]();
          }
        }, {
          key: "updateKeyboardNavigation",
          value: function BrowserModel_updateKeyboardNavigation_() {
            this.view._faderTriggered ? this.prohibitKeyboardNavigation() : this.allowKeyboardNavigation();
          }
        }, {
          key: "prohibitKeyboardNavigation",
          value: function BrowserModel_prohibitKeyboardNavigation_() {
            var cv = this.ui.columnView;
            cv.treeData.listNavigationProhibited = true;
            cv.lists.forEach(function (list) {
              return list.arrowNavigationProhibited = true;
            });
          }
        }, {
          key: "allowKeyboardNavigation",
          value: function BrowserModel_allowKeyboardNavigation_() {
            var cv = this.ui.columnView;
            cv.treeData.listNavigationProhibited = false;
            cv.lists.forEach(function (list) {
              return list.arrowNavigationProhibited = false;
            });
          }
        }, {
          key: "setEvalBackend",
          value: function () {
            var _BrowserModel_setEvalBackend_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(newRemote) {
              var oldSystemInterface;
              return regeneratorRuntime.wrap(function _callee15$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      newRemote = newRemote || "local";
                      oldSystemInterface = this.systemInterface;

                      if (!(newRemote !== oldSystemInterface.name)) {
                        _context15.next = 7;
                        break;
                      }

                      this.editorPlugin.setSystemInterfaceNamed(newRemote);
                      _context15.next = 6;
                      return this.toggleWindowStyle();

                    case 6:
                      this.browse(this.browseSpec());

                    case 7:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee15, this);
            }));

            function BrowserModel_setEvalBackend_(_x11) {
              return _BrowserModel_setEvalBackend_.apply(this, arguments);
            }

            return BrowserModel_setEvalBackend_;
          }()
        }, {
          key: "toggleWindowStyle",
          value: function () {
            var _BrowserModel_toggleWindowStyle_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
              var animated,
                  duration,
                  easing,
                  theme,
                  _this$ui2,
                  columnView,
                  sourceEditor,
                  _args16 = arguments;

              return regeneratorRuntime.wrap(function _callee16$(_context16) {
                while (1) {
                  switch (_context16.prev = _context16.next) {
                    case 0:
                      animated = _args16.length > 0 && _args16[0] !== undefined ? _args16[0] : true;
                      duration = 1000;
                      easing = easings.outExpo;
                      _this$ui2 = this.ui, columnView = _this$ui2.columnView, sourceEditor = _this$ui2.sourceEditor;
                      columnView.reset();
                      _context16.t0 = this.editorPlugin.runEval;

                      if (!_context16.t0) {
                        _context16.next = 10;
                        break;
                      }

                      _context16.next = 9;
                      return this.editorPlugin.runEval("System.get('@system-env').node");

                    case 9:
                      _context16.t0 = _context16.sent.value;

                    case 10:
                      if (!_context16.t0) {
                        _context16.next = 15;
                        break;
                      }

                      theme = DarkTheme.instance;
                      columnView.listMaster = ColumnListDark;
                      _context16.next = 17;
                      break;

                    case 15:
                      theme = DefaultTheme.instance;
                      columnView.listMaster = ColumnListDefault;

                    case 17:
                      this.editorPlugin.theme = theme;

                      if (animated) {
                        sourceEditor.animate({
                          fill: theme.background,
                          duration: duration,
                          easing: easing
                        });
                        columnView.animate({
                          fill: theme.background,
                          duration: duration,
                          easing: easing
                        });
                      } else {
                        sourceEditor.fill = theme.background;
                        columnView.fill = theme.background;
                      }

                      this.editorPlugin.highlight();
                      this.relayout();

                    case 21:
                    case "end":
                      return _context16.stop();
                  }
                }
              }, _callee16, this);
            }));

            function BrowserModel_toggleWindowStyle_() {
              return _BrowserModel_toggleWindowStyle_.apply(this, arguments);
            }

            return BrowserModel_toggleWindowStyle_;
          }()
        }, {
          key: "packageResources",
          value: function () {
            var _BrowserModel_packageResources_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(p) {
              var excluded;
              return regeneratorRuntime.wrap(function _callee17$(_context17) {
                while (1) {
                  switch (_context17.prev = _context17.next) {
                    case 0:
                      excluded = (Path("lively.ide.exclude").get(p) || []).map(function (ea) {
                        return ea.includes("*") ? new RegExp(ea.replace(/\*/g, ".*")) : ea;
                      });
                      excluded.push(".git", "node_modules", ".module_cache", "assets");
                      _context17.prev = 2;
                      _context17.next = 5;
                      return this.systemInterface.resourcesOfPackage(p.address, excluded);

                    case 5:
                      _context17.t0 = function (_ref4) {
                        var url = _ref4.url;
                        return (url.endsWith(".js") || url.endsWith(".json") || url.endsWith(".jsx")) && !excluded.some(function (ex) {
                          return ex instanceof RegExp ? ex.test(url) : url.includes(ex);
                        });
                      };

                      _context17.t1 = function (ea) {
                        ea.name = ea.url;
                        return ea;
                      };

                      return _context17.abrupt("return", _context17.sent.filter(_context17.t0).map(_context17.t1));

                    case 10:
                      _context17.prev = 10;
                      _context17.t2 = _context17["catch"](2);
                      this.view.showError(_context17.t2);
                      return _context17.abrupt("return", []);

                    case 14:
                    case "end":
                      return _context17.stop();
                  }
                }
              }, _callee17, this, [[2, 10]]);
            }));

            function BrowserModel_packageResources_(_x12) {
              return _BrowserModel_packageResources_.apply(this, arguments);
            }

            return BrowserModel_packageResources_;
          }()
        }, {
          key: "showPackageVersionNumber",
          value: function () {
            var _BrowserModel_showPackageVersionNumber_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(bool) {
              var columnView, treeData;
              return regeneratorRuntime.wrap(function _callee18$(_context18) {
                while (1) {
                  switch (_context18.prev = _context18.next) {
                    case 0:
                      columnView = this.ui.columnView;
                      treeData = columnView.treeData;
                      _context18.next = 4;
                      return columnView.setTreeData(new __varRecorder__$e.PackageTreeData({
                        browser: this
                      }, {
                        showPkgVersion: bool,
                        showDependencyPackages: treeData.showDependencyPackages,
                        showHiddenFolders: treeData.showHiddenFolders
                      }));

                    case 4:
                      _context18.next = 6;
                      return this.selectPackageNamed(null, true);

                    case 6:
                    case "end":
                      return _context18.stop();
                  }
                }
              }, _callee18, this);
            }));

            function BrowserModel_showPackageVersionNumber_(_x13) {
              return _BrowserModel_showPackageVersionNumber_.apply(this, arguments);
            }

            return BrowserModel_showPackageVersionNumber_;
          }()
        }, {
          key: "showDependencyPackages",
          value: function () {
            var _BrowserModel_showDependencyPackages_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(bool) {
              var columnView, treeData;
              return regeneratorRuntime.wrap(function _callee19$(_context19) {
                while (1) {
                  switch (_context19.prev = _context19.next) {
                    case 0:
                      columnView = this.ui.columnView;
                      treeData = columnView.treeData;
                      treeData.showDependencyPackages = bool;
                      _context19.next = 5;
                      return columnView.treeData.listAllPackages();

                    case 5:
                      treeData.root.subNodes = _context19.sent;
                      _context19.next = 8;
                      return this.selectPackageNamed(null, true);

                    case 8:
                    case "end":
                      return _context19.stop();
                  }
                }
              }, _callee19, this);
            }));

            function BrowserModel_showDependencyPackages_(_x14) {
              return _BrowserModel_showDependencyPackages_.apply(this, arguments);
            }

            return BrowserModel_showDependencyPackages_;
          }()
        }, {
          key: "showHiddenFolders",
          value: function () {
            var _BrowserModel_showHiddenFolders_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(bool) {
              var columnView, treeData, browseState;
              return regeneratorRuntime.wrap(function _callee20$(_context20) {
                while (1) {
                  switch (_context20.prev = _context20.next) {
                    case 0:
                      columnView = this.ui.columnView;
                      treeData = columnView.treeData;
                      treeData.showHiddenFolders = bool;
                      browseState = this.browseSpec();
                      _context20.next = 6;
                      return columnView.setTreeData(new __varRecorder__$e.PackageTreeData({
                        browser: this
                      }, {
                        showHiddenFolders: bool,
                        showDependencyPackages: treeData.showDependencyPackages
                      }));

                    case 6:
                      _context20.next = 8;
                      return this.browse(browseState);

                    case 8:
                    case "end":
                      return _context20.stop();
                  }
                }
              }, _callee20, this);
            }));

            function BrowserModel_showHiddenFolders_(_x15) {
              return _BrowserModel_showHiddenFolders_.apply(this, arguments);
            }

            return BrowserModel_showHiddenFolders_;
          }()
        }, {
          key: "toggleTextMap",
          value: function BrowserModel_toggleTextMap_(bool) {
            var ed = this.ui.sourceEditor;
            if (!bool) ed.removeTextMap();else {
              ed.showTextMap();
            }
          }
        }, {
          key: "browseSpec",
          value: function BrowserModel_browseSpec_() {
            var codeEntity;

            if (this.selectedCodeEntity) {
              if (Array.isArray(this.selectedCodeEntity)) codeEntity = last$2(this.selectedCodeEntity).name;else codeEntity = this.selectedCodeEntity.name;
            } else codeEntity = null;

            return {
              packageName: this.selectedPackage ? this.selectedPackage.name : "lively.morphic",
              textPosition: this.ui.sourceEditor.selection.start,
              scroll: this.ui.sourceEditor.scroll,
              moduleName: this.selectedModule ? this.selectedModule.nameInPackage : null,
              codeEntity: codeEntity,
              systemInterface: this.systemInterface
            };
          }
        }, {
          key: "browserSpec",
          value: function BrowserModel_browserSpec_() {
            this.ui.tabs.selectedTab.content = {
              config: this.browseSpec(),
              history: this.state.history
            };
            var tabs = this.ui.tabs.tabs;
            var tabsConfig = tabs.map(function (tab) {
              return tab.config;
            });
            return tabsConfig;
          }
        }, {
          key: "browserFromConfig",
          value: function BrowserModel_browserFromConfig_(tabConfigs) {
            var _this6 = this;

            noUpdate(function () {
              _this6.ui.tabs.loadFromConfig(tabConfigs);
            });
            var curr = this.ui.tabs.selectedTab;
            this.state.history = curr.content.history;
            this.refreshHistoryButtons();
            this.browse(curr.content.config);
            return this.view;
          }
        }, {
          key: "browse",
          value: function () {
            var _BrowserModel_browse_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21() {
              var _this$selectedPackage, _this$selectedModule;

              var browseSpec,
                  optSystemInterface,
                  packageName,
                  moduleName,
                  textPosition,
                  codeEntity,
                  scroll,
                  systemInterface,
                  range,
                  sourceEditor,
                  system,
                  m,
                  p,
                  mNameParts,
                  pName,
                  mNameRest,
                  startPos,
                  endPos,
                  _args21 = arguments;
              return regeneratorRuntime.wrap(function _callee21$(_context21) {
                while (1) {
                  switch (_context21.prev = _context21.next) {
                    case 0:
                      browseSpec = _args21.length > 0 && _args21[0] !== undefined ? _args21[0] : {};
                      optSystemInterface = _args21.length > 1 ? _args21[1] : undefined;
                      packageName = browseSpec.packageName, moduleName = browseSpec.moduleName, textPosition = browseSpec.textPosition, codeEntity = browseSpec.codeEntity, scroll = browseSpec.scroll, systemInterface = browseSpec.systemInterface, range = browseSpec.range;

                      if (!(packageName && moduleName && packageName === ((_this$selectedPackage = this.selectedPackage) === null || _this$selectedPackage === void 0 ? void 0 : _this$selectedPackage.name) && moduleName === ((_this$selectedModule = this.selectedModule) === null || _this$selectedModule === void 0 ? void 0 : _this$selectedModule.name))) {
                        _context21.next = 5;
                        break;
                      }

                      return _context21.abrupt("return");

                    case 5:
                      sourceEditor = this.ui.sourceEditor;
                      _context21.next = 8;
                      return this.ensureColumnViewData();

                    case 8:
                      if (!(optSystemInterface || systemInterface)) {
                        _context21.next = 18;
                        break;
                      }

                      _context21.prev = 9;
                      this.systemInterface = optSystemInterface || systemInterface;

                      if (!this.ui.evalBackendList) {
                        _context21.next = 14;
                        break;
                      }

                      _context21.next = 14;
                      return this.ui.evalBackendList.updateFromTarget();

                    case 14:
                      _context21.next = 18;
                      break;

                    case 16:
                      _context21.prev = 16;
                      _context21.t0 = _context21["catch"](9);

                    case 18:
                      _context21.next = 20;
                      return this.toggleWindowStyle(false);

                    case 20:
                      if (!packageName) {
                        _context21.next = 28;
                        break;
                      }

                      _context21.next = 23;
                      return this.selectPackageNamed(packageName);

                    case 23:
                      if (!moduleName) {
                        _context21.next = 26;
                        break;
                      }

                      _context21.next = 26;
                      return this.selectModuleNamed(moduleName, false);

                    case 26:
                      _context21.next = 55;
                      break;

                    case 28:
                      if (!moduleName) {
                        _context21.next = 55;
                        break;
                      }

                      system = this.systemInterface;
                      _context21.next = 32;
                      return system.getModule(moduleName);

                    case 32:
                      m = _context21.sent;

                      if (!m) {
                        _context21.next = 40;
                        break;
                      }

                      moduleName = m.id;
                      _context21.next = 37;
                      return system.getPackageForModule(m.id);

                    case 37:
                      p = _context21.sent;
                      _context21.next = 49;
                      break;

                    case 40:
                      mNameParts = moduleName.split("/");
                      pName = mNameParts.shift();
                      mNameRest = mNameParts.join("/");
                      _context21.next = 45;
                      return system.getPackage(pName);

                    case 45:
                      p = _context21.sent;
                      _context21.next = 48;
                      return system.getModule("".concat(p.url, "/").concat(mNameRest));

                    case 48:
                      m = _context21.sent;

                    case 49:
                      if (!(m && p)) {
                        _context21.next = 55;
                        break;
                      }

                      moduleName = m.id;
                      _context21.next = 53;
                      return this.selectPackageNamed(p.url);

                    case 53:
                      _context21.next = 55;
                      return this.selectModuleNamed(moduleName, false);

                    case 55:
                      this.historyRecord();

                      if (!this.selectedModule) {
                        _context21.next = 59;
                        break;
                      }

                      _context21.next = 59;
                      return this.prepareCodeEditorForModule(this.selectedModule);

                    case 59:
                      if (!(codeEntity && scroll)) {
                        _context21.next = 62;
                        break;
                      }

                      _context21.next = 62;
                      return this.selectCodeEntityInColumnView(codeEntity, false);

                    case 62:
                      if (!(codeEntity && !scroll)) {
                        _context21.next = 65;
                        break;
                      }

                      _context21.next = 65;
                      return this.selectCodeEntity(codeEntity, false);

                    case 65:
                      if (range) {
                        startPos = sourceEditor.indexToPosition(range.start);
                        endPos = sourceEditor.indexToPosition(range.end);
                        sourceEditor.selection = {
                          start: startPos,
                          end: endPos
                        };
                        sourceEditor.centerRange();
                      }

                      if (textPosition) {
                        sourceEditor.cursorPosition = textPosition;
                        sourceEditor.centerRow(textPosition.row);
                        sourceEditor.selectLine(textPosition.row);
                      }

                      if (!scroll) {
                        _context21.next = 72;
                        break;
                      }

                      if (!this.world()) {
                        _context21.next = 71;
                        break;
                      }

                      _context21.next = 71;
                      return delay(10);

                    case 71:
                      sourceEditor.scroll = scroll;

                    case 72:
                      return _context21.abrupt("return", this.view);

                    case 73:
                    case "end":
                      return _context21.stop();
                  }
                }
              }, _callee21, this, [[9, 16]]);
            }));

            function BrowserModel_browse_() {
              return _BrowserModel_browse_.apply(this, arguments);
            }

            return BrowserModel_browse_;
          }()
        }, {
          key: "whenPackageUpdated",
          value: function BrowserModel_whenPackageUpdated_() {
            return this.state.packageUpdateInProgress || Promise.resolve();
          }
        }, {
          key: "whenModuleUpdated",
          value: function BrowserModel_whenModuleUpdated_() {
            this.reactivateEditor();
            return this.state.moduleUpdateInProgress || Promise.resolve();
          }
        }, {
          key: "selectPackageNamed",
          value: function () {
            var _BrowserModel_selectPackageNamed_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(pName) {
              var _this$selectedPackage2;

              var selectPackageNode,
                  p,
                  columnView,
                  td,
                  pNode,
                  _args22 = arguments;
              return regeneratorRuntime.wrap(function _callee22$(_context22) {
                while (1) {
                  switch (_context22.prev = _context22.next) {
                    case 0:
                      selectPackageNode = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : false;
                      pName = pName || "lively.morphic";

                      if (!(((_this$selectedPackage2 = this.selectedPackage) === null || _this$selectedPackage2 === void 0 ? void 0 : _this$selectedPackage2.address) === pName)) {
                        _context22.next = 4;
                        break;
                      }

                      return _context22.abrupt("return");

                    case 4:
                      _context22.next = 6;
                      return this.systemInterface.getPackage(pName);

                    case 6:
                      p = _context22.sent;
                      columnView = this.ui.columnView;
                      td = columnView.treeData;
                      _context22.next = 11;
                      return columnView.setExpandedPath(function (n) {
                        return n === td.root || n.url === p.address + "/";
                      }, td.root, false);

                    case 11:
                      if (!selectPackageNode) {
                        _context22.next = 16;
                        break;
                      }

                      pNode = columnView.treeData.root.subNodes.find(function (_ref5) {
                        var name = _ref5.name;
                        return pName === name;
                      });
                      _context22.next = 15;
                      return columnView.selectNode(pNode);

                    case 15:
                      columnView.submorphs.forEach(function (list) {
                        list.scrollSelectionIntoView();
                      });

                    case 16:
                      _context22.next = 18;
                      return this.onPackageSelected(p);

                    case 18:
                      _context22.next = 20;
                      return this.whenPackageUpdated();

                    case 20:
                      return _context22.abrupt("return", p);

                    case 21:
                    case "end":
                      return _context22.stop();
                  }
                }
              }, _callee22, this);
            }));

            function BrowserModel_selectPackageNamed_(_x16) {
              return _BrowserModel_selectPackageNamed_.apply(this, arguments);
            }

            return BrowserModel_selectPackageNamed_;
          }()
        }, {
          key: "onPackageSelected",
          value: function () {
            var _BrowserModel_onPackageSelected_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(p) {
              var deferred$1, win;
              return regeneratorRuntime.wrap(function _callee23$(_context23) {
                while (1) {
                  switch (_context23.prev = _context23.next) {
                    case 0:
                      this.switchMode("js");
                      this.state.selectedPackage = p;

                      if (!this.state.packageUpdateInProgress) {
                        deferred$1 = deferred();
                        this.state.packageUpdateInProgress = deferred$1.promise;
                      }

                      try {
                        win = this.view.getWindow();

                        if (!p) {
                          this.updateSource("");
                          win.title = "browser";
                        } else {
                          win.title = "browser - " + this.formatPackageName(p);
                          if (!this.ui.tabs.selectedTab.caption.includes(p.name)) this.ui.tabs.selectedTab.caption = p.name;
                        }
                      } finally {
                        if (deferred$1) {
                          this.state.packageUpdateInProgress = null;
                          deferred$1.resolve(p);
                        }
                      }

                    case 4:
                    case "end":
                      return _context23.stop();
                  }
                }
              }, _callee23, this);
            }));

            function BrowserModel_onPackageSelected_(_x17) {
              return _BrowserModel_onPackageSelected_.apply(this, arguments);
            }

            return BrowserModel_onPackageSelected_;
          }()
        }, {
          key: "reviveFrozenModuleIfNeeded",
          value: function () {
            var _BrowserModel_reviveFrozenModuleIfNeeded_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24() {
              var m;
              return regeneratorRuntime.wrap(function _callee24$(_context24) {
                while (1) {
                  switch (_context24.prev = _context24.next) {
                    case 0:
                      _context24.next = 2;
                      return this.systemInterface.getModule(this.selectedModule.url);

                    case 2:
                      m = _context24.sent;

                      if (m) {
                        _context24.next = 5;
                        break;
                      }

                      return _context24.abrupt("return");

                    case 5:
                      if (!m._frozenModule) {
                        _context24.next = 8;
                        break;
                      }

                      _context24.next = 8;
                      return m.revive();

                    case 8:
                    case "end":
                      return _context24.stop();
                  }
                }
              }, _callee24, this);
            }));

            function BrowserModel_reviveFrozenModuleIfNeeded_() {
              return _BrowserModel_reviveFrozenModuleIfNeeded_.apply(this, arguments);
            }

            return BrowserModel_reviveFrozenModuleIfNeeded_;
          }()
        }, {
          key: "updateRecorderIfNeeded",
          value: function () {
            var _BrowserModel_updateRecorderIfNeeded_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25() {
              var m, rec;
              return regeneratorRuntime.wrap(function _callee25$(_context25) {
                while (1) {
                  switch (_context25.prev = _context25.next) {
                    case 0:
                      _context25.next = 2;
                      return this.systemInterface.getModule(this.selectedModule.url);

                    case 2:
                      m = _context25.sent;
                      rec = m.System.get("@lively-env").moduleEnv(m.id).recorder;

                      if (!(rec === null || rec === void 0 ? void 0 : rec.contextModule)) {
                        _context25.next = 7;
                        break;
                      }

                      _context25.next = 7;
                      return m.updateBundledModules([rec.contextModule]);

                    case 7:
                    case "end":
                      return _context25.stop();
                  }
                }
              }, _callee25, this);
            }));

            function BrowserModel_updateRecorderIfNeeded_() {
              return _BrowserModel_updateRecorderIfNeeded_.apply(this, arguments);
            }

            return BrowserModel_updateRecorderIfNeeded_;
          }()
        }, {
          key: "getDisplayedModuleNodes",
          value: function BrowserModel_getDisplayedModuleNodes_() {
            var columnView = this.ui.columnView;
            var moduleLists = columnView.submorphs.filter(function (m) {
              return ["directory", "package"].includes(m._managedNode.type);
            });
            return moduleLists.map(function (list) {
              return list.items.map(function (m) {
                return m.value;
              });
            }).flat();
          }
        }, {
          key: "selectModuleNamed",
          value: function () {
            var _BrowserModel_selectModuleNamed_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(mName) {
              var animated,
                  columnView,
                  m,
                  _this$state$selectedM,
                  system,
                  p,
                  url,
                  _this$state$selectedM2,
                  td,
                  _args26 = arguments;

              return regeneratorRuntime.wrap(function _callee26$(_context26) {
                while (1) {
                  switch (_context26.prev = _context26.next) {
                    case 0:
                      animated = _args26.length > 1 && _args26[1] !== undefined ? _args26[1] : true;
                      columnView = this.ui.columnView;
                      m = this.getDisplayedModuleNodes().find(function (_ref6) {
                        var nameInPackage = _ref6.nameInPackage,
                            url = _ref6.url;
                        return mName === url || mName === nameInPackage;
                      });

                      if (!m) {
                        _context26.next = 10;
                        break;
                      }

                      if (!(((_this$state$selectedM = this.state.selectedModule) === null || _this$state$selectedM === void 0 ? void 0 : _this$state$selectedM.url) === m.url)) {
                        _context26.next = 6;
                        break;
                      }

                      return _context26.abrupt("return");

                    case 6:
                      this.state.selectedModule = {
                        url: m.url
                      };
                      _context26.next = 9;
                      return columnView.selectNode(m, animated);

                    case 9:
                      columnView.submorphs.forEach(function (list) {
                        list.scrollSelectionIntoView();
                      });

                    case 10:
                      if (m) {
                        _context26.next = 39;
                        break;
                      }

                      system = this.systemInterface;
                      p = this.state.selectedPackage;
                      _context26.next = 15;
                      return system.doesModuleExist(mName);

                    case 15:
                      if (!_context26.sent) {
                        _context26.next = 19;
                        break;
                      }

                      if (p && !mName.startsWith(p.url)) {
                        url = p.url + "/" + mName;
                      } else url = mName;

                      _context26.next = 26;
                      break;

                    case 19:
                      _context26.t0 = p;

                      if (!_context26.t0) {
                        _context26.next = 24;
                        break;
                      }

                      _context26.next = 23;
                      return system.doesModuleExist(p.url + "/" + mName, true);

                    case 23:
                      _context26.t0 = _context26.sent;

                    case 24:
                      if (!_context26.t0) {
                        _context26.next = 26;
                        break;
                      }

                      url = p.url + "/" + mName;

                    case 26:
                      if (!url) {
                        _context26.next = 39;
                        break;
                      }

                      if (!(((_this$state$selectedM2 = this.state.selectedModule) === null || _this$state$selectedM2 === void 0 ? void 0 : _this$state$selectedM2.url) === url)) {
                        _context26.next = 29;
                        break;
                      }

                      return _context26.abrupt("return");

                    case 29:
                      this.state.selectedModule = {
                        url: url
                      };
                      td = columnView.treeData;
                      _context26.next = 33;
                      return columnView.setExpandedPath(function (node) {
                        return node === td.root || url.startsWith(node.url);
                      }, td.root, false);

                    case 33:
                      _context26.t1 = this;
                      _context26.next = 36;
                      return this.systemInterface.moduleRead(url);

                    case 36:
                      _context26.t2 = _context26.sent;
                      _context26.t3 = {
                        row: 0,
                        column: 0
                      };

                      _context26.t1.updateSource.call(_context26.t1, _context26.t2, _context26.t3);

                    case 39:
                      this.ui.sourceEditor.undoManager.reset();
                      _context26.next = 42;
                      return this.whenModuleUpdated();

                    case 42:
                      _context26.next = 44;
                      return this.reviveFrozenModuleIfNeeded();

                    case 44:
                      return _context26.abrupt("return", m);

                    case 45:
                    case "end":
                      return _context26.stop();
                  }
                }
              }, _callee26, this);
            }));

            function BrowserModel_selectModuleNamed_(_x18) {
              return _BrowserModel_selectModuleNamed_.apply(this, arguments);
            }

            return BrowserModel_selectModuleNamed_;
          }()
        }, {
          key: "searchForModuleAndSelect",
          value: function () {
            var _BrowserModel_searchForModuleAndSelect_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(moduleURI) {
              var selectedModule, system, mods, m, p;
              return regeneratorRuntime.wrap(function _callee27$(_context27) {
                while (1) {
                  switch (_context27.prev = _context27.next) {
                    case 0:
                      selectedModule = this.selectedModule;

                      if (!(selectedModule && selectedModule.url === moduleURI)) {
                        _context27.next = 3;
                        break;
                      }

                      return _context27.abrupt("return", selectedModule);

                    case 3:
                      system = this.systemInterface;
                      _context27.next = 6;
                      return system.getModules();

                    case 6:
                      mods = _context27.sent;
                      m = mods.find(function (_ref7) {
                        var name = _ref7.name;
                        return name === moduleURI;
                      });
                      _context27.t0 = m;

                      if (!_context27.t0) {
                        _context27.next = 13;
                        break;
                      }

                      _context27.next = 12;
                      return system.getPackageForModule(m.name);

                    case 12:
                      _context27.t0 = _context27.sent;

                    case 13:
                      p = _context27.t0;

                      if (p) {
                        _context27.next = 16;
                        break;
                      }

                      return _context27.abrupt("return", null);

                    case 16:
                      _context27.next = 18;
                      return this.selectPackageNamed(p.address);

                    case 18:
                      _context27.next = 20;
                      return this.selectModuleNamed(m.name);

                    case 20:
                      _context27.next = 22;
                      return this.prepareCodeEditorForModule(this.selectedModule);

                    case 22:
                      return _context27.abrupt("return", this.selectedModule);

                    case 23:
                    case "end":
                      return _context27.stop();
                  }
                }
              }, _callee27, this);
            }));

            function BrowserModel_searchForModuleAndSelect_(_x19) {
              return _BrowserModel_searchForModuleAndSelect_.apply(this, arguments);
            }

            return BrowserModel_searchForModuleAndSelect_;
          }()
        }, {
          key: "warnForUnsavedChanges",
          value: function () {
            var _BrowserModel_warnForUnsavedChanges_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28() {
              return regeneratorRuntime.wrap(function _callee28$(_context28) {
                while (1) {
                  switch (_context28.prev = _context28.next) {
                    case 0:
                      _context28.next = 2;
                      return this.world().confirm(["Discard Changes\n", {}, "The unsaved changes to this module are going to be discarded.\nAre you sure you want to proceed?", {
                        fontSize: 16,
                        fontWeight: "normal"
                      }], {
                        requester: this.view,
                        width: 350
                      });

                    case 2:
                      return _context28.abrupt("return", _context28.sent);

                    case 3:
                    case "end":
                      return _context28.stop();
                  }
                }
              }, _callee28, this);
            }));

            function BrowserModel_warnForUnsavedChanges_() {
              return _BrowserModel_warnForUnsavedChanges_.apply(this, arguments);
            }

            return BrowserModel_warnForUnsavedChanges_;
          }()
        }, {
          key: "loadES6Mocha",
          value: function () {
            var _BrowserModel_loadES6Mocha_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29() {
              var _yield$this$systemInt, isInstalled, pkg;

              return regeneratorRuntime.wrap(function _callee29$(_context29) {
                while (1) {
                  switch (_context29.prev = _context29.next) {
                    case 0:
                      _context29.next = 2;
                      return this.systemInterface.runEval("\n      const g = typeof global !== 'undefined' ? global : window;\n     !!g.Mocha && !!g.chai\n    ", {
                        targetModule: "lively://lively.morphic/browser"
                      });

                    case 2:
                      _yield$this$systemInt = _context29.sent;
                      isInstalled = _yield$this$systemInt.value;

                      if (!isInstalled) {
                        _context29.next = 6;
                        break;
                      }

                      return _context29.abrupt("return");

                    case 6:
                      _context29.next = 8;
                      return this.systemInterface.importPackage("mocha-es6");

                    case 8:
                      pkg = _context29.sent;
                      _context29.next = 11;
                      return this.systemInterface.runEval("\n      const g = typeof global !== 'undefined' ? global : window;\n      const promise = await System.import('lively.lang/promise.js')\n      promise.waitFor(30 * 1000, () =>  !!g.Mocha && !!g.chai);\n    ", {
                        targetModule: "lively://lively.morphic/browser"
                      });

                    case 11:
                      return _context29.abrupt("return", pkg);

                    case 12:
                    case "end":
                      return _context29.stop();
                  }
                }
              }, _callee29, this);
            }));

            function BrowserModel_loadES6Mocha_() {
              return _BrowserModel_loadES6Mocha_.apply(this, arguments);
            }

            return BrowserModel_loadES6Mocha_;
          }()
        }, {
          key: "onListSelectionChange",
          value: function BrowserModel_onListSelectionChange_(selectedPath) {
            var selectedFile = last$2(selectedPath);

            if (this.isModule(selectedFile)) {
              this.ui.sourceEditor.opacity = 1;
              this.ui.sourceEditor.readOnly = false;
              this.onModuleSelected(selectedFile);
            }

            if (selectedFile.type === "package") {
              this.onPackageSelected(selectedFile.pkg);
            }

            if (selectedFile.isDeclaration) {
              this.onCodeEntitySelected(selectedFile);
            }

            if (["directory", "package"].includes(selectedFile.type)) {
              this.state.selectedModule = null;
              this.deactivateEditor();
            }
          }
        }, {
          key: "deactivateEditor",
          value: function BrowserModel_deactivateEditor_() {
            var _this$ui3 = this.ui,
                sourceEditor = _this$ui3.sourceEditor,
                metaInfoText = _this$ui3.metaInfoText;
            sourceEditor.opacity = 0.7;
            sourceEditor.readOnly = true;
            sourceEditor.submorphs = [];
            this.updateSource("");
            metaInfoText.showInactive();
            var selectedPathItems = this.ui.columnView.getExpandedPath();
            selectedPathItems = selectedPathItems.slice(selectedPathItems.findIndex(function (i) {
              return i.type === "package";
            }));
            this.view.getWindow().title = "browser - [".concat(this.formatPackageName(selectedPathItems[0]), "] ").concat(selectedPathItems.slice(1).map(function (i) {
              return i.name;
            }).join("/"));
          }
        }, {
          key: "reactivateEditor",
          value: function BrowserModel_reactivateEditor_() {
            var _this$ui4 = this.ui,
                sourceEditor = _this$ui4.sourceEditor,
                metaInfoText = _this$ui4.metaInfoText;
            sourceEditor.opacity = 1;
            sourceEditor.readOnly = false;
            metaInfoText.showDefault();
          }
        }, {
          key: "onModuleSelected",
          value: function () {
            var _BrowserModel_onModuleSelected_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(m) {
              var cleanupComponents,
                  pack,
                  proceed,
                  deferred$1,
                  system,
                  err,
                  p,
                  isLoadedNow,
                  source,
                  _args30 = arguments;
              return regeneratorRuntime.wrap(function _callee30$(_context30) {
                while (1) {
                  switch (_context30.prev = _context30.next) {
                    case 0:
                      cleanupComponents = _args30.length > 1 && _args30[1] !== undefined ? _args30[1] : true;
                      pack = this.selectedPackage;

                      if (!this._return) {
                        _context30.next = 4;
                        break;
                      }

                      return _context30.abrupt("return");

                    case 4:
                      proceed = true;

                      if (!(this.selectedModule && this.hasUnsavedChanges())) {
                        _context30.next = 9;
                        break;
                      }

                      _context30.next = 8;
                      return this.warnForUnsavedChanges();

                    case 8:
                      proceed = _context30.sent;

                    case 9:
                      if (!(cleanupComponents && proceed)) {
                        _context30.next = 13;
                        break;
                      }

                      _context30.next = 12;
                      return this.cleanupActiveEditSessions();

                    case 12:
                      proceed = _context30.sent;

                    case 13:
                      if (proceed) {
                        _context30.next = 21;
                        break;
                      }

                      this._return = true;
                      _context30.next = 17;
                      return this.state.history.navigationInProgress;

                    case 17:
                      _context30.next = 19;
                      return this.selectModuleNamed(last$2(this.state.history.left).module.url);

                    case 19:
                      this._return = false;
                      return _context30.abrupt("return");

                    case 21:
                      this.state.moduleChangeWarning = null;

                      if (m) {
                        _context30.next = 28;
                        break;
                      }

                      this.updateSource("");
                      if (!this.ui.tabs.selectedTab.caption.includes(pack.name)) this.ui.tabs.selectedTab.caption = pack.name;
                      this.updateCodeEntities(null);
                      this.ui.metaInfoText.textString = "";
                      return _context30.abrupt("return");

                    case 28:
                      if (pack) {
                        _context30.next = 31;
                        break;
                      }

                      this.showError(new Error("Browser>>onModuleSelected called but no package selected!" + m));
                      return _context30.abrupt("return");

                    case 31:
                      if (!this.state.moduleUpdateInProgress) {
                        deferred$1 = deferred();
                        this.state.moduleUpdateInProgress = deferred$1.promise;
                      }

                      _context30.prev = 32;
                      system = this.systemInterface;
                      _context30.t0 = this;
                      _context30.next = 37;
                      return system.moduleRead(m.url);

                    case 37:
                      _context30.t1 = _context30.sent;

                      if (!_context30.t0.isTestModule.call(_context30.t0, _context30.t1)) {
                        _context30.next = 41;
                        break;
                      }

                      _context30.next = 41;
                      return this.loadES6Mocha();

                    case 41:
                      if (!(!m.isLoaded && m.name.endsWith(".js"))) {
                        _context30.next = 66;
                        break;
                      }

                      _context30.prev = 42;
                      _context30.next = 45;
                      return system.importModule(m.url);

                    case 45:
                      _context30.next = 50;
                      break;

                    case 47:
                      _context30.prev = 47;
                      _context30.t2 = _context30["catch"](42);
                      err = _context30.t2;

                    case 50:
                      if (err) this.view.showError(err);
                      _context30.next = 53;
                      return system.getPackage(pack.address);

                    case 53:
                      p = _context30.sent;
                      isLoadedNow = p.modules.map(function (ea) {
                        return ea.name;
                      }).includes(m.url);

                      if (!isLoadedNow) {
                        _context30.next = 66;
                        break;
                      }

                      Object.assign(pack, p);
                      m.isLoaded = true;
                      _context30.next = 60;
                      return this.updateModuleList();

                    case 60:
                      this.state.moduleUpdateInProgress = null;
                      _context30.next = 63;
                      return this.selectModuleNamed(m.url);

                    case 63:
                      m = this.selectedModule;

                      if (deferred$1) {
                        this.state.moduleUpdateInProgress = deferred$1.promise;
                      }

                      return _context30.abrupt("return");

                    case 66:
                      this.ui.tabs.selectedTab.caption = "[".concat(pack.name, "] ").concat(m.nameInPackage);
                      _context30.next = 69;
                      return system.moduleRead(m.url);

                    case 69:
                      source = _context30.sent;
                      this.updateSource(source, {
                        row: 0,
                        column: 0
                      });
                      _context30.next = 73;
                      return this.prepareCodeEditorForModule(m);

                    case 73:
                      this.historyRecord();
                      m.isLoaded = true;
                      this.updateModuleList();
                      this.state.selectedModule = m;

                    case 77:
                      _context30.prev = 77;
                      this.reviveFrozenModuleIfNeeded();

                      if (deferred$1) {
                        this.state.moduleUpdateInProgress = null;
                        deferred$1.resolve(m);
                      }

                      this.ui.metaInfoText.showDefault();
                      return _context30.finish(77);

                    case 82:
                    case "end":
                      return _context30.stop();
                  }
                }
              }, _callee30, this, [[32,, 77, 82], [42, 47]]);
            }));

            function BrowserModel_onModuleSelected_(_x20) {
              return _BrowserModel_onModuleSelected_.apply(this, arguments);
            }

            return BrowserModel_onModuleSelected_;
          }()
        }, {
          key: "closeStatusMessage",
          value: function BrowserModel_closeStatusMessage_() {
            this.ui.metaInfoText.showDefault();
          }
        }, {
          key: "openStatusMessage",
          value: function BrowserModel_openStatusMessage_() {
            this.ui.metaInfoText.showInfoInWorkspace();
          }
        }, {
          key: "switchMode",
          value: function BrowserModel_switchMode_(mode) {
            var Mode = JavaScriptEditorPlugin;

            switch (mode) {
              case "js":
                break;

              case "json":
                Mode = JSONEditorPlugin;
                break;

              case "jsx":
                Mode = JSXEditorPlugin;
                break;

              case "md":
                Mode = MarkdownEditorPlugin;
                break;

              case "css":
                Mode = CSSEditorPlugin;
                break;

              case "html":
                Mode = HTMLEditorPlugin;
                break;
            }

            if (this.editorPlugin.constructor !== Mode) {
              var env = this.editorPlugin.evalEnvironment;
              this.ui.sourceEditor.removePlugin(this.editorPlugin);
              this.ui.sourceEditor.addPlugin(new Mode(config$2.codeEditor.defaultTheme));

              if (!this.editorPlugin.evalEnvironment) {
                this.editorPlugin.evalEnvironment = {
                  systemInterface: localInterface
                };
              }

              Object.assign(this.editorPlugin.evalEnvironment, env);
              this.editorPlugin.highlight();
            }
          }
        }, {
          key: "prepareCodeEditorForModule",
          value: function () {
            var _BrowserModel_prepareCodeEditorForModule_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(mod) {
              var sourceEditor, system, format, pack, _ref8, _ref9, ext;

              return regeneratorRuntime.wrap(function _callee31$(_context31) {
                while (1) {
                  switch (_context31.prev = _context31.next) {
                    case 0:
                      sourceEditor = this.ui.sourceEditor;
                      system = this.systemInterface;
                      _context31.next = 4;
                      return system.moduleFormat(mod.url);

                    case 4:
                      _context31.t0 = _context31.sent;

                      if (_context31.t0) {
                        _context31.next = 7;
                        break;
                      }

                      _context31.t0 = "esm";

                    case 7:
                      format = _context31.t0;
                      pack = this.selectedPackage;
                      _ref8 = mod.name.match(/\.([^\.]+)$/) || [], _ref9 = _slicedToArray(_ref8, 2), ext = _ref9[1];
                      this.switchMode(ext);

                      if (!(ext === "md" && module$1("lively.ide/md/compiler.js")._frozenModule)) {
                        _context31.next = 14;
                        break;
                      }

                      _context31.next = 14;
                      return module$1("lively.ide/md/compiler.js").revive();

                    case 14:
                      if (this.editorPlugin.evalEnvironment.targetModule !== mod.url) {
                        sourceEditor.scroll = pt(0, 0);
                        sourceEditor.undoManager.reset();
                      }

                      Object.assign(this.editorPlugin.evalEnvironment, {
                        targetModule: mod.url,
                        context: sourceEditor,
                        format: format
                      });
                      this.editorPlugin._tokenizerValidBefore = {
                        row: 0,
                        column: 0
                      };
                      this.editorPlugin.requestHighlight(true);
                      _context31.next = 20;
                      return this.injectComponentEditControls(mod);

                    case 20:
                      _context31.next = 22;
                      return this.updateTestUI(mod);

                    case 22:
                      this.ui.metaInfoText.setPath(["[".concat(this.formatPackageName(pack), "]"), {
                        nativeCursor: "pointer",
                        textDecoration: "underline",
                        doit: {
                          code: "$world.execCommand(\"open file browser\", {location: \"".concat(pack.url, "\"})")
                        }
                      }, " ", null, mod.nameInPackage || "", null]);
                      this.view.getWindow().title = "browser - [".concat(this.formatPackageName(pack), "] ").concat(mod.nameInPackage || "", " ");

                    case 24:
                    case "end":
                      return _context31.stop();
                  }
                }
              }, _callee31, this);
            }));

            function BrowserModel_prepareCodeEditorForModule_(_x21) {
              return _BrowserModel_prepareCodeEditorForModule_.apply(this, arguments);
            }

            return BrowserModel_prepareCodeEditorForModule_;
          }()
        }, {
          key: "updateFocusedCodeEntityDebounced",
          value: function BrowserModel_updateFocusedCodeEntityDebounced_() {
            var _this7 = this;

            debounceNamed(this.id + "updateFocusedCodeEntityDebounced", 20, function () {
              return _this7.updateFocusedCodeEntity();
            })();
          }
        }, {
          key: "updateFocusedCodeEntity",
          value: function BrowserModel_updateFocusedCodeEntity_() {
            var minWidthToDisplay = 600;
            var _this$ui5 = this.ui,
                sourceEditor = _this$ui5.sourceEditor,
                metaInfoText = _this$ui5.metaInfoText;
            var cursorIdx = sourceEditor.positionToIndex(sourceEditor.cursorPosition);

            var _ref10 = last$2(this.renderedCodeEntities().filter(function (entity) {
              if (!entity.node) return;
              var _entity$node = entity.node,
                  start = _entity$node.start,
                  end = _entity$node.end;
              return start < cursorIdx && cursorIdx < end;
            })) || {},
                parent = _ref10.parent,
                name = _ref10.name;

            var parents = parent ? [parent.name, ""] : [];

            while (parent && (parent = parent.parent)) {
              parents.unshift(parent.name);
            }

            if (name && this.view.width > minWidthToDisplay) {
              metaInfoText.setPath([].concat(_toConsumableArray$1(metaInfoText.getPath().slice(0, 4)), [" - ".concat(parents.join(">>")).concat(name, ":").concat(sourceEditor.cursorPosition.row), {
                fontSize: 12,
                paddingTop: "2px"
              }]));
            }
          }
        }, {
          key: "isComponentEntity",
          value: function () {
            var _BrowserModel_isComponentEntity_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(entity) {
              var _this$selectedModule$;

              var res;
              return regeneratorRuntime.wrap(function _callee32$(_context32) {
                while (1) {
                  switch (_context32.prev = _context32.next) {
                    case 0:
                      if ((_this$selectedModule$ = this.selectedModule.name) === null || _this$selectedModule$ === void 0 ? void 0 : _this$selectedModule$.endsWith(".cp.js")) {
                        _context32.next = 2;
                        break;
                      }

                      return _context32.abrupt("return", false);

                    case 2:
                      _context32.next = 4;
                      return this.systemInterface.runEval(entity.name + "?.isComponentDescriptor", {
                        targetModule: this.selectedModule.url
                      });

                    case 4:
                      res = _context32.sent;
                      return _context32.abrupt("return", res.value);

                    case 6:
                    case "end":
                      return _context32.stop();
                  }
                }
              }, _callee32, this);
            }));

            function BrowserModel_isComponentEntity_(_x22) {
              return _BrowserModel_isComponentEntity_.apply(this, arguments);
            }

            return BrowserModel_isComponentEntity_;
          }()
        }, {
          key: "onCodeEntitySelected",
          value: function () {
            var _BrowserModel_onCodeEntitySelected_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(entity) {
              var sourceEditor, moduleType, start, end, isComponent;
              return regeneratorRuntime.wrap(function _callee33$(_context33) {
                while (1) {
                  switch (_context33.prev = _context33.next) {
                    case 0:
                      if (entity) {
                        _context33.next = 2;
                        break;
                      }

                      return _context33.abrupt("return");

                    case 2:
                      sourceEditor = this.ui.sourceEditor;

                      if (!(this.selectedModule.type === "js" || this.selectedModule.type === "json")) {
                        _context33.next = 15;
                        break;
                      }

                      moduleType = this.selectedModule.type;
                      start = sourceEditor.indexToPosition(moduleType === "js" ? entity.node.start : entity.start);
                      end = sourceEditor.indexToPosition(moduleType === "js" ? entity.node.end : entity.end);
                      _context33.next = 9;
                      return this.isComponentEntity(entity);

                    case 9:
                      isComponent = _context33.sent;
                      sourceEditor.cursorPosition = start;
                      sourceEditor.flash({
                        start: start,
                        end: end
                      }, {
                        id: "codeentity",
                        time: 1000,
                        fill: Color.rgb(200, 235, 255)
                      });
                      if (isComponent) start.row -= 2;
                      sourceEditor.centerRange({
                        start: start,
                        end: end
                      });
                      sourceEditor.scrollDown(-60);

                    case 15:
                      if (this.selectedModule.type === "md") {
                        sourceEditor.execCommand("[markdown] goto heading", {
                          choice: entity
                        });
                      }

                    case 16:
                    case "end":
                      return _context33.stop();
                  }
                }
              }, _callee33, this);
            }));

            function BrowserModel_onCodeEntitySelected_(_x23) {
              return _BrowserModel_onCodeEntitySelected_.apply(this, arguments);
            }

            return BrowserModel_onCodeEntitySelected_;
          }()
        }, {
          key: "findCodeEntity",
          value: function BrowserModel_findCodeEntity_(_ref11) {
            var name = _ref11.name,
                type = _ref11.type,
                parent = _ref11.parent;
            var parentDef = parent ? this.findCodeEntity(parent) : null;
            var defs = this.renderedCodeEntities();
            if (!defs) return null;
            return defs.find(function (def) {
              if (parentDef && def.parent !== parentDef) return false;
              if (def.name !== name) return false;
              if (!type || def.type === type) return true;
              if (type === "method" && def.type.includes("method")) return true;
              return false;
            });
          }
        }, {
          key: "renderedCodeEntities",
          value: function BrowserModel_renderedCodeEntities_() {
            var columnView = this.ui.columnView;
            var selectedModuleNode = this.selectedModule;
            var td = columnView && columnView.treeData;
            if (!td || !selectedModuleNode) return [];
            return filter(selectedModuleNode, function (node) {
              return node.isDeclaration;
            }, function (node) {
              if (!node.subNodes && node.children) {
                node.subNodes = node.children;
                node.subNodes.forEach(function (n) {
                  return n.isDeclaration = true;
                });
              }

              return td.getChildren(node);
            });
          }
        }, {
          key: "selectCodeEntityInColumnView",
          value: function () {
            var _BrowserModel_selectCodeEntityInColumnView_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(spec, animated) {
              var def, parents, current, parent;
              return regeneratorRuntime.wrap(function _callee34$(_context34) {
                while (1) {
                  switch (_context34.prev = _context34.next) {
                    case 0:
                      if (typeof spec === "string") spec = {
                        name: spec
                      };
                      parents = [this.selectedModule];

                      if (!isArray$2(spec)) {
                        _context34.next = 7;
                        break;
                      }

                      spec = spec.map(function (sp) {
                        return typeof sp === "string" ? {
                          name: sp
                        } : sp;
                      });

                      while (current = spec.shift()) {
                        current.parent = last$2(parents);
                        parents.push(def = this.findCodeEntity(current));
                      }

                      _context34.next = 12;
                      break;

                    case 7:
                      def = this.findCodeEntity(spec);
                      parent = def;

                      if (parent) {
                        _context34.next = 11;
                        break;
                      }

                      return _context34.abrupt("return");

                    case 11:
                      while (parent = parent.parent) {
                        parents.push(parent);
                      }

                    case 12:
                      _context34.next = 14;
                      return this.ui.columnView.setExpandedPath(function (n) {
                        return n.name === def.name || !!parents.find(function (p) {
                          return p.type === n.type && p.name === n.name;
                        });
                      }, this.selectedModule, animated);

                    case 14:
                      return _context34.abrupt("return", def);

                    case 15:
                    case "end":
                      return _context34.stop();
                  }
                }
              }, _callee34, this);
            }));

            function BrowserModel_selectCodeEntityInColumnView_(_x24, _x25) {
              return _BrowserModel_selectCodeEntityInColumnView_.apply(this, arguments);
            }

            return BrowserModel_selectCodeEntityInColumnView_;
          }()
        }, {
          key: "selectCodeEntity",
          value: function () {
            var _BrowserModel_selectCodeEntity_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(spec) {
              var animated,
                  def,
                  _args35 = arguments;
              return regeneratorRuntime.wrap(function _callee35$(_context35) {
                while (1) {
                  switch (_context35.prev = _context35.next) {
                    case 0:
                      animated = _args35.length > 1 && _args35[1] !== undefined ? _args35[1] : true;
                      _context35.next = 3;
                      return this.selectCodeEntityInColumnView(spec, animated);

                    case 3:
                      def = _context35.sent;
                      this.onListSelectionChange(this.ui.columnView.getExpandedPath());
                      return _context35.abrupt("return", def);

                    case 6:
                    case "end":
                      return _context35.stop();
                  }
                }
              }, _callee35, this);
            }));

            function BrowserModel_selectCodeEntity_(_x26) {
              return _BrowserModel_selectCodeEntity_.apply(this, arguments);
            }

            return BrowserModel_selectCodeEntity_;
          }()
        }, {
          key: "updateModuleList",
          value: function () {
            var _BrowserModel_updateModuleList_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36(m) {
              var columnView, parent;
              return regeneratorRuntime.wrap(function _callee36$(_context36) {
                while (1) {
                  switch (_context36.prev = _context36.next) {
                    case 0:
                      columnView = this.ui.columnView;

                      if (!m) {
                        _context36.next = 5;
                        break;
                      }

                      parent = columnView.treeData.parentNode(m);
                      _context36.next = 5;
                      return columnView.treeData.collapse(parent, false);

                    case 5:
                      _context36.next = 7;
                      return columnView.refresh(false);

                    case 7:
                    case "end":
                      return _context36.stop();
                  }
                }
              }, _callee36, this);
            }));

            function BrowserModel_updateModuleList_(_x27) {
              return _BrowserModel_updateModuleList_.apply(this, arguments);
            }

            return BrowserModel_updateModuleList_;
          }()
        }, {
          key: "updateCodeEntities",
          value: function () {
            var _BrowserModel_updateCodeEntities_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(mod) {
              var _this8 = this;

              var columnView, modNode;
              return regeneratorRuntime.wrap(function _callee37$(_context37) {
                while (1) {
                  switch (_context37.prev = _context37.next) {
                    case 0:
                      columnView = this.ui.columnView;
                      modNode = columnView.getExpandedPath().find(function (node) {
                        return _this8.isModule(node);
                      });
                      modNode.subNodes = null;
                      _context37.next = 5;
                      return columnView.treeData.collapse(modNode, false);

                    case 5:
                      _context37.next = 7;
                      return columnView.refresh(false);

                    case 7:
                    case "end":
                      return _context37.stop();
                  }
                }
              }, _callee37, this);
            }));

            function BrowserModel_updateCodeEntities_(_x28) {
              return _BrowserModel_updateCodeEntities_.apply(this, arguments);
            }

            return BrowserModel_updateCodeEntities_;
          }()
        }, {
          key: "isTestModule",
          value: function BrowserModel_isTestModule_(astOrSource) {
            var tests = testsFromSource(astOrSource);
            return tests && tests.length > 0;
          }
        }, {
          key: "isMarkdown",
          value: function BrowserModel_isMarkdown_(mod) {
            return mod.type === "md";
          }
        }, {
          key: "updateTestUI",
          value: function BrowserModel_updateTestUI_(mod) {
            var _this$ui6 = this.ui,
                metaInfoText = _this$ui6.metaInfoText,
                sourceEditor = _this$ui6.sourceEditor;
            var hasTests = false;

            if (this.editorPlugin.isJSEditorPlugin) {
              try {
                var ast = this.editorPlugin.getNavigator().ensureAST(sourceEditor);
                hasTests = this.isTestModule(ast || sourceEditor.textString);
              } catch (err) {
                console.warn("sytem browser updateTestUI: ".concat(err));
                hasTests = false;
              }
            }

            if (hasTests) sourceEditor.submorphs = [];
            metaInfoText.testModuleMode = hasTests;
          }
        }, {
          key: "getComponentDeclsFromScope",
          value: function () {
            var _BrowserModel_getComponentDeclsFromScope_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(modId, scope) {
              var mod, componentDecls, _iterator, _step, _decl$declarations$, _decl$declarations$$i, decl, varName, val;

              return regeneratorRuntime.wrap(function _callee38$(_context38) {
                while (1) {
                  switch (_context38.prev = _context38.next) {
                    case 0:
                      mod = module$1(modId);

                      if (scope) {
                        _context38.next = 5;
                        break;
                      }

                      _context38.next = 4;
                      return mod.scope();

                    case 4:
                      scope = _context38.sent;

                    case 5:
                      componentDecls = [];
                      _iterator = _createForOfIteratorHelper(scope.varDecls);
                      _context38.prev = 7;

                      _iterator.s();

                    case 9:
                      if ((_step = _iterator.n()).done) {
                        _context38.next = 18;
                        break;
                      }

                      decl = _step.value;
                      varName = (_decl$declarations$ = decl.declarations[0]) === null || _decl$declarations$ === void 0 ? void 0 : (_decl$declarations$$i = _decl$declarations$.id) === null || _decl$declarations$$i === void 0 ? void 0 : _decl$declarations$$i.name;

                      if (varName) {
                        _context38.next = 14;
                        break;
                      }

                      return _context38.abrupt("continue", 16);

                    case 14:
                      val = mod.recorder[varName];

                      if (val === null || val === void 0 ? void 0 : val.isComponentDescriptor) {
                        componentDecls.push([val, decl]);
                      }

                    case 16:
                      _context38.next = 9;
                      break;

                    case 18:
                      _context38.next = 23;
                      break;

                    case 20:
                      _context38.prev = 20;
                      _context38.t0 = _context38["catch"](7);

                      _iterator.e(_context38.t0);

                    case 23:
                      _context38.prev = 23;

                      _iterator.f();

                      return _context38.finish(23);

                    case 26:
                      return _context38.abrupt("return", componentDecls);

                    case 27:
                    case "end":
                      return _context38.stop();
                  }
                }
              }, _callee38, null, [[7, 20, 23, 26]]);
            }));

            function BrowserModel_getComponentDeclsFromScope_(_x29, _x30) {
              return _BrowserModel_getComponentDeclsFromScope_.apply(this, arguments);
            }

            return BrowserModel_getComponentDeclsFromScope_;
          }()
        }, {
          key: "injectComponentEditControls",
          value: function () {
            var _BrowserModel_injectComponentEditControls_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(mod) {
              var _this9 = this;

              var editor;
              return regeneratorRuntime.wrap(function _callee39$(_context39) {
                while (1) {
                  switch (_context39.prev = _context39.next) {
                    case 0:
                      editor = this.ui.sourceEditor;
                      editor.submorphs = compact([editor.textMap]);
                      editor.anchors = editor.anchors.filter(function (anchor) {
                        var _anchor$id;

                        return !((_anchor$id = anchor.id) === null || _anchor$id === void 0 ? void 0 : _anchor$id.startsWith("Component->"));
                      });

                      if (mod.name.endsWith(".cp.js")) {
                        _context39.next = 5;
                        break;
                      }

                      return _context39.abrupt("return");

                    case 5:
                      this.getComponentDeclsFromScope(mod.url).then(function (decls) {
                        return Promise.all(decls.map(function (_ref12) {
                          var _ref13 = _slicedToArray(_ref12, 2),
                              val = _ref13[0],
                              decl = _ref13[1];

                          if (queryNodes(decl, ".// CallExpression [ /:callee Identifier [ @name == 'component']]").length > 0) {
                            return _this9.ensureComponentEditButtonFor(val, decl);
                          }
                        }));
                      }).then(function (btns) {
                        return compact(btns).forEach(function (btn) {
                          return btn.opacity = 1;
                        });
                      });

                    case 6:
                    case "end":
                      return _context39.stop();
                  }
                }
              }, _callee39, this);
            }));

            function BrowserModel_injectComponentEditControls_(_x31) {
              return _BrowserModel_injectComponentEditControls_.apply(this, arguments);
            }

            return BrowserModel_injectComponentEditControls_;
          }()
        }, {
          key: "resetComponentControls",
          value: function () {
            var _BrowserModel_resetComponentControls_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee40() {
              var editor, _query$topLevelDeclsA, scope, _iterator2, _step2, _loop;

              return regeneratorRuntime.wrap(function _callee40$(_context40) {
                while (1) {
                  switch (_context40.prev = _context40.next) {
                    case 0:
                      editor = this.ui.sourceEditor;
                      _context40.prev = 1;
                      _query$topLevelDeclsA = topLevelDeclsAndRefs(parse$2(editor.textString)), scope = _query$topLevelDeclsA.scope;
                      _context40.t0 = _createForOfIteratorHelper;
                      _context40.next = 6;
                      return this.getComponentDeclsFromScope(this.selectedModule.url, scope);

                    case 6:
                      _context40.t1 = _context40.sent;
                      _iterator2 = (0, _context40.t0)(_context40.t1);

                      try {
                        _loop = function _loop() {
                          var _step2$value = _slicedToArray(_step2.value, 2),
                              val = _step2$value[0],
                              decl = _step2$value[1];

                          var matchingControl = editor.submorphs.find(function (m) {
                            return m.componentDescriptor === val;
                          });
                          if (matchingControl) matchingControl.declaration = decl;
                        };

                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                          _loop();
                        }
                      } catch (err) {
                        _iterator2.e(err);
                      } finally {
                        _iterator2.f();
                      }

                      _context40.next = 13;
                      break;

                    case 11:
                      _context40.prev = 11;
                      _context40.t2 = _context40["catch"](1);

                    case 13:
                    case "end":
                      return _context40.stop();
                  }
                }
              }, _callee40, this, [[1, 11]]);
            }));

            function BrowserModel_resetComponentControls_() {
              return _BrowserModel_resetComponentControls_.apply(this, arguments);
            }

            return BrowserModel_resetComponentControls_;
          }()
        }, {
          key: "repositionComponentEditButtons",
          value: function BrowserModel_repositionComponentEditButtons_() {
            this.ui.sourceEditor.submorphs.forEach(function (m) {
              return m.isComponentControl && m.positionInLine();
            });
          }
        }, {
          key: "showComponentEditButtons",
          value: function BrowserModel_showComponentEditButtons_() {
            var sourceEditor = this.ui.sourceEditor;
            sourceEditor.submorphs.forEach(function (m) {
              if (sourceEditor.textMap === m) return;
              if (!m.visible && m.isComponentControl) m.positionInLine();
              m.visible = true;
            });
          }
        }, {
          key: "toggleComponentControlsOnOccur",
          value: function BrowserModel_toggleComponentControlsOnOccur_(arg) {
            if (arg === null || arg === void 0 ? void 0 : arg.isTextSnippet) return;

            if (this.ui.sourceEditor.pluginFind(function (plugin) {
              return plugin.isOccurPlugin;
            })) {
              this.hideComponentEditButtons();
            } else this.showComponentEditButtons();
          }
        }, {
          key: "activeComponentEditSessions",
          value: function BrowserModel_activeComponentEditSessions_() {
            var sourceEditor = this.ui.sourceEditor;
            return sourceEditor.submorphs.filter(function (m) {
              return m.isActiveEditSession;
            });
          }
        }, {
          key: "hideComponentEditButtons",
          value: function BrowserModel_hideComponentEditButtons_() {
            var sourceEditor = this.ui.sourceEditor;
            sourceEditor.submorphs.forEach(function (m) {
              if (sourceEditor.textMap === m) return;
              m.visible = false;
            });
          }
        }, {
          key: "ensureComponentEditButtonFor",
          value: function () {
            var _BrowserModel_ensureComponentEditButtonFor_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee41(componentDescriptor, declaration) {
              var _yield$import, ComponentEditButton, editor, btn;

              return regeneratorRuntime.wrap(function _callee41$(_context41) {
                while (1) {
                  switch (_context41.prev = _context41.next) {
                    case 0:
                      _context41.next = 2;
                      return Promise.resolve().then(function () { return ui_cp$1; });

                    case 2:
                      _yield$import = _context41.sent;
                      ComponentEditButton = _yield$import.ComponentEditButton;
                      editor = this.ui.sourceEditor;
                      btn = part(ComponentEditButton, {
                        name: "edit component btn",
                        componentDescriptor: componentDescriptor,
                        epiMorph: true,
                        declaration: declaration
                      });
                      adoptObject(componentDescriptor, InteractiveComponentDescriptor);
                      InteractiveComponentDescriptor.ensureInteractive(componentDescriptor);
                      editor.addMorph(btn);
                      _context41.next = 11;
                      return btn.positionInLine();

                    case 11:
                      return _context41.abrupt("return", btn);

                    case 12:
                    case "end":
                      return _context41.stop();
                  }
                }
              }, _callee41, this);
            }));

            function BrowserModel_ensureComponentEditButtonFor_(_x32, _x33) {
              return _BrowserModel_ensureComponentEditButtonFor_.apply(this, arguments);
            }

            return BrowserModel_ensureComponentEditButtonFor_;
          }()
        }, {
          key: "runOnServer",
          value: function () {
            var _BrowserModel_runOnServer_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee42(source) {
              var result;
              return regeneratorRuntime.wrap(function _callee42$(_context42) {
                while (1) {
                  switch (_context42.prev = _context42.next) {
                    case 0:
                      _context42.next = 2;
                      return serverInterfaceFor(config$2.remotes.server).runEval("\n        ".concat(source, "\n    "), {
                        targetModule: "lively://PackageBrowser/eval"
                      });

                    case 2:
                      result = _context42.sent;

                      if (!result.isError) {
                        _context42.next = 5;
                        break;
                      }

                      throw result.value;

                    case 5:
                      return _context42.abrupt("return", result.value);

                    case 6:
                    case "end":
                      return _context42.stop();
                  }
                }
              }, _callee42);
            }));

            function BrowserModel_runOnServer_(_x34) {
              return _BrowserModel_runOnServer_.apply(this, arguments);
            }

            return BrowserModel_runOnServer_;
          }()
        }, {
          key: "getInstalledPackagesList",
          value: function () {
            var _BrowserModel_getInstalledPackagesList_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee43() {
              var pmap, items, pname, versions, v, p;
              return regeneratorRuntime.wrap(function _callee43$(_context43) {
                while (1) {
                  switch (_context43.prev = _context43.next) {
                    case 0:
                      _context43.next = 2;
                      return this.runOnServer("\n      let r = System.get(\"@lively-env\").packageRegistry;\n      r.toJSON();");

                    case 2:
                      pmap = _context43.sent;
                      items = [];

                      for (pname in pmap.packageMap) {
                        versions = pmap.packageMap[pname].versions;

                        for (v in versions) {
                          p = versions[v];
                          items.push(p);
                        }
                      }

                      return _context43.abrupt("return", items);

                    case 6:
                    case "end":
                      return _context43.stop();
                  }
                }
              }, _callee43, this);
            }));

            function BrowserModel_getInstalledPackagesList_() {
              return _BrowserModel_getInstalledPackagesList_.apply(this, arguments);
            }

            return BrowserModel_getInstalledPackagesList_;
          }()
        }, {
          key: "updatePackageDependencies",
          value: function () {
            var _BrowserModel_updatePackageDependencies_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee44() {
              return regeneratorRuntime.wrap(function _callee44$(_context44) {
                while (1) {
                  switch (_context44.prev = _context44.next) {
                    case 0:
                    case "end":
                      return _context44.stop();
                  }
                }
              }, _callee44);
            }));

            function BrowserModel_updatePackageDependencies_() {
              return _BrowserModel_updatePackageDependencies_.apply(this, arguments);
            }

            return BrowserModel_updatePackageDependencies_;
          }()
        }, {
          key: "installPackage",
          value: function () {
            var _BrowserModel_installPackage_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee45(name, version, sourceIdx) {
              var _yield$this$runOnServ, pkgRegistry;

              return regeneratorRuntime.wrap(function _callee45$(_context45) {
                while (1) {
                  switch (_context45.prev = _context45.next) {
                    case 0:
                      _context45.prev = 0;
                      _context45.next = 3;
                      return this.runOnServer("        \n        async function installPackage(name, version) {\n          let Module = System._nodeRequire(\"module\"),\n              flatn = Module._load(\"flatn\")\n        \n          let env = process.env,\n              devPackageDirs = env.FLATN_DEV_PACKAGE_DIRS.split(\":\").filter(Boolean),\n              packageCollectionDirs = env.FLATN_PACKAGE_COLLECTION_DIRS.split(\":\").filter(Boolean),\n              packageDirs = env.FLATN_PACKAGE_DIRS.split(\":\").filter(Boolean),\n              packageMap = flatn.PackageMap.ensure(packageCollectionDirs, packageDirs, devPackageDirs);\n              buildFailed;\n\n          await flatn.installPackage(\n            name + \"@\" + version,\n            System.baseURL.replace(\"file://\", \"\") + \"custom-npm-modules\",\n            packageMap,\n            undefined,\n            /*isDev = */false,\n            /*verbose = */true\n          );\n          try {          \n            await flatn.installDependenciesOfPackage(\n               packageMap.lookup(name, version),\n               System.baseURL.replace(\"file://\", \"\") + 'dev-deps',\n               packageMap,\n               ['devDependencies'],\n               true\n            );\n          } catch(e) {\n            // install scripts dont really work sometimes so\n            // dont let that disrup the normal install process\n            buildFailed = e.message;\n          }\n        \n          let r = System.get(\"@lively-env\").packageRegistry\n          await r.update();\n          return { pkgRegistry: r, buildFailed };\n        }\n        await installPackage(\"".concat(name, "\", \"").concat(version, "\");   \n    "));

                    case 3:
                      _yield$this$runOnServ = _context45.sent;
                      pkgRegistry = _yield$this$runOnServ.pkgRegistry;
                      System.get("@lively-env").packageRegistry.updateFromJSON(pkgRegistry);
                      _context45.next = 10;
                      break;

                    case 8:
                      _context45.prev = 8;
                      _context45.t0 = _context45["catch"](0);

                    case 10:
                    case "end":
                      return _context45.stop();
                  }
                }
              }, _callee45, this, [[0, 8]]);
            }));

            function BrowserModel_installPackage_(_x35, _x36, _x37) {
              return _BrowserModel_installPackage_.apply(this, arguments);
            }

            return BrowserModel_installPackage_;
          }()
        }, {
          key: "save",
          value: function () {
            var _BrowserModel_save_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee46() {
              var attempt,
                  _this$ui7,
                  sourceEditor,
                  metaInfoText,
                  state,
                  system,
                  module,
                  content,
                  warnings,
                  really,
                  _ref14,
                  _ref15,
                  ext,
                  fixed,
                  linterOutput,
                  cursorPosition,
                  result,
                  warningStrings,
                  warningMessage,
                  _args46 = arguments;

              return regeneratorRuntime.wrap(function _callee46$(_context46) {
                while (1) {
                  switch (_context46.prev = _context46.next) {
                    case 0:
                      attempt = _args46.length > 0 && _args46[0] !== undefined ? _args46[0] : 0;
                      _this$ui7 = this.ui, sourceEditor = _this$ui7.sourceEditor, metaInfoText = _this$ui7.metaInfoText, state = this.state, system = this.systemInterface;
                      module = this.selectedModule;

                      if (module) {
                        _context46.next = 5;
                        break;
                      }

                      return _context46.abrupt("return");

                    case 5:
                      _context46.next = 7;
                      return this.updateRecorderIfNeeded(module.url);

                    case 7:
                      content = sourceEditor.textString.split(objectReplacementChar).join("");
                      warnings = [];

                      if (!(state.sourceHash !== hashCode(content) && state.moduleChangeWarning && state.moduleChangeWarning === module.url)) {
                        _context46.next = 16;
                        break;
                      }

                      _context46.next = 12;
                      return this.world().confirm(["Change Conflict\n", null, "The module ".concat(module.url, " you are trying to save changed elsewhere!\nOverwrite those changes?"), {
                        fontSize: 16,
                        fontWeight: "normal"
                      }], {
                        requester: this.view,
                        width: 350
                      });

                    case 12:
                      really = _context46.sent;

                      if (really) {
                        _context46.next = 15;
                        break;
                      }

                      return _context46.abrupt("return");

                    case 15:
                      state.moduleChangeWarning = null;

                    case 16:
                      _context46.next = 18;
                      return system.moduleFormat(module.url);

                    case 18:
                      _context46.t0 = _context46.sent;

                      if (_context46.t0) {
                        _context46.next = 21;
                        break;
                      }

                    case 21:
                      _ref14 = module.name.match(/\.([^\.]+)$/) || [], _ref15 = _slicedToArray(_ref14, 2), ext = _ref15[1];
                      state.isSaving = true;
                      _context46.prev = 23;
                      sourceEditor.cleanupSnippetsExpansions();

                      if (!(ext !== "js" && ext !== "jsx")) {
                        _context46.next = 41;
                        break;
                      }

                      if (!(module.nameInPackage === "package.json")) {
                        _context46.next = 32;
                        break;
                      }

                      _context46.next = 29;
                      return system.packageConfChange(content, module.url);

                    case 29:
                      this.updatePackageDependencies();
                      _context46.next = 38;
                      break;

                    case 32:
                      if (!(ext === "md")) {
                        _context46.next = 36;
                        break;
                      }

                      if (!(this.editorPlugin.isMarkdownEditorPlugin && this.editorPlugin.textMorph._mdPreviewMorph && this.editorPlugin.textMorph._mdPreviewMorph.owner.owner)) {
                        _context46.next = 36;
                        break;
                      }

                      _context46.next = 36;
                      return this.renderMarkdown(false);

                    case 36:
                      _context46.next = 38;
                      return system.coreInterface.resourceWrite(module.url, content);

                    case 38:
                      metaInfoText.showSaved();
                      _context46.next = 60;
                      break;

                    case 41:
                      if (!config$2.systemBrowser.fixUndeclaredVarsOnSave) {
                        _context46.next = 48;
                        break;
                      }

                      _context46.next = 44;
                      return sourceEditor.execCommand("[javascript] fix undeclared variables");

                    case 44:
                      fixed = _context46.sent;

                      if (fixed) {
                        _context46.next = 47;
                        break;
                      }

                      return _context46.abrupt("return");

                    case 47:
                      content = sourceEditor.textString;

                    case 48:
                      _context46.next = 50;
                      return System.lint(content);

                    case 50:
                      linterOutput = _context46.sent;
                      content = linterOutput[0];
                      warnings = linterOutput[1];

                      if (!module.isLoaded) {
                        _context46.next = 58;
                        break;
                      }

                      _context46.next = 56;
                      return system.interactivelyChangeModule(module.url, content, {
                        targetModule: module.url,
                        doEval: true
                      });

                    case 56:
                      _context46.next = 60;
                      break;

                    case 58:
                      _context46.next = 60;
                      return system.coreInterface.resourceWrite(module.url, content);

                    case 60:
                      cursorPosition = sourceEditor.cursorPosition;
                      this.updateSource(content);
                      _context46.next = 64;
                      return this.updateCodeEntities(module);

                    case 64:
                      _context46.next = 66;
                      return this.injectComponentEditControls(module);

                    case 66:
                      _context46.next = 68;
                      return this.updateTestUI(module);

                    case 68:
                      sourceEditor.focus();
                      sourceEditor.cursorPosition = cursorPosition;
                      _context46.next = 82;
                      break;

                    case 72:
                      _context46.prev = 72;
                      _context46.t1 = _context46["catch"](23);

                      if (!(attempt > 0 || _context46.t1 instanceof SyntaxError)) {
                        _context46.next = 77;
                        break;
                      }

                      metaInfoText.showError(_context46.t1);
                      return _context46.abrupt("return");

                    case 77:
                      _context46.next = 79;
                      return this.reloadModule(false);

                    case 79:
                      result = _context46.sent;
                      sourceEditor.textString = content;
                      return _context46.abrupt("return", !result || result instanceof Error ? metaInfoText.showError(_context46.t1) : this.save(attempt + 1));

                    case 82:
                      _context46.prev = 82;
                      this.state.isSaving = false;
                      return _context46.finish(82);

                    case 85:
                      if (!(warnings.length > 0)) {
                        _context46.next = 93;
                        break;
                      }

                      warningStrings = warnings.map(function (warning) {
                        return "\"".concat(warning.message, "\" on line ").concat(warning.line);
                      });
                      warningMessage = ["Saved with warnings:"].concat(warningStrings).join("\n");
                      if (warnings.some(function (w) {
                        return w.severity === 2;
                      })) metaInfoText.showError(warningMessage);else metaInfoText.showWarning(warningMessage);
                      _context46.next = 91;
                      return delay(5000);

                    case 91:
                      if (metaInfoText.master.getState() == "warning") metaInfoText.showSaved();
                      return _context46.abrupt("return");

                    case 93:
                      metaInfoText.showSaved();

                    case 94:
                    case "end":
                      return _context46.stop();
                  }
                }
              }, _callee46, this, [[23, 72, 82, 85]]);
            }));

            function BrowserModel_save_() {
              return _BrowserModel_save_.apply(this, arguments);
            }

            return BrowserModel_save_;
          }()
        }, {
          key: "reloadModule",
          value: function () {
            var _BrowserModel_reloadModule_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee47() {
              var hard,
                  proceed,
                  m,
                  systemInterface,
                  sourceEditor,
                  scroll,
                  cursorPosition,
                  reloadDeps,
                  resetEnv,
                  _args47 = arguments;
              return regeneratorRuntime.wrap(function _callee47$(_context47) {
                while (1) {
                  switch (_context47.prev = _context47.next) {
                    case 0:
                      hard = _args47.length > 0 && _args47[0] !== undefined ? _args47[0] : false;
                      _context47.next = 3;
                      return this.cleanupActiveEditSessions();

                    case 3:
                      proceed = _context47.sent;

                      if (proceed) {
                        _context47.next = 6;
                        break;
                      }

                      return _context47.abrupt("return", null);

                    case 6:
                      m = this.selectedModule, systemInterface = this.systemInterface, sourceEditor = this.ui.sourceEditor;
                      scroll = sourceEditor.scroll, cursorPosition = sourceEditor.cursorPosition;

                      if (m) {
                        _context47.next = 10;
                        break;
                      }

                      return _context47.abrupt("return", null);

                    case 10:
                      reloadDeps = !!hard;
                      resetEnv = !!hard;
                      _context47.prev = 12;
                      _context47.next = 15;
                      return systemInterface.interactivelyReloadModule(null, m.url, reloadDeps, resetEnv);

                    case 15:
                      this.state.selectedModule = null;
                      _context47.next = 18;
                      return this.selectModuleNamed(m.nameInPackage);

                    case 18:
                      sourceEditor.scroll = scroll;
                      sourceEditor.cursorPosition = cursorPosition;
                      _context47.next = 25;
                      break;

                    case 22:
                      _context47.prev = 22;
                      _context47.t0 = _context47["catch"](12);
                      return _context47.abrupt("return", new Error("Error while reloading ".concat(m.name, ":\n").concat(_context47.t0.stack || _context47.t0)));

                    case 25:
                      return _context47.abrupt("return", m);

                    case 26:
                    case "end":
                      return _context47.stop();
                  }
                }
              }, _callee47, this, [[12, 22]]);
            }));

            function BrowserModel_reloadModule_() {
              return _BrowserModel_reloadModule_.apply(this, arguments);
            }

            return BrowserModel_reloadModule_;
          }()
        }, {
          key: "historyBackward",
          value: function () {
            var _BrowserModel_historyBackward_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee48() {
              var current, before, _this$historyGetLocat, scroll, cursor;

              return regeneratorRuntime.wrap(function _callee48$(_context48) {
                while (1) {
                  switch (_context48.prev = _context48.next) {
                    case 0:
                      if (!(this.state.history.left.length < 2)) {
                        _context48.next = 2;
                        break;
                      }

                      return _context48.abrupt("return");

                    case 2:
                      current = this.state.history.left.pop();
                      before = last$2(this.state.history.left);
                      this.state.history.right.unshift(current);
                      this.refreshHistoryButtons();
                      _this$historyGetLocat = this.historyGetLocation(), scroll = _this$historyGetLocat.scroll, cursor = _this$historyGetLocat.cursor;
                      current.scroll = scroll;
                      current.cursor = cursor;
                      _context48.prev = 9;
                      _context48.next = 12;
                      return this.historySetLocation(before);

                    case 12:
                      _context48.next = 19;
                      break;

                    case 14:
                      _context48.prev = 14;
                      _context48.t0 = _context48["catch"](9);
                      this.state.history.left.push(before);
                      this.state.history.right.unshift();
                      throw _context48.t0;

                    case 19:
                    case "end":
                      return _context48.stop();
                  }
                }
              }, _callee48, this, [[9, 14]]);
            }));

            function BrowserModel_historyBackward_() {
              return _BrowserModel_historyBackward_.apply(this, arguments);
            }

            return BrowserModel_historyBackward_;
          }()
        }, {
          key: "historyForward",
          value: function () {
            var _BrowserModel_historyForward_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee49() {
              var current, next, _this$historyGetLocat2, scroll, cursor;

              return regeneratorRuntime.wrap(function _callee49$(_context49) {
                while (1) {
                  switch (_context49.prev = _context49.next) {
                    case 0:
                      current = last$2(this.state.history.left);
                      next = this.state.history.right.shift();

                      if (next) {
                        _context49.next = 4;
                        break;
                      }

                      return _context49.abrupt("return");

                    case 4:
                      this.state.history.left.push(next);
                      this.refreshHistoryButtons();

                      if (current) {
                        _this$historyGetLocat2 = this.historyGetLocation(), scroll = _this$historyGetLocat2.scroll, cursor = _this$historyGetLocat2.cursor;
                        current.scroll = scroll;
                        current.cursor = cursor;
                      }

                      _context49.prev = 7;
                      _context49.next = 10;
                      return this.historySetLocation(next);

                    case 10:
                      _context49.next = 17;
                      break;

                    case 12:
                      _context49.prev = 12;
                      _context49.t0 = _context49["catch"](7);
                      this.state.history.left.pop();
                      this.state.history.right.unshift(next);
                      throw _context49.t0;

                    case 17:
                    case "end":
                      return _context49.stop();
                  }
                }
              }, _callee49, this, [[7, 12]]);
            }));

            function BrowserModel_historyForward_() {
              return _BrowserModel_historyForward_.apply(this, arguments);
            }

            return BrowserModel_historyForward_;
          }()
        }, {
          key: "historyGetLocation",
          value: function BrowserModel_historyGetLocation_() {
            var ed = this.ui.sourceEditor;
            return {
              "package": this.selectedPackage,
              module: this.selectedModule,
              cursor: ed.cursorPosition,
              scroll: ed.scroll
            };
          }
        }, {
          key: "historyRecord",
          value: function BrowserModel_historyRecord_() {
            var addToRight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            if (this.state.history.navigationInProgress) return;
            this.state.history.right.length = 0;
            var loc = this.historyGetLocation();
            var last;

            if (addToRight) {
              while ((last = this.state.history.right[0]) && last.module && loc.module && last.module.url === loc.module.url) {
                this.state.history.right.shift();
              }

              this.state.history.right.unshift(loc);
            } else {
              while ((last = last$2(this.state.history.left)) && last.module && loc.module && last.module.url === loc.module.url) {
                this.state.history.left.pop();
              }

              this.state.history.left.push(loc);
            }

            this.refreshHistoryButtons();
          }
        }, {
          key: "refreshHistoryButtons",
          value: function BrowserModel_refreshHistoryButtons_() {
            var _this$ui8 = this.ui,
                goBack = _this$ui8.goBack,
                goForward = _this$ui8.goForward;
            if (this.state.history.left.length < 2) goBack.disable();else goBack.enable();
            if (this.state.history.right.length === 0) goForward.disable();else goForward.enable();
          }
        }, {
          key: "historyReset",
          value: function BrowserModel_historyReset_() {
            this.state.history.left = [];
            this.state.history.right = [];
            this.state.history.navigationInProgress = null;
          }
        }, {
          key: "historySetLocation",
          value: function () {
            var _BrowserModel_historySetLocation_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee50(loc) {
              var hstate, _promise$deferred, navPromise, resolve, ed;

              return regeneratorRuntime.wrap(function _callee50$(_context50) {
                while (1) {
                  switch (_context50.prev = _context50.next) {
                    case 0:
                      if (loc) {
                        _context50.next = 2;
                        break;
                      }

                      return _context50.abrupt("return");

                    case 2:
                      hstate = this.state.history;

                      if (!hstate.navigationInProgress) {
                        _context50.next = 8;
                        break;
                      }

                      _context50.next = 6;
                      return hstate.navigationInProgress;

                    case 6:
                      this.historySetLocation(loc);
                      return _context50.abrupt("return");

                    case 8:
                      _promise$deferred = deferred(), navPromise = _promise$deferred.promise, resolve = _promise$deferred.resolve;
                      hstate.navigationInProgress = navPromise;
                      _context50.prev = 10;
                      ed = this.ui.sourceEditor;
                      _context50.next = 14;
                      return this.whenPackageUpdated();

                    case 14:
                      _context50.next = 16;
                      return this.whenModuleUpdated();

                    case 16:
                      if (!(!this.selectedPackage || loc["package"].address !== this.selectedPackage.address)) {
                        _context50.next = 19;
                        break;
                      }

                      _context50.next = 19;
                      return this.selectPackageNamed(loc["package"].address);

                    case 19:
                      if (!(!this.selectedModule || loc.module.url !== this.selectedModule.url)) {
                        _context50.next = 22;
                        break;
                      }

                      _context50.next = 22;
                      return this.selectModuleNamed(loc.module.url);

                    case 22:
                      ed.cursorPosition = loc.cursor;
                      ed.scroll = loc.scroll;
                      ed.scrollCursorIntoView();

                    case 25:
                      _context50.prev = 25;
                      hstate.navigationInProgress = null;
                      resolve();
                      return _context50.finish(25);

                    case 29:
                    case "end":
                      return _context50.stop();
                  }
                }
              }, _callee50, this, [[10,, 25, 29]]);
            }));

            function BrowserModel_historySetLocation_(_x38) {
              return _BrowserModel_historySetLocation_.apply(this, arguments);
            }

            return BrowserModel_historySetLocation_;
          }()
        }, {
          key: "makeTabsNotCloseable",
          value: function BrowserModel_makeTabsNotCloseable_() {
            this.ui.tabs.tabs.forEach(function (tab) {
              return tab.closeable = false;
            });
          }
        }, {
          key: "adaptViewForTabs",
          value: function BrowserModel_adaptViewForTabs_() {
            this.ui.columnView.top = this.ui.columnView.top + 32;
          }
        }, {
          key: "browsedTabChanged",
          value: function () {
            var _BrowserModel_browsedTabChanged_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee51(tabs) {
              var curr, prev, proceed, loading;
              return regeneratorRuntime.wrap(function _callee51$(_context51) {
                while (1) {
                  switch (_context51.prev = _context51.next) {
                    case 0:
                      curr = tabs.curr, prev = tabs.prev;

                      if (prev) {
                        _context51.next = 4;
                        break;
                      }

                      curr.closeable = false;
                      return _context51.abrupt("return");

                    case 4:
                      this.ui.tabs.tabs.forEach(function (tab) {
                        return tab.closeable = true;
                      });

                      if (!(this.selectedModule && this.hasUnsavedChanges())) {
                        _context51.next = 13;
                        break;
                      }

                      _context51.next = 8;
                      return this.warnForUnsavedChanges();

                    case 8:
                      proceed = _context51.sent;

                      if (proceed) {
                        _context51.next = 13;
                        break;
                      }

                      prev.setProperty("selected", true);
                      curr.closeSilently();
                      return _context51.abrupt("return");

                    case 13:
                      prev.content = {
                        config: this.browseSpec(),
                        history: this.state.history
                      };
                      prev.caption = "[".concat(prev.content.config.packageName, "]").concat(prev.content.config.moduleName ? "- " + prev.content.config.moduleName : "");

                      if (!curr.content) {
                        curr.content = {
                          config: $world.openedProject ? {
                            packageName: $world.openedProject.fullName,
                            moduleName: $world.openedProject.config.main || "index.js",
                            scroll: pt(0, 0)
                          } : {
                            packageName: "lively.morphic",
                            moduleName: "morph.js",
                            scroll: pt(0, 0)
                          },
                          history: {
                            left: [],
                            right: [],
                            navigationInProgress: null
                          }
                        };
                        curr.caption = $world.openedProject ? "[".concat($world.openedProject.fullName, "] - ").concat($world.openedProject.config.main || "index.js") : "[lively.morphic] - morph.js";
                      }

                      loading = open$1("Preparing Editor");
                      this.state.history = curr.content.history;
                      this.refreshHistoryButtons();
                      delete this.state.selectedModule;
                      _context51.next = 22;
                      return this.browse(curr.content.config);

                    case 22:
                      loading.remove();

                    case 23:
                    case "end":
                      return _context51.stop();
                  }
                }
              }, _callee51, this);
            }));

            function BrowserModel_browsedTabChanged_(_x39) {
              return _BrowserModel_browsedTabChanged_.apply(this, arguments);
            }

            return BrowserModel_browsedTabChanged_;
          }()
        }, {
          key: "onModuleChanged",
          value: function () {
            var _BrowserModel_onModuleChanged_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee52(evt) {
              var _this10 = this;

              var m, selectedModule, selectedPackage;
              return regeneratorRuntime.wrap(function _callee52$(_context52) {
                while (1) {
                  switch (_context52.prev = _context52.next) {
                    case 0:
                      if (!this.state.isSaving) {
                        _context52.next = 2;
                        break;
                      }

                      return _context52.abrupt("return");

                    case 2:
                      m = module$1(evt.module);
                      selectedModule = this.selectedModule, selectedPackage = this.selectedPackage;

                      if (selectedPackage) {
                        _context52.next = 6;
                        break;
                      }

                      return _context52.abrupt("return");

                    case 6:
                      if (!(!m["package"]() || m["package"]().address !== selectedPackage.address)) {
                        _context52.next = 8;
                        break;
                      }

                      return _context52.abrupt("return");

                    case 8:
                      if (!(selectedModule && selectedModule.url === m.id)) {
                        _context52.next = 20;
                        break;
                      }

                      if (!this.hasUnsavedChanges()) {
                        _context52.next = 18;
                        break;
                      }

                      this.addModuleChangeWarning(m.id);
                      _context52.t0 = string;
                      _context52.next = 14;
                      return m.source();

                    case 14:
                      _context52.t1 = _context52.sent;
                      this.state.sourceHash = _context52.t0.hashCode.call(_context52.t0, _context52.t1);
                      _context52.next = 20;
                      break;

                    case 18:
                      _context52.next = 20;
                      return this.ui.sourceEditor.saveExcursion(function () {
                        _this10.onModuleSelected(selectedModule, false);
                      });

                    case 20:
                    case "end":
                      return _context52.stop();
                  }
                }
              }, _callee52, this);
            }));

            function BrowserModel_onModuleChanged_(_x40) {
              return _BrowserModel_onModuleChanged_.apply(this, arguments);
            }

            return BrowserModel_onModuleChanged_;
          }()
        }, {
          key: "onModuleLoaded",
          value: function () {
            var _BrowserModel_onModuleLoaded_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee53(evt) {
              var m, selectedPackage;
              return regeneratorRuntime.wrap(function _callee53$(_context53) {
                while (1) {
                  switch (_context53.prev = _context53.next) {
                    case 0:
                      if (!this.state.isSaving) {
                        _context53.next = 2;
                        break;
                      }

                      return _context53.abrupt("return");

                    case 2:
                      m = module$1(evt.module);
                      selectedPackage = this.selectedPackage;

                      if (!selectedPackage || !m["package"]() || m["package"]().address !== selectedPackage.address) ;

                    case 5:
                    case "end":
                      return _context53.stop();
                  }
                }
              }, _callee53, this);
            }));

            function BrowserModel_onModuleLoaded_(_x41) {
              return _BrowserModel_onModuleLoaded_.apply(this, arguments);
            }

            return BrowserModel_onModuleLoaded_;
          }()
        }, {
          key: "addModuleChangeWarning",
          value: function BrowserModel_addModuleChangeWarning_(mid) {
            this.state.moduleChangeWarning = mid;
          }
        }, {
          key: "setStatusMessage",
          value: function BrowserModel_setStatusMessage_() {
            var ed = this.ui.sourceEditor;
            return ed.setStatusMessage.apply(ed, arguments);
          }
        }, {
          key: "onWindowClose",
          value: function () {
            var _BrowserModel_onWindowClose_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee54() {
              var proceed;
              return regeneratorRuntime.wrap(function _callee54$(_context54) {
                while (1) {
                  switch (_context54.prev = _context54.next) {
                    case 0:
                      proceed = true;

                      if (!this.hasUnsavedChanges()) {
                        _context54.next = 5;
                        break;
                      }

                      _context54.next = 4;
                      return this.warnForUnsavedChanges();

                    case 4:
                      proceed = _context54.sent;

                    case 5:
                      if (!proceed) {
                        _context54.next = 9;
                        break;
                      }

                      _context54.next = 8;
                      return this.cleanupActiveEditSessions();

                    case 8:
                      proceed = _context54.sent;

                    case 9:
                      return _context54.abrupt("return", proceed);

                    case 10:
                    case "end":
                      return _context54.stop();
                  }
                }
              }, _callee54, this);
            }));

            function BrowserModel_onWindowClose_() {
              return _BrowserModel_onWindowClose_.apply(this, arguments);
            }

            return BrowserModel_onWindowClose_;
          }()
        }, {
          key: "cleanupActiveEditSessions",
          value: function () {
            var _BrowserModel_cleanupActiveEditSessions_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee55() {
              var activeSessions, _iterator3, _step3, session;

              return regeneratorRuntime.wrap(function _callee55$(_context55) {
                while (1) {
                  switch (_context55.prev = _context55.next) {
                    case 0:
                      activeSessions = this.activeComponentEditSessions();
                      _iterator3 = _createForOfIteratorHelper(activeSessions);
                      _context55.prev = 2;

                      _iterator3.s();

                    case 4:
                      if ((_step3 = _iterator3.n()).done) {
                        _context55.next = 12;
                        break;
                      }

                      session = _step3.value;
                      _context55.next = 8;
                      return session.terminateIfNoEditorExcept();

                    case 8:
                      if (_context55.sent) {
                        _context55.next = 10;
                        break;
                      }

                      return _context55.abrupt("return", false);

                    case 10:
                      _context55.next = 4;
                      break;

                    case 12:
                      _context55.next = 17;
                      break;

                    case 14:
                      _context55.prev = 14;
                      _context55.t0 = _context55["catch"](2);

                      _iterator3.e(_context55.t0);

                    case 17:
                      _context55.prev = 17;

                      _iterator3.f();

                      return _context55.finish(17);

                    case 20:
                      delete this.ui.sourceEditor._confirmedProceed;
                      return _context55.abrupt("return", true);

                    case 22:
                    case "end":
                      return _context55.stop();
                  }
                }
              }, _callee55, this, [[2, 14, 17, 20]]);
            }));

            function BrowserModel_cleanupActiveEditSessions_() {
              return _BrowserModel_cleanupActiveEditSessions_.apply(this, arguments);
            }

            return BrowserModel_cleanupActiveEditSessions_;
          }()
        }, {
          key: "focus",
          value: function BrowserModel_focus_(evt) {
            var sourceEditor = this.ui.sourceEditor;
            sourceEditor.focus();
          }
        }, {
          key: "focusSourceEditor",
          value: function BrowserModel_focusSourceEditor_() {
            this.ui.sourceEditor.focus();
            this.ui.sourceEditor.show();
          }
        }, {
          key: "focusColumnView",
          value: function BrowserModel_focusColumnView_() {
            this.models.columnView.focusActiveList();
          }
        }, {
          key: "keybindings",
          get: function get() {
            return [{
              keys: {
                mac: "Meta-S",
                win: "Ctrl-S"
              },
              command: "browser save"
            }, {
              keys: "Alt-Up",
              command: "focus list with selection"
            }, {
              keys: "F1",
              command: "focus module list"
            }, {
              keys: "F2",
              command: "focus code entities"
            }, {
              keys: "F3|Alt-Down",
              command: "focus source editor"
            }, {
              keys: "F4",
              command: "resize editor panel"
            }, {
              keys: "Alt-R",
              command: "reload module"
            }, {
              keys: "Alt-Ctrl-R",
              command: {
                command: "reload module",
                args: {
                  hard: true
                }
              }
            }, {
              keys: "Alt-L",
              command: "load or add module"
            }, {
              keys: "Ctrl-C Ctrl-T",
              command: "run all tests in module"
            }, {
              keys: "Ctrl-C T",
              command: "run tests at point"
            }, {
              keys: "Ctrl-C B E F",
              command: "run setup code of tests (before and beforeEach)"
            }, {
              keys: "Ctrl-C A F T",
              command: "run teardown code of tests (after and afterEach)"
            }, {
              keys: "Alt-P",
              command: "browser history backward"
            }, {
              keys: "Alt-N",
              command: "browser history forward"
            }, {
              keys: "Alt-H",
              command: "browser history browse"
            }, {
              keys: "Meta-Shift-L b a c k e n d",
              command: "activate eval backend dropdown list"
            }, {
              keys: "Alt-J",
              command: "jump to codeentity"
            }, {
              keys: "Meta-N",
              command: "open new tab"
            }].concat(this.ui.tabs.keybindings);
          }
        }, {
          key: "commands",
          get: function get() {
            return browserCommands(this).concat(EvalBackendChooser["default"].activateEvalBackendCommand(this)).concat(this.ui.tabs.commands);
          }
        }, {
          key: "renderMarkdown",
          value: function BrowserModel_renderMarkdown_() {
            var openInWorld = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            this.ui.sourceEditor.execCommand("[markdown] convert to html", {
              openInWorld: openInWorld
            });
          }
        }, {
          key: "interactivelyJumpToCodeentity",
          value: function () {
            var _BrowserModel_interactivelyJumpToCodeentity_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee56() {
              var _this$ui9, ed, columnView, codeEntities, currentIdx, items, _yield$this$world$fil, _yield$this$world$fil2, choice;

              return regeneratorRuntime.wrap(function _callee56$(_context56) {
                while (1) {
                  switch (_context56.prev = _context56.next) {
                    case 0:
                      _this$ui9 = this.ui, ed = _this$ui9.sourceEditor, columnView = _this$ui9.columnView;

                      if (!this.isTestModule(ed.textString)) {
                        _context56.next = 3;
                        break;
                      }

                      return _context56.abrupt("return", this.execCommand("jump to test"));

                    case 3:
                      if (!this.isMarkdown(this.selectedModule)) {
                        _context56.next = 5;
                        break;
                      }

                      return _context56.abrupt("return", ed.execCommand("[markdown] goto heading"));

                    case 5:
                      codeEntities = this.renderedCodeEntities();
                      currentIdx = codeEntities.indexOf(columnView._selectedNode);
                      items = codeEntities.map(function (def) {
                        var name = def.name,
                            type = def.type,
                            parent = def.parent;
                        return {
                          isListItem: true,
                          label: ["".concat(parent ? parent.name + ">>" : "").concat(name), null, "".concat(type), {
                            fontSize: "70%",
                            textStyleClasses: ["annotation"]
                          }],
                          value: def
                        };
                      });
                      _context56.next = 10;
                      return this.world().filterableListPrompt("Select item", items, {
                        preselect: currentIdx,
                        requester: this.view,
                        historyId: "js-browser-codeentity-jump-hist"
                      });

                    case 10:
                      _yield$this$world$fil = _context56.sent;
                      _yield$this$world$fil2 = _slicedToArray(_yield$this$world$fil.selected, 1);
                      choice = _yield$this$world$fil2[0];

                      if (choice) {
                        ed.saveMark();
                        this.selectCodeEntity(choice);
                      }

                    case 14:
                    case "end":
                      return _context56.stop();
                  }
                }
              }, _callee56, this);
            }));

            function BrowserModel_interactivelyJumpToCodeentity_() {
              return _BrowserModel_interactivelyJumpToCodeentity_.apply(this, arguments);
            }

            return BrowserModel_interactivelyJumpToCodeentity_;
          }()
        }, {
          key: "interactivelyJumpToTest",
          value: function () {
            var _BrowserModel_interactivelyJumpToTest_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee57() {
              var m, sourceEditor, source, items, testsByFile, lines, currentRow, preselect, _yield$import2, loadTestModuleAndExtractTestState, tests, _loop2, i, _yield$this$world$fil3, _yield$this$world$fil4, choice;

              return regeneratorRuntime.wrap(function _callee57$(_context57) {
                while (1) {
                  switch (_context57.prev = _context57.next) {
                    case 0:
                      m = this.selectedModule, sourceEditor = this.ui.sourceEditor;

                      if (m) {
                        _context57.next = 3;
                        break;
                      }

                      return _context57.abrupt("return", true);

                    case 3:
                      source = sourceEditor.textString;
                      items = [];
                      testsByFile = [];
                      lines = source.split("\n");
                      currentRow = sourceEditor.cursorPosition.row;
                      preselect = 0;
                      _context57.next = 11;
                      return module.import('./mocha-es6-5c28146c.js');

                    case 11:
                      _yield$import2 = _context57.sent;
                      loadTestModuleAndExtractTestState = _yield$import2.loadTestModuleAndExtractTestState;
                      _context57.next = 15;
                      return loadTestModuleAndExtractTestState(m.url, testsByFile);

                    case 15:
                      tests = testsByFile[0].tests.filter(function (ea) {
                        return ea.fullTitle;
                      });

                      _loop2 = function _loop2(i) {
                        var value = tests[i];
                        var depth = value.depth,
                            fullTitle = value.fullTitle,
                            title = value.title,
                            type = value.type;
                        var fnName = type === "suite" ? "describe" : "it";
                        var row = value.row = lines.findIndex(function (line) {
                          return line.match(new RegExp("".concat(fnName, ".*\".*").concat(title, ".*\"")));
                        });
                        if (row <= currentRow) preselect = i;
                        items.push({
                          isListItem: true,
                          value: value,
                          label: ["".concat("\u2002".repeat(depth - 1)).concat(fullTitle), null, "line ".concat(row, " ").concat(type), {
                            fontSize: "70%",
                            textStyleClasses: ["annotation"]
                          }]
                        });
                      };

                      for (i = 0; i < tests.length; i++) {
                        _loop2(i);
                      }

                      _context57.next = 20;
                      return this.world().filterableListPrompt("tests of ".concat(m.nameInPackage), items, {
                        requester: this.view,
                        preselect: preselect
                      });

                    case 20:
                      _yield$this$world$fil3 = _context57.sent;
                      _yield$this$world$fil4 = _slicedToArray(_yield$this$world$fil3.selected, 1);
                      choice = _yield$this$world$fil4[0];

                      if (choice) {
                        sourceEditor.saveMark();
                        sourceEditor.cursorPosition = {
                          row: choice.row,
                          column: 0
                        };
                        sourceEditor.execCommand("goto line start");
                        sourceEditor.centerRow(choice.row);
                      }

                      return _context57.abrupt("return", true);

                    case 25:
                    case "end":
                      return _context57.stop();
                  }
                }
              }, _callee57, this);
            }));

            function BrowserModel_interactivelyJumpToTest_() {
              return _BrowserModel_interactivelyJumpToTest_.apply(this, arguments);
            }

            return BrowserModel_interactivelyJumpToTest_;
          }()
        }, {
          key: "interactivelyAddOrLoadModule",
          value: function () {
            var _BrowserModel_interactivelyAddOrLoadModule_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee58(dir) {
              var p, m, system, requester, mods;
              return regeneratorRuntime.wrap(function _callee58$(_context58) {
                while (1) {
                  switch (_context58.prev = _context58.next) {
                    case 0:
                      p = this.selectedPackage;
                      m = this.selectedModule;
                      system = this.systemInterface;
                      requester = this.view;
                      _context58.prev = 4;
                      _context58.next = 7;
                      return system.interactivelyAddModule(requester, m ? m.name : p ? p.address : null);

                    case 7:
                      mods = _context58.sent;
                      _context58.next = 14;
                      break;

                    case 10:
                      _context58.prev = 10;
                      _context58.t0 = _context58["catch"](4);
                      _context58.t0 === "Canceled" ? requester.setStatusMessage(_context58.t0) : this.world().inform("Error while trying to load modules:\n".concat(_context58.t0.stack || _context58.t0), {
                        requester: requester
                      });
                      return _context58.abrupt("return");

                    case 14:
                      mods.forEach(function (_ref16) {
                        var name = _ref16.name,
                            error = _ref16.error;
                        return error ? requester.showError("Error while loading module ".concat(name, ": ").concat(error.stack || error)) : requester.setStatusMessage("Module ".concat(name, " loaded"));
                      });
                      _context58.next = 17;
                      return this.updateModuleList(p);

                    case 17:
                      mods.length && this.selectModuleNamed(mods[0].name);
                      return _context58.abrupt("return", true);

                    case 19:
                    case "end":
                      return _context58.stop();
                  }
                }
              }, _callee58, this, [[4, 10]]);
            }));

            function BrowserModel_interactivelyAddOrLoadModule_(_x42) {
              return _BrowserModel_interactivelyAddOrLoadModule_.apply(this, arguments);
            }

            return BrowserModel_interactivelyAddOrLoadModule_;
          }()
        }, {
          key: "interactivelyCreateNewFolder",
          value: function () {
            var _BrowserModel_interactivelyCreateNewFolder_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee59(dir) {
              var columnView, td, coreInterface, name, dirPath, parentNode;
              return regeneratorRuntime.wrap(function _callee59$(_context59) {
                while (1) {
                  switch (_context59.prev = _context59.next) {
                    case 0:
                      columnView = this.ui.columnView;
                      td = columnView.treeData;

                      if (dir) {
                        _context59.next = 4;
                        break;
                      }

                      return _context59.abrupt("return");

                    case 4:
                      coreInterface = this.systemInterface.coreInterface;
                      _context59.next = 7;
                      return this.world().prompt("Enter folder name", {
                        requester: this.view
                      });

                    case 7:
                      name = _context59.sent;

                      if (name) {
                        _context59.next = 10;
                        break;
                      }

                      return _context59.abrupt("return");

                    case 10:
                      dirPath = joinPath(dir, name);
                      if (!dirPath.endsWith("/")) dirPath += "/";
                      _context59.next = 14;
                      return coreInterface.resourceMkdir(dirPath);

                    case 14:
                      parentNode = columnView.getExpandedPath().find(function (n) {
                        return n.url === dir;
                      });

                      if (!parentNode) {
                        _context59.next = 18;
                        break;
                      }

                      _context59.next = 18;
                      return td.collapse(parentNode, false);

                    case 18:
                      columnView.selectNode(parentNode.subNodes.find(function (n) {
                        return n.url === dirPath;
                      }));

                    case 19:
                    case "end":
                      return _context59.stop();
                  }
                }
              }, _callee59, this);
            }));

            function BrowserModel_interactivelyCreateNewFolder_(_x43) {
              return _BrowserModel_interactivelyCreateNewFolder_.apply(this, arguments);
            }

            return BrowserModel_interactivelyCreateNewFolder_;
          }()
        }, {
          key: "interactivelyAddNewModule",
          value: function () {
            var _BrowserModel_interactivelyAddNewModule_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee60(dir, type) {
              var columnView, td, coreInterface, name, dirPath, parentNode;
              return regeneratorRuntime.wrap(function _callee60$(_context60) {
                while (1) {
                  switch (_context60.prev = _context60.next) {
                    case 0:
                      columnView = this.ui.columnView;
                      td = columnView.treeData;

                      if (dir) {
                        _context60.next = 4;
                        break;
                      }

                      return _context60.abrupt("return");

                    case 4:
                      coreInterface = this.systemInterface.coreInterface;
                      name = "";

                      if (!type) {
                        _context60.next = 13;
                        break;
                      }

                      _context60.next = 9;
                      return this.world().prompt(["Enter module name", null], {
                        requester: this.view
                      });

                    case 9:
                      name = _context60.sent;

                      if (name) {
                        name = name.replace(/(\.js|\.md|\.json)$/, "") + "." + type;
                      }

                      _context60.next = 19;
                      break;

                    case 13:
                      if (!(name !== undefined && !name.match(/(\.js|\.md|\.json)$/))) {
                        _context60.next = 19;
                        break;
                      }

                      _context60.next = 16;
                      return this.world().prompt({
                        title: "Enter module name",
                        text: ["Supported file types are:\n", {
                          fontSize: 16,
                          fontWeight: "normal"
                        }, "markdown (.md)\nJavascript (.js)\nJSON (.json)", {
                          fontWeight: "normal",
                          fontSize: 16,
                          fontStyle: "italic"
                        }]
                      }, {
                        requester: this.view
                      });

                    case 16:
                      name = _context60.sent;
                      _context60.next = 13;
                      break;

                    case 19:
                      if (name) {
                        _context60.next = 21;
                        break;
                      }

                      return _context60.abrupt("return");

                    case 21:
                      dirPath = joinPath(dir, name);
                      _context60.next = 24;
                      return coreInterface.resourceEnsureExistance(dirPath, "'format esm';");

                    case 24:
                      parentNode = columnView.getExpandedPath().find(function (n) {
                        return n.url === dir;
                      });

                      if (!parentNode) {
                        _context60.next = 28;
                        break;
                      }

                      _context60.next = 28;
                      return td.collapse(parentNode, false);

                    case 28:
                      columnView.selectNode(parentNode.subNodes.find(function (n) {
                        return n.url === dirPath;
                      }));

                    case 29:
                    case "end":
                      return _context60.stop();
                  }
                }
              }, _callee60, this);
            }));

            function BrowserModel_interactivelyAddNewModule_(_x44, _x45) {
              return _BrowserModel_interactivelyAddNewModule_.apply(this, arguments);
            }

            return BrowserModel_interactivelyAddNewModule_;
          }()
        }, {
          key: "interactivelyBrowseHistory",
          value: function () {
            var _BrowserModel_interactivelyBrowseHistory_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee61() {
              var _this$state$history, left, right, current, currentIdx, items, _yield$this$world$fil5, _yield$this$world$fil6, choice, _this$historyGetLocat3, scroll, cursor;

              return regeneratorRuntime.wrap(function _callee61$(_context61) {
                while (1) {
                  switch (_context61.prev = _context61.next) {
                    case 0:
                      _this$state$history = this.state.history, left = _this$state$history.left, right = _this$state$history.right;
                      current = last$2(left);
                      currentIdx = left.indexOf(current);
                      items = left.concat(right).map(function (loc) {
                        return {
                          isListItem: true,
                          string: loc.module ? loc["package"] ? loc["package"].name + " - " + loc.module.nameInPackage : loc.module.nameInPackage : loc["package"] ? loc["package"].name || loc["package"].address : "strange location",
                          value: loc
                        };
                      });
                      _context61.next = 6;
                      return this.world().filterableListPrompt("Jump to location", items, {
                        preselect: currentIdx,
                        requester: this.view
                      });

                    case 6:
                      _yield$this$world$fil5 = _context61.sent;
                      _yield$this$world$fil6 = _slicedToArray(_yield$this$world$fil5.selected, 1);
                      choice = _yield$this$world$fil6[0];

                      if (!choice) {
                        _context61.next = 14;
                        break;
                      }

                      if (left.includes(choice)) {
                        this.state.history.left = left.slice(0, left.indexOf(choice) + 1);
                        this.state.history.right = left.slice(left.indexOf(choice) + 1).concat(right);
                      } else if (right.includes(choice)) {
                        this.state.history.left = left.concat(right.slice(0, right.indexOf(choice) + 1));
                        this.state.history.right = right.slice(right.indexOf(choice) + 1);
                      }

                      if (current) {
                        _this$historyGetLocat3 = this.historyGetLocation(), scroll = _this$historyGetLocat3.scroll, cursor = _this$historyGetLocat3.cursor;
                        current.scroll = scroll;
                        current.cursor = cursor;
                      }

                      _context61.next = 14;
                      return this.historySetLocation(choice);

                    case 14:
                      return _context61.abrupt("return", true);

                    case 15:
                    case "end":
                      return _context61.stop();
                  }
                }
              }, _callee61, this);
            }));

            function BrowserModel_interactivelyBrowseHistory_() {
              return _BrowserModel_interactivelyBrowseHistory_.apply(this, arguments);
            }

            return BrowserModel_interactivelyBrowseHistory_;
          }()
        }, {
          key: "interactivelyRemoveSelectedItem",
          value: function () {
            var _BrowserModel_interactivelyRemoveSelectedItem_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee62(dir) {
              var selectedPackage, columnView, systemInterface, coreInterface, td, parentNode, selectedNodeInDir, textStyle, removed, proceed, pkg, modulesToRemove, _iterator4, _step4, mod;

              return regeneratorRuntime.wrap(function _callee62$(_context62) {
                while (1) {
                  switch (_context62.prev = _context62.next) {
                    case 0:
                      selectedPackage = this.selectedPackage, columnView = this.ui.columnView, systemInterface = this.systemInterface;
                      coreInterface = systemInterface.coreInterface;
                      td = columnView.treeData;

                      if (!(!dir || !selectedPackage)) {
                        _context62.next = 5;
                        break;
                      }

                      return _context62.abrupt("return");

                    case 5:
                      parentNode = columnView.getExpandedPath().find(function (n) {
                        return n.url === dir;
                      });
                      selectedNodeInDir = parentNode.subNodes.find(function (n) {
                        return !n.isCollapsed;
                      });
                      textStyle = {
                        fontSize: 16,
                        fontWeight: "normal"
                      };

                      if (selectedNodeInDir) {
                        _context62.next = 10;
                        break;
                      }

                      return _context62.abrupt("return");

                    case 10:
                      if (!this.isModule(selectedNodeInDir)) {
                        _context62.next = 23;
                        break;
                      }

                      removed = false;

                      if (!selectedNodeInDir.url.match(/(\.md|\.json)$/)) {
                        _context62.next = 18;
                        break;
                      }

                      _context62.next = 15;
                      return this.execCommand("remove module");

                    case 15:
                      removed = _context62.sent;
                      _context62.next = 21;
                      break;

                    case 18:
                      _context62.next = 20;
                      return this.execCommand("remove module", {
                        mod: selectedNodeInDir
                      });

                    case 20:
                      removed = _context62.sent;

                    case 21:
                      if (removed) {
                        this.deactivateEditor();
                        this.world().withAllSubmorphsSelect(function (m) {
                          var _m$selectedModule;

                          return m.isBrowser && ((_m$selectedModule = m.selectedModule) === null || _m$selectedModule === void 0 ? void 0 : _m$selectedModule.url) === selectedNodeInDir.url;
                        }).forEach(function (m) {
                          return m.getWindow().close(false);
                        });
                      }

                      return _context62.abrupt("return");

                    case 23:
                      if (!(selectedNodeInDir.type === "directory")) {
                        _context62.next = 52;
                        break;
                      }

                      _context62.next = 26;
                      return this.world().confirm(["Folder removal\n", {}, "You are about to remove a folder containing several modules. ", textStyle, "All of these modules will be immediately unloaded from the system.\n", textStyle, "This may potentially crash the system, especially if the modules in question are currently in use by one or more objects. Proceed with caution.", textStyle], {
                        width: 400,
                        requester: this.view
                      });

                    case 26:
                      proceed = _context62.sent;

                      if (proceed) {
                        _context62.next = 29;
                        break;
                      }

                      return _context62.abrupt("return");

                    case 29:
                      _context62.next = 31;
                      return coreInterface.getPackage(selectedPackage.address);

                    case 31:
                      pkg = _context62.sent;
                      modulesToRemove = pkg.modules.filter(function (m) {
                        return m.name.startsWith(selectedNodeInDir.url);
                      });
                      _iterator4 = _createForOfIteratorHelper(modulesToRemove);
                      _context62.prev = 34;

                      _iterator4.s();

                    case 36:
                      if ((_step4 = _iterator4.n()).done) {
                        _context62.next = 42;
                        break;
                      }

                      mod = _step4.value;
                      _context62.next = 40;
                      return this.execCommand("remove module", {
                        mod: mod
                      });

                    case 40:
                      _context62.next = 36;
                      break;

                    case 42:
                      _context62.next = 47;
                      break;

                    case 44:
                      _context62.prev = 44;
                      _context62.t0 = _context62["catch"](34);

                      _iterator4.e(_context62.t0);

                    case 47:
                      _context62.prev = 47;

                      _iterator4.f();

                      return _context62.finish(47);

                    case 50:
                      _context62.next = 52;
                      return coreInterface.resourceRemove(selectedNodeInDir.url);

                    case 52:
                      if (!parentNode) {
                        _context62.next = 55;
                        break;
                      }

                      _context62.next = 55;
                      return td.collapse(parentNode, false);

                    case 55:
                      this.updateModuleList();

                    case 56:
                    case "end":
                      return _context62.stop();
                  }
                }
              }, _callee62, this, [[34, 44, 47, 50]]);
            }));

            function BrowserModel_interactivelyRemoveSelectedItem_(_x46) {
              return _BrowserModel_interactivelyRemoveSelectedItem_.apply(this, arguments);
            }

            return BrowserModel_interactivelyRemoveSelectedItem_;
          }()
        }, {
          key: "browseSnippetForSelection",
          value: function BrowserModel_browseSnippetForSelection_() {
            var p = this.selectedPackage;
            var m = this.selectedModule;
            var c = this.selectedCodeEntity;
            var sysI = this.systemInterface;
            var codeSnip = "$world.execCommand(\"open browser\", {";

            if (m) {
              codeSnip += "moduleName: \"".concat(m.nameInPackage, "\", ");
              if (p) codeSnip += "packageName: \"".concat(p.name, "\", ");
            } else {
              if (p) codeSnip += " packageName: \"".concat(p.name, "\", ");
            }

            if (c) {
              codeSnip += "codeEntity: ".concat(isArray$2(c) ? JSON.stringify(c.map(function (c) {
                return select(c, ["name", "type"]);
              })) : "\"".concat(c.name, "\""));
            }

            if (sysI.name !== "local") codeSnip += ", systemInterface: \"".concat(sysI.name, "\"");
            codeSnip += "});";
            return codeSnip;
          }
        }, {
          key: "menuItems",
          value: function BrowserModel_menuItems_() {
            var _this11 = this;

            var td = this.ui.columnView.treeData;
            var ed = this.ui.sourceEditor;
            var checked = Icon.textAttribute("check-square", {
              paddingRight: "3px"
            });
            var unchecked = Icon.textAttribute("square", {
              paddingRight: "3px"
            });
            Object.assign(checked[1], {
              "float": "none",
              display: "inline"
            });
            var p = this.selectedPackage;
            var m = this.selectedModule;
            return [p && {
              command: "open browse snippet",
              target: this,
              showKeyShortcuts: false
            }, m && {
              command: "open selected module in text editor",
              target: this,
              showKeyShortcuts: false
            }, (m || p) && {
              isDivider: true
            }, [[].concat(_toConsumableArray$1(td.showDependencyPackages ? checked : unchecked), [" " + "Display Dependency Packages", {
              "float": "none"
            }]), function () {
              _this11.showDependencyPackages(!td.showDependencyPackages);
            }], [[].concat(_toConsumableArray$1(td.showPkgVersion ? checked : unchecked), [" " + "Display Packages Version Number", {
              "float": "none"
            }]), function () {
              _this11.showPackageVersionNumber(!td.showPkgVersion);
            }], [[].concat(_toConsumableArray$1(td.showHiddenFolders ? checked : unchecked), [" " + "Show Hidden Folders", {
              "float": "none"
            }]), function () {
              _this11.showHiddenFolders(!td.showHiddenFolders);
            }], [[].concat(_toConsumableArray$1(ed.textMap ? checked : unchecked), [" " + "Display Code Map", {
              "float": "none"
            }]), function () {
              _this11.toggleTextMap(!ed.textMap);
            }]].filter(Boolean);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "BrowserModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              systemInterface: {
                derived: true,
                readOnly: true,
                after: ["editorPlugin"],
                get: function get() {
                  var env = this.editorPlugin.evalEnvironment;

                  try {
                    return this.editorPlugin.systemInterface();
                  } catch (err) {
                    return env.systemInterface;
                  }
                },
                set: function set(systemInterface) {
                  this.editorPlugin.setSystemInterfaceNamed(systemInterface);
                }
              },
              associatedSearchPanel: {
                derived: true,
                get: function get() {
                  return this.state.associatedSearchPanel;
                },
                set: function set(panel) {
                  this.state.associatedSearchPanel = panel;
                }
              },
              editorPlugin: {
                readOnly: true,
                derived: true,
                get: function get() {
                  return this.ui.sourceEditor.pluginFind(function (p) {
                    return p.isEditorPlugin;
                  });
                }
              },
              expose: {
                get: function get() {
                  return ["isBrowser", "focus", "keybindings", "browse", "browserFromConfig", "browseSnippetForSelection", "commands", "systemInterface", "selectedModule", "selectedPackage", "selectedCodeEntity", "selectCodeEntity", "selectPackageNamed", "setEvalBackend", "editorPlugin", "isTestModule", "reloadModule", "renderedCodeEntities", "focusSourceEditor", "historyBackward", "historyForward", "save", "hasUnsavedChanges", "interactivelyBrowseHistory", "interactivelyAddNewModule", "interactivelyCreateNewFolder", "interactivelyRemoveSelectedItem", "searchForModuleAndSelect", "updateModuleList", "onWindowClose", "onModuleLoaded", "onModuleChanged", "showDependencyPackages", "showPackageVersionNumber", "showHiddenFolders", "menuItems", "resetChangedContentIndicator", "formatPackageName", "toggleWindowStyle", "relayout", "ensureColumnViewData", "state", "updateFocusedCodeEntityDebounced", {
                    method: "serializeBrowser",
                    as: "__serialize__"
                  }];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    signal: "extent",
                    handler: "relayout"
                  }, {
                    target: "global search",
                    signal: "fire",
                    handler: "execCommand",
                    converter: function converter() {
                      return "open code search";
                    }
                  }, {
                    target: "go back",
                    signal: "fire",
                    handler: "execCommand",
                    converter: function converter() {
                      return "browser history backward";
                    }
                  }, {
                    target: "go forward",
                    signal: "fire",
                    handler: "execCommand",
                    converter: function converter() {
                      return "browser history forward";
                    }
                  }, {
                    target: "browse history",
                    signal: "fire",
                    handler: "execCommand",
                    converter: function converter() {
                      return "browser history browse";
                    }
                  }, {
                    target: "browse modules",
                    signal: "fire",
                    handler: "execCommand",
                    converter: function converter() {
                      return "choose and browse module";
                    }
                  }, {
                    target: "add tab",
                    signal: "fire",
                    handler: "execCommand",
                    converter: function converter() {
                      return "open new tab";
                    }
                  }, {
                    target: "run tests in module",
                    signal: "onMouseDown",
                    handler: "execCommand",
                    converter: function converter() {
                      return "run all tests in module";
                    }
                  }, {
                    target: "jump to entity",
                    signal: "onMouseDown",
                    handler: "execCommand",
                    converter: function converter() {
                      return "jump to codeentity";
                    }
                  }, {
                    target: "export to html",
                    signal: "onMouseDown",
                    handler: "renderMarkdown"
                  }, {
                    target: "copy to clipboard",
                    signal: "onMouseDown",
                    handler: "execCommand",
                    converter: function converter() {
                      return "open browse snippet";
                    }
                  }, {
                    target: "freeze button",
                    signal: "onMouseDown",
                    handler: "execCommand",
                    converter: function converter() {
                      return "freeze selected module";
                    }
                  }, {
                    target: "open in editor",
                    signal: "onMouseDown",
                    handler: "execCommand",
                    converter: function converter() {
                      return "open selected module in text editor";
                    }
                  }, {
                    target: "close button",
                    signal: "onMouseDown",
                    handler: "closeStatusMessage"
                  }, {
                    target: "open in workspace",
                    signal: "onMouseDown",
                    handler: "openStatusMessage"
                  }, {
                    target: "column view",
                    signal: "selectionChange",
                    handler: "onListSelectionChange"
                  }, {
                    target: "source editor",
                    signal: "textChange",
                    handler: "updateUnsavedChangeIndicatorDebounced"
                  }, {
                    target: "source editor",
                    signal: "onMouseDown",
                    handler: "updateFocusedCodeEntity"
                  }, {
                    target: "source editor",
                    signal: "onScroll",
                    handler: "repositionComponentEditButtons"
                  }, {
                    target: "source editor",
                    signal: "addPlugin",
                    handler: "toggleComponentControlsOnOccur"
                  }, {
                    target: "source editor",
                    signal: "removePlugin",
                    handler: "toggleComponentControlsOnOccur"
                  }, {
                    target: "source editor",
                    signal: "textString",
                    handler: "resetComponentControls"
                  }, {
                    target: "tabs",
                    signal: "onSelectedTabChange",
                    handler: "browsedTabChanged"
                  }, {
                    target: "tabs",
                    signal: "oneTabRemaining",
                    handler: "makeTabsNotCloseable"
                  }, {
                    target: "tabs",
                    signal: "becameVisible",
                    handler: "relayout"
                  }, {
                    target: "tabs",
                    signal: "becameInvisible",
                    handler: "relayout"
                  }, {
                    signal: "onWindowActivated",
                    handler: "allowKeyboardNavigation"
                  }, {
                    signal: "onWindowDeactivated",
                    handler: "prohibitKeyboardNavigation"
                  }, {
                    signal: "toggleFader",
                    handler: "updateKeyboardNavigation"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/browser/index.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 17409,
          end: 93569
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$e.BrowserModel = BrowserModel;
      __varRecorder__$e.BrowserModel = BrowserModel;

      var __varRecorder__$d = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/tabs.cp.js", __contextModule__);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/tabs.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("TabCloseButton") && typeof __lively_classholder__.TabCloseButton === "function" ? __lively_classholder__.TabCloseButton : __lively_classholder__.TabCloseButton = function TabCloseButton(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "tab",
          get: function get() {
            return this.owner.owner;
          }
        }, {
          key: "onMouseUp",
          value: function TabCloseButton_onMouseUp_() {
            this.owner.owner.close();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "TabCloseButton";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/tabs.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 254,
          end: 392
        });
      })({
        referencedAs: "Label",
        value: Label
      });

      __varRecorder__$d.DefaultTab = component["for"](function () {
        return component({
          name: "tab",
          borderColor: Color.rgb(0, 0, 0),
          borderRadius: {
            bottomLeft: 0,
            bottomRight: 0,
            topLeft: 5,
            topRight: 5
          },
          clipMode: "hidden",
          extent: pt(300, 32),
          fill: new LinearGradient({
            stops: [{
              offset: 0,
              color: Color.white
            }, {
              offset: 1,
              color: Color.rgb(236, 240, 241)
            }],
            vector: 0
          }),
          layout: new TilingLayout({
            axisAlign: "center",
            resizePolicies: [["horizontal container", {
              height: "fixed",
              width: "fill"
            }]]
          }),
          submorphs: [{
            name: "horizontal container",
            halosEnabled: false,
            borderStyle: "none",
            fill: Color.rgba(0, 0, 0, 0),
            reactsToPointer: false,
            layout: new TilingLayout({
              padding: rect(6, 6, 0, 0),
              resizePolicies: [["tab caption", {
                height: "fixed",
                width: "fill"
              }]]
            }),
            submorphs: [{
              type: Label,
              halosEnabled: false,
              name: "tab caption",
              fill: Color.transparent,
              fixedWidth: true,
              fontColor: Color.rgba(0, 0, 0, 0.5),
              reactsToPointer: false,
              textAndAttributes: ["tab caption", null]
            }, {
              type: __varRecorder__$d.TabCloseButton,
              name: "tab close",
              halosEnabled: false,
              fontColor: Color.rgba(0, 0, 0, 0.5),
              nativeCursor: "pointer",
              textAndAttributes: Icon.textAttribute("times")
            }]
          }]
        });
      }, {
        module: "lively.ide/studio/tabs.cp.js",
        "export": "DefaultTab",
        range: {
          start: 400,
          end: 1736
        }
      }, System, __varRecorder__$d, "DefaultTab");
      __varRecorder__$d.HoverTab = component["for"](function () {
        return component(__varRecorder__$d.DefaultTab, {
          fill: Color.rgb(245, 245, 245)
        });
      }, {
        module: "lively.ide/studio/tabs.cp.js",
        "export": "HoverTab",
        range: {
          start: 1745,
          end: 1815
        }
      }, System, __varRecorder__$d, "HoverTab");
      __varRecorder__$d.ActiveTab = component["for"](function () {
        return component(__varRecorder__$d.DefaultTab, {
          fill: Color.rgb(183, 183, 183)
        });
      }, {
        module: "lively.ide/studio/tabs.cp.js",
        "export": "ActiveTab",
        range: {
          start: 1824,
          end: 1895
        }
      }, System, __varRecorder__$d, "ActiveTab");
      __varRecorder__$d.SelectedTab = component["for"](function () {
        return component(__varRecorder__$d.DefaultTab, {
          borderWidth: {
            bottom: 3,
            top: 0,
            right: 0,
            left: 0
          },
          borderColor: Color.rgb(33, 47, 60),
          submorphs: [{
            name: "horizontal container",
            submorphs: [{
              name: "tab caption",
              fontColor: Color.rgba(0, 0, 0, 1)
            }, {
              name: "tab close",
              fontColor: Color.rgba(0, 0, 0, 1)
            }]
          }]
        });
      }, {
        module: "lively.ide/studio/tabs.cp.js",
        "export": "SelectedTab",
        range: {
          start: 1904,
          end: 2264
        }
      }, System, __varRecorder__$d, "SelectedTab");

      var TabModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/tabs.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("TabModel") && typeof __lively_classholder__.TabModel === "function" ? __lively_classholder__.TabModel : __lively_classholder__.TabModel = function TabModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "config",
          get: function get() {
            return {
              caption: this.caption,
              content: this.content,
              hasMorphicContent: this.hasMorphicContent,
              selected: this.selected,
              closeable: this.closeable,
              renamable: this.renameable
            };
          }
        }, {
          key: "menuItems",
          value: function TabModel_menuItems_() {
            var _this = this;

            if (!this.renameable) return;
            return [["Rename Tab", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var newName;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return $world.prompt("Tab name:", {
                        input: _this.caption
                      });

                    case 2:
                      newName = _context.sent;

                      if (newName) {
                        _this.caption = newName;
                      }

                    case 4:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }))]];
          }
        }, {
          key: "setAppearance",
          value: function TabModel_setAppearance_(isSelected) {
            this.view.master.setState(isSelected ? "selected" : null);
          }
        }, {
          key: "isTab",
          get: function get() {
            return true;
          }
        }, {
          key: "close",
          value: function TabModel_close_() {
            if (!this.closeable) {
              $world.setStatusMessage("This tab cannot be closed.");
              return;
            }

            signal(this.view, "onClose");

            if (this.hasMorphicContent && this.content) {
              this.content.remove();
            }

            this.view.remove();
          }
        }, {
          key: "closeSilently",
          value: function TabModel_closeSilently_() {
            this.view.remove();
          }
        }, {
          key: "onMouseUp",
          value: function TabModel_onMouseUp_(evt) {
            if (first(evt.targetMorphs) === this.ui.tabClose) return;

            if (!this.selected) {
              this.selected = true;
            }
          }
        }, {
          key: "viewDidLoad",
          value: function TabModel_viewDidLoad_() {
            this.caption = this.caption;
          }
        }, {
          key: "onRefresh",
          value: function TabModel_onRefresh_(prop) {
            if (prop === "selected") {
              this.setAppearance(this.selected);
            }
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "TabModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              defaultTabMaster: {
                initialize: function initialize() {
                  this.defaultTabMaster = __varRecorder__$d.DefaultTab;
                }
              },
              expose: {
                get: function get() {
                  return ["isTab", "content", "hasMorphicContent", "caption", "close", "selected", "closeable", "closeSilently", "config"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    signal: "onMouseUp",
                    handler: "onMouseUp"
                  }, {
                    signal: "menuItems",
                    handler: "menuItems",
                    override: true
                  }];
                }
              },
              caption: {
                defaultValue: "Unnamed Tab",
                set: function set(caption) {
                  if (!caption) return;
                  this.setProperty("caption", caption);
                  var captionLabel = this.ui.tabCaption;
                  if (captionLabel) captionLabel.textString = caption.length > 47 ? caption.substring(0, 47) + "..." : caption;
                  if (this.view) this.view.tooltip = caption;
                  this.name = caption + " tab";
                }
              },
              content: {
                defaultValue: undefined
              },
              hasMorphicContent: {
                defaultValue: true
              },
              selected: {
                defaultValue: false,
                set: function set(selected) {
                  this.setProperty("selected", selected);
                  signal(this.view, "onSelectionChange", selected);
                }
              },
              closeable: {
                defaultValue: true,
                set: function set(closeable) {
                  this.setProperty("closeable", closeable);

                  if (this.view) {
                    {
                      this.ui.tabClose.visible = closeable;
                      this.ui.tabClose.isLayoutable = closeable;
                      this.ui.tabCaption.padding = closeable ? rect(6, 3, -6, -2) : rect(6, 3, 0, -2);
                    }
                  }
                }
              },
              renameable: {
                defaultValue: true
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/tabs.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 2267,
          end: 5598
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      __varRecorder__$d.Tab = component["for"](function () {
        return component(__varRecorder__$d.DefaultTab, {
          name: "tab",
          defaultViewModel: __varRecorder__$d.TabModel,
          master: {
            auto: __varRecorder__$d.DefaultTab,
            click: __varRecorder__$d.ActiveTab,
            hover: __varRecorder__$d.HoverTab,
            states: {
              selected: __varRecorder__$d.SelectedTab
            }
          }
        });
      }, {
        module: "lively.ide/studio/tabs.cp.js",
        "export": "Tab",
        range: {
          start: 5632,
          end: 5828
        }
      }, System, __varRecorder__$d, "Tab");

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/tabs.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("TabContentContainerModel") && typeof __lively_classholder__.TabContentContainerModel === "function" ? __lively_classholder__.TabContentContainerModel : __lively_classholder__.TabContentContainerModel = function TabContentContainerModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onDrop",
          value: function TabContentContainerModel_onDrop_(evt) {
            var content = this.view.submorphs[0];

            if (content) {
              this.view.owner.addContentToSelectedTab(content);
            }
          }
        }, {
          key: "resize",
          value: function TabContentContainerModel_resize_(size) {
            var content = this.view.submorphs[0];
            if (!content) return;
            content.position = pt(0, 0);
            content.extent = size;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "TabContentContainerModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["resize"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    signal: "onDrop",
                    handler: "onDrop"
                  }, {
                    signal: "extent",
                    handler: "resize"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/tabs.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 5831,
          end: 6535
        });
      })({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      __varRecorder__$d.TabContentContainer = component["for"](function () {
        return component({
          name: "tab content container",
          defaultViewModel: __varRecorder__$d.TabContentContainerModel,
          fill: Color.white,
          halosEnabled: false,
          extent: pt(600, 375)
        });
      }, {
        module: "lively.ide/studio/tabs.cp.js",
        "export": "TabContentContainer",
        range: {
          start: 6636,
          end: 6818
        }
      }, System, __varRecorder__$d, "TabContentContainer");

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/tabs.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("TabContainerModel") && typeof __lively_classholder__.TabContainerModel === "function" ? __lively_classholder__.TabContainerModel : __lively_classholder__.TabContainerModel = function TabContainerModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "tabs",
          get: function get() {
            return this.ui.tabFlapContainer.submorphs.filter(function (submorph) {
              return submorph.isTab;
            });
          }
        }, {
          key: "scrollToRightmostTab",
          value: function TabContainerModel_scrollToRightmostTab_() {
            var _this2 = this;

            var node = this.ui.tabFlapScrollContainer.env.renderer.getNodeForMorph(this.ui.tabFlapScrollContainer);
            if (!node) return;
            this.view.whenRendered().then(function () {
              node.scrollLeft = 1000000;

              _this2.ui.tabFlapScrollContainer.setProperty("scroll", 1000000);
            });
          }
        }, {
          key: "add",
          value: function TabContainerModel_add_(aTab) {
            this.ui.tabFlapContainer.addMorph(aTab);
          }
        }, {
          key: "onMouseWheel",
          value: function TabContainerModel_onMouseWheel_(event) {
            var node = this.ui.tabFlapScrollContainer.env.renderer.getNodeForMorph(this.ui.tabFlapScrollContainer);
            var offset;

            if (Math.abs(event.domEvt.deltaY) > Math.abs(event.domEvt.deltaX)) {
              offset = event.domEvt.deltaY;
            } else {
              offset = event.domEvt.deltaX;
            }

            node.scrollLeft = node.scrollLeft + offset;
            this.ui.tabFlapScrollContainer.setProperty("scroll", pt(node.scrollLeft, node.scrollTop));
            event.stop();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "TabContainerModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["add", "tabs", "scrollToRightmostTab"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    signal: "onMouseWheel",
                    handler: "onMouseWheel"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/tabs.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 6821,
          end: 8234
        });
      })({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      __varRecorder__$d.NewTabButtonDefault = component["for"](function () {
        return component({
          name: "new tab button",
          extent: pt(32, 32),
          borderRadius: {
            topLeft: 5,
            bottomLeft: 0,
            bottomRight: 0,
            topRight: 0
          },
          fill: new LinearGradient({
            stops: [{
              offset: 0,
              color: Color.white
            }, {
              offset: 1,
              color: Color.rgb(236, 240, 241)
            }],
            vector: 0
          }),
          halosEnabled: false,
          layout: new TilingLayout({
            justifySubmorphs: "center",
            align: "center",
            axisAlign: "center"
          }),
          submorphs: [{
            type: Label,
            name: "new tab",
            halosEnabled: false,
            reactsToPointer: false,
            fontColor: Color.rgba(0, 0, 0, 0.5),
            nativeCursor: "pointer",
            padding: rect(2, 1, 0, 1),
            textAndAttributes: Icon.textAttribute("plus")
          }]
        });
      }, {
        module: "lively.ide/studio/tabs.cp.js",
        "export": "NewTabButtonDefault",
        range: {
          start: 8242,
          end: 8963
        }
      }, System, __varRecorder__$d, "NewTabButtonDefault");
      __varRecorder__$d.NewTabButtonHover = component["for"](function () {
        return component(__varRecorder__$d.NewTabButtonDefault, {
          fill: Color.rgb(245, 245, 245),
          submorphs: [{
            name: "new tab",
            fontColor: Color.rgba(0, 0, 0, 0.5)
          }]
        });
      }, {
        module: "lively.ide/studio/tabs.cp.js",
        "export": "NewTabButtonHover",
        range: {
          start: 8972,
          end: 9143
        }
      }, System, __varRecorder__$d, "NewTabButtonHover");
      __varRecorder__$d.NewTabButtonActive = component["for"](function () {
        return component(__varRecorder__$d.NewTabButtonDefault, {
          fill: Color.rgb(183, 183, 183),
          submorphs: [{
            name: "new tab",
            fontColor: Color.rgba(0, 0, 0, 0.5)
          }]
        });
      }, {
        module: "lively.ide/studio/tabs.cp.js",
        "export": "NewTabButtonActive",
        range: {
          start: 9152,
          end: 9324
        }
      }, System, __varRecorder__$d, "NewTabButtonActive");
      __varRecorder__$d.NewTabButton = component["for"](function () {
        return component(__varRecorder__$d.NewTabButtonDefault, {
          name: "new tab button",
          master: {
            hover: __varRecorder__$d.NewTabButtonHover,
            click: __varRecorder__$d.NewTabButtonActive,
            auto: __varRecorder__$d.NewTabButtonDefault
          }
        });
      }, {
        module: "lively.ide/studio/tabs.cp.js",
        "export": "NewTabButton",
        range: {
          start: 9333,
          end: 9554
        }
      }, System, __varRecorder__$d, "NewTabButton");
      __varRecorder__$d.TabContainer = component["for"](function () {
        return component({
          name: "tab container",
          defaultViewModel: __varRecorder__$d.TabContainerModel,
          extent: pt(600, 32),
          halosEnabled: false,
          fill: Color.transparent,
          layout: new TilingLayout({
            axisAlign: "center",
            resizePolicies: [["tab flap scroll container", {
              height: "fixed",
              width: "fill"
            }]]
          }),
          submorphs: [{
            name: "tab flap scroll container",
            extent: pt(525, 32),
            fill: Color.transparent,
            borderWidth: 0,
            clipMode: "hidden",
            submorphs: [{
              name: "tab flap container",
              fill: Color.transparent,
              borderWidth: 0,
              layout: new TilingLayout({
                axis: "row"
              })
            }]
          }]
        });
      }, {
        module: "lively.ide/studio/tabs.cp.js",
        "export": "TabContainer",
        range: {
          start: 9646,
          end: 10370
        }
      }, System, __varRecorder__$d, "TabContainer");

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/tabs.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("TabsModel") && typeof __lively_classholder__.TabsModel === "function" ? __lively_classholder__.TabsModel : __lively_classholder__.TabsModel = function TabsModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "loadFromConfig",
          value: function TabsModel_loadFromConfig_(configs) {
            var _iterator = _createForOfIteratorHelper(this.tabs),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var tab = _step.value;
                tab.closeSilently();
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            var _iterator2 = _createForOfIteratorHelper(configs),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var tabConfig = _step2.value;
                this.addTab(tabConfig.caption, tabConfig.content, tabConfig.selected, tabConfig.hasMorphicContent, tabConfig.selected, tabConfig.closeable, tabConfig.renameable);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        }, {
          key: "addTab",
          value: function TabsModel_addTab_(caption) {
            var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
            var selectAfterCreation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            var hasMorphicContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.providesContentContainer;
            var closeable = arguments.length > 4 ? arguments[4] : undefined;
            var renameable = arguments.length > 5 ? arguments[5] : undefined;
            var newTab = part(this.defaultTabMaster, {
              viewModel: {
                caption: caption,
                content: content,
                hasMorphicContent: hasMorphicContent,
                renameable: renameable,
                closeable: closeable
              }
            });
            this.initializeConnectionsFor(newTab);
            this.ui.tabContainer.add(newTab);
            newTab.selected = selectAfterCreation;
            this.updateVisibility(false);
            this.scrollToRightmostTab();
            return newTab;
          }
        }, {
          key: "updateVisibility",
          value: function TabsModel_updateVisibility_(closing) {
            if (!this.showsSingleTab && this.tabs.length > 1) {
              this.view.visible = true;
              signal(this, "becameVisible");
            }

            if (!this.showsSingleTab && this.tabs.length === 2 && closing) {
              this.view.visible = false;
              signal(this, "becameInvisible");
            }
          }
        }, {
          key: "initializeConnectionsFor",
          value: function TabsModel_initializeConnectionsFor_(tab) {
            connect(tab, "onSelectionChange", this, "showContent", {
              updater: "($update, selected) => {\n        if (selected) $update(source.content);\n      }"
            });
            connect(tab, "onSelectionChange", this, "deselectAllTabsExcept", {
              updater: "($update, selected) => {\n        if (selected) $update(source);\n      }"
            });
            connect(tab, "onSelectionChange", this, "onSelectedTabChange", {
              updater: "($update, selected) => { if (selected) $update({curr: source, prev: target._previouslySelectedTab}) }"
            });
            connect(tab, "onClose", this, "onTabClose", {
              converter: "() => source"
            });
          }
        }, {
          key: "disbandConnectionsFor",
          value: function TabsModel_disbandConnectionsFor_(closedTab) {
            disconnect(closedTab, "onSelectionChange", this, "showContent");
            disconnect(closedTab, "onSelectionChange", this, "deselectAllTabsExcept");
            disconnect(closedTab, "onSelectionChange", this, "onSelectedTabChange");
            disconnect(closedTab, "onClose", this, "onTabClose");
          }
        }, {
          key: "onSelectedTabChange",
          value: function TabsModel_onSelectedTabChange_(currAndPrevTabsObject) {
            signal(this.view, "onSelectedTabChange", currAndPrevTabsObject);
            this._previouslySelectedTab = currAndPrevTabsObject.curr;
            return currAndPrevTabsObject;
          }
        }, {
          key: "onTabClose",
          value: function TabsModel_onTabClose_(closedTab) {
            if (closedTab.selected) this.selectNearestTab(closedTab);

            if (this.tabs.length === 2) {
              signal(this.view, "oneTabRemaining");
            }

            if (this.tabs.length === 1) {
              this._previouslySelectedTab = undefined;
            }

            this.disbandConnectionsFor(closedTab);
            this.updateVisibility(true);
            return closedTab;
          }
        }, {
          key: "tabs",
          get: function get() {
            return this.ui.tabContainer.tabs;
          }
        }, {
          key: "deselectAllTabsExcept",
          value: function TabsModel_deselectAllTabsExcept_(excludedTab) {
            this.tabs.forEach(function (tab) {
              if (tab === excludedTab) return;
              tab.selected = false;
            });
          }
        }, {
          key: "selectNearestTab",
          value: function TabsModel_selectNearestTab_(otherTab) {
            if (this.tabs.length === 0) return;

            if (this.tabs.length === 1) {
              this.tabs[0].selected = true;
              return;
            }

            var tabIndex = this.tabs.indexOf(otherTab);
            var tab = tabIndex < this.tabs.length - 1 ? this.tabs[++tabIndex] : this.tabs[--tabIndex];
            tab.selected = true;
            return tab;
          }
        }, {
          key: "selectedTab",
          get: function get() {
            return this.tabs.find(function (tab) {
              return tab.selected;
            });
          }
        }, {
          key: "addContentToSelectedTab",
          value: function TabsModel_addContentToSelectedTab_(content) {
            if (!this.providesContentContainer) return;
            var tab = this.selectedTab;

            if (tab) {
              tab.content = content;
              this.showContent(content);
            }
          }
        }, {
          key: "showContent",
          value: function TabsModel_showContent_(content) {
            if (!this.providesContentContainer) return content;
            var container = this.ui.tabContentContainer;
            container.submorphs.forEach(function (submorph) {
              return submorph.remove();
            });

            if (content) {
              container.addMorph(content);
              content.position = pt(0, 0);
              content.extent = container.extent;
            }
          }
        }, {
          key: "viewDidLoad",
          value: function TabsModel_viewDidLoad_() {
            if (!this.providesContentContainer && this.ui.tabContentContainer) {
              this.ui.tabContentContainer.remove();
            }

            if (!this.showsSingleTab) this.view.visible = false;
          }
        }, {
          key: "keybindings",
          get: function get() {
            return [{
              keys: "Alt-W",
              command: "close current tab"
            }, {
              keys: "Alt-Q",
              command: "select previous tab"
            }, {
              keys: "Alt-Y",
              command: "select next tab"
            }];
          }
        }, {
          key: "commands",
          get: function get() {
            var _this3 = this;

            return [{
              name: "close current tab",
              exec: function exec() {
                _this3.selectedTab.close();
              }
            }, {
              name: "select previous tab",
              exec: function exec() {
                var i = _this3.tabs.indexOf(_this3.selectedTab);

                _this3.tabs[i === 0 ? _this3.tabs.length - 1 : i - 1].selected = true;
              }
            }, {
              name: "select next tab",
              exec: function exec() {
                var i = _this3.tabs.indexOf(_this3.selectedTab);

                _this3.tabs[i + 1 === _this3.tabs.length ? 0 : i + 1].selected = true;
              }
            }];
          }
        }, {
          key: "scrollToRightmostTab",
          value: function TabsModel_scrollToRightmostTab_() {
            this.ui.tabContainer.scrollToRightmostTab();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "TabsModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["addContentToSelectedTab", "addTab", "selectedTab", "keybindings", "commands", "tabs", "loadFromConfig", "becameVisible", "becameInvisible"];
                }
              },
              bindings: {
                get: function get() {
                  return [{}];
                }
              },
              providesContentContainer: {
                defaultValue: false
              },
              _previouslySelectedTab: {},
              showsSingleTab: {
                defaultValue: true
              },
              defaultTabMaster: {
                isComponent: true,
                initialize: function initialize() {
                  this.defaultTabMaster = __varRecorder__$d.Tab;
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/tabs.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 10373,
          end: 17005
        });
      })({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      __varRecorder__$d.Tabs = component["for"](function () {
        return component({
          name: "tabs",
          fill: Color.transparent,
          defaultViewModel: __varRecorder__$d.TabsModel,
          layout: new TilingLayout({
            axis: "column",
            resizePolicies: [["tab container", {
              height: "fixed",
              width: "fill"
            }]]
          }),
          submorphs: [part(__varRecorder__$d.TabContainer), part(__varRecorder__$d.TabContentContainer)]
        });
      }, {
        module: "lively.ide/studio/tabs.cp.js",
        "export": "Tabs",
        range: {
          start: 17114,
          end: 17425
        }
      }, System, __varRecorder__$d, "Tabs");
      var Tabs = __varRecorder__$d.Tabs;
      var DefaultTab = __varRecorder__$d.DefaultTab;
      var HoverTab = __varRecorder__$d.HoverTab;
      var ActiveTab = __varRecorder__$d.ActiveTab;
      var SelectedTab = __varRecorder__$d.SelectedTab;
      var Tab = __varRecorder__$d.Tab;
      __varRecorder__$d.TabModel = TabModel;
      __varRecorder__$d.Tabs = Tabs;
      __varRecorder__$d.DefaultTab = DefaultTab;
      __varRecorder__$d.HoverTab = HoverTab;
      __varRecorder__$d.ActiveTab = ActiveTab;
      __varRecorder__$d.SelectedTab = SelectedTab;
      __varRecorder__$d.Tab = Tab;

      var __varRecorder__$c = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/browser/ui.cp.js", __contextModule__);
      var __moduleMeta__$5 = {
        pathInPackage: function pathInPackage() {
          return "./js/browser/ui.cp.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var positionForAnchor = __varRecorder__$c["lively.ide/js/browser/ui.cp.js__define__"]("positionForAnchor", "function", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(context, anchor, morphToPosition) {
          var paddingToCode, bounds, pos, startPos;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (context === null || context === void 0 ? void 0 : context.isText) {
                    _context.next = 2;
                    break;
                  }

                  return _context.abrupt("return", morphToPosition.leftCenter);

                case 2:
                  if (context.renderingState.needsRerender) context.env.forceUpdate();
                  paddingToCode = 5;
                  bounds = context.charBoundsFromTextPosition(anchor.position);
                  pos = bounds.rightCenter().addXY(paddingToCode, 0);

                  if (pos.x + morphToPosition.width > context.width) {
                    startPos = context.charBoundsFromTextPosition({
                      row: anchor.position.row,
                      column: 0
                    });
                    pos = bounds.topRight().withY(startPos.top() - morphToPosition.height / 2).withX(context.width - morphToPosition.width);
                  }

                  return _context.abrupt("return", pos);

                case 8:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x, _x2, _x3) {
          return _ref.apply(this, arguments);
        };
      }(), __moduleMeta__$5);

      __varRecorder__$c.positionForAnchor = positionForAnchor;

      var ensureAnchor = __varRecorder__$c["lively.ide/js/browser/ui.cp.js__define__"]("ensureAnchor", "function", function (control) {
        var _declaration$declarat, _declaration$declarat2;

        var declaration = control.declaration,
            editor = control.editor;
        var varName = (_declaration$declarat = declaration.declarations[0]) === null || _declaration$declarat === void 0 ? void 0 : (_declaration$declarat2 = _declaration$declarat.id) === null || _declaration$declarat2 === void 0 ? void 0 : _declaration$declarat2.name;
        var anchor = editor.addAnchor(Object.assign({
          id: "Component->" + varName
        }, editor.screenLineRange(editor.indexToPosition(declaration.start)).end));
        connect(anchor, "position", control, "positionInLine", {
          updater: function updater($upd) {
            return $upd();
          }
        });
        return anchor;
      }, __moduleMeta__$5);

      __varRecorder__$c.ensureAnchor = ensureAnchor;

      var browse = __varRecorder__$c["lively.ide/js/browser/ui.cp.js__define__"]("browse", "function", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var browseSpec,
            browserOrProps,
            optSystemInterface,
            browser,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                browseSpec = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                browserOrProps = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
                optSystemInterface = _args2.length > 2 ? _args2[2] : undefined;
                browser = browserOrProps.isBrowser ? browserOrProps : part(__varRecorder__$c.SystemBrowser, browserOrProps);
                if (!browser.world()) browser.openInWindow();
                browser.env.forceUpdate();
                delete browser.state.selectedModule;
                return _context2.abrupt("return", browser.browse(Object.assign({
                  systemInterface: optSystemInterface
                }, browseSpec)));

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      })), __moduleMeta__$5);

      __varRecorder__$c.browse = browse;

      var browserForFile = exports('f', __varRecorder__$c["lively.ide/js/browser/ui.cp.js__define__"]("browserForFile", "function", function (fileName) {
        var browsers = $world.getWindows().map(function (win) {
          return win.targetMorph;
        }).filter(function (ea) {
          return ea.isBrowser;
        });
        var browserWithFile = browsers.find(function (_ref3) {
          var selectedModule = _ref3.selectedModule;
          return selectedModule && selectedModule.url === fileName;
        });
        return browserWithFile;
      }, __moduleMeta__$5));

      __varRecorder__$c.browserForFile = browserForFile;

      var open = __varRecorder__$c["lively.ide/js/browser/ui.cp.js__define__"]("open", "function", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var browser;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                browser = part(__varRecorder__$c.SystemBrowser);
                _context3.next = 3;
                return browser.toggleWindowStyle(false);

              case 3:
                _context3.next = 5;
                return browser.ensureColumnViewData();

              case 5:
                browser.openInWindow();
                return _context3.abrupt("return", browser);

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      })), __moduleMeta__$5);

      __varRecorder__$c.open = open;

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/browser/ui.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ComponentEditControlModel") && typeof __lively_classholder__.ComponentEditControlModel === "function" ? __lively_classholder__.ComponentEditControlModel : __lively_classholder__.ComponentEditControlModel = function ComponentEditControlModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "terminateIfNoEditorExcept",
          value: function () {
            var _ComponentEditControlModel_terminateIfNoEditorExcept_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
              var browsers, proceed;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      browsers = this.getAllOtherEqualBrowsers();

                      if (!(browsers.length > 0)) {
                        _context4.next = 3;
                        break;
                      }

                      return _context4.abrupt("return", true);

                    case 3:
                      _context4.t0 = this.editor._confirmedProceed;

                      if (_context4.t0) {
                        _context4.next = 8;
                        break;
                      }

                      _context4.next = 7;
                      return this.world().confirm(["Pending Edit Sessions", {}, "\nYou still have some active component edit sessions that are about to be closed. Are you sure you want to proceed?", {
                        fontWeight: "normal",
                        fontSize: 18
                      }], {
                        requester: this.editor.owner
                      });

                    case 7:
                      _context4.t0 = _context4.sent;

                    case 8:
                      proceed = _context4.t0;

                      if (proceed) {
                        _context4.next = 11;
                        break;
                      }

                      return _context4.abrupt("return", false);

                    case 11:
                      this.editor._confirmedProceed = true;
                      _context4.next = 14;
                      return this.terminateEditSession();

                    case 14:
                      return _context4.abrupt("return", true);

                    case 15:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function ComponentEditControlModel_terminateIfNoEditorExcept_() {
              return _ComponentEditControlModel_terminateIfNoEditorExcept_.apply(this, arguments);
            }

            return ComponentEditControlModel_terminateIfNoEditorExcept_;
          }()
        }, {
          key: "viewDidLoad",
          value: function ComponentEditControlModel_viewDidLoad_() {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "viewDidLoad", this).call(this);

            this.updateControlButtons();
            once$1(this.componentMorph, "stop editing", this, "terminateEditSession");
            once$1(this.componentDescriptor, "makeDirty", this, "updateControlButtons");
            connect(this.componentMorph, "behaviorChanged", this, "updateControlButtons");
          }
        }, {
          key: "hasViewModels",
          value: function ComponentEditControlModel_hasViewModels_() {
            var found = false;
            withAllViewModelsDo(this.componentMorph, function (m) {
              if (m.viewModel) found = true;
            });
            return found;
          }
        }, {
          key: "updateControlButtons",
          value: function ComponentEditControlModel_updateControlButtons_() {
            var _this$componentDescri;

            this.ui.livelyButton.visible = this.hasViewModels();
            this.ui.livelyButton.master.setState(this.isLively ? null : "disabled");
            this.ui.revertButton.master.setState(((_this$componentDescri = this.componentDescriptor) === null || _this$componentDescri === void 0 ? void 0 : _this$componentDescri.isDirty()) ? null : "disabled");
          }
        }, {
          key: "positionInLine",
          value: function () {
            var _ComponentEditControlModel_positionInLine_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
              var _this$componentDescri2;

              var transition,
                  view,
                  editor,
                  anchor,
                  _args5 = arguments;
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      transition = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : !((_this$componentDescri2 = this.componentDescriptor) === null || _this$componentDescri2 === void 0 ? void 0 : _this$componentDescri2._cachedComponent);
                      view = this.view, editor = this.editor, anchor = this.anchor;

                      if (editor) {
                        _context5.next = 4;
                        break;
                      }

                      return _context5.abrupt("return");

                    case 4:
                      if (!anchor) anchor = this.anchor = __varRecorder__$c.ensureAnchor(this);

                      if (!transition) {
                        _context5.next = 7;
                        break;
                      }

                      return _context5.abrupt("return", this.replaceWithEditButton());

                    case 7:
                      if (!(anchor.position.row > editor.renderingState.lastVisibleRow || anchor.position.row < editor.renderingState.firstVisibleRow)) {
                        _context5.next = 10;
                        break;
                      }

                      view.bottom = -10;
                      return _context5.abrupt("return");

                    case 10:
                      _context5.next = 12;
                      return __varRecorder__$c.positionForAnchor(editor, anchor, view);

                    case 12:
                      view.leftCenter = _context5.sent;

                    case 13:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function ComponentEditControlModel_positionInLine_() {
              return _ComponentEditControlModel_positionInLine_.apply(this, arguments);
            }

            return ComponentEditControlModel_positionInLine_;
          }()
        }, {
          key: "resetComponentDef",
          value: function ComponentEditControlModel_resetComponentDef_() {
            var _this$componentDescri3;

            if ((_this$componentDescri3 = this.componentDescriptor) === null || _this$componentDescri3 === void 0 ? void 0 : _this$componentDescri3.isDirty()) this.componentDescriptor.reset();
          }
        }, {
          key: "toggleDerivedInstance",
          value: function ComponentEditControlModel_toggleDerivedInstance_(active) {
            var _this = this;

            if (active) {
              try {
                var _this$world$sceneGrap, _this$world$sceneGrap2;

                var pos = this.componentMorph.position;
                noUpdate(function () {
                  return _this.componentMorph.remove();
                });
                (_this$world$sceneGrap = this.world().sceneGraph) === null || _this$world$sceneGrap === void 0 ? void 0 : _this$world$sceneGrap.refresh();
                this.instanceMorph = part(this.componentDescriptor).openInWorld();
                this.instanceMorph.position = pos;
                once$1(this.instanceMorph, "abandon", this, "terminateEditSession");
                (_this$world$sceneGrap2 = this.world().sceneGraph) === null || _this$world$sceneGrap2 === void 0 ? void 0 : _this$world$sceneGrap2.refresh();
              } catch (err) {
                this.view.getWindow().showError("Failed to load live version of component: " + err.message);
              }
            }

            if (!active && this.instanceMorph) {
              var _this$world$sceneGrap3, _this$world$sceneGrap4;

              var _pos = this.instanceMorph.position;
              this.cleanupInstance();
              (_this$world$sceneGrap3 = this.world().sceneGraph) === null || _this$world$sceneGrap3 === void 0 ? void 0 : _this$world$sceneGrap3.refresh();
              this.componentMorph.openInWorld();
              (_this$world$sceneGrap4 = this.world().sceneGraph) === null || _this$world$sceneGrap4 === void 0 ? void 0 : _this$world$sceneGrap4.refresh();
              this.componentMorph.position = _pos;
              noUpdate(function () {
                return _this.componentMorph.bringToFront();
              });
            }

            this.updateControlButtons();
          }
        }, {
          key: "cleanupInstance",
          value: function ComponentEditControlModel_cleanupInstance_() {
            if (this.instanceMorph) {
              disconnect(this.instanceMorph, "abandon", this, "terminateEditSession");
              this.instanceMorph.remove();
              this.instanceMorph = null;
            }
          }
        }, {
          key: "terminateEditSession",
          value: function () {
            var _ComponentEditControlModel_terminateEditSession_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
              var mod;
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      mod = module$1(this.componentDescriptor.moduleName);

                      if (mod._source) {
                        mod.changeSource(mod._source, {
                          doSave: true,
                          doEval: false
                        });
                      }

                      _context6.next = 4;
                      return this.minifyComponentMorph();

                    case 4:
                      this.componentDescriptor.stopEditSession();

                    case 5:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function ComponentEditControlModel_terminateEditSession_() {
              return _ComponentEditControlModel_terminateEditSession_.apply(this, arguments);
            }

            return ComponentEditControlModel_terminateEditSession_;
          }()
        }, {
          key: "minifyComponentMorph",
          value: function () {
            var _ComponentEditControlModel_minifyComponentMorph_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
              var _this2 = this;

              var componentMorph, editor, view;
              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      if (!this._initializing) {
                        _context8.next = 2;
                        break;
                      }

                      return _context8.abrupt("return");

                    case 2:
                      componentMorph = this.componentMorph, editor = this.editor, view = this.view;
                      _context8.next = 5;
                      return guardNamed("collapse-" + componentMorph.id, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
                        var halos, placeholderPos, pos, wrapper;
                        return regeneratorRuntime.wrap(function _callee7$(_context7) {
                          while (1) {
                            switch (_context7.prev = _context7.next) {
                              case 0:
                                halos = $world.halos();
                                halos.forEach(function (h) {
                                  if (h.target.ownerChain().includes(componentMorph)) h.remove();
                                });
                                placeholderPos = view.position;
                                pos = componentMorph.position;
                                wrapper = morph({
                                  epiMorph: true,
                                  fill: Color.transparent,
                                  submorphs: [componentMorph]
                                }).openInWorld();
                                componentMorph.position = pt(0);
                                wrapper.position = pos;
                                _context7.next = 9;
                                return wrapper.withAnimationDo(function () {
                                  wrapper.scale = 0;
                                  wrapper.opacity = 0;
                                  wrapper.center = editor.worldPoint(placeholderPos.subPt(editor.scroll));
                                }, {
                                  duration: 300,
                                  easing: easings.outQuint
                                });

                              case 9:
                                _this2.collapse(editor);

                                _this2.isActiveEditSession = false;
                                componentMorph.remove();
                                wrapper.remove();

                              case 13:
                              case "end":
                                return _context7.stop();
                            }
                          }
                        }, _callee7);
                      })))();

                    case 5:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, this);
            }));

            function ComponentEditControlModel_minifyComponentMorph_() {
              return _ComponentEditControlModel_minifyComponentMorph_.apply(this, arguments);
            }

            return ComponentEditControlModel_minifyComponentMorph_;
          }()
        }, {
          key: "replaceWithEditButton",
          value: function () {
            var _ComponentEditControlModel_replaceWithEditButton_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
              var editor, editButton;
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      editor = this.editor, editButton = this.editButton;

                      if (editor) {
                        _context9.next = 3;
                        break;
                      }

                      return _context9.abrupt("return");

                    case 3:
                      this.view.remove();
                      editButton.reset();
                      editor.addMorph(editButton);
                      editButton.positionInLine();

                    case 7:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, this);
            }));

            function ComponentEditControlModel_replaceWithEditButton_() {
              return _ComponentEditControlModel_replaceWithEditButton_.apply(this, arguments);
            }

            return ComponentEditControlModel_replaceWithEditButton_;
          }()
        }, {
          key: "getAllOtherEqualBrowsers",
          value: function ComponentEditControlModel_getAllOtherEqualBrowsers_() {
            var _this3 = this;

            var editors = getEligibleSourceEditorsFor(System.decanonicalize(this.componentDescriptor.moduleName), this.editor.textString);
            return editors.filter(function (m) {
              return m !== _this3.editor;
            }).map(function (ed) {
              return ed.owner;
            });
          }
        }, {
          key: "collapse",
          value: function () {
            var _ComponentEditControlModel_collapse_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
              var editor,
                  animated,
                  view,
                  editButton,
                  otherBrowsers,
                  center,
                  _args10 = arguments;
              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      editor = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : this.editor;
                      animated = true;
                      view = this.view, editButton = this.editButton;
                      otherBrowsers = this.getAllOtherEqualBrowsers();
                      this.cleanupInstance();
                      disconnect(this.componentMorph, "behaviorChanged", this, "updateControlButtons");
                      disconnect(this.anchor, "position", this, "positionInLine");
                      editButton.reset();
                      editButton.opacity = 0;
                      editor.addMorph(editButton);
                      this.componentDescriptor._dirty = false;
                      _context10.next = 13;
                      return editButton.positionInLine(false);

                    case 13:
                      if (!animated) {
                        _context10.next = 16;
                        break;
                      }

                      _context10.next = 16;
                      return view.animate({
                        opacity: 0,
                        scale: 0.2,
                        center: view.center,
                        duration: 300,
                        easing: easings.outQuint
                      });

                    case 16:
                      view.remove();

                      if (!animated) {
                        _context10.next = 25;
                        break;
                      }

                      _context10.next = 20;
                      return editButton.positionInLine();

                    case 20:
                      center = editButton.center;
                      editButton.scale = 1.2;
                      editButton.center = center;
                      _context10.next = 25;
                      return editButton.animate({
                        scale: 1,
                        opacity: 1,
                        center: center,
                        duration: 300,
                        easing: easings.outQuint
                      });

                    case 25:
                      editButton.scale = 1;
                      editButton.opacity = 1;
                      otherBrowsers.forEach(function (b) {
                        return b.relayout();
                      });

                    case 28:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, this);
            }));

            function ComponentEditControlModel_collapse_() {
              return _ComponentEditControlModel_collapse_.apply(this, arguments);
            }

            return ComponentEditControlModel_collapse_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ComponentEditControlModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              componentDescriptor: {},
              componentMorph: {},
              anchor: {},
              editButton: {},
              declaration: {
                before: ["anchor"],
                set: function set(decl) {
                  this.setProperty("declaration", decl);
                  this.anchor = null;
                  this.positionInLine();
                }
              },
              editor: {
                derived: true,
                get: function get() {
                  var _this$view;

                  return (_this$view = this.view) === null || _this$view === void 0 ? void 0 : _this$view.owner;
                }
              },
              isLively: {
                get: function get() {
                  return !!this.instanceMorph;
                }
              },
              isActiveEditSession: {
                defaultValue: true
              },
              isComponentControl: {
                get: function get() {
                  return true;
                }
              },
              expose: {
                get: function get() {
                  return ["positionInLine", "collapse", "isComponentControl", "componentDescriptor", "declaration", "isActiveEditSession", "terminateEditSession", "terminateIfNoEditorExcept"];
                }
              },
              bindings: {
                get: function get() {
                  var _this4 = this;

                  return [{
                    target: "close button",
                    signal: "onMouseUp",
                    handler: "terminateEditSession"
                  }, {
                    target: "revert button",
                    signal: "onMouseUp",
                    handler: "resetComponentDef"
                  }, {
                    target: "lively button",
                    signal: "onMouseUp",
                    handler: function handler() {
                      _this4.toggleDerivedInstance(!_this4.isLively);
                    }
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/browser/ui.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 2172,
          end: 10258
        });
      })({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/browser/ui.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ComponentEditButtonMorph") && typeof __lively_classholder__.ComponentEditButtonMorph === "function" ? __lively_classholder__.ComponentEditButtonMorph : __lively_classholder__.ComponentEditButtonMorph = function ComponentEditButtonMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "animateSwapWithPlaceholder",
          value: function () {
            var _ComponentEditButtonMorph_animateSwapWithPlaceholder_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(placeholder, componentMorph) {
              var _this5 = this;

              var wrapper;
              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      placeholder._initializing = true;
                      _context11.next = 4;
                      return placeholder.positionInLine();

                    case 4:
                      placeholder.scale = 0.2;
                      this.openInWorld(this.globalPosition);
                      this.layout = null;
                      wrapper = this.addMorph({
                        fill: Color.transparent,
                        opacity: 0,
                        epiMorph: true,
                        submorphs: [componentMorph]
                      });
                      wrapper.scale = 0;
                      componentMorph.position = pt(0, 0);
                      this.fill = Color.transparent;
                      _context11.next = 13;
                      return $world.withAnimationDo(function () {
                        placeholder.opacity = 1;
                        placeholder.scale = 1;
                        _this5.submorphs[0].opacity = 0;
                        componentMorph.applyLayoutIfNeeded();
                        _this5.extent = componentMorph.bounds().extent();
                        _this5.center = _this5.world().visibleBounds().center();
                        _this5.submorphs[0].center = _this5.extent.scaleBy(0.5);
                        wrapper.opacity = 1;
                        wrapper.scale = 1;
                      }, {
                        duration: 300,
                        easing: easings.outQuint
                      });

                    case 13:
                      componentMorph.openInWorld(componentMorph.globalPosition);
                      this.remove();
                      placeholder._initializing = false;

                    case 16:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11, this);
            }));

            function ComponentEditButtonMorph_animateSwapWithPlaceholder_(_x4, _x5) {
              return _ComponentEditButtonMorph_animateSwapWithPlaceholder_.apply(this, arguments);
            }

            return ComponentEditButtonMorph_animateSwapWithPlaceholder_;
          }()
        }, {
          key: "getAllOtherEqualBrowsers",
          value: function ComponentEditButtonMorph_getAllOtherEqualBrowsers_() {
            var _this$editor,
                _this6 = this;

            var editors = getEligibleSourceEditorsFor(System.decanonicalize(this.componentDescriptor.moduleName), (_this$editor = this.editor) === null || _this$editor === void 0 ? void 0 : _this$editor.textString);
            return editors.filter(function (m) {
              return m !== _this6.editor;
            }).map(function (ed) {
              return ed.owner;
            });
          }
        }, {
          key: "ensureEditControlsFor",
          value: function () {
            var _ComponentEditButtonMorph_ensureEditControlsFor_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(componentMorph) {
              var editor,
                  componentDescriptor,
                  anchor,
                  declaration,
                  btnPlaceholder,
                  _args12 = arguments;
              return regeneratorRuntime.wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      editor = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : this.editor;
                      componentDescriptor = this.componentDescriptor, anchor = this.anchor, declaration = this.declaration;
                      btnPlaceholder = editor.addMorph(part(__varRecorder__$c.ComponentEditControls, {
                        name: "component edit control",
                        viewModel: {
                          componentMorph: componentMorph,
                          componentDescriptor: componentDescriptor,
                          declaration: declaration,
                          anchor: anchor,
                          editButton: this
                        }
                      }));
                      btnPlaceholder.bottom = -10;
                      _context12.next = 6;
                      return btnPlaceholder.positionInLine();

                    case 6:
                      return _context12.abrupt("return", btnPlaceholder);

                    case 7:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12, this);
            }));

            function ComponentEditButtonMorph_ensureEditControlsFor_(_x6) {
              return _ComponentEditButtonMorph_ensureEditControlsFor_.apply(this, arguments);
            }

            return ComponentEditButtonMorph_ensureEditControlsFor_;
          }()
        }, {
          key: "replaceWithControls",
          value: function () {
            var _ComponentEditButtonMorph_replaceWithControls_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
              var componentDescriptor, editor, componentMorph, btnPlaceholder;
              return regeneratorRuntime.wrap(function _callee13$(_context13) {
                while (1) {
                  switch (_context13.prev = _context13.next) {
                    case 0:
                      componentDescriptor = this.componentDescriptor, editor = this.editor;

                      if (editor) {
                        _context13.next = 3;
                        break;
                      }

                      return _context13.abrupt("return");

                    case 3:
                      this.remove();
                      componentMorph = componentDescriptor.getComponentMorph();
                      _context13.next = 7;
                      return this.ensureEditControlsFor(componentMorph, editor);

                    case 7:
                      btnPlaceholder = _context13.sent;
                      btnPlaceholder.opacity = 1;

                    case 9:
                    case "end":
                      return _context13.stop();
                  }
                }
              }, _callee13, this);
            }));

            function ComponentEditButtonMorph_replaceWithControls_() {
              return _ComponentEditButtonMorph_replaceWithControls_.apply(this, arguments);
            }

            return ComponentEditButtonMorph_replaceWithControls_;
          }()
        }, {
          key: "expand",
          value: function () {
            var _ComponentEditButtonMorph_expand_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
              var componentDescriptor, otherBrowsers, componentMorph, btnPlaceholder;
              return regeneratorRuntime.wrap(function _callee14$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      componentDescriptor = this.componentDescriptor;
                      otherBrowsers = this.getAllOtherEqualBrowsers();
                      _context14.next = 4;
                      return componentDescriptor.edit();

                    case 4:
                      componentMorph = _context14.sent;

                      if (componentMorph) {
                        componentMorph.applyLayoutIfNeeded();
                      }

                      _context14.next = 8;
                      return this.ensureEditControlsFor(componentMorph);

                    case 8:
                      btnPlaceholder = _context14.sent;
                      _context14.next = 11;
                      return this.animateSwapWithPlaceholder(btnPlaceholder, componentMorph);

                    case 11:
                      otherBrowsers.forEach(function (b) {
                        return b.relayout();
                      });

                    case 12:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee14, this);
            }));

            function ComponentEditButtonMorph_expand_() {
              return _ComponentEditButtonMorph_expand_.apply(this, arguments);
            }

            return ComponentEditButtonMorph_expand_;
          }()
        }, {
          key: "positionInLine",
          value: function () {
            var _ComponentEditButtonMorph_positionInLine_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
              var _this$componentDescri4;

              var transition,
                  editor,
                  anchor,
                  _args15 = arguments;
              return regeneratorRuntime.wrap(function _callee15$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      transition = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : !!((_this$componentDescri4 = this.componentDescriptor) === null || _this$componentDescri4 === void 0 ? void 0 : _this$componentDescri4._cachedComponent);
                      editor = this.editor, anchor = this.anchor;

                      if (editor) {
                        _context15.next = 4;
                        break;
                      }

                      return _context15.abrupt("return");

                    case 4:
                      if (!transition) {
                        _context15.next = 6;
                        break;
                      }

                      return _context15.abrupt("return", this.replaceWithControls());

                    case 6:
                      if (!anchor) anchor = this.anchor = __varRecorder__$c.ensureAnchor(this);

                      if (!(anchor.position.row > editor.renderingState.lastVisibleRow || anchor.position.row < editor.renderingState.firstVisibleRow)) {
                        _context15.next = 10;
                        break;
                      }

                      this.bottom = -10;
                      return _context15.abrupt("return");

                    case 10:
                      _context15.next = 12;
                      return __varRecorder__$c.positionForAnchor(editor, anchor, this);

                    case 12:
                      this.leftCenter = _context15.sent;

                    case 13:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee15, this);
            }));

            function ComponentEditButtonMorph_positionInLine_() {
              return _ComponentEditButtonMorph_positionInLine_.apply(this, arguments);
            }

            return ComponentEditButtonMorph_positionInLine_;
          }()
        }, {
          key: "reset",
          value: function ComponentEditButtonMorph_reset_() {
            this.master = __varRecorder__$c.ComponentEditButton;
            this.submorphs = [this.submorphs[0]];
          }
        }, {
          key: "onMouseUp",
          value: function ComponentEditButtonMorph_onMouseUp_(evt) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onMouseUp", this).call(this, evt);

            this.expand();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ComponentEditButtonMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              isComponentControl: {
                get: function get() {
                  return true;
                }
              },
              componentMorph: {
                get: function get() {
                  return this.componentDescriptor._cachedComponent;
                }
              },
              declaration: {
                set: function set(decl) {
                  this.setProperty("declaration", decl);
                  this.anchor = null;
                  this.positionInLine();
                }
              },
              editor: {
                derived: true,
                get: function get() {
                  return this.owner;
                }
              },
              componentDescriptor: {}
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/browser/ui.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 10260,
          end: 14498
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      __varRecorder__$c.ComponentEditButtonDefault = component["for"](function () {
        return component({
          type: __varRecorder__$c.ComponentEditButtonMorph,
          isLayoutable: false,
          fill: Color.rgba(76, 175, 80, 0.7539),
          nativeCursor: "pointer",
          borderRadius: 20,
          layout: new TilingLayout({
            align: "right",
            hugContentsHorizontally: true,
            hugContentsVertically: true,
            orderByIndex: true,
            padding: rect(2, 1, -1, 0)
          }),
          submorphs: [{
            type: "label",
            name: "label",
            reactsToPointer: false,
            padding: rect(5, 1, 0, -1),
            fontColor: Color.white,
            fontWeight: "bold",
            fontSize: 12,
            textAndAttributes: ["Edit Component  ", {}, "\uF04B", {
              fontFamily: "Font Awesome",
              paddingTop: "2px"
            }]
          }]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "ComponentEditButtonDefault",
        range: {
          start: 14506,
          end: 15214
        }
      }, System, __varRecorder__$c, "ComponentEditButtonDefault");
      __varRecorder__$c.ComponentEditButtonClicked = component["for"](function () {
        return component(__varRecorder__$c.ComponentEditButtonDefault, {
          fill: Color.rgba(27, 94, 32, 0.7095)
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "ComponentEditButtonClicked",
        range: {
          start: 15223,
          end: 15333
        }
      }, System, __varRecorder__$c, "ComponentEditButtonClicked");
      __varRecorder__$c.ComponentEditButton = component["for"](function () {
        return component(__varRecorder__$c.ComponentEditButtonDefault, {
          master: {
            click: __varRecorder__$c.ComponentEditButtonClicked
          }
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "ComponentEditButton",
        range: {
          start: 15342,
          end: 15454
        }
      }, System, __varRecorder__$c, "ComponentEditButton");
      __varRecorder__$c.CloseComponentButtonDefault = component["for"](function () {
        return component({
          type: Label,
          nativeCursor: "pointer",
          borderRadius: 15,
          padding: rect(5, 1, 0, 0),
          fill: Color.rgb(221, 37, 37),
          fontColor: Color.white,
          fontWeight: "bold",
          fontSize: 12,
          textAndAttributes: ["Stop ", {}].concat(_toConsumableArray$1(Icon.textAttribute("pause", {
            paddingTop: "2px"
          })))
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "CloseComponentButtonDefault",
        range: {
          start: 15463,
          end: 15784
        }
      }, System, __varRecorder__$c, "CloseComponentButtonDefault");
      __varRecorder__$c.CloseComponentButtonClicked = component["for"](function () {
        return component(__varRecorder__$c.CloseComponentButtonDefault, {
          fill: Color.rgb(183, 28, 28)
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "CloseComponentButtonClicked",
        range: {
          start: 15793,
          end: 15897
        }
      }, System, __varRecorder__$c, "CloseComponentButtonClicked");
      __varRecorder__$c.CloseComponentButton = component["for"](function () {
        return component(__varRecorder__$c.CloseComponentButtonDefault, {
          master: {
            click: __varRecorder__$c.CloseComponentButtonClicked
          }
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "CloseComponentButton",
        range: {
          start: 15906,
          end: 16021
        }
      }, System, __varRecorder__$c, "CloseComponentButton");
      __varRecorder__$c.RevertComponentButtonDefault = component["for"](function () {
        return component({
          type: Label,
          nativeCursor: "pointer",
          borderRadius: 15,
          padding: rect(5, 1, 0, 0),
          fill: Color.rgb(33, 150, 243),
          fontColor: Color.white,
          fontWeight: "bold",
          fontSize: 12,
          textAndAttributes: ["Revert ", {}].concat(_toConsumableArray$1(Icon.textAttribute("rotate-left", {
            lineHeight: 1.4
          })))
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "RevertComponentButtonDefault",
        range: {
          start: 16030,
          end: 16359
        }
      }, System, __varRecorder__$c, "RevertComponentButtonDefault");
      __varRecorder__$c.RevertComponentButtonClicked = component["for"](function () {
        return component(__varRecorder__$c.RevertComponentButtonDefault, {
          fill: Color.rgb(0, 119, 189)
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "RevertComponentButtonClicked",
        range: {
          start: 16368,
          end: 16474
        }
      }, System, __varRecorder__$c, "RevertComponentButtonClicked");
      __varRecorder__$c.RevertComponentButtonDisabled = component["for"](function () {
        return component(__varRecorder__$c.RevertComponentButtonDefault, {
          opacity: 0.5,
          nativeCursor: "not-allowed"
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "RevertComponentButtonDisabled",
        range: {
          start: 16483,
          end: 16605
        }
      }, System, __varRecorder__$c, "RevertComponentButtonDisabled");
      __varRecorder__$c.RevertComponentButton = component["for"](function () {
        return component(__varRecorder__$c.RevertComponentButtonDefault, {
          master: {
            click: __varRecorder__$c.RevertComponentButtonClicked
          }
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "RevertComponentButton",
        range: {
          start: 16614,
          end: 16732
        }
      }, System, __varRecorder__$c, "RevertComponentButton");
      __varRecorder__$c.BehaviorToggleButton = component["for"](function () {
        return component({
          master: {
            auto: new PolicyApplicator({
              fill: Color.rgb(255, 111, 0)
            }),
            click: new PolicyApplicator({
              fill: Color.rgb(206, 89, 0)
            })
          },
          nativeCursor: "pointer",
          borderRadius: 20,
          layout: new TilingLayout({
            wrapSubmorphs: false,
            hugContentsVertically: true,
            hugContentsHorizontally: true
          }),
          submorphs: [{
            type: "label",
            name: "active",
            visible: true,
            reactsToPointer: false,
            padding: rect(5, 1, 0, 0),
            fontColor: Color.white,
            fontWeight: "bold",
            fontSize: 12,
            textAndAttributes: ["Turn Stale ", {}].concat(_toConsumableArray$1(Icon.textAttribute("heart-pulse", {
              lineHeight: 1.4
            })))
          }, {
            type: "label",
            name: "inactive",
            visible: false,
            reactsToPointer: false,
            padding: rect(5, 1, 0, 0),
            fontColor: Color.white,
            fontWeight: "bold",
            fontSize: 12,
            textAndAttributes: ["Turn Lively ", {}].concat(_toConsumableArray$1(Icon.textAttribute("heart-circle-xmark", {
              lineHeight: 1.4
            })))
          }]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "BehaviorToggleButton",
        range: {
          start: 16741,
          end: 17770
        }
      }, System, __varRecorder__$c, "BehaviorToggleButton");
      __varRecorder__$c.BehaviorToggleButtonDisabled = component["for"](function () {
        return component(__varRecorder__$c.BehaviorToggleButton, {
          name: "behavior toggle button disabled",
          fill: Color.rgb(121, 85, 72),
          opacity: 0.6,
          submorphs: [{
            name: "active",
            visible: false
          }, {
            name: "inactive",
            visible: true
          }]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "BehaviorToggleButtonDisabled",
        range: {
          start: 17779,
          end: 18044
        }
      }, System, __varRecorder__$c, "BehaviorToggleButtonDisabled");
      __varRecorder__$c.ComponentEditControls = component["for"](function () {
        return component({
          viewModelClass: __varRecorder__$c.ComponentEditControlModel,
          fill: Color.rgba(255, 255, 255, 0),
          layout: new TilingLayout({
            orderByIndex: true,
            spacing: 5,
            wrapSubmorphs: false,
            hugContentsHorizontally: true,
            hugContentsVertically: true
          }),
          submorphs: [part(__varRecorder__$c.CloseComponentButton, {
            name: "close button"
          }), part(__varRecorder__$c.RevertComponentButton, {
            name: "revert button",
            master: {
              states: {
                disabled: __varRecorder__$c.RevertComponentButtonDisabled
              }
            }
          }), part(__varRecorder__$c.BehaviorToggleButton, {
            name: "lively button",
            master: {
              states: {
                disabled: __varRecorder__$c.BehaviorToggleButtonDisabled
              }
            }
          })]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "ComponentEditControls",
        range: {
          start: 18053,
          end: 18698
        }
      }, System, __varRecorder__$c, "ComponentEditControls");
      __varRecorder__$c.BrowserTabDefault = component["for"](function () {
        return component(DefaultTab, {
          name: "browser/tab/default",
          defaultViewModel: TabModel,
          borderRadius: 0,
          fill: Color.black.withA(0.3),
          submorphs: [{
            name: "horizontal container",
            extent: pt(300, 30.7),
            layout: new TilingLayout({
              align: "center",
              axisAlign: "center",
              orderByIndex: true,
              padding: rect(6, 6, 0, 0),
              resizePolicies: [["tab caption", {
                height: "fixed",
                width: "fill"
              }]]
            })
          }]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "BrowserTabDefault",
        range: {
          start: 18707,
          end: 19191
        }
      }, System, __varRecorder__$c, "BrowserTabDefault");
      __varRecorder__$c.BrowserTabSelected = component["for"](function () {
        return component(__varRecorder__$c.BrowserTabDefault, {
          name: "browser/tab/selected",
          opacity: 1,
          borderRadius: 0,
          dropShadow: new ShadowObject({
            color: Color.rgba(0, 0, 0, 0.5),
            blur: 5
          }),
          fill: Color.transparent,
          submorphs: [{
            name: "horizontal container",
            submorphs: [{
              name: "tab caption",
              fontWeight: 700
            }]
          }]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "BrowserTabSelected",
        range: {
          start: 19200,
          end: 19553
        }
      }, System, __varRecorder__$c, "BrowserTabSelected");
      __varRecorder__$c.BrowserTabClicked = component["for"](function () {
        return component(__varRecorder__$c.BrowserTabSelected, {
          name: "browser/tab/clicked",
          fill: new LinearGradient({
            stops: [{
              offset: 0,
              color: Color.rgb(126, 127, 127)
            }, {
              offset: 1,
              color: Color.rgb(150, 152, 153)
            }],
            vector: rect(0, 0, 0, 1)
          })
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "BrowserTabClicked",
        range: {
          start: 19562,
          end: 19837
        }
      }, System, __varRecorder__$c, "BrowserTabClicked");
      __varRecorder__$c.BrowserTabHovered = component["for"](function () {
        return component(__varRecorder__$c.BrowserTabSelected, {
          name: "browser/tab/hovered",
          dropShadow: null,
          fill: Color.black.withA(0.15),
          submorphs: [{
            name: "horizontal container",
            submorphs: [{
              name: "tab caption",
              fontWeight: "400"
            }]
          }]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "BrowserTabHovered",
        range: {
          start: 19846,
          end: 20114
        }
      }, System, __varRecorder__$c, "BrowserTabHovered");
      __varRecorder__$c.FileStatusDefault = component["for"](function () {
        return component({
          name: "file status default",
          borderColor: Color.rgb(44, 62, 80),
          borderRadius: 5,
          borderWidth: 1,
          dropShadow: new ShadowObject({
            distance: 0,
            color: Color.rgba(0, 0, 0, 0.5)
          }),
          extent: pt(176.3, 35.3),
          fill: new LinearGradient({
            stops: [{
              offset: 0,
              color: Color.rgba(44, 62, 80, 0.9)
            }, {
              offset: 1,
              color: Color.rgba(33, 47, 60, 0.9)
            }],
            vector: rect(0.5, 0, 0, 1)
          })
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "FileStatusDefault",
        range: {
          start: 20123,
          end: 20542
        }
      }, System, __varRecorder__$c, "FileStatusDefault");
      __varRecorder__$c.FileStatusError = component["for"](function () {
        return component(__varRecorder__$c.FileStatusDefault, {
          name: "file status error",
          fill: new LinearGradient({
            stops: [{
              offset: 0,
              color: Color.rgb(231, 76, 60)
            }, {
              offset: 1,
              color: Color.rgb(192, 57, 43)
            }],
            vector: rect(0.5, 0, 0, 1)
          })
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "FileStatusError",
        range: {
          start: 20551,
          end: 20814
        }
      }, System, __varRecorder__$c, "FileStatusError");
      __varRecorder__$c.FileStatusSaved = component["for"](function () {
        return component(__varRecorder__$c.FileStatusDefault, {
          name: "file status saved",
          fill: new LinearGradient({
            stops: [{
              offset: 0,
              color: Color.rgb(46, 204, 113)
            }, {
              offset: 1,
              color: Color.rgb(39, 174, 96)
            }],
            vector: rect(0.5, 0, 0, 1)
          })
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "FileStatusSaved",
        range: {
          start: 20823,
          end: 21087
        }
      }, System, __varRecorder__$c, "FileStatusSaved");
      __varRecorder__$c.FileStatusInactive = component["for"](function () {
        return component(__varRecorder__$c.FileStatusDefault, {
          name: "file status inactive",
          fill: new LinearGradient({
            stops: [{
              offset: 0,
              color: Color.rgb(128, 139, 150)
            }, {
              offset: 1,
              color: Color.rgb(93, 109, 126)
            }],
            vector: rect(0.5, 0, 0, 1)
          })
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "FileStatusInactive",
        range: {
          start: 21096,
          end: 21368
        }
      }, System, __varRecorder__$c, "FileStatusInactive");
      __varRecorder__$c.FileStatusWarning = component["for"](function () {
        return component(__varRecorder__$c.FileStatusDefault, {
          name: "file status warning",
          borderColor: Color.rgbHex("DA9819"),
          fill: new LinearGradient({
            stops: [{
              offset: 0,
              color: Color.rgb(249, 213, 68)
            }, {
              offset: 1,
              color: Color.rgb(219, 162, 18)
            }],
            vector: rect(0.5, 1, 0, 1)
          })
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "FileStatusWarning",
        range: {
          start: 21377,
          end: 21690
        }
      }, System, __varRecorder__$c, "FileStatusWarning");
      __varRecorder__$c.BackendButtonDefault = component["for"](function () {
        return component(ButtonDefault, {
          name: "backend button default",
          layout: new TilingLayout({
            align: "center",
            axisAlign: "center",
            hugContentsHorizontally: true,
            padding: rect(5, 0, 0, 0)
          }),
          borderColor: Color.rgb(44, 62, 80),
          extent: pt(130.3, 26.1),
          fill: new LinearGradient({
            stops: [{
              offset: 0,
              color: Color.rgba(44, 62, 80, 0.9)
            }, {
              offset: 1,
              color: Color.rgba(33, 47, 60, 0.9)
            }],
            vector: rect(0.5, 0, 0, 1)
          }),
          submorphs: [{
            name: "label",
            fontColor: Color.rgb(163, 228, 215),
            fontFamily: "\"IBM Plex Mono\"",
            fontSize: 14
          }]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "BackendButtonDefault",
        range: {
          start: 21699,
          end: 22300
        }
      }, System, __varRecorder__$c, "BackendButtonDefault");
      __varRecorder__$c.BackendButtonClicked = component["for"](function () {
        return component(__varRecorder__$c.BackendButtonDefault, {
          name: "backend button clicked",
          fill: new LinearGradient({
            stops: [{
              offset: 0,
              color: Color.rgb(33, 48, 63)
            }, {
              offset: 1,
              color: Color.rgb(33, 47, 60)
            }],
            vector: rect(0.5, 0, 0, 1)
          }),
          submorphs: [{
            name: "label",
            fontColor: Color.rgb(63, 110, 101),
            fontFamily: "\"IBM Plex Mono\"",
            fontSize: 14
          }]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "BackendButtonClicked",
        range: {
          start: 22309,
          end: 22693
        }
      }, System, __varRecorder__$c, "BackendButtonClicked");
      __varRecorder__$c.EmbeddedIconDefault = component["for"](function () {
        return component({
          type: Label,
          name: "embedded icon default",
          fontColor: Color.rgb(253, 254, 254),
          fontFamily: "IBM Plex Mono",
          nativeCursor: "pointer",
          padding: rect(5, 5, 0, 0),
          borderRadius: 4,
          textAndAttributes: Icon.textAttribute("external-link-alt")
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "EmbeddedIconDefault",
        range: {
          start: 22702,
          end: 22992
        }
      }, System, __varRecorder__$c, "EmbeddedIconDefault");
      __varRecorder__$c.EmbeddedIconHovered = component["for"](function () {
        return component(__varRecorder__$c.EmbeddedIconDefault, {
          name: "embedded icon hovered",
          fill: Color.rgba(0, 0, 0, 0.2)
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "EmbeddedIconHovered",
        range: {
          start: 23001,
          end: 23124
        }
      }, System, __varRecorder__$c, "EmbeddedIconHovered");
      __varRecorder__$c.EmbeddedIconClicked = component["for"](function () {
        return component(__varRecorder__$c.EmbeddedIconDefault, {
          name: "embedded icon clicked",
          fill: Color.rgba(0, 0, 0, 0.4)
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "EmbeddedIconClicked",
        range: {
          start: 23133,
          end: 23256
        }
      }, System, __varRecorder__$c, "EmbeddedIconClicked");
      __varRecorder__$c.EmbeddedIcon = component["for"](function () {
        return component(__varRecorder__$c.EmbeddedIconDefault, {
          name: "embedded icon",
          master: {
            auto: __varRecorder__$c.EmbeddedIconDefault,
            hover: __varRecorder__$c.EmbeddedIconHovered,
            click: __varRecorder__$c.EmbeddedIconClicked
          }
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "EmbeddedIcon",
        range: {
          start: 23265,
          end: 23436
        }
      }, System, __varRecorder__$c, "EmbeddedIcon");
      __varRecorder__$c.BrowserDirectoryControls = component["for"](function () {
        return component({
          type: DirectoryControls,
          name: "directory controls",
          acceptsDrops: false,
          borderColor: Color.rgb(23, 160, 251),
          extent: pt(83.2, 30.8),
          fill: Color.rgba(0, 0, 0, 0),
          layout: new TilingLayout({
            axisAlign: "center",
            align: "center",
            orderByIndex: true,
            padding: {
              height: 0,
              width: 0,
              x: 5,
              y: 5
            },
            reactToSubmorphAnimations: false,
            renderViaCSS: true,
            spacing: 5
          }),
          submorphs: [part(DarkButton, {
            name: "add folder",
            extent: pt(21, 21),
            submorphs: [{
              name: "label",
              textAndAttributes: Icon.textAttribute("folder-plus")
            }],
            tooltip: "Add folder"
          }), part(DarkButton, {
            name: "remove selected",
            extent: pt(21, 21),
            submorphs: [{
              name: "label",
              textAndAttributes: Icon.textAttribute("minus")
            }],
            tooltip: "Remove selected"
          }), part(DarkButton, {
            name: "add file",
            extent: pt(21, 21),
            submorphs: [{
              name: "label",
              textAndAttributes: Icon.textAttribute("file-medical")
            }],
            tooltip: "Add file"
          })]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "BrowserDirectoryControls",
        range: {
          start: 23445,
          end: 24615
        }
      }, System, __varRecorder__$c, "BrowserDirectoryControls");
      __varRecorder__$c.BrowserPackageControls = component["for"](function () {
        return component({
          type: PackageControls,
          name: "browser package controls",
          acceptsDrops: false,
          borderColor: Color.rgb(23, 160, 251),
          extent: pt(123.4, 30.8),
          fill: Color.rgba(0, 0, 0, 0),
          layout: new TilingLayout({
            axisAlign: "center",
            align: "center",
            padding: {
              height: 0,
              width: 0,
              x: 5,
              y: 5
            },
            reactToSubmorphAnimations: false,
            renderViaCSS: true,
            spacing: 5
          }),
          position: pt(767.5, 1556.9),
          submorphs: [part(DarkButton, {
            name: "add pkg",
            extent: pt(21, 21),
            tooltip: "Add package",
            submorphs: [{
              name: "label",
              textAndAttributes: Icon.textAttribute("plus")
            }]
          }), part(DarkButton, {
            name: "remove pkg",
            extent: pt(21, 21),
            tooltip: "Remove package",
            submorphs: [{
              name: "label",
              textAndAttributes: Icon.textAttribute("minus")
            }]
          }), part(DarkButton, {
            name: "run all pkg tests",
            extent: pt(62, 21),
            tooltip: "Run all tests in this package",
            submorphs: [{
              name: "label",
              textAndAttributes: ["Run all tests", null]
            }]
          })]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "BrowserPackageControls",
        range: {
          start: 24624,
          end: 25809
        }
      }, System, __varRecorder__$c, "BrowserPackageControls");
      var PathIndicator = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/browser/ui.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PathIndicator") && typeof __lively_classholder__.PathIndicator === "function" ? __lively_classholder__.PathIndicator : __lively_classholder__.PathIndicator = function PathIndicator(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "reset",
          value: function PathIndicator_reset_() {
            var _this$ui = this.ui;
                _this$ui.statusBox;
                _this$ui.statusLabel;
                _this$ui.errorControls;
            this.master.setState(null);
            this.setPath();
          }
        }, {
          key: "showInfoInWorkspace",
          value: function PathIndicator_showInfoInWorkspace_() {
            var content = this.ui.statusBox.textString;
            var title = content.split("\n")[0];
            part(BlackOnWhite, {
              textString: content.split("\n").slice(1).join("\n"),
              name: title
            }).openInWindow();
          }
        }, {
          key: "getPath",
          value: function PathIndicator_getPath_() {
            return this.ui.filePath.textAndAttributes;
          }
        }, {
          key: "setPath",
          value: function PathIndicator_setPath_() {
            var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getPath();
            var _this$ui2 = this.ui,
                filePath = _this$ui2.filePath,
                clipboardControls = _this$ui2.clipboardControls,
                exportToHtml = _this$ui2.exportToHtml,
                freezeButton = _this$ui2.freezeButton,
                runTestsButton = _this$ui2.runTestsButton;
            clipboardControls.opacity = 1;
            filePath.value = path;
            freezeButton.isLayoutable = freezeButton.visible = !this.testModuleMode && filePath.textString.includes(".js");
            exportToHtml.isLayoutable = exportToHtml.visible = filePath.textString.includes(".md");
            runTestsButton.isLayoutable = runTestsButton.visible = this.testModuleMode;
          }
        }, {
          key: "showInactive",
          value: function PathIndicator_showInactive_() {
            var _this7 = this;

            var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 300;
            this.requestTransition( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
              var filePath;
              return regeneratorRuntime.wrap(function _callee16$(_context16) {
                while (1) {
                  switch (_context16.prev = _context16.next) {
                    case 0:
                      filePath = _this7.ui.filePath;
                      filePath.value = "No file selected";

                      _this7.master.setState("inactive");

                      _context16.next = 5;
                      return _this7.master.applyAnimated({
                        duration: duration,
                        easing: easings.outQuint
                      });

                    case 5:
                    case "end":
                      return _context16.stop();
                  }
                }
              }, _callee16);
            })));
            this.setPath();
          }
        }, {
          key: "showDefault",
          value: function PathIndicator_showDefault_() {
            var _this8 = this;

            var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 300;
            this.requestTransition( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
              var statusBox;
              return regeneratorRuntime.wrap(function _callee17$(_context17) {
                while (1) {
                  switch (_context17.prev = _context17.next) {
                    case 0:
                      statusBox = _this8.ui.statusBox;

                      _this8.master.setState(null);

                      _context17.next = 4;
                      return _this8.master.applyAnimated({
                        duration: duration,
                        easing: easings.outQuint
                      });

                    case 4:
                      statusBox.reactsToPointer = false;

                    case 5:
                    case "end":
                      return _context17.stop();
                  }
                }
              }, _callee17);
            })));
            this.setPath();
          }
        }, {
          key: "showError",
          value: function () {
            var _PathIndicator_showError_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(err) {
              var _this9 = this;

              var duration,
                  _args19 = arguments;
              return regeneratorRuntime.wrap(function _callee19$(_context19) {
                while (1) {
                  switch (_context19.prev = _context19.next) {
                    case 0:
                      duration = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : 300;
                      this.requestTransition( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
                        var _this9$ui, statusBox, statusLabel;

                        return regeneratorRuntime.wrap(function _callee18$(_context18) {
                          while (1) {
                            switch (_context18.prev = _context18.next) {
                              case 0:
                                _this9$ui = _this9.ui, statusBox = _this9$ui.statusBox, statusLabel = _this9$ui.statusLabel;
                                statusBox.textString = err;
                                statusLabel.value = ["Error ", null].concat(_toConsumableArray$1(Icon.textAttribute("exclamation-triangle", {
                                  paddingTop: "3px"
                                })));

                                _this9.master.setState("error");

                                _context18.next = 6;
                                return _this9.master.applyAnimated({
                                  duration: duration,
                                  easing: easings.outQuint
                                });

                              case 6:
                                statusBox.reactsToPointer = true;

                              case 7:
                              case "end":
                                return _context18.stop();
                            }
                          }
                        }, _callee18);
                      })));
                      this.setPath();

                    case 3:
                    case "end":
                      return _context19.stop();
                  }
                }
              }, _callee19, this);
            }));

            function PathIndicator_showError_(_x7) {
              return _PathIndicator_showError_.apply(this, arguments);
            }

            return PathIndicator_showError_;
          }()
        }, {
          key: "showWarning",
          value: function () {
            var _PathIndicator_showWarning_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(warning) {
              var _this10 = this;

              var duration,
                  _args21 = arguments;
              return regeneratorRuntime.wrap(function _callee21$(_context21) {
                while (1) {
                  switch (_context21.prev = _context21.next) {
                    case 0:
                      duration = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : 300;
                      _context21.next = 3;
                      return this.requestTransition( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
                        var _this10$ui, statusBox, statusLabel;

                        return regeneratorRuntime.wrap(function _callee20$(_context20) {
                          while (1) {
                            switch (_context20.prev = _context20.next) {
                              case 0:
                                _this10$ui = _this10.ui, statusBox = _this10$ui.statusBox, statusLabel = _this10$ui.statusLabel;
                                statusBox.textString = warning;
                                statusLabel.value = ["Warning ", null].concat(_toConsumableArray$1(Icon.textAttribute("exclamation-circle", {
                                  paddingTop: "3px"
                                })));

                                _this10.master.setState("warning");

                                _context20.next = 6;
                                return _this10.master.applyAnimated({
                                  duration: duration,
                                  easing: easings.outQuint
                                });

                              case 6:
                                statusBox.reactsToPointer = true;

                              case 7:
                              case "end":
                                return _context20.stop();
                            }
                          }
                        }, _callee20);
                      })));

                    case 3:
                      this.setPath();

                    case 4:
                    case "end":
                      return _context21.stop();
                  }
                }
              }, _callee21, this);
            }));

            function PathIndicator_showWarning_(_x8) {
              return _PathIndicator_showWarning_.apply(this, arguments);
            }

            return PathIndicator_showWarning_;
          }()
        }, {
          key: "showSaved",
          value: function () {
            var _PathIndicator_showSaved_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23() {
              var _this11 = this;

              var duration,
                  timeout,
                  _args23 = arguments;
              return regeneratorRuntime.wrap(function _callee23$(_context23) {
                while (1) {
                  switch (_context23.prev = _context23.next) {
                    case 0:
                      duration = _args23.length > 0 && _args23[0] !== undefined ? _args23[0] : 300;
                      timeout = _args23.length > 1 && _args23[1] !== undefined ? _args23[1] : 5000;

                      if (!this._animating) {
                        _context23.next = 4;
                        break;
                      }

                      return _context23.abrupt("return");

                    case 4:
                      this._animating = true;
                      this.requestTransition( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22() {
                        var _this11$ui, statusBox, statusLabel;

                        return regeneratorRuntime.wrap(function _callee22$(_context22) {
                          while (1) {
                            switch (_context22.prev = _context22.next) {
                              case 0:
                                _this11$ui = _this11.ui, statusBox = _this11$ui.statusBox, statusLabel = _this11$ui.statusLabel;
                                statusLabel.value = ["Saved ", null].concat(_toConsumableArray$1(Icon.textAttribute("check", {
                                  paddingTop: "3px"
                                })));

                                _this11.master.setState("saved");

                                _context22.next = 5;
                                return _this11.master.applyAnimated({
                                  duration: duration,
                                  easing: easings.outQuint
                                });

                              case 5:
                                statusBox.reactsToPointer = false;

                              case 6:
                              case "end":
                                return _context22.stop();
                            }
                          }
                        }, _callee22);
                      })));
                      this.setPath();
                      _context23.next = 9;
                      return delay(timeout);

                    case 9:
                      this._animating = false;
                      this.showDefault(duration);

                    case 11:
                    case "end":
                      return _context23.stop();
                  }
                }
              }, _callee23, this);
            }));

            function PathIndicator_showSaved_() {
              return _PathIndicator_showSaved_.apply(this, arguments);
            }

            return PathIndicator_showSaved_;
          }()
        }, {
          key: "requestTransition",
          value: function () {
            var _PathIndicator_requestTransition_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(transition) {
              return regeneratorRuntime.wrap(function _callee24$(_context24) {
                while (1) {
                  switch (_context24.prev = _context24.next) {
                    case 0:
                      if (!this._currentTransition) {
                        _context24.next = 8;
                        break;
                      }

                      this._nextTransition = transition;
                      _context24.next = 4;
                      return this._currentTransition;

                    case 4:
                      this._nextTransition && this.requestTransition(this._nextTransition);
                      this._nextTransition = null;
                      _context24.next = 12;
                      break;

                    case 8:
                      this._currentTransition = transition();
                      _context24.next = 11;
                      return this._currentTransition;

                    case 11:
                      this._currentTransition = null;

                    case 12:
                    case "end":
                      return _context24.stop();
                  }
                }
              }, _callee24, this);
            }));

            function PathIndicator_requestTransition_(_x9) {
              return _PathIndicator_requestTransition_.apply(this, arguments);
            }

            return PathIndicator_requestTransition_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PathIndicator";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              ui: {
                get: function get() {
                  return {
                    filePath: this.getSubmorphNamed("file path"),
                    pathContainer: this.getSubmorphNamed("path container"),
                    clipboardControls: this.getSubmorphNamed("clipboard controls"),
                    statusBox: this.getSubmorphNamed("status box"),
                    statusLabel: this.getSubmorphNamed("status label"),
                    errorControls: this.getSubmorphNamed("error controls"),
                    exportToHtml: this.getSubmorphNamed("export to html"),
                    runTestsButton: this.getSubmorphNamed("run tests in module"),
                    freezeButton: this.getSubmorphNamed("freeze button")
                  };
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/browser/ui.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 25819,
          end: 30272
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$c.PathIndicator = PathIndicator;
      __varRecorder__$c.PathIndicator = PathIndicator;
      __varRecorder__$c.MetaInfoContainerExpanded = component["for"](function () {
        return component({
          type: __varRecorder__$c.PathIndicator,
          master: __varRecorder__$c.FileStatusDefault,
          isLayoutable: true,
          clipMode: "hidden",
          extent: pt(587.6, 60.4),
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "right",
            hugContentsVertically: true,
            padding: rect(10, 10, 0, 0),
            reactToSubmorphAnimations: true,
            resizePolicies: [["path container", {
              height: "fixed",
              width: "fill"
            }], ["status box", {
              height: "fixed",
              width: "fill"
            }]]
          }),
          submorphs: [{
            name: "path container",
            clipMode: "hidden",
            borderColor: Color.rgb(23, 160, 251),
            extent: pt(568, 30),
            fill: Color.rgba(0, 0, 0, 0),
            layout: new TilingLayout({
              align: "center",
              axisAlign: "center",
              justifySubmorphs: "spaced",
              orderByIndex: true,
              reactToSubmorphAnimations: true,
              spacing: 5,
              resizePolicies: [["status label", {
                height: "fixed",
                width: "fixed"
              }], ["file path", {
                height: "fixed",
                width: "fill"
              }], ["clipboard controls", {
                height: "fixed",
                width: "fixed"
              }]]
            }),
            position: pt(9.1, 11.7),
            submorphs: [{
              type: Label,
              name: "status label",
              borderRadius: 20,
              fill: Color.rgba(0, 0, 0, 0.30302366762504984),
              fontColor: Color.rgb(255, 255, 255),
              fontSize: 14,
              fontWeight: "bold",
              padding: rect(10, 4, 0, 0),
              textAndAttributes: ["Error ", null, "\uF071", {
                fontFamily: "Font Awesome",
                paddingTop: "3px"
              }]
            }, {
              type: Label,
              name: "file path",
              extent: pt(388.9, 18),
              clipMode: "hidden",
              fontColor: Color.rgb(253, 254, 254),
              fontFamily: "IBM Plex Mono",
              hideScrollbars: true,
              fontSize: 14,
              fixedWidth: true,
              fontWeight: "bold",
              textAndAttributes: ["lively.sync/client.js:Client#toString", null]
            }, {
              name: "clipboard controls",
              extent: pt(169.1, 27.7),
              fill: Color.rgba(0, 0, 0, 0),
              layout: new TilingLayout({
                align: "right",
                axisAlign: "center",
                orderByIndex: true,
                spacing: 5,
                hugContentsHorizontally: true
              }),
              submorphs: [part(__varRecorder__$c.EmbeddedIcon, {
                type: Label,
                tooltip: "Freeze this module",
                name: "freeze button",
                textAndAttributes: Icon.textAttribute("snowflake")
              }), part(__varRecorder__$c.EmbeddedIcon, {
                type: Label,
                tooltip: "Open file in editor",
                name: "open in editor"
              }), part(__varRecorder__$c.EmbeddedIcon, {
                type: Label,
                tooltip: "Open path in workspace",
                name: "copy to clipboard",
                textAndAttributes: Icon.textAttribute("clipboard")
              }), part(__varRecorder__$c.EmbeddedIcon, {
                type: Label,
                tooltip: "Jump to code entity",
                name: "jump to entity",
                textAndAttributes: Icon.textAttribute("search")
              }), part(__varRecorder__$c.EmbeddedIcon, {
                type: Label,
                tooltip: "Export markdown to HTML",
                name: "export to html",
                textAndAttributes: Icon.textAttribute("file-export")
              }), part(__varRecorder__$c.EmbeddedIcon, {
                type: Label,
                tooltip: "Run tests in this module",
                name: "run tests in module",
                visible: false,
                textAndAttributes: Icon.textAttribute("tachometer-alt")
              })]
            }]
          }, {
            type: Text,
            name: "status box",
            clipMode: "auto",
            extent: pt(560.7, 85.3),
            fill: Color.rgba(0, 0, 0, 0),
            fixedHeight: true,
            fixedWidth: true,
            fontColor: Color.rgb(255, 255, 255),
            fontFamily: "IBM Plex Sans",
            fontSize: 16,
            padding: rect(5, 0, -5, 0),
            lineWrapping: "by-words",
            readOnly: true
          }, {
            name: "error controls",
            extent: pt(205, 41),
            fill: Color.rgba(0, 0, 0, 0),
            layout: new TilingLayout({
              orderByIndex: true,
              hugContentsVertically: true,
              padding: {
                height: -8,
                width: 0,
                x: 8,
                y: 8
              },
              reactToSubmorphAnimations: false,
              spacing: 8
            }),
            position: pt(385, 123.5),
            submorphs: [part(__varRecorder__$c.EmbeddedIcon, {
              name: "close button",
              textAndAttributes: ["Close ", null, "\uF057", {
                fontFamily: "Font Awesome",
                paddingTop: "1px"
              }]
            }), part(__varRecorder__$c.EmbeddedIcon, {
              name: "open in workspace",
              textAndAttributes: ["Open in workspace ", null, "\uF360", {
                fontFamily: "Font Awesome",
                fontWeight: "900",
                paddingTop: "2px"
              }]
            })]
          }]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "MetaInfoContainerExpanded",
        range: {
          start: 30280,
          end: 34849
        }
      }, System, __varRecorder__$c, "MetaInfoContainerExpanded");
      __varRecorder__$c.MetaInfoContainerCollapsed = component["for"](function () {
        return component(__varRecorder__$c.MetaInfoContainerExpanded, {
          submorphs: [{
            name: "path container",
            submorphs: [{
              name: "status label",
              isLayoutable: false,
              opacity: 0
            }]
          }, {
            name: "status box",
            isLayoutable: false,
            reactsToPointer: false,
            opacity: 0
          }, {
            name: "error controls",
            reactsToPointer: false,
            opacity: 0,
            isLayoutable: false
          }]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "MetaInfoContainerCollapsed",
        range: {
          start: 34858,
          end: 35276
        }
      }, System, __varRecorder__$c, "MetaInfoContainerCollapsed");
      __varRecorder__$c.MetaInfoWarning = component["for"](function () {
        return component(__varRecorder__$c.MetaInfoContainerExpanded, {
          clipMode: "hidden",
          master: __varRecorder__$c.FileStatusWarning
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "MetaInfoWarning",
        range: {
          start: 35285,
          end: 35394
        }
      }, System, __varRecorder__$c, "MetaInfoWarning");
      __varRecorder__$c.MetaInfoError = component["for"](function () {
        return component(__varRecorder__$c.MetaInfoContainerExpanded, {
          clipMode: "hidden",
          master: __varRecorder__$c.FileStatusError
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "MetaInfoError",
        range: {
          start: 35403,
          end: 35504
        }
      }, System, __varRecorder__$c, "MetaInfoError");
      __varRecorder__$c.MetaInfoSaved = component["for"](function () {
        return component(__varRecorder__$c.MetaInfoContainerCollapsed, {
          clipMode: "hidden",
          master: __varRecorder__$c.FileStatusSaved,
          submorphs: [{
            name: "path container",
            submorphs: [{
              name: "status label",
              opacity: 1,
              isLayoutable: true
            }]
          }]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "MetaInfoSaved",
        range: {
          start: 35513,
          end: 35765
        }
      }, System, __varRecorder__$c, "MetaInfoSaved");
      __varRecorder__$c.MetaInfoInactive = component["for"](function () {
        return component(__varRecorder__$c.MetaInfoContainerCollapsed, {
          clipMode: "hidden",
          master: __varRecorder__$c.FileStatusInactive,
          submorphs: [{
            name: "path container",
            submorphs: [{
              name: "clipboard controls",
              visible: false
            }]
          }]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "MetaInfoInactive",
        range: {
          start: 35774,
          end: 36016
        }
      }, System, __varRecorder__$c, "MetaInfoInactive");
      __varRecorder__$c.SystemBrowser = component["for"](function () {
        return component({
          name: "system browser",
          defaultViewModel: BrowserModel,
          layout: new ConstraintLayout({
            lastExtent: {
              x: 605,
              y: 745
            },
            reactToSubmorphAnimations: false,
            submorphSettings: [["top side wrapper", {
              x: "resize",
              y: "fixed"
            }], ["source editor", {
              x: "resize",
              y: "resize"
            }], ["meta info text", {
              x: "resize",
              y: "fixed"
            }], ["vertical resizer", {
              x: "resize",
              y: "fixed"
            }]]
          }),
          extent: pt(605, 745),
          fill: Color.rgba(0, 0, 0, 0),
          position: pt(125.8, 1349.5),
          reactsToPointer: false,
          submorphs: [{
            type: Label,
            name: "smiley",
            isLayoutable: true,
            fontSize: 100,
            opacity: 0.2,
            position: pt(254, 456.7),
            textAndAttributes: Icon.textAttribute("smile")
          }, {
            name: "top side wrapper",
            reactsToPointer: false,
            extent: pt(605, 302.8),
            fill: Color.transparent,
            layout: new TilingLayout({
              align: "column",
              axis: "column",
              hugContentsVertically: true,
              resizePolicies: [["header buttons", {
                height: "fixed",
                width: "fill"
              }], ["tabs", {
                height: "fixed",
                width: "fill"
              }], ["column view", {
                height: "fixed",
                width: "fill"
              }]]
            }),
            submorphs: [{
              name: "header buttons",
              extent: pt(605, 49.8),
              fill: Color.rgba(0, 0, 0, 0),
              layout: new TilingLayout({
                axisAlign: "center",
                padding: rect(10, 0, -10, 0),
                resizePolicies: [["eval backend chooser wrapper", {
                  height: "fixed",
                  width: "fill"
                }]]
              }),
              reactsToPointer: false,
              submorphs: [part(SystemButton, {
                name: "go back",
                clipMode: "hidden",
                borderRadius: {
                  topLeft: 5,
                  topRight: 0,
                  bottomRight: 0,
                  bottomLeft: 5
                },
                tooltip: "Move backwards in history.",
                extent: pt(35, 26),
                padding: rect(10, 2, 3, -1),
                position: pt(7, 12.9),
                submorphs: [{
                  name: "label",
                  textAndAttributes: Icon.textAttribute("caret-left"),
                  fontSize: 20,
                  fontColor: Color.rgb(52, 73, 94)
                }]
              }), part(SystemButton, {
                name: "browse history",
                borderWidth: {
                  bottom: 1,
                  left: 0,
                  right: 0,
                  top: 1
                },
                extent: pt(35, 26),
                borderRadius: 0,
                padding: rect(10, 5, 0, 0),
                position: pt(40, 12.9),
                tooltip: "Browse navigation history.",
                submorphs: [{
                  name: "label",
                  textAndAttributes: Icon.textAttribute("history"),
                  fontSize: 14
                }]
              }), part(SystemButton, {
                name: "go forward",
                clipMode: "hidden",
                borderRadius: {
                  topLeft: 0,
                  topRight: 5,
                  bottomRight: 5,
                  bottomLeft: 0
                },
                tooltip: "Move forwards in history.",
                extent: pt(35, 26),
                padding: rect(15, 2, -5, -1),
                position: pt(74, 12.9),
                submorphs: [{
                  name: "label",
                  fontSize: 20,
                  fontColor: Color.rgb(52, 73, 94),
                  textAndAttributes: Icon.textAttribute("caret-right")
                }]
              }), {
                name: "spacer",
                fill: Color.rgba(255, 255, 255, 0),
                extent: pt(15.1, 45.9),
                position: pt(-15.2, 19.6)
              }, part(SystemButton, {
                name: "browse modules",
                extent: pt(35, 26),
                borderRadius: {
                  topLeft: 5,
                  topRight: 0,
                  bottomRight: 0,
                  bottomLeft: 5
                },
                tooltip: "Browse loaded modules in the system.",
                padding: rect(10, 5, 0, 0),
                position: pt(152, 12),
                submorphs: [{
                  name: "label",
                  fontColor: Color.rgb(52, 73, 94),
                  fontSize: 14,
                  textAndAttributes: Icon.textAttribute("list-alt")
                }]
              }), part(SystemButton, {
                name: "global search",
                borderWidth: {
                  bottom: 1,
                  left: 0,
                  right: 1,
                  top: 1
                },
                extent: pt(35, 26),
                borderRadius: {
                  topLeft: 0,
                  topRight: 0,
                  bottomRight: 0,
                  bottomLeft: 0
                },
                tooltip: "Open global code search.",
                padding: rect(10, 5, 0, 0),
                position: pt(186, 12),
                submorphs: [{
                  name: "label",
                  fontColor: Color.rgb(52, 73, 94),
                  fontSize: 14,
                  textAndAttributes: Icon.textAttribute("search")
                }]
              }), part(SystemButton, {
                name: "add tab",
                extent: pt(35, 26),
                tooltip: "Open up a new browser tab.",
                borderRadius: {
                  topLeft: 0,
                  topRight: 5,
                  bottomRight: 5,
                  bottomLeft: 0
                },
                borderWidth: {
                  left: 0,
                  top: 1,
                  bottom: 1,
                  right: 1
                },
                padding: rect(10, 5, 0, 0),
                position: pt(221, 12),
                submorphs: [{
                  name: "label",
                  fontColor: Color.rgb(52, 73, 94),
                  fontSize: 14,
                  textAndAttributes: Icon.textAttribute("plus")
                }]
              }), {
                name: "eval backend chooser wrapper",
                extent: pt(252.1, 39),
                fill: Color.rgba(0, 0, 0, 0),
                layout: new TilingLayout({
                  align: "right",
                  axisAlign: "center",
                  padding: rect(15, 15, 0, 0),
                  spacing: 15
                }),
                position: pt(354.8, 5.8),
                reactsToPointer: false,
                submorphs: [part(__varRecorder__$c.BackendButtonDefault, {
                  defaultViewModel: EvalBackendButtonModel,
                  master: {
                    auto: __varRecorder__$c.BackendButtonDefault,
                    click: __varRecorder__$c.BackendButtonClicked
                  },
                  name: "eval backend button",
                  tooltip: "Select evaluation backend for browser.",
                  padding: rect(5, 4, 0, 0),
                  nativeCursor: "pointer",
                  submorphs: [{
                    type: "label",
                    name: "label",
                    textAndAttributes: ["local", null]
                  }]
                })]
              }]
            }, part(Tabs, {
              name: "tabs",
              extent: pt(605, 32),
              position: pt(0, 50),
              viewModel: {
                showsSingleTab: false,
                defaultTabMaster: component(__varRecorder__$c.BrowserTabDefault, {
                  master: {
                    click: __varRecorder__$c.BrowserTabClicked,
                    hover: __varRecorder__$c.BrowserTabHovered,
                    states: {
                      selected: __varRecorder__$c.BrowserTabSelected
                    }
                  }
                })
              }
            }), part(MullerColumnView, {
              viewModel: {
                defaultTooltips: true
              },
              name: "column view",
              extent: pt(605, 221),
              borderWidthBottom: 1,
              borderWidthTop: 1,
              borderColor: Color.rgb(112, 123, 124),
              position: pt(0, 50)
            })]
          }, {
            type: Text,
            name: "source editor",
            readOnly: false,
            needsDocument: true,
            borderColor: Color.rgb(204, 204, 204),
            borderRadius: {
              topLeft: 0,
              topRight: 0,
              bottomRight: 6,
              bottomLeft: 6
            },
            borderWidth: 1,
            clipMode: "auto",
            extent: pt(605, 474),
            fixedHeight: true,
            fixedWidth: true,
            fontFamily: "\"IBM Plex Mono\"",
            lineWrapping: "by-chars",
            padding: rect(4, 60, 0, -60),
            position: pt(0, 271.1),
            scroll: pt(0, 15)
          }, part(__varRecorder__$c.MetaInfoContainerCollapsed, {
            name: "meta info text",
            master: {
              states: {
                warning: __varRecorder__$c.MetaInfoWarning,
                error: __varRecorder__$c.MetaInfoError,
                saved: __varRecorder__$c.MetaInfoSaved,
                inactive: __varRecorder__$c.MetaInfoInactive
              }
            },
            position: pt(9, 280.8)
          }), {
            type: HorizontalResizer,
            name: "vertical resizer",
            scalingAbove: ["column view"],
            scalingBelow: ["source editor"],
            fixed: ["meta info text"],
            extent: pt(605, 8.7),
            fill: Color.rgba(230, 230, 230, 0),
            position: pt(0, 271)
          }]
        });
      }, {
        module: "lively.ide/js/browser/ui.cp.js",
        "export": "SystemBrowser",
        range: {
          start: 36025,
          end: 44088
        }
      }, System, __varRecorder__$c, "SystemBrowser");
      var ComponentEditButton = __varRecorder__$c.ComponentEditButton;
      var FileStatusDefault = __varRecorder__$c.FileStatusDefault;
      var FileStatusError = __varRecorder__$c.FileStatusError;
      var FileStatusSaved = __varRecorder__$c.FileStatusSaved;
      var FileStatusInactive = __varRecorder__$c.FileStatusInactive;
      var FileStatusWarning = exports('F', __varRecorder__$c.FileStatusWarning);
      var BrowserTabDefault = __varRecorder__$c.BrowserTabDefault;
      var BrowserTabClicked = __varRecorder__$c.BrowserTabClicked;
      var BrowserTabSelected = __varRecorder__$c.BrowserTabSelected;
      var BrowserTabHovered = __varRecorder__$c.BrowserTabHovered;
      var BackendButtonDefault = __varRecorder__$c.BackendButtonDefault;
      var BackendButtonClicked = __varRecorder__$c.BackendButtonClicked;
      var BrowserDirectoryControls = __varRecorder__$c.BrowserDirectoryControls;
      var BrowserPackageControls = __varRecorder__$c.BrowserPackageControls;
      var SystemBrowser = __varRecorder__$c.SystemBrowser;
      var BehaviorToggleButton = __varRecorder__$c.BehaviorToggleButton;
      var BehaviorToggleButtonDisabled = __varRecorder__$c.BehaviorToggleButtonDisabled;
      __varRecorder__$c.ComponentEditButton = ComponentEditButton;
      __varRecorder__$c.FileStatusDefault = FileStatusDefault;
      __varRecorder__$c.FileStatusError = FileStatusError;
      __varRecorder__$c.FileStatusSaved = FileStatusSaved;
      __varRecorder__$c.FileStatusInactive = FileStatusInactive;
      __varRecorder__$c.FileStatusWarning = FileStatusWarning;
      __varRecorder__$c.BrowserTabDefault = BrowserTabDefault;
      __varRecorder__$c.BrowserTabClicked = BrowserTabClicked;
      __varRecorder__$c.BrowserTabSelected = BrowserTabSelected;
      __varRecorder__$c.BrowserTabHovered = BrowserTabHovered;
      __varRecorder__$c.BackendButtonDefault = BackendButtonDefault;
      __varRecorder__$c.BackendButtonClicked = BackendButtonClicked;
      __varRecorder__$c.DarkButton = DarkButton;
      __varRecorder__$c.BrowserDirectoryControls = BrowserDirectoryControls;
      __varRecorder__$c.BrowserPackageControls = BrowserPackageControls;
      __varRecorder__$c.SystemBrowser = SystemBrowser;
      __varRecorder__$c.open = open;
      __varRecorder__$c.browse = browse;
      __varRecorder__$c.browserForFile = browserForFile;
      __varRecorder__$c.BehaviorToggleButton = BehaviorToggleButton;
      __varRecorder__$c.BehaviorToggleButtonDisabled = BehaviorToggleButtonDisabled;

      var ui_cp$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        PathIndicator: PathIndicator,
        ComponentEditButton: ComponentEditButton,
        FileStatusDefault: FileStatusDefault,
        FileStatusError: FileStatusError,
        FileStatusSaved: FileStatusSaved,
        FileStatusInactive: FileStatusInactive,
        FileStatusWarning: FileStatusWarning,
        BrowserTabDefault: BrowserTabDefault,
        BrowserTabClicked: BrowserTabClicked,
        BrowserTabSelected: BrowserTabSelected,
        BrowserTabHovered: BrowserTabHovered,
        BackendButtonDefault: BackendButtonDefault,
        BackendButtonClicked: BackendButtonClicked,
        DarkButton: DarkButton,
        BrowserDirectoryControls: BrowserDirectoryControls,
        BrowserPackageControls: BrowserPackageControls,
        SystemBrowser: SystemBrowser,
        open: open,
        browse: browse,
        browserForFile: browserForFile,
        BehaviorToggleButton: BehaviorToggleButton,
        BehaviorToggleButtonDisabled: BehaviorToggleButtonDisabled
      });
      exports('ag', ui_cp$1);

      var __varRecorder__$b = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/dark-color-picker.cp.js", __contextModule__);
      __varRecorder__$b.DarkColorPicker = component["for"](function () {
        return component(ColorPicker, {
          name: "dark color picker",
          borderColor: Color.rgba(112, 123, 124, 1),
          fill: Color.rgb(66, 73, 73),
          submorphs: [{
            name: "header menu",
            borderWidth: {
              top: 0,
              left: 0,
              right: 0,
              bottom: 1
            },
            borderColor: Color.rgb(112, 123, 124),
            submorphs: [{
              name: "title",
              fontColor: Color.white
            }, {
              name: "color type selector",
              master: EnumSelector,
              viewModel: {
                listMaster: DarkThemeList,
                listAlign: "selection"
              }
            }, {
              name: "close button",
              master: {
                auto: DarkCloseButton,
                hover: DarkCloseButtonHovered
              }
            }]
          }, {
            name: "color controls",
            layout: new TilingLayout({
              axis: "column",
              axisAlign: "center",
              justifySubmorphs: "spaced",
              padding: rect(5, 15, 1, 0),
              resizePolicies: [["eye dropper button", {
                height: "fixed",
                width: "fill"
              }]],
              spacing: 10
            }),
            borderColor: Color.rgb(112, 123, 124),
            submorphs: [{
              name: "color encoding",
              submorphs: [{
                name: "color code selector",
                master: EnumSelector,
                viewModel: {
                  listMaster: DarkThemeList,
                  listHeight: 500,
                  listAlign: "selection"
                }
              }, {
                name: "controls",
                submorphs: [{
                  name: "hex encoding",
                  submorphs: [{
                    name: "hex opacity control",
                    master: DarkNumberIconWidget,
                    borderRadius: 0,
                    submorphs: [{
                      name: "value",
                      fontSize: 12,
                      fontColor: Color.rgbHex("B2EBF2")
                    }]
                  }, {
                    name: "hex input",
                    borderRadius: 0,
                    fill: Color.rgb(66, 73, 73),
                    fontColor: Color.rgbHex("B2EBF2")
                  }]
                }, {
                  name: "3 val encoding",
                  fill: Color.rgb(189, 195, 199),
                  submorphs: [{
                    name: "opacity control",
                    master: DarkNumberIconWidget,
                    borderRadius: 0,
                    submorphs: [{
                      name: "value",
                      fontColor: Color.rgbHex("B2EBF2"),
                      fontSize: 12
                    }]
                  }, {
                    name: "first value",
                    master: DarkNumberIconWidget,
                    borderRadius: 0,
                    submorphs: [{
                      name: "value",
                      fontColor: Color.rgbHex("B2EBF2"),
                      fontSize: 12
                    }]
                  }, {
                    name: "second value",
                    master: DarkNumberIconWidget,
                    borderRadius: 0,
                    submorphs: [{
                      name: "value",
                      fontColor: Color.rgbHex("B2EBF2"),
                      fontSize: 12
                    }]
                  }, {
                    name: "third value",
                    master: DarkNumberIconWidget,
                    borderRadius: 0,
                    submorphs: [{
                      name: "value",
                      fontColor: Color.rgbHex("B2EBF2"),
                      fontSize: 12
                    }]
                  }]
                }, {
                  name: "css encoding",
                  layout: new TilingLayout({
                    align: "center",
                    padding: rect(1, 1, 0, 0),
                    resizePolicies: [["css input", {
                      height: "fixed",
                      width: "fill"
                    }]],
                    spacing: 1
                  }),
                  submorphs: [{
                    name: "css input",
                    textAlign: "center",
                    master: TextInput,
                    borderRadius: 0
                  }]
                }]
              }, {
                name: "color copier",
                fontColor: Color.white
              }]
            }, {
              name: "eye dropper button",
              layout: new TilingLayout({
                align: "center",
                axisAlign: "center",
                padding: rect(5, 0, 0, 0)
              }),
              master: BackendButtonDefault,
              borderColor: Color.fromString("95A5A6"),
              fill: Color.transparent
            }]
          }, {
            name: "color palettes",
            submorphs: [{
              name: "color palette selector",
              master: EnumSelector,
              viewModel: {
                listMaster: DarkThemeList,
                listAlign: "selection"
              }
            }]
          }]
        });
      }, {
        module: "lively.ide/studio/dark-color-picker.cp.js",
        "export": "DarkColorPicker",
        range: {
          start: 422,
          end: 4761
        }
      }, System, __varRecorder__$b, "DarkColorPicker");
      var DarkColorPicker = exports('x', __varRecorder__$b.DarkColorPicker);
      __varRecorder__$b.DarkColorPicker = DarkColorPicker;

      var __varRecorder__$a = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/controls/popups.cp.js", __contextModule__);
      var __moduleMeta__$4 = {
        pathInPackage: function pathInPackage() {
          return "./studio/controls/popups.cp.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var parameterizedNumberPopupLight = __varRecorder__$a["lively.ide/studio/controls/popups.cp.js__define__"]("parameterizedNumberPopupLight", "function", function (spec) {
        var title = spec.title,
            tooltip = spec.tooltip,
            value = spec.value,
            min = spec.min,
            max = spec.max,
            baseFactor = spec.baseFactor,
            floatingPoint = spec.floatingPoint;
        title = tokens(decamelize(title)).map(function (m) {
          return capitalize(m);
        }).join(" ");
        return component(__varRecorder__$a.NumberPopupLight, {
          viewModel: {
            value: value
          },
          hasFixedPosition: true,
          submorphs: [{
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: [title, null]
            }]
          }, {
            name: "footer",
            submorphs: [{
              name: "value input",
              viewModel: {
                min: min,
                max: max,
                baseFactor: baseFactor,
                floatingPoint: floatingPoint
              }
            }],
            tooltip: tooltip
          }]
        });
      }, __moduleMeta__$4);

      __varRecorder__$a.parameterizedNumberPopupLight = parameterizedNumberPopupLight;
      var PopupModel = exports('v', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/controls/popups.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PopupModel") && typeof __lively_classholder__.PopupModel === "function" ? __lively_classholder__.PopupModel : __lively_classholder__.PopupModel = function PopupModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "alignAtButton",
          value: function PopupModel_alignAtButton_(btn) {
            this.view.height = 25;
            this.view.topRight = btn.globalBounds().bottomRight().addXY(0, 5);
            this.view.topLeft = this.world().visibleBounds().translateForInclusion(this.view.globalBounds()).topLeft();
          }
        }, {
          key: "close",
          value: function PopupModel_close_() {
            this.view.remove();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PopupModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              liveStyleClasses: {
                defaultValues: ["Popup"]
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "onMouseDown",
                    handler: "close"
                  }];
                }
              },
              expose: {
                get: function get() {
                  return ["close"];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/controls/popups.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 937,
          end: 1736
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      }));
      __varRecorder__$a.PopupModel = PopupModel;
      __varRecorder__$a.PopupModel = PopupModel;
      var ShadowPopupModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/controls/popups.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ShadowPopupModel") && typeof __lively_classholder__.ShadowPopupModel === "function" ? __lively_classholder__.ShadowPopupModel : __lively_classholder__.ShadowPopupModel = function ShadowPopupModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "isPropertiesPanelPopup",
          get: function get() {
            return true;
          }
        }, {
          key: "attach",
          value: function ShadowPopupModel_attach_(view) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "attach", this).call(this, view);

            this.update();
          }
        }, {
          key: "onRefresh",
          value: function ShadowPopupModel_onRefresh_(prop) {
            if (!this.view) return;
            if (prop === "fastShadow") this.update();
            if (prop === "insetShadow") this.update();
          }
        }, {
          key: "initFrom",
          value: function ShadowPopupModel_initFrom_(shadowValue) {
            if (shadowValue) this.fastShadow = shadowValue.fast;
            this.shadowValue = shadowValue;
            this.update();
          }
        }, {
          key: "toggleFastShadow",
          value: function ShadowPopupModel_toggleFastShadow_() {
            this.fastShadow = !this.fastShadow;
            this.confirm();
          }
        }, {
          key: "update",
          value: function ShadowPopupModel_update_() {
            var _this = this;

            this.withoutBindingsDo(function () {
              var _this$ui = _this.ui,
                  fastShadowCheckbox = _this$ui.fastShadowCheckbox,
                  spreadInput = _this$ui.spreadInput,
                  blurInput = _this$ui.blurInput,
                  xOffset = _this$ui.xOffset,
                  yOffset = _this$ui.yOffset,
                  buffer = _this$ui.buffer,
                  shadowColorInput = _this$ui.shadowColorInput,
                  title = _this$ui.title,
                  footer = _this$ui.footer;
              fastShadowCheckbox.checked = !_this.fastShadow;
              var p = Point.polar(_this.shadowValue.distance, toRadians(_this.shadowValue.rotation));
              xOffset.number = p.x;
              yOffset.number = p.y;
              spreadInput.number = _this.shadowValue.spread;
              blurInput.number = _this.shadowValue.blur;
              shadowColorInput.setColor(_this.shadowValue.color);
              title.textString = _this.insetShadow ? "Inner Shadow" : "Drop Shadow";
              footer.visible = !_this.insetShadow;
              buffer.height = !_this.insetShadow ? 10 : 20;
            });
          }
        }, {
          key: "confirm",
          value: function ShadowPopupModel_confirm_() {
            var _this$ui2 = this.ui,
                shadowColorInput = _this$ui2.shadowColorInput,
                spreadInput = _this$ui2.spreadInput,
                blurInput = _this$ui2.blurInput,
                xOffset = _this$ui2.xOffset,
                yOffset = _this$ui2.yOffset;
            var polar = pt(xOffset.number, yOffset.number);
            var distance = polar.r();
            var rotation = toDegrees(polar.theta()) % 360;
            this.shadowValue = new ShadowObject({
              fast: this.fastShadow,
              inset: this.insetShadow,
              color: shadowColorInput.colorValue,
              blur: blurInput.number,
              spread: spreadInput.number,
              distance: distance,
              rotation: rotation
            });
            signal(this.view, "value", this.shadowValue);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ShadowPopupModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              fastShadow: {
                defaultValue: false
              },
              insetShadow: {
                defaultValue: false
              },
              isHaloItem: {
                defaultValue: true
              },
              shadowValue: {
                initialize: function initialize() {
                  this.shadowValue = new ShadowObject({});
                }
              },
              expose: {
                get: function get() {
                  return ["isHaloItem", "isPropertiesPanelPopup", "close", "shadowValue"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "onMouseDown",
                    handler: "close"
                  }, {
                    target: "fast shadow checkbox",
                    signal: "checked",
                    handler: "toggleFastShadow"
                  }, {
                    target: "x offset",
                    signal: "number",
                    handler: "confirm"
                  }, {
                    target: "y offset",
                    signal: "number",
                    handler: "confirm"
                  }, {
                    target: "blur input",
                    signal: "number",
                    handler: "confirm"
                  }, {
                    target: "spread input",
                    signal: "number",
                    handler: "confirm"
                  }, {
                    target: "shadow color input",
                    signal: "color",
                    handler: "confirm"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/controls/popups.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 1745,
          end: 5107
        });
      }(__varRecorder__$a.PopupModel);
      __varRecorder__$a.ShadowPopupModel = ShadowPopupModel;
      __varRecorder__$a.ShadowPopupModel = ShadowPopupModel;
      var SingleNumberModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/controls/popups.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("SingleNumberModel") && typeof __lively_classholder__.SingleNumberModel === "function" ? __lively_classholder__.SingleNumberModel : __lively_classholder__.SingleNumberModel = function SingleNumberModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "isPropertiesPanelPopup",
          get: function get() {
            return true;
          }
        }, {
          key: "attach",
          value: function SingleNumberModel_attach_(view) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "attach", this).call(this, view);

            this.ui.valueInput.number = this.value;
          }
        }, {
          key: "onValueChanged",
          value: function SingleNumberModel_onValueChanged_() {
            this.value = this.ui.valueInput.number;
            signal(this.view, "value", this.value);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "SingleNumberModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              value: {},
              isHaloItem: {
                defaultValue: true
              },
              expose: {
                get: function get() {
                  return ["isHaloItem", "value", "isPropertiesPanelPopup", "close"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "onMouseDown",
                    handler: "close"
                  }, {
                    target: "value input",
                    signal: "number",
                    handler: "onValueChanged"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/controls/popups.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 5235,
          end: 6001
        });
      }(__varRecorder__$a.PopupModel);
      __varRecorder__$a.SingleNumberModel = SingleNumberModel;
      __varRecorder__$a.SingleNumberModel = SingleNumberModel;
      var SingleSelectionModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/controls/popups.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("SingleSelectionModel") && typeof __lively_classholder__.SingleSelectionModel === "function" ? __lively_classholder__.SingleSelectionModel : __lively_classholder__.SingleSelectionModel = function SingleSelectionModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "isPropertiesPanelPopup",
          get: function get() {
            return true;
          }
        }, {
          key: "attach",
          value: function SingleSelectionModel_attach_(view) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "attach", this).call(this, view);

            this.ui.selectionInput.selection = this.selection;
          }
        }, {
          key: "onSelectionChanged",
          value: function SingleSelectionModel_onSelectionChanged_() {
            this.selection = this.ui.selectionInput.selection;
            signal(this.view, "value", this.selection);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "SingleSelectionModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              selection: {},
              isHaloItem: {
                defaultValue: true
              },
              expose: {
                get: function get() {
                  return ["isHaloItem", "isPropertiesPanelPopup", "close"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "onMouseDown",
                    handler: "close"
                  }, {
                    target: "selection input",
                    signal: "selection",
                    handler: "onSelectionChanged"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/controls/popups.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 6145,
          end: 6950
        });
      }(__varRecorder__$a.PopupModel);
      __varRecorder__$a.SingleSelectionModel = SingleSelectionModel;
      __varRecorder__$a.SingleSelectionModel = SingleSelectionModel;
      var PaddingControlsModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/controls/popups.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PaddingControlsModel") && typeof __lively_classholder__.PaddingControlsModel === "function" ? __lively_classholder__.PaddingControlsModel : __lively_classholder__.PaddingControlsModel = function PaddingControlsModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "startPadding",
          value: function PaddingControlsModel_startPadding_(pad) {
            var _this2 = this;

            this.withoutBindingsDo(function () {
              var left = pad.left();
              var right = pad.right();
              var bottom = pad.bottom();
              var top = pad.top();
              _this2.showAllSidesControl = !(uniq([left, right, top, bottom]).length === 1);
              _this2.ui.paddingBottom.number = bottom;
              _this2.ui.paddingLeft.number = left;
              _this2.ui.paddingRight.number = right;
              _this2.ui.paddingTop.number = top;
              if (!_this2.showAllSidesControl) _this2.ui.paddingAll.number = left;else _this2.ui.paddingAll.setMixed();
            });
          }
        }, {
          key: "viewDidLoad",
          value: function PaddingControlsModel_viewDidLoad_() {
            this.update();
          }
        }, {
          key: "onRefresh",
          value: function PaddingControlsModel_onRefresh_(prop) {
            if (prop === "showAllSidesControl") {
              this.update();
            }
          }
        }, {
          key: "update",
          value: function PaddingControlsModel_update_() {
            var _this$ui3 = this.ui,
                paddingAll = _this$ui3.paddingAll,
                multiPaddingControl = _this$ui3.multiPaddingControl,
                independentPaddingToggle = _this$ui3.independentPaddingToggle;
            paddingAll.visible = !this.showAllSidesControl;
            multiPaddingControl.visible = this.showAllSidesControl;
            independentPaddingToggle.master.setState(this.showAllSidesControl ? "active" : null);
          }
        }, {
          key: "focusField",
          value: function PaddingControlsModel_focusField_(focusedField) {
            var paddingIndicator = this.ui.paddingIndicator;

            switch (focusedField) {
              case "top":
                paddingIndicator.rotation = 0;
                break;

              case "right":
                paddingIndicator.rotation = Math.PI / 2;
                break;

              case "bottom":
                paddingIndicator.rotation = Math.PI;
                break;

              case "left":
                paddingIndicator.rotation = -Math.PI / 2;
                break;
            }
          }
        }, {
          key: "confirm",
          value: function PaddingControlsModel_confirm_() {
            var _this$ui4 = this.ui,
                paddingAll = _this$ui4.paddingAll,
                multiPaddingControl = _this$ui4.multiPaddingControl,
                paddingTop = _this$ui4.paddingTop,
                paddingRight = _this$ui4.paddingRight,
                paddingBottom = _this$ui4.paddingBottom,
                paddingLeft = _this$ui4.paddingLeft;

            if (paddingAll.visible) {
              signal(this, "paddingChanged", rect(paddingAll.number, paddingAll.number, 0, 0));
              paddingLeft.number = paddingRight.number = paddingTop.number = paddingBottom.number = paddingAll.number;
            }

            if (multiPaddingControl.visible) {
              signal(this, "paddingChanged", Rectangle.inset(paddingLeft.number, paddingTop.number, paddingRight.number, paddingBottom.number));
              if (paddingTop.number === paddingLeft.number && paddingTop.number === paddingRight.number && paddingTop.number === paddingBottom.number) paddingAll.number = paddingLeft.number;else paddingAll.setMixed();
            }
          }
        }, {
          key: "toggleAllSidesPadding",
          value: function PaddingControlsModel_toggleAllSidesPadding_() {
            this.showAllSidesControl = !this.showAllSidesControl;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PaddingControlsModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              showAllSidesControl: {
                defaultValue: false
              },
              expose: {
                get: function get() {
                  return ["paddingChanged", "startPadding"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "independent padding toggle",
                    signal: "onMouseDown",
                    handler: "toggleAllSidesPadding"
                  }, {
                    target: "padding top",
                    signal: "onMouseDown",
                    handler: "focusField",
                    converter: function converter() {
                      return "top";
                    }
                  }, {
                    target: "padding right",
                    signal: "onMouseDown",
                    handler: "focusField",
                    converter: function converter() {
                      return "right";
                    }
                  }, {
                    target: "padding bottom",
                    signal: "onMouseDown",
                    handler: "focusField",
                    converter: function converter() {
                      return "bottom";
                    }
                  }, {
                    target: "padding left",
                    signal: "onMouseDown",
                    handler: "focusField",
                    converter: function converter() {
                      return "left";
                    }
                  }, {
                    target: "padding top",
                    signal: "numberChanged",
                    handler: "confirm"
                  }, {
                    target: "padding right",
                    signal: "numberChanged",
                    handler: "confirm"
                  }, {
                    target: "padding bottom",
                    signal: "numberChanged",
                    handler: "confirm"
                  }, {
                    target: "padding left",
                    signal: "numberChanged",
                    handler: "confirm"
                  }, {
                    target: "padding all",
                    signal: "numberChanged",
                    handler: "confirm"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/controls/popups.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 6959,
          end: 10619
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$a.PaddingControlsModel = PaddingControlsModel;
      __varRecorder__$a.PaddingControlsModel = PaddingControlsModel;
      var PaddingPopupModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/controls/popups.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PaddingPopupModel") && typeof __lively_classholder__.PaddingPopupModel === "function" ? __lively_classholder__.PaddingPopupModel : __lively_classholder__.PaddingPopupModel = function PaddingPopupModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "startPadding",
          value: function PaddingPopupModel_startPadding_(pad) {
            this.ui.paddingControls.startPadding(pad);
          }
        }, {
          key: "isPropertiesPanelPopup",
          get: function get() {
            return true;
          }
        }, {
          key: "paddingChanged",
          value: function PaddingPopupModel_paddingChanged_(padding) {
            signal(this, "paddingChanged", padding);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PaddingPopupModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["isPropertiesPanelPopup", "close", "startPadding", "paddingChanged"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "padding controls",
                    signal: "paddingChanged",
                    handler: "paddingChanged"
                  }, {
                    target: "close button",
                    signal: "onMouseDown",
                    handler: "close"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/controls/popups.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 10628,
          end: 11339
        });
      }(__varRecorder__$a.PopupModel);
      __varRecorder__$a.PaddingPopupModel = PaddingPopupModel;
      __varRecorder__$a.PaddingPopupModel = PaddingPopupModel;
      var PositionPopupModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/controls/popups.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PositionPopupModel") && typeof __lively_classholder__.PositionPopupModel === "function" ? __lively_classholder__.PositionPopupModel : __lively_classholder__.PositionPopupModel = function PositionPopupModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "isPropertiesPanelPopup",
          get: function get() {
            return true;
          }
        }, {
          key: "setPoint",
          value: function PositionPopupModel_setPoint_(point) {
            var _this$ui5 = this.ui,
                positionYInput = _this$ui5.positionYInput,
                positionXInput = _this$ui5.positionXInput;
            positionXInput.number = point.x;
            positionYInput.number = point.y;
          }
        }, {
          key: "confirm",
          value: function PositionPopupModel_confirm_() {
            var _this$ui6 = this.ui,
                positionYInput = _this$ui6.positionYInput,
                positionXInput = _this$ui6.positionXInput;
            signal(this.view, "value", pt(positionXInput.number, positionYInput.number));
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PositionPopupModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["setPoint", "isPropertiesPanelPopup", "close"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "onMouseDown",
                    handler: "close"
                  }, {
                    target: "position x input",
                    signal: "numberChanged",
                    handler: "confirm"
                  }, {
                    target: "position y input",
                    signal: "numberChanged",
                    handler: "confirm"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/controls/popups.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 11348,
          end: 12364
        });
      }(__varRecorder__$a.PopupModel);
      __varRecorder__$a.PositionPopupModel = PositionPopupModel;
      __varRecorder__$a.PositionPopupModel = PositionPopupModel;
      __varRecorder__$a.ShadowPopup = component["for"](function () {
        return component(DarkPopupWindow, {
          defaultViewModel: __varRecorder__$a.ShadowPopupModel,
          name: "shadow popup",
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "center",
            hugContentsHorizontally: true,
            hugContentsVertically: true,
            orderByIndex: true,
            resizePolicies: [["header menu", {
              height: "fixed",
              width: "fill"
            }], ["footer", {
              height: "fixed",
              width: "fill"
            }]]
          }),
          extent: pt(241.4, 191),
          submorphs: [{
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: ["Shadow", null]
            }]
          }, add({
            name: "shadow controls",
            borderColor: Color.rgb(23, 160, 251),
            borderWidth: 0,
            extent: pt(241, 76.6),
            layout: new TilingLayout({
              align: "right",
              hugContentsVertically: true,
              justifySubmorphs: "spaced",
              orderByIndex: true,
              padding: rect(48, 10, -15, -2),
              spacing: 10,
              wrapSubmorphs: true
            }),
            fill: Color.rgba(0, 0, 0, 0),
            submorphs: [part(DarkNumberIconWidget, {
              name: "x offset",
              width: 70,
              submorphs: [{
                name: "interactive label",
                fontFamily: "IBM Plex Mono",
                fontSize: 13,
                padding: rect(8, 0, -1, 0),
                textAndAttributes: ["X", null]
              }],
              tooltip: "X offset"
            }), part(DarkNumberIconWidget, {
              name: "blur input",
              extent: pt(80, 22),
              viewModel: {
                min: 0
              },
              submorphs: [{
                name: "interactive label",
                fontSize: 14,
                fontFamily: "Material Icons",
                textAndAttributes: ["\uE3A5", null]
              }],
              tooltip: "Shadow blur"
            }), part(DarkNumberIconWidget, {
              name: "y offset",
              width: 70,
              submorphs: [{
                name: "interactive label",
                fontFamily: "IBM Plex Mono",
                fontSize: 13,
                padding: rect(7, 0, 0, 0),
                textAndAttributes: ["Y", null]
              }],
              tooltip: "Y offset"
            }), part(DarkNumberIconWidget, {
              name: "spread input",
              extent: pt(80, 22),
              viewModel: {
                min: 0
              },
              submorphs: [{
                name: "interactive label",
                fontSize: 14,
                fontFamily: "Material Icons",
                textAndAttributes: ["\uE3E0", null]
              }],
              tooltip: "Shadow spread"
            })]
          }), add(part(ColorInput, {
            name: "shadow color input",
            height: 27,
            viewModel: {
              colorPickerComponent: DarkColorPicker
            },
            submorphs: [{
              name: "hex input",
              extent: pt(70, 23),
              textAndAttributes: ["FFFFFF", null]
            }, {
              name: "opacity input",
              width: 80
            }]
          })), add({
            name: "buffer",
            height: 10,
            fill: Color.transparent
          }), add({
            name: "footer",
            borderColor: Color.rgbHex("616A6B"),
            borderWidth: 1,
            extent: pt(241, 50.3),
            fill: Color.rgba(0, 0, 0, 0),
            submorphs: [{
              name: "h wrapper",
              borderColor: Color.rgb(23, 160, 251),
              extent: pt(228, 31),
              fill: Color.rgba(0, 0, 0, 0),
              layout: new TilingLayout({
                axisAlign: "center",
                orderByIndex: true,
                padding: rect(15, 0, -10, 0)
              }),
              position: pt(6.2, 9.5),
              submorphs: [part(LabeledCheckboxOnDark, {
                name: "fast shadow checkbox",
                viewModel: {
                  label: "Show behind transparent areas"
                }
              })]
            }]
          })]
        });
      }, {
        module: "lively.ide/studio/controls/popups.cp.js",
        "export": "ShadowPopup",
        range: {
          start: 12372,
          end: 15653
        }
      }, System, __varRecorder__$a, "ShadowPopup");
      __varRecorder__$a.NumberWidgetLight = component["for"](function () {
        return component(DefaultNumberWidget, {
          name: "number widget/light",
          layout: new TilingLayout({
            align: "center",
            axisAlign: "center",
            justifySubmorphs: "spaced",
            padding: rect(0, 0, 5, 0),
            resizePolicies: [["value", {
              height: "fixed",
              width: "fixed"
            }]]
          }),
          borderColor: Color.rgbHex("CCCCCC"),
          borderRadius: 2,
          borderWidth: 1,
          dropShadow: null,
          submorphs: [{
            name: "value",
            fontColor: Color.black,
            cursorColor: Color.gray,
            fontSize: 14
          }, without("button holder")]
        });
      }, {
        module: "lively.ide/studio/controls/popups.cp.js",
        "export": "NumberWidgetLight",
        range: {
          start: 15662,
          end: 16207
        }
      }, System, __varRecorder__$a, "NumberWidgetLight");
      __varRecorder__$a.NumberPopupLight = component["for"](function () {
        return component(PopupWindow, {
          defaultViewModel: __varRecorder__$a.SingleNumberModel,
          name: "number popup",
          layout: new TilingLayout({
            axis: "column",
            hugContentsHorizontally: true,
            hugContentsVertically: true
          }),
          submorphs: [{
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: ["d", null]
            }]
          }, add({
            name: "footer",
            borderColor: Color.rgb(97, 106, 107),
            borderWidth: 0,
            extent: pt(70, 50.3),
            fill: Color.rgba(0, 0, 0, 0),
            submorphs: [part(__varRecorder__$a.NumberWidgetLight, {
              name: "value input",
              viewModel: {
                min: 0
              },
              position: pt(11.3, 14),
              submorphs: [{
                name: "interactive label",
                fontSize: 14,
                fontFamily: "Material Icons",
                textAndAttributes: ["\uE3A5", null]
              }],
              tooltip: "Object Blur"
            })]
          })]
        });
      }, {
        module: "lively.ide/studio/controls/popups.cp.js",
        "export": "NumberPopupLight",
        range: {
          start: 16216,
          end: 17059
        }
      }, System, __varRecorder__$a, "NumberPopupLight");
      __varRecorder__$a.parameterizedNumberPopupLight = parameterizedNumberPopupLight;
      __varRecorder__$a.PositionPopupLight = component["for"](function () {
        return component(PopupWindow, {
          name: "position popup/light",
          defaultViewModel: __varRecorder__$a.PositionPopupModel,
          submorphs: [{
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: ["Position", null]
            }]
          }, add({
            name: "position controls",
            extent: pt(241, 43.6),
            layout: new TilingLayout({
              orderByIndex: true,
              padding: rect(10, 10, 0, 0),
              spacing: 20
            }),
            submorphs: [part(DarkNumberIconWidget, {
              name: "position x input",
              master: __varRecorder__$a.NumberWidgetLight,
              submorphs: [{
                name: "interactive label",
                fontSize: 13,
                fontFamily: "IBM Plex Mono",
                padding: rect(8, 0, -1, 0),
                textAndAttributes: ["X", null],
                fontColor: Color.rgba(101, 135, 139, 0.5)
              }]
            }), part(DarkNumberIconWidget, {
              name: "position y input",
              master: __varRecorder__$a.NumberWidgetLight,
              submorphs: [{
                name: "interactive label",
                fontSize: 13,
                fontFamily: "IBM Plex Mono",
                padding: rect(8, 0, -1, 0),
                textAndAttributes: ["Y", null],
                fontColor: Color.rgba(101, 135, 139, 0.5)
              }]
            })]
          })]
        });
      }, {
        module: "lively.ide/studio/controls/popups.cp.js",
        "export": "PositionPopupLight",
        range: {
          start: 17759,
          end: 19073
        }
      }, System, __varRecorder__$a, "PositionPopupLight");
      __varRecorder__$a.ShadowPopupLight = component["for"](function () {
        return component(__varRecorder__$a.ShadowPopup, {
          name: "shadow popup/light",
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "center",
            hugContentsHorizontally: true,
            hugContentsVertically: true,
            orderByIndex: true,
            resizePolicies: [["header menu", {
              height: "fixed",
              width: "fill"
            }], ["footer", {
              height: "fixed",
              width: "fill"
            }]],
            wrapSubmorphs: false
          }),
          master: PopupWindow,
          submorphs: [{
            name: "shadow controls",
            submorphs: [{
              name: "x offset",
              master: __varRecorder__$a.NumberWidgetLight,
              submorphs: [{
                name: "interactive label",
                fontColor: Color.rgba(101, 135, 139, 0.5)
              }]
            }, {
              name: "blur input",
              master: __varRecorder__$a.NumberWidgetLight,
              submorphs: [{
                name: "interactive label",
                fontColor: Color.rgba(101, 135, 139, 0.5)
              }]
            }, {
              name: "y offset",
              master: __varRecorder__$a.NumberWidgetLight,
              submorphs: [{
                name: "interactive label",
                fontColor: Color.rgba(101, 135, 139, 0.5)
              }]
            }, {
              name: "spread input",
              master: __varRecorder__$a.NumberWidgetLight,
              submorphs: [{
                name: "interactive label",
                fontColor: Color.rgba(101, 135, 139, 0.5)
              }]
            }]
          }, {
            name: "shadow color input",
            submorphs: [{
              name: "hex input",
              borderRadius: 2,
              borderWidth: 1,
              dropShadow: null,
              fontSize: 14,
              master: InputLineDefault
            }, {
              name: "opacity input",
              master: __varRecorder__$a.NumberWidgetLight,
              submorphs: [{
                name: "interactive label",
                fontColor: Color.rgba(101, 135, 139, 0.5)
              }]
            }]
          }, {
            name: "footer",
            borderColor: Color.rgbHex("D7DBDD"),
            borderWidthLeft: 0,
            submorphs: [{
              name: "h wrapper",
              submorphs: [{
                name: "fast shadow checkbox",
                master: LabeledCheckboxLight
              }]
            }]
          }]
        });
      }, {
        module: "lively.ide/studio/controls/popups.cp.js",
        "export": "ShadowPopupLight",
        range: {
          start: 19082,
          end: 21300
        }
      }, System, __varRecorder__$a, "ShadowPopupLight");
      __varRecorder__$a.InsetShadowPopup = component["for"](function () {
        return component(__varRecorder__$a.ShadowPopup, {
          name: "inset shadow popup",
          submorphs: [{
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: ["Inset Shadow", null]
            }]
          }]
        });
      }, {
        module: "lively.ide/studio/controls/popups.cp.js",
        "export": "InsetShadowPopup",
        range: {
          start: 21309,
          end: 21525
        }
      }, System, __varRecorder__$a, "InsetShadowPopup");
      __varRecorder__$a.PaddingControlsLight = component["for"](function () {
        var _add, _ref, _part;

        return component({
          name: "padding controls",
          defaultViewModel: __varRecorder__$a.PaddingControlsModel,
          layout: new TilingLayout({
            align: "right",
            axisAlign: "center",
            orderByIndex: true,
            padding: rect(0, 0, 27, 0),
            spacing: 5
          }),
          extent: pt(250, 30),
          fill: Color.rgba(0, 0, 0, 0),
          submorphs: [part(__varRecorder__$a.NumberWidgetLight, {
            name: "padding all",
            viewModel: {
              min: 0,
              number: 0
            },
            extent: pt(60, 22),
            position: pt(9.7, 6.6),
            tooltip: "Padding",
            borderRadius: 2,
            submorphs: [add((_add = {
              type: Label,
              name: "interactive label",
              fontFamily: "Material Icons",
              fontColor: Color.rgba(101, 135, 139),
              padding: rect(8, 0, -1, 0),
              lineHeight: 1,
              fontSize: 16
            }, _defineProperty(_add, "fontFamily", "Material Icons"), _defineProperty(_add, "textAndAttributes", ["\uE22F", null]), _add), "value"), {
              name: "value",
              fontSize: 14,
              width: 60
            }]
          }), {
            name: "multi padding control",
            position: pt(7.6, 33.4),
            layout: new TilingLayout({
              align: "center",
              axisAlign: "center",
              orderByIndex: true,
              spacing: 1
            }),
            fill: Color.transparent,
            extent: pt(175, 30),
            clipMode: "hidden",
            submorphs: [{
              name: "centering wrapper",
              fill: Color.transparent,
              clipMode: "hidden",
              layout: new TilingLayout({
                align: "center",
                axisAlign: "center"
              }),
              extent: pt(30, 30),
              submorphs: [(_ref = {
                type: Label,
                name: "padding indicator",
                fill: Color.rgba(229, 231, 233, 0),
                fontColor: Color.rgb(101, 135, 139),
                fontFamily: "Material Icons",
                padding: rect(7, 5, 0, 0),
                fontSize: 16
              }, _defineProperty(_ref, "fontFamily", "Material Icons"), _defineProperty(_ref, "textAndAttributes", ["\uE25A", null]), _ref)]
            }, part(__varRecorder__$a.NumberWidgetLight, {
              name: "padding left",
              viewModel: {
                min: 0
              },
              extent: pt(35, 22),
              tooltip: "Leftside Padding",
              borderRadiusTopRight: 0,
              borderRadiusBottomRight: 0,
              borderRadiusTopleft: 2,
              borderRadiusBottomLeft: 2,
              submorphs: [{
                name: "value",
                fontSize: 14,
                width: 35
              }, without("interactive label")]
            }), part(__varRecorder__$a.NumberWidgetLight, {
              name: "padding top",
              viewModel: {
                min: 0
              },
              borderRadius: 0,
              extent: pt(35, 22),
              tooltip: "Topside Padding",
              submorphs: [{
                name: "value",
                fontSize: 14,
                width: 35
              }, without("interactive label")]
            }), part(__varRecorder__$a.NumberWidgetLight, {
              name: "padding right",
              viewModel: {
                min: 0
              },
              borderRadius: 0,
              extent: pt(35, 22),
              tooltip: "Rightside Padding",
              submorphs: [{
                name: "value",
                fontSize: 14,
                width: 35
              }, without("interactive label")]
            }), part(__varRecorder__$a.NumberWidgetLight, {
              name: "padding bottom",
              viewModel: {
                min: 0
              },
              borderRadiusTopLeft: 0,
              borderRadiusBottomLeft: 0,
              borderRadiusTopRight: 2,
              borderRadiusBottomRight: 2,
              extent: pt(35, 22),
              tooltip: "Bottomside Padding",
              submorphs: [{
                name: "value",
                fontSize: 14,
                width: 35
              }, without("interactive label")]
            })]
          }, part(PropertyLabel, (_part = {
            name: "independent padding toggle",
            padding: rect(2, 2),
            lineHeight: 1,
            fontSize: 14,
            master: {
              auto: PropertyLabelLight,
              states: {
                active: PropertyLabelActiveLight
              },
              hover: PropertyLabelHoveredLight
            },
            tooltip: "Toggle independent Fields per Direction",
            fontFamily: "Material Icons"
          }, _defineProperty(_part, "fontSize", 18), _defineProperty(_part, "textAndAttributes", ["\uE5D0", null]), _part))]
        });
      }, {
        module: "lively.ide/studio/controls/popups.cp.js",
        "export": "PaddingControlsLight",
        range: {
          start: 21541,
          end: 25588
        }
      }, System, __varRecorder__$a, "PaddingControlsLight");
      var PaddingControlsLight = exports('X', __varRecorder__$a.PaddingControlsLight);
      __varRecorder__$a.PaddingControlsLight = PaddingControlsLight;
      __varRecorder__$a.PaddingControlsDark = component["for"](function () {
        return component(__varRecorder__$a.PaddingControlsLight, {
          submorphs: [{
            name: "padding all",
            layout: new TilingLayout({
              axisAlign: "center",
              justifySubmorphs: "spaced",
              resizePolicies: [["value", {
                height: "fixed",
                width: "fill"
              }]]
            }),
            borderWidth: 0,
            master: DarkNumberWidget,
            dropShadow: null,
            submorphs: [{
              name: "interactive label",
              lineHeight: 1,
              fontColor: Color.rgba(178, 235, 242, 0.4976)
            }, {
              name: "value",
              fixedWidth: true,
              fontSize: 14
            }]
          }, {
            name: "multi padding control",
            submorphs: [{
              name: "centering wrapper",
              submorphs: [{
                name: "padding indicator",
                fontColor: Color.rgb(178, 235, 242),
                borderWidth: 0
              }]
            }, {
              name: "padding left",
              master: DarkNumberWidget,
              dropShadow: null,
              borderWidth: 0,
              submorphs: [{
                name: "value",
                fontSize: 14
              }, without("button holder")]
            }, {
              name: "padding top",
              master: DarkNumberWidget,
              borderRadius: 0,
              dropShadow: null,
              borderWidth: 0,
              submorphs: [{
                name: "value",
                fontSize: 14
              }, without("button holder")]
            }, {
              name: "padding right",
              master: DarkNumberWidget,
              borderRadius: 0,
              dropShadow: null,
              borderWidth: 0,
              submorphs: [{
                name: "value",
                fontSize: 14
              }, without("button holder")]
            }, {
              name: "padding bottom",
              master: DarkNumberWidget,
              dropShadow: null,
              borderWidth: 0,
              submorphs: [{
                name: "value",
                fontSize: 14
              }, without("button holder")]
            }]
          }, {
            name: "independent padding toggle",
            padding: rect(2, 2),
            fontSize: 18,
            master: {
              auto: PropertyLabel,
              hover: PropertyLabelHovered,
              states: {
                active: PropertyLabelActive
              }
            }
          }]
        });
      }, {
        module: "lively.ide/studio/controls/popups.cp.js",
        "export": "PaddingControlsDark",
        range: {
          start: 25604,
          end: 27945
        }
      }, System, __varRecorder__$a, "PaddingControlsDark");
      var PaddingControlsDark = __varRecorder__$a.PaddingControlsDark;
      __varRecorder__$a.PaddingControlsDark = PaddingControlsDark;
      __varRecorder__$a.PaddingPopup = component["for"](function () {
        return component(PopupWindow, {
          name: "padding popup",
          defaultViewModel: __varRecorder__$a.PaddingPopupModel,
          submorphs: [{
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: ["Padding", null]
            }]
          }, add(part(__varRecorder__$a.PaddingControlsLight))]
        });
      }, {
        module: "lively.ide/studio/controls/popups.cp.js",
        "export": "PaddingPopup",
        range: {
          start: 28046,
          end: 28320
        }
      }, System, __varRecorder__$a, "PaddingPopup");
      __varRecorder__$a.BlurPopup = component["for"](function () {
        return component(DarkPopupWindow, {
          defaultViewModel: __varRecorder__$a.SingleNumberModel,
          name: "blur popup",
          submorphs: [{
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: ["Blur", null]
            }]
          }, add({
            name: "footer",
            borderColor: Color.rgb(97, 106, 107),
            borderWidth: 0,
            extent: pt(241, 50.3),
            fill: Color.rgba(0, 0, 0, 0),
            submorphs: [part(DarkNumberIconWidget, {
              name: "value input",
              extent: pt(75.5, 22),
              viewModel: {
                min: 0,
                scaleFactor: 100,
                unit: "%"
              },
              position: pt(11.3, 14),
              submorphs: [{
                name: "interactive label",
                fontSize: 14,
                fontFamily: "Material Icons",
                textAndAttributes: ["\uE3A5", null]
              }],
              tooltip: "Object Blur"
            })]
          })]
        });
      }, {
        module: "lively.ide/studio/controls/popups.cp.js",
        "export": "BlurPopup",
        range: {
          start: 28329,
          end: 29138
        }
      }, System, __varRecorder__$a, "BlurPopup");
      __varRecorder__$a.OpacityPopup = component["for"](function () {
        return component(DarkPopupWindow, {
          defaultViewModel: __varRecorder__$a.SingleNumberModel,
          name: "opacity popup",
          submorphs: [{
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: ["Opacity", null]
            }]
          }, add({
            name: "footer",
            borderColor: Color.rgb(97, 106, 107),
            borderWidth: 0,
            extent: pt(241, 50.3),
            fill: Color.rgba(0, 0, 0, 0),
            submorphs: [part(DarkNumberIconWidget, {
              name: "value input",
              position: pt(11.3, 14),
              viewModel: {
                min: 0,
                max: 1,
                scaleFactor: 100,
                unit: "%"
              },
              tooltip: "Object opacity",
              submorphs: [{
                name: "interactive label",
                fontSize: 14,
                fontFamily: "Material Icons",
                textAndAttributes: ["\uE91C", null]
              }]
            })]
          })]
        });
      }, {
        module: "lively.ide/studio/controls/popups.cp.js",
        "export": "OpacityPopup",
        range: {
          start: 29147,
          end: 29962
        }
      }, System, __varRecorder__$a, "OpacityPopup");
      __varRecorder__$a.CursorPopup = component["for"](function () {
        return component(DarkPopupWindow, {
          defaultViewModel: __varRecorder__$a.SingleSelectionModel,
          name: "cursor popup",
          submorphs: [{
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: ["Cursor", null]
            }]
          }, add({
            name: "footer",
            borderColor: Color.rgb(97, 106, 107),
            borderWidth: 0,
            extent: pt(241, 50.3),
            fill: Color.rgba(0, 0, 0, 0),
            submorphs: [part(EnumSelector, {
              name: "selection input",
              tooltip: "Selector Cursor",
              viewModel: {
                openListInWorld: true,
                listAlign: "selection",
                items: Morph.properties.nativeCursor.values,
                listMaster: DarkThemeList,
                listHeight: 1000
              },
              extent: pt(210.4, 23.3),
              master: EnumSelector,
              position: pt(15.4, 13.5),
              submorphs: [add({
                type: Label,
                name: "interactive label",
                fill: Color.rgba(229, 231, 233, 0),
                fontColor: Color.rgb(255, 255, 255),
                fontFamily: "Material Icons",
                nativeCursor: "pointer",
                padding: rect(6, 0, -6, 0),
                reactsToPointer: false,
                textAndAttributes: Icon.textAttribute("mouse-pointer", {
                  fontSize: 16
                })
              }, "label")]
            })]
          })]
        });
      }, {
        module: "lively.ide/studio/controls/popups.cp.js",
        "export": "CursorPopup",
        range: {
          start: 29971,
          end: 31184
        }
      }, System, __varRecorder__$a, "CursorPopup");
      __varRecorder__$a.TiltPopup = component["for"](function () {
        return component(DarkPopupWindow, {
          defaultViewModel: __varRecorder__$a.SingleNumberModel,
          name: "tilt popup",
          submorphs: [{
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: ["Tilt ", null, "(Rotate along X-Axis)", {
                fontWeight: "400"
              }]
            }]
          }, add({
            name: "footer",
            borderColor: Color.rgb(97, 106, 107),
            borderWidth: 0,
            extent: pt(241, 50.3),
            fill: Color.rgba(0, 0, 0, 0),
            submorphs: [part(DarkNumberIconWidget, {
              name: "value input",
              extent: pt(90, 22),
              viewModel: {
                unit: "\xB0",
                min: 0,
                scaleFactor: 180,
                max: 1
              },
              position: pt(11.3, 14),
              tooltip: "Object Tilt",
              submorphs: [{
                name: "interactive label",
                textAndAttributes: ["X ", {
                  fontSize: 16,
                  fontFamily: "IBM Plex Mono"
                }].concat(_toConsumableArray$1(Icon.textAttribute("undo", {
                  fontSize: 14,
                  paddingTop: "3px"
                })))
              }]
            })]
          })]
        });
      }, {
        module: "lively.ide/studio/controls/popups.cp.js",
        "export": "TiltPopup",
        range: {
          start: 31193,
          end: 32116
        }
      }, System, __varRecorder__$a, "TiltPopup");
      __varRecorder__$a.FlipPopup = component["for"](function () {
        return component(DarkPopupWindow, {
          defaultViewModel: __varRecorder__$a.SingleNumberModel,
          name: "flip popup",
          submorphs: [{
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: ["Flip ", null, "(Rotate along Y-Axis)", {
                fontWeight: "400"
              }]
            }]
          }, add({
            name: "footer",
            borderColor: Color.rgb(97, 106, 107),
            borderWidth: 0,
            extent: pt(241, 50.3),
            fill: Color.rgba(0, 0, 0, 0),
            submorphs: [part(DarkNumberIconWidget, {
              name: "value input",
              extent: pt(90, 22),
              viewModel: {
                unit: "\xB0",
                min: 0,
                scaleFactor: 180,
                max: 1
              },
              position: pt(11.3, 14),
              tooltip: "Object Flip",
              submorphs: [{
                name: "interactive label",
                textAndAttributes: ["Y ", {
                  fontSize: 16,
                  fontFamily: "IBM Plex Mono"
                }].concat(_toConsumableArray$1(Icon.textAttribute("undo", {
                  fontSize: 14,
                  paddingTop: "3px"
                })))
              }]
            })]
          })]
        });
      }, {
        module: "lively.ide/studio/controls/popups.cp.js",
        "export": "FlipPopup",
        range: {
          start: 32125,
          end: 33069
        }
      }, System, __varRecorder__$a, "FlipPopup");
      var BlurPopup = exports('B', __varRecorder__$a.BlurPopup);
      var ShadowPopup = exports('y', __varRecorder__$a.ShadowPopup);
      var ShadowPopupLight = __varRecorder__$a.ShadowPopupLight;
      var InsetShadowPopup = exports('z', __varRecorder__$a.InsetShadowPopup);
      var OpacityPopup = exports('O', __varRecorder__$a.OpacityPopup);
      var CursorPopup = exports('G', __varRecorder__$a.CursorPopup);
      var TiltPopup = exports('H', __varRecorder__$a.TiltPopup);
      var NumberWidgetLight = __varRecorder__$a.NumberWidgetLight;
      var NumberPopupLight = __varRecorder__$a.NumberPopupLight;
      var PaddingPopup = __varRecorder__$a.PaddingPopup;
      var PositionPopupLight = __varRecorder__$a.PositionPopupLight;
      var FlipPopup = exports('J', __varRecorder__$a.FlipPopup);
      __varRecorder__$a.BlurPopup = BlurPopup;
      __varRecorder__$a.ShadowPopup = ShadowPopup;
      __varRecorder__$a.ShadowPopupLight = ShadowPopupLight;
      __varRecorder__$a.InsetShadowPopup = InsetShadowPopup;
      __varRecorder__$a.OpacityPopup = OpacityPopup;
      __varRecorder__$a.CursorPopup = CursorPopup;
      __varRecorder__$a.TiltPopup = TiltPopup;
      __varRecorder__$a.NumberWidgetLight = NumberWidgetLight;
      __varRecorder__$a.NumberPopupLight = NumberPopupLight;
      __varRecorder__$a.PaddingPopup = PaddingPopup;
      __varRecorder__$a.PositionPopupLight = PositionPopupLight;
      __varRecorder__$a.FlipPopup = FlipPopup;

      var __varRecorder__$9 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/font-manager.cp.js", __contextModule__);
      var __moduleMeta__$3 = {
        pathInPackage: function pathInPackage() {
          return "./studio/font-manager.cp.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var openFontManager = __varRecorder__$9["lively.ide/studio/font-manager.cp.js__define__"]("openFontManager", "function", function () {
        return part(__varRecorder__$9.FontManagerPopup).openInWorld();
      }, __moduleMeta__$3);

      __varRecorder__$9.openFontManager = openFontManager;
      __varRecorder__$9.openFontManager = openFontManager;

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/font-manager.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("FontManagerModel") && typeof __lively_classholder__.FontManagerModel === "function" ? __lively_classholder__.FontManagerModel : __lively_classholder__.FontManagerModel = function FontManagerModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "bindings",
          get: function get() {
            return [].concat(_toConsumableArray$1(initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "bindings", this)), [{
              signal: "onNativeDrop",
              target: "drag and drop area",
              handler: "onNativeDrop"
            }, {
              signal: "onNativeDragenter",
              target: "drag and drop area",
              handler: "onNativeDragenter"
            }, {
              signal: "onNativeDragleave",
              target: "drag and drop area",
              handler: "onNativeDragleave"
            }, {
              signal: "onNativeDragend",
              target: "drag and drop area",
              handler: "onNativeDragend"
            }, {
              target: "upload font button",
              signal: "onMouseDown",
              handler: "openFilePicker"
            }]);
          }
        }, {
          key: "expose",
          get: function get() {
            return initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "expose", this).concat(["isHaloItem", "isPropertiesPanelPopup"]);
          }
        }, {
          key: "viewDidLoad",
          value: function () {
            var _FontManagerModel_viewDidLoad_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (!$world.openedProject) {
                        _context.next = 3;
                        break;
                      }

                      _context.next = 3;
                      return this.regenerateFontList(true);

                    case 3:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function FontManagerModel_viewDidLoad_() {
              return _FontManagerModel_viewDidLoad_.apply(this, arguments);
            }

            return FontManagerModel_viewDidLoad_;
          }()
        }, {
          key: "regenerateFontList",
          value: function () {
            var _FontManagerModel_regenerateFontList_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
              var _li;

              var withLoadingIndicator,
                  li,
                  projectFonts,
                  _iterator,
                  _step,
                  fontObj,
                  fontName,
                  fileName,
                  fontWeight,
                  fontStyle,
                  unicodeRange,
                  _args2 = arguments;

              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      withLoadingIndicator = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : false;
                      if (withLoadingIndicator) li = $world.showLoadingIndicatorFor($world, "Loading Project Fonts");
                      this.ui.fontListContainer.submorphs = [];
                      _context2.next = 5;
                      return $world.openedProject.retrieveProjectFontsFromCSS();

                    case 5:
                      projectFonts = _context2.sent;
                      _iterator = _createForOfIteratorHelper(projectFonts);

                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                          fontObj = _step.value;
                          fontName = fontObj.fontName, fileName = fontObj.fileName, fontWeight = fontObj.fontWeight, fontStyle = fontObj.fontStyle, unicodeRange = fontObj.unicodeRange;
                          this.ui.fontListContainer.addMorph(part(__varRecorder__$9.FontListEntry, {
                            viewModel: {
                              collapsed: true,
                              fontName: fontName,
                              fileName: fileName,
                              fontWeight: fontWeight,
                              fontStyle: fontStyle,
                              unicodeRange: unicodeRange
                            }
                          }));
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }

                      (_li = li) === null || _li === void 0 ? void 0 : _li.remove();

                    case 9:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function FontManagerModel_regenerateFontList_() {
              return _FontManagerModel_regenerateFontList_.apply(this, arguments);
            }

            return FontManagerModel_regenerateFontList_;
          }()
        }, {
          key: "openFilePicker",
          value: function () {
            var _FontManagerModel_openFilePicker_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
              var pickerOpts, files, _iterator2, _step2, fontFile, font;

              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      pickerOpts = {
                        multiple: true,
                        types: [{
                          description: "woff2 webfonts",
                          accept: {
                            "font/*": [".woff2"]
                          }
                        }],
                        excludeAcceptAllOption: true
                      };
                      this.allowUploads = false;
                      _context3.next = 4;
                      return window.showOpenFilePicker(pickerOpts);

                    case 4:
                      files = _context3.sent;
                      if (files.length === 0) this.allowUploads = true;
                      _iterator2 = _createForOfIteratorHelper(files);
                      _context3.prev = 7;

                      _iterator2.s();

                    case 9:
                      if ((_step2 = _iterator2.n()).done) {
                        _context3.next = 18;
                        break;
                      }

                      fontFile = _step2.value;
                      _context3.next = 13;
                      return fontFile.getFile();

                    case 13:
                      font = _context3.sent;
                      _context3.next = 16;
                      return this.uploadFont(font);

                    case 16:
                      _context3.next = 9;
                      break;

                    case 18:
                      _context3.next = 23;
                      break;

                    case 20:
                      _context3.prev = 20;
                      _context3.t0 = _context3["catch"](7);

                      _iterator2.e(_context3.t0);

                    case 23:
                      _context3.prev = 23;

                      _iterator2.f();

                      return _context3.finish(23);

                    case 26:
                      _context3.next = 28;
                      return this.regenerateFontList();

                    case 28:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this, [[7, 20, 23, 26]]);
            }));

            function FontManagerModel_openFilePicker_() {
              return _FontManagerModel_openFilePicker_.apply(this, arguments);
            }

            return FontManagerModel_openFilePicker_;
          }()
        }, {
          key: "uploadFont",
          value: function () {
            var _FontManagerModel_uploadFont_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(file) {
              var _$world$get;

              var fd, res, uploadPath, fontFile, _this$ui, statusText, statusPrompt, cancelButton, proceedButton, p, name, fontFace;

              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      fd = new FormData();
                      fd.append("file", file, file.name);
                      res = resource(System.baseURL);

                      if (!isUserLoggedIn()) {
                        uploadPath = "uploads/";
                      } else uploadPath = $world.openedProject ? $world.openedProject.url.replace(System.baseURL, "") + "/assets/" : "users/" + currentUsername() + "/uploads";

                      fontFile = resource(System.baseURL).join(uploadPath).join(file.name);
                      _context4.next = 7;
                      return fontFile.exists();

                    case 7:
                      if (!_context4.sent) {
                        _context4.next = 22;
                        break;
                      }

                      _this$ui = this.ui, statusText = _this$ui.statusText, statusPrompt = _this$ui.statusPrompt, cancelButton = _this$ui.cancelButton, proceedButton = _this$ui.proceedButton;
                      statusPrompt.visible = true;
                      statusText.textString = "This font file already exists, do you want to proceed and override?";
                      p = deferred();
                      once$1(cancelButton, "onMouseDown", function () {
                        return p.resolve(false);
                      });
                      once$1(proceedButton, "onMouseDown", function () {
                        return p.resolve(true);
                      });
                      _context4.next = 16;
                      return p.promise;

                    case 16:
                      if (_context4.sent) {
                        _context4.next = 19;
                        break;
                      }

                      this.resetStatusText();
                      return _context4.abrupt("return");

                    case 19:
                      _context4.next = 21;
                      return fontFile.remove();

                    case 21:
                      this.resetStatusText();

                    case 22:
                      res = res.join("/upload?uploadPath=".concat(encodeURIComponent(uploadPath)));
                      _context4.next = 25;
                      return res.write(fd);

                    case 25:
                      if ($world.openedProject) {
                        _context4.next = 27;
                        break;
                      }

                      return _context4.abrupt("return");

                    case 27:
                      name = file.name.replace(".woff2", "");
                      fontFace = {
                        fontWeight: [],
                        fontName: name,
                        fileName: name,
                        fontStyle: "normal",
                        unicodeRange: "''"
                      };
                      _context4.next = 31;
                      return $world.openedProject.deleteCustomFont(fontFace, false);

                    case 31:
                      _context4.next = 33;
                      return $world.openedProject.addCustomFontFace(fontFace);

                    case 33:
                      (_$world$get = $world.get("text control")) === null || _$world$get === void 0 ? void 0 : _$world$get.update();

                    case 34:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function FontManagerModel_uploadFont_(_x) {
              return _FontManagerModel_uploadFont_.apply(this, arguments);
            }

            return FontManagerModel_uploadFont_;
          }()
        }, {
          key: "onNativeDrop",
          value: function () {
            var _FontManagerModel_onNativeDrop_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(evt) {
              var dragAndDropArea, domEvt, legalFiles, legalFilesCount, _iterator3, _step3, legalFile;

              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      dragAndDropArea = this.ui.dragAndDropArea;
                      dragAndDropArea.master = {
                        auto: __varRecorder__$9.DragArea
                      };
                      domEvt = evt.domEvt;

                      if (domEvt.dataTransfer.items.length) {
                        _context5.next = 5;
                        break;
                      }

                      return _context5.abrupt("return");

                    case 5:
                      legalFiles = Array.from(domEvt.dataTransfer.items).filter(function (item) {
                        return item.type === "font/woff2";
                      }).map(function (i) {
                        return i.getAsFile();
                      });
                      legalFilesCount = legalFiles.length;

                      if (!legalFilesCount) {
                        _context5.next = 25;
                        break;
                      }

                      _iterator3 = _createForOfIteratorHelper(legalFiles);
                      _context5.prev = 9;

                      _iterator3.s();

                    case 11:
                      if ((_step3 = _iterator3.n()).done) {
                        _context5.next = 17;
                        break;
                      }

                      legalFile = _step3.value;
                      _context5.next = 15;
                      return this.uploadFont(legalFile);

                    case 15:
                      _context5.next = 11;
                      break;

                    case 17:
                      _context5.next = 22;
                      break;

                    case 19:
                      _context5.prev = 19;
                      _context5.t0 = _context5["catch"](9);

                      _iterator3.e(_context5.t0);

                    case 22:
                      _context5.prev = 22;

                      _iterator3.f();

                      return _context5.finish(22);

                    case 25:
                      _context5.next = 27;
                      return this.regenerateFontList();

                    case 27:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this, [[9, 19, 22, 25]]);
            }));

            function FontManagerModel_onNativeDrop_(_x2) {
              return _FontManagerModel_onNativeDrop_.apply(this, arguments);
            }

            return FontManagerModel_onNativeDrop_;
          }()
        }, {
          key: "resetStatusText",
          value: function FontManagerModel_resetStatusText_() {
            this.ui.statusPrompt.visible = false;
          }
        }, {
          key: "onNativeDragenter",
          value: function FontManagerModel_onNativeDragenter_() {
            this.ui.dragAndDropArea.master = {
              auto: __varRecorder__$9.DragAreaActive
            };
          }
        }, {
          key: "onNativeDragleave",
          value: function FontManagerModel_onNativeDragleave_() {
            this.ui.dragAndDropArea.master = {
              auto: __varRecorder__$9.DragArea
            };
          }
        }, {
          key: "onNativeDragend",
          value: function FontManagerModel_onNativeDragend_() {
            this.ui.dragAndDropArea.master = {
              auto: __varRecorder__$9.DragArea
            };
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "FontManagerModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              isHaloItem: {
                get: function get() {
                  return true;
                }
              },
              isPropertiesPanelPopup: {
                get: function get() {
                  return true;
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/font-manager.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 1005,
          end: 5904
        });
      })({
        referencedAs: "PopupModel",
        value: PopupModel
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/font-manager.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("FontListEntryModel") && typeof __lively_classholder__.FontListEntryModel === "function" ? __lively_classholder__.FontListEntryModel : __lively_classholder__.FontListEntryModel = function FontListEntryModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "editFont",
          value: function FontListEntryModel_editFont_() {
            var _this = this;

            var p = part(__varRecorder__$9.FontConfigurationPopup, {
              viewModel: {
                fontName: this.fontName,
                fontWeight: this.fontWeight,
                fontStyle: this.fontStyle,
                unicodeRange: this.unicodeRange
              }
            }).openInWorld();
            connect(p, "fontFaceChanged", function (fontFace) {
              _this.updateFontFace(function () {
                Object.assign(_this, fontFace);
              });
            });
            p.env.forceUpdate(p);
            p.topRight = this.view.globalBounds().topLeft();
            p.topLeft = this.world().visibleBounds().translateForInclusion(p.globalBounds()).topLeft();
          }
        }, {
          key: "updateFontFace",
          value: function () {
            var _FontListEntryModel_updateFontFace_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(cb) {
              var _$world$get2;

              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      _context6.next = 2;
                      return this.deleteFont(true);

                    case 2:
                      _context6.next = 4;
                      return cb();

                    case 4:
                      _context6.next = 6;
                      return this.addFont();

                    case 6:
                      (_$world$get2 = $world.get("text control")) === null || _$world$get2 === void 0 ? void 0 : _$world$get2.update();

                    case 7:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function FontListEntryModel_updateFontFace_(_x3) {
              return _FontListEntryModel_updateFontFace_.apply(this, arguments);
            }

            return FontListEntryModel_updateFontFace_;
          }()
        }, {
          key: "addFont",
          value: function () {
            var _FontListEntryModel_addFont_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      _context7.next = 2;
                      return $world.openedProject.addCustomFontFace({
                        fontWeight: this.fontWeight,
                        fontName: this.fontName,
                        fileName: this.fileName,
                        fontStyle: this.fontStyle,
                        unicodeRange: this.uniCodeRange
                      });

                    case 2:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7, this);
            }));

            function FontListEntryModel_addFont_() {
              return _FontListEntryModel_addFont_.apply(this, arguments);
            }

            return FontListEntryModel_addFont_;
          }()
        }, {
          key: "deleteFont",
          value: function () {
            var _FontListEntryModel_deleteFont_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
              var keepView,
                  fontObj,
                  _args8 = arguments;
              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      keepView = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : false;
                      fontObj = {
                        fileName: this.fileName,
                        fontName: this.fontName,
                        fontWeight: this.fontWeight,
                        fontStyle: this.fontStyle,
                        unicodeRange: this.unicodeRange
                      };
                      _context8.next = 4;
                      return $world.openedProject.deleteCustomFont(fontObj, !keepView);

                    case 4:
                      if (!keepView) this.view.remove();

                    case 5:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, this);
            }));

            function FontListEntryModel_deleteFont_() {
              return _FontListEntryModel_deleteFont_.apply(this, arguments);
            }

            return FontListEntryModel_deleteFont_;
          }()
        }, {
          key: "viewDidLoad",
          value: function FontListEntryModel_viewDidLoad_() {
            this.onRefresh();
          }
        }, {
          key: "onRefresh",
          value: function FontListEntryModel_onRefresh_() {
            var fontName = this.ui.fontName;
            fontName.textString = this.fileName;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "FontListEntryModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              bindings: {
                get: function get() {
                  return [{
                    target: "font delete",
                    signal: "onMouseDown",
                    handler: "deleteFont",
                    converter: function converter() {
                      return false;
                    }
                  }, {
                    target: "font edit",
                    signal: "onMouseDown",
                    handler: "editFont"
                  }];
                }
              },
              fontName: {},
              fileName: {},
              fontWeight: {
                defaultValue: []
              },
              fontStyle: {
                defaultValue: "normal"
              },
              unicodeRange: {
                defaultValue: "U+0-10FFFF"
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/font-manager.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 5906,
          end: 8083
        });
      })({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/font-manager.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("FontConfigurationModel") && typeof __lively_classholder__.FontConfigurationModel === "function" ? __lively_classholder__.FontConfigurationModel : __lively_classholder__.FontConfigurationModel = function FontConfigurationModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "viewDidLoad",
          value: function FontConfigurationModel_viewDidLoad_() {
            this.ui.nameInput.input = this.fontName;
            this.ui.styleSelector.selection = this.fontStyle;

            var _this$fontWeight = _slicedToArray(this.fontWeight, 2),
                min = _this$fontWeight[0],
                max = _this$fontWeight[1];

            this.ui.weightSelectorMin.selection = min;
            this.ui.weightSelectorMax.selection = max;
            this.ui.unicodeRangeInput.input = this.unicodeRange;
          }
        }, {
          key: "bindings",
          get: function get() {
            return [].concat(_toConsumableArray$1(initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "bindings", this)), [{
              target: "name input",
              signal: "onInput",
              handler: "confirm"
            }, {
              target: "name input",
              signal: "onBlur",
              handler: "confirm"
            }, {
              target: "unicode range input",
              signal: "onInput",
              handler: "confirm"
            }, {
              target: "unicode range input",
              signal: "onBlur",
              handler: "confirm"
            }, {
              target: "weight selector min",
              signal: "toggleList",
              handler: "confirm"
            }, {
              target: "weight selector max",
              signal: "toggleList",
              handler: "confirm"
            }, {
              target: "style selector",
              signal: "toggleList",
              handler: "confirm"
            }]);
          }
        }, {
          key: "confirm",
          value: function FontConfigurationModel_confirm_() {
            this.fontName = this.ui.nameInput.textString;
            this.fontStyle = this.ui.styleSelector.selection;
            this.unicodeRange = this.ui.unicodeRangeInput.textString || "''";
            this.fontWeight = compact([this.ui.weightSelectorMin.selection, this.ui.weightSelectorMax.selection]);
            signal(this.view, "fontFaceChanged", select(this, ["fontName", "fontStyle", "unicodeRange", "fontWeight"]));
          }
        }, {
          key: "expose",
          get: function get() {
            return initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "expose", this).concat(["isHaloItem", "isPropertiesPanelPopup"]);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "FontConfigurationModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              isHaloItem: {
                get: function get() {
                  return true;
                }
              },
              isPropertiesPanelPopup: {
                get: function get() {
                  return true;
                }
              },
              fontName: {},
              fontStyle: {
                defaultValue: "normal"
              },
              fontWeight: {
                defaultValue: []
              },
              unicodeRange: {
                defaultValue: "U+0-10FFFF"
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/font-manager.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 8085,
          end: 9915
        });
      })({
        referencedAs: "PopupModel",
        value: PopupModel
      });

      __varRecorder__$9.FontListEntry = component["for"](function () {
        return component({
          name: "font list entry",
          defaultViewModel: __varRecorder__$9.FontListEntryModel,
          extent: pt(212.2, 36.7),
          layout: new TilingLayout({
            axisAlign: "center",
            hugContentsVertically: true,
            orderByIndex: true,
            resizePolicies: [["list header", {
              height: "fill",
              width: "fill"
            }]]
          }),
          fill: Color.transparent,
          submorphs: [{
            name: "list header",
            layout: new TilingLayout({
              axisAlign: "center",
              orderByIndex: true,
              resizePolicies: [["font name", {
                height: "fixed",
                width: "fill"
              }]],
              spacing: 10
            }),
            fill: Color.transparent,
            borderColor: Color.rgb(69, 69, 69),
            submorphs: [part(PropertyLabel, {
              name: "font edit",
              fontSize: 15,
              textAndAttributes: ["\uF3A2", {
                fontFamily: "Font Awesome Brands",
                fontWeight: "400"
              }, " ", {}],
              tooltip: "Configure font properties",
              padding: rect(6, 1, -2, 1),
              master: {
                auto: PropertyLabel,
                hover: PropertyLabelHovered,
                click: PropertyLabelActive
              }
            }), part(TextInput, {
              name: "font name",
              padding: rect(5, 2, -4, -1),
              height: 23.7265625,
              readOnly: true,
              tooltip: ".woff2 name of the font file",
              textAndAttributes: ["Example Font Name ", {}]
            }), part(RemoveButton, {
              master: {
                auto: RemoveButton,
                hover: PropertyLabelHovered
              },
              name: "font delete",
              tooltip: "Remove font from the project",
              padding: rect(4, 4, 0, 0)
            })]
          }]
        });
      }, {
        module: "lively.ide/studio/font-manager.cp.js",
        "export": "FontListEntry",
        range: {
          start: 9923,
          end: 11452
        }
      }, System, __varRecorder__$9, "FontListEntry");
      __varRecorder__$9.DragArea = component["for"](function () {
        return component({
          name: "drag and drop area",
          fill: Color.rgba(255, 255, 255, 0),
          layout: new TilingLayout({
            align: "center",
            axis: "column",
            axisAlign: "center",
            orderByIndex: true
          }),
          borderRadius: 10,
          borderWidth: 6,
          extent: pt(211.5, 111.2),
          borderStyle: "dashed",
          borderColor: Color.rgb(101, 101, 101),
          submorphs: [{
            type: Text,
            name: "drop label",
            extent: pt(176, 48.3),
            textAlign: "center",
            fontColor: Color.rgb(139, 141, 142),
            fontSize: 17,
            fixedWidth: true,
            dynamicCursorColoring: true,
            fill: Color.rgba(255, 255, 255, 0),
            position: pt(22.6, 39.9),
            textAndAttributes: ["Drop font file here", {
              fontWeight: "600",
              textAlign: "center"
            }, " ", {
              textAlign: "center"
            }, "\uEA96", {
              fontFamily: "Tabler Icons",
              fontWeight: "900",
              textAlign: "center"
            }, " \n", {
              textAlign: "center"
            }, "or", {
              fontWeight: "600",
              textAlign: "center"
            }]
          }, part(DarkButton, {
            name: "upload font button",
            extent: pt(88.8, 28.8),
            submorphs: [{
              name: "label",
              fontSize: 12,
              textAndAttributes: ["Browse files", null]
            }]
          })]
        });
      }, {
        module: "lively.ide/studio/font-manager.cp.js",
        "export": "DragArea",
        range: {
          start: 11461,
          end: 12664
        }
      }, System, __varRecorder__$9, "DragArea");
      __varRecorder__$9.DragAreaActive = component["for"](function () {
        return component(__varRecorder__$9.DragArea, {
          borderWidth: 8
        });
      }, {
        module: "lively.ide/studio/font-manager.cp.js",
        "export": "DragAreaActive",
        range: {
          start: 12673,
          end: 12731
        }
      }, System, __varRecorder__$9, "DragAreaActive");
      __varRecorder__$9.FontManager = component["for"](function () {
        return component({
          name: "font manager",
          fill: Color.rgba(255, 255, 255, 0),
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "center",
            hugContentsVertically: true,
            orderByIndex: true,
            padding: rect(10, 10, 0, 0),
            resizePolicies: [["font list container", {
              height: "fixed",
              width: "fill"
            }]],
            spacing: 10
          }),
          extent: pt(290.7, 176),
          submorphs: [part(__varRecorder__$9.DragArea, {
            name: "drag and drop area"
          }), {
            name: "status prompt",
            extent: pt(207, 58),
            layout: new TilingLayout({
              hugContentsVertically: true,
              orderByIndex: true,
              padding: rect(5, 5, 0, 0),
              spacing: 5,
              wrapSubmorphs: true
            }),
            master: FileStatusWarning,
            submorphs: [{
              type: Text,
              name: "status text",
              padding: rect(5, 3, 0, 0),
              fixedWidth: true,
              fixedHeight: false,
              textAndAttributes: ["I am a status text", null],
              cursorWidth: 1.5,
              dynamicCursorColoring: true,
              extent: pt(195.3, 23),
              lineWrapping: "by-words"
            }, part(DarkButton, {
              name: "proceed button ",
              extent: pt(80, 20),
              opacity: 0.8,
              submorphs: [{
                name: "label",
                textAndAttributes: ["Proceed", null]
              }]
            }), part(DarkButton, {
              name: "cancel button ",
              opacity: 0.8,
              extent: pt(79.9, 19.7),
              submorphs: [{
                name: "label",
                textAndAttributes: ["Cancel", null]
              }]
            })]
          }, {
            name: "font list container",
            fill: Color.transparent,
            layout: new TilingLayout({
              axis: "column",
              axisAlign: "center",
              hugContentsVertically: true,
              orderByIndex: true
            }),
            clipMode: "auto",
            extent: pt(372, 396.5),
            position: pt(-120, 18)
          }]
        });
      }, {
        module: "lively.ide/studio/font-manager.cp.js",
        "export": "FontManager",
        range: {
          start: 12740,
          end: 14699
        }
      }, System, __varRecorder__$9, "FontManager");
      __varRecorder__$9.FontConfigurationPopup = component["for"](function () {
        return component(DarkPopupWindow, {
          viewModelClass: __varRecorder__$9.FontConfigurationModel,
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "center",
            hugContentsHorizontally: true,
            hugContentsVertically: true,
            orderByIndex: true,
            resizePolicies: [["font controls", {
              height: "fixed",
              width: "fill"
            }]]
          }),
          submorphs: [add({
            name: "font controls",
            fill: Color.rgba(255, 255, 255, 0),
            layout: new TilingLayout({
              axis: "column",
              orderByIndex: true,
              resizePolicies: [["name control", {
                height: "fixed",
                width: "fill"
              }], ["style control", {
                height: "fixed",
                width: "fill"
              }], ["weight control", {
                height: "fixed",
                width: "fill"
              }], ["unicode range control", {
                height: "fixed",
                width: "fill"
              }]]
            }),
            submorphs: [{
              name: "name control",
              layout: new TilingLayout({
                align: "right",
                axis: "column",
                hugContentsVertically: true,
                orderByIndex: true,
                padding: rect(15, 10, 0, 0),
                resizePolicies: [["name input", {
                  height: "fixed",
                  width: "fill"
                }]],
                spacing: 5
              }),
              height: 35.6796875,
              fill: Color.rgba(255, 255, 255, 0),
              submorphs: [{
                type: Label,
                name: "name label",
                nativeCursor: "pointer",
                opacity: 0.7,
                fontColor: Color.rgb(255, 255, 255),
                fontWeight: "bold",
                position: pt(13.6, 8),
                tooltip: "Defines the name under which the font is going to be available throughout the project.",
                textAndAttributes: ["Font Name  ", null, "\uF05A", {
                  fontFamily: "Font Awesome",
                  fontWeight: "900"
                }, " ", {}]
              }, part(TextInput, {
                name: "name input",
                fixedWidth: true,
                height: 25
              })]
            }, {
              name: "style control",
              layout: new TilingLayout({
                align: "right",
                axis: "column",
                hugContentsVertically: true,
                orderByIndex: true,
                padding: rect(15, 10, 0, 0),
                resizePolicies: [["style selector", {
                  height: "fixed",
                  width: "fill"
                }]],
                spacing: 5
              }),
              fill: Color.rgba(255, 255, 255, 0),
              submorphs: [{
                type: Label,
                name: "style label",
                fontColor: Color.rgb(255, 255, 255),
                fontWeight: "bold",
                nativeCursor: "pointer",
                opacity: 0.7,
                position: pt(11.6, 1.9),
                tooltip: "Defines the style this font file covers. For instance different font styles may be partitioned in different font files.",
                textAndAttributes: ["Font Style  ", null, "\uF05A", {
                  fontFamily: "Font Awesome",
                  fontWeight: "900"
                }, " ", {}]
              }, part(EnumSelector, {
                name: "style selector",
                layout: new TilingLayout({
                  align: "right",
                  justifySubmorphs: "spaced",
                  orderByIndex: true,
                  padding: rect(5, 0, 10, 0)
                }),
                viewModel: {
                  openListInWorld: true,
                  listMaster: DarkThemeList,
                  items: ["normal", "italic", "underline"]
                }
              })]
            }, {
              name: "weight control",
              layout: new TilingLayout({
                align: "right",
                hugContentsVertically: true,
                justifySubmorphs: "spaced",
                orderByIndex: true,
                padding: rect(15, 10, 0, 0),
                spacing: 5,
                wrapSubmorphs: true
              }),
              fill: Color.rgba(255, 255, 255, 0),
              submorphs: [{
                type: Label,
                name: "weight label",
                extent: pt(210.5, 18),
                fontColor: Color.rgb(255, 255, 255),
                fontWeight: "bold",
                nativeCursor: "pointer",
                opacity: 0.7,
                position: pt(5.4, 28.4),
                fixedWidth: true,
                tooltip: "A single fontweight or a range of fontweights for which to use this font file. For most cases, the default value will suffice.",
                textAndAttributes: ["Font Weight  ", null, "\uF05A", {
                  fontFamily: "Font Awesome",
                  fontWeight: "900"
                }, " ", {}]
              }, {
                type: Label,
                name: "min label",
                extent: pt(99, 17),
                fixedWidth: true,
                fontColor: Color.rgb(255, 255, 255),
                fontWeight: "bold",
                nativeCursor: "pointer",
                opacity: 0.7,
                position: pt(-163, 27),
                textAndAttributes: ["Min", null]
              }, {
                type: Label,
                name: "max label",
                extent: pt(99.8, 16.1),
                fixedWidth: true,
                fontColor: Color.rgb(255, 255, 255),
                fontWeight: "bold",
                nativeCursor: "pointer",
                opacity: 0.7,
                position: pt(-113, 27),
                textAndAttributes: ["Max", null]
              }, part(EnumSelector, {
                name: "weight selector min",
                extent: pt(100, 23.3),
                viewModel: {
                  openListInWorld: true,
                  listMaster: DarkThemeList,
                  listHeight: 500,
                  items: range(1, 9).map(function (i) {
                    return i * 100;
                  }),
                  listAlign: "selection"
                }
              }), part(EnumSelector, {
                name: "weight selector max",
                extent: pt(100, 23.3),
                viewModel: {
                  openListInWorld: true,
                  listMaster: DarkThemeList,
                  listHeight: 500,
                  items: range(1, 9).map(function (i) {
                    return i * 100;
                  }),
                  listAlign: "selection"
                }
              })]
            }, {
              name: "unicode range control",
              layout: new TilingLayout({
                align: "right",
                axis: "column",
                hugContentsVertically: true,
                orderByIndex: true,
                padding: rect(15, 10, 0, 10),
                resizePolicies: [["unicode range input", {
                  height: "fixed",
                  width: "fill"
                }]],
                spacing: 5
              }),
              fill: Color.rgba(255, 255, 255, 0),
              submorphs: [{
                type: Label,
                name: "unicode range label",
                extent: pt(213.2, 18),
                fontColor: Color.rgb(255, 255, 255),
                fontWeight: "bold",
                nativeCursor: "pointer",
                opacity: 0.7,
                position: pt(44.6, 31.4),
                tooltip: "A list of unicode code-points for which to use this font. If empty, this font-file will be used for all code-points. Usually, this is the warranted behavior.",
                textAndAttributes: ["Unicode Range  ", null, "\uF05A", {
                  fontFamily: "Font Awesome",
                  fontWeight: "900"
                }, " ", {}]
              }, part(TextInput, {
                name: "unicode range input",
                extent: pt(100, 23)
              })]
            }]
          }), {
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: ["Font Configuration", null]
            }]
          }]
        });
      }, {
        module: "lively.ide/studio/font-manager.cp.js",
        "export": "FontConfigurationPopup",
        range: {
          start: 14708,
          end: 22185
        }
      }, System, __varRecorder__$9, "FontConfigurationPopup");
      __varRecorder__$9.FontManagerPopup = component["for"](function () {
        return component(DarkPopupWindow, {
          defaultViewModel: __varRecorder__$9.FontManagerModel,
          extent: pt(241, 568),
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "center",
            hugContentsHorizontally: true,
            hugContentsVertically: true,
            orderByIndex: true,
            resizePolicies: [["header menu", {
              height: "fixed",
              width: "fill"
            }], ["font manager", {
              height: "fixed",
              width: "fill"
            }]]
          }),
          submorphs: [{
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: ["Manage Fonts", null]
            }]
          }, add(part(__varRecorder__$9.FontManager, {
            name: "font manager",
            submorphs: [{
              name: "status prompt",
              visible: false
            }, {
              name: "font list container",
              height: 1
            }]
          }))]
        });
      }, {
        module: "lively.ide/studio/font-manager.cp.js",
        "export": "FontManagerPopup",
        range: {
          start: 22194,
          end: 23012
        }
      }, System, __varRecorder__$9, "FontManagerPopup");

      var __varRecorder__$8 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/controls/text.cp.js", __contextModule__);
      var RichTextControlModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/studio/controls/text.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("RichTextControlModel") && typeof __lively_classholder__.RichTextControlModel === "function" ? __lively_classholder__.RichTextControlModel : __lively_classholder__.RichTextControlModel = function RichTextControlModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "installCustomFont",
          value: function RichTextControlModel_installCustomFont_() {
            var p = openFontManager();
            p.env.forceUpdate(p);
            p.topRight = this.view.globalBounds().topLeft();
            p.topLeft = this.world().visibleBounds().translateForInclusion(p.globalBounds()).topLeft();
            this.update();
          }
        }, {
          key: "focusOn",
          value: function RichTextControlModel_focusOn_(target) {
            if (this.targetMorph) {
              disconnect(this.targetMorph, "selectionChange", this, "update");
            }

            if (target.isText || target.isLabel) {
              this.targetMorph = target;
            }

            this.update();

            if (target.isText && !this.globalMode) {
              epiConnect(target, "selectionChange", this, "update");
            }
          }
        }, {
          key: "attach",
          value: function RichTextControlModel_attach_(view) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "attach", this).call(this, view);

            this.update();
          }
        }, {
          key: "update",
          value: function RichTextControlModel_update_() {
            var _this = this;

            this.withoutBindingsDo(function () {
              _this.withContextDo(function (text) {
                var _text$fontFamily;

                var _this$ui = _this.ui,
                    fontFamilySelector = _this$ui.fontFamilySelector,
                    fontWeightSelector = _this$ui.fontWeightSelector,
                    fontSizeInput = _this$ui.fontSizeInput,
                    lineHeightInput = _this$ui.lineHeightInput,
                    letterSpacingInput = _this$ui.letterSpacingInput,
                    fontColorInput = _this$ui.fontColorInput,
                    leftAlign = _this$ui.leftAlign,
                    centerAlign = _this$ui.centerAlign,
                    rightAlign = _this$ui.rightAlign,
                    blockAlign = _this$ui.blockAlign,
                    inlineLink = _this$ui.inlineLink,
                    italicStyle = _this$ui.italicStyle,
                    underlineStyle = _this$ui.underlineStyle,
                    quote = _this$ui.quote,
                    lineWrappingSelector = _this$ui.lineWrappingSelector,
                    paddingControls = _this$ui.paddingControls;

                var fontItemCreator = function fontItemCreator(font) {
                  return {
                    value: font,
                    string: font.name,
                    isListItem: true,
                    tooltip: font.name
                  };
                };

                var shortcutFonts = [{
                  name: "Monospace"
                }, {
                  name: "Sans-Serif"
                }, {
                  name: "Serif"
                }];
                var shortcutFontItems = shortcutFonts.map(fontItemCreator);
                shortcutFontItems[2].style = {
                  borderWidth: _defineProperty({
                    bottom: 5,
                    top: 0,
                    left: 0,
                    right: 0
                  }, "top", 0),
                  borderStyle: _defineProperty({
                    bottom: "double",
                    top: "none",
                    left: "none",
                    right: "none"
                  }, "top", "none")
                };

                if ($world.openedProject) {
                  var projectFontItems = $world.openedProject.projectFonts.map(fontItemCreator);

                  if (projectFontItems.length > 0) {
                    projectFontItems[projectFontItems.length - 1].style = {
                      borderWidth: _defineProperty({
                        bottom: 5,
                        top: 0,
                        left: 0,
                        right: 0
                      }, "top", 0),
                      borderStyle: _defineProperty({
                        bottom: "double",
                        top: "none",
                        left: "none",
                        right: "none"
                      }, "top", "none")
                    };
                  }

                  _this.models.fontFamilySelector.items = projectFontItems.concat(shortcutFontItems).concat(DEFAULT_FONTS.map(fontItemCreator));
                } else _this.models.fontFamilySelector.items = shortcutFontItems.concat(DEFAULT_FONTS.map(fontItemCreator));

                fontFamilySelector.selection = (_text$fontFamily = text.fontFamily) === null || _text$fontFamily === void 0 ? void 0 : _text$fontFamily.replace(/^"(.*)"$/, "$1");
                if (text.fontFamilyMixed || _this.globalMode && text.hasMixedTextAttributes("fontFamily")) fontFamilySelector.setMixed();
                fontWeightSelector.selection = /\d/.test(text.fontWeight) ? fontWeightToString(text.fontWeight) : capitalize(text.fontWeight);
                if (text.fontWeightMixed || _this.globalMode && text.hasMixedTextAttributes("fontWeight")) fontWeightSelector.setMixed();

                _this.updateFontWeightChoices(text.fontFamily);

                fontSizeInput.number = text.fontSize;
                if (text.fontSizeMixed || _this.globalMode && text.hasMixedTextAttributes("fontSize")) fontSizeInput.setMixed();
                lineHeightInput.number = text.lineHeight;
                if (text.lineHeightMixed || _this.globalMode && text.hasMixedTextAttributes("lineHeight")) lineHeightInput.setMixed();

                if (letterSpacingInput) {
                  letterSpacingInput.number = text.letterSpacing;
                  if (text.letterSpacingMixed || _this.globalMode && text.hasMixedTextAttributes("letterSpacing")) letterSpacingInput.setMixed();
                }

                if (lineWrappingSelector) {
                  lineWrappingSelector.selection = text.lineWrapping;
                  if (text.lineWrappingMixed || _this.globalMode && text.hasMixedTextAttributes("lineWrapping")) lineWrappingSelector.setMixed();
                }

                fontColorInput.setColor(text.fontColor);
                if (text.fontColorMixed || _this.globalMode && text.hasMixedTextAttributes("fontColor")) fontColorInput.setMixed(rainbow);
                leftAlign.master.setState(text.textAlign === "left" ? "active" : null);
                centerAlign.master.setState(text.textAlign === "center" ? "active" : null);
                rightAlign.master.setState(text.textAlign === "right" ? "active" : null);
                blockAlign.master.setState(text.textAlign === "justify" ? "active" : null);
                italicStyle.master.setState(text.fontStyle === "italic" ? "active" : null);
                underlineStyle.master.setState(text.textDecoration === "underline" ? "active" : null);
                if (quote) quote.master.setState(text.quote === 1 ? "active" : null);
                if (inlineLink) inlineLink.master.setState(text.link ? "active" : null);
                if (paddingControls) paddingControls.startPadding(text.padding);
              });
            });
          }
        }, {
          key: "withContextDo",
          value: function RichTextControlModel_withContextDo_(cb) {
            var targetMorph = this.targetMorph;
            if (!targetMorph) return;
            var sel = targetMorph.selection;
            if (sel && !sel.isEmpty() && !this.globalMode) cb(Object.assign({}, select(targetMorph, this.styledProps), {}, targetMorph.getStyleInRange(sel)));else cb(targetMorph);
          }
        }, {
          key: "confirm",
          value: function RichTextControlModel_confirm_(name, valueOrFn) {
            var _this2 = this;

            var targetMorph = this.targetMorph;
            if (!targetMorph) return;
            targetMorph.withMetaDo({
              reconcileChanges: true
            }, function () {
              var sel = targetMorph.selection;

              if (targetMorph.isLabel || sel && sel.isEmpty() || _this2.globalMode) {
                targetMorph[name] = typeof valueOrFn === "function" ? valueOrFn(targetMorph[name]) : valueOrFn;
              } else {
                targetMorph.undoManager.group();
                targetMorph.changeStyleProperty(name, function (oldVal) {
                  return typeof valueOrFn === "function" ? valueOrFn(oldVal) : valueOrFn;
                });
                targetMorph.undoManager.group();
              }
            });
          }
        }, {
          key: "changeLink",
          value: function () {
            var _RichTextControlModel_changeLink_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var targetMorph, sel, _targetMorph$getStyle, link, newLink;

              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      targetMorph = this.targetMorph;
                      sel = targetMorph.selection;
                      _targetMorph$getStyle = targetMorph.getStyleInRange(sel), link = _targetMorph$getStyle.link;
                      _context.next = 5;
                      return this.world().prompt("Set link", {
                        input: link || "https://"
                      });

                    case 5:
                      newLink = _context.sent;
                      targetMorph.undoManager.group();
                      targetMorph.setStyleInRange({
                        link: newLink || undefined
                      }, sel);
                      targetMorph.undoManager.group();

                    case 9:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function RichTextControlModel_changeLink_() {
              return _RichTextControlModel_changeLink_.apply(this, arguments);
            }

            return RichTextControlModel_changeLink_;
          }()
        }, {
          key: "selectTextAlignment",
          value: function RichTextControlModel_selectTextAlignment_(evt) {
            var align = {
              "left align": "left",
              "right align": "right",
              "center align": "center",
              "block align": "justify"
            }[evt.targetMorph.name];

            if (align) {
              if (this.globalMode) this.targetMorph.removePlainTextAttribute("textAlign");
              this.confirm("textAlign", align);
              this.update();
            }
          }
        }, {
          key: "selectBoundsResizing",
          value: function RichTextControlModel_selectBoundsResizing_(evt) {
            var text = this.targetMorph;

            switch (evt.targetMorph.name) {
              case "auto width":
                text.fixedWidth = false;
                text.fixedHeight = true;
                break;

              case "auto height":
                text.fixedWidth = true;
                text.fixedHeight = false;
                break;

              case "fixed extent":
                text.fixedWidth = true;
                text.fixedHeight = true;
                break;
            }

            this.update();
          }
        }, {
          key: "changeLineWrapping",
          value: function RichTextControlModel_changeLineWrapping_() {
            var _this3 = this;

            var text = this.targetMorph;

            if (text) {
              text.withMetaDo({
                reconcileChanges: true
              }, function () {
                text.lineWrapping = _this3.ui.lineWrappingSelector.selection;
              });
            }
          }
        }, {
          key: "toggleItalic",
          value: function RichTextControlModel_toggleItalic_() {
            if (this.globalMode) this.targetMorph.removePlainTextAttribute("fontStyle");
            this.confirm("fontStyle", function (style) {
              return style === "italic" ? "normal" : "italic";
            });
            this.update();
          }
        }, {
          key: "toggleUnderline",
          value: function RichTextControlModel_toggleUnderline_() {
            if (this.globalMode) this.targetMorph.removePlainTextAttribute("textDecoration", "underline");
            this.confirm("textDecoration", function (decoration) {
              return decoration === "underline" ? "none" : "underline";
            });
            this.update();
          }
        }, {
          key: "toggleQuote",
          value: function RichTextControlModel_toggleQuote_() {
            this.confirm("quote", function (quoteActive) {
              return quoteActive === 1 ? 0 : 1;
            });
            this.update();
          }
        }, {
          key: "changeFontWeight",
          value: function RichTextControlModel_changeFontWeight_(weight) {
            if (this.globalMode) this.targetMorph.removePlainTextAttribute("fontWeight");
            this.confirm("fontWeight", fontWeightNameToNumeric().get(weight));
          }
        }, {
          key: "changeFontColor",
          value: function RichTextControlModel_changeFontColor_(color) {
            if (this.globalMode) this.targetMorph.removePlainTextAttribute("fontColor");
            this.confirm("fontColor", color);
          }
        }, {
          key: "changeFontSize",
          value: function RichTextControlModel_changeFontSize_(size) {
            if (this.globalMode) this.targetMorph.removePlainTextAttribute("fontSize");
            this.confirm("fontSize", size);
          }
        }, {
          key: "changeFontFamily",
          value: function RichTextControlModel_changeFontFamily_(fontFamily) {
            if (this.globalMode) this.targetMorph.removePlainTextAttribute("fontFamily");
            if (fontFamily.name in config$2.fonts.genericFonts) fontFamily = sanitizeFont(config$2.fonts.genericFonts[fontFamily.name]);else fontFamily = sanitizeFont(fontFamily.name);
            this.confirm("fontFamily", fontFamily);
            this.updateFontWeightChoices(fontFamily);
          }
        }, {
          key: "updateFontWeightChoices",
          value: function RichTextControlModel_updateFontWeightChoices_(forFont) {
            var fontEntry = availableFonts().find(function (f) {
              return sanitizeFont(f.name) === sanitizeFont(forFont);
            });
            var supportedFontWeights = (fontEntry === null || fontEntry === void 0 ? void 0 : fontEntry.supportedWeights.map(function (fontWeight) {
              return fontWeightToString(fontWeight);
            })) || [];
            this.models.fontWeightSelector.items = supportedFontWeights.length > 0 ? supportedFontWeights : [400, 700].map(function (fontWeight) {
              return fontWeightToString(fontWeight);
            });
          }
        }, {
          key: "changeLineHeight",
          value: function RichTextControlModel_changeLineHeight_(height) {
            if (this.globalMode) this.targetMorph.removePlainTextAttribute("lineHeight");
            this.confirm("lineHeight", height);
          }
        }, {
          key: "changeLetterSpacing",
          value: function RichTextControlModel_changeLetterSpacing_(spacing) {
            if (this.globalMode) this.targetMorph.removePlainTextAttribute("letterSpacing");
            this.confirm("letterSpacing", spacing);
          }
        }, {
          key: "changePadding",
          value: function RichTextControlModel_changePadding_(padding) {
            var _this4 = this;

            this.targetMorph.withMetaDo({
              reconcileChanges: true
            }, function () {
              _this4.targetMorph.padding = padding;
            });
          }
        }, {
          key: "deactivate",
          value: function RichTextControlModel_deactivate_() {
            this.models.fontColorInput.closeColorPicker();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "RichTextControlModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              globalMode: {
                defaultValue: false
              },
              targetMorph: {},
              styledProps: {
                readOnly: true,
                get: function get() {
                  return ["fontSize", "lineHeight", "letterSpacing", "fontColor", "fontFamily", "fontWeight", "textAlign", "textDecoration", "fontStyle"];
                }
              },
              expose: {
                get: function get() {
                  return ["update", "targetMorph"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "font family selector",
                    signal: "selection",
                    handler: "changeFontFamily"
                  }, {
                    target: "font weight selector",
                    signal: "selection",
                    handler: "changeFontWeight"
                  }, {
                    target: "line wrapping selector",
                    signal: "selection",
                    handler: "changeLineWrapping"
                  }, {
                    target: "font size input",
                    signal: "number",
                    handler: "changeFontSize"
                  }, {
                    target: "line height input",
                    signal: "number",
                    handler: "changeLineHeight"
                  }, {
                    target: "letter spacing input",
                    signal: "number",
                    handler: "changeLetterSpacing"
                  }, {
                    target: "font color input",
                    signal: "color",
                    handler: "changeFontColor"
                  }, {
                    target: "alignment controls",
                    signal: "onMouseDown",
                    handler: "selectTextAlignment"
                  }, {
                    target: "resizing controls",
                    signal: "onMouseDown",
                    handler: "selectBoundsResizing"
                  }, {
                    target: "inline link",
                    signal: "onMouseDown",
                    handler: "changeLink"
                  }, {
                    target: "italic style",
                    signal: "onMouseDown",
                    handler: "toggleItalic"
                  }, {
                    target: "quote",
                    signal: "onMouseDown",
                    handler: "toggleQuote"
                  }, {
                    target: "underline style",
                    signal: "onMouseDown",
                    handler: "toggleUnderline"
                  }, {
                    target: "padding controls",
                    signal: "paddingChanged",
                    handler: "changePadding"
                  }, {
                    target: "add button",
                    signal: "onMouseDown",
                    handler: "installCustomFont"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/controls/text.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 1432,
          end: 14218
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$8.RichTextControlModel = RichTextControlModel;
      __varRecorder__$8.RichTextControlModel = RichTextControlModel;
      __varRecorder__$8.RichTextControl = component["for"](function () {
        return component(PropertySection, {
          defaultViewModel: __varRecorder__$8.RichTextControlModel,
          name: "rich text control",
          extent: pt(250, 313),
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "center",
            hugContentsVertically: true,
            orderByIndex: true,
            padding: rect(0, 10, 0, 0),
            resizePolicies: [["h floater", {
              height: "fixed",
              width: "fill"
            }]],
            spacing: 10
          }),
          submorphs: [{
            name: "h floater",
            submorphs: [{
              name: "section headline",
              textAndAttributes: ["Rich Text", null]
            }, {
              name: "add button",
              tooltip: "Install a custom font",
              textAndAttributes: ["\uEC91", {
                fontFamily: "Tabler Icons",
                fontSize: 18,
                fontWeight: "900"
              }]
            }]
          }, add({
            name: "text controls",
            layout: new TilingLayout({
              orderByIndex: true,
              padding: rect(20, 0, -20, 0),
              spacing: 10,
              wrapSubmorphs: true
            }),
            borderColor: Color.rgb(23, 160, 251),
            borderWidth: 0,
            extent: pt(250, 93.8),
            fill: Color.rgba(0, 0, 0, 0),
            submorphs: [part(EnumSelector, {
              name: "font family selector",
              tooltip: "Choose Font",
              layout: new TilingLayout({
                align: "center",
                axisAlign: "center",
                justifySubmorphs: "spaced",
                orderByIndex: true,
                padding: rect(10, 0, 5, 0),
                spacing: 0
              }),
              extent: pt(198.6, 23.3),
              viewModel: {
                items: ["IBM Plex Sans"],
                openListInWorld: true,
                listMaster: DarkThemeList,
                listHeight: 200,
                listAlign: "bottom"
              },
              submorphs: [{
                name: "label",
                fontSize: 12
              }]
            }), {
              name: "weight and styles",
              extent: pt(198, 8.9),
              layout: new TilingLayout({
                hugContentsVertically: true,
                orderByIndex: true,
                resizePolicies: [["font weight selector", {
                  height: "fixed",
                  width: "fill"
                }]],
                spacing: 10
              }),
              fill: Color.transparent,
              submorphs: [part(EnumSelector, {
                name: "font weight selector",
                tooltip: "Choose Font Weight",
                extent: pt(100, 23.3),
                viewModel: {
                  listMaster: DarkThemeList,
                  items: [{
                    isListItem: true,
                    string: "Thin",
                    value: 100
                  }, {
                    isListItem: true,
                    string: "Extra Light",
                    value: 200
                  }, {
                    isListItem: true,
                    string: "Light",
                    value: 300
                  }, {
                    isListItem: true,
                    string: "Normal",
                    value: 400
                  }, {
                    isListItem: true,
                    string: "Medium",
                    value: 500
                  }, {
                    isListItem: true,
                    string: "Semi Bold",
                    value: 600
                  }, {
                    isListItem: true,
                    string: "Bold",
                    value: 700
                  }, {
                    isListItem: true,
                    string: "Extra Bold",
                    value: 800
                  }, {
                    isListItem: true,
                    string: "Ultra Bold",
                    value: 900
                  }],
                  listAlign: "bottom",
                  openListInWorld: true,
                  listHeight: 1000
                },
                layout: new TilingLayout({
                  align: "center",
                  axisAlign: "center",
                  justifySubmorphs: "spaced",
                  orderByIndex: true,
                  padding: rect(10, 0, 5, 0)
                }),
                submorphs: [{
                  name: "label",
                  fontSize: 12
                }]
              }), part(BoundsContainerInactive, {
                name: "styling controls",
                extent: pt(87.4, 26.4),
                master: {
                  auto: BoundsContainerInactive,
                  hover: BoundsContainerHovered
                },
                layout: new TilingLayout({
                  orderByIndex: true,
                  hugContentsHorizontally: true
                }),
                submorphs: [add(part(PropertyLabel, {
                  name: "italic style",
                  master: {
                    states: {
                      active: PropertyLabelHovered
                    }
                  },
                  tooltip: "Italic",
                  fontSize: 14,
                  padding: rect(2, 0, 0, 0),
                  textAndAttributes: ["\uE23F", {
                    fontSize: 18,
                    fontFamily: "Material Icons"
                  }]
                })), add(part(PropertyLabel, {
                  name: "underline style",
                  master: {
                    states: {
                      active: PropertyLabelHovered
                    }
                  },
                  tooltip: "Underline",
                  fontSize: 14,
                  padding: rect(2, 0, 0, 0),
                  textAndAttributes: ["\uE249", {
                    fontSize: 18,
                    fontFamily: "Material Icons"
                  }]
                })), add(part(PropertyLabel, {
                  name: "inline link",
                  master: {
                    states: {
                      active: PropertyLabelHovered
                    }
                  },
                  tooltip: "Create Link",
                  fontSize: 14,
                  padding: rect(2, 0, 0, 0),
                  textAndAttributes: ["\uE157", {
                    fontSize: 18,
                    fontFamily: "Material Icons"
                  }]
                })), add(part(PropertyLabel, {
                  name: "quote",
                  master: {
                    states: {
                      active: PropertyLabelHovered
                    }
                  },
                  tooltip: "Quote",
                  fontSize: 14,
                  padding: rect(2, 0, 0, 0),
                  textAndAttributes: ["\uE244", {
                    fontSize: 18,
                    fontFamily: "Material Icons"
                  }]
                }))]
              })]
            }, part(DarkNumberIconWidget, {
              name: "font size input",
              width: 60,
              submorphs: [{
                name: "interactive label",
                textAndAttributes: ["\uE245", {
                  fontSize: 16,
                  fontFamily: "Material Icons"
                }]
              }],
              tooltip: "Font Size"
            }), part(DarkNumberIconWidget, {
              name: "line height input",
              width: 60,
              floatingPoint: true,
              submorphs: [{
                name: "interactive label",
                textAndAttributes: ["\uE240", {
                  fontSize: 16,
                  fontFamily: "Material Icons"
                }]
              }, {
                name: "value",
                floatingPoint: true,
                precision: 1
              }],
              tooltip: "Line Height"
            }), part(DarkNumberIconWidget, {
              name: "letter spacing input",
              width: 60,
              submorphs: [{
                name: "interactive label",
                textAndAttributes: ["\uE014", {
                  fontSize: 16,
                  fontFamily: "Material Icons"
                }]
              }],
              tooltip: "Letter Spacing"
            })]
          }), add(part(ColorInput, {
            name: "font color input",
            viewModel: {
              colorPickerComponent: DarkColorPicker
            },
            layout: new TilingLayout({
              axisAlign: "center",
              orderByIndex: true,
              padding: rect(20, 1, -10, 1),
              resizePolicies: [["hex input", {
                height: "fill",
                width: "fixed"
              }], ["opacity input", {
                height: "fill",
                width: "fixed"
              }]],
              spacing: 10
            }),
            extent: pt(250.3, 25),
            submorphs: [{
              name: "hex input",
              extent: pt(74.8, 22)
            }, {
              name: "opacity input",
              extent: pt(83.4, 22)
            }]
          })), add({
            name: "bottom wrapper",
            clipMode: "hidden",
            extent: pt(251.4, 65.6),
            fill: Color.transparent,
            layout: new TilingLayout({
              hugContentsVertically: true,
              orderByIndex: true,
              padding: rect(20, 0, -20, 0),
              spacing: 10,
              wrapSubmorphs: true
            }),
            submorphs: [{
              name: "alignment controls",
              master: {
                auto: BoundsContainerInactive,
                hover: BoundsContainerHovered
              },
              extent: pt(110.3, 22),
              layout: new TilingLayout({
                hugContentsVertically: true,
                justifySubmorphs: "spaced",
                spacing: 5
              }),
              submorphs: [part(PropertyLabel, {
                name: "left align",
                master: {
                  states: {
                    active: PropertyLabelHovered
                  }
                },
                tooltip: "Align Left",
                fontSize: 14,
                padding: rect(4, 4, 0, 0),
                textAndAttributes: Icon.textAttribute("align-left")
              }), part(PropertyLabel, {
                name: "center align",
                master: {
                  states: {
                    active: PropertyLabelHovered
                  }
                },
                tooltip: "Align Centered",
                fontSize: 14,
                padding: rect(4, 4, 0, 0),
                textAndAttributes: Icon.textAttribute("align-center")
              }), part(PropertyLabel, {
                name: "right align",
                master: {
                  states: {
                    active: PropertyLabelHovered
                  }
                },
                tooltip: "Align Right",
                fontSize: 14,
                padding: rect(4, 4, 0, 0),
                textAndAttributes: Icon.textAttribute("align-right")
              }), part(PropertyLabel, {
                name: "block align",
                master: {
                  states: {
                    active: PropertyLabelHovered
                  }
                },
                tooltip: "Justify Text",
                fontSize: 14,
                padding: rect(4, 4, 0, 0),
                textAndAttributes: Icon.textAttribute("align-justify")
              })]
            }, part(EnumSelector, {
              name: "line wrapping selector",
              extent: pt(202.2, 23.3),
              tooltip: "Choose Line Wrapping",
              viewModel: {
                listAlign: "bottom",
                openListInWorld: true,
                listMaster: DarkThemeList,
                items: [{
                  isListItem: true,
                  string: "No Wrapping",
                  value: "no-wrap"
                }, {
                  isListItem: true,
                  string: "Wrap by Words",
                  value: "by-words"
                }, {
                  isListItem: true,
                  string: "Wrap by Characters",
                  value: "by-chars"
                }, {
                  isListItem: true,
                  string: "Wrap only by Words",
                  value: "only-by-words"
                }]
              },
              submorphs: [{
                name: "label",
                fontSize: 12
              }]
            })]
          }), add(part(PaddingControlsDark, {
            name: "padding controls"
          }))]
        });
      }, {
        module: "lively.ide/studio/controls/text.cp.js",
        "export": "RichTextControl",
        range: {
          start: 14226,
          end: 23948
        }
      }, System, __varRecorder__$8, "RichTextControl");
      var RichTextControl = exports('Q', __varRecorder__$8.RichTextControl);
      __varRecorder__$8.RichTextControl = RichTextControl;

      var __varRecorder__$7 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/text-formatting-popup.cp.js", __contextModule__);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/text-formatting-popup.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("TextFormattingPopUpModel") && typeof __lively_classholder__.TextFormattingPopUpModel === "function" ? __lively_classholder__.TextFormattingPopUpModel : __lively_classholder__.TextFormattingPopUpModel = function TextFormattingPopUpModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "close",
          value: function TextFormattingPopUpModel_close_() {
            this.view.remove();
          }
        }, {
          key: "viewDidLoad",
          value: function TextFormattingPopUpModel_viewDidLoad_() {
            this.ui.richTextControl.targetMorph = this.targetMorph;
            this.ui.richTextControl.update();
            this.view.withAllSubmorphsDo(function (m) {
              return m.halosEnabled = false;
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "TextFormattingPopUpModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["close"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "onMouseDown",
                    handler: "close"
                  }];
                }
              },
              targetMorph: {}
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./text/text-formatting-popup.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 213,
          end: 781
        });
      })({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      __varRecorder__$7.SelectionBasedRichTextControl = component["for"](function () {
        return component(RichTextControl, {
          submorphs: [without("h floater"), {
            name: "bottom wrapper",
            height: 22,
            submorphs: [without("line wrapping selector"), without("resizing controls")]
          }, without("padding controls")]
        });
      }, {
        module: "lively.ide/text/text-formatting-popup.cp.js",
        "export": "SelectionBasedRichTextControl",
        range: {
          start: 789,
          end: 1098
        }
      }, System, __varRecorder__$7, "SelectionBasedRichTextControl");
      __varRecorder__$7.TextFormattingPopUp = component["for"](function () {
        return component(DarkPopupWindow, {
          name: "formatting pop up",
          defaultViewModel: __varRecorder__$7.TextFormattingPopUpModel,
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "center",
            hugContentsVertically: true,
            hugContentsHorizontally: true,
            resizePolicies: [["header menu", {
              width: "fill",
              height: "fixed"
            }]]
          }),
          submorphs: [{
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: ["Format Selection", null]
            }]
          }, add(part(__varRecorder__$7.SelectionBasedRichTextControl, {
            name: "rich text control"
          }))]
        });
      }, {
        module: "lively.ide/text/text-formatting-popup.cp.js",
        "export": "TextFormattingPopUp",
        range: {
          start: 1114,
          end: 1706
        }
      }, System, __varRecorder__$7, "TextFormattingPopUp");
      var TextFormattingPopUp = __varRecorder__$7.TextFormattingPopUp;
      __varRecorder__$7.TextFormattingPopUp = TextFormattingPopUp;

      var __varRecorder__$6 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/rich-text-editor-plugin.js", __contextModule__);
      var RichTextPlugin = exports('R', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/text/rich-text-editor-plugin.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("RichTextPlugin") && typeof __lively_classholder__.RichTextPlugin === "function" ? __lively_classholder__.RichTextPlugin : __lively_classholder__.RichTextPlugin = function RichTextPlugin(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "shortName",
          get: function get() {
            return "richText";
          }
        }, {
          key: "longName",
          get: function get() {
            return this.shortName;
          }
        }, {
          key: "attach",
          value: function RichTextPlugin_attach_(editor) {
            this.textMorph = editor;
            connect(this.textMorph, "onMouseMove", this, "onMouseMove");
            connect(this.textMorph, "onMouseUp", this, "onMouseUp");
          }
        }, {
          key: "detach",
          value: function RichTextPlugin_detach_(editor) {
            this.textMorph = null;
            disconnect(this.textMorph, "onMouseMove", this, "onMouseMove");
            disconnect(this.textMorph, "onMouseUp", this, "onMouseUp");
          }
        }, {
          key: "onMouseMove",
          value: function RichTextPlugin_onMouseMove_(evt) {
            if (!evt.leftMouseButtonPressed() || !this.textMorph.selectable || evt.state.clickedOnMorph !== this.textMorph) {
              return;
            }

            this.textMorph.selection.lead = this.textMorph.textPositionFromPoint(this.textMorph.localize(evt.position));
            this.textMorph.wantsFormattingPopUp = true;
          }
        }, {
          key: "onMouseUp",
          value: function RichTextPlugin_onMouseUp_() {
            if (this.textMorph.wantsFormattingPopUp) {
              this.showFormattingPopUp();
              this.textMorph.wantsFormattingPopUp = false;
            }
          }
        }, {
          key: "showIconButton",
          value: function RichTextPlugin_showIconButton_() {
            var iconButton = part(PropertyLabel, {
              reactsToPointer: false,
              name: "insert icon button",
              tooltip: "Insert Icon",
              fontSize: 14,
              textAndAttributes: Icon.textAttribute("ti-icons")
            });
            var iconButtonHolder = new Morph({
              epiMorph: true,
              fill: Color.rgb(30, 30, 30).withA(0.95),
              borderRadius: 3,
              nativeCursor: "pointer",
              layout: new TilingLayout({
                hugContentsVertically: true,
                hugContentsHorizontally: true
              }),
              submorphs: [iconButton]
            });
            iconButton.master = {
              auto: PropertyLabel,
              hover: PropertyLabelHovered
            };
            this.textMorph.iconButton = iconButtonHolder;
            connect(iconButtonHolder, "onMouseDown", this, "startIconInsertion");
            connect(this.textMorph, "extent", iconButtonHolder, "globalPosition", {
              converter: "(extent) => (pt(source.globalPosition.x + extent.x, source.globalPosition.y))",
              varMapping: {
                pt: pt
              }
            });
            iconButtonHolder.openInWorld(this.textMorph.globalBounds().topRight());
          }
        }, {
          key: "startIconInsertion",
          value: function RichTextPlugin_startIconInsertion_() {
            this.textMorph.execCommand("add icon at cursor position");
          }
        }, {
          key: "removeIconButton",
          value: function RichTextPlugin_removeIconButton_() {
            var _this$textMorph$iconB;

            (_this$textMorph$iconB = this.textMorph.iconButton) === null || _this$textMorph$iconB === void 0 ? void 0 : _this$textMorph$iconB.remove();
            delete this.textMorph.iconButton;
          }
        }, {
          key: "showFormattingPopUp",
          value: function RichTextPlugin_showFormattingPopUp_() {
            if (this.textMorph.readOnly) return;

            if (!this.textMorph.selection.isEmpty()) {
              var start = this.textMorph.selection.start;
              var startBounds = this.textMorph.charBoundsFromTextPosition(start);
              var startPoint = this.textMorph.worldPoint(startBounds.topLeft());
              var worldBounds = this.textMorph.world().bounds();
              if (this.formattingPopUp) this.formattingPopUp.openInWorld();else this.formattingPopUp = part(TextFormattingPopUp, {
                viewModel: {
                  targetMorph: this.textMorph
                }
              }).openInWorld();
              $world.env.forceUpdate();
              this.formattingPopUp.bottomRight = startPoint;
              this.formattingPopUp.position = worldBounds.translateForInclusion(this.formattingPopUp.bounds()).topLeft();
            }
          }
        }, {
          key: "removeFormattingPopUp",
          value: function () {
            var _RichTextPlugin_removeFormattingPopUp_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var imm,
                  popup,
                  _args = arguments;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      imm = _args.length > 0 && _args[0] !== undefined ? _args[0] : false;

                      if (this.formattingPopUp) {
                        _context.next = 3;
                        break;
                      }

                      return _context.abrupt("return");

                    case 3:
                      popup = this.formattingPopUp;
                      this.formattingPopUp = null;

                      if (imm) {
                        _context.next = 8;
                        break;
                      }

                      _context.next = 8;
                      return popup.animate({
                        duration: 200,
                        opacity: 0,
                        easing: easings.inOutQuad
                      });

                    case 8:
                      popup.remove();

                    case 9:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function RichTextPlugin_removeFormattingPopUp_() {
              return _RichTextPlugin_removeFormattingPopUp_.apply(this, arguments);
            }

            return RichTextPlugin_removeFormattingPopUp_;
          }()
        }, {
          key: "remove",
          value: function RichTextPlugin_remove_() {
            this.removeFormattingPopUp(true);

            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "remove", this).call(this);
          }
        }, {
          key: "getCommands",
          value: function RichTextPlugin_getCommands_(otherCommands) {
            return otherCommands.concat(interactiveCommands);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "RichTextPlugin";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./text/rich-text-editor-plugin.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 442,
          end: 4201
        });
      }({
        referencedAs: "EditorPlugin",
        value: EditorPlugin
      }));
      __varRecorder__$6.RichTextPlugin = RichTextPlugin;
      __varRecorder__$6.RichTextPlugin = RichTextPlugin;

      var __varRecorder__$5 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);
      var __moduleMeta__$2 = {
        pathInPackage: function pathInPackage() {
          return "./morph.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.halos",
            version: "0.1.0"
          };
        }
      };

      var getColorForTarget = __varRecorder__$5["lively.halos/morph.js__define__"]("getColorForTarget", "function", function (target) {
        var baseColor = !!target.master || target.ownerChain().find(function (m) {
          return m.master && m.master.managesMorph(target.name);
        }) ? __varRecorder__$5.derivedAccent : __varRecorder__$5.haloBlue;
        return target.isComponent ? __varRecorder__$5.componentAccent : baseColor;
      }, __moduleMeta__$2);

      __varRecorder__$5.getColorForTarget = getColorForTarget;
      __varRecorder__$5.haloBlue = Color.rgb(23, 160, 251);
      __varRecorder__$5.derivedAccent = Color.rgba(171, 71, 188, 1);
      __varRecorder__$5.componentAccent = Color.magenta;
      var MorphHighlighter = exports('W', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("MorphHighlighter") && typeof __lively_classholder__.MorphHighlighter === "function" ? __lively_classholder__.MorphHighlighter : __lively_classholder__.MorphHighlighter = function MorphHighlighter(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "alignWithHalo",
          value: function MorphHighlighter_alignWithHalo_() {
            if (this.target) {
              this.position = this.halo.localize(this.target.globalBounds().topLeft());
              if (this.halo.isWorld) this.position = this.position.subPt(this.halo.scroll);
              this.extent = this.target.globalBounds().extent();
              this.get("name tag").value = this.target.name;
              this.get("name tag").topCenter = this.innerBounds().insetBy(-10).bottomCenter();
            }
          }
        }, {
          key: "show",
          value: function MorphHighlighter_show_() {
            if (this.target && this.target.layout && this.showLayout) {
              this.layoutHalo = this.layoutHalo || this.world().showLayoutHaloFor(this.target, this.pointerId);

              if (this.layoutHalo && this.layoutHalo.previewDrop) {
                this.visible = false;
                this.alignWithHalo();

                if (this.halo.get("grab").hand.grabbedMorphs) {
                  this.layoutHalo.previewDrop(this.halo.get("grab").hand.grabbedMorphs);
                }

                return;
              }
            }

            this.visible = true;
            this.alignWithHalo();
          }
        }, {
          key: "handleDrop",
          value: function MorphHighlighter_handleDrop_(morph) {
            this.layoutHalo && this.layoutHalo.handleDrop(morph);
          }
        }, {
          key: "deactivate",
          value: function MorphHighlighter_deactivate_() {
            if (this.layoutHalo) {
              this.layoutHalo.remove();
              this.layoutHalo = null;
            }

            this.visible = false;
            this.alignWithHalo();
            this.remove();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "MorphHighlighter";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              draggable: {
                defaultValue: false
              },
              name: {
                defaultValue: "morphHighlighter"
              },
              styleClasses: {
                defaultValue: ["inactive"]
              },
              reactsToPointer: {
                defaultValue: false
              },
              hasFixedPosition: {
                defaultValue: true
              },
              fill: {
                defaultValue: Color.orange.withA(0.3)
              },
              borderWidth: {
                defaultValue: 2
              },
              borderColor: {
                defaultValue: Color.orange
              },
              halo: {},
              epiMorph: {
                defaultValue: true
              },
              isHighlighter: {
                readOnly: true,
                defaultValue: true
              },
              acceptsDrops: {
                get: function get() {
                  return !!this.layoutHalo;
                }
              },
              highlightedSides: {
                defaultValue: [],
                set: function set(sides) {
                  var _this2 = this;

                  this.setProperty("highlightedSides", sides);
                  this.submorphs = sides.map(function (side) {
                    return {
                      type: "ellipse",
                      isHaloItem: true,
                      fill: Color.orange,
                      center: _this2.innerBounds()[side]()
                    };
                  });
                  this.addMorph({
                    type: "label",
                    name: "name tag",
                    padding: Rectangle.inset(5, 5, 5, 5),
                    fontColor: Color.white,
                    fill: Color.orange,
                    borderRadius: 3
                  });
                  this.alignWithHalo();
                }
              },
              showLayout: {
                defaultValue: false
              },
              targetId: {},
              target: {
                readOnly: true,
                derived: true,
                get: function get() {
                  return (this.world() || this.env.world).getMorphWithId(this.targetId);
                }
              }
            };
          }
        }, {
          key: "removeHighlighters",
          value: function MorphHighlighter_removeHighlighters_() {
            var halo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $world;
            var store = halo._morphHighlighters;

            for (var id in store) {
              store[id].remove();
            }

            delete halo._morphHighlighters;
          }
        }, {
          key: "for",
          value: function MorphHighlighter_for_(haloOrWorld, morph) {
            var showLayout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var highlightedSides = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
            var store = haloOrWorld._morphHighlighters = haloOrWorld._morphHighlighters || {};
            forEachOwn(store, function (_, h) {
              return h.alignWithHalo();
            });
            if (!morph || morph.ownerChain().find(function (owner) {
              return owner.isHaloItem;
            })) return null;
            store[morph.id] = store[morph.id] || new this({
              targetId: morph.id,
              halo: haloOrWorld,
              showLayout: showLayout
            });
            haloOrWorld.addMorph(store[morph.id]);
            store[morph.id].highlightedSides = highlightedSides;
            return store[morph.id];
          }
        }, {
          key: "interceptDrop",
          value: function MorphHighlighter_interceptDrop_(halo, target, morph) {
            var store = halo._morphHighlighters = halo._morphHighlighters || {};
            store && store[target.id] && store[target.id].handleDrop(morph);
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 1532,
          end: 5327
        });
      }({
        referencedAs: "Morph",
        value: Morph
      }));
      __varRecorder__$5.MorphHighlighter = MorphHighlighter;
      __varRecorder__$5.MorphHighlighter = MorphHighlighter;

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("MultiSelectionTarget") && typeof __lively_classholder__.MultiSelectionTarget === "function" ? __lively_classholder__.MultiSelectionTarget : __lively_classholder__.MultiSelectionTarget = function MultiSelectionTarget(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "isHaloItem",
          get: function get() {
            return true;
          }
        }, {
          key: "isMorphSelection",
          get: function get() {
            return true;
          }
        }, {
          key: "selectsMorph",
          value: function MultiSelectionTarget_selectsMorph_(morph) {
            return this.selectedMorphs.includes(morph);
          }
        }, {
          key: "alignWithSelection",
          value: function MultiSelectionTarget_alignWithSelection_() {
            var bounds = this.selectedMorphs.map(function (m) {
              return m.globalBounds();
            }).reduce(function (a, b) {
              return a.union(b);
            });
            this.setBounds(bounds);
          }
        }, {
          key: "onGrab",
          value: function MultiSelectionTarget_onGrab_(evt) {
            this.grabbingHand = evt.hand;
            this.selectionGrabbed = true;
            evt.hand.grab(this.selectedMorphs);
            once$1(evt.hand, "dropMorphsOn", this, "onGrabEnd");
            connect(evt.hand, "position", this, "alignWithSelection");
          }
        }, {
          key: "onGrabEnd",
          value: function MultiSelectionTarget_onGrabEnd_() {
            this.selectionGrabbed = false;
            disconnectAll(this.grabbingHand);
          }
        }, {
          key: "updateExtent",
          value: function MultiSelectionTarget_updateExtent_(_ref) {
            var prevValue = _ref.prevValue,
                value = _ref.value;
            var delta = value.subPt(prevValue);
            this.selectedMorphs.forEach(function (m) {
              return m.resizeBy(delta);
            });
          }
        }, {
          key: "updatePosition",
          value: function MultiSelectionTarget_updatePosition_(_ref2) {
            var prevValue = _ref2.prevValue,
                value = _ref2.value;
            if (this.selectionGrabbed) return;
            var delta = value.subPt(prevValue);
            this.selectedMorphs.forEach(function (m) {
              return m.moveBy(delta);
            });
          }
        }, {
          key: "updateRotation",
          value: function MultiSelectionTarget_updateRotation_(_ref3) {
            var _this3 = this;

            var prevValue = _ref3.prevValue,
                value = _ref3.value;
            var delta = value - prevValue;
            this.selectedMorphs.forEach(function (m) {
              var oldOrigin = m.origin;
              m.adjustOrigin(m.localize(_this3.worldPoint(pt(0, 0))));
              m.rotation += delta;
              m.adjustOrigin(oldOrigin);
            });
          }
        }, {
          key: "updateScale",
          value: function MultiSelectionTarget_updateScale_(_ref4) {
            var _this4 = this;

            var prevValue = _ref4.prevValue,
                value = _ref4.value;
            var delta = value - prevValue;
            this.selectedMorphs.forEach(function (m) {
              var oldOrigin = m.origin;
              m.adjustOrigin(m.localize(_this4.worldPoint(pt(0, 0))));
              m.scale += delta;
              m.adjustOrigin(oldOrigin);
            });
          }
        }, {
          key: "onChange",
          value: function MultiSelectionTarget_onChange_(change) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onChange", this).call(this, change);

            if (!this.modifiesSelectedMorphs) return;

            switch (change.prop) {
              case "extent":
                this.updateExtent(change);
                break;

              case "scale":
                this.updateScale(change);
                break;

              case "position":
                this.updatePosition(change);
                break;

              case "rotation":
                this.updateRotation(change);
                break;
            }

            return change;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "MultiSelectionTarget";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              visible: {
                defaultValue: false
              },
              modifiesSelectedMorphs: {
                defaultValue: false
              },
              selectedMorphs: {
                defaultValue: []
              },
              halosEnabled: {
                defaultValue: false
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 5395,
          end: 7666
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("HaloPropertyDisplay") && typeof __lively_classholder__.HaloPropertyDisplay === "function" ? __lively_classholder__.HaloPropertyDisplay : __lively_classholder__.HaloPropertyDisplay = function HaloPropertyDisplay(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "isHaloItem",
          get: function get() {
            return false;
          }
        }, {
          key: "halo",
          get: function get() {
            return this.owner;
          }
        }, {
          key: "displayedValue",
          value: function HaloPropertyDisplay_displayedValue_() {
            return this.textString;
          }
        }, {
          key: "displayProperty",
          value: function HaloPropertyDisplay_displayProperty_(val) {
            var activeButton = this.halo.state.activeButton;
            val = String(val);
            this.visible = true;
            this.textString = val;
            this.position = this.constructor.defaultPosition;

            if (this.bounds().insetBy(10).intersects(activeButton.bounds())) {
              this.position = pt(activeButton.topRight.x + 10, this.position.y);
            }

            if (this.halo.target._responsiveHalo) {
              this.topRight = this.position;
            }
          }
        }, {
          key: "disable",
          value: function HaloPropertyDisplay_disable_() {
            this.position = this.constructor.defaultPosition;
            this.visible = false;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "HaloPropertyDisplay";
          }
        }, {
          key: "morphName",
          get: function get() {
            return "propertyDisplay";
          }
        }, {
          key: "defaultPosition",
          get: function get() {
            return pt(25, 0);
          }
        }, {
          key: "for",
          value: function HaloPropertyDisplay_for_(halo) {
            return halo.getSubmorphNamed(this.morphName) || halo.addMorph(new this({
              name: this.morphName
            }));
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              name: {
                defaultValue: this.morphName
              },
              fill: {
                defaultValue: Color.black.withA(0.7)
              },
              borderRadius: {
                defaultValue: 7
              },
              padding: {
                defaultValue: Rectangle.inset(5)
              },
              visible: {
                defaultValue: false
              },
              readOnly: {
                defaultValue: true
              },
              fontSize: {
                defaultValue: 12
              },
              fontColor: {
                defaultValue: Color.white
              },
              position: {
                defaultValue: this.defaultPosition
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 7856,
          end: 9285
        });
      })({
        referencedAs: "Text",
        value: Text
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("HaloItem") && typeof __lively_classholder__.HaloItem === "function" ? __lively_classholder__.HaloItem : __lively_classholder__.HaloItem = function HaloItem(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "isEpiMorph",
          get: function get() {
            return true;
          }
        }, {
          key: "isHaloItem",
          get: function get() {
            return true;
          }
        }, {
          key: "menuItems",
          value: function HaloItem_menuItems_() {
            return [];
          }
        }, {
          key: "init",
          value: function HaloItem_init_() {}
        }, {
          key: "update",
          value: function HaloItem_update_() {}
        }, {
          key: "stop",
          value: function HaloItem_stop_() {}
        }, {
          key: "valueForPropertyDisplay",
          value: function HaloItem_valueForPropertyDisplay_() {
            return undefined;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "HaloItem";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              borderRadius: {
                defaultValue: 15
              },
              nativeCursor: {
                defaultValue: "pointer"
              },
              fill: {
                defaultValue: Color.gray.withA(0.7)
              },
              grabbable: {
                defaultValue: false
              },
              extent: {
                defaultValue: pt(24, 24)
              },
              halo: {},
              acceptsDrops: {
                defaultValue: false
              }
            };
          }
        }, {
          key: "for",
          value: function HaloItem_for_(halo) {
            return halo.getSubmorphNamed(this.morphName) || halo.addMorph(new this({
              halo: halo,
              name: this.morphName
            }));
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 9449,
          end: 10167
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("RoundHaloItem") && typeof __lively_classholder__.RoundHaloItem === "function" ? __lively_classholder__.RoundHaloItem : __lively_classholder__.RoundHaloItem = function RoundHaloItem(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, undefined, [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "RoundHaloItem";
          }
        }, {
          key: "makeLabel",
          value: function RoundHaloItem_makeLabel_(iconName) {
            var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            return Icon.makeLabel(iconName, Object.assign({
              fontSize: 15,
              reactsToPointer: false
            }, attributes));
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              layout: {
                initialize: function initialize() {
                  this.layout = new TilingLayout({
                    axisAlign: "center",
                    align: "center"
                  });
                }
              }
            };
          }
        }, {
          key: "for",
          value: function RoundHaloItem_for_(halo) {
            return halo.getSubmorphNamed(this.morphName) || halo.addMorph(new this({
              halo: halo,
              name: this.morphName,
              submorphs: [this.label(halo)]
            }));
          }
        }, {
          key: "label",
          value: function RoundHaloItem_label_() {
            return __varRecorder__$5.RoundHaloItem.makeLabel("circle-question");
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 10169,
          end: 10841
        });
      })(__varRecorder__$5.HaloItem);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("NameHolder") && typeof __lively_classholder__.NameHolder === "function" ? __lively_classholder__.NameHolder : __lively_classholder__.NameHolder = function NameHolder(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onHoverIn",
          value: function NameHolder_onHoverIn_(evt) {
            if (this.highlightOnHover && this.nameHolder.active) {
              this.halo.toggleMorphHighlighter(true, this.target);
              this.nameHolder.fontColor = Color.orange;
            }
          }
        }, {
          key: "onHoverOut",
          value: function NameHolder_onHoverOut_(evt) {
            if (this.highlightOnHover) {
              this.halo.toggleMorphHighlighter(false, this.target);
              this.nameHolder.fontColor = Color.darkgray;
            }
          }
        }, {
          key: "accept",
          value: function NameHolder_accept_() {
            if (!this.isEditable) return;

            if (this.target.name !== this.nameHolder.textString) {
              this.updateName(this.nameHolder.textString);
            }
          }
        }, {
          key: "onKeyDown",
          value: function NameHolder_onKeyDown_(evt) {
            if (evt.keyCombo === "Enter") {
              this.accept();
              this.halo.focus();
              evt.stop();
            } else {
              initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onKeyDown", this).call(this, evt);
            }
          }
        }, {
          key: "onMouseUp",
          value: function NameHolder_onMouseUp_() {
            if (!this.isEditable) return;
            signal(this, "active", [true, this]);
          }
        }, {
          key: "onMouseDown",
          value: function NameHolder_onMouseDown_(evt) {
            if (!this.isEditable) return;
            this.nameHolder.fontColor = Color.white;
            this.halo.toggleMorphHighlighter(false, this.target);
          }
        }, {
          key: "onKeyUp",
          value: function NameHolder_onKeyUp_(evt) {
            var _this5 = this;

            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onKeyUp", this).call(this, evt);

            var oldName = this.target.name;
            var newName = this.nameHolder.textString;
            var owner = this.target.owner;
            this.validName = !owner || !owner.getSubmorphNamed(newName) || oldName === newName;

            if (this.target.isComponent && !evt.hasArrowPressed) {
              Promise.resolve().then(function () { return reconciliation; }).then(function (_ref5) {
                var canBeRenamed = _ref5.canBeRenamed;
                _this5.validName = _this5.validName && canBeRenamed(module$1(_this5.target[Symbol["for"]("lively-module-meta")].moduleId), oldName, newName);
                signal(_this5, "valid", [_this5.validName, newName]);
              });
              return;
            }

            signal(this, "valid", [this.validName, newName]);
          }
        }, {
          key: "update",
          value: function NameHolder_update_() {
            this.nameHolder.nativeCursor = this.isEditable ? "text" : "not-allowed";
            this.nameHolder.readOnly = !this.isEditable;

            if (!this.isEditable) {
              this.tooltip = "Cannot change this items name, since it was derived from another component.";
            } else this.tooltip = "Click to edit the item's name";

            if (this.nameHolder.textString === this.target.name) return;
            this.nameHolder.textString = this.target.name;
            this.nameHolder.fit();
          }
        }, {
          key: "activate",
          value: function NameHolder_activate_() {
            this.nameHolder.readOnly = false;
            this.nameHolder.active = true;
            this.nameHolder.animate({
              opacity: 1
            });
          }
        }, {
          key: "deactivate",
          value: function NameHolder_deactivate_() {
            this.nameHolder.readOnly = true;
            this.nameHolder.active = false;
            this.nameHolder.animate({
              opacity: 0.3
            });
          }
        }, {
          key: "updateName",
          value: function NameHolder_updateName_(newName) {
            var _this6 = this;

            if (!this.forceUniqueName || this.validName) {
              this.withMetaDo({
                reconcileChanges: true
              }, function () {
                _this6.target.name = newName;
              });
              signal(this, "active", [false, this]);
              var commentBrowser = $world.getSubmorphNamed("Comment Browser");
              if (commentBrowser) commentBrowser.updateName(this.target);
            }
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "NameHolder";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              tooltip: {
                defaultValue: "Click to edit the morph's name"
              },
              draggable: {
                defaultValue: false
              },
              fill: {
                defaultValue: Color.transparent
              },
              forceUniqueName: {
                defaultValue: false
              },
              halo: {},
              isEditable: {
                derived: true,
                get: function get() {
                  var ownerChain = this.target.ownerChain();
                  var withinComponentContext = false;
                  var derived = false;

                  var _iterator = _createForOfIteratorHelper(ownerChain),
                      _step;

                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                      var _each$master$parent;

                      var each = _step.value;
                      if (each.isComponent) withinComponentContext = true;
                      if (each.master) derived = !!((_each$master$parent = each.master.parent) === null || _each$master$parent === void 0 ? void 0 : _each$master$parent.getSubSpecFor(this.target.name));
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }

                  return withinComponentContext && !derived || !withinComponentContext;
                }
              },
              layout: {
                after: ["nameHolder"],
                initialize: function initialize() {
                  this.layout = new TilingLayout({
                    hugContentsHorizontally: true,
                    hugContentsVertically: true,
                    spacing: 7
                  });
                }
              },
              nameHolder: {
                after: ["submorphs"],
                initialize: function initialize() {
                  this.nameHolder = this.addMorph(new Text({
                    fill: Color.transparent,
                    fontColor: Color.white,
                    fontWeight: "bold",
                    nativeCursor: "text",
                    readOnly: true,
                    active: false
                  }));
                  connect(this.nameHolder, "onBlur", this, "accept");
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 10876,
          end: 15238
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("NameHaloItem") && typeof __lively_classholder__.NameHaloItem === "function" ? __lively_classholder__.NameHaloItem : __lively_classholder__.NameHaloItem = function NameHaloItem(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function NameHaloItem_initialize_(props) {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this, props);
            this.initComponentLink();
            this.initNameHolders();
            this.validityIndicator = Icon.makeLabel("check", {
              fontColor: Color.green,
              fontSize: 15,
              padding: Rectangle.inset(5, 0, 0, 0)
            });
            this.fill = __varRecorder__$5.getColorForTarget(this.halo.target);
            this.alignInHalo();
            return _this;
          }
        }, {
          key: "initComponentLink",
          value: function NameHaloItem_initComponentLink_() {
            var target = this.halo.target;
            if (!target || target.isMorphSelection) return;

            if (target.master || target.isComponent) {
              var appliedMaster = target.master || target;
              var meta;

              while (!meta) {
                meta = appliedMaster[Symbol["for"]("lively-module-meta")];
                appliedMaster = appliedMaster.parent;
                if (!appliedMaster) break;
              }

              var masterLink = this.addMorph(Icon.makeLabel(meta ? "external-link-alt" : "exclamation-triangle", {
                nativeCursor: "pointer",
                fontColor: Color.white,
                padding: Rectangle.inset(0, 0, 4, 0),
                name: "master link",
                tooltip: meta ? "Located in " + meta.moduleId : "This morph is assigned an empty style policy.\nThis means there is no master component that\ndictates the styling of this morph at any time.\nTo fix this, assign a master component to a custom state,\nbreakpoint or event state."
              }));
              meta && connect(masterLink, "onMouseDown", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                var _meta$path;

                var _yield$import, findComponentDef, range, parsedModule, scope;

                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return Promise.resolve().then(function () { return helpers; });

                      case 2:
                        _yield$import = _context.sent;
                        findComponentDef = _yield$import.findComponentDef;

                        if (!(((_meta$path = meta.path) === null || _meta$path === void 0 ? void 0 : _meta$path.length) > 0)) {
                          _context.next = 25;
                          break;
                        }

                        _context.next = 9;
                        return module$1(meta.moduleId).ast();

                      case 9:
                        parsedModule = _context.sent;

                      case 10:

                        scope = getPropertiesNode(findComponentDef(parsedModule, meta.exportedName));
                        range = drillDownPath(scope, meta.path);

                        if (range) {
                          _context.next = 22;
                          break;
                        }

                        if (appliedMaster) {
                          _context.next = 16;
                          break;
                        }

                        return _context.abrupt("break", 25);

                      case 16:
                        meta = appliedMaster[Symbol["for"]("lively-module-meta")];
                        _context.next = 19;
                        return module$1(meta.moduleId).ast();

                      case 19:
                        parsedModule = _context.sent;
                        appliedMaster = appliedMaster.parent;
                        return _context.abrupt("continue", 10);

                      case 22:
                        return _context.abrupt("break", 25);

                      case 25:
                        $world.execCommand("open browser", Object.assign({
                          moduleName: meta.moduleId,
                          reuse: true
                        }, range ? {
                          range: range
                        } : {
                          codeEntity: meta.exportedName
                        }));

                      case 26:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              })));
            }
          }
        }, {
          key: "showLocalMaster",
          value: function NameHaloItem_showLocalMaster_(masterComponent) {
            var win;

            if (win = masterComponent.getWindow()) {
              win.activate();
              if (win.minimized) win.minimized = false;
            }

            masterComponent.show();
          }
        }, {
          key: "targets",
          value: function NameHaloItem_targets_() {
            if (!this.halo.target) return [];
            return this.halo.target.isMorphSelection ? this.halo.target.selectedMorphs.map(function (target) {
              return {
                target: target,
                highlightOnHover: true
              };
            }) : [{
              target: this.halo.target,
              highlightOnHover: false
            }];
          }
        }, {
          key: "initNameHolders",
          value: function NameHaloItem_initNameHolders_() {
            var _this7 = this;

            this.nameHolders = this.targets().map(function (_ref7) {
              var target = _ref7.target,
                  highlightOnHover = _ref7.highlightOnHover;
              var nh = new __varRecorder__$5.NameHolder({
                halo: _this7.halo,
                highlightOnHover: highlightOnHover,
                target: target,
                forceUniqueName: target.isComponent
              });
              connect(nh, "active", _this7, "toggleActive");
              connect(nh, "valid", _this7, "toggleNameValid");
              return nh;
            });
            this.submorphs = [].concat(_toConsumableArray$1(this.submorphs), _toConsumableArray$1(interpose(this.nameHolders, {
              extent: pt(1, 28),
              fill: Color.black.withA(0.4)
            })));
          }
        }, {
          key: "toggleActive",
          value: function NameHaloItem_toggleActive_(_ref8) {
            var _ref9 = _slicedToArray(_ref8, 2),
                active = _ref9[0],
                nameHolder = _ref9[1];

            if (this.halo.changingName === active) {
              return;
            }

            this.halo.changingName = active;
            var masterLink = this.get("master link");

            if (masterLink) {
              masterLink.visible = masterLink.isLayoutable = !active;
            }

            if (active) {
              this.nameHolders.forEach(function (nh) {
                return nh !== nameHolder && nh.deactivate();
              });
              this.borderWidth = 3;
              this.addMorph(this.validityIndicator);
              this.fill = Color.darkGray;
              nameHolder.activate();
              setTimeout(function () {
                nameHolder.nameHolder.selectAll();
              });
            } else {
              this.fill = __varRecorder__$5.haloBlue;
              this.nameHolders.forEach(function (nh) {
                return nh !== nameHolder && nh.activate();
              });
              this.borderWidth = 0;
              this.validityIndicator.remove();
            }

            this.alignInHalo();
          }
        }, {
          key: "toggleNameValid",
          value: function NameHaloItem_toggleNameValid_(_ref10) {
            var _ref11 = _slicedToArray(_ref10, 2),
                valid = _ref11[0],
                name = _ref11[1];

            this.validName = valid;

            if (valid) {
              this.conflictingMorph = null;
              this.borderColor = Color.green;
              this.validityIndicator.nativeCursor = "auto";
              this.validityIndicator.fontColor = Color.green;
              Icon.setIcon(this.validityIndicator, "check");
            } else {
              this.conflictingMorph = this.get(name);
              this.borderColor = Color.red;
              this.validityIndicator.fontColor = Color.red;
              this.validityIndicator.nativeCursor = "pointer";
              Icon.setIcon(this.validityIndicator, "exclamation-circle");
            }
          }
        }, {
          key: "alignInHalo",
          value: function NameHaloItem_alignInHalo_() {
            zip(this.targets(), this.nameHolders).map(function (_ref12) {
              var _ref13 = _slicedToArray(_ref12, 2),
                  target = _ref13[0].target,
                  nh = _ref13[1];

              nh.target = target;
              nh.update();
            });

            var _this$halo$innerBound = this.halo.innerBounds().bottomCenter().addPt(pt(0, 2)),
                x = _this$halo$innerBound.x,
                y = _this$halo$innerBound.y;

            this.topCenter = pt(Math.max(x, 30), Math.max(y, 80));
          }
        }, {
          key: "onMouseDown",
          value: function NameHaloItem_onMouseDown_(evt) {
            var _this8 = this;

            var m = this.conflictingMorph;

            if (m) {
              this.halo.toggleMorphHighlighter(true, m);
              setTimeout(function () {
                return _this8.halo.toggleMorphHighlighter(false, m);
              }, 1000);
            }
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "NameHaloItem";
          }
        }, {
          key: "morphName",
          get: function get() {
            return "name";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              borderRadius: {
                defaultValue: 4
              },
              fill: {
                defaultValue: __varRecorder__$5.haloBlue
              },
              borderColor: {
                defaultValue: Color.green
              },
              layout: {
                initialize: function initialize() {
                  this.layout = new TilingLayout({
                    hugContentsHorizontally: true,
                    hugContentsVertically: true,
                    axisAlign: "center",
                    orderByIndex: true,
                    padding: Rectangle.inset(7.5, 5, 7.5, 5)
                  });
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 15240,
          end: 21158
        });
      })(__varRecorder__$5.HaloItem);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("CloseHaloItem") && typeof __lively_classholder__.CloseHaloItem === "function" ? __lively_classholder__.CloseHaloItem : __lively_classholder__.CloseHaloItem = function CloseHaloItem(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "update",
          value: function CloseHaloItem_update_() {
            this.halo.closeSession();
          }
        }, {
          key: "onMouseDown",
          value: function CloseHaloItem_onMouseDown_(evt) {
            this.update();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "CloseHaloItem";
          }
        }, {
          key: "morphName",
          get: function get() {
            return "close";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              targetIsComponent: {
                derived: true,
                get: function get() {
                  return this.halo.target.isComponent;
                }
              },
              draggable: {
                defaultValue: false
              },
              tooltip: {
                after: ["halo"],
                initialize: function initialize() {
                  this.tooltip = this.targetIsComponent ? "Hide this component" : "Remove this morph from the world";
                }
              }
            };
          }
        }, {
          key: "label",
          value: function CloseHaloItem_label_(halo) {
            return halo.target.isComponent ? __varRecorder__$5.RoundHaloItem.makeLabel("eye-slash") : __varRecorder__$5.RoundHaloItem.makeLabel("trash");
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 21160,
          end: 21902
        });
      })(__varRecorder__$5.RoundHaloItem);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GrabHaloItem") && typeof __lively_classholder__.GrabHaloItem === "function" ? __lively_classholder__.GrabHaloItem : __lively_classholder__.GrabHaloItem = function GrabHaloItem(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "adjustTarget",
          value: function GrabHaloItem_adjustTarget_(target, pos) {
            if (Path("owner.layout.autoResize").get(target)) {
              if (!target.globalBounds().insetBy(10).containsPoint(pos)) target = target.owner;
            }

            return target;
          }
        }, {
          key: "valueForPropertyDisplay",
          value: function GrabHaloItem_valueForPropertyDisplay_() {
            var hand = this.hand,
                halo = this.halo,
                prevDropTarget = this.prevDropTarget;
            var world = hand.world();
            var dropTarget = hand.findDropTarget(hand.globalPosition, [halo.target], function (morph) {
              return !morph.isHaloItem && !morph.ownerChain().some(function (m) {
                return m.isHaloItem || !m.visible || m.opacity === 0;
              });
            });
            if (!dropTarget) return;
            dropTarget = this.adjustTarget(dropTarget, hand.globalPosition);
            halo.toggleMorphHighlighter(dropTarget && dropTarget !== world, dropTarget, true);

            if (prevDropTarget && prevDropTarget !== dropTarget) {
              halo.toggleMorphHighlighter(false, prevDropTarget);
            }

            this.prevDropTarget = dropTarget;
            return dropTarget && dropTarget.name;
          }
        }, {
          key: "init",
          value: function GrabHaloItem_init_(hand) {
            var halo = this.halo;
            var undo = halo.target.undoStart("grab-halo");
            undo && undo.addTarget(halo.target.owner);
            this.hand = hand;
            this.withMetaDo({
              reconcileChanges: true
            }, function () {
              halo.target.onGrab({
                halo: halo,
                hand: hand,
                isShiftDown: function isShiftDown() {
                  return false;
                }
              });
            });
            halo.state.activeButton = this;
            this.opacity = 0.3;
            var c = connect(hand, "update", this, "update");
            once$1(halo.target, "remove", function () {
              return c.disconnect();
            });
          }
        }, {
          key: "stop",
          value: function GrabHaloItem_stop_(evt) {
            var halo = this.halo,
                prevDropTarget = this.prevDropTarget;
            var undo = halo.target.undoInProgress;
            var dropTarget = evt.hand.findDropTarget(evt.hand.globalPosition, [halo.target], function (m) {
              return !m.isHaloItem && !m.ownerChain().some(function (m) {
                return m.isHaloItem;
              });
            });
            dropTarget = this.adjustTarget(dropTarget, evt.hand.globalPosition);
            disconnect(evt.hand, "update", this, "update");

            __varRecorder__$5.MorphHighlighter.interceptDrop(halo, dropTarget, halo.target);

            undo.addTarget(dropTarget);
            this.withMetaDo({
              reconcileChanges: true
            }, function () {
              dropTarget.onDrop(evt);
            });
            halo.state.activeButton = null;
            halo.toggleMorphHighlighter(false, prevDropTarget);

            __varRecorder__$5.MorphHighlighter.removeHighlighters(halo);

            halo.target.undoStop("grab-halo");
            this.opacity = 1;
            halo.alignWithTarget();
          }
        }, {
          key: "update",
          value: function GrabHaloItem_update_() {
            this.halo.alignWithTarget();
          }
        }, {
          key: "onDragStart",
          value: function GrabHaloItem_onDragStart_(evt) {
            this.init(evt.hand);
          }
        }, {
          key: "onDragEnd",
          value: function GrabHaloItem_onDragEnd_(evt) {
            this.stop(evt);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GrabHaloItem";
          }
        }, {
          key: "morphName",
          get: function get() {
            return "grab";
          }
        }, {
          key: "label",
          value: function GrabHaloItem_label_() {
            return __varRecorder__$5.RoundHaloItem.makeLabel("hand-back-fist");
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              tooltip: {
                defaultValue: "Grab the morph"
              },
              draggable: {
                defaultValue: true
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 21965,
          end: 24649
        });
      })(__varRecorder__$5.RoundHaloItem);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DragHaloItem") && typeof __lively_classholder__.DragHaloItem === "function" ? __lively_classholder__.DragHaloItem : __lively_classholder__.DragHaloItem = function DragHaloItem(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "valueForPropertyDisplay",
          value: function DragHaloItem_valueForPropertyDisplay_() {
            return this._dontShowPosition ? undefined : this.halo.target.position;
          }
        }, {
          key: "updateAlignmentGuide",
          value: function DragHaloItem_updateAlignmentGuide_(active) {
            var mesh = this.halo.getSubmorphNamed("mesh");

            if (!active) {
              mesh && mesh.remove();
              return;
            }

            mesh = this.halo.getMesh(this.halo.target.worldPoint(pt(0, 0)));
            this.focus();
            return mesh;
          }
        }, {
          key: "init",
          value: function DragHaloItem_init_() {
            var target = this.halo.target;
            if (!target.owner) return;
            var interferingLayout = target.owner.layout;
            target.undoStart("drag-halo");

            if (interferingLayout && interferingLayout.name() === "Tiling" && interferingLayout.layoutableSubmorphs.includes(target)) {
              this._dontShowPosition = true;
              this.halo.indicateLooseMovement(true);
            }

            this.halo.state.activeButton = this;
            this.actualPos = target.position;
            this.targetTransform = target.owner.getGlobalTransform().inverse();
          }
        }, {
          key: "stop",
          value: function DragHaloItem_stop_() {
            this.halo.target.undoStop("drag-halo");
            this.halo.state.activeButton = null;
            this.halo.alignWithTarget();
            this.halo.originHalo().alignInHalo();
            this.halo.indicateLooseMovement(false);
            this._dontShowPosition = false;
            this.updateAlignmentGuide(false);
            removeSnapToGuidesOf(this.halo.target);
          }
        }, {
          key: "update",
          value: function DragHaloItem_update_(delta) {
            var _this9 = this;

            var grid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var snapToGuides = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            if (!this.actualPos) return;
            var newPos = this.actualPos.addPt(this.targetTransform.transformDirection(delta));
            this.actualPos = newPos;

            if (grid) {
              newPos = newPos.griddedBy(pt(10, 10));
            }

            this.withMetaDo({
              reconcileChanges: true
            }, function () {
              _this9.halo.target.position = newPos;
            });
            this.updateAlignmentGuide(grid);
            var world = this.world();

            if (world.activeSideBars.includes("properties panel")) {
              world.propertiesPanel.onHierarchyChange();
            }

            if (!grid) {
              showAndSnapToGuides(this.halo.target, true, snapToGuides, 5, 500);
            }
          }
        }, {
          key: "onDragStart",
          value: function DragHaloItem_onDragStart_(evt) {
            this.init();
          }
        }, {
          key: "onDrag",
          value: function DragHaloItem_onDrag_(evt) {
            this.update(evt.state.dragDelta, evt.isAltDown(), evt.isCtrlDown());
          }
        }, {
          key: "onDragEnd",
          value: function DragHaloItem_onDragEnd_(evt) {
            this.stop();
          }
        }, {
          key: "onKeyUp",
          value: function DragHaloItem_onKeyUp_(evt) {
            this.updateAlignmentGuide(false);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DragHaloItem";
          }
        }, {
          key: "morphName",
          get: function get() {
            return "drag";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              draggable: {
                defaultValue: true
              },
              tooltip: {
                defaultValue: "Change the morph's position. Press (alt) while dragging to align the morph's position along a grid."
              }
            };
          }
        }, {
          key: "label",
          value: function DragHaloItem_label_() {
            return __varRecorder__$5.RoundHaloItem.makeLabel("arrows-alt");
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 24651,
          end: 27228
        });
      })(__varRecorder__$5.RoundHaloItem);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("InspectHaloItem") && typeof __lively_classholder__.InspectHaloItem === "function" ? __lively_classholder__.InspectHaloItem : __lively_classholder__.InspectHaloItem = function InspectHaloItem(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onMouseDown",
          value: function InspectHaloItem_onMouseDown_(evt) {
            var _this10 = this;

            _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
              var Inspector, existing, win;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return Promise.resolve().then(function () { return ui_cp; });

                    case 2:
                      Inspector = _context2.sent;
                      existing = _this10.world().withAllSubmorphsSelect(function (m) {
                        var _m$targetMorph;

                        return m.isWindow && ((_m$targetMorph = m.targetMorph) === null || _m$targetMorph === void 0 ? void 0 : _m$targetMorph.isInspector);
                      }).map(function (w) {
                        return w.targetMorph;
                      }).find(function (i) {
                        return i.targetObject === _this10.halo.target;
                      });

                      if (existing && (win = existing.getWindow())) {
                        win.minimized = false;
                        win.activate();
                        win.animate({
                          center: _this10.world().visibleBounds().center(),
                          duration: 200
                        });
                        win.show();
                      } else {
                        Inspector.openInWindow({
                          targetObject: _this10.halo.target
                        });
                      }

                      _this10.halo.remove();

                    case 6:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }))();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "InspectHaloItem";
          }
        }, {
          key: "morphName",
          get: function get() {
            return "inspect";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              tooltip: {
                defaultValue: "Inspect the morph's local state"
              },
              draggable: {
                defaultValue: false
              }
            };
          }
        }, {
          key: "label",
          value: function InspectHaloItem_label_() {
            return __varRecorder__$5.RoundHaloItem.makeLabel("magnifying-glass-chart");
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 27230,
          end: 28257
        });
      })(__varRecorder__$5.RoundHaloItem);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("EditHaloItem") && typeof __lively_classholder__.EditHaloItem === "function" ? __lively_classholder__.EditHaloItem : __lively_classholder__.EditHaloItem = function EditHaloItem(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onMouseDown",
          value: function () {
            var _EditHaloItem_onMouseDown_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(evt) {
              var targetToEdit, world, existing, win;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      targetToEdit = this.halo.target;
                      world = this.world();

                      if (!targetToEdit.viewModel) {
                        _context3.next = 7;
                        break;
                      }

                      this.halo.remove();
                      _context3.next = 6;
                      return world.multipleChoicePrompt({
                        title: "Edit View or Morph?",
                        text: "The selected morph is attached to a view model. Please select which one you would like to edit."
                      }, {
                        choices: new Map([[[].concat(_toConsumableArray$1(Icon.textAttribute("database", {
                          paddingTop: "3px"
                        })), ["   Model", null]), targetToEdit.viewModel], [[].concat(_toConsumableArray$1(Icon.textAttribute("eye", {
                          paddingTop: "3px"
                        })), ["   View", null]), targetToEdit]])
                      });

                    case 6:
                      targetToEdit = _context3.sent;

                    case 7:
                      existing = world.getSubmorphsByStyleClassName("ObjectEditor").find(function (oe) {
                        return oe.target === targetToEdit;
                      });

                      if (existing) {
                        win = existing.getWindow();
                        win.bringToFront();
                        win.minimized = false;
                        win.animate({
                          center: world.visibleBounds().center(),
                          duration: 200
                        });
                      } else {
                        world.execCommand("open object editor", {
                          target: targetToEdit
                        });
                      }

                      this.halo.remove();

                    case 10:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function EditHaloItem_onMouseDown_(_x) {
              return _EditHaloItem_onMouseDown_.apply(this, arguments);
            }

            return EditHaloItem_onMouseDown_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "EditHaloItem";
          }
        }, {
          key: "morphName",
          get: function get() {
            return "edit";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              tooltip: {
                defaultValue: "Edit the morph's definition"
              },
              draggable: {
                defaultValue: false
              }
            };
          }
        }, {
          key: "label",
          value: function EditHaloItem_label_() {
            return __varRecorder__$5.RoundHaloItem.makeLabel("wrench");
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 28259,
          end: 29735
        });
      })(__varRecorder__$5.RoundHaloItem);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ResponsiveHaloItem") && typeof __lively_classholder__.ResponsiveHaloItem === "function" ? __lively_classholder__.ResponsiveHaloItem : __lively_classholder__.ResponsiveHaloItem = function ResponsiveHaloItem(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onMouseDown",
          value: function ResponsiveHaloItem_onMouseDown_(evt) {
            this.start();
          }
        }, {
          key: "start",
          value: function ResponsiveHaloItem_start_() {
            this.world().execCommand("show responsive halo for", {
              target: this.halo.target
            });
          }
        }, {
          key: "stop",
          value: function ResponsiveHaloItem_stop_() {
            this.halo.activeItems = ["*"];
            this.halo.alignWithTarget();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ResponsiveHaloItem";
          }
        }, {
          key: "morphName",
          get: function get() {
            return "responsive";
          }
        }, {
          key: "label",
          value: function ResponsiveHaloItem_label_() {
            return __varRecorder__$5.RoundHaloItem.makeLabel("ti-columns-3");
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              tooltip: {
                defaultValue: "Activate the responsive design mode for this morph."
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 29737,
          end: 30291
        });
      })(__varRecorder__$5.RoundHaloItem);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("RotateHaloItem") && typeof __lively_classholder__.RotateHaloItem === "function" ? __lively_classholder__.RotateHaloItem : __lively_classholder__.RotateHaloItem = function RotateHaloItem(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function RotateHaloItem_initialize_(props) {
            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this, props);
            this.adaptAppearance(false);
            return _this;
          }
        }, {
          key: "angle",
          get: function get() {
            return this.getProperty("angle") || 0;
          }
        }, {
          key: "angle",
          set: function set(val) {
            this.setProperty("angle", val);
          }
        }, {
          key: "scaleGauge",
          get: function get() {
            return this.getProperty("scaleGauge") || null;
          }
        }, {
          key: "scaleGauge",
          set: function set(val) {
            this.setProperty("scaleGauge", val);
          }
        }, {
          key: "initRotation",
          get: function get() {
            return this.getProperty("initRotation") || 0;
          }
        }, {
          key: "initRotation",
          set: function set(val) {
            this.setProperty("initRotation", val);
          }
        }, {
          key: "valueForPropertyDisplay",
          value: function RotateHaloItem_valueForPropertyDisplay_() {
            var scaleGauge = this.scaleGauge,
                t = this.halo.target;
            return scaleGauge ? t.scale.toFixed(4).toString() : toDegrees(t.rotation).toFixed(1) + "\xB0";
          }
        }, {
          key: "init",
          value: function RotateHaloItem_init_(angleToTarget) {
            this.detachFromLayout();
            this.halo.target.undoStart("rotate-halo");
            this.halo.state.activeButton = this;
            this.angle = angleToTarget;
            this.initRotation = this.halo.target.rotation;
            this.halo.toggleRotationIndicator(true, this);
          }
        }, {
          key: "initScale",
          value: function RotateHaloItem_initScale_(gauge) {
            this.detachFromLayout();
            this.halo.state.activeButton = this;
            this.scaleGauge = gauge.scaleBy(1 / this.halo.target.scale);
            this.halo.toggleRotationIndicator(true, this);
          }
        }, {
          key: "update",
          value: function RotateHaloItem_update_(angleToTarget) {
            var _this11 = this;

            this.scaleGauge = null;
            var newRotation = this.initRotation + (angleToTarget - this.angle);
            newRotation = toRadians(detent(toDegrees(newRotation), 10, 45));
            this.withMetaDo({
              reconcileChanges: true
            }, function () {
              _this11.halo.target.rotation = newRotation;
            });
            this.halo.toggleRotationIndicator(true, this);
          }
        }, {
          key: "updateScale",
          value: function RotateHaloItem_updateScale_(gauge) {
            var scaleG = this.scaleGauge,
                halo = this.halo;
            if (!scaleG) scaleG = this.scaleGauge = gauge.scaleBy(1 / halo.target.scale);
            this.angle = gauge.theta();
            this.withMetaDo({
              reconcileChanges: true
            }, function () {
              halo.target.scale = detent(gauge.dist(pt(0, 0)) / scaleG.dist(pt(0, 0)), 0.1, 0.5);
            });
            halo.toggleRotationIndicator(true, this);
          }
        }, {
          key: "stop",
          value: function RotateHaloItem_stop_() {
            this.attachToLayout();
            this.scaleGauge = null;
            this.halo.state.activeButton = null;
            this.halo.alignWithTarget();
            this.halo.toggleRotationIndicator(false, this);
            this.halo.target.undoStop("rotate-halo");
            this.halo.ensureResizeHandles();
          }
        }, {
          key: "adaptAppearance",
          value: function RotateHaloItem_adaptAppearance_(scaling) {
            if (scaling && config$2.ide.studio.canvasModeEnabled && $world.morphsInWorld.includes(this.halo.target)) scaling = false;
            this.submorphs[0].textAndAttributes = scaling ? Icon.textAttribute("search-plus", {
              fontSize: 15
            }) : Icon.textAttribute("redo", {
              fontSize: 15
            });
            this.tooltip = scaling ? "Scale morph" : "Rotate morph";
          }
        }, {
          key: "detachFromLayout",
          value: function RotateHaloItem_detachFromLayout_() {}
        }, {
          key: "attachToLayout",
          value: function RotateHaloItem_attachToLayout_() {}
        }, {
          key: "isInScaleMode",
          value: function RotateHaloItem_isInScaleMode_(evt) {
            if (config$2.ide.studio.canvasModeEnabled) return evt.isShiftDown() && !$world.morphsInWorld.includes(this.halo.target);
            return evt.isShiftDown();
          }
        }, {
          key: "onDragStart",
          value: function RotateHaloItem_onDragStart_(evt) {
            var scaleMode = this.isInScaleMode(evt);
            this.adaptAppearance(scaleMode);

            if (scaleMode) {
              this.initScale(evt.position.subPt(this.halo.target.globalPosition));
            } else {
              this.init(evt.position.subPt(this.halo.target.globalPosition).theta());
            }
          }
        }, {
          key: "onDrag",
          value: function RotateHaloItem_onDrag_(evt) {
            var scaleMode = this.isInScaleMode(evt);
            this.globalPosition = evt.position.addPt(pt(-10, -10));
            this.adaptAppearance(scaleMode);

            if (scaleMode) {
              this.updateScale(evt.position.subPt(this.halo.target.globalPosition));
            } else {
              this.update(evt.position.subPt(this.halo.target.globalPosition).theta());
            }
          }
        }, {
          key: "onDragEnd",
          value: function RotateHaloItem_onDragEnd_(evt) {
            this.adaptAppearance(this.isInScaleMode(evt));
            this.stop();
          }
        }, {
          key: "onKeyDown",
          value: function RotateHaloItem_onKeyDown_(evt) {
            this.adaptAppearance(evt.isShiftDown());
          }
        }, {
          key: "onKeyUp",
          value: function RotateHaloItem_onKeyUp_(evt) {
            this.adaptAppearance(evt.isShiftDown());
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "RotateHaloItem";
          }
        }, {
          key: "morphName",
          get: function get() {
            return "rotate";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              draggable: {
                defaultValue: true
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 30293,
          end: 34422
        });
      })(__varRecorder__$5.RoundHaloItem);

      __varRecorder__$5.nameNumberRe = /(.+)([0-9]+)$/;

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ComponentHaloItem") && typeof __lively_classholder__.ComponentHaloItem === "function" ? __lively_classholder__.ComponentHaloItem : __lively_classholder__.ComponentHaloItem = function ComponentHaloItem(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "updateComponentIndicator",
          value: function ComponentHaloItem_updateComponentIndicator_() {
            var world = this.world();
            var target = this.halo.target;
            this.halo.remove();
            world.showHaloFor(target);
          }
        }, {
          key: "checkForDuplicateNamesInHierarchy",
          value: function () {
            var _ComponentHaloItem_checkForDuplicateNamesInHierarchy_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
              var target, world, morphsInHierarchy, nameGroups, defaultStyle, numberOfAmbigousMorphs, canProceed, name, nonUniqueMorphs, morphToBeRenamed, newName;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      target = this.halo.target;
                      world = this.world();
                      morphsInHierarchy = [];
                      target.withAllSubmorphsDoExcluding(function (m) {
                        if (m !== target) morphsInHierarchy.push(m);
                      }, function (m) {
                        return m.master && m !== target;
                      });
                      nameGroups = groupBy(morphsInHierarchy, function (m) {
                        return m.name;
                      });
                      defaultStyle = {
                        fontWeight: "normal",
                        fontSize: 16
                      };

                      if (!Object.values(nameGroups).find(function (ms) {
                        return ms.length > 1;
                      })) {
                        _context4.next = 13;
                        break;
                      }

                      numberOfAmbigousMorphs = sum(Object.values(nameGroups).filter(function (ms) {
                        return ms.length > 1;
                      }).map(function (ms) {
                        return ms.length;
                      }));
                      _context4.next = 10;
                      return world.confirm(["Ambigous Names in Submorph Hierarchy  ", {}].concat(_toConsumableArray$1(Icon.textAttribute("exclamation-triangle", {
                        fontColor: Color.rgb(230, 126, 34),
                        fontSize: 30,
                        lineHeight: "40px"
                      })), ["\nThe morph you are about to turn into a component has ".concat(numberOfAmbigousMorphs, " morphs within its submorph hierarchy, that have ambigous names. This can lead to incorrect applications of style properties when you create derived instances from this component.\n\n"), Object.assign({}, defaultStyle, {
                        textAlign: "left"
                      }), "Usually ambigous names are caused if your component is in some kind of intermittent state, where it already displays an example state or code has run that automatically created interface elements. This can be fixed by resetting the submorphs of this morph, usually by implementing a ", Object.assign({}, defaultStyle, {
                        textAlign: "left",
                        fontStyle: "italic"
                      }), "reset()", Object.assign({}, defaultStyle, {
                        fontStyle: "italic",
                        fontFamily: "IBM Plex Mono"
                      }), " routine you can invoke to put the morph into some kind of \"neutral\" state. Alternatively you can go ahead and rename the duplicate morphs to have proper unique names. If you have a hard time giving the conflicting morphs appropriate names, this can be an indication that the component you are declaring is too large, and you need to decompose your component into subcomponents further.", Object.assign({}, defaultStyle, {
                        textAlign: "left",
                        fontStyle: "italic"
                      })]), {
                        width: 600,
                        confirmLabel: "PROCEED TO RENAME",
                        rejectLabel: "CANCEL",
                        align: "left"
                      });

                    case 10:
                      canProceed = _context4.sent;

                      if (canProceed) {
                        _context4.next = 13;
                        break;
                      }

                      return _context4.abrupt("return");

                    case 13:
                      _context4.t0 = regeneratorRuntime.keys(nameGroups);

                    case 14:
                      if ((_context4.t1 = _context4.t0()).done) {
                        _context4.next = 39;
                        break;
                      }

                      name = _context4.t1.value;

                      if (!(nameGroups[name].length < 2)) {
                        _context4.next = 18;
                        break;
                      }

                      return _context4.abrupt("continue", 14);

                    case 18:
                      nonUniqueMorphs = nameGroups[name];

                    case 19:
                      if (!(nonUniqueMorphs.length > 1)) {
                        _context4.next = 37;
                        break;
                      }

                      morphToBeRenamed = nonUniqueMorphs[0];
                      show(morphToBeRenamed, true);
                      _context4.next = 24;
                      return world.prompt({
                        title: "Name Collision",
                        text: ["The name of\n", defaultStyle, morphToBeRenamed.toString(), Object.assign({}, defaultStyle, {
                          fontStyle: "italic",
                          fontWeight: "bold"
                        }), "\nis not unique within the submorph hierachy of\n", Object.assign({}, defaultStyle), target.name, Object.assign({}, defaultStyle, {
                          fontStyle: "italic",
                          fontWeight: "bold"
                        }), "\nThere ".concat(nonUniqueMorphs.length > 2 ? "are " + (nonUniqueMorphs.length - 1) + " other morphs" : "is one other morph", " with the exact same name located in this component."), defaultStyle, " Duplicate names can cause errors when applying styles to derived morphs of this master component, so it is essential that there is no name ambiguity. Please enter a new name for this or the other conflicting morphs:", defaultStyle]
                      }, {
                        input: morphToBeRenamed.name,
                        lineWrapping: "by-words",
                        width: 500,
                        fontSize: 12,
                        rejectLabel: "IGNORE",
                        confirmLabel: "RENAME",
                        errorMessage: "Provided name is not unique",
                        validate: function validate(val) {
                          return !Object.keys(nameGroups).includes(val);
                        }
                      });

                    case 24:
                      newName = _context4.sent;
                      signal(world, "hideMarkers");
                      if (newName) morphToBeRenamed.name = newName;

                      if (!(newName in nameGroups)) {
                        _context4.next = 31;
                        break;
                      }

                      return _context4.abrupt("continue", 19);

                    case 31:
                      if (newName) {
                        _context4.next = 34;
                        break;
                      }

                      nonUniqueMorphs = rotate(nonUniqueMorphs);
                      return _context4.abrupt("continue", 19);

                    case 34:
                      remove(nonUniqueMorphs, morphToBeRenamed);
                      _context4.next = 19;
                      break;

                    case 37:
                      _context4.next = 14;
                      break;

                    case 39:
                      return _context4.abrupt("return", true);

                    case 40:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function ComponentHaloItem_checkForDuplicateNamesInHierarchy_() {
              return _ComponentHaloItem_checkForDuplicateNamesInHierarchy_.apply(this, arguments);
            }

            return ComponentHaloItem_checkForDuplicateNamesInHierarchy_;
          }()
        }, {
          key: "onMouseDown",
          value: function () {
            var _ComponentHaloItem_onMouseDown_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      this.update();

                    case 1:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function ComponentHaloItem_onMouseDown_() {
              return _ComponentHaloItem_onMouseDown_.apply(this, arguments);
            }

            return ComponentHaloItem_onMouseDown_;
          }()
        }, {
          key: "update",
          value: function () {
            var _ComponentHaloItem_update_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
              var target, toBeComponent, openBrowser, autoSelectModule, _yield$import2, insertComponentDefinition, removeComponentDefinition, _yield$import3, InteractiveComponentDescriptor, Browser, _target$master, _target$master$parent, _target$master$parent2, _yield$import4, localInterface, items, variableName, parentName, selectedModule, _varRecorder__$__int, _varRecorder__$__int2, res, _target$master2, _target$master2$paren, _target$master2$paren2, r, mod, browser, descr, componentMorph, _target$master$_depen, _target$master$_depen2, _target$master$_depen3, _target$master$Symbol, moduleId, exportedName, pos, master;

              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      target = this.halo.target;
                      toBeComponent = !target.isComponent;
                      openBrowser = false;
                      autoSelectModule = true;
                      _context6.next = 6;
                      return Promise.resolve().then(function () { return reconciliation; });

                    case 6:
                      _yield$import2 = _context6.sent;
                      insertComponentDefinition = _yield$import2.insertComponentDefinition;
                      removeComponentDefinition = _yield$import2.removeComponentDefinition;
                      _context6.next = 11;
                      return Promise.resolve().then(function () { return editor; });

                    case 11:
                      _yield$import3 = _context6.sent;
                      InteractiveComponentDescriptor = _yield$import3.InteractiveComponentDescriptor;
                      _context6.next = 15;
                      return Promise.resolve().then(function () { return ui_cp$1; });

                    case 15:
                      Browser = _context6.sent;

                      if (!toBeComponent) {
                        _context6.next = 82;
                        break;
                      }

                      _context6.next = 19;
                      return Promise.resolve().then(function () { return index$2; });

                    case 19:
                      _yield$import4 = _context6.sent;
                      localInterface = _yield$import4.localInterface;
                      _context6.next = 23;
                      return localInterface.coreInterface.getLoadedModules(config$2.ide.js.ignoredPackages);

                    case 23:
                      _context6.t0 = function (_ref15) {
                        var _$world$openedProject, _m$name;

                        var m = _ref15.module,
                            p = _ref15["package"];
                        return p.url === ((_$world$openedProject = $world.openedProject) === null || _$world$openedProject === void 0 ? void 0 : _$world$openedProject.url) && ((_m$name = m.name) === null || _m$name === void 0 ? void 0 : _m$name.endsWith(".cp.js"));
                      };

                      _context6.t1 = function (_ref16) {
                        var p = _ref16["package"],
                            m = _ref16.module;
                        var shortName = localInterface.shortModuleName(m.name, p);
                        var string = "[".concat(p.name, "] ").concat(shortName);
                        return {
                          isListItem: true,
                          string: string,
                          value: m
                        };
                      };

                      items = _context6.sent.filter(_context6.t0).map(_context6.t1);
                      parentName = (_target$master = target.master) === null || _target$master === void 0 ? void 0 : (_target$master$parent = _target$master.parent) === null || _target$master$parent === void 0 ? void 0 : (_target$master$parent2 = _target$master$parent[Symbol["for"]("lively-module-meta")]) === null || _target$master$parent2 === void 0 ? void 0 : _target$master$parent2.exportedName;

                      if (!isUUID(target.name)) {
                        variableName = camelCaseString(target.name);
                      }

                      if (!variableName && parentName || variableName === parentName) {
                        variableName = incName(parentName);
                      }

                      if (variableName) {
                        _context6.next = 33;
                        break;
                      }

                      _context6.next = 32;
                      return $world.prompt("Enter a name for this component", {
                        input: decamelize(target.name)
                      });

                    case 32:
                      variableName = _context6.sent;

                    case 33:
                      if (variableName) {
                        _context6.next = 35;
                        break;
                      }

                      return _context6.abrupt("return");

                    case 35:
                      variableName = variableName.replace(/[^a-zA-Z0-9 ]/g, "").replace(/^\d+/, "");
                      variableName = camelCaseString(variableName);

                      if (autoSelectModule) {
                        _context6.next = 46;
                        break;
                      }

                      _context6.next = 40;
                      return $world.filterableListPrompt("Select Home Module for Component", items, {
                        historyId: "lively.morphic-choose and browse package resources",
                        width: 700,
                        multiSelect: false,
                        fuzzy: "value.shortName"
                      });

                    case 40:
                      res = _context6.sent;
                      __varRecorder__$5.__inter0__ = res, (_varRecorder__$__int = __varRecorder__$5.__inter0__.selected, _varRecorder__$__int2 = _slicedToArray(_varRecorder__$__int, 1), selectedModule = _varRecorder__$__int2[0], _varRecorder__$__int), __varRecorder__$5.__inter0__;

                      if (selectedModule) {
                        _context6.next = 44;
                        break;
                      }

                      return _context6.abrupt("return");

                    case 44:
                      _context6.next = 55;
                      break;

                    case 46:
                      selectedModule = (_target$master2 = target.master) === null || _target$master2 === void 0 ? void 0 : (_target$master2$paren = _target$master2.parent) === null || _target$master2$paren === void 0 ? void 0 : (_target$master2$paren2 = _target$master2$paren[Symbol["for"]("lively-module-meta")]) === null || _target$master2$paren2 === void 0 ? void 0 : _target$master2$paren2.moduleId;

                      if (!(selectedModule && !selectedModule.includes("lively."))) {
                        _context6.next = 51;
                        break;
                      }

                      selectedModule = {
                        name: selectedModule
                      };
                      _context6.next = 55;
                      break;

                    case 51:
                      r = resource($world.openedProject["package"].url).join("ui").join(decamelize(variableName).split(" ").join("-") + ".cp.js");
                      _context6.next = 54;
                      return r.ensureExistance("\"format esm\";");

                    case 54:
                      selectedModule = {
                        name: r.url
                      };

                    case 55:
                      target.name = undefined;
                      mod = module$1(selectedModule.name);

                      while (mod.recorder[variableName]) {
                        variableName = incName(variableName);
                      }

                      _context6.next = 60;
                      return insertComponentDefinition(target, variableName, mod);

                    case 60:
                      if (!openBrowser) {
                        _context6.next = 70;
                        break;
                      }

                      _context6.t2 = Browser.browserForFile(mod.id);

                      if (_context6.t2) {
                        _context6.next = 66;
                        break;
                      }

                      _context6.next = 65;
                      return $world.execCommand("open browser");

                    case 65:
                      _context6.t2 = _context6.sent;

                    case 66:
                      browser = _context6.t2;
                      browser.getWindow().activate();
                      _context6.next = 70;
                      return browser.browse({
                        packageName: mod["package"]().name,
                        moduleName: mod.pathInPackage(),
                        codeEntity: variableName
                      });

                    case 70:
                      _context6.next = 72;
                      return waitFor(function () {
                        return mod.recorder[variableName];
                      });

                    case 72:
                      descr = _context6.sent;
                      adoptObject(descr, InteractiveComponentDescriptor);
                      _context6.next = 76;
                      return descr.edit();

                    case 76:
                      componentMorph = _context6.sent;
                      componentMorph.openInWorld(target.globalPosition);
                      target.remove();
                      $world.showHaloFor(componentMorph);
                      _context6.next = 95;
                      break;

                    case 82:
                      _context6.next = 84;
                      return $world.confirm(["Caution\n", {}, "Do you really want to remove this component from the system?", {
                        fontWeight: "normal",
                        fontSize: 16
                      }, ((_target$master$_depen = target.master._dependants) === null || _target$master$_depen === void 0 ? void 0 : _target$master$_depen.size) > 0 ? " ".concat((_target$master$_depen2 = target.master._dependants) === null || _target$master$_depen2 === void 0 ? void 0 : _target$master$_depen2.size, " component").concat(((_target$master$_depen3 = target.master._dependants) === null || _target$master$_depen3 === void 0 ? void 0 : _target$master$_depen3.size) > 1 ? "s are" : " is", " depending on this component.") : "", {
                        fontWeight: "normal",
                        fontSize: 16
                      }]);

                    case 84:
                      if (!_context6.sent) {
                        _context6.next = 95;
                        break;
                      }

                      _target$master$Symbol = target.master[Symbol["for"]("lively-module-meta")], moduleId = _target$master$Symbol.moduleId, exportedName = _target$master$Symbol.exportedName;
                      pos = target.position;
                      _context6.next = 89;
                      return removeComponentDefinition(exportedName, module$1(moduleId));

                    case 89:
                      target.isComponent = false;
                      master = new PolicyApplicator({}, target.master);
                      target.master = null;
                      target.master = master;
                      target.position = pos;
                      this.updateComponentIndicator();

                    case 95:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function ComponentHaloItem_update_() {
              return _ComponentHaloItem_update_.apply(this, arguments);
            }

            return ComponentHaloItem_update_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ComponentHaloItem";
          }
        }, {
          key: "morphName",
          get: function get() {
            return "component";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              tooltip: {
                get: function get() {
                  return this.halo.target.isComponent ? "Retract Component" : "Turn into Component";
                }
              }
            };
          }
        }, {
          key: "label",
          value: function ComponentHaloItem_label_(halo) {
            return halo.target.isComponent ? __varRecorder__$5.RoundHaloItem.makeLabel("eraser") : __varRecorder__$5.RoundHaloItem.makeLabel("cube");
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 34463,
          end: 43971
        });
      })(__varRecorder__$5.RoundHaloItem);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("CopyHaloItem") && typeof __lively_classholder__.CopyHaloItem === "function" ? __lively_classholder__.CopyHaloItem : __lively_classholder__.CopyHaloItem = function CopyHaloItem(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "init",
          value: function CopyHaloItem_init_(hand) {
            var halo = this.halo;
            var target = halo.target;
            var world = halo.world();
            var isMultiSelection = target instanceof __varRecorder__$5.MultiSelectionTarget;
            halo.remove();
            connect(hand, "update", this, "update");

            function findNewName(originalMorph, name) {
              if (!name.match(__varRecorder__$5.nameNumberRe)) return name + "1";
              return name.replace(__varRecorder__$5.nameNumberRe, function (_, name, num) {
                if (!num) num = "0";
                var n = Number(num);

                while (originalMorph.get(name + ++n)) {}

                return name + n;
              });
            }

            if (isMultiSelection) {
              var copies = compact(target.selectedMorphs.map(function (ea) {
                if (ea.canBeCopied()) {
                  var copy = ea.copy(true);
                  world.addMorph(copy);
                  return copy;
                }
              }));
              var positions = copies.map(function (ea) {
                ea.name = findNewName(target, ea.name);
                return ea.position;
              });
              copies[0].undoStart("copy-halo");
              world.addMorph(halo);
              halo.refocus(copies);
              hand.grab(halo.target);
              halo.target.onGrab({
                halo: halo,
                hand: hand,
                isShiftDown: function isShiftDown() {
                  return false;
                }
              });
              positions.forEach(function (pos, i) {
                return copies[i].globalPosition = pos;
              });
              halo.alignWithTarget();
            } else {
              var pos = target.globalPosition;
              var copy;

              if (target.isComponent && target._changeTracker) {
                copy = part(target._changeTracker.componentPolicy);
              } else {
                copy = target.copy(true);
              }

              copy.name = findNewName(target, target.name);
              world.addMorph(copy);
              copy.globalPosition = pos;
              copy.undoStart("copy-halo");
              hand.grab(copy);
              world.addMorph(halo);
              halo.visible = false;
            }
          }
        }, {
          key: "stop",
          value: function CopyHaloItem_stop_(hand) {
            var halo = this.halo;

            var _hand$grabbedMorphs = _slicedToArray(hand.grabbedMorphs, 1),
                copy = _hand$grabbedMorphs[0];

            var dropTarget = hand.findDropTarget(hand.globalPosition, [halo.target], function (m) {
              return !m.isHaloItem && !m.ownerChain().some(function (m) {
                return m.isHaloItem;
              });
            });
            var undo = halo.target.undoInProgress;
            disconnect(hand, "update", this, "update");
            undo.addTarget(dropTarget);
            hand.dropMorphsOn(dropTarget);
            halo.target.undoStop("copy-halo");
            halo.remove();
            hand.world().showHaloFor(copy);
          }
        }, {
          key: "onDragStart",
          value: function CopyHaloItem_onDragStart_(evt) {
            this.init(evt.hand);
          }
        }, {
          key: "onDragEnd",
          value: function CopyHaloItem_onDragEnd_(evt) {
            this.stop(evt.hand);
          }
        }, {
          key: "update",
          value: function CopyHaloItem_update_() {
            this.halo.alignWithTarget();
          }
        }, {
          key: "copyToClipBoard",
          value: function () {
            var _CopyHaloItem_copyToClipBoard_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
              var halo, t, world, isMultiSelection, origin, morphsToCopy, modifiedMorphsToCopy, snapshots, html, _iterator2, _step2, m, snap, data;

              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      halo = this.halo;

                      if (!halo.nameHalo().nameHolders.find(function (nh) {
                        return nh.nameHolder === $world.focusedMorph;
                      })) {
                        _context8.next = 3;
                        break;
                      }

                      return _context8.abrupt("return");

                    case 3:
                      t = halo.target;
                      world = halo.world();
                      isMultiSelection = t instanceof __varRecorder__$5.MultiSelectionTarget;
                      origin = t.globalBounds().topLeft();
                      morphsToCopy = isMultiSelection ? t.selectedMorphs : [t];
                      _context8.next = 10;
                      return Promise.all(morphsToCopy.filter(function (morph) {
                        return !morph.isCommentIndicator;
                      }).map( /*#__PURE__*/function () {
                        var _ref17 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(morph) {
                          var cp;
                          return regeneratorRuntime.wrap(function _callee7$(_context7) {
                            while (1) {
                              switch (_context7.prev = _context7.next) {
                                case 0:
                                  cp = morph.copy(true);
                                  _context7.next = 3;
                                  return Promise.all(cp.withAllSubmorphsDo(function (m) {
                                    if (m.master) {
                                      m.master.applyIfNeeded();
                                      return m.master.whenApplied();
                                    }
                                  }));

                                case 3:
                                  return _context7.abrupt("return", cp);

                                case 4:
                                case "end":
                                  return _context7.stop();
                              }
                            }
                          }, _callee7);
                        }));

                        return function (_x2) {
                          return _ref17.apply(this, arguments);
                        };
                      }()));

                    case 10:
                      modifiedMorphsToCopy = _context8.sent;
                      snapshots = [];
                      html = "<!DOCTYPE html>\n          <html lang=\"en\">\n          <head>\n            <meta charset=\"utf-8\">\n            ".concat(document.querySelector("#lively-morphic-css").outerHTML, "\n          </head>\n          <body>");
                      halo.remove();
                      _context8.prev = 14;
                      _iterator2 = _createForOfIteratorHelper(modifiedMorphsToCopy);
                      _context8.prev = 16;

                      _iterator2.s();

                    case 18:
                      if ((_step2 = _iterator2.n()).done) {
                        _context8.next = 28;
                        break;
                      }

                      m = _step2.value;
                      _context8.next = 22;
                      return createMorphSnapshot(m, {
                        addPreview: false,
                        testLoad: false,
                        moduleManager: modules
                      });

                    case 22:
                      snap = _context8.sent;
                      snap.copyMeta = {
                        offset: m.worldPoint(pt(0, 0)).subPt(origin)
                      };
                      snapshots.push(snap);
                      html += m.renderPreview();

                    case 26:
                      _context8.next = 18;
                      break;

                    case 28:
                      _context8.next = 33;
                      break;

                    case 30:
                      _context8.prev = 30;
                      _context8.t0 = _context8["catch"](16);

                      _iterator2.e(_context8.t0);

                    case 33:
                      _context8.prev = 33;

                      _iterator2.f();

                      return _context8.finish(33);

                    case 36:
                      html += "</body></html>";
                      data = JSON.stringify(snapshots);
                      _context8.next = 40;
                      return this.env.eventDispatcher.doCopyWithMimeTypes([{
                        type: "text/html",
                        data: html
                      }, {
                        type: "application/morphic",
                        data: data
                      }]);

                    case 40:
                      _context8.next = 46;
                      break;

                    case 42:
                      _context8.prev = 42;
                      _context8.t1 = _context8["catch"](14);
                      world.logError(_context8.t1);
                      return _context8.abrupt("return");

                    case 46:
                      world.addMorph(halo);
                      halo.refocus(morphsToCopy);
                      halo.setStatusMessage("copied");

                    case 49:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, this, [[14, 42], [16, 30, 33, 36]]);
            }));

            function CopyHaloItem_copyToClipBoard_() {
              return _CopyHaloItem_copyToClipBoard_.apply(this, arguments);
            }

            return CopyHaloItem_copyToClipBoard_;
          }()
        }, {
          key: "onMouseUp",
          value: function () {
            var _CopyHaloItem_onMouseUp_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(evt) {
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      evt.stop();
                      _context9.next = 3;
                      return this.copyToClipBoard();

                    case 3:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, this);
            }));

            function CopyHaloItem_onMouseUp_(_x3) {
              return _CopyHaloItem_onMouseUp_.apply(this, arguments);
            }

            return CopyHaloItem_onMouseUp_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "CopyHaloItem";
          }
        }, {
          key: "morphName",
          get: function get() {
            return "copy";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              draggable: {
                defaultValue: true
              },
              tooltip: {
                defaultValue: "Copy morph"
              }
            };
          }
        }, {
          key: "label",
          value: function CopyHaloItem_label_() {
            return __varRecorder__$5.RoundHaloItem.makeLabel("clone", {
              fontWeight: "400"
            });
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 43973,
          end: 48545
        });
      })(__varRecorder__$5.RoundHaloItem);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("OriginHaloItem") && typeof __lively_classholder__.OriginHaloItem === "function" ? __lively_classholder__.OriginHaloItem : __lively_classholder__.OriginHaloItem = function OriginHaloItem(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "fill",
          get: function get() {
            return Color.white.interpolate(0.2, this.borderColorTop);
          }
        }, {
          key: "extent",
          get: function get() {
            return pt(15, 15);
          }
        }, {
          key: "tooltip",
          get: function get() {
            return "Change the morph's origin";
          }
        }, {
          key: "computePositionAtTarget",
          value: function OriginHaloItem_computePositionAtTarget_() {
            var topLeft = this.halo.target.globalPosition;
            return this.halo.localize(topLeft);
          }
        }, {
          key: "alignInHalo",
          value: function OriginHaloItem_alignInHalo_() {
            this.visible = !this.halo.hasTinyTarget;
            this.center = this.computePositionAtTarget();
          }
        }, {
          key: "valueForPropertyDisplay",
          value: function OriginHaloItem_valueForPropertyDisplay_() {
            return this.halo.target.origin;
          }
        }, {
          key: "init",
          value: function OriginHaloItem_init_() {
            this.halo.target.undoStart("origin-halo");
            this.halo.state.activeButton = this;
          }
        }, {
          key: "stop",
          value: function OriginHaloItem_stop_() {
            this.halo.target.undoStop("origin-halo");
            this.halo.state.activeButton = null;
            this.halo.alignWithTarget();
          }
        }, {
          key: "update",
          value: function OriginHaloItem_update_(delta) {
            var halo = this.halo;
            var oldOrigin = halo.target.origin;
            var globalOrigin = halo.target.worldPoint(oldOrigin);
            var newOrigin = halo.target.localize(globalOrigin.addPt(delta)).subPt(halo.target.scroll);
            delta = newOrigin.subPt(oldOrigin);
            this.withMetaDo({
              reconcileChanges: true
            }, function () {
              halo.target.adjustOrigin(halo.target.origin.addPt(delta));
            });
          }
        }, {
          key: "onDragStart",
          value: function OriginHaloItem_onDragStart_(evt) {
            this.init();
          }
        }, {
          key: "onDragEnd",
          value: function OriginHaloItem_onDragEnd_(evt) {
            this.stop();
          }
        }, {
          key: "onDrag",
          value: function OriginHaloItem_onDrag_(evt) {
            this.update(evt.state.dragDelta);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "OriginHaloItem";
          }
        }, {
          key: "morphName",
          get: function get() {
            return "origin";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              borderWidth: {
                defaultValue: 3
              },
              nativeCursor: {
                defaultValue: "-webkit-grab"
              },
              draggable: {
                defaultValue: true
              },
              borderColor: {
                after: ["halo"],
                initialize: function initialize() {
                  this.borderColor = __varRecorder__$5.getColorForTarget(this.halo.target);
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 48547,
          end: 50252
        });
      })(__varRecorder__$5.HaloItem);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ResizeHandle") && typeof __lively_classholder__.ResizeHandle === "function" ? __lively_classholder__.ResizeHandle : __lively_classholder__.ResizeHandle = function ResizeHandle(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "valueForPropertyDisplay",
          value: function ResizeHandle_valueForPropertyDisplay_() {
            if (this.halo.target._responsiveHalo) return;
            var _this$halo$target$ext = this.halo.target.extent,
                width = _this$halo$target$ext.x,
                height = _this$halo$target$ext.y;
            return "".concat(width.toFixed(1), "x").concat(height.toFixed(1));
          }
        }, {
          key: "positionInHalo",
          value: function ResizeHandle_positionInHalo_() {
            var bounds = this.halo.borderBox.bounds();

            if (this.halo.hasTinyTarget) {
              if (Rectangle.prototype.sides.includes(this.location)) this.visible = false;
              bounds = bounds.insetBy(-4);
            }

            return bounds.partNamed(this.location);
          }
        }, {
          key: "alignInHalo",
          value: function ResizeHandle_alignInHalo_() {
            this.center = this.positionInHalo();
            return this;
          }
        }, {
          key: "onKeyUp",
          value: function ResizeHandle_onKeyUp_(evt) {
            if (this.halo.state.activeButton === this) {
              this.halo.toggleDiagonal(evt.isShiftDown(), this.corner);
            }
          }
        }, {
          key: "onKeyDown",
          value: function ResizeHandle_onKeyDown_(evt) {
            if (this.halo.state.activeButton === this) {
              this.halo.toggleDiagonal(evt.isShiftDown(), this.corner);
            }
          }
        }, {
          key: "onDragStart",
          value: function ResizeHandle_onDragStart_(evt) {
            this.init(evt.position, evt.isShiftDown());
          }
        }, {
          key: "onDragEnd",
          value: function ResizeHandle_onDragEnd_(evt) {
            this.stop(evt.isShiftDown());
          }
        }, {
          key: "onDrag",
          value: function ResizeHandle_onDrag_(evt) {
            this.update(evt.position, evt.isShiftDown(), evt.isAltDown(), evt.isCtrlDown());
            this.focus();
          }
        }, {
          key: "init",
          value: function ResizeHandle_init_(startPos) {
            var proportional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var _this$halo$target = this.halo.target,
                origin = _this$halo$target.origin,
                position = _this$halo$target.position,
                extent = _this$halo$target.extent;
            this.startPos = startPos;
            this.startBounds = position.subPt(origin).extent(extent);
            this.startOrigin = this.halo.target.origin;
            this.halo.state.activeButton = this;
            this.tfm = this.halo.target.getGlobalTransform().inverse();
            var globalRot = this.halo.target.getGlobalTransform().getRotation();
            this.offsetRotation = toRadians(globalRot % 45);
            this.halo.toggleDiagonal(proportional, this.corner);
          }
        }, {
          key: "update",
          value: function ResizeHandle_update_(currentPos) {
            var _this12 = this;

            var shiftDown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var altDown = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var ctrlDown = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            var corner = this.corner,
                tfm = this.tfm,
                startPos = this.startPos;

            var _startPos$subPt = startPos.subPt(currentPos),
                x = _startPos$subPt.x,
                y = _startPos$subPt.y;

            var delta = tfm.transformDirection(pt(x, y));

            if (altDown) {
              delta = delta.griddedBy(pt(10, 10));
            }

            this.halo.updateBoundsFor(corner, shiftDown, delta, this.startBounds, this.startOrigin);
            this.halo.toggleDiagonal(shiftDown, corner);
            this.updateAlignmentGuide(altDown);
            var sides = [];
            var cl = corner.toLowerCase();
            if (cl.includes("left")) sides.push("left");
            if (cl.includes("top")) sides.push("top");
            if (cl.includes("bottom")) sides.push("bottom");
            if (cl.includes("right")) sides.push("right");
            this.withMetaDo({
              reconcileChanges: true
            }, function () {
              showAndSnapToResizeGuides(_this12.halo.target, sides, true, ctrlDown, 5, 200);
            });
          }
        }, {
          key: "stop",
          value: function ResizeHandle_stop_(proportional) {
            var h = this.halo;
            h.state.activeButton = null;
            h.alignWithTarget();
            h.toggleDiagonal(false);
            this.updateAlignmentGuide(false);
            removeSnapToGuidesOf(h.target);
          }
        }, {
          key: "updateAlignmentGuide",
          value: function ResizeHandle_updateAlignmentGuide_(active) {
            var mesh = this.halo.getSubmorphNamed("mesh");

            if (!active) {
              mesh && mesh.remove();
              return;
            }

            var _this$halo$target$ext2 = this.halo.target.extent,
                x = _this$halo$target$ext2.x,
                y = _this$halo$target$ext2.y;
            var offset = pt(x % 10, y % 10);
            mesh = this.halo.getMesh(this.globalPosition.addPt(this.extent.scaleBy(0.5)), offset);
            this.focus();
            return mesh;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ResizeHandle";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              corner: {},
              location: {},
              draggable: {
                defaultValue: true
              },
              isResizeHandle: {
                readOnly: true,
                get: function get() {
                  return true;
                }
              }
            };
          }
        }, {
          key: "getResizeParts",
          value: function ResizeHandle_getResizeParts_(rotation) {
            if (rotation > 0) rotation = rotation - 360;
            var offset = -8 - (rotation / 45).toFixed();
            if (offset === 0) offset = 8;
            return zip(rotate([["topLeft", function (delta) {
              return delta.negated();
            }], ["topCenter", function (delta) {
              return delta.withX(0).negated();
            }], ["topRight", function (delta) {
              return delta.withX(0).negated();
            }], ["rightCenter", function (delta) {
              return pt(0, 0);
            }], ["bottomRight", function (delta) {
              return pt(0, 0);
            }], ["bottomCenter", function (delta) {
              return pt(0, 0);
            }], ["bottomLeft", function (delta) {
              return delta.withY(0).negated();
            }], ["leftCenter", function (delta) {
              return delta.withY(0).negated();
            }]], offset), [["nwse-resize", "topLeft"], ["ns-resize", "topCenter"], ["nesw-resize", "topRight"], ["ew-resize", "rightCenter"], ["nwse-resize", "bottomRight"], ["ns-resize", "bottomCenter"], ["nesw-resize", "bottomLeft"], ["ew-resize", "leftCenter"]]);
          }
        }, {
          key: "resizersFor",
          value: function ResizeHandle_resizersFor_(halo) {
            var _this13 = this;

            if (!halo.target) return [];
            var globalRot = halo.target.getGlobalTransform().getRotation();
            return compact(this.getResizeParts(globalRot).map(function (_ref18) {
              var _ref19 = _slicedToArray(_ref18, 2),
                  _ref19$ = _slicedToArray(_ref19[0], 3),
                  corner = _ref19$[0];
                  _ref19$[1];
                  _ref19$[2];
                  var _ref19$2 = _slicedToArray(_ref19[1], 2),
                  nativeCursor = _ref19$2[0],
                  location = _ref19$2[1];

              return _this13["for"](halo, corner, location, nativeCursor);
            })).map(function (h) {
              return h.alignInHalo();
            });
          }
        }, {
          key: "for",
          value: function ResizeHandle_for_(halo, corner, location, nativeCursor) {
            var name = "Resize " + corner;
            var resizerSize = 10;
            var resizer = halo.getSubmorphNamed(name) || new this({
              name: name,
              halo: halo,
              corner: corner,
              tooltip: "Resize " + decamelize(corner.replace("Center", "")),
              extent: pt(resizerSize, resizerSize),
              borderWidth: 1,
              borderRadius: 0,
              borderColor: __varRecorder__$5.getColorForTarget(halo.target),
              fill: Color.white
            });

            if (corner === "topCenter" || corner === "bottomCenter") {
              resizer.width = halo.borderBox.width - resizerSize;
              resizer.opacity = 0;
            }

            if (corner === "rightCenter" || corner === "leftCenter") {
              resizer.height = halo.borderBox.height - resizerSize;
              resizer.opacity = 0;
            }

            return Object.assign(resizer, {
              nativeCursor: nativeCursor,
              location: location
            });
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 50311,
          end: 56086
        });
      })(__varRecorder__$5.HaloItem);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("MenuHaloItem") && typeof __lively_classholder__.MenuHaloItem === "function" ? __lively_classholder__.MenuHaloItem : __lively_classholder__.MenuHaloItem = function MenuHaloItem(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onMouseDown",
          value: function () {
            var _MenuHaloItem_onMouseDown_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(evt) {
              var target, menuItems;
              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      target = this.halo.target;
                      this.halo.remove();
                      _context10.next = 4;
                      return target.menuItems(evt);

                    case 4:
                      menuItems = _context10.sent;
                      target.world().openMenu(menuItems).hasFixedPosition = this.halo.hasFixedPosition;

                    case 6:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, this);
            }));

            function MenuHaloItem_onMouseDown_(_x4) {
              return _MenuHaloItem_onMouseDown_.apply(this, arguments);
            }

            return MenuHaloItem_onMouseDown_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "MenuHaloItem";
          }
        }, {
          key: "morphName",
          get: function get() {
            return "menu";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              draggable: {
                defaultValue: false
              },
              tooltip: {
                defaultValue: "Opens the morph menu"
              }
            };
          }
        }, {
          key: "label",
          value: function MenuHaloItem_label_() {
            return __varRecorder__$5.RoundHaloItem.makeLabel("bars");
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 56088,
          end: 56629
        });
      })(__varRecorder__$5.RoundHaloItem);

      var InteractiveMorphSelector = exports('a0', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("InteractiveMorphSelector") && typeof __lively_classholder__.InteractiveMorphSelector === "function" ? __lively_classholder__.InteractiveMorphSelector : __lively_classholder__.InteractiveMorphSelector = function InteractiveMorphSelector(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function InteractiveMorphSelector_initialize_() {
            var world = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $world;
            var controllingMorph = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var filterFn = arguments.length > 2 ? arguments[2] : undefined;
            this.controllingMorph = controllingMorph;
            this.selectorMorph = null;
            this.morphHighlighter = null;
            this.possibleTarget = null;
            this.world = world;
            this.filterFn = filterFn;
            this.whenDone = null;
          }
        }, {
          key: "selectNewTarget",
          value: function InteractiveMorphSelector_selectNewTarget_() {
            this.targetObject = null;
            var deferred$1 = deferred();
            deferred$1.promise.resolve = deferred$1.resolve;
            this.whenDone = deferred$1.promise;
            this.selectorMorph = Icon.makeLabel("crosshairs", {
              fontSize: 20,
              hasFixedPosition: true,
              epiMorph: true
            }).openInWorld();
            connect(this.world.firstHand, "position", this, "scanForTargetAt");
            once$1(this.selectorMorph, "onMouseUp", this, "selectTarget");
            once$1(this.selectorMorph, "onKeyDown", this, "stopSelect");
            this.selectorMorph.focus();
            this.scanForTargetAt(this.world.firstHand.position);
          }
        }, {
          key: "scanForTargetAt",
          value: function InteractiveMorphSelector_scanForTargetAt_() {
            var pos = this.world.firstHand.globalPosition;
            this.selectorMorph.center = pos;
            this.selectorMorph.focus();
            var target = this.selectorMorph.morphBeneath(pos);
            var hiddenMorph;
            var possibleTarget = this.possibleTarget,
                controllingMorph = this.controllingMorph,
                filterFn = this.filterFn,
                world = this.world,
                morphHighlighter = this.morphHighlighter;

            if (morphHighlighter === target) {
              target = morphHighlighter.morphBeneath(pos);
            } else if (target && target.isEpiMorph) {
              target = target.morphBeneath(pos);
            }

            while (target && (hiddenMorph = [target].concat(_toConsumableArray$1(target.ownerChain())).find(function (m) {
              return !m.visible;
            }))) {
              target = hiddenMorph = hiddenMorph.morphBeneath(pos);
            }

            if (target && filterFn && !filterFn(target)) {
              while (target && ![target].concat(_toConsumableArray$1(target.ownerChain())).find(filterFn)) {
                target = target.morphBeneath(pos);
              }
            }

            if (!target) return;

            if (target !== possibleTarget && (!controllingMorph || !target.ownerChain().includes(controllingMorph.getWindow()))) {
              if (morphHighlighter) morphHighlighter.deactivate();
              this.possibleTarget = possibleTarget = target;

              if (possibleTarget && !possibleTarget.isWorld) {
                var h = this.morphHighlighter = __varRecorder__$5.MorphHighlighter["for"](world, target);

                h && h.show();
              }
            }
          }
        }, {
          key: "selectTarget",
          value: function InteractiveMorphSelector_selectTarget_() {
            this.targetObject = this.possibleTarget;
            this.stopSelect();
          }
        }, {
          key: "stopSelect",
          value: function InteractiveMorphSelector_stopSelect_() {
            __varRecorder__$5.MorphHighlighter.removeHighlighters(this.world);

            disconnect(this.world.firstHand, "position", this, "scanForTargetAt");
            this.selectorMorph.remove();
            this.whenDone && this.whenDone.resolve(this.targetObject);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "InteractiveMorphSelector";
          }
        }, {
          key: "selectMorph",
          value: function InteractiveMorphSelector_selectMorph_(world, controllingMorph, filterFn) {
            var sel = new this(world, controllingMorph, filterFn);
            sel.selectNewTarget();
            return sel.whenDone;
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 56638,
          end: 59393
        });
      }(undefined));
      __varRecorder__$5.InteractiveMorphSelector = InteractiveMorphSelector;
      __varRecorder__$5.InteractiveMorphSelector = InteractiveMorphSelector;

      var Halo = exports('U', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/morph.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("Halo") && typeof __lively_classholder__.Halo === "function" ? __lively_classholder__.Halo : __lively_classholder__.Halo = function Halo(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "relayout",
          value: function Halo_relayout_() {
            this.alignWithTarget();
          }
        }, {
          key: "keybindings",
          get: function get() {
            return [{
              keys: {
                mac: "Meta-C",
                win: "Ctrl-C"
              },
              command: {
                command: "clipboard copy",
                passEvent: true
              }
            }];
          }
        }, {
          key: "commands",
          get: function get() {
            return [{
              name: "clipboard copy",
              doc: "copy selected morph(s) to clipboard",
              scrollCursorIntoView: false,
              exec: function exec(halo) {
                halo.copyHalo().copyToClipBoard();
              }
            }];
          }
        }, {
          key: "removeIfDetached",
          value: function Halo_removeIfDetached_(newOwner) {
            var _this$target$undoInPr,
                _this14 = this;

            var isGrabAction = ((_this$target$undoInPr = this.target.undoInProgress) === null || _this$target$undoInPr === void 0 ? void 0 : _this$target$undoInPr.name) === "grab-halo";
            setTimeout(function () {
              if (isGrabAction) {
                return;
              }

              if (!newOwner || !_this14.target.owner) _this14.remove();
            });
          }
        }, {
          key: "initLayout",
          value: function Halo_initLayout_() {
            var layout = this.layout = new GridLayout({
              autoAssign: false,
              fitToCell: false,
              renderViaCSS: true,
              columns: [0, {
                fixed: 36,
                paddingRight: 10
              }, 2, {
                fixed: 26
              }, 4, {
                fixed: 26
              }, 6, {
                fixed: 36,
                paddingLeft: 10
              }],
              rows: [0, {
                fixed: 36,
                paddingBottom: 10
              }, 2, {
                fixed: 26
              }, 4, {
                fixed: 26
              }, 6, {
                fixed: 26
              }, 7, {
                fixed: 36,
                paddingTop: 10
              }],
              grid: [["menu", null, "grab", null, "drag", null, "close"], [null, null, null, null, null, null, null], ["copy", null, null, null, null, null, "edit"], [null, null, null, null, null, null, null], ["component", null, null, null, null, null, "inspect"], [null, null, null, null, null, null, null], ["rotate", null, null, null, null, null, "responsive"], [null, "name", "name", "name", "name", "name", null]]
            });
            layout.col(1).row(7).group.align = "topCenter";
            layout.col(1).row(7).group.resize = false;
          }
        }, {
          key: "initButtons",
          value: function Halo_initButtons_() {
            this.submorphs = [].concat(_toConsumableArray$1(this.ensureResizeHandles()), _toConsumableArray$1(this.resizeOnly ? [] : [this.closeHalo(), this.dragHalo(), this.grabHalo(), this.menuHalo(), this.inspectHalo(), this.editHalo(), this.copyHalo(), this.componentHalo(), this.responsiveHalo(), this.rotateHalo(), this.nameHalo(), this.originHalo()]));
          }
        }, {
          key: "isEpiMorph",
          get: function get() {
            return true;
          }
        }, {
          key: "isHaloItem",
          get: function get() {
            return true;
          }
        }, {
          key: "isHalo",
          get: function get() {
            return true;
          }
        }, {
          key: "borderBox",
          get: function get() {
            return this.getSubmorphNamed("border-box") || this.addMorphBack(morph({
              name: "border-box",
              halosEnabled: false,
              reactsToPointer: false,
              fill: Color.transparent,
              borderColor: __varRecorder__$5.getColorForTarget(this.target),
              borderWidth: 1
            }));
          }
        }, {
          key: "pointerId",
          get: function get() {
            return this.state ? this.state.pointerId : null;
          }
        }, {
          key: "pointerId",
          set: function set(p) {
            if (!this.state) this.state = {};
            this.state.pointerId = p;
          }
        }, {
          key: "prepareTarget",
          value: function Halo_prepareTarget_(target) {
            if (!isArray$2(target)) return target;
            if (target.length <= 1) return target[0];
            target = target[0].world().addMorph(new __varRecorder__$5.MultiSelectionTarget({
              selectedMorphs: target
            }));
            target.alignWithSelection();
            target.modifiesSelectedMorphs = true;
            return target;
          }
        }, {
          key: "refocus",
          value: function Halo_refocus_(newTarget) {
            this.target = newTarget;
            this.alignWithTarget();
          }
        }, {
          key: "alignWithTarget",
          value: function Halo_alignWithTarget_(change) {
            var _this15 = this;

            if (change && !["extent", "position", "scale", "rotation"].includes(change.prop)) {
              return;
            }

            if (this.active || !this.target) return;
            var world = this.target.world() || $world;
            var worldBounds = this.maskBounds;
            var targetBounds = this.target.globalBounds();
            var haloBounds = targetBounds.insetBy(-36).intersection(worldBounds);
            var boxBounds = targetBounds.intersection(worldBounds);
            this.setBounds(haloBounds.translatedBy(world.scroll.negated()));
            this.borderBox.setBounds($world.transformRectToMorph(this, boxBounds));
            if (!this.resizeOnly) this.originHalo().alignInHalo();
            this.nameHalo().alignInHalo();

            if (this.state.activeButton) {
              this.buttonControls.forEach(function (ea) {
                return ea.visible = false;
              });
              this.ensureResizeHandles().forEach(function (h) {
                return h.visible = false;
              });
              this.state.activeButton.visible = true;
              this.updatePropertyDisplay(this.state.activeButton);
            } else {
              if (this.changingName) this.nameHalo().toggleActive([false]);
              this.ensureResizeHandles().forEach(function (h) {
                return h.visible = true;
              });
              this.buttonControls.filter(function (b) {
                if (_this15.activeItems.includes("*")) return true;else return _this15.activeItems.includes(b.name);
              }).forEach(function (b) {
                b.visible = true;
              });
              this.propertyDisplay.disable();
            }

            this.responsiveHalo().visible = !!this.target.master && this.responsiveHalo().visible;
            this.ensureResizeHandles().forEach(function (h) {
              return h.alignInHalo();
            });
            return this;
          }
        }, {
          key: "detachFromTarget",
          value: function Halo_detachFromTarget_() {
            var target = this.target;
            if (!target) return;
            disconnect(target, "onChange", this, "alignWithTarget");
            disconnect(target, "onOwnerChanged", this, "removeIfDetached");

            if (target instanceof __varRecorder__$5.MultiSelectionTarget) {
              target.modifiesSelectedMorphs = false;
              target.remove();
            } else if (typeof target.detachedHalo === "function") {
              target.detachedHalo(this);
            }
          }
        }, {
          key: "remove",
          value: function Halo_remove_() {
            this.detachFromTarget();
            signal($world, "onHaloRemoved");

            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "remove", this).call(this);
          }
        }, {
          key: "propertyDisplay",
          get: function get() {
            return __varRecorder__$5.HaloPropertyDisplay["for"](this);
          }
        }, {
          key: "nameHalo",
          value: function Halo_nameHalo_() {
            return __varRecorder__$5.NameHaloItem["for"](this);
          }
        }, {
          key: "closeHalo",
          value: function Halo_closeHalo_() {
            return __varRecorder__$5.CloseHaloItem["for"](this);
          }
        }, {
          key: "grabHalo",
          value: function Halo_grabHalo_() {
            return __varRecorder__$5.GrabHaloItem["for"](this);
          }
        }, {
          key: "dragHalo",
          value: function Halo_dragHalo_() {
            return __varRecorder__$5.DragHaloItem["for"](this);
          }
        }, {
          key: "menuHalo",
          value: function Halo_menuHalo_() {
            return __varRecorder__$5.MenuHaloItem["for"](this);
          }
        }, {
          key: "inspectHalo",
          value: function Halo_inspectHalo_() {
            return __varRecorder__$5.InspectHaloItem["for"](this);
          }
        }, {
          key: "editHalo",
          value: function Halo_editHalo_() {
            return __varRecorder__$5.EditHaloItem["for"](this);
          }
        }, {
          key: "rotateHalo",
          value: function Halo_rotateHalo_() {
            return __varRecorder__$5.RotateHaloItem["for"](this);
          }
        }, {
          key: "copyHalo",
          value: function Halo_copyHalo_() {
            return __varRecorder__$5.CopyHaloItem["for"](this);
          }
        }, {
          key: "originHalo",
          value: function Halo_originHalo_() {
            return __varRecorder__$5.OriginHaloItem["for"](this);
          }
        }, {
          key: "componentHalo",
          value: function Halo_componentHalo_() {
            return __varRecorder__$5.ComponentHaloItem["for"](this);
          }
        }, {
          key: "responsiveHalo",
          value: function Halo_responsiveHalo_() {
            return __varRecorder__$5.ResponsiveHaloItem["for"](this);
          }
        }, {
          key: "buttonControls",
          get: function get() {
            return this.submorphs.filter(function (m) {
              return m.isHaloItem && !m.isResizeHandle;
            });
          }
        }, {
          key: "addMorphToSelection",
          value: function () {
            var _Halo_addMorphToSelection_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(morph) {
              var world, currentTargets;
              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      world = this.world();
                      currentTargets = this.target.isMorphSelection ? this.target.selectedMorphs : [this.target];

                      if (!currentTargets.includes(morph)) {
                        _context11.next = 4;
                        break;
                      }

                      return _context11.abrupt("return");

                    case 4:
                      this.remove();
                      _context11.next = 7;
                      return world.showHaloForSelection([].concat(_toConsumableArray$1(currentTargets), [morph]), this.state.pointerId);

                    case 7:
                      return _context11.abrupt("return", _context11.sent);

                    case 8:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11, this);
            }));

            function Halo_addMorphToSelection_(_x5) {
              return _Halo_addMorphToSelection_.apply(this, arguments);
            }

            return Halo_addMorphToSelection_;
          }()
        }, {
          key: "removeMorphFromSelection",
          value: function () {
            var _Halo_removeMorphFromSelection_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(morph) {
              var world;
              return regeneratorRuntime.wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      world = this.world();
                      this.remove();

                      if (!this.target.isMorphSelection) {
                        _context12.next = 7;
                        break;
                      }

                      remove(this.target.selectedMorphs, morph);
                      _context12.next = 6;
                      return world.showHaloForSelection(this.target.selectedMorphs, this.state.pointerId);

                    case 6:
                      return _context12.abrupt("return", _context12.sent);

                    case 7:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12, this);
            }));

            function Halo_removeMorphFromSelection_(_x6) {
              return _Halo_removeMorphFromSelection_.apply(this, arguments);
            }

            return Halo_removeMorphFromSelection_;
          }()
        }, {
          key: "isAlreadySelected",
          value: function Halo_isAlreadySelected_(morph) {
            return this.target === morph || this.target.isMorphSelection && this.target.selectsMorph(morph);
          }
        }, {
          key: "updateBoundsFor",
          value: function Halo_updateBoundsFor_(corner, proportional, delta, bounds, origin) {
            var _this16 = this;

            var s = this.target.scale;
            var proportionalMask = {
              topLeft: Rectangle.inset(-s, -s, s - 1, s - 1),
              topCenter: proportional ? Rectangle.inset(s, -s, 2 - s, s - 1) : Rectangle.inset(0, -s, 0, s - 1),
              topRight: Rectangle.inset(0, -s, 1, s - 1),
              rightCenter: proportional ? rect(0, 1, 1, 1) : rect(0, 0, 1, 0),
              bottomRight: rect(0, 0, 1, 1),
              bottomCenter: proportional ? rect(1, 0, 0, 1) : rect(0, 0, 0, 1),
              bottomLeft: Rectangle.inset(-s, 0, s - 1, 1),
              leftCenter: proportional ? Rectangle.inset(-s, s, s - 1, 2 - s) : Rectangle.inset(-s, 0, s - 1, 0)
            };
            var _proportionalMask$cor = proportionalMask[corner],
                x = _proportionalMask$cor.x,
                y = _proportionalMask$cor.y,
                width = _proportionalMask$cor.width,
                height = _proportionalMask$cor.height;
            delta = proportional ? this.proportionalDelta(corner, delta, bounds) : delta;
            var offsetRect = rect(delta.x * x, delta.y * y, delta.x * width, delta.y * height);
            this.active = true;
            this.withMetaDo({
              reconcileChanges: true
            }, function () {
              if (_this16.targetIsPositionedByLayout) {
                _this16.target.extent = bounds.insetByRect(offsetRect).extent();
              } else {
                _this16.target.setBounds(bounds.insetByRect(offsetRect));

                if (_this16.target.isText) {
                  if (offsetRect.width) _this16.target.fixedWidth = true;
                  if (offsetRect.height) _this16.target.fixedHeight = true;
                }

                if (_this16.target.isPolygon || _this16.target.isPath) {
                  _this16.target.moveBy(_this16.target.origin.negated());
                }
              }
            });
            this.active = false;
            this.alignWithTarget();
            var world = this.world();

            if (world.activeSideBars.includes("properties panel")) {
              world.propertiesPanel.onHierarchyChange();
            }
          }
        }, {
          key: "proportionalDelta",
          value: function Halo_proportionalDelta_(corner, delta, bounds) {
            var width = bounds.width,
                height = bounds.height;
            var diagonals = {
              topLeft: pt(-1, -1),
              topCenter: pt(0, -1),
              topRight: pt(1, -1),
              leftCenter: pt(-1, 0),
              rightCenter: pt(1, 0),
              bottomLeft: pt(-1, 1),
              bottomCenter: pt(0, 1),
              bottomRight: pt(1, 1)
            };
            var w = width / Math.max(width, height);
            var h = height / Math.max(height, width);
            var gradients = {
              topLeft: pt(-w, -h),
              topCenter: pt(1 / (2 * height / width), -1),
              topRight: pt(w, -h),
              leftCenter: pt(-1, height / (2 * width)),
              rightCenter: pt(1, height / (3 * width)),
              bottomLeft: pt(-w, h),
              bottomCenter: pt(1 / (2 * height / width), 1),
              bottomRight: pt(w, h)
            };
            var diagonal = diagonals[corner];
            var gradient = gradients[corner];
            return gradient.scaleBy(diagonal.dotProduct(delta) / diagonal.dotProduct(diagonal));
          }
        }, {
          key: "ensureResizeHandles",
          value: function Halo_ensureResizeHandles_() {
            return __varRecorder__$5.ResizeHandle.resizersFor(this);
          }
        }, {
          key: "updatePropertyDisplay",
          value: function Halo_updatePropertyDisplay_(haloItem) {
            var val = haloItem.valueForPropertyDisplay();

            if (typeof val !== "undefined") {
              this.propertyDisplay.displayProperty(val);
            } else {
              this.propertyDisplay.disable();
            }
          }
        }, {
          key: "toggleDiagonal",
          value: function Halo_toggleDiagonal_(active, corner) {
            if (rect(0).sides.includes(corner)) return;
            var diagonal = this.getSubmorphNamed("diagonal");

            if (!active) {
              diagonal && diagonal.fadeOut(500);
              return;
            }

            var _this$target$globalBo = this.target.globalBounds(),
                x = _this$target$globalBo.x,
                y = _this$target$globalBo.y,
                width = _this$target$globalBo.width,
                height = _this$target$globalBo.height;

            var bounds = this.localize(pt(x, y)).extent(pt(width, height)).scaleRectTo(this.innerBounds());
            var vertices = {
              topLeft: [pt(width, height), pt(0, 0)],
              topRight: [pt(0, height), pt(width, 0)],
              bottomRight: [pt(0, 0), pt(width, height)],
              bottomLeft: [pt(width, 0), pt(0, height)]
            };

            if (diagonal) {
              diagonal.setBounds(bounds);
              return;
            }

            var _vertices$corner = _slicedToArray(vertices[corner], 2),
                v1 = _vertices$corner[0],
                v2 = _vertices$corner[1];

            var guideGradient = new LinearGradient({
              stops: [{
                offset: 0,
                color: Color.orange.withA(0)
              }, {
                offset: 0.2,
                color: Color.orange
              }, {
                offset: 0.8,
                color: Color.orange
              }, {
                offset: 1,
                color: Color.orange.withA(0)
              }]
            });
            diagonal = this.addMorphBack(new Path$1({
              opacity: 0,
              name: "diagonal",
              borderStyle: "dotted",
              borderWidth: 5,
              bounds: bounds,
              borderColor: guideGradient,
              vertices: [v1, v2]
            }));
            diagonal.setBounds(bounds);
            diagonal.animate({
              opacity: 1,
              duration: 500
            });
          }
        }, {
          key: "toggleRotationIndicator",
          value: function Halo_toggleRotationIndicator_(active, haloItem) {
            var _this17 = this;

            var rotationIndicator = this.getSubmorphNamed("rotationIndicator");

            if (!active || !haloItem) {
              rotationIndicator && rotationIndicator.remove();
              return;
            }

            var originPos = this.getSubmorphNamed("origin").center;

            var localize = function localize(p) {
              return rotationIndicator.localizePointFrom(p, _this17);
            };

            rotationIndicator = rotationIndicator || this.addMorphBack(new Path$1({
              name: "rotationIndicator",
              borderColor: __varRecorder__$5.haloBlue,
              borderWidth: 1,
              vertices: []
            }));
            rotationIndicator.setBounds(haloItem.bounds().union(this.innerBounds()));
            rotationIndicator.vertices = [localize(originPos), localize(haloItem.center)];
          }
        }, {
          key: "toggleMorphHighlighter",
          value: function Halo_toggleMorphHighlighter_(active, target) {
            var showLayout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            if (!target) return;

            if (target.onHaloGrabover) {
              target.onHaloGrabover(active);
              return;
            }

            var h = __varRecorder__$5.MorphHighlighter["for"](this, target, showLayout);

            if (active && target && target !== this.world()) h && h.show(target);else h && h.deactivate();
          }
        }, {
          key: "onDragStart",
          value: function Halo_onDragStart_(evt) {
            this.dragHalo().init();
            this._lastDragPos = evt.startPosition;
          }
        }, {
          key: "onDrag",
          value: function Halo_onDrag_(evt) {
            if (!this.world()) return;
            this.dragHalo().update(evt.state.dragDelta);
            this.dragHalo().visible = false;
          }
        }, {
          key: "onDragEnd",
          value: function Halo_onDragEnd_(evt) {
            this.dragHalo().stop();

            if (!this.target._responsiveHalo) {
              this.dragHalo().visible = true;
            }
          }
        }, {
          key: "customDrag",
          value: function Halo_customDrag_(evt) {
            if (!this.world()) return;
            this.dragHalo().update(evt.position.subPt(this._lastDragPos));
            this.dragHalo().visible = false;
            this._lastDragPos = evt.position;
          }
        }, {
          key: "onMouseDown",
          value: function Halo_onMouseDown_(evt) {
            var _this18 = this;

            var evtTarget = evt.state.clickedOnMorph;

            if (!evt.isCommandKey()) {
              if (evt.state.clickCount === 2 && this.target.isText) {
                if (this.target.editorModeName === null) this.target.addPlugin(new RichTextPlugin());
                this.target.execCommand("temporary edit text", evt);
                return;
              }
            }

            if (evt.isShiftDown() && evt.isCommandKey()) {
              var actualMorph = this.target.isMorphSelection ? this.target.morphBeneath(evt.position) : this.morphBeneath(evt.position);
              this.isAlreadySelected(actualMorph) ? this.removeMorphFromSelection(actualMorph) : this.addMorphToSelection(actualMorph);
              return;
            }

            if (evtTarget === this && evt.isCommandKey()) {
              var morphsBelow = evt.world.morphsContainingPoint(evt.position).filter(function (ea) {
                return ea.halosEnabled;
              });
              var morphsBelowHaloMorph = morphsBelow.slice(morphsBelow.indexOf(this.target) + 1);
              var newTarget = morphsBelowHaloMorph[0] || morphsBelow[0] || evt.world;
              newTarget && evt.world.showHaloFor(newTarget, evt.domEvt.pointerId);
              noUpdate(function () {
                return _this18.remove();
              });
            }

            if (evtTarget === this || evtTarget && !evtTarget.isHaloItem && !this.nameHalo().nameHolders.includes(evtTarget.owner)) {
              if (![this.target].concat(_toConsumableArray$1(this.target.ownerChain())).includes(this.morphBeneath(evt.position))) {
                return noUpdate(function () {
                  return _this18.remove();
                });
              }
            }

            this.target.onHaloMouseDown(evt);
          }
        }, {
          key: "onContextMenu",
          value: function Halo_onContextMenu_(evt) {
            var _this19 = this;

            evt.stop();
            Promise.resolve($world.defaultMenuItems(this.target)).then(function (items) {
              return _this19.target.openMenu(items, evt);
            })["catch"](function (err) {
              return $world.logError(err);
            });
          }
        }, {
          key: "onKeyUp",
          value: function Halo_onKeyUp_(evt) {
            if (!this.changingName) {
              this.buttonControls.map(function (b) {
                return b.onKeyUp(evt);
              });
            }
          }
        }, {
          key: "onMouseWheel",
          value: function Halo_onMouseWheel_(evt) {
            var _evt$domEvt = evt.domEvt,
                deltaX = _evt$domEvt.deltaX,
                deltaY = _evt$domEvt.deltaY;
            this.world().scrollWorld(deltaX, deltaY);
          }
        }, {
          key: "indicateLooseMovement",
          value: function Halo_indicateLooseMovement_(active) {
            this.borderBox.borderStyle = active ? "dotted" : "solid";
          }
        }, {
          key: "discard",
          value: function Halo_discard_(aMorph) {
            if (aMorph.isComponent) {
              aMorph.remove();
              signal(aMorph, "stop editing");
            } else aMorph.abandon();
          }
        }, {
          key: "closeSession",
          value: function Halo_closeSession_() {
            var _this20 = this;

            var o = this.target.owner;
            o.undoStart("close-halo");
            this.withMetaDo({
              reconcileChanges: true
            }, function () {
              _this20.target.selectedMorphs ? _this20.target.selectedMorphs.forEach(function (m) {
                return _this20.discard(m);
              }) : _this20.discard(_this20.target);
            });
            o.undoStop("close-halo");
            var world = this.world();

            if (world.propertiesPanel) {
              world.propertiesPanel.clearFocus();
            }

            if (world.sceneGraph) {
              world.sceneGraph.clearFocus();
            }

            if (this.target.isComponent) {
              var _this$target$_changeT;

              (_this$target$_changeT = this.target._changeTracker) === null || _this$target$_changeT === void 0 ? void 0 : _this$target$_changeT.componentDescriptor.stopEditSession();
            }

            this.remove();
          }
        }, {
          key: "getMesh",
          value: function Halo_getMesh_(_ref20) {
            var x = _ref20.x,
                y = _ref20.y;
            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : pt(0, 0);

            var _this$world$visibleBo = this.world().visibleBounds(),
                height = _this$world$visibleBo.height,
                width = _this$world$visibleBo.width;

            var defaultGuideProps = {
              borderStyle: "dotted",
              borderWidth: 2,
              borderColor: Color.orange
            };
            var mesh = this.get("mesh") || this.addMorph(new Morph({
              name: "mesh",
              styleClasses: ["halo-mesh"],
              extent: pt(width, height),
              fill: null,
              submorphs: [new Path$1(Object.assign({
                name: "vertical"
              }, defaultGuideProps)), new Path$1(Object.assign({
                name: "horizontal"
              }, defaultGuideProps))]
            }));
            mesh.globalPosition = offset;
            mesh.getSubmorphNamed("vertical").vertices = [pt(x, 0).subPt(offset), pt(x, height).subPt(offset)];
            mesh.getSubmorphNamed("horizontal").vertices = [pt(0, y).subPt(offset), pt(width, y).subPt(offset)];
            return mesh;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "Halo";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              fill: {
                defaultValue: Color.transparent
              },
              resizeOnly: {
                defaultValue: false
              },
              pointerId: {},
              hasFixedPosition: {
                defaultValue: true
              },
              respondsToVisibleWindow: {
                defaultValue: true
              },
              acceptsDrops: {
                defaultValue: false
              },
              draggable: {
                defaultValue: true
              },
              maskBounds: {
                initialize: function initialize() {
                  this.maskBounds = $world.visibleBounds();
                },
                set: function set(b) {
                  this.setProperty("maskBounds", b);
                  this.relayout();
                }
              },
              activeItems: {
                derived: true,
                defaultValue: ["*"],
                set: function set(itemNames) {
                  this.setProperty("activeItems", itemNames);
                  this.buttonControls.forEach(function (b) {
                    return b.visible = itemNames.includes(b.name);
                  });
                }
              },
              submorphs: {
                after: ["target"],
                initialize: function initialize() {
                  this.initButtons();
                  this.alignWithTarget();
                }
              },
              layout: {
                after: ["submorphs"],
                initialize: function initialize() {
                  this.initLayout();
                }
              },
              hasTinyTarget: {
                derived: true,
                get: function get() {
                  return this.target.bounds().extent().dist(pt(0)) < 40;
                }
              },
              halosEnabled: {
                defaultValue: false
              },
              topBar: {
                serialize: false,
                get: function get() {
                  return this.getProperty("topBar") || this.get("lively top bar");
                }
              },
              targetIsPositionedByLayout: {
                derived: true,
                get: function get() {
                  return this.target.isLayoutable && Path("target.owner.layout.renderViaCSS").get(this);
                }
              },
              target: {
                get: function get() {
                  return this.state ? this.state.target : null;
                },
                set: function set(t) {
                  if (!this.state) this.state = {};
                  var isUpdate = !!this.state.target;
                  this.detachFromTarget();
                  t = this.prepareTarget(t);
                  this.state.target = t;
                  isUpdate && this.alignWithTarget();
                  epiConnect(t, "onChange", this, "alignWithTarget");
                  epiConnect(t, "onOwnerChanged", this, "removeIfDetached");
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./morph.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 59600,
          end: 79856
        });
      }({
        referencedAs: "Morph",
        value: Morph
      }));
      __varRecorder__$5["default"] = Halo;

      var __varRecorder__$4 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/layout.js", __contextModule__);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/layout.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ProportionSlider") && typeof __lively_classholder__.ProportionSlider === "function" ? __lively_classholder__.ProportionSlider : __lively_classholder__.ProportionSlider = function ProportionSlider(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "alignWithTarget",
          value: function ProportionSlider_alignWithTarget_() {
            this.setBounds(this.axis.getProportionSliderBounds(this));
          }
        }, {
          key: "onDragStart",
          value: function ProportionSlider_onDragStart_() {
            this.view.visible = true;
          }
        }, {
          key: "onDrag",
          value: function ProportionSlider_onDrag_(evt) {
            this.axis.adjustStretch(this.axis.getDelta(evt));
            this.axis.halo.alignWithTarget();
          }
        }, {
          key: "onDragEnd",
          value: function ProportionSlider_onDragEnd_() {
            this.view.visible = false;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ProportionSlider";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              axis: {},
              view: {},
              fill: {
                defaultValue: Color.transparent
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./layout.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 322,
          end: 807
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/layout.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("MinViewer") && typeof __lively_classholder__.MinViewer === "function" ? __lively_classholder__.MinViewer : __lively_classholder__.MinViewer = function MinViewer(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "alignWithTarget",
          value: function MinViewer_alignWithTarget_() {
            var min = this.axis.targetAxis.min;
            this.textString = "min: ".concat(min.toFixed(), "px !");
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "MinViewer";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              axis: {}
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./layout.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 809,
          end: 1031
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/layout.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("MinSlider") && typeof __lively_classholder__.MinSlider === "function" ? __lively_classholder__.MinSlider : __lively_classholder__.MinSlider = function MinSlider(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "alignWithTarget",
          value: function MinSlider_alignWithTarget_() {
            this.position = this.axis.getMinSliderPosition();
          }
        }, {
          key: "requestToShow",
          value: function MinSlider_requestToShow_() {
            this.visible = !this.axis.targetAxis.fixed;
          }
        }, {
          key: "requestToHide",
          value: function MinSlider_requestToHide_() {
            if (this.active) {
              this.shouldHide = true;
            } else {
              this.visible = false;
            }
          }
        }, {
          key: "onDragStart",
          value: function MinSlider_onDragStart_() {
            var _this$submorphs = _slicedToArray(this.submorphs, 2),
                minViewer = _this$submorphs[0],
                minSpaceVisualizer = _this$submorphs[1];

            this.axis.forceMenuHidden = true;
            minViewer.visible = true;
            minSpaceVisualizer.visible = true;
            this.active = true;
          }
        }, {
          key: "onDrag",
          value: function MinSlider_onDrag_(evt) {
            this.axis.targetAxis.min += -this.getDelta(evt);
            this.axis.halo.alignWithTarget();
          }
        }, {
          key: "onDragEnd",
          value: function MinSlider_onDragEnd_() {
            var _this$submorphs2 = _slicedToArray(this.submorphs, 2),
                minViewer = _this$submorphs2[0],
                minSpaceVisualizer = _this$submorphs2[1];

            this.axis.forceMenuHidden = false;
            minViewer.visible = false;
            minSpaceVisualizer.visible = false;
            this.active = false;

            if (this.shouldHide) {
              this.visible = false;
              this.shouldHide = false;
            }
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "MinSlider";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              axis: {},
              fill: {
                defaultValue: Color.green
              },
              visible: {
                defaultValue: false
              },
              becomesActiveOnHover: {
                defaultValue: true
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./layout.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 1033,
          end: 2190
        });
      })({
        referencedAs: "Ellipse",
        value: Ellipse
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/layout.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("AxisHalo") && typeof __lively_classholder__.AxisHalo === "function" ? __lively_classholder__.AxisHalo : __lively_classholder__.AxisHalo = function AxisHalo(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "initialize",
          value: function AxisHalo_initialize_() {
            this.setBounds(this.fetchBounds());
            var minSlider = this.minSlider();
            var axisMenu = this.axisMenu();
            var proportionSlider = this.proportionSlider();
            proportionSlider.addMorph(minSlider);
            this.submorphs = [proportionSlider, axisMenu];
            this.halo.addGuide(this);
          }
        }, {
          key: "forceMenuHidden",
          set: function set(hidden) {
            this._forceMenuHidden = hidden;
            this.axisMenu.visible = !hidden;
          }
        }, {
          key: "forceMenuHidden",
          get: function get() {
            return this._forceMenuHidden;
          }
        }, {
          key: "lastAxis",
          get: function get() {
            return !this.targetAxis.after;
          }
        }, {
          key: "fetchBounds",
          value: function AxisHalo_fetchBounds_() {
            return this.fetchPosition().extent(this.fetchExtent());
          }
        }, {
          key: "alignWithTarget",
          value: function AxisHalo_alignWithTarget_() {
            this.extent = this.fetchExtent();
            this.position = this.fetchPosition();
            this.proportionSlider.alignWithTarget();
            this.axisMenu.alignWithTarget();
          }
        }, {
          key: "onHoverIn",
          value: function AxisHalo_onHoverIn_() {
            this.minSlider.requestToShow();
            this.axisMenu.visible = !this.forceMenuHidden && true;
          }
        }, {
          key: "onHoverOut",
          value: function AxisHalo_onHoverOut_(evt) {
            this.minSlider.requestToHide();
            this.axisMenu.visible = this.forceMenuVisible || false;
          }
        }, {
          key: "proportionSlider",
          value: function AxisHalo_proportionSlider_() {
            var proportionViewer = this.proportionViewer();
            return this.halo.addGuide(new __varRecorder__$4.ProportionSlider({
              nativeCursor: this.getResizeCursor(),
              axis: this,
              view: proportionViewer,
              submorphs: [this.devider(), proportionViewer]
            }));
          }
        }, {
          key: "devider",
          value: function AxisHalo_devider_() {
            return new Morph({
              visible: !this.lastAxis,
              fill: Color.black.withA(0.5),
              bounds: this.getDeviderBounds(),
              draggable: false,
              reactsToPointer: false
            });
          }
        }, {
          key: "minSlider",
          value: function AxisHalo_minSlider_() {
            var minSpaceVisualizer = this.minSpaceVisualizer();
            var minViewer = this.minViewer();
            return this.halo.addGuide(new __varRecorder__$4.MinSlider({
              nativeCursor: this.getResizeCursor(),
              axis: this,
              submorphs: [minSpaceVisualizer, minViewer]
            }));
          }
        }, {
          key: "minViewer",
          value: function AxisHalo_minViewer_() {
            return this.viewer(new __varRecorder__$4.MinViewer({
              axis: this,
              position: this.getMinViewerPosition()
            }));
          }
        }, {
          key: "minSpaceBorder",
          value: function AxisHalo_minSpaceBorder_() {
            return new Path$1(Object.assign({
              position: pt(-1, -1),
              borderStyle: "dashed",
              borderColor: Color.green,
              borderWidth: 2
            }, this.getMinSpaceBorder()));
          }
        }, {
          key: "minSpaceVisualizer",
          value: function AxisHalo_minSpaceVisualizer_() {
            var self = this;
            var minSpaceBorder = this.minSpaceBorder();
            return this.halo.addGuide(new Morph({
              fill: Color.green.withA(0.1),
              visible: false,
              isHaloItem: true,
              submorphs: [minSpaceBorder],
              alignWithTarget: function alignWithTarget() {
                this.extent = self.getMinSpaceExtent();
                this.topLeft = pt(5, 5);
              }
            }));
          }
        }, {
          key: "axisMenu",
          value: function AxisHalo_axisMenu_() {
            var lockButton = this.lockButton();
            var menuButton = this.menuButton();
            var self = this;
            return new Morph({
              layout: this.getMenuLayout(),
              submorphs: [lockButton, menuButton],
              fill: Color.transparent,
              visible: false,
              becomesActiveOnHover: true,
              alignWithTarget: function alignWithTarget() {
                this.bottomRight = this.owner.extent.subPt(self.getMenuOffset(this));
              }
            });
          }
        }, {
          key: "lockButton",
          value: function AxisHalo_lockButton_() {
            var self = this;
            return this.halo.addGuide(new Morph({
              fill: Color.transparent,
              extent: pt(25, 25),
              submorphs: [{
                center: pt(12.5, 12.5),
                fill: Color.transparent,
                styleClasses: ["fa", "fa-unlock"]
              }],
              alignWithTarget: function alignWithTarget() {
                if (self.targetAxis.fixed) {
                  this.fontColor = Color.red;
                  this.submorphs[0].styleClasses = ["fa", "fa-lock"];
                } else {
                  this.fontColor = Color.green;
                  this.submorphs[0].styleClasses = ["fa", "fa-unlock"];
                }
              },
              onMouseDown: function onMouseDown() {
                this.toggleLock();
              },
              toggleLock: function toggleLock() {
                self.targetAxis.fixed = !self.targetAxis.fixed;
                self.halo.alignWithTarget();
              }
            }));
          }
        }, {
          key: "menuButton",
          value: function AxisHalo_menuButton_() {
            var _this2 = this;

            var self = this;

            var remove = function remove() {
              _this2.targetAxis.remove();

              _this2.halo.initGuides();

              _this2.halo.alignWithTarget();
            };

            var addBefore = function addBefore() {
              _this2.targetAxis.addBefore();

              _this2.halo.initGuides();

              _this2.halo.alignWithTarget();
            };

            var addAfter = function addAfter() {
              _this2.targetAxis.addAfter();

              _this2.halo.initGuides();

              _this2.halo.alignWithTarget();
            };

            return new Morph({
              fill: Color.transparent,
              extent: pt(25, 25),
              submorphs: [{
                fill: Color.transparent,
                styleClasses: ["fa", "fa-cog"],
                center: pt(12.5, 12.5)
              }],
              onMouseDown: function onMouseDown(evt) {
                self.forceMenuVisible = true;
                this.addMorph(evt.state.menu = new Menu({
                  position: pt(15, 15),
                  items: [["Remove ".concat(self.subject), function () {
                    return remove();
                  }], ["Insert ".concat(self.subject, " before"), function () {
                    return addBefore();
                  }], ["Insert ".concat(self.subject, " after"), function () {
                    return addAfter();
                  }]]
                }));
              }
            });
          }
        }, {
          key: "viewer",
          value: function AxisHalo_viewer_(_ref) {
            var position = _ref.position,
                alignWithTarget = _ref.alignWithTarget;
            return this.halo.addGuide(new Text({
              styleClasses: ["Halo"],
              padding: Rectangle.inset(6),
              visible: false,
              borderRadius: 10,
              fontColor: Color.white,
              fill: Color.black.withA(0.5),
              position: position,
              alignWithTarget: alignWithTarget,
              readOnly: true
            }));
          }
        }, {
          key: "proportionViewer",
          value: function AxisHalo_proportionViewer_() {
            var self = this;
            return this.viewer({
              position: this.getProportionViewerPosition(),
              alignWithTarget: function alignWithTarget() {
                var length = self.targetAxis.length;
                this.textString = "".concat(length.toFixed(1), "px");
              }
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "AxisHalo";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              halo: {},
              targetAxis: {},
              container: {},
              fill: {
                defaultValue: Color.transparent
              },
              submorphs: {
                initialize: function initialize() {
                  this.initialize();
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./layout.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 2192,
          end: 8105
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/layout.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("RowHalo") && typeof __lively_classholder__.RowHalo === "function" ? __lively_classholder__.RowHalo : __lively_classholder__.RowHalo = function RowHalo(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "subject",
          get: function get() {
            return "row";
          }
        }, {
          key: "adjustStretch",
          value: function RowHalo_adjustStretch_(delta) {
            this.targetAxis.height += delta;
          }
        }, {
          key: "getDelta",
          value: function RowHalo_getDelta_(evt) {
            return evt.state.dragDelta.y;
          }
        }, {
          key: "axisOffset",
          value: function RowHalo_axisOffset_() {
            return this.targetAxis.origin.position.y;
          }
        }, {
          key: "fetchPosition",
          value: function RowHalo_fetchPosition_() {
            return pt(-45, this.axisOffset() + 10);
          }
        }, {
          key: "fetchExtent",
          value: function RowHalo_fetchExtent_() {
            return pt(40, this.targetAxis.length - 10);
          }
        }, {
          key: "getMenuOffset",
          value: function RowHalo_getMenuOffset_(menu) {
            return this.targetAxis.length > menu.height ? pt(2, 5) : pt(26, 10);
          }
        }, {
          key: "getMenuLayout",
          value: function RowHalo_getMenuLayout_() {
            return new VerticalLayout();
          }
        }, {
          key: "getResizeCursor",
          value: function RowHalo_getResizeCursor_() {
            return "row-resize";
          }
        }, {
          key: "getMinViewerPosition",
          value: function RowHalo_getMinViewerPosition_() {
            return pt(50, 20);
          }
        }, {
          key: "getMinSliderPosition",
          value: function RowHalo_getMinSliderPosition_() {
            return pt(0, -this.targetAxis.min);
          }
        }, {
          key: "getMinSpaceExtent",
          value: function RowHalo_getMinSpaceExtent_() {
            return pt(this.container.width + 45, this.targetAxis.min);
          }
        }, {
          key: "getMinSpaceBorder",
          value: function RowHalo_getMinSpaceBorder_() {
            return {
              extent: pt(this.container.width + 50, 2),
              vertices: [pt(0, 1), pt(this.container.width + 50, 1)]
            };
          }
        }, {
          key: "getProportionViewerPosition",
          value: function RowHalo_getProportionViewerPosition_() {
            return pt(40, 20);
          }
        }, {
          key: "getProportionSliderBounds",
          value: function RowHalo_getProportionSliderBounds_(slider) {
            return pt(0, slider.owner.height - 5).extent(pt(40, 10));
          }
        }, {
          key: "getDeviderBounds",
          value: function RowHalo_getDeviderBounds_() {
            return pt(15, 4).extent(pt(25, 2));
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "RowHalo";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              row: {},
              targetAxis: {
                derived: true,
                get: function get() {
                  return this.halo.target.row(this.row);
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./layout.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 8107,
          end: 9459
        });
      })(__varRecorder__$4.AxisHalo);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/layout.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ColumnHalo") && typeof __lively_classholder__.ColumnHalo === "function" ? __lively_classholder__.ColumnHalo : __lively_classholder__.ColumnHalo = function ColumnHalo(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: Symbol["for"]("lively-instance-initialize"),
          value: function ColumnHalo_initialize_(_ref2) {
            var col = _ref2.col,
                halo = _ref2.halo;

            var _this;

            _this = initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol["for"]("lively-instance-initialize"), this).call(this, {
              targetAxis: halo.target.col(col),
              halo: halo
            });
            return _this;
          }
        }, {
          key: "subject",
          get: function get() {
            return "column";
          }
        }, {
          key: "adjustStretch",
          value: function ColumnHalo_adjustStretch_(delta) {
            this.targetAxis.width += delta;
          }
        }, {
          key: "getDelta",
          value: function ColumnHalo_getDelta_(evt) {
            return evt.state.dragDelta.x;
          }
        }, {
          key: "axisOffset",
          value: function ColumnHalo_axisOffset_() {
            return this.targetAxis.origin.position.x;
          }
        }, {
          key: "fetchPosition",
          value: function ColumnHalo_fetchPosition_() {
            return pt(this.axisOffset() + 10, -45);
          }
        }, {
          key: "fetchExtent",
          value: function ColumnHalo_fetchExtent_() {
            return pt(this.targetAxis.length - 10, 40);
          }
        }, {
          key: "getMenuOffset",
          value: function ColumnHalo_getMenuOffset_(menu) {
            return this.targetAxis.length > menu.width ? pt(5, 3) : pt(8, 26);
          }
        }, {
          key: "getMenuLayout",
          value: function ColumnHalo_getMenuLayout_() {
            return new HorizontalLayout();
          }
        }, {
          key: "getResizeCursor",
          value: function ColumnHalo_getResizeCursor_() {
            return "col-resize";
          }
        }, {
          key: "getMinViewerPosition",
          value: function ColumnHalo_getMinViewerPosition_() {
            return pt(20, 50);
          }
        }, {
          key: "getMinSliderPosition",
          value: function ColumnHalo_getMinSliderPosition_() {
            return pt(-this.targetAxis.min, 0);
          }
        }, {
          key: "getMinSpaceExtent",
          value: function ColumnHalo_getMinSpaceExtent_() {
            return pt(this.targetAxis.min, this.container.height + 45);
          }
        }, {
          key: "getMinSpaceBorder",
          value: function ColumnHalo_getMinSpaceBorder_() {
            return {
              extent: pt(2, this.container.height + 50),
              vertices: [pt(1, 0), pt(1, this.container.height + 50)]
            };
          }
        }, {
          key: "getProportionViewerPosition",
          value: function ColumnHalo_getProportionViewerPosition_() {
            return pt(20, 40);
          }
        }, {
          key: "getProportionSliderBounds",
          value: function ColumnHalo_getProportionSliderBounds_(slider) {
            return pt(slider.owner.width - 5, 0).extent(pt(10, 40));
          }
        }, {
          key: "getDeviderBounds",
          value: function ColumnHalo_getDeviderBounds_() {
            return pt(4, 15).extent(pt(2, 25));
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ColumnHalo";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./layout.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 9461,
          end: 10716
        });
      })(__varRecorder__$4.AxisHalo);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/layout.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("CellGuide") && typeof __lively_classholder__.CellGuide === "function" ? __lively_classholder__.CellGuide : __lively_classholder__.CellGuide = function CellGuide(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "menuItems",
          value: function CellGuide_menuItems_() {
            var _this3 = this;

            var checked = Icon.textAttribute("check-square-o");
            var unchecked = Icon.textAttribute("square-o");
            checked[1].textStyleClasses.push("annotation");
            unchecked[1].textStyleClasses.push("annotation");
            unchecked[1].paddingRight = "2px";
            return [["Resize Policy", [[["Rigid  ", null].concat(_toConsumableArray$1(this.cellGroup.resize ? unchecked : checked)), function () {
              _this3.cellGroup.resize = false;
            }], [["Space Filling  ", null].concat(_toConsumableArray$1(this.cellGroup.resize ? checked : unchecked)), function () {
              _this3.cellGroup.resize = true;
            }]]], ["Align at...", ["center"].concat(_toConsumableArray$1(new Rectangle().sides), _toConsumableArray$1(new Rectangle().corners)).map(function (side) {
              return [[side, {
                paddingRight: "2px"
              }].concat(_toConsumableArray$1(_this3.cellGroup.align === side ? checked : unchecked), ["  ", null]), function () {
                return _this3.cellGroup.align = side;
              }];
            })]].concat(this.cellGroup.morph ? [["Release Morph from Cell", function () {
              var m = _this3.cellGroup.morph;

              if (m) {
                _this3.world().firstHand.grab(m);

                _this3.world().firstHand.longClickGrab = true;
                m.position = pt(0);
              }
            }]] : []);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "CellGuide";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              cellGroup: {}
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./layout.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 10718,
          end: 12038
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/layout.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("LayoutHalo") && typeof __lively_classholder__.LayoutHalo === "function" ? __lively_classholder__.LayoutHalo : __lively_classholder__.LayoutHalo = function LayoutHalo(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, undefined, [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "LayoutHalo";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              container: {},
              target: {
                get: function get() {
                  return this.container.layout;
                }
              },
              pointerId: {},
              halosEnabled: {
                defaultValue: false
              },
              isEpiMorph: {
                defaultValue: true
              },
              isHaloItem: {
                defaultValue: true
              },
              borderColor: {
                defaultValue: Color.orange
              },
              borderWidth: {
                defaultValue: 2
              },
              styleClasses: {
                defaultValue: ["Halo"]
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./layout.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 12040,
          end: 12496
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      var GridLayoutHalo = exports('V', function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/layout.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GridLayoutHalo") && typeof __lively_classholder__.GridLayoutHalo === "function" ? __lively_classholder__.GridLayoutHalo : __lively_classholder__.GridLayoutHalo = function GridLayoutHalo(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "previewDrop",
          value: function GridLayoutHalo_previewDrop_(morphs) {
            if (morphs.length < 1) return;
            var cell = this.cellGuides.find(function (g) {
              return g.fullContainsWorldPoint($world.firstHand.position);
            });

            if (cell !== this.currentCell) {
              this.currentCell && this.currentCell.stopPreview();
            }

            this.currentCell = cell;
            this.currentCell && this.currentCell.startPreview();
          }
        }, {
          key: "handleDrop",
          value: function GridLayoutHalo_handleDrop_(morph) {
            var _this4 = this;

            if (this.currentCell) {
              morph.whenRendered().then(function () {
                return _this4.currentCell.cellGroup.morph = morph;
              });
            }
          }
        }, {
          key: "initialize",
          value: function GridLayoutHalo_initialize_() {
            this.initGuides();
            this.alignWithTarget();
            this.focus();
          }
        }, {
          key: "optionControls",
          value: function GridLayoutHalo_optionControls_() {
            var layout = this.target;
            var compensateOrigin = part(LabeledCheckbox, {
              name: "compensateOrigin",
              viewModel: {
                label: "Compensate Origin",
                checked: layout.compensateOrigin
              }
            });
            var fitToCell = part(LabeledCheckbox, {
              name: "fitToCell",
              viewModel: {
                label: "Resize Submorphs",
                checked: layout.fitToCell
              }
            });
            connect(compensateOrigin, "checked", layout, "compensateOrigin");
            connect(fitToCell, "checked", layout, "fitToCell");
            connect(compensateOrigin, "checked", this, "alignWithTarget");
            return [compensateOrigin, fitToCell];
          }
        }, {
          key: "isLayoutHalo",
          get: function get() {
            return false;
          }
        }, {
          key: "alignWithTarget",
          value: function GridLayoutHalo_alignWithTarget_() {
            this.target.apply();
            this.position = this.container.globalPosition;
            if (this.target.compensateOrigin) this.moveBy(this.container.origin.negated());
            this.extent = this.container.extent;
            this.addMissingGuides();
            this.guides.reverse().forEach(function (guide) {
              return guide.alignWithTarget();
            });
          }
        }, {
          key: "addMissingGuides",
          value: function GridLayoutHalo_addMissingGuides_() {
            var _this5 = this;

            withoutAll(this.target.cellGroups, this.guides.map(function (g) {
              return g.cellGroup;
            })).forEach(function (group) {
              return _this5.addMorph(_this5.cellGuide(group));
            });
          }
        }, {
          key: "initGuides",
          value: function GridLayoutHalo_initGuides_() {
            this.submorphs = [];
            this.guides = [];
            this.initCellGuides();
            this.initColumnGuides();
            this.initRowGuides();
          }
        }, {
          key: "initCellGuides",
          value: function GridLayoutHalo_initCellGuides_() {
            var _this6 = this;

            var cellContainer = this.addMorph({
              fill: Color.transparent,
              borderRadius: this.borderRadius,
              extent: this.extent
            });
            this.target.cellGroups.forEach(function (group) {
              cellContainer.addMorph(_this6.cellGuide(group));
            });
            this.cellGuides = cellContainer.submorphs;
            this.addMorph(this.resizer());
          }
        }, {
          key: "addGuide",
          value: function GridLayoutHalo_addGuide_(guide) {
            guide.isHaloItem = true;
            this.guides.push(guide);
            return guide;
          }
        }, {
          key: "initRowGuides",
          value: function GridLayoutHalo_initRowGuides_() {
            var _this7 = this;

            var self = this;
            this.addGuide(this.addMorph(new Morph({
              width: 25,
              fill: Color.gray.withA(0.7),
              borderRadius: 15,
              height: this.container.height,
              topRight: pt(-5, 0),
              alignWithTarget: function alignWithTarget() {
                this.height = self.container.height;
              }
            })));
            range(0, this.target.rowCount - 1).forEach(function (row) {
              _this7.addMorph(new __varRecorder__$4.RowHalo({
                row: row,
                halo: _this7
              }));
            });
          }
        }, {
          key: "initColumnGuides",
          value: function GridLayoutHalo_initColumnGuides_() {
            var _this8 = this;

            var self = this;
            this.addGuide(this.addMorph(new Morph({
              height: 25,
              fill: Color.gray.withA(0.7),
              borderRadius: 15,
              width: this.container.width,
              bottomLeft: pt(0, -5),
              alignWithTarget: function alignWithTarget() {
                this.width = self.container.width;
              }
            })));
            range(0, this.target.columnCount - 1).forEach(function (col) {
              _this8.addMorph(new __varRecorder__$4.ColumnHalo({
                col: col,
                halo: _this8
              }));
            });
          }
        }, {
          key: "resizer",
          value: function GridLayoutHalo_resizer_() {
            var self = this;
            return this.addGuide(new Morph({
              fill: Color.transparent,
              extent: pt(25, 25),
              nativeCursor: "nwse-resize",
              onDrag: function onDrag(evt) {
                self.container.resizeBy(evt.state.dragDelta);
                self.alignWithTarget();
              },
              alignWithTarget: function alignWithTarget() {
                this.bottomRight = self.extent;
              }
            }));
          }
        }, {
          key: "cellResizer",
          value: function GridLayoutHalo_cellResizer_(cellGroup, corner) {
            var self = this;
            var adjacentCorner = corner === "topLeft" ? "bottomRight" : "topLeft";

            var getCorner = function getCorner(c) {
              return cellGroup.bounds().partNamed(c);
            };

            return new Ellipse({
              borderWidth: 1,
              visible: false,
              borderColor: Color.black,
              nativeCursor: "nwse-resize",
              removeCell: function removeCell(cell) {
                cellGroup.disconnect(cell);
                self.alignWithTarget();
              },
              addCell: function addCell(cell) {
                cellGroup.connect(cell);
                self.alignWithTarget();
              },
              start: function start() {
                this.fixpointCell = cellGroup[adjacentCorner];
                this.draggedDelta = getCorner(corner);
                this.debugMorph = self.addMorph(new Morph({
                  fill: Color.orange.withA(0.5)
                }));
              },
              update: function update(delta) {
                var _this9 = this;

                this.draggedDelta = this.draggedDelta.addPt(delta);
                var coveringRect = Rectangle.unionPts([this.draggedDelta]).union(this.fixpointCell.bounds());
                this.debugMorph.setBounds(coveringRect);
                self.cells.forEach(function (cell) {
                  var coverage = coveringRect.intersection(cell.bounds()).area() / cell.bounds().area();
                  if (cellGroup.includes(cell) && coverage < 0.1) _this9.removeCell(cell);
                  if (!cellGroup.includes(cell) && coverage > 1 / 3) _this9.addCell(cell);
                });
              },
              onDragEnd: function onDragEnd(evt) {
                this.debugMorph.remove();
              },
              onDragStart: function onDragStart(evt) {
                this.start(evt.position);
              },
              onDrag: function onDrag(evt) {
                this.update(evt.state.dragDelta);
              }
            });
          }
        }, {
          key: "cellGuide",
          value: function GridLayoutHalo_cellGuide_(cellGroup) {
            var self = this;
            var topLeft = this.cellResizer(cellGroup, "topLeft");
            var bottomRight = this.cellResizer(cellGroup, "bottomRight");
            return this.addGuide(new __varRecorder__$4.CellGuide({
              cellGroup: cellGroup,
              bounds: cellGroup.bounds(),
              fill: Color.transparent,
              borderColor: Color.orange,
              borderWidth: 1,
              isHaloItem: true,
              isCell: true,
              draggable: false,
              submorphs: [topLeft, bottomRight],
              onMouseDown: function onMouseDown(evt) {
                this.becomeActive();
              },
              deactivate: function deactivate() {
                this.borderColor = Color.orange;
                this.fill = Color.transparent;
                this.submorphs.forEach(function (b) {
                  b.visible = false;
                });
              },
              becomeActive: function becomeActive() {
                self.guides.forEach(function (guide) {
                  if (guide.isCell) guide.deactivate();
                });
                this.borderColor = Color.rgbHex("#1565C0"), this.fill = Color.rgbHex("#1565C0").withA(0.3), self.addMorph(this.remove());
                this.submorphs.forEach(function (b) {
                  b.visible = true;
                });
              },
              startPreview: function startPreview(evt) {
                this.fill = Color.orange.withA(0.7);
              },
              stopPreview: function stopPreview(evt) {
                this.fill = Color.transparent;
              },
              onDrop: function onDrop(evt) {
                var _evt$hand$grabbedMorp = _slicedToArray(evt.hand.grabbedMorphs, 1),
                    m = _evt$hand$grabbedMorp[0];

                evt.hand.dropMorphsOn(self.container);
                cellGroup.morph = m;
              },
              alignWithTarget: function alignWithTarget() {
                var bounds = cellGroup.bounds();

                if (bounds.isNonEmpty()) {
                  this.setBounds(cellGroup.bounds());
                  topLeft.center = this.innerBounds().topLeft();
                  bottomRight.center = this.innerBounds().bottomRight();
                } else {
                  remove(self.guides, this);
                  this.remove();
                }
              }
            }));
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GridLayoutHalo";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              fill: {
                defaultValue: Color.transparent
              },
              cells: {
                derived: true,
                get: function get() {
                  return this.target.col(0).items.map(function (c) {
                    return c.row(0).items;
                  }).flat();
                }
              },
              submorphs: {
                after: ["target"],
                initialize: function initialize() {
                  this.initialize();
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./layout.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.halos",
              version: "0.1.0"
            };
          }
        }, {
          start: 12505,
          end: 19944
        });
      }(__varRecorder__$4.LayoutHalo));
      __varRecorder__$4.GridLayoutHalo = GridLayoutHalo;
      __varRecorder__$4.GridLayoutHalo = GridLayoutHalo;

      var __varRecorder__$3 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.halos/index.js", __contextModule__);
      __varRecorder__$3.show = show;
      __varRecorder__$3.Halo = Halo;
      __varRecorder__$3.MorphHighlighter = MorphHighlighter;
      __varRecorder__$3.InteractiveMorphSelector = InteractiveMorphSelector;
      __varRecorder__$3.GridLayoutHalo = GridLayoutHalo;
      __varRecorder__$3.FlexLayoutHalo = _missingExportShim;
      __varRecorder__$3.showAndSnapToGuides = showAndSnapToGuides;
      __varRecorder__$3.removeSnapToGuidesOf = removeSnapToGuidesOf;

      var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        show: show,
        Halo: Halo,
        MorphHighlighter: MorphHighlighter,
        InteractiveMorphSelector: InteractiveMorphSelector,
        GridLayoutHalo: GridLayoutHalo,
        FlexLayoutHalo: _missingExportShim,
        showAndSnapToGuides: showAndSnapToGuides,
        removeSnapToGuidesOf: removeSnapToGuidesOf
      });
      exports('ah', index);

      var __varRecorder__$2 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/helpers.js", __contextModule__);
      var __moduleMeta__$1 = {
        pathInPackage: function pathInPackage() {
          return "./js/inspector/helpers.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var ensureDefaultImports = __varRecorder__$2["lively.ide/js/inspector/helpers.js__define__"]("ensureDefaultImports", "function", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var inspectorEvalContext, imports, _loop, modName, _ret;

        return regeneratorRuntime.wrap(function _callee$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(typeof module$1 === "undefined")) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                inspectorEvalContext = module$1("lively://lively.morphic/inspector");
                imports = lively.FreezerRuntime ? {} : config$2.ide.js.defaultInspectorImports;
                _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop(modName) {
                  var exports;
                  return regeneratorRuntime.wrap(function _loop$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          exports = void 0;
                          _context.prev = 1;
                          _context.next = 4;
                          return System["import"](modName);

                        case 4:
                          exports = _context.sent;
                          _context.next = 11;
                          break;

                        case 7:
                          _context.prev = 7;
                          _context.t0 = _context["catch"](1);
                          console.log("Failed to load inspector workspace default import: " + modName);
                          return _context.abrupt("return", "continue");

                        case 11:
                          imports[modName].forEach(function (v) {
                            inspectorEvalContext.define(v, exports[v], false);
                          });

                        case 12:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _loop, null, [[1, 7]]);
                });
                _context2.t0 = regeneratorRuntime.keys(imports);

              case 6:
                if ((_context2.t1 = _context2.t0()).done) {
                  _context2.next = 14;
                  break;
                }

                modName = _context2.t1.value;
                return _context2.delegateYield(_loop(modName), "t2", 9);

              case 9:
                _ret = _context2.t2;

                if (!(_ret === "continue")) {
                  _context2.next = 12;
                  break;
                }

                return _context2.abrupt("continue", 6);

              case 12:
                _context2.next = 6;
                break;

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee);
      })), __moduleMeta__$1);

      __varRecorder__$2.ensureDefaultImports = ensureDefaultImports;

      var generateReferenceExpression = exports('a3', __varRecorder__$2["lively.ide/js/inspector/helpers.js__define__"]("generateReferenceExpression", "function", function (morph) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var world = morph.world();
        var _opts$maxLength = opts.maxLength,
            maxLength = _opts$maxLength === void 0 ? 10 : _opts$maxLength,
            _opts$fromMorph = opts.fromMorph,
            fromMorph = _opts$fromMorph === void 0 ? world : _opts$fromMorph;
        if (fromMorph === morph) return "this";
        var rootExpr = world === fromMorph ? "$world" : "this";

        if (!world && (!morph.name || fromMorph.get(morph.name) !== morph)) {
          return "morph";
        }

        var exprs = makeReferenceExpressionListFor(morph);
        return exprs.length > maxLength ? "$world.getMorphWithId(\"".concat(morph.id, "\")") : exprs.join(".");

        function makeReferenceExpressionListFor(morph) {
          var name = morph.name;
          var owners = morph.ownerChain();
          var owner = morph.owner;
          var world = morph.world();
          var exprList;
          if (morph === fromMorph) exprList = [rootExpr];
          if (world === morph) exprList = ["$world"];

          if (!exprList && name && owner) {
            if (owner === world && count(pluck(world.submorphs, "name"), name) === 1) {
              exprList = ["$world.get(\"".concat(name, "\")")];
            }

            if (!exprList && owner !== world) {
              for (var i = owners.length - 1; i--;) {
                if (owners[i].getAllNamed(name).length === 1) {
                  exprList = [].concat(_toConsumableArray$1(makeReferenceExpressionListFor(owners[i])), ["get(\"".concat(name, "\")")]);
                  break;
                }
              }
            }

            if (!exprList) {
              var exprsToCheck = [].concat(_toConsumableArray$1(makeReferenceExpressionListFor(owner)), ["get(\"".concat(name, "\")")]);

              if (syncEval(exprsToCheck.join("."), {
                context: fromMorph
              }).value === morph) {
                exprList = exprsToCheck;
              }
            }
          }

          if (!exprList) {
            exprList = ["".concat(rootExpr, ".getMorphWithId(\"").concat(morph.id, "\")")];
          }

          return exprList;
        }
      }, __moduleMeta__$1));

      __varRecorder__$2.generateReferenceExpression = generateReferenceExpression;
      __varRecorder__$2.ensureDefaultImports = ensureDefaultImports;
      __varRecorder__$2.generateReferenceExpression = generateReferenceExpression;

      var __varRecorder__$1 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/index.js", __contextModule__);
      ensureDefaultImports();
      __varRecorder__$1.NUMBER_COLOR = Color.rgb(40, 116, 166);
      __varRecorder__$1.inspectorCommands = [{
        name: "focus codeEditor",
        exec: function exec(inspector) {
          inspector.get("codeEditor").show();
          inspector.get("codeEditor").focus();
          return true;
        }
      }, {
        name: "focus propertyTree",
        exec: function exec(inspector) {
          inspector.get("propertyTree").show();
          inspector.get("propertyTree").focus();
          return true;
        }
      }];

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/index.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DraggableTreeLabel") && typeof __lively_classholder__.DraggableTreeLabel === "function" ? __lively_classholder__.DraggableTreeLabel : __lively_classholder__.DraggableTreeLabel = function DraggableTreeLabel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "inspector",
          get: function get() {
            return this.owner.owner;
          }
        }, {
          key: "onDragStart",
          value: function DraggableTreeLabel_onDragStart_(evt) {
            this.draggedProp = part(DraggedProp, {
              sourceObject: this.inspector.targetObject,
              control: this.copy()
            });
            this.draggedProp.openInWorld();
            connect(evt.hand, "update", this.draggedProp, "update");
          }
        }, {
          key: "onDrag",
          value: function DraggableTreeLabel_onDrag_() {}
        }, {
          key: "onDragEnd",
          value: function DraggableTreeLabel_onDragEnd_(evt) {
            disconnect(evt.hand, "update", this.draggedProp, "update");
            this.draggedProp.applyToTarget(evt);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DraggableTreeLabel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              styleClasses: {
                defaultValue: ["TreeLabel"]
              },
              draggable: {
                defaultValue: true
              },
              nativeCursor: {
                defaultValue: "-webkit-grab"
              },
              keyString: {},
              valueString: {},
              fontFamily: {
                defaultValue: config$2.codeEditor.defaultStyle.fontFamily
              },
              fill: {
                defaultValue: Color.transparent
              },
              padding: {
                defaultValue: rect(0, 1, 10, -1)
              },
              isSelected: {
                after: ["submorphs"],
                set: function set(b) {
                  this.setProperty("isSelected", b);

                  if (b) {
                    this.removeStyleClass("deselected");
                    this.addStyleClass("selected");
                  } else {
                    this.addStyleClass("deselected");
                    this.removeStyleClass("selected");
                  }

                  if (this.control) this.control.isSelected = b;
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/inspector/index.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 1456,
          end: 2794
        });
      })({
        referencedAs: "Label",
        value: Label
      });

      var PropertyControl = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/index.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PropertyControl") && typeof __lively_classholder__.PropertyControl === "function" ? __lively_classholder__.PropertyControl : __lively_classholder__.PropertyControl = function PropertyControl(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "menuItems",
          value: function PropertyControl_menuItems_() {
            return this._targetMenuItems || [];
          }
        }, {
          key: "renderValueSelector",
          value: function PropertyControl_renderValueSelector_(propertyControl, selectedValue, values) {
            propertyControl.control = new DropDownSelector({
              opacity: 0.8,
              fill: Color.white.withA(0.5),
              name: "valueString",
              styleClasses: ["TreeLabel"],
              selectedValue: selectedValue,
              padding: 0,
              values: values
            });
            connect(propertyControl.control, "update", propertyControl, "propertyValue", {
              updater: function updater($upd, val) {
                if (this.targetObj.propertyValue !== val) $upd(val);
              }
            });
            connect(propertyControl, "update", propertyControl.control, "selectedValue", {
              updater: function updater($upd, val) {
                val = val && val.valueOf ? val.valueOf() : val;
                if (this.targetObj.propertyValue !== val) $upd(val);
              }
            });
            return propertyControl;
          }
        }, {
          key: "toggleMultiValuePlaceholder",
          value: function PropertyControl_toggleMultiValuePlaceholder_(active) {
            this.multiValuePlaceholder = this.multiValuePlaceholder || this.addMorph({
              fill: Color.transparent,
              layout: new TilingLayout({
                axis: "column",
                spacing: 3
              }),
              name: "multi value placeholder",
              nativeCursor: "pointer",
              submorphs: range(0, 2).map(function () {
                return {
                  type: "ellipse",
                  fill: Color.gray.withA(0.5),
                  reactsToPointer: false,
                  extent: pt(7, 7)
                };
              })
            });

            if (active) {
              connect(this.multiValuePlaceholder, "onMouseDown", this, "propertyValue", {
                converter: function converter() {
                  return this.targetObj.propertyValue.valueOf();
                }
              });
              this.control.opacity = 0;
              this.multiValuePlaceholder.visible = true;
            } else {
              disconnect(this.multiValuePlaceholder, "onMouseDown", this, "propertyValue");
              this.control.opacity = 1;
              this.multiValuePlaceholder.visible = false;
            }
          }
        }, {
          key: "toggleFoldableValue",
          value: function PropertyControl_toggleFoldableValue_(newValue) {
            if (!this.foldableProperties) return;
            this.toggleMultiValuePlaceholder(isMultiValue(newValue, this.foldableProperties));
          }
        }, {
          key: "asFoldable",
          value: function PropertyControl_asFoldable_(foldableProperties) {
            this.foldableProperties = foldableProperties;
            connect(this, "update", this, "toggleFoldableValue");
          }
        }, {
          key: "relayout",
          value: function PropertyControl_relayout_() {
            this.fit();

            if (this.control) {
              this.control.topLeft = this.textBounds().topRight().addXY(-2, 1);
              this.width = this.textBounds().width + this.control.bounds().width;
            }

            this.height = 18;

            if (this.multiValuePlaceholder) {
              this.multiValuePlaceholder.leftCenter = this.textBounds().rightCenter();
            }
          }
        }, {
          key: "toString",
          value: function PropertyControl_toString_() {
            return "".concat(this.keyString, ": ").concat(this.valueString);
          }
        }, {
          key: "highlight",
          value: function PropertyControl_highlight_() {
            if (this.highlighter) this.highlighter.remove();
            var hl = this.highlighter = this.addMorph({
              type: "label",
              name: "valueString",
              value: this.keyString
            });
            hl.isLayoutable = false;
            hl.fontWeight = "bold", hl.fontColor = Color.orange;
            hl.reactsToPointer = false;
            hl.fadeOut(2000);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PropertyControl";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              root: {},
              keyString: {},
              valueString: {},
              propertyValue: {},
              control: {
                after: ["submorphs"],
                derived: true,
                get: function get() {
                  return this.submorphs[0] || false;
                },
                set: function set(c) {
                  this.submorphs = [c];
                }
              },
              submorphs: {
                initialize: function initialize() {
                  this.value = this.keyString + ":";
                  this.submorphs = [];
                  connect(this, "extent", this, "relayout");
                }
              }
            };
          }
        }, {
          key: "inferType",
          value: function PropertyControl_inferType_(_ref) {
            var value = _ref.value;

            if (value && (value.isColor || value.isGradient)) {
              return "Color";
            } else if (value && value.isPoint) {
              return "Point";
            } else if (isBoolean$1(value)) {
              return "Boolean";
            } else if (isNumber$2(value)) {
              return "Number";
            } else if (isString$3(value)) {
              return "String";
            } else if (value && value.isRectangle) {
              return "Rectangle";
            }

            return false;
          }
        }, {
          key: "render",
          value: function PropertyControl_render_(args) {
            var propertyControl;

            if (!args.spec.type) {
              args.spec = Object.assign({}, args.spec, {
                isFloat: !Number.isInteger(args.value),
                type: this.inferType(args)
              });
            }

            switch (args.spec.type) {
              case "Color":
                propertyControl = this.renderColorControl(args);
                break;

              case "ColorGradient":
                propertyControl = this.renderColorControl(Object.assign({}, args, {
                  gradientEnabled: true
                }));
                break;

              case "Number":
                propertyControl = this.renderNumberControl(args);
                break;

              case "String":
                propertyControl = this.renderStringControl(args);
                break;

              case "RichText":
                propertyControl = this.renderStringControl(args);
                break;

              case "Layout":
                propertyControl = this.renderLayoutControl(args);
                break;

              case "Enum":
                propertyControl = this.renderEnumControl(args);
                break;

              case "Shadow":
                propertyControl = this.renderShadowControl(args);
                break;

              case "Point":
                propertyControl = this.renderPointControl(args);
                break;

              case "Rectangle":
                propertyControl = this.renderRectangleControl(args);
                break;

              case "Boolean":
                propertyControl = this.renderBooleanControl(args);
                break;

              default:
                propertyControl = this.renderItSomehow(args);
            }

            if (propertyControl.control) {
              propertyControl.toggleFoldableValue(args.value);
              return propertyControl;
            }

            return propertyControl;
          }
        }, {
          key: "baseControl",
          value: function PropertyControl_baseControl_(_ref2) {
            var keyString = _ref2.keyString,
                valueString = _ref2.valueString,
                value = _ref2.value,
                spec = _ref2.spec;
            var propertyControl = new this({
              keyString: keyString,
              valueString: valueString,
              isSelected: false,
              propertyValue: value
            });

            if (spec.foldable) {
              propertyControl.asFoldable(spec.foldable);
            }

            return propertyControl;
          }
        }, {
          key: "renderGrabbableKey",
          value: function PropertyControl_renderGrabbableKey_(args) {
            var _this = this;

            var isDraggable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var keyString = args.keyString,
                target = args.target;
                args.value;
            isDraggable = target.isMorph && isDraggable;
            var dragHandlers = {
              onDragStart: function onDragStart(evt) {
                evt.state.draggedProp = part(DraggedProp, {
                  sourceObject: target,
                  control: _this.baseControl(args)
                });
                evt.state.draggedProp.openInWorld();
                connect(evt.hand, "update", evt.state.draggedProp, "update");
              },
              onDrag: function onDrag() {},
              onDragEnd: function onDragEnd(evt) {
                disconnect(evt.hand, "update", evt.state.draggedProp, "update");
                evt.state.draggedProp.applyToTarget(evt);
              }
            };
            return [].concat(_toConsumableArray$1(isDraggable ? Icon.textAttribute("mi-drag_indicator", Object.assign({
              verticalAlign: "bottom",
              fontSize: 16,
              opacity: 0.5
            }, isDraggable ? dragHandlers : {})) : ["  ", null]), ["".concat(keyString, ":"), Object.assign({
              "vertical-align": "top"
            }, isDraggable ? dragHandlers : {})]);
          }
        }, {
          key: "renderEnumControl",
          value: function PropertyControl_renderEnumControl_(args) {
            var value = args.value,
                values = args.spec.values,
                keyString = args.keyString,
                target = args.target,
                node = args.node,
                tree = args.tree;

            var handler = /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(evt) {
                var menu;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return target.world().openWorldMenu(evt, values.map(function (v) {
                          return {
                            string: v.toString(),
                            action: function action() {
                              target[keyString] = v;
                              node.rerender();
                            }
                          };
                        }));

                      case 2:
                        menu = _context.sent;
                        tree.owner.openWidget = menu;

                      case 4:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function handler(_x) {
                return _ref3.apply(this, arguments);
              };
            }();

            return [].concat(_toConsumableArray$1(this.renderGrabbableKey(args)), [" ".concat(value ? value.valueOf ? value.valueOf() : value : "Not set"), {
              onMouseDown: handler
            }], _toConsumableArray$1(Icon.textAttribute("angle-down", {
              paddingTop: "4px",
              paddingLeft: "4px",
              opacity: 0.7,
              onMouseDown: handler
            })));
          }
        }, {
          key: "renderStringControl",
          value: function PropertyControl_renderStringControl_(args) {
            var value = args.value;
            return [].concat(_toConsumableArray$1(this.renderGrabbableKey(args)), [" ".concat(value.length > 200 ? value.slice(0, 20) + "..." : value), {
              fontColor: Color.blue,
              paddingTop: "0px"
            }]);
          }
        }, {
          key: "renderRectangleControl",
          value: function PropertyControl_renderRectangleControl_(args) {
            var keyString = args.keyString,
                valueString = args.valueString,
                target = args.target,
                node = args.node,
                tree = args.tree;
            var inspector = tree.owner;

            var handler = /*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(evt) {
                var editor;
                return regeneratorRuntime.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        editor = part(PaddingPopup, {
                          hasFixedPosition: true
                        });
                        editor.startPadding(target[keyString]);
                        _context2.next = 4;
                        return editor.fadeIntoWorld(evt.positionIn(target.world()));

                      case 4:
                        inspector.openWidget = editor;
                        connect(editor, "paddingChanged", function (padding) {
                          target[keyString] = padding;
                          node.rerender();
                        });

                      case 6:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));

              return function handler(_x2) {
                return _ref4.apply(this, arguments);
              };
            }();

            return [].concat(_toConsumableArray$1(this.renderGrabbableKey(args)), [" ".concat(valueString), {
              fontColor: Color.black,
              onMouseDown: handler
            }]);
          }
        }, {
          key: "renderBooleanControl",
          value: function PropertyControl_renderBooleanControl_(args) {
            var value = args.value,
                keyString = args.keyString,
                valueString = args.valueString,
                target = args.target,
                node = args.node;
            return [].concat(_toConsumableArray$1(this.renderGrabbableKey(args)), [" ".concat(valueString), {
              nativeCursor: "pointer",
              fontColor: value ? Color.green : Color.red,
              onMouseDown: function onMouseDown() {
                target[keyString] = !target[keyString];
                node.rerender();
              }
            }]);
          }
        }, {
          key: "renderNumberControl",
          value: function PropertyControl_renderNumberControl_(args) {
            var value = args.value,
                spec = args.spec,
                keyString = args.keyString,
                node = args.node,
                target = args.target,
                tree = args.tree;
            var inspector = tree.owner;
            var widgetState = {};

            if ("max" in spec && "min" in spec && spec.min !== -Infinity && spec.max !== Infinity) {
              widgetState.baseFactor = (spec.max - spec.min) / 100;
              widgetState.floatingPoint = spec.isFloat;
              widgetState.max = spec.max;
              widgetState.min = spec.min;
            } else {
              widgetState.floatingPoint = spec.isFloat;
              widgetState.baseFactor = 0.5;
              widgetState.min = spec.min !== undefined ? spec.min : -Infinity;
              widgetState.max = spec.max !== undefined ? spec.max : Infinity;
            }

            var handler = /*#__PURE__*/function () {
              var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(evt) {
                var editor;
                return regeneratorRuntime.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        editor = part(parameterizedNumberPopupLight({
                          title: keyString,
                          tooltip: keyString,
                          value: target[keyString],
                          min: widgetState.min,
                          max: widgetState.max,
                          baseFactor: widgetState.baseFactor,
                          floatingPoint: widgetState.floatingPoint
                        }));
                        editor.epiMorph = true;
                        _context3.next = 4;
                        return editor.fadeIntoWorld(evt.positionIn(target.world()));

                      case 4:
                        inspector.openWidget = editor;
                        connect(editor, "value", function (num) {
                          target[keyString] = num;
                          node.rerender();
                        });

                      case 6:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function handler(_x3) {
                return _ref5.apply(this, arguments);
              };
            }();

            var attrs = {
              onMouseDown: handler,
              fontColor: __varRecorder__$1.NUMBER_COLOR
            };
            return [].concat(_toConsumableArray$1(this.renderGrabbableKey(args)), _toConsumableArray$1(node._inputMorph ? [node._inputMorph, Object.assign({}, attrs)] : [" ".concat(value !== undefined && (value.valueOf ? value.valueOf() : value).toFixed(spec.isFloat ? Math.max(4, precision(value)) : 0), " "), Object.assign({}, attrs)]));
          }
        }, {
          key: "renderShadowControl",
          value: function PropertyControl_renderShadowControl_(args) {
            var keyString = args.keyString,
                value = args.value,
                target = args.target,
                node = args.node,
                tree = args.tree;
            var inspector = tree.owner;

            var handler = /*#__PURE__*/function () {
              var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(evt) {
                var editor;
                return regeneratorRuntime.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        editor = part(ShadowPopupLight, {
                          hasFixedPosition: true
                        });
                        editor.shadowValue = target[keyString];
                        _context4.next = 4;
                        return editor.fadeIntoWorld(evt.positionIn(target.world()));

                      case 4:
                        inspector.openWidget = editor;
                        connect(editor, "value", function (shadowValue) {
                          target[keyString] = shadowValue;
                          node.rerender();
                        });

                      case 6:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));

              return function handler(_x4) {
                return _ref6.apply(this, arguments);
              };
            }();

            return [].concat(_toConsumableArray$1(this.renderGrabbableKey(args)), ["".concat(value ? value.toFilterCss() : "No Shadow"), {
              onMouseDown: handler
            }]);
          }
        }, {
          key: "renderPointControl",
          value: function PropertyControl_renderPointControl_(args) {
            var keyString = args.keyString,
                value = args.value,
                target = args.target,
                node = args.node,
                tree = args.tree;
            var inspector = tree.owner;

            var handler = /*#__PURE__*/function () {
              var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(evt) {
                var editor;
                return regeneratorRuntime.wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        editor = part(PositionPopupLight, {
                          hasFixedPosition: true
                        });
                        editor.setPoint(target[keyString]);
                        _context5.next = 4;
                        return editor.fadeIntoWorld(evt.positionIn(target.world()));

                      case 4:
                        inspector.openWidget = editor;
                        connect(editor, "value", function (pointValue) {
                          target[keyString] = pointValue;
                          node.rerender();
                        });

                      case 6:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5);
              }));

              return function handler(_x5) {
                return _ref7.apply(this, arguments);
              };
            }();

            var attrs = {
              onMouseDown: handler
            };
            return [].concat(_toConsumableArray$1(this.renderGrabbableKey(args)), [" pt(", Object.assign({}, attrs), "".concat(value.x.toFixed()), Object.assign({
              fontColor: __varRecorder__$1.NUMBER_COLOR
            }, attrs), ",", Object.assign({}, attrs), "".concat(value.y.toFixed()), Object.assign({
              fontColor: __varRecorder__$1.NUMBER_COLOR
            }, attrs), ")", Object.assign({}, attrs)]);
          }
        }, {
          key: "renderLayoutControl",
          value: function PropertyControl_renderLayoutControl_(args) {
            var valueString = args.valueString,
                value = args.value;
            return [].concat(_toConsumableArray$1(this.renderGrabbableKey(args)), [" ".concat(value ? valueString : "No Layout"), {
              onMouseDown: function onMouseDown() {}
            }]);
          }
        }, {
          key: "renderColorControl",
          value: function PropertyControl_renderColorControl_(args) {
            var node = args.node,
                gradientEnabled = args.gradientEnabled,
                valueString = args.valueString,
                keyString = args.keyString,
                value = args.value,
                target = args.target,
                tree = args.tree;
            var inspector = tree.owner;

            var handler = /*#__PURE__*/function () {
              var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(evt) {
                var editor;
                return regeneratorRuntime.wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        editor = part(ColorPicker, {
                          hasFixedPosition: true
                        });
                        editor.solidOnly = !gradientEnabled;
                        editor.focusOnMorph(target, value.valueOf ? value.valueOf() : value);
                        _context6.next = 5;
                        return editor.fadeIntoWorld(evt.positionIn(target.world()));

                      case 5:
                        inspector.openWidget = editor;
                        connect(editor, "value", function (fill) {
                          target[keyString] = fill;
                          node.rerender();
                        });

                      case 7:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6);
              }));

              return function handler(_x6) {
                return _ref8.apply(this, arguments);
              };
            }();

            return [].concat(_toConsumableArray$1(this.renderGrabbableKey(args)), [morph({
              fill: value.valueOf ? value.valueOf() : value,
              extent: pt(15, 15),
              reactsToPointer: false,
              borderColor: Color.gray,
              borderWidth: 1
            }), {
              paddingLeft: "5px",
              paddingTop: "4px",
              paddingRight: "5px"
            }, "".concat(value ? value.valueOf ? value.valueOf() : valueString : "No Color"), {
              onMouseDown: handler
            }]);
          }
        }, {
          key: "renderItSomehow",
          value: function PropertyControl_renderItSomehow_(args) {
            var valueString = args.valueString;
            return [].concat(_toConsumableArray$1(this.renderGrabbableKey(args, false)), [" ".concat(valueString), {}]);
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/inspector/index.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 2803,
          end: 16666
        });
      }(__varRecorder__$1.DraggableTreeLabel);
      __varRecorder__$1.PropertyControl = PropertyControl;
      __varRecorder__$1.PropertyControl = PropertyControl;
      var Inspector = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/index.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("Inspector") && typeof __lively_classholder__.Inspector === "function" ? __lively_classholder__.Inspector : __lively_classholder__.Inspector = function Inspector(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "attach",
          value: function Inspector_attach_(view) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "attach", this).call(this, view);

            var self = this;
            var _this$ui = this.ui,
                codeEditor = _this$ui.codeEditor,
                thisBindingSelector = _this$ui.thisBindingSelector,
                propertyTree = _this$ui.propertyTree;
            var rightArrow = Icon.textAttribute("long-arrow-alt-right", {
              paddingTop: "2px"
            });
            thisBindingSelector.items = [{
              isListItem: true,
              value: "target",
              label: ["this ", null].concat(_toConsumableArray$1(rightArrow), [" target", null])
            }, {
              isListItem: true,
              value: "selection",
              label: ["this ", null].concat(_toConsumableArray$1(rightArrow), [" selection", null])
            }];
            codeEditor.changeEditorMode("js").then(function () {
              return codeEditor.evalEnvironment = {
                targetModule: "lively://lively.morphic/inspector",

                get context() {
                  return thisBindingSelector.selection === "selection" ? self.selectedContext : self.targetObject;
                },

                get systemInterface() {
                  return Path("treeData.systemInterface").get(propertyTree);
                },

                format: "esm"
              };
            })["catch"](function (err) {
              return $world.logError(err);
            });
          }
        }, {
          key: "viewDidLoad",
          value: function Inspector_viewDidLoad_() {
            this.prepareForNewTargetObject(this.targetObject);
          }
        }, {
          key: "fixUndeclaredVariables",
          value: function Inspector_fixUndeclaredVariables_() {
            this.ui.codeEditor.execCommand("[javascript] fix undeclared variables", {
              autoApplyIfSingleChoice: true
            });
          }
        }, {
          key: "renderDraggableTreeLabel",
          value: function Inspector_renderDraggableTreeLabel_(args) {
            return new __varRecorder__$1.DraggableTreeLabel(args);
          }
        }, {
          key: "renderPropertyControl",
          value: function Inspector_renderPropertyControl_(args) {
            return __varRecorder__$1.PropertyControl.render(args);
          }
        }, {
          key: "onWindowClose",
          value: function Inspector_onWindowClose_() {
            this.view.stopStepping();
            this.ui.propertyTree.treeData.dispose();
            this.openWidget && this.closeOpenWidget();
          }
        }, {
          key: "refreshSelectedLine",
          value: function Inspector_refreshSelectedLine_() {
            var row = this.ui.propertyTree.selectedIndex - 1;
            var selectedNode = this.ui.propertyTree.selectedNode;
            this.ui.propertyTree.selectedNode.refreshProperty();
            var newLine = this.ui.propertyTree.document.getLine(row).textAndAttributes.slice(0, 4).concat(selectedNode.display(this));
            var lineRange = this.ui.propertyTree.lineRange(row, false);
            this.ui.propertyTree.replace(lineRange, newLine, false, false, false);
            this.ui.propertyTree.selectedNode = this.ui.propertyTree.selectedNode;
          }
        }, {
          key: "refreshAllProperties",
          value: function Inspector_refreshAllProperties_() {
            if (!this.world()) this.stopStepping();

            if (!this.targetObject || !this.targetObject.isMorph) {
              this.stopStepping();
              return;
            }

            if (this.targetObject._styleSheetProps !== this.lastStyleSheetProps) {
              this.refreshTreeView();
              this.lastStyleSheetProps = this.targetObject._styleSheetProps;
              return;
            }

            var change = last$2(this.targetObject.env.changeManager.changesFor(this.targetObject));

            if (change === this.lastChange && this.lastSubmorphs === printValue(this.targetObject && this.targetObject.submorphs)) {
              return;
            }

            this.lastChange = change;
            this.lastSubmorphs = printValue(this.targetObject && this.targetObject.submorphs);
            this.refreshTreeView();
          }
        }, {
          key: "refreshTreeView",
          value: function Inspector_refreshTreeView_() {
            var v;
            this.originalTreeData && this.originalTreeData.asListWithIndexAndDepth(false).forEach(function (_ref9) {
              var node = _ref9.node;
              if (!node.target) return;

              if (node.foldableNode) {
                v = node.target[node.foldableNode.key][node.key];
              } else {
                v = node.target[node.key];
              }

              if (!equals(v, node.value) && node.refreshProperty) {
                node.refreshProperty(v);
              }
            });
            this.ui.propertyTree.update(true);
            this.ui.propertyTree.doNotAcceptDropsForThisAndSubmorphs();
          }
        }, {
          key: "prepareForNewTargetObject",
          value: function () {
            var _Inspector_prepareForNewTargetObject_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(target) {
              var remote,
                  _promise$deferred,
                  p,
                  animated,
                  li,
                  td,
                  tree,
                  changedNodes,
                  _iterator,
                  _step,
                  _step$value,
                  curr,
                  upd,
                  _args7 = arguments;

              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      remote = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : false;

                      if (!this.isUpdating()) {
                        _context7.next = 4;
                        break;
                      }

                      _context7.next = 4;
                      return this.whenUpdated();

                    case 4:
                      _promise$deferred = deferred(), p = _promise$deferred.promise;
                      animated = !!this.target;
                      this.updateInProgress = p;
                      _context7.prev = 7;
                      if (remote) li = open$1("connecting to remote...");

                      if (!remote) {
                        _context7.next = 15;
                        break;
                      }

                      _context7.next = 12;
                      return RemoteInspectionTree.forObject(target, this);

                    case 12:
                      _context7.t0 = _context7.sent;
                      _context7.next = 16;
                      break;

                    case 15:
                      _context7.t0 = InspectionTree.forObject(target, this);

                    case 16:
                      td = _context7.t0;
                      tree = this.ui.propertyTree;
                      _context7.next = 20;
                      return td.collapse(td.root, false);

                    case 20:
                      if (!td.root.children) {
                        _context7.next = 23;
                        break;
                      }

                      _context7.next = 23;
                      return td.collapse(td.root.children[0], false);

                    case 23:
                      changedNodes = this.originalTreeData && this.originalTreeData.diff(td);

                      if (!changedNodes) {
                        _context7.next = 29;
                        break;
                      }

                      _iterator = _createForOfIteratorHelper(changedNodes);

                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                          _step$value = _slicedToArray(_step.value, 2), curr = _step$value[0], upd = _step$value[1];
                          curr.refreshProperty(upd.value);
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }

                      _context7.next = 38;
                      break;

                    case 29:
                      tree.treeData = td;
                      _context7.next = 32;
                      return this.filterProperties();

                    case 32:
                      if (!tree.treeData.root.isCollapsed) {
                        _context7.next = 36;
                        break;
                      }

                      _context7.next = 35;
                      return tree.onNodeCollapseChanged({
                        node: td.root,
                        isCollapsed: false
                      });

                    case 35:
                      tree.selectedIndex = 1;

                    case 36:
                      _context7.next = 38;
                      return tree.execCommand("uncollapse selected node");

                    case 38:
                      this.toggleWindowStyle(animated);
                      if (li) li.remove();
                      _context7.next = 45;
                      break;

                    case 42:
                      _context7.prev = 42;
                      _context7.t1 = _context7["catch"](7);
                      this.view.showError(_context7.t1);

                    case 45:
                      this.view.startStepping(1000, "refreshAllProperties");
                      this.updateInProgress = null;

                    case 47:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7, this, [[7, 42]]);
            }));

            function Inspector_prepareForNewTargetObject_(_x7) {
              return _Inspector_prepareForNewTargetObject_.apply(this, arguments);
            }

            return Inspector_prepareForNewTargetObject_;
          }()
        }, {
          key: "toggleWindowStyle",
          value: function () {
            var _Inspector_toggleWindowStyle_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
              var animated,
                  duration,
                  theme,
                  styleClasses,
                  codeEditor,
                  editorPlugin,
                  window,
                  _args8 = arguments;
              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      animated = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : true;
                      duration = 300;
                      codeEditor = this.ui.codeEditor;
                      editorPlugin = codeEditor.pluginFind(function (p) {
                        return p.runEval;
                      });
                      window = this.view.getWindow();
                      _context8.next = 7;
                      return editorPlugin.runEval("System.get('@system-env').node");

                    case 7:
                      if (!_context8.sent.value) {
                        _context8.next = 12;
                        break;
                      }

                      styleClasses = [].concat(_toConsumableArray$1(without$1(window.styleClasses, "local")), ["node"]);
                      theme = DarkTheme.instance;
                      _context8.next = 14;
                      break;

                    case 12:
                      styleClasses = ["local"].concat(_toConsumableArray$1(window ? without$1(window.styleClasses, "node") : []));
                      theme = DefaultTheme.instance;

                    case 14:
                      editorPlugin.theme = theme;

                      if (animated) {
                        window && window.animate({
                          duration: duration,
                          styleClasses: styleClasses
                        });
                        codeEditor.animate({
                          fill: theme.background,
                          duration: duration
                        });
                      } else {
                        if (window) window.styleClasses = styleClasses;
                      }

                      codeEditor.textString = codeEditor.textString;
                      editorPlugin.highlight();

                    case 18:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, this);
            }));

            function Inspector_toggleWindowStyle_() {
              return _Inspector_toggleWindowStyle_.apply(this, arguments);
            }

            return Inspector_toggleWindowStyle_;
          }()
        }, {
          key: "isUpdating",
          value: function Inspector_isUpdating_() {
            return !!this.updateInProgress;
          }
        }, {
          key: "whenUpdated",
          value: function Inspector_whenUpdated_() {
            return this.updateInProgress || Promise.resolve();
          }
        }, {
          key: "focus",
          value: function Inspector_focus_() {
            this.ui.codeEditor.focus();
          }
        }, {
          key: "selectTarget",
          value: function () {
            var _Inspector_selectTarget_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
              var newTarget, _yield$$world$execCom, _yield$$world$execCom2;

              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      this.closeOpenWidget();

                      if (!this.view.env.eventDispatcher.isKeyPressed("Shift")) {
                        _context9.next = 9;
                        break;
                      }

                      _context9.next = 4;
                      return $world.execCommand("select morph", {
                        filterFn: function filterFn(m) {
                          return $world.morphsInWorldWithSubmorphs.concat([$world]).includes(m);
                        },
                        justReturn: true
                      });

                    case 4:
                      _yield$$world$execCom = _context9.sent;
                      _yield$$world$execCom2 = _slicedToArray(_yield$$world$execCom, 1);
                      newTarget = _yield$$world$execCom2[0];
                      _context9.next = 14;
                      break;

                    case 9:
                      this.toggleSelectionInstructions(true);
                      _context9.next = 12;
                      return InteractiveMorphSelector.selectMorph();

                    case 12:
                      newTarget = _context9.sent;
                      this.toggleSelectionInstructions(false);

                    case 14:
                      if (newTarget) this.targetObject = newTarget;

                    case 15:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, this);
            }));

            function Inspector_selectTarget_() {
              return _Inspector_selectTarget_.apply(this, arguments);
            }

            return Inspector_selectTarget_;
          }()
        }, {
          key: "toggleSelectionInstructions",
          value: function Inspector_toggleSelectionInstructions_(active) {
            if (active && !this.instructionWidget) {
              this.instructionWidget = this.view.addMorph(part(InstructionWidget, {
                isLayoutable: false,
                opacity: 0,
                clipMode: "hidden",
                center: this.view.extent.scaleBy(0.5)
              }));
              this.instructionWidget.animate({
                opacity: 1,
                duration: 200
              });
            } else {
              this.instructionWidget.fadeOut(200);
              this.instructionWidget = null;
            }
          }
        }, {
          key: "closeOpenWidget",
          value: function Inspector_closeOpenWidget_() {
            var _this$openWidget;

            (_this$openWidget = this.openWidget) === null || _this$openWidget === void 0 ? void 0 : _this$openWidget.close();
            this.openWidget = null;
          }
        }, {
          key: "adjustProportions",
          value: function Inspector_adjustProportions_(evt) {
            var layout = this.view.layout;
            layout.row(1).height = Math.max(50, layout.row(1).height + evt.state.dragDelta.y);
            layout.row(3).height = Math.min(this.view.height - 50, layout.row(3).height - evt.state.dragDelta.y);
          }
        }, {
          key: "isEditorVisible",
          value: function Inspector_isEditorVisible_() {
            return this.ui.codeEditor.height > 10;
          }
        }, {
          key: "makeEditorVisible",
          value: function Inspector_makeEditorVisible_(show) {
            var _this2 = this;

            if (show === this.isEditorVisible()) return;
            var _this$view = this.view,
                prevExtent = _this$view.extent,
                layout = _this$view.layout;
            var _this$ui2 = this.ui,
                terminalToggler = _this$ui2.terminalToggler,
                codeEditor = _this$ui2.codeEditor,
                thisBindingSelector = _this$ui2.thisBindingSelector,
                fixImportButton = _this$ui2.fixImportButton;
            var duration = 200;
            layout.disable();
            this.withoutBindingsDo(function () {
              if (show) {
                terminalToggler.fontColor = Color.rgbHex("00e0ff");
                layout.row(3).height = _this2.codeEditorHeight || 180;
                layout.row(2).height = 5;
                fixImportButton.animate({
                  visible: true,
                  duration: duration
                });
                thisBindingSelector.animate({
                  visible: true,
                  duration: duration
                });
              } else {
                _this2.codeEditorHeight = layout.row(3).height;
                terminalToggler.fontColor = Color.white;
                layout.row(3).height = layout.row(2).height = 0;
                fixImportButton.animate({
                  visible: false,
                  duration: duration
                });
                thisBindingSelector.animate({
                  visible: false,
                  duration: duration
                });
              }

              _this2.view.extent = prevExtent;
            });
            layout.enable({
              duration: duration
            });
            this.relayout({
              duration: duration
            });
            codeEditor.focus();
            codeEditor.animate({
              opacity: show ? 1 : 0,
              duration: duration
            });
          }
        }, {
          key: "toggleCodeEditor",
          value: function () {
            var _Inspector_toggleCodeEditor_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      this.makeEditorVisible(!this.isEditorVisible());

                    case 1:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, this);
            }));

            function Inspector_toggleCodeEditor_() {
              return _Inspector_toggleCodeEditor_.apply(this, arguments);
            }

            return Inspector_toggleCodeEditor_;
          }()
        }, {
          key: "filterProperties",
          value: function () {
            var _Inspector_filterProperties_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
              var searchField, tree;
              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      searchField = this.ui.searchField;
                      tree = this.ui.propertyTree;

                      if (!this.originalTreeData) {
                        this.originalTreeData = tree.treeData;
                      }

                      _context11.next = 5;
                      return tree.treeData.filter({
                        maxDepth: 2,
                        showUnknown: this.ui.unknowns.checked,
                        showInternal: this.ui.internals.checked,
                        iterator: function iterator(node) {
                          return searchField.matches(node.key);
                        }
                      });

                    case 5:
                      tree.update();

                    case 6:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11, this);
            }));

            function Inspector_filterProperties_() {
              return _Inspector_filterProperties_.apply(this, arguments);
            }

            return Inspector_filterProperties_;
          }()
        }, {
          key: "onViewResized",
          value: function Inspector_onViewResized_(newExt) {
            if (!this._lastExtent || !this._lastExtent.equals(newExt)) {
              this.view.env.forceUpdate();
              this.relayout();
            }

            if (this.world()) this._lastExtent = newExt;
          }
        }, {
          key: "relayout",
          value: function Inspector_relayout_() {
            var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var _this$ui3 = this.ui;
                _this$ui3.fixImportButton;
                var toggler = _this$ui3.terminalToggler,
                tree = _this$ui3.propertyTree;
                _this$ui3.thisBindingSelector;
                var editorControlsWrapper = _this$ui3.editorControlsWrapper,
                layout = this.view.layout;
            layout && layout.forceLayout();
            editorControlsWrapper.width = tree.bounds().width;
            toggler.visible = !!this.world();

            if (animated.duration) {
              editorControlsWrapper.animate(Object.assign({
                bottomLeft: tree.bounds().bottomLeft()
              }, animated));
            } else {
              editorControlsWrapper.bottomLeft = tree.bounds().bottomLeft();
            }
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "Inspector";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              _serializableTarget: {
                defaultValue: null
              },
              remoteTarget: {
                set: function set(obj) {
                  this.setProperty("remoteTarget", obj);
                  if (!this.ui.propertyTree) return;
                  this.originalTreeData = null;
                  this.prepareForNewTargetObject(obj, true);
                }
              },
              targetObject: {
                set: function set(obj) {
                  this._serializableTarget = obj && obj.isMorph ? obj.id : obj;
                  this.setProperty("targetObject", obj);
                  if (!this.ui.propertyTree) return;
                  this.originalTreeData = null;
                  this.prepareForNewTargetObject(obj);
                }
              },
              selectedContext: {
                readOnly: true,
                derived: true,
                get: function get() {
                  var _this$ui$propertyTree = this.ui.propertyTree,
                      selectedNode = _this$ui$propertyTree.selectedNode,
                      treeData = _this$ui$propertyTree.treeData;
                  return treeData.getContextFor(selectedNode || treeData.root);
                }
              },
              originalTreeData: {
                serialize: false
              },
              updateInProgress: {
                defaultValue: false,
                serialize: false
              },
              expose: {
                get: function get() {
                  return ["isInspector", "onWindowClose", "commands", "keybindings", "openWidget", "targetObject", "relayout"];
                }
              },
              isInspector: {
                get: function get() {
                  return true;
                }
              },
              keybindings: {
                get: function get() {
                  return [{
                    keys: "Alt-Up",
                    command: "focus propertyTree"
                  }, {
                    keys: "Alt-Down",
                    command: "focus codeEditor"
                  }, {
                    keys: "F1",
                    command: "focus propertyTree"
                  }, {
                    keys: "F2",
                    command: "focus codeEditor"
                  }];
                }
              },
              commands: {
                get: function get() {
                  return __varRecorder__$1.inspectorCommands;
                }
              },
              openWidget: {
                set: function set(widget) {
                  var _this$openWidget2;

                  (_this$openWidget2 = this.openWidget) === null || _this$openWidget2 === void 0 ? void 0 : _this$openWidget2.close();
                  this.setProperty("openWidget", widget);
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "target picker",
                    signal: "onMouseUp",
                    handler: "selectTarget",
                    override: false
                  }, {
                    target: "property tree",
                    signal: "onScroll",
                    handler: "closeOpenWidget"
                  }, {
                    target: "resizer",
                    signal: "onDrag",
                    handler: "adjustProportions",
                    override: false
                  }, {
                    target: "terminal toggler",
                    signal: "onMouseDown",
                    handler: "toggleCodeEditor",
                    override: false
                  }, {
                    target: "unknowns",
                    signal: "checked",
                    handler: "filterProperties",
                    override: false
                  }, {
                    target: "internals",
                    signal: "checked",
                    handler: "filterProperties",
                    override: false
                  }, {
                    target: "search field",
                    signal: "searchInput",
                    handler: "filterProperties",
                    override: false
                  }, {
                    target: "property tree",
                    signal: "nodeCollapseChanged",
                    handler: "filterProperties",
                    override: false
                  }, {
                    target: "fix import button",
                    signal: "fire",
                    handler: "fixUndeclaredVariables",
                    override: false
                  }, {
                    signal: "extent",
                    handler: "onViewResized",
                    override: false
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/inspector/index.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 16921,
          end: 30027
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$1.Inspector = Inspector;
      __varRecorder__$1.Inspector = Inspector;

      var __varRecorder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/ui.cp.js", __contextModule__);
      var __moduleMeta__ = {
        pathInPackage: function pathInPackage() {
          return "./js/inspector/ui.cp.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ide",
            version: "0.1.0"
          };
        }
      };

      var openInWindow = __varRecorder__["lively.ide/js/inspector/ui.cp.js__define__"]("openInWindow", "function", function (modelAttributes) {
        var inspector = part(__varRecorder__.SystemInspector, {
          viewModel: modelAttributes
        });
        var w = inspector.openInWindow();
        inspector.env.forceUpdate();
        inspector.relayout();
        w.title = "Inspector for ".concat(inspector.targetObject.name);
        return inspector;
      }, __moduleMeta__);

      __varRecorder__.openInWindow = openInWindow;

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ide/js/inspector/ui.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DraggedPropMorph") && typeof __lively_classholder__.DraggedPropMorph === "function" ? __lively_classholder__.DraggedPropMorph : __lively_classholder__.DraggedPropMorph = function DraggedPropMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "applyToTarget",
          value: function DraggedPropMorph_applyToTarget_(evt) {
            var target = this.currentTarget,
                control = this.control;
            this.remove();
            MorphHighlighter.removeHighlighters(evt.world);
            if (!target) return;

            if (!target.isText || target.editorModeName !== "js") {
              if ("propertyValue" in control) {
                target[control.keyString] = control.propertyValue;
              }

              return;
            }

            var editor = target;
            var toObject = editor.evalEnvironment.context;
            var textPos = editor.textPositionFromPoint(editor.localize(evt.position));
            var expr = generateReferenceExpression(this.sourceObject, {
              fromMorph: toObject
            });
            if (control.keyString) expr += "." + control.keyString;
            editor.insertTextAndSelect(expr, textPos);
            editor.focus();
          }
        }, {
          key: "update",
          value: function DraggedPropMorph_update_(evt) {
            var handPosition = evt.hand.globalPosition;
            var target = this.morphBeneath(handPosition);
            if (!target) return;

            if (target === this.morphHighlighter) {
              target = target.morphBeneath(handPosition);
            }

            while ([target].concat(_toConsumableArray$1(target.ownerChain())).find(function (m) {
              return !m.visible;
            })) {
              target = target.morphBeneath(handPosition);
            }

            if (target !== this.currentTarget) {
              this.currentTarget = target;
              if (this.morphHighlighter) this.morphHighlighter.deactivate();
              if (target.isWorld) return;
              this.morphHighlighter = MorphHighlighter["for"]($world, target);
              this.morphHighlighter.show();
            }

            this.position = handPosition;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DraggedPropMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              control: {
                after: ["submorphs"],
                set: function set(control) {
                  this.setProperty("control", control);
                  if (!control) return this.submorphs = [];
                  this.submorphs = [control];
                  control.fontSize = 14;

                  if (typeof control.relayout === "function") {
                    control.relayout();
                  }
                }
              },
              sourceObject: {}
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./js/inspector/ui.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "lively.ide",
              version: "0.1.0"
            };
          }
        }, {
          start: 679,
          end: 2726
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      __varRecorder__.DraggedProp = component["for"](function () {
        return component({
          type: __varRecorder__.DraggedPropMorph,
          clipMode: "hidden",
          origin: pt(10, 10),
          extent: pt(151.3, 41.9),
          fill: Color.rgba(255, 255, 251, 0.8),
          borderWidth: 2,
          borderColor: Color.rgb(169, 204, 227),
          borderRadius: 4,
          layout: new TilingLayout({
            align: "right",
            hugContentsHorizontally: true,
            hugContentsVertically: true,
            padding: rect(5, 0, 0, 5)
          }),
          submorphs: [{
            type: Text,
            name: "some placeholer control",
            dynamicCursorColoring: true,
            fill: Color.rgba(255, 255, 255, 0),
            position: pt(25.3, 12.6),
            textAndAttributes: ["I am a control!", null]
          }]
        });
      }, {
        module: "lively.ide/js/inspector/ui.cp.js",
        "export": "DraggedProp",
        range: {
          start: 2741,
          end: 3363
        }
      }, System, __varRecorder__, "DraggedProp");
      var DraggedProp = __varRecorder__.DraggedProp;
      __varRecorder__.DraggedProp = DraggedProp;
      __varRecorder__.InstructionWidget = component["for"](function () {
        return component({
          type: Text,
          fixedWidth: true,
          fixedHeight: true,
          lineWrapping: "by-words",
          name: "instruction widget",
          fontSize: 13,
          borderRadius: 3,
          padding: rect(10, 10, 0, 0),
          fill: Color.rgba(0, 0, 0, 0.75),
          fontColor: Color.rgb(255, 255, 255),
          fontFamily: "IBM Plex Sans",
          extent: pt(140, 135),
          textAndAttributes: ["Select a new morph to inspect by hovering over it and clicking left. You can exit this mode by pressing ", {}, morph({
            type: "label",
            name: "escapeKey",
            borderRadius: 5,
            borderWidth: 1,
            padding: rect(5, 0, 0, 2),
            fontWeight: "bold",
            fontColor: Color.rgb(255, 255, 255),
            position: pt(62.5, 100.9),
            value: "esc"
          }), {}]
        });
      }, {
        module: "lively.ide/js/inspector/ui.cp.js",
        "export": "InstructionWidget",
        range: {
          start: 3372,
          end: 4129
        }
      }, System, __varRecorder__, "InstructionWidget");
      __varRecorder__.SmallList = component["for"](function () {
        return component(DarkList, {
          fontSize: 10
        });
      }, {
        module: "lively.ide/js/inspector/ui.cp.js",
        "export": "SmallList",
        range: {
          start: 4138,
          end: 4189
        }
      }, System, __varRecorder__, "SmallList");
      __varRecorder__.DarkDropDownList = component["for"](function () {
        return component(DarkButton, {
          defaultViewModel: DropDownListModel,
          name: "dark drop down list",
          submorphs: [{
            name: "label",
            fontSize: 12
          }]
        });
      }, {
        module: "lively.ide/js/inspector/ui.cp.js",
        "export": "DarkDropDownList",
        range: {
          start: 4198,
          end: 4360
        }
      }, System, __varRecorder__, "DarkDropDownList");
      __varRecorder__.SystemInspector = component["for"](function () {
        return component({
          defaultViewModel: Inspector,
          name: "system inspector",
          extent: pt(365.9, 502.7),
          fill: Color.transparent,
          layout: new GridLayout({
            autoAssign: false,
            grid: [["search bar"], ["property tree"], ["resizer"], ["code editor"]],
            groups: {
              "search bar": {
                align: "topLeft",
                resize: true
              },
              "property tree": {
                align: "topLeft",
                resize: true
              },
              resizer: {
                align: "topLeft",
                resize: true
              },
              "code editor": {
                align: "topLeft",
                resize: true
              }
            },
            rows: [0, {
              fixed: 30
            }, 1, {
              height: 375
            }, 2, {
              fixed: 0
            }, 3, {
              fixed: 0
            }]
          }),
          submorphs: [{
            name: "search bar",
            fill: Color.rgba(0, 0, 0, 0),
            layout: new GridLayout({
              autoAssign: false,
              grid: [["search field", "target picker", "internals", "unknowns"]],
              groups: {
                "search field": {
                  align: "topLeft",
                  resize: true
                },
                "target picker": {
                  align: "topLeft",
                  resize: true
                },
                internals: {
                  align: "topLeft",
                  resize: true
                },
                unknowns: {
                  align: "topLeft",
                  resize: true
                }
              },
              columns: [0, {
                paddingLeft: 5,
                paddingRight: 2,
                width: 100
              }, 1, {
                fixed: 22
              }, 2, {
                fixed: 80
              }, 3, {
                fixed: 90,
                paddingRight: 5
              }],
              rows: [0, {
                height: 30,
                paddingBottom: 3,
                paddingTop: 3
              }]
            }),
            submorphs: [part(SearchField, {
              viewModel: {
                placeholder: "Search"
              },
              name: "search field"
            }), part(SystemButton, {
              viewModel: {
                label: {
                  value: Icon.textAttribute("crosshairs")
                }
              },
              name: "target picker",
              borderRadius: 20,
              padding: rect(2, 2, 0, 0),
              tooltip: "Change Inspection Target"
            }), part(LabeledCheckboxLight, {
              viewModel: {
                label: "internals",
                align: "center"
              },
              name: "internals"
            }), part(LabeledCheckboxLight, {
              viewModel: {
                label: "unknowns",
                align: "center"
              },
              name: "unknowns"
            })]
          }, {
            type: PropertyTree,
            name: "property tree",
            fill: Color.white,
            borderColor: Color.rgb(204, 204, 204),
            borderWidth: 1,
            clipMode: "hidden",
            draggable: true,
            selectable: true,
            fontFamily: "\"IBM Plex Mono\"",
            fontSize: 14,
            treeData: {}
          }, {
            name: "resizer",
            draggable: true,
            fill: Color.rgb(230, 230, 230),
            nativeCursor: "ns-resize"
          }, Object.assign({
            type: Text,
            name: "code editor",
            readOnly: false,
            borderRadius: {
              topLeft: 0,
              topRight: 0,
              bottomRight: 6,
              bottomLeft: 6
            },
            fixedWidth: true,
            fixedHeight: true,
            lineWrapping: "by-chars",
            padding: rect(4, 2, 0, 0)
          }, config$2.codeEditor.defaultStyle), {
            name: "editor controls wrapper",
            extent: pt(365.1, 24.9),
            layout: new TilingLayout({
              padding: rect(5, 0, 0, 0),
              resizePolicies: [["filler", {
                height: "fixed",
                width: "fill"
              }]],
              spacing: 5
            }),
            reactsToPointer: false,
            fill: Color.transparent,
            submorphs: [{
              type: Label,
              master: DarkButton,
              name: "terminal toggler",
              position: pt(7.3, 572.6),
              extent: pt(27, 19),
              fontColor: Color.white,
              nativeCursor: "pointer",
              lineHeight: 1,
              fontSize: 15,
              padding: rect(4, 2, 0, 0),
              textAndAttributes: Icon.textAttribute("keyboard")
            }, {
              name: "filler",
              reactsToPointer: false,
              fill: Color.rgba(255, 255, 255, 0),
              extent: pt(103.7, 19.1),
              position: pt(569.6, 716.2)
            }, part(__varRecorder__.DarkDropDownList, {
              viewModel: {
                listAlign: "top",
                smartDropDown: false,
                label: "this -> target",
                openListInWorld: true,
                listMaster: __varRecorder__.SmallList,
                listOffset: pt(0, -5)
              },
              name: "this binding selector",
              position: pt(92.2, 571.2),
              extent: pt(120, 22),
              visible: false
            }), part(DarkButton, {
              viewModel: {
                label: {
                  value: "fix undeclared vars",
                  fontSize: 12
                }
              },
              name: "fix import button",
              position: pt(221.4, 570.8),
              extent: pt(136, 22),
              visible: false
            })]
          }]
        });
      }, {
        module: "lively.ide/js/inspector/ui.cp.js",
        "export": "SystemInspector",
        range: {
          start: 4369,
          end: 8900
        }
      }, System, __varRecorder__, "SystemInspector");
      var DarkDropDownList = __varRecorder__.DarkDropDownList;
      var SystemInspector = __varRecorder__.SystemInspector;
      var InstructionWidget = __varRecorder__.InstructionWidget;
      __varRecorder__.DarkButton = DarkButton;
      __varRecorder__.DarkDropDownList = DarkDropDownList;
      __varRecorder__.SystemInspector = SystemInspector;
      __varRecorder__.InstructionWidget = InstructionWidget;
      __varRecorder__.openInWindow = openInWindow;

      var ui_cp = /*#__PURE__*/Object.freeze({
        __proto__: null,
        DraggedProp: DraggedProp,
        DarkButton: DarkButton,
        DarkDropDownList: DarkDropDownList,
        SystemInspector: SystemInspector,
        InstructionWidget: InstructionWidget,
        openInWindow: openInWindow
      });
      exports('ai', ui_cp);

      exports('$', _missingExportShim);

    })
  };
}));
