System.register(['./__rootModule___commonjs-entry-b4b3f14a.js', './index-86a2e14d.js', './index-a20680f1.js', './ui.cp-56bd45de.js', './list.cp-2ad57db4.js', './loading-indicator.cp-0c52e0d6.js', './canvas-c6825fb4.js', './index-0fa033b8.js', './index-c2e1ab78.js', './messages.cp-333e9a76.js', './code-search.cp-b272b96c.js', './client-38471ced.js', './editor-modes-3f03bbff.js', './search-9f87f96e.js', './shell-interface-5e92d3e1.js', './client-command-eac125c5.js', './index-009b6510.js', './client-resource-7725075c.js', './editor-plugin-c8567fde.js', './dialogs.cp-2718d623.js', './morph-to-image-88f22258.js', './object-classes-637c5b0b.js'], (function (exports) {
  var __contextModule__ = typeof module !== 'undefined' ? module : arguments[1];
;
  var component, Color$1, initializeClass, part, ViewModel, Morph, connect, pt, sortBy, equals, interpolate$1, clamp, rect, TilingLayout, ShadowObject, Text, _toConsumableArray, add, Image, Label, Icon, LinearGradient, without, _asyncToGenerator, easings, Ellipse, _createForOfIteratorHelper, _typeof, signal, _createClass, _defineProperty, _classCallCheck, HTMLMorph, copy, _slicedToArray, dateFormat, range, groupBy, min, max, last, first, noUpdate, compact, debounceNamed, _inherits, _createSuper, _get, _getPrototypeOf, resource, loadViaScript, isString, ExpressionSerializer, Point, Rectangle, morph, md5, getClassName, createMorphSnapshot, _missingExportShim$1, Polygon, TopBarModel, TopBar, FillControl, ConstraintMarker, ConstraintMarkerActive, ConstraintsSimulator, ConstraintSizeSelectorDefault, _missingExportShim, ConstraintsManager, MiniLayoutPreview, AutoLayoutAlignmentFlap, MiniLayoutPreviewActive, LayoutControl, BorderPopup, BorderControl, BodyControlModel, DynamicProperty, ShapeControl, PropertiesPanelModel, PropertiesPanel, LivelyWorld, CheckboxChecked, CheckboxUnchecked, DropDownListModel, MorphList, ConfirmPromptModel, InputLineDefault, InputLine, TextInput, DarkNumberIconWidget, EnumSelector, AddButton, PropertyLabel, PropertyLabelActive, PropertyLabelHovered, ColorInput, SystemList, PropertySection, ShadowPopup, OpacityPopup, BlurPopup, CursorPopup, TiltPopup, FlipPopup, PaddingControlsLight, RichTextControl, ColorPicker, Halo, DropDownList, DefaultList, ButtonModel, open, Canvas;
  return {
    setters: [function (module) {
      component = module.c;
      Color$1 = module.C;
      initializeClass = module.i;
      part = module.p;
      ViewModel = module.V;
      Morph = module.M;
      connect = module.a;
      pt = module.b;
      sortBy = module.aP;
      equals = module.af;
      interpolate$1 = module.aM;
      clamp = module.cc;
      rect = module.ap;
      TilingLayout = module.T;
      ShadowObject = module.ao;
      Text = module.j;
      _toConsumableArray = module.r;
      add = module.ar;
      Image = module.I;
      Label = module.L;
      Icon = module.h;
      LinearGradient = module.au;
      without = module.as;
      _asyncToGenerator = module._;
      easings = module.az;
      Ellipse = module.aC;
      _createForOfIteratorHelper = module.a6;
      _typeof = module.a5;
      signal = module.s;
      _createClass = module.g;
      _defineProperty = module.ah;
      _classCallCheck = module.f;
      HTMLMorph = module.al;
      copy = module.dQ;
      _slicedToArray = module.o;
      dateFormat = module.dR;
      range = module.aO;
      groupBy = module.be;
      min = module.b1;
      max = module.av;
      last = module.q;
      first = module.bJ;
      noUpdate = module.b5;
      compact = module.aT;
      debounceNamed = module.z;
      _inherits = module.d;
      _createSuper = module.e;
      _get = module.b$;
      _getPrototypeOf = module.c0;
      resource = module.ac;
      loadViaScript = module.dS;
      isString = module.bv;
      ExpressionSerializer = module.br;
      Point = module.bu;
      Rectangle = module.R;
      morph = module.aZ;
      md5 = module.dT;
      getClassName = module.bi;
      createMorphSnapshot = module.aV;
      _missingExportShim$1 = module.dU;
      Polygon = module.bf;
    }, function (module) {
      TopBarModel = module.T;
      TopBar = module.a;
      FillControl = module.F;
      ConstraintMarker = module.C;
      ConstraintMarkerActive = module.b;
      ConstraintsSimulator = module.c;
      ConstraintSizeSelectorDefault = module.d;
      _missingExportShim = module._;
      ConstraintsManager = module.e;
      MiniLayoutPreview = module.M;
      AutoLayoutAlignmentFlap = module.A;
      MiniLayoutPreviewActive = module.f;
      LayoutControl = module.L;
      BorderPopup = module.B;
      BorderControl = module.g;
      BodyControlModel = module.h;
      DynamicProperty = module.D;
      ShapeControl = module.S;
      PropertiesPanelModel = module.P;
      PropertiesPanel = module.i;
      LivelyWorld = module.j;
    }, function (module) {
      CheckboxChecked = module.t;
      CheckboxUnchecked = module.u;
      DropDownListModel = module.r;
      MorphList = module.M;
      ConfirmPromptModel = module.s;
      InputLineDefault = module.d;
      InputLine = module.I;
    }, function (module) {
      TextInput = module.T;
      DarkNumberIconWidget = module.k;
      EnumSelector = module.c;
      AddButton = module.A;
      PropertyLabel = module.K;
      PropertyLabelActive = module.m;
      PropertyLabelHovered = module.q;
      ColorInput = module.w;
      SystemList = module.b;
      PropertySection = module.p;
      ShadowPopup = module.y;
      OpacityPopup = module.O;
      BlurPopup = module.B;
      CursorPopup = module.G;
      TiltPopup = module.H;
      FlipPopup = module.J;
      PaddingControlsLight = module.Z;
      RichTextControl = module.Q;
      ColorPicker = module._;
      Halo = module.U;
    }, function (module) {
      DropDownList = module.D;
      DefaultList = module.b;
    }, function (module) {
      ButtonModel = module.c;
      open = module.o;
    }, function (module) {
      Canvas = module.C;
    }, function () {}, function () {}, function () {}, function () {}, function () {}, function () {}, function () {}, function () {}, function () {}, function () {}, function () {}, function () {}, function () {}, function () {}, function () {}],
    execute: (function () {

      var __varRecorder__$v = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.project/helpers.js", __contextModule__);

      var __moduleMeta__$1 = {
        pathInPackage: function pathInPackage() {
          return "./helpers.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.project",
            version: "0.1.0"
          };
        }
      };

      var projectAsset = __varRecorder__$v["lively.project/helpers.js__define__"]("projectAsset", "function", function (fileName) {
        if (lively.FreezerRuntime) {
          return "./assets/" + fileName;
        }

        var callStack = new Error().stack;
        var callingProject = callStack.match(new RegExp("\\(.*\\/local_projects\\/(?<callingProject>[a-zA-Z_\\-\\d]+)\\/.*\\.js")).groups.callingProject;
        return "/local_projects/" + callingProject + "/assets/" + fileName;
      }, __moduleMeta__$1);

      __varRecorder__$v.projectAsset = projectAsset;
      __varRecorder__$v.projectAsset = projectAsset;

      var __varRecorder__$u = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/shared.cp.js", __contextModule__);
      __varRecorder__$u.galyleoFont = "Noto Sans";
      __varRecorder__$u.GalyleoCheckboxChecked = component["for"](function () {
        return component(CheckboxChecked, {
          name: "galyleo/checkbox/active",
          fill: Color$1.rgb(245, 127, 23)
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoCheckboxChecked",
        range: {
          start: 1091,
          end: 1214
        }
      }, System, __varRecorder__$u, "GalyleoCheckboxChecked");
      __varRecorder__$u.GalyleoCheckboxUnchecked = component["for"](function () {
        return component(CheckboxUnchecked, {
          name: "galyleo/checkbox/inactive",
          borderColor: Color$1.black
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoCheckboxUnchecked",
        range: {
          start: 1223,
          end: 1347
        }
      }, System, __varRecorder__$u, "GalyleoCheckboxUnchecked");
      var SelectableEntryModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/shared.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("SelectableEntryModel") && typeof __lively_classholder__.SelectableEntryModel === "function" ? __lively_classholder__.SelectableEntryModel : __lively_classholder__.SelectableEntryModel = function SelectableEntryModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onDrag",
          value: function SelectableEntryModel_onDrag_($onDrag, evt) {
            var absDragDelta = evt.state.absDragDelta;
            this.shiftOrder(absDragDelta.y, evt);
          }
        }, {
          key: "onDragStart",
          value: function SelectableEntryModel_onDragStart_(evt) {
            this.startShifting();
          }
        }, {
          key: "onDragEnd",
          value: function SelectableEntryModel_onDragEnd_(evt) {
            this.stopShifting();
          }
        }, {
          key: "toggleEdit",
          value: function SelectableEntryModel_toggleEdit_() {}
        }, {
          key: "startShifting",
          value: function SelectableEntryModel_startShifting_() {
            this.entryList.startShiftingEntry(this.view);
            this.view.master.setState("dragged");
          }
        }, {
          key: "stopShifting",
          value: function SelectableEntryModel_stopShifting_() {
            this.view.master.setState(null);
            this.entryList.stopShifting();
          }
        }, {
          key: "shiftOrder",
          value: function SelectableEntryModel_shiftOrder_(verticalOffset, evt) {
            this.entryList.pushShiftedElementBy(verticalOffset, evt);
          }
        }, {
          key: "onRefresh",
          value: function SelectableEntryModel_onRefresh_() {
            var _this = this;

            var view = this.view,
                _this$ui = this.ui,
                checkbox = _this$ui.checkbox,
                entryName = _this$ui.entryName,
                dragControl = _this$ui.dragControl;
            view.draggable = this.orderMode;
            view.master.setState(this.orderMode ? "orderMode" : null);
            entryName.value = this.entryName;
            checkbox.master.setState(this.isSelected ? "selected" : null);

            var updateElements = function updateElements() {
              if (checkbox.visible !== !_this.orderMode) {
                checkbox.visible = !_this.orderMode;
              }

              if (dragControl.visible !== !!_this.orderMode) {
                dragControl.visible = !!_this.orderMode;
              }
            };

            updateElements();
          }
        }, {
          key: "toggleSelect",
          value: function SelectableEntryModel_toggleSelect_() {
            this.isSelected = !this.isSelected;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "SelectableEntryModel";
          }
        }, {
          key: "wrap",
          value: function SelectableEntryModel_wrap_(entryName, opts) {
            var entry = part(__varRecorder__$u.SelectableEntry, {
              viewModel: Object.assign({
                entryName: entryName
              }, opts)
            });
            return {
              isListItem: true,
              morph: entry
            };
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              entryName: {},
              entryList: {},
              orderMode: {
                defaultValue: false
              },
              isSelected: {},
              expose: {
                get: function get() {
                  return ["toggleEdit", "isSelected", "editMode", "orderMode", "entryName"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    signal: "onMouseUp",
                    handler: "toggleSelect"
                  }, {
                    signal: "onDrag",
                    handler: "onDrag",
                    override: true
                  }, {
                    signal: "onDragStart",
                    handler: "onDragStart",
                    override: true
                  }, {
                    signal: "onDragEnd",
                    handler: "onDragEnd",
                    override: true
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/shared.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 1357,
          end: 3854
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$u.SelectableEntryModel = SelectableEntryModel;
      __varRecorder__$u.SelectableEntryModel = SelectableEntryModel;
      var TableEntryMorph = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/shared.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("TableEntryMorph") && typeof __lively_classholder__.TableEntryMorph === "function" ? __lively_classholder__.TableEntryMorph : __lively_classholder__.TableEntryMorph = function TableEntryMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onMouseUp",
          value: function TableEntryMorph_onMouseUp_(evt) {
            var removeButton = this.getSubmorphNamed("remove button");
            var configButton = this.getSubmorphNamed("edit config button");
            var dataButton = this.getSubmorphNamed("edit data button");

            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onMouseUp", this).call(this, evt);

            if (evt.targetMorph === removeButton) {
              this["delete"]();
            }

            if (evt.targetMorph === configButton) {
              this.openConfig();
            }

            if (evt.targetMorph === dataButton) {
              this.openData();
            }
          }
        }, {
          key: "delete",
          value: function TableEntryMorph_delete_() {
            if (this.onDelete) this.onDelete();
          }
        }, {
          key: "openConfig",
          value: function TableEntryMorph_openConfig_() {
            if (this.onConfig) this.onConfig();
          }
        }, {
          key: "openData",
          value: function TableEntryMorph_openData_() {
            if (this.onData) this.onData();
          }
        }, {
          key: "relayout",
          value: function TableEntryMorph_relayout_() {
            var entryName = this.getSubmorphNamed("entry name");
            entryName.value = this.value;
          }
        }, {
          key: "toggleEdit",
          value: function () {
            var _TableEntryMorph_toggleEdit_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(active) {
              var _this2 = this;

              var animated,
                  toggle,
                  _args = arguments;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      animated = _args.length > 1 && _args[1] !== undefined ? _args[1] : true;
                      this.setProperty("editMode", active);

                      toggle = function toggle() {
                        var removeButton = _this2.getSubmorphNamed("remove button");

                        var configButton = _this2.getSubmorphNamed("edit config button");

                        var dataButton = _this2.getSubmorphNamed("edit data button");

                        removeButton.visible = removeButton.isLayoutable = active;
                        if (configButton) configButton.visible = configButton.isLayoutable = !active;
                        if (dataButton) dataButton.visible = dataButton.isLayoutable = !active;
                      };

                      if (!animated) {
                        _context.next = 10;
                        break;
                      }

                      this.layout.renderViaCSS = false;
                      _context.next = 7;
                      return this.withAnimationDo(toggle, {
                        duration: 300
                      });

                    case 7:
                      this.layout.renderViaCSS = true;
                      _context.next = 11;
                      break;

                    case 10:
                      toggle();

                    case 11:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function TableEntryMorph_toggleEdit_(_x) {
              return _TableEntryMorph_toggleEdit_.apply(this, arguments);
            }

            return TableEntryMorph_toggleEdit_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "TableEntryMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              onDelete: {
                doc: "This is a closure that is invoked in response to clicking in the remove button of this entry",
                serialize: false
              },
              onConfig: {
                doc: "This is a closure that is invoked in response to clicking in the config or preview button",
                serialize: false
              },
              onData: {
                doc: "This is a closure that is invoked in response to clicking on the preview button"
              },
              value: {
                derived: true,
                set: function set(v) {
                  this.setProperty("value", v);
                }
              },
              editMode: {
                defaultValue: false,
                after: ["submorphs"],
                set: function set(active) {
                  if (this.submorphs.length > 0) {
                    this.toggleEdit(active);
                  }
                }
              }
            };
          }
        }, {
          key: "wrapVisualOnlyEntry",
          value: function TableEntryMorph_wrapVisualOnlyEntry_(visualOnlyEntryName) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var entry = part(__varRecorder__$u.TableEntryVisualOnly, opts);
            entry.value = visualOnlyEntryName;
            entry.relayout();
            return {
              isListItem: true,
              morph: entry,
              value: visualOnlyEntryName
            };
          }
        }, {
          key: "wrapVisualDataEntry",
          value: function TableEntryMorph_wrapVisualDataEntry_(visualDataEntryName) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var entry = part(__varRecorder__$u.TableEntryVisual, opts);
            entry.value = visualDataEntryName;
            entry.relayout();
            return {
              isListItem: true,
              morph: entry,
              value: visualDataEntryName
            };
          }
        }, {
          key: "wrapDataEntry",
          value: function TableEntryMorph_wrapDataEntry_(dataEntryName) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var entry = part(__varRecorder__$u.TableEntry, opts);
            entry.value = dataEntryName;
            entry.relayout();
            return {
              isListItem: true,
              morph: entry,
              value: dataEntryName
            };
          }
        }, {
          key: "wrapVisualEntry",
          value: function TableEntryMorph_wrapVisualEntry_(filterOrChartName) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var entry = part(__varRecorder__$u.TableEntryEdit, opts);
            entry.value = filterOrChartName;
            entry.relayout();
            return {
              isListItem: true,
              morph: entry,
              value: filterOrChartName
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/shared.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 3863,
          end: 7417
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$u.TableEntryMorph = TableEntryMorph;
      __varRecorder__$u.TableEntryMorph = TableEntryMorph;
      var GalyleoListMorph = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/shared.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GalyleoListMorph") && typeof __lively_classholder__.GalyleoListMorph === "function" ? __lively_classholder__.GalyleoListMorph : __lively_classholder__.GalyleoListMorph = function GalyleoListMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onLoad",
          value: function GalyleoListMorph_onLoad_() {
            connect(this, "extent", this, "relayout");
            connect(this.get("item list"), "onScroll", this, "relayout");
            connect(this.get("scroll bar"), "onDrag", this, "onScrollBarDrag");
            this.get("item list").scroll = pt(0, 0);
          }
        }, {
          key: "startShiftingEntry",
          value: function GalyleoListMorph_startShiftingEntry_(entry) {
            var _this3 = this;

            var itemList = this.getSubmorphNamed("item list");
            var item = itemList.items.find(function (item) {
              return item.morph === entry;
            });
            var offsetY = 0;
            this._itemToShift = item;
            this._itemOffset = new WeakMap();
            this._dynamicOffset = 0;
            this._currentShift = 0;
            this.items.forEach(function (item) {
              return _this3._itemOffset.set(item, offsetY += itemList.itemHeight);
            });
          }
        }, {
          key: "stopShifting",
          value: function GalyleoListMorph_stopShifting_() {
            this.stopStepping();
            this._itemToShift = false;
          }
        }, {
          key: "pushShiftedElementBy",
          value: function GalyleoListMorph_pushShiftedElementBy_(deltaY, dragEvt) {
            var scrollTriggerRange = 20;

            if (dragEvt.positionIn(this).y < scrollTriggerRange) {
              this.startStepping("_autoShiftDown");
            } else if (dragEvt.positionIn(this).y > this.height - scrollTriggerRange) {
              this.startStepping("_autoShiftUp");
            } else {
              this.stopStepping();
            }

            this._currentShift = deltaY;

            this._ensureOffsetInView();

            this._updateOrder();
          }
        }, {
          key: "_ensureOffsetInView",
          value: function GalyleoListMorph__ensureOffsetInView_() {
            var offsetY = this._itemOffset.get(this._itemToShift) + this._currentShift + this._dynamicOffset;

            var itemList = this.getSubmorphNamed("item list");
            var listScrollY = itemList.scroll.y;

            if (listScrollY > offsetY) {
              itemList.scrollUp(listScrollY - offsetY);
            }

            if (listScrollY + this.height < offsetY) {
              itemList.scrollDown(offsetY - listScrollY - this.height);
            }
          }
        }, {
          key: "_updateOrder",
          value: function GalyleoListMorph__updateOrder_() {
            var _this4 = this;

            var deltaY = this._currentShift + this._dynamicOffset;
            var newlyOrderedItems = sortBy(this.items, function (item) {
              return _this4._itemOffset.get(item) + (item === _this4._itemToShift ? deltaY : 0);
            });

            if (!equals(newlyOrderedItems, this.items)) {
              this.items = newlyOrderedItems;
            }
          }
        }, {
          key: "_autoShiftUp",
          value: function GalyleoListMorph__autoShiftUp_() {
            this._dynamicOffset += 2;

            this._ensureOffsetInView();

            this._updateOrder();
          }
        }, {
          key: "_autoShiftDown",
          value: function GalyleoListMorph__autoShiftDown_() {
            this._dynamicOffset -= 2;

            this._ensureOffsetInView();

            this._updateOrder();
          }
        }, {
          key: "selectAll",
          value: function GalyleoListMorph_selectAll_() {
            this.items.forEach(function (_ref) {
              var morph = _ref.morph;
              return morph.isSelected = true;
            });
          }
        }, {
          key: "toggleOrderMode",
          value: function GalyleoListMorph_toggleOrderMode_() {
            this.items.forEach(function (_ref2) {
              var morph = _ref2.morph;
              morph.orderMode = !morph.orderMode;
            });
            this.relayout();
          }
        }, {
          key: "toggleEdit",
          value: function GalyleoListMorph_toggleEdit_() {
            this.editMode = !this.editMode;
          }
        }, {
          key: "_positionScrollbar",
          value: function GalyleoListMorph__positionScrollbar_(scrollY) {
            var _this5 = this;

            var list = this.getSubmorphNamed("item list");
            var scrollBar = this.getSubmorphNamed("scroll bar");
            var padding = 8;
            this.withMetaDo({
              skipReconciliation: true
            }, function () {
              scrollBar.top = interpolate$1(clamp(scrollY / (list.scrollExtent.y - list.height), 0, 1), padding, list.height - scrollBar.height - 3 * padding);
              scrollBar.right = _this5.width - padding;
            });
          }
        }, {
          key: "relayout",
          value: function () {
            var _GalyleoListMorph_relayout_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
              var _this6 = this;

              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      this.withMetaDo({
                        skipReconciliation: true
                      }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                        var list, scrollBar;
                        return regeneratorRuntime.wrap(function _callee2$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                list = _this6.getSubmorphNamed("item list");
                                scrollBar = _this6.getSubmorphNamed("scroll bar");
                                list.extent = _this6.extent.addXY(20, 20);
                                scrollBar.height = (list.height - 25) * list.height / list.scrollExtent.y;

                                _this6._positionScrollbar(list.scroll.y);

                                _this6.items.map(function (m) {
                                  m.morph.width = _this6.width - 10;
                                  if (m.editMode !== _this6.editMode) m.editMode = _this6.editMode;
                                });

                              case 6:
                              case "end":
                                return _context2.stop();
                            }
                          }
                        }, _callee2);
                      })));

                    case 1:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function GalyleoListMorph_relayout_() {
              return _GalyleoListMorph_relayout_.apply(this, arguments);
            }

            return GalyleoListMorph_relayout_;
          }()
        }, {
          key: "onScrollBarDrag",
          value: function GalyleoListMorph_onScrollBarDrag_(evt) {
            var list = this.getSubmorphNamed("item list");
            var scrollBar = this.getSubmorphNamed("scroll bar");
            var scrollOffsetY = list.scrollExtent.y * scrollBar.top / list.height;
            list.env.renderer.getNodeForMorph(list).scrollTop = scrollOffsetY;

            this._positionScrollbar(list.env.renderer.getNodeForMorph(list).scrollTop);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GalyleoListMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              editMode: {
                defaultValue: false,
                derived: true,
                after: ["submorphs"],
                set: function set(v) {
                  this.setProperty("editMode", v);
                  this.items.forEach(function (_ref4) {
                    var morph = _ref4.morph;
                    morph.editMode = v;
                  });
                }
              },
              items: {
                derived: true,
                after: ["editMode"],
                set: function set(items) {
                  var _this7 = this;

                  items.forEach(function (m, i) {
                    m.morph.toggleEdit(_this7.editMode, false);
                  });
                  this.getSubmorphNamed("item list").items = items;
                  if (items.length === 0) this.editMode = false;
                  this.whenRendered().then(function () {
                    return _this7.relayout();
                  });
                },
                get: function get() {
                  return (this.getSubmorphNamed("item list") || {}).items || [];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/shared.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 7426,
          end: 12895
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$u.GalyleoListMorph = GalyleoListMorph;
      __varRecorder__$u.GalyleoListMorph = GalyleoListMorph;
      __varRecorder__$u.GalyleoTextInput = component["for"](function () {
        return component(TextInput, {
          name: "galyleo/text input",
          borderColor: Color$1.rgbHex("8E9B9B"),
          borderWidth: 1,
          fontSize: 14,
          padding: rect(2, 2, 0, 0),
          fill: Color$1.rgba(0, 0, 0, 0.15),
          fontColor: Color$1.black
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoTextInput",
        range: {
          start: 12903,
          end: 13139
        }
      }, System, __varRecorder__$u, "GalyleoTextInput");
      __varRecorder__$u.GalyleoNumberInput = component["for"](function () {
        return component(DarkNumberIconWidget, {
          name: "galyleo/number input",
          borderColor: Color$1.rgbHex("8E9B9B"),
          borderWidth: 1,
          fill: Color$1.rgba(0, 0, 0, 0.15),
          submorphs: [{
            name: "interactive label",
            fontColor: Color$1.rgba(100, 100, 100, 0.5)
          }, {
            name: "value",
            cursorColor: Color$1.black,
            fontColor: Color$1.black
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoNumberInput",
        range: {
          start: 13148,
          end: 13509
        }
      }, System, __varRecorder__$u, "GalyleoNumberInput");
      __varRecorder__$u.GalyleoEnumSelector = component["for"](function () {
        return component(EnumSelector, {
          borderColor: Color$1.rgbHex("8E9B9B"),
          borderWidth: 1,
          fill: Color$1.rgba(0, 0, 0, 0.15),
          submorphs: [{
            name: "label",
            fontColor: Color$1.black
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoEnumSelector",
        range: {
          start: 13518,
          end: 13727
        }
      }, System, __varRecorder__$u, "GalyleoEnumSelector");
      __varRecorder__$u.GalyleoAddButtonDefault = component["for"](function () {
        return component(AddButton, {
          name: "galyleo/add button/default",
          fontColor: Color$1.rgb(66, 73, 73)
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoAddButtonDefault",
        range: {
          start: 13736,
          end: 13860
        }
      }, System, __varRecorder__$u, "GalyleoAddButtonDefault");
      __varRecorder__$u.GalyleoAddButtonHovered = component["for"](function () {
        return component(AddButton, {
          name: "galyleo/add button/hovered",
          fontColor: Color$1.rgb(66, 73, 73),
          fill: Color$1.black.withA(0.1)
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoAddButtonHovered",
        range: {
          start: 13869,
          end: 14024
        }
      }, System, __varRecorder__$u, "GalyleoAddButtonHovered");
      __varRecorder__$u.GalyleoAddButtonActive = component["for"](function () {
        return component(__varRecorder__$u.GalyleoAddButtonHovered, {
          name: "galyleo/add button/active",
          fontColor: Color$1.white,
          fill: Color$1.rgbHex("F57F17")
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoAddButtonActive",
        range: {
          start: 14033,
          end: 14191
        }
      }, System, __varRecorder__$u, "GalyleoAddButtonActive");
      __varRecorder__$u.GalyleoAddButton = component["for"](function () {
        return component(AddButton, {
          name: "galyleo/add button",
          master: {
            auto: __varRecorder__$u.GalyleoAddButtonDefault,
            hover: __varRecorder__$u.GalyleoAddButtonHovered
          },
          fontColor: Color$1.rgb(66, 73, 73)
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoAddButton",
        range: {
          start: 14200,
          end: 14386
        }
      }, System, __varRecorder__$u, "GalyleoAddButton");
      __varRecorder__$u.GalyleoPropertyLabel = component["for"](function () {
        return component(PropertyLabel, {
          name: "galyleo/property label",
          fontColor: Color$1.rgb(66, 73, 73)
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoPropertyLabel",
        range: {
          start: 14395,
          end: 14516
        }
      }, System, __varRecorder__$u, "GalyleoPropertyLabel");
      __varRecorder__$u.GalyleoPropertyLabelActive = component["for"](function () {
        return component(PropertyLabelActive, {
          name: "galyleo/property label/active",
          fontColor: Color$1.rgb(255, 255, 255),
          fill: Color$1.rgb(251, 140, 0),
          extent: pt(31.2, 34)
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoPropertyLabelActive",
        range: {
          start: 14525,
          end: 14724
        }
      }, System, __varRecorder__$u, "GalyleoPropertyLabelActive");
      __varRecorder__$u.GalyleoPropertyLabelHovered = component["for"](function () {
        return component(PropertyLabelHovered, {
          name: "galyleo/property label/hovered",
          fill: Color$1.rgb(172, 172, 172),
          fontColor: Color$1.rgb(66, 73, 73)
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoPropertyLabelHovered",
        range: {
          start: 14733,
          end: 14910
        }
      }, System, __varRecorder__$u, "GalyleoPropertyLabelHovered");
      __varRecorder__$u.GalyleoColorInput = component["for"](function () {
        return component(ColorInput, {
          name: "galyleo/color input",
          layout: new TilingLayout({
            axisAlign: "center",
            orderByIndex: true,
            padding: rect(20, 2, -10, 0),
            resizePolicies: [["hex input", {
              height: "fill",
              width: "fixed"
            }], ["opacity input", {
              height: "fill",
              width: "fixed"
            }]],
            spacing: 10,
            wrapSubmorphs: false
          }),
          submorphs: [{
            name: "hex input",
            readOnly: true,
            needsDocument: false,
            master: __varRecorder__$u.GalyleoTextInput
          }, {
            name: "opacity input",
            master: __varRecorder__$u.GalyleoNumberInput
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoColorInput",
        range: {
          start: 14919,
          end: 15500
        }
      }, System, __varRecorder__$u, "GalyleoColorInput");
      __varRecorder__$u.GalyleoWindow = component["for"](function () {
        return component({
          name: "galyleo/window",
          dropShadow: new ShadowObject({
            color: Color$1.rgba(0, 0, 0, 0.4086),
            blur: 20
          }),
          borderColor: Color$1.rgb(127, 140, 141),
          borderRadius: 10,
          borderWidth: 2,
          clipMode: "hidden",
          draggable: true,
          extent: pt(340.5, 257.7),
          fill: Color$1.rgb(215, 219, 221),
          layout: new TilingLayout({
            axis: "column",
            orderByIndex: true,
            resizePolicies: [["window title", {
              height: "fixed",
              width: "fill"
            }]],
            wrapSubmorphs: false
          }),
          nativeCursor: "grab",
          position: pt(413.3, 676),
          submorphs: [{
            type: Text,
            name: "window title",
            textString: "A prompt",
            acceptsDrops: false,
            extent: pt(340, 29.5),
            fill: Color$1.rgb(127, 140, 141),
            fixedHeight: true,
            fixedWidth: true,
            fontColor: Color$1.rgb(253, 254, 254),
            fontSize: 17,
            fontWeight: "bold",
            lineWrapping: true,
            nativeCursor: "pointer",
            padding: rect(3, 3, -3, -3),
            readOnly: true,
            selectable: false,
            textAlign: "center"
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoWindow",
        range: {
          start: 15509,
          end: 16537
        }
      }, System, __varRecorder__$u, "GalyleoWindow");
      __varRecorder__$u.GalyleoDropDownList = component["for"](function () {
        return component(SystemList, {
          name: "galyleo/drop down list",
          fontFamily: __varRecorder__$u.galyleoFont,
          fontSize: 14,
          fill: Color$1.rgb(230, 230, 230),
          selectionFontColor: Color$1.white,
          selectionColor: Color$1.rgb(127, 140, 141),
          itemBorderRadius: 3
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoDropDownList",
        range: {
          start: 16546,
          end: 16806
        }
      }, System, __varRecorder__$u, "GalyleoDropDownList");
      var GalyleoDropDownListModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/shared.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GalyleoDropDownListModel") && typeof __lively_classholder__.GalyleoDropDownListModel === "function" ? __lively_classholder__.GalyleoDropDownListModel : __lively_classholder__.GalyleoDropDownListModel = function GalyleoDropDownListModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "updateListMorphIfNeeded",
          value: function GalyleoDropDownListModel_updateListMorphIfNeeded_() {
            if (initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "updateListMorphIfNeeded", this).call(this)) {
              this.listMorph.items = [{
                isListItem: true,
                isPlaceholder: true,
                value: "__no_selection__",
                label: [this.placeholder, {
                  fontStyle: "italic",
                  opacity: 0.5
                }]
              }].concat(_toConsumableArray(this.items.filter(function (item) {
                return !item.isPlaceholder;
              })));
            }
          }
        }, {
          key: "toggleError",
          value: function GalyleoDropDownListModel_toggleError_() {
            this.view.master.setState("error");
          }
        }, {
          key: "adjustLableFor",
          value: function GalyleoDropDownListModel_adjustLableFor_(item) {
            var label = item.label || [item.string, null];
            this.label = {
              value: label
            };
          }
        }, {
          key: "toggleList",
          value: function () {
            var _GalyleoDropDownListModel_toggleList_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      _context4.next = 2;
                      return initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "toggleList", this).call(this);

                    case 2:
                      this.listMorph.update();
                      this.view.master.setState(null);

                    case 4:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function GalyleoDropDownListModel_toggleList_() {
              return _GalyleoDropDownListModel_toggleList_.apply(this, arguments);
            }

            return GalyleoDropDownListModel_toggleList_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GalyleoDropDownListModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              placeholder: {
                defaultValue: "Nothing selected"
              },
              listMaster: {
                initialize: function initialize() {
                  this.listMaster = __varRecorder__$u.GalyleoDropDownList;
                }
              },
              expose: {
                get: function get() {
                  return [].concat(_toConsumableArray(initializeClass._get(Object.getPrototypeOf(__lively_class__), "prototype", this).expose), ["toggleError"]);
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/shared.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 16816,
          end: 17921
        });
      }({
        referencedAs: "DropDownListModel",
        value: DropDownListModel
      });
      __varRecorder__$u.GalyleoDropDownListModel = GalyleoDropDownListModel;
      __varRecorder__$u.GalyleoDropDownListModel = GalyleoDropDownListModel;
      __varRecorder__$u.GalyleoDropDownAuto = component["for"](function () {
        return component(DropDownList, {
          name: "galyleo/drop down/auto",
          defaultViewModel: __varRecorder__$u.GalyleoDropDownListModel,
          fill: Color$1.rgba(0, 0, 0, 0.15),
          borderWidth: 1,
          borderColor: Color$1.rgbHex("8E9B9B"),
          borderRadius: 30,
          layout: new TilingLayout({
            align: "center",
            axisAlign: "center",
            justifySubmorphs: "spaced",
            orderByIndex: true,
            padding: rect(10, 0, 0, 0),
            spacing: 5,
            wrapSubmorphs: false
          }),
          extent: pt(160, 30),
          submorphs: [{
            name: "label",
            fontWeight: 800,
            fontColor: Color$1.rgb(128, 128, 128)
          }, add({
            type: Image,
            name: "down caret",
            extent: pt(20, 20),
            reactsToPointer: false,
            imageUrl: projectAsset("engageLively--galyleo-dashboard__list-icon.svg")
          }), add({
            type: Label,
            name: "error icon",
            fontColor: Color$1.rgb(205, 0, 0),
            fontSize: 16,
            visible: false,
            textAndAttributes: Icon.textAttribute("exclamation-circle")
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoDropDownAuto",
        range: {
          start: 17929,
          end: 18925
        }
      }, System, __varRecorder__$u, "GalyleoDropDownAuto");
      __varRecorder__$u.GalyleoDropDownClicked = component["for"](function () {
        return component(__varRecorder__$u.GalyleoDropDownAuto, {
          name: "galyleo/drop down/clicked",
          fill: Color$1.darkGray
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoDropDownClicked",
        range: {
          start: 18934,
          end: 19054
        }
      }, System, __varRecorder__$u, "GalyleoDropDownClicked");
      __varRecorder__$u.GalyleoDropDownError = component["for"](function () {
        return component(__varRecorder__$u.GalyleoDropDownAuto, {
          name: "galyleo/drop down/error",
          extent: pt(168, 34),
          borderColor: Color$1.rgb(205, 0, 0),
          borderWidth: 4,
          submorphs: [{
            name: "label",
            fontColor: Color$1.rgb(205, 0, 0)
          }, {
            name: "down caret",
            visible: false
          }, {
            name: "error icon",
            visible: true
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoDropDownError",
        range: {
          start: 19063,
          end: 19430
        }
      }, System, __varRecorder__$u, "GalyleoDropDownError");
      __varRecorder__$u.GalyleoDropDown = component["for"](function () {
        return component(__varRecorder__$u.GalyleoDropDownAuto, {
          name: "galyleo/drop down",
          master: {
            auto: __varRecorder__$u.GalyleoDropDownAuto,
            click: __varRecorder__$u.GalyleoDropDownClicked,
            states: {
              error: __varRecorder__$u.GalyleoDropDownError
            }
          }
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoDropDown",
        range: {
          start: 19439,
          end: 19633
        }
      }, System, __varRecorder__$u, "GalyleoDropDown");
      __varRecorder__$u.GalyleoList = component["for"](function () {
        return component({
          type: __varRecorder__$u.GalyleoListMorph,
          name: "galyleo list",
          borderColor: Color$1.rgb(127, 140, 141),
          borderRadius: 10,
          borderWidth: 2,
          clipMode: "hidden",
          extent: pt(191.4, 128.8),
          fill: Color$1.rgb(189, 195, 199),
          position: pt(467.7, 690.9),
          submorphs: [{
            type: MorphList,
            name: "item list",
            clipMode: "hidden",
            borderColor: Color$1.rgb(127, 140, 141),
            extent: pt(211.4, 148.8),
            fill: Color$1.rgba(255, 255, 255, 0),
            halosEnabled: false,
            itemHeight: 30,
            itemPadding: rect(3, 2, -2, -1),
            manualItemHeight: true,
            padding: rect(1, 1, 0, 29),
            position: pt(0.7, -0.3),
            renderOnGPU: true,
            scroll: pt(4, 0),
            selectedIndexes: [],
            selectionColor: Color$1.rgba(0, 0, 0, 0),
            touchInput: false
          }, {
            name: "scroll bar",
            borderColor: Color$1.rgb(23, 160, 251),
            borderRadius: 8,
            draggable: true,
            extent: pt(4.6, 111.8),
            fill: Color$1.rgb(253, 254, 254),
            nativeCursor: "grab",
            opacity: 0.75,
            position: pt(178.8, 8)
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoList",
        range: {
          start: 19642,
          end: 20673
        }
      }, System, __varRecorder__$u, "GalyleoList");
      __varRecorder__$u.MenuBarButtonDefault = component["for"](function () {
        return component({
          name: "menu bar button default",
          defaultViewModel: ButtonModel,
          borderColor: Color$1.rgb(23, 160, 251),
          borderRadius: 5,
          extent: pt(127.8, 38.2),
          fill: Color$1.rgba(0, 0, 0, 0),
          layout: new TilingLayout({
            align: "center",
            axis: "row",
            axisAlign: "center",
            autoResize: false,
            direction: "centered",
            orderByIndex: true,
            padding: {
              height: 0,
              width: 0,
              x: 10,
              y: 0
            },
            reactToSubmorphAnimations: false,
            renderViaCSS: true,
            resizeSubmorphs: false,
            spacing: 10
          }),
          nativeCursor: "pointer",
          position: pt(560.7, 667.5),
          renderOnGPU: true,
          submorphs: [{
            type: Label,
            name: "label",
            fontColor: Color$1.rgb(128, 128, 128),
            fontFamily: __varRecorder__$u.galyleoFont,
            fontSize: 15,
            fontWeight: "bold",
            reactsToPointer: false,
            textAndAttributes: ["CLOSE", null]
          }, {
            type: Image,
            name: "icon",
            extent: pt(19.8, 19.8),
            imageUrl: projectAsset("engageLively--galyleo-dashboard__add-icon.svg"),
            naturalExtent: pt(150, 150),
            reactsToPointer: false
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "MenuBarButtonDefault",
        range: {
          start: 20682,
          end: 21783
        }
      }, System, __varRecorder__$u, "MenuBarButtonDefault");
      __varRecorder__$u.MenuBarButtonHovered = component["for"](function () {
        return component(__varRecorder__$u.MenuBarButtonDefault, {
          name: "menu bar button hovered",
          fill: Color$1.rgba(0, 0, 0, 0.15)
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "MenuBarButtonHovered",
        range: {
          start: 21792,
          end: 21920
        }
      }, System, __varRecorder__$u, "MenuBarButtonHovered");
      __varRecorder__$u.MenuBarButtonClicked = component["for"](function () {
        return component(__varRecorder__$u.MenuBarButtonDefault, {
          name: "menu bar button clicked",
          fill: Color$1.rgba(0, 0, 0, 0.25)
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "MenuBarButtonClicked",
        range: {
          start: 21929,
          end: 22057
        }
      }, System, __varRecorder__$u, "MenuBarButtonClicked");
      __varRecorder__$u.MenuBarButton = component["for"](function () {
        return component(__varRecorder__$u.MenuBarButtonDefault, {
          name: "menu bar button",
          master: {
            auto: __varRecorder__$u.MenuBarButtonDefault,
            hover: __varRecorder__$u.MenuBarButtonHovered,
            click: __varRecorder__$u.MenuBarButtonClicked
          }
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "MenuBarButton",
        range: {
          start: 22066,
          end: 22258
        }
      }, System, __varRecorder__$u, "MenuBarButton");
      __varRecorder__$u.PromptButtonAuto = component["for"](function () {
        return component(__varRecorder__$u.MenuBarButtonDefault, {
          name: "prompt button auto",
          fill: new LinearGradient({
            stops: [{
              offset: 0,
              color: Color$1.rgb(237, 28, 36)
            }, {
              offset: 1,
              color: Color$1.rgb(241, 90, 36)
            }],
            vector: rect(0.0007483204642836916, 0.4726547905335063, 0.9985033590714326, 0.05469041893298742)
          }),
          borderRadius: 5,
          dropShadow: new ShadowObject({
            distance: 4,
            rotation: 90,
            color: Color$1.rgba(0, 0, 0, 0.3),
            blur: 0
          }),
          submorphs: [{
            name: "label",
            fontColor: Color$1.rgb(255, 255, 255)
          }, {
            name: "icon",
            imageUrl: projectAsset("engageLively--galyleo-dashboard__add-icon-light.svg")
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "PromptButtonAuto",
        range: {
          start: 22267,
          end: 22904
        }
      }, System, __varRecorder__$u, "PromptButtonAuto");
      __varRecorder__$u.PromptButtonClick = component["for"](function () {
        return component(__varRecorder__$u.PromptButtonAuto, {
          name: "prompt button click",
          fill: new LinearGradient({
            stops: [{
              offset: 0,
              color: Color$1.rgb(190, 22, 28)
            }, {
              offset: 1,
              color: Color$1.rgb(193, 72, 28)
            }],
            vector: rect(0.0007483204642836916, 0.4726547905335063, 0.9985033590714326, 0.05469041893298742)
          })
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "PromptButtonClick",
        range: {
          start: 22913,
          end: 23226
        }
      }, System, __varRecorder__$u, "PromptButtonClick");
      __varRecorder__$u.PromptButton = component["for"](function () {
        return component(__varRecorder__$u.PromptButtonAuto, {
          name: "prompt button",
          master: {
            auto: __varRecorder__$u.PromptButtonAuto,
            click: __varRecorder__$u.PromptButtonClick
          }
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "PromptButton",
        range: {
          start: 23235,
          end: 23370
        }
      }, System, __varRecorder__$u, "PromptButton");
      __varRecorder__$u.GalyleoEntryCheckboxChecked = component["for"](function () {
        return component({
          name: "checkbox/checked",
          borderColor: Color$1.rgb(127, 140, 141),
          borderRadius: 2,
          borderWidth: 1,
          extent: pt(17, 17),
          fill: Color$1.rgba(0, 0, 0, 0),
          layout: new TilingLayout({
            autoResize: true,
            axis: "column",
            align: "center",
            axisAlign: "center",
            hugsContentsVertically: true,
            orderByIndex: true,
            padding: rect(0, 2, 0, 0),
            resizePolicies: [["h floater", {
              height: "fixed",
              width: "fill"
            }], ["background fill input", {
              height: "fixed",
              width: "fill"
            }]],
            resizeSubmorphs: false,
            spacing: 2
          }),
          position: pt(354.1, 231.8),
          submorphs: [{
            name: "checker",
            borderColor: Color$1.rgb(23, 160, 251),
            extent: pt(13.3, 12.9),
            fill: Color$1.rgb(241, 90, 36),
            nativeCursor: "pointer"
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoEntryCheckboxChecked",
        range: {
          start: 23379,
          end: 24210
        }
      }, System, __varRecorder__$u, "GalyleoEntryCheckboxChecked");
      __varRecorder__$u.GalyleoEntryCheckboxUnchecked = component["for"](function () {
        return component({
          name: "checkbox/unchecked",
          borderColor: Color$1.rgb(127, 140, 141),
          borderRadius: 2,
          borderWidth: 1,
          extent: pt(17, 17),
          fill: Color$1.rgba(0, 0, 0, 0),
          layout: new TilingLayout({
            autoResize: true,
            axis: "column",
            hugsContentsVertically: true,
            orderByIndex: true,
            padding: rect(0, 2, 0, 0),
            resizePolicies: [["h floater", {
              height: "fixed",
              width: "fill"
            }], ["background fill input", {
              height: "fixed",
              width: "fill"
            }]],
            resizeSubmorphs: false,
            spacing: 2
          }),
          position: pt(388.9, 233.4),
          submorphs: [{
            name: "checker",
            borderColor: Color$1.rgb(23, 160, 251),
            extent: pt(13.3, 12.9),
            fill: Color$1.rgb(241, 90, 36),
            nativeCursor: "pointer",
            opacity: 0
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoEntryCheckboxUnchecked",
        range: {
          start: 24219,
          end: 25024
        }
      }, System, __varRecorder__$u, "GalyleoEntryCheckboxUnchecked");
      __varRecorder__$u.GalyleoEntryCheckbox = component["for"](function () {
        return component(__varRecorder__$u.GalyleoEntryCheckboxUnchecked, {
          master: {
            states: {
              selected: __varRecorder__$u.GalyleoEntryCheckboxChecked
            }
          }
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoEntryCheckbox",
        range: {
          start: 25033,
          end: 25181
        }
      }, System, __varRecorder__$u, "GalyleoEntryCheckbox");
      __varRecorder__$u.SelectableEntryDefault = component["for"](function () {
        return component({
          defaultViewModel: __varRecorder__$u.SelectableEntryModel,
          name: "selectable entry",
          nativeCursor: "grab",
          borderColor: Color$1.rgb(23, 160, 251),
          clipMode: "hidden",
          extent: pt(163.9, 32.5),
          fill: Color$1.rgba(0, 0, 0, 0),
          isSelected: false,
          layout: new TilingLayout({
            padding: rect(10, 8, 0, 2),
            reactToSubmorphAnimations: true,
            spacing: 10
          }),
          position: pt(344.3, 280.5),
          submorphs: [{
            type: Label,
            name: "drag control",
            fontColor: Color$1.rgb(81, 90, 90),
            nativeCursor: "grab",
            fill: Color$1.transparent,
            reactsToPointer: false,
            padding: rect(3, 0, 0, 5),
            textAndAttributes: Icon.textAttribute("bars")
          }, part(__varRecorder__$u.GalyleoEntryCheckbox, {
            name: "checkbox"
          }), {
            type: Label,
            name: "entry name",
            reactsToPointer: false,
            fontFamily: __varRecorder__$u.galyleoFont,
            textAndAttributes: ["entry", null]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "SelectableEntryDefault",
        range: {
          start: 25190,
          end: 26075
        }
      }, System, __varRecorder__$u, "SelectableEntryDefault");
      __varRecorder__$u.SelectableEntryDragged = component["for"](function () {
        return component(__varRecorder__$u.SelectableEntryDefault, {
          name: "selectable entry/dragged",
          nativeCursor: "grabbing",
          borderRadius: 5,
          fill: Color$1.rgba(0, 0, 0, 0.15),
          submorphs: [{
            name: "drag control",
            padding: rect(3, 0, 0, 5)
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "SelectableEntryDragged",
        range: {
          start: 26084,
          end: 26342
        }
      }, System, __varRecorder__$u, "SelectableEntryDragged");
      __varRecorder__$u.SelectableEntry = component["for"](function () {
        return component(__varRecorder__$u.SelectableEntryDefault, {
          master: {
            states: {
              dragged: __varRecorder__$u.SelectableEntryDragged,
              orderMode: component(__varRecorder__$u.SelectableEntryDefault, {
                master: {
                  click: __varRecorder__$u.SelectableEntryDragged
                }
              })
            }
          }
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "SelectableEntry",
        range: {
          start: 26351,
          end: 26612
        }
      }, System, __varRecorder__$u, "SelectableEntry");
      __varRecorder__$u.TableEntry = component["for"](function () {
        return component({
          type: __varRecorder__$u.TableEntryMorph,
          name: "table entry",
          layout: new TilingLayout({
            align: "center",
            axisAlign: "center",
            justifySubmorphs: "spaced",
            orderByIndex: true,
            reactToSubmorphAnimations: true,
            padding: rect(5, 0, 0, 0),
            resizePolicies: [["buffer", {
              height: "fixed",
              width: "fill"
            }]],
            spacing: 5,
            wrapSubmorphs: false
          }),
          borderColor: Color$1.rgb(23, 160, 251),
          extent: pt(200, 32),
          fill: Color$1.rgba(0, 0, 0, 0),
          submorphs: [{
            type: Image,
            name: "remove button",
            extent: pt(17.4, 27.9),
            imageUrl: projectAsset("engageLively--galyleo-dashboard__delete-icon.png"),
            nativeCursor: "pointer",
            naturalExtent: pt(226, 358),
            visible: true
          }, {
            type: Label,
            name: "entry name",
            fontFamily: __varRecorder__$u.galyleoFont,
            textAndAttributes: ["A table entry", null]
          }, {
            name: "buffer",
            borderColor: Color$1.rgb(23, 160, 251),
            extent: pt(79.9, 20.3),
            fill: Color$1.rgba(0, 0, 0, 0)
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "TableEntry",
        range: {
          start: 26621,
          end: 27630
        }
      }, System, __varRecorder__$u, "TableEntry");
      __varRecorder__$u.TableEntryVisualOnly = component["for"](function () {
        return component(__varRecorder__$u.TableEntry, {
          name: "table entry/edit",
          submorphs: [add({
            type: Image,
            name: "edit config button",
            extent: pt(15.2, 15.2),
            imageUrl: projectAsset("engageLively--galyleo-dashboard__preview-icon.svg"),
            nativeCursor: "pointer",
            naturalExtent: pt(133, 150)
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "TableEntryVisualOnly",
        range: {
          start: 27639,
          end: 27983
        }
      }, System, __varRecorder__$u, "TableEntryVisualOnly");
      __varRecorder__$u.TableEntryEdit = component["for"](function () {
        return component(__varRecorder__$u.TableEntry, {
          name: "table entry/edit",
          submorphs: [add({
            type: Image,
            name: "edit data button",
            extent: pt(15.2, 15.2),
            imageUrl: projectAsset("engageLively--galyleo-dashboard__chart-gear.svg"),
            nativeCursor: "pointer",
            naturalExtent: pt(133, 150)
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "TableEntryEdit",
        range: {
          start: 27992,
          end: 28326
        }
      }, System, __varRecorder__$u, "TableEntryEdit");
      __varRecorder__$u.TableEntryVisual = component["for"](function () {
        return component(__varRecorder__$u.TableEntryEdit, {
          name: "table entry/visual",
          submorphs: [add({
            type: Image,
            name: "edit config button",
            extent: pt(15.2, 15.2),
            imageUrl: projectAsset("engageLively--galyleo-dashboard__preview-icon.svg"),
            nativeCursor: "pointer",
            naturalExtent: pt(133, 150)
          }, "edit data button")]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "TableEntryVisual",
        range: {
          start: 28335,
          end: 28701
        }
      }, System, __varRecorder__$u, "TableEntryVisual");
      __varRecorder__$u.GalyleoConfirmPrompt = component["for"](function () {
        return component(__varRecorder__$u.GalyleoWindow, {
          name: "galyleo/confirm prompt",
          defaultViewModel: ConfirmPromptModel,
          extent: pt(340.5, 248.4),
          layout: new TilingLayout({
            axis: "column",
            orderByIndex: true,
            resizePolicies: [["window title", {
              height: "fixed",
              width: "fill"
            }], ["prompt content", {
              height: "fixed",
              width: "fill"
            }], ["button wrapper", {
              height: "fixed",
              width: "fill"
            }]],
            wrapSubmorphs: false
          }),
          submorphs: [add({
            type: Text,
            name: "prompt title",
            fontSize: 15,
            borderColor: Color$1.rgb(23, 160, 251),
            borderWidth: 0,
            extent: pt(341, 142.8),
            padding: rect(20, 10, 0, 0),
            fill: Color$1.rgba(0, 0, 0, 0),
            fixedHeight: true,
            fixedWidth: true,
            lineWrapping: true,
            readOnly: true,
            textString: "This is something to confirm or not...."
          }), add({
            name: "button wrapper",
            layout: new TilingLayout({
              align: "center",
              axisAlign: "center",
              justifySubmorphs: "spaced",
              orderByIndex: true,
              padding: rect(20, 0, 0, 0)
            }),
            borderColor: Color$1.rgb(23, 160, 251),
            borderWidth: 0,
            extent: pt(341, 72.4),
            fill: Color$1.rgba(0, 0, 0, 0),
            submorphs: [part(__varRecorder__$u.PromptButton, {
              name: "cancel button",
              position: pt(18.1, 11.8),
              submorphs: [{
                name: "label",
                textAndAttributes: ["Cancel", null]
              }, without("icon")]
            }), part(__varRecorder__$u.PromptButton, {
              name: "ok button",
              position: pt(18.1, 11.8),
              submorphs: [{
                name: "label",
                textAndAttributes: ["Accept", null]
              }, without("icon")]
            })]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "GalyleoConfirmPrompt",
        range: {
          start: 28710,
          end: 30357
        }
      }, System, __varRecorder__$u, "GalyleoConfirmPrompt");
      __varRecorder__$u.WindowHeader = component["for"](function () {
        return component({
          name: "window header",
          layout: new TilingLayout({
            align: "center",
            axisAlign: "center",
            orderByIndex: true,
            padding: rect(5, 0, 0, 0),
            wrapSubmorphs: false
          }),
          fill: Color$1.rgb(127, 140, 141),
          extent: pt(241, 26.3),
          submorphs: [{
            name: "title",
            type: "label",
            fontFamily: __varRecorder__$u.galyleoFont,
            fontWeight: "bold",
            fontColor: Color$1.rgb(255, 255, 255)
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "WindowHeader",
        range: {
          start: 30366,
          end: 30812
        }
      }, System, __varRecorder__$u, "WindowHeader");
      __varRecorder__$u.CloseButtonFloat = component["for"](function () {
        return component({
          name: "close button float",
          layout: new TilingLayout({
            align: "right",
            orderByIndex: true,
            padding: rect(0, 5, 10, -5)
          }),
          fill: Color$1.rgba(255, 255, 255, 0),
          submorphs: [part(__varRecorder__$u.MenuBarButton, {
            tooltip: "Close this dialog without loading",
            name: "close button",
            extent: pt(72.4, 21.3),
            submorphs: [{
              name: "label",
              fontSize: 12,
              textAndAttributes: ["CLOSE", null]
            }, {
              name: "icon",
              extent: pt(10, 10),
              imageUrl: projectAsset("engageLively--galyleo-dashboard__close-button-icon-2.svg")
            }]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/shared.cp.js",
        "export": "CloseButtonFloat",
        range: {
          start: 30821,
          end: 31464
        }
      }, System, __varRecorder__$u, "CloseButtonFloat");
      var GalyleoWindow = __varRecorder__$u.GalyleoWindow;
      var GalyleoList = __varRecorder__$u.GalyleoList;
      var MenuBarButton = __varRecorder__$u.MenuBarButton;
      var PromptButton = __varRecorder__$u.PromptButton;
      var GalyleoCheckboxChecked = __varRecorder__$u.GalyleoCheckboxChecked;
      var GalyleoCheckboxUnchecked = __varRecorder__$u.GalyleoCheckboxUnchecked;
      var SelectableEntry = __varRecorder__$u.SelectableEntry;
      var SelectableEntryDragged = __varRecorder__$u.SelectableEntryDragged;
      var GalyleoDropDownList = __varRecorder__$u.GalyleoDropDownList;
      var GalyleoDropDownError = __varRecorder__$u.GalyleoDropDownError;
      var GalyleoTextInput = __varRecorder__$u.GalyleoTextInput;
      var TableEntry = __varRecorder__$u.TableEntry;
      var TableEntryEdit = __varRecorder__$u.TableEntryEdit;
      var TableEntryVisual = __varRecorder__$u.TableEntryVisual;
      var GalyleoDropDown = __varRecorder__$u.GalyleoDropDown;
      var GalyleoNumberInput = __varRecorder__$u.GalyleoNumberInput;
      var GalyleoColorInput = __varRecorder__$u.GalyleoColorInput;
      var GalyleoAddButtonActive = __varRecorder__$u.GalyleoAddButtonActive;
      var GalyleoDropDownAuto = __varRecorder__$u.GalyleoDropDownAuto;
      var GalyleoAddButton = __varRecorder__$u.GalyleoAddButton;
      var GalyleoPropertyLabel = __varRecorder__$u.GalyleoPropertyLabel;
      var GalyleoPropertyLabelActive = __varRecorder__$u.GalyleoPropertyLabelActive;
      var GalyleoPropertyLabelHovered = __varRecorder__$u.GalyleoPropertyLabelHovered;
      var GalyleoAddButtonDefault = __varRecorder__$u.GalyleoAddButtonDefault;
      var GalyleoAddButtonHovered = __varRecorder__$u.GalyleoAddButtonHovered;
      var GalyleoConfirmPrompt = __varRecorder__$u.GalyleoConfirmPrompt;
      var WindowHeader = __varRecorder__$u.WindowHeader;
      var CloseButtonFloat = __varRecorder__$u.CloseButtonFloat;
      var galyleoFont = __varRecorder__$u.galyleoFont;
      var GalyleoEnumSelector = __varRecorder__$u.GalyleoEnumSelector;
      __varRecorder__$u.GalyleoWindow = GalyleoWindow;
      __varRecorder__$u.GalyleoList = GalyleoList;
      __varRecorder__$u.MenuBarButton = MenuBarButton;
      __varRecorder__$u.PromptButton = PromptButton;
      __varRecorder__$u.GalyleoCheckboxChecked = GalyleoCheckboxChecked;
      __varRecorder__$u.GalyleoCheckboxUnchecked = GalyleoCheckboxUnchecked;
      __varRecorder__$u.SelectableEntry = SelectableEntry;
      __varRecorder__$u.SelectableEntryDragged = SelectableEntryDragged;
      __varRecorder__$u.GalyleoDropDownList = GalyleoDropDownList;
      __varRecorder__$u.GalyleoDropDownError = GalyleoDropDownError;
      __varRecorder__$u.GalyleoTextInput = GalyleoTextInput;
      __varRecorder__$u.TableEntry = TableEntry;
      __varRecorder__$u.TableEntryEdit = TableEntryEdit;
      __varRecorder__$u.TableEntryVisual = TableEntryVisual;
      __varRecorder__$u.GalyleoDropDown = GalyleoDropDown;
      __varRecorder__$u.GalyleoNumberInput = GalyleoNumberInput;
      __varRecorder__$u.GalyleoColorInput = GalyleoColorInput;
      __varRecorder__$u.GalyleoAddButtonActive = GalyleoAddButtonActive;
      __varRecorder__$u.GalyleoDropDownAuto = GalyleoDropDownAuto;
      __varRecorder__$u.GalyleoAddButton = GalyleoAddButton;
      __varRecorder__$u.GalyleoPropertyLabel = GalyleoPropertyLabel;
      __varRecorder__$u.GalyleoPropertyLabelActive = GalyleoPropertyLabelActive;
      __varRecorder__$u.GalyleoPropertyLabelHovered = GalyleoPropertyLabelHovered;
      __varRecorder__$u.GalyleoAddButtonDefault = GalyleoAddButtonDefault;
      __varRecorder__$u.GalyleoAddButtonHovered = GalyleoAddButtonHovered;
      __varRecorder__$u.GalyleoConfirmPrompt = GalyleoConfirmPrompt;
      __varRecorder__$u.WindowHeader = WindowHeader;
      __varRecorder__$u.CloseButtonFloat = CloseButtonFloat;
      __varRecorder__$u.galyleoFont = galyleoFont;
      __varRecorder__$u.GalyleoEnumSelector = GalyleoEnumSelector;

      var __varRecorder__$t = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/search.cp.js", __contextModule__);
      __varRecorder__$t.GalyleoSearch = component["for"](function () {
        return component(InputLineDefault, {
          name: "galyleo search",
          borderRadius: 50,
          dropShadow: new ShadowObject({
            rotation: 90,
            color: Color$1.rgba(102, 102, 102, 0.65),
            blur: 8
          }),
          extent: pt(318.1, 28.8),
          fontFamily: galyleoFont,
          fontSize: 15,
          submorphs: [{
            name: "placeholder",
            extent: pt(59, 28.8),
            fontFamily: galyleoFont,
            fontSize: 15
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/search.cp.js",
        "export": "GalyleoSearch",
        range: {
          start: 319,
          end: 727
        }
      }, System, __varRecorder__$t, "GalyleoSearch");
      var GalyleoSearch = __varRecorder__$t.GalyleoSearch;
      __varRecorder__$t.GalyleoSearch = GalyleoSearch;

      var __varRecorder__$s = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/toggle.cp.js", __contextModule__);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/toggle.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ToggleMorph") && typeof __lively_classholder__.ToggleMorph === "function" ? __lively_classholder__.ToggleMorph : __lively_classholder__.ToggleMorph = function ToggleMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "positions",
          get: function get() {
            return {
              "false": this.borderWidthLeft,
              "true": this.width - this.getSubmorphNamed("knob").width - this.borderWidthRight
            };
          }
        }, {
          key: "colors",
          get: function get() {
            return {
              "false": Color$1.rgbHex("cccccc"),
              "true": Color$1.rgbHex("33cc33")
            };
          }
        }, {
          key: "onMouseDown",
          value: function ToggleMorph_onMouseDown_(evt) {
            var _this = this;

            this.withAnimationDo(function () {
              _this.state = !_this.state;
            }, {
              duration: 300,
              easing: easings.inOutExpo
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ToggleMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              state: {
                set: function set(aBoolean) {
                  aBoolean = !!aBoolean;
                  this.setProperty("state", aBoolean);
                  this.getSubmorphNamed("trueLabel").visible = aBoolean;
                  this.getSubmorphNamed("falseLabel").visible = !aBoolean;
                  this.getSubmorphNamed("knob").left = this.positions[aBoolean];
                  this.fill = this.borderColor = this.colors[aBoolean];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/inputs/toggle.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 174,
          end: 1107
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      __varRecorder__$s.Toggle = component["for"](function () {
        return component({
          type: __varRecorder__$s.ToggleMorph,
          name: "toggle",
          borderColor: Color$1.rgb(204, 204, 204),
          borderRadius: 20,
          borderWidth: 3,
          clipMode: "hidden",
          dropShadow: false,
          extent: pt(98, 40),
          fill: Color$1.rgb(204, 204, 204),
          position: pt(895.6, 826),
          scale: 0.5,
          submorphs: [{
            type: Label,
            name: "trueLabel",
            fontColor: Color$1.rgb(253, 254, 254),
            fontSize: 25,
            fontWeight: 500,
            position: pt(5.6, 2.6),
            textAndAttributes: ["ON", null],
            visible: false
          }, {
            type: Label,
            name: "falseLabel",
            fontColor: Color$1.rgb(253, 254, 254),
            fontSize: 25,
            fontWeight: 500,
            position: pt(42.7, 3.8),
            textAndAttributes: ["OFF", null]
          }, {
            type: Ellipse,
            name: "knob",
            borderColor: Color$1.rgb(149, 165, 166),
            dropShadow: false,
            extent: pt(33.7, 33.7),
            fill: Color$1.rgb(253, 254, 254),
            isEllipse: true,
            nativeCursor: "pointer",
            position: pt(3, 3)
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/toggle.cp.js",
        "export": "Toggle",
        range: {
          start: 1115,
          end: 2063
        }
      }, System, __varRecorder__$s, "Toggle");
      var Toggle = __varRecorder__$s.Toggle;
      __varRecorder__$s.Toggle = Toggle;

      var t$2 = 2147483647,
          o$3 = /^xn--/,
          n$3 = /[^\0-\x7E]/,
          e$3 = /[\x2E\u3002\uFF0E\uFF61]/g,
          r$3 = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      },
          c$2 = Math.floor,
          s$1 = String.fromCharCode;

      function i$2(t) {
        throw new RangeError(r$3[t]);
      }

      function f$2(t, o) {
        var n = t.split("@");
        var r = "";
        n.length > 1 && (r = n[0] + "@", t = n[1]);

        var c = function (t, o) {
          var n = [];
          var e = t.length;

          for (; e--;) {
            n[e] = o(t[e]);
          }

          return n;
        }((t = t.replace(e$3, ".")).split("."), o).join(".");

        return r + c;
      }

      function l$2(t) {
        var o = [];
        var n = 0;
        var e = t.length;

        for (; n < e;) {
          var _r = t.charCodeAt(n++);

          if (_r >= 55296 && _r <= 56319 && n < e) {
            var _e = t.charCodeAt(n++);

            56320 == (64512 & _e) ? o.push(((1023 & _r) << 10) + (1023 & _e) + 65536) : (o.push(_r), n--);
          } else o.push(_r);
        }

        return o;
      }

      var u$2 = function u(t, o) {
        return t + 22 + 75 * (t < 26) - ((0 != o) << 5);
      },
          a$2 = function a(t, o, n) {
        var e = 0;

        for (t = n ? c$2(t / 700) : t >> 1, t += c$2(t / o); t > 455; e += 36) {
          t = c$2(t / 35);
        }

        return c$2(e + 36 * t / (t + 38));
      },
          d$1 = function d(o) {
        var n = [],
            e = o.length;
        var r = 0,
            s = 128,
            f = 72,
            l = o.lastIndexOf("-");
        l < 0 && (l = 0);

        for (var _t = 0; _t < l; ++_t) {
          o.charCodeAt(_t) >= 128 && i$2("not-basic"), n.push(o.charCodeAt(_t));
        }

        for (var _d = l > 0 ? l + 1 : 0; _d < e;) {
          var _l = r;

          for (var _n = 1, _s = 36;; _s += 36) {
            _d >= e && i$2("invalid-input");

            var _l2 = (u = o.charCodeAt(_d++)) - 48 < 10 ? u - 22 : u - 65 < 26 ? u - 65 : u - 97 < 26 ? u - 97 : 36;

            (_l2 >= 36 || _l2 > c$2((t$2 - r) / _n)) && i$2("overflow"), r += _l2 * _n;

            var _a = _s <= f ? 1 : _s >= f + 26 ? 26 : _s - f;

            if (_l2 < _a) break;

            var _h2 = 36 - _a;

            _n > c$2(t$2 / _h2) && i$2("overflow"), _n *= _h2;
          }

          var _h = n.length + 1;

          f = a$2(r - _l, _h, 0 == _l), c$2(r / _h) > t$2 - s && i$2("overflow"), s += c$2(r / _h), r %= _h, n.splice(r++, 0, s);
        }

        var u;
        return String.fromCodePoint.apply(String, n);
      },
          h$2 = function h(o) {
        var n = [];
        var e = (o = l$2(o)).length,
            r = 128,
            f = 0,
            d = 72;

        var _iterator = _createForOfIteratorHelper(o),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _t4 = _step.value;
            _t4 < 128 && n.push(s$1(_t4));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var h = n.length,
            p = h;

        for (h && n.push("-"); p < e;) {
          var _e2 = t$2;

          var _iterator2 = _createForOfIteratorHelper(o),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _t2 = _step2.value;
              _t2 >= r && _t2 < _e2 && (_e2 = _t2);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          var _l3 = p + 1;

          _e2 - r > c$2((t$2 - f) / _l3) && i$2("overflow"), f += (_e2 - r) * _l3, r = _e2;

          var _iterator3 = _createForOfIteratorHelper(o),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _e3 = _step3.value;

              if (_e3 < r && ++f > t$2 && i$2("overflow"), _e3 == r) {
                var _t3 = f;

                for (var _o = 36;; _o += 36) {
                  var _e4 = _o <= d ? 1 : _o >= d + 26 ? 26 : _o - d;

                  if (_t3 < _e4) break;

                  var _r2 = _t3 - _e4,
                      _i = 36 - _e4;

                  n.push(s$1(u$2(_e4 + _r2 % _i, 0))), _t3 = c$2(_r2 / _i);
                }

                n.push(s$1(u$2(_t3, 0))), d = a$2(f, _l3, p == h), f = 0, ++p;
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          ++f, ++r;
        }

        return n.join("");
      };

      var p$2 = {
        version: "2.1.0",
        ucs2: {
          decode: l$2,
          encode: function encode(t) {
            return String.fromCodePoint.apply(String, _toConsumableArray(t));
          }
        },
        decode: d$1,
        encode: h$2,
        toASCII: function toASCII(t) {
          return f$2(t, function (t) {
            return n$3.test(t) ? "xn--" + h$2(t) : t;
          });
        },
        toUnicode: function toUnicode(t) {
          return f$2(t, function (t) {
            return o$3.test(t) ? d$1(t.slice(4).toLowerCase()) : t;
          });
        }
      };

      function e$2(e, n) {
        return Object.prototype.hasOwnProperty.call(e, n);
      }

      var n$2 = function n(_n, r, t, o) {
        r = r || "&", t = t || "=";
        var a = {};
        if ("string" != typeof _n || 0 === _n.length) return a;
        var u = /\+/g;
        _n = _n.split(r);
        var c = 1000;
        o && "number" == typeof o.maxKeys && (c = o.maxKeys);
        var i = _n.length;
        c > 0 && i > c && (i = c);

        for (var s = 0; s < i; ++s) {
          var p,
              f,
              d,
              y,
              m = _n[s].replace(u, "%20"),
              l = m.indexOf(t);

          l >= 0 ? (p = m.substr(0, l), f = m.substr(l + 1)) : (p = m, f = ""), d = decodeURIComponent(p), y = decodeURIComponent(f), e$2(a, d) ? Array.isArray(a[d]) ? a[d].push(y) : a[d] = [a[d], y] : a[d] = y;
        }

        return a;
      },
          r$2 = function r(e) {
        switch (_typeof(e)) {
          case "string":
            return e;

          case "boolean":
            return e ? "true" : "false";

          case "number":
            return isFinite(e) ? e : "";

          default:
            return "";
        }
      },
          t$1 = function t(e, n, _t, o) {
        return n = n || "&", _t = _t || "=", null === e && (e = void 0), "object" == _typeof(e) ? Object.keys(e).map(function (o) {
          var a = encodeURIComponent(r$2(o)) + _t;

          return Array.isArray(e[o]) ? e[o].map(function (e) {
            return a + encodeURIComponent(r$2(e));
          }).join(n) : a + encodeURIComponent(r$2(e[o]));
        }).join(n) : o ? encodeURIComponent(r$2(o)) + _t + encodeURIComponent(r$2(e)) : "";
      },
          o$2 = {};

      o$2.decode = o$2.parse = n$2, o$2.encode = o$2.stringify = t$1;
      o$2.decode;
      o$2.encode;
      o$2.parse;
      o$2.stringify;

      var e$1,
          t,
          n$1,
          r$1 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global,
          o$1 = e$1 = {};

      function i$1() {
        throw new Error("setTimeout has not been defined");
      }

      function u$1() {
        throw new Error("clearTimeout has not been defined");
      }

      function c$1(e) {
        if (t === setTimeout) return setTimeout(e, 0);
        if ((t === i$1 || !t) && setTimeout) return t = setTimeout, setTimeout(e, 0);

        try {
          return t(e, 0);
        } catch (n) {
          try {
            return t.call(null, e, 0);
          } catch (n) {
            return t.call(this || r$1, e, 0);
          }
        }
      }

      !function () {
        try {
          t = "function" == typeof setTimeout ? setTimeout : i$1;
        } catch (e) {
          t = i$1;
        }

        try {
          n$1 = "function" == typeof clearTimeout ? clearTimeout : u$1;
        } catch (e) {
          n$1 = u$1;
        }
      }();
      var l$1,
          s = [],
          f$1 = !1,
          a$1 = -1;

      function h$1() {
        f$1 && l$1 && (f$1 = !1, l$1.length ? s = l$1.concat(s) : a$1 = -1, s.length && d());
      }

      function d() {
        if (!f$1) {
          var e = c$1(h$1);
          f$1 = !0;

          for (var t = s.length; t;) {
            for (l$1 = s, s = []; ++a$1 < t;) {
              l$1 && l$1[a$1].run();
            }

            a$1 = -1, t = s.length;
          }

          l$1 = null, f$1 = !1, function (e) {
            if (n$1 === clearTimeout) return clearTimeout(e);
            if ((n$1 === u$1 || !n$1) && clearTimeout) return n$1 = clearTimeout, clearTimeout(e);

            try {
              n$1(e);
            } catch (t) {
              try {
                return n$1.call(null, e);
              } catch (t) {
                return n$1.call(this || r$1, e);
              }
            }
          }(e);
        }
      }

      function m$1(e, t) {
        (this || r$1).fun = e, (this || r$1).array = t;
      }

      function p$1() {}

      o$1.nextTick = function (e) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) {
          t[n - 1] = arguments[n];
        }
        s.push(new m$1(e, t)), 1 !== s.length || f$1 || c$1(d);
      }, m$1.prototype.run = function () {
        (this || r$1).fun.apply(null, (this || r$1).array);
      }, o$1.title = "browser", o$1.browser = !0, o$1.env = {}, o$1.argv = [], o$1.version = "", o$1.versions = {}, o$1.on = p$1, o$1.addListener = p$1, o$1.once = p$1, o$1.off = p$1, o$1.removeListener = p$1, o$1.removeAllListeners = p$1, o$1.emit = p$1, o$1.prependListener = p$1, o$1.prependOnceListener = p$1, o$1.listeners = function (e) {
        return [];
      }, o$1.binding = function (e) {
        throw new Error("process.binding is not supported");
      }, o$1.cwd = function () {
        return "/";
      }, o$1.chdir = function (e) {
        throw new Error("process.chdir is not supported");
      }, o$1.umask = function () {
        return 0;
      };
      var T = e$1;
      T.addListener;
      T.argv;
      T.binding;
      T.browser;
      T.chdir;
      T.cwd;
      T.emit;
      T.env;
      T.listeners;
      T.nextTick;
      T.off;
      T.on;
      T.once;
      T.prependListener;
      T.prependOnceListener;
      T.removeAllListeners;
      T.removeListener;
      T.title;
      T.umask;
      T.version;
      T.versions;

      var exports$4 = {},
          _dewExec$2 = false;

      var _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

      function dew$2() {
        if (_dewExec$2) return exports$4;
        _dewExec$2 = true;
        var process = exports$4 = {};
        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }

        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }

        (function () {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }

          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();

        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }

          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }

          try {
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
              return cachedSetTimeout.call(this || _global$1, fun, 0);
            }
          }
        }

        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }

          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }

          try {
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e) {
              return cachedClearTimeout.call(this || _global$1, marker);
            }
          }
        }

        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }

          draining = false;

          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }

          if (queue.length) {
            drainQueue();
          }
        }

        function drainQueue() {
          if (draining) {
            return;
          }

          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;

          while (len) {
            currentQueue = queue;
            queue = [];

            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }

            queueIndex = -1;
            len = queue.length;
          }

          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }

        process.nextTick = function (fun) {
          var args = new Array(arguments.length - 1);

          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }

          queue.push(new Item(fun, args));

          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };

        function Item(fun, array) {
          (this || _global$1).fun = fun;
          (this || _global$1).array = array;
        }

        Item.prototype.run = function () {
          (this || _global$1).fun.apply(null, (this || _global$1).array);
        };

        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;

        process.listeners = function (name) {
          return [];
        };

        process.binding = function (name) {
          throw new Error("process.binding is not supported");
        };

        process.cwd = function () {
          return "/";
        };

        process.chdir = function (dir) {
          throw new Error("process.chdir is not supported");
        };

        process.umask = function () {
          return 0;
        };

        return exports$4;
      }

      var process = dew$2();
      process.platform = "browser";
      process.addListener;
      process.argv;
      process.binding;
      process.browser;
      process.chdir;
      process.cwd;
      process.emit;
      process.env;
      process.listeners;
      process.nextTick;
      process.off;
      process.on;
      process.once;
      process.prependListener;
      process.prependOnceListener;
      process.removeAllListeners;
      process.removeListener;
      process.title;
      process.umask;
      process.version;
      process.versions;

      var exports$1$1 = {},
          _dewExec$1 = false;

      function dew$1() {
        if (_dewExec$1) return exports$1$1;
        _dewExec$1 = true;
        var process$1 = process;

        function assertPath(path) {
          if (typeof path !== "string") {
            throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
          }
        }

        function normalizeStringPosix(path, allowAboveRoot) {
          var res = "";
          var lastSegmentLength = 0;
          var lastSlash = -1;
          var dots = 0;
          var code;

          for (var i = 0; i <= path.length; ++i) {
            if (i < path.length) code = path.charCodeAt(i);else if (code === 47) break;else code = 47;

            if (code === 47) {
              if (lastSlash === i - 1 || dots === 1) ;else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                  if (res.length > 2) {
                    var lastSlashIndex = res.lastIndexOf("/");

                    if (lastSlashIndex !== res.length - 1) {
                      if (lastSlashIndex === -1) {
                        res = "";
                        lastSegmentLength = 0;
                      } else {
                        res = res.slice(0, lastSlashIndex);
                        lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                      }

                      lastSlash = i;
                      dots = 0;
                      continue;
                    }
                  } else if (res.length === 2 || res.length === 1) {
                    res = "";
                    lastSegmentLength = 0;
                    lastSlash = i;
                    dots = 0;
                    continue;
                  }
                }

                if (allowAboveRoot) {
                  if (res.length > 0) res += "/..";else res = "..";
                  lastSegmentLength = 2;
                }
              } else {
                if (res.length > 0) res += "/" + path.slice(lastSlash + 1, i);else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
              }
              lastSlash = i;
              dots = 0;
            } else if (code === 46 && dots !== -1) {
              ++dots;
            } else {
              dots = -1;
            }
          }

          return res;
        }

        function _format(sep, pathObject) {
          var dir = pathObject.dir || pathObject.root;
          var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");

          if (!dir) {
            return base;
          }

          if (dir === pathObject.root) {
            return dir + base;
          }

          return dir + sep + base;
        }

        var posix = {
          resolve: function resolve() {
            var resolvedPath = "";
            var resolvedAbsolute = false;
            var cwd;

            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path;
              if (i >= 0) path = arguments[i];else {
                if (cwd === undefined) cwd = process$1.cwd();
                path = cwd;
              }
              assertPath(path);

              if (path.length === 0) {
                continue;
              }

              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charCodeAt(0) === 47;
            }

            resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

            if (resolvedAbsolute) {
              if (resolvedPath.length > 0) return "/" + resolvedPath;else return "/";
            } else if (resolvedPath.length > 0) {
              return resolvedPath;
            } else {
              return ".";
            }
          },
          normalize: function normalize(path) {
            assertPath(path);
            if (path.length === 0) return ".";
            var isAbsolute = path.charCodeAt(0) === 47;
            var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
            path = normalizeStringPosix(path, !isAbsolute);
            if (path.length === 0 && !isAbsolute) path = ".";
            if (path.length > 0 && trailingSeparator) path += "/";
            if (isAbsolute) return "/" + path;
            return path;
          },
          isAbsolute: function isAbsolute(path) {
            assertPath(path);
            return path.length > 0 && path.charCodeAt(0) === 47;
          },
          join: function join() {
            if (arguments.length === 0) return ".";
            var joined;

            for (var i = 0; i < arguments.length; ++i) {
              var arg = arguments[i];
              assertPath(arg);

              if (arg.length > 0) {
                if (joined === undefined) joined = arg;else joined += "/" + arg;
              }
            }

            if (joined === undefined) return ".";
            return posix.normalize(joined);
          },
          relative: function relative(from, to) {
            assertPath(from);
            assertPath(to);
            if (from === to) return "";
            from = posix.resolve(from);
            to = posix.resolve(to);
            if (from === to) return "";
            var fromStart = 1;

            for (; fromStart < from.length; ++fromStart) {
              if (from.charCodeAt(fromStart) !== 47) break;
            }

            var fromEnd = from.length;
            var fromLen = fromEnd - fromStart;
            var toStart = 1;

            for (; toStart < to.length; ++toStart) {
              if (to.charCodeAt(toStart) !== 47) break;
            }

            var toEnd = to.length;
            var toLen = toEnd - toStart;
            var length = fromLen < toLen ? fromLen : toLen;
            var lastCommonSep = -1;
            var i = 0;

            for (; i <= length; ++i) {
              if (i === length) {
                if (toLen > length) {
                  if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                  } else if (i === 0) {
                    return to.slice(toStart + i);
                  }
                } else if (fromLen > length) {
                  if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                  } else if (i === 0) {
                    lastCommonSep = 0;
                  }
                }

                break;
              }

              var fromCode = from.charCodeAt(fromStart + i);
              var toCode = to.charCodeAt(toStart + i);
              if (fromCode !== toCode) break;else if (fromCode === 47) lastCommonSep = i;
            }

            var out = "";

            for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
              if (i === fromEnd || from.charCodeAt(i) === 47) {
                if (out.length === 0) out += "..";else out += "/..";
              }
            }

            if (out.length > 0) return out + to.slice(toStart + lastCommonSep);else {
              toStart += lastCommonSep;
              if (to.charCodeAt(toStart) === 47) ++toStart;
              return to.slice(toStart);
            }
          },
          _makeLong: function _makeLong(path) {
            return path;
          },
          dirname: function dirname(path) {
            assertPath(path);
            if (path.length === 0) return ".";
            var code = path.charCodeAt(0);
            var hasRoot = code === 47;
            var end = -1;
            var matchedSlash = true;

            for (var i = path.length - 1; i >= 1; --i) {
              code = path.charCodeAt(i);

              if (code === 47) {
                if (!matchedSlash) {
                  end = i;
                  break;
                }
              } else {
                matchedSlash = false;
              }
            }

            if (end === -1) return hasRoot ? "/" : ".";
            if (hasRoot && end === 1) return "//";
            return path.slice(0, end);
          },
          basename: function basename(path, ext) {
            if (ext !== undefined && typeof ext !== "string") throw new TypeError("\"ext\" argument must be a string");
            assertPath(path);
            var start = 0;
            var end = -1;
            var matchedSlash = true;
            var i;

            if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
              if (ext.length === path.length && ext === path) return "";
              var extIdx = ext.length - 1;
              var firstNonSlashEnd = -1;

              for (i = path.length - 1; i >= 0; --i) {
                var code = path.charCodeAt(i);

                if (code === 47) {
                  if (!matchedSlash) {
                    start = i + 1;
                    break;
                  }
                } else {
                  if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                  }

                  if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                      if (--extIdx === -1) {
                        end = i;
                      }
                    } else {
                      extIdx = -1;
                      end = firstNonSlashEnd;
                    }
                  }
                }
              }

              if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
              return path.slice(start, end);
            } else {
              for (i = path.length - 1; i >= 0; --i) {
                if (path.charCodeAt(i) === 47) {
                  if (!matchedSlash) {
                    start = i + 1;
                    break;
                  }
                } else if (end === -1) {
                  matchedSlash = false;
                  end = i + 1;
                }
              }

              if (end === -1) return "";
              return path.slice(start, end);
            }
          },
          extname: function extname(path) {
            assertPath(path);
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            var preDotState = 0;

            for (var i = path.length - 1; i >= 0; --i) {
              var code = path.charCodeAt(i);

              if (code === 47) {
                if (!matchedSlash) {
                  startPart = i + 1;
                  break;
                }

                continue;
              }

              if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }

              if (code === 46) {
                if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
              } else if (startDot !== -1) {
                preDotState = -1;
              }
            }

            if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              return "";
            }

            return path.slice(startDot, end);
          },
          format: function format(pathObject) {
            if (pathObject === null || _typeof(pathObject) !== "object") {
              throw new TypeError("The \"pathObject\" argument must be of type Object. Received type " + _typeof(pathObject));
            }

            return _format("/", pathObject);
          },
          parse: function parse(path) {
            assertPath(path);
            var ret = {
              root: "",
              dir: "",
              base: "",
              ext: "",
              name: ""
            };
            if (path.length === 0) return ret;
            var code = path.charCodeAt(0);
            var isAbsolute = code === 47;
            var start;

            if (isAbsolute) {
              ret.root = "/";
              start = 1;
            } else {
              start = 0;
            }

            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            var i = path.length - 1;
            var preDotState = 0;

            for (; i >= start; --i) {
              code = path.charCodeAt(i);

              if (code === 47) {
                if (!matchedSlash) {
                  startPart = i + 1;
                  break;
                }

                continue;
              }

              if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }

              if (code === 46) {
                if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
              } else if (startDot !== -1) {
                preDotState = -1;
              }
            }

            if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              if (end !== -1) {
                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
              }
            } else {
              if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
              } else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
              }

              ret.ext = path.slice(startDot, end);
            }

            if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = "/";
            return ret;
          },
          sep: "/",
          delimiter: ":",
          win32: null,
          posix: null
        };
        posix.posix = posix;
        exports$1$1 = posix;
        return exports$1$1;
      }

      var exports$3 = dew$1();

      var h = {}, e = p$2, a = {
          isString: function (t) {
            return "string" == typeof t;
          },
          isObject: function (t) {
            return "object" == typeof t && null !== t;
          },
          isNull: function (t) {
            return null === t;
          },
          isNullOrUndefined: function (t) {
            return null == t;
          }
        };
      function r() {
        this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
      }
      h.parse = O, h.resolve = function (t, s) {
        return O(t, !1, !0).resolve(s);
      }, h.resolveObject = function (t, s) {
        return t ? O(t, !1, !0).resolveObject(s) : s;
      }, h.format = function (t) {
        a.isString(t) && (t = O(t));
        return t instanceof r ? t.format() : r.prototype.format.call(t);
      }, h.Url = r;
      var o = /^([a-z0-9.+-]+:)/i, n = /:[0-9]*$/, i = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, l = [
          "{",
          "}",
          "|",
          "\\",
          "^",
          "`"
        ].concat([
          "<",
          ">",
          "\"",
          "`",
          " ",
          "\r",
          "\n",
          "\t"
        ]), p = ["'"].concat(l), c = [
          "%",
          "/",
          "?",
          ";",
          "#"
        ].concat(p), u = [
          "/",
          "?",
          "#"
        ], f = /^[+a-z0-9A-Z_-]{0,63}$/, m = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, v = {
          javascript: !0,
          "javascript:": !0
        }, g = {
          javascript: !0,
          "javascript:": !0
        }, y = {
          http: !0,
          https: !0,
          ftp: !0,
          gopher: !0,
          file: !0,
          "http:": !0,
          "https:": !0,
          "ftp:": !0,
          "gopher:": !0,
          "file:": !0
        }, b = o$2;
      function O(t, s, h) {
        if (t && a.isObject(t) && t instanceof r)
          return t;
        var e = new r();
        return e.parse(t, s, h), e;
      }
      r.prototype.parse = function (t, s, h) {
        if (!a.isString(t))
          throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
        var r = t.indexOf("?"), n = -1 !== r && r < t.indexOf("#") ? "?" : "#", l = t.split(n);
        l[0] = l[0].replace(/\\/g, "/");
        var O = t = l.join(n);
        if (O = O.trim(), !h && 1 === t.split("#").length) {
          var d = i.exec(O);
          if (d)
            return this.path = O, this.href = O, this.pathname = d[1], d[2] ? (this.search = d[2], this.query = s ? b.parse(this.search.substr(1)) : this.search.substr(1)) : s && (this.search = "", this.query = {}), this;
        }
        var j = o.exec(O);
        if (j) {
          var q = (j = j[0]).toLowerCase();
          this.protocol = q, O = O.substr(j.length);
        }
        if (h || j || O.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var x = "//" === O.substr(0, 2);
          !x || j && g[j] || (O = O.substr(2), this.slashes = !0);
        }
        if (!g[j] && (x || j && !y[j])) {
          for (var A, C, I = -1, w = 0; w < u.length; w++) {
            -1 !== (N = O.indexOf(u[w])) && (-1 === I || N < I) && (I = N);
          }
          -1 !== (C = -1 === I ? O.lastIndexOf("@") : O.lastIndexOf("@", I)) && (A = O.slice(0, C), O = O.slice(C + 1), this.auth = decodeURIComponent(A)), I = -1;
          for (w = 0; w < c.length; w++) {
            var N;
            -1 !== (N = O.indexOf(c[w])) && (-1 === I || N < I) && (I = N);
          }
          -1 === I && (I = O.length), this.host = O.slice(0, I), O = O.slice(I), this.parseHost(), this.hostname = this.hostname || "";
          var U = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
          if (!U)
            for (var k = this.hostname.split(/\./), S = (w = 0, k.length); w < S; w++) {
              var R = k[w];
              if (R && !R.match(f)) {
                for (var $ = "", z = 0, H = R.length; z < H; z++)
                  R.charCodeAt(z) > 127 ? $ += "x" : $ += R[z];
                if (!$.match(f)) {
                  var L = k.slice(0, w), Z = k.slice(w + 1), _ = R.match(m);
                  _ && (L.push(_[1]), Z.unshift(_[2])), Z.length && (O = "/" + Z.join(".") + O), this.hostname = L.join(".");
                  break;
                }
              }
            }
          this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), U || (this.hostname = e.toASCII(this.hostname));
          var E = this.port ? ":" + this.port : "", P = this.hostname || "";
          this.host = P + E, this.href += this.host, U && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O[0] && (O = "/" + O));
        }
        if (!v[q])
          for (w = 0, S = p.length; w < S; w++) {
            var T = p[w];
            if (-1 !== O.indexOf(T)) {
              var B = encodeURIComponent(T);
              B === T && (B = escape(T)), O = O.split(T).join(B);
            }
          }
        var D = O.indexOf("#");
        -1 !== D && (this.hash = O.substr(D), O = O.slice(0, D));
        var F = O.indexOf("?");
        if (-1 !== F ? (this.search = O.substr(F), this.query = O.substr(F + 1), s && (this.query = b.parse(this.query)), O = O.slice(0, F)) : s && (this.search = "", this.query = {}), O && (this.pathname = O), y[q] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
          E = this.pathname || "";
          var G = this.search || "";
          this.path = E + G;
        }
        return this.href = this.format(), this;
      }, r.prototype.format = function () {
        var t = this.auth || "";
        t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ":"), t += "@");
        var s = this.protocol || "", h = this.pathname || "", e = this.hash || "", r = !1, o = "";
        this.host ? r = t + this.host : this.hostname && (r = t + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r += ":" + this.port)), this.query && a.isObject(this.query) && Object.keys(this.query).length && (o = b.stringify(this.query));
        var n = this.search || o && "?" + o || "";
        return s && ":" !== s.substr(-1) && (s += ":"), this.slashes || (!s || y[s]) && !1 !== r ? (r = "//" + (r || ""), h && "/" !== h.charAt(0) && (h = "/" + h)) : r || (r = ""), e && "#" !== e.charAt(0) && (e = "#" + e), n && "?" !== n.charAt(0) && (n = "?" + n), s + r + (h = h.replace(/[?#]/g, function (t) {
          return encodeURIComponent(t);
        })) + (n = n.replace("#", "%23")) + e;
      }, r.prototype.resolve = function (t) {
        return this.resolveObject(O(t, !1, !0)).format();
      }, r.prototype.resolveObject = function (t) {
        if (a.isString(t)) {
          var s = new r();
          s.parse(t, !1, !0), t = s;
        }
        for (var h = new r(), e = Object.keys(this), o = 0; o < e.length; o++) {
          var n = e[o];
          h[n] = this[n];
        }
        if (h.hash = t.hash, "" === t.href)
          return h.href = h.format(), h;
        if (t.slashes && !t.protocol) {
          for (var i = Object.keys(t), l = 0; l < i.length; l++) {
            var p = i[l];
            "protocol" !== p && (h[p] = t[p]);
          }
          return y[h.protocol] && h.hostname && !h.pathname && (h.path = h.pathname = "/"), h.href = h.format(), h;
        }
        if (t.protocol && t.protocol !== h.protocol) {
          if (!y[t.protocol]) {
            for (var c = Object.keys(t), u = 0; u < c.length; u++) {
              var f = c[u];
              h[f] = t[f];
            }
            return h.href = h.format(), h;
          }
          if (h.protocol = t.protocol, t.host || g[t.protocol])
            h.pathname = t.pathname;
          else {
            for (var m = (t.pathname || "").split("/"); m.length && !(t.host = m.shift()););
            t.host || (t.host = ""), t.hostname || (t.hostname = ""), "" !== m[0] && m.unshift(""), m.length < 2 && m.unshift(""), h.pathname = m.join("/");
          }
          if (h.search = t.search, h.query = t.query, h.host = t.host || "", h.auth = t.auth, h.hostname = t.hostname || t.host, h.port = t.port, h.pathname || h.search) {
            var v = h.pathname || "", b = h.search || "";
            h.path = v + b;
          }
          return h.slashes = h.slashes || t.slashes, h.href = h.format(), h;
        }
        var O = h.pathname && "/" === h.pathname.charAt(0), d = t.host || t.pathname && "/" === t.pathname.charAt(0), j = d || O || h.host && t.pathname, q = j, x = h.pathname && h.pathname.split("/") || [], A = (m = t.pathname && t.pathname.split("/") || [], h.protocol && !y[h.protocol]);
        if (A && (h.hostname = "", h.port = null, h.host && ("" === x[0] ? x[0] = h.host : x.unshift(h.host)), h.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && ("" === m[0] ? m[0] = t.host : m.unshift(t.host)), t.host = null), j = j && ("" === m[0] || "" === x[0])), d)
          h.host = t.host || "" === t.host ? t.host : h.host, h.hostname = t.hostname || "" === t.hostname ? t.hostname : h.hostname, h.search = t.search, h.query = t.query, x = m;
        else if (m.length)
          x || (x = []), x.pop(), x = x.concat(m), h.search = t.search, h.query = t.query;
        else if (!a.isNullOrUndefined(t.search)) {
          if (A)
            h.hostname = h.host = x.shift(), (U = !!(h.host && h.host.indexOf("@") > 0) && h.host.split("@")) && (h.auth = U.shift(), h.host = h.hostname = U.shift());
          return h.search = t.search, h.query = t.query, a.isNull(h.pathname) && a.isNull(h.search) || (h.path = (h.pathname ? h.pathname : "") + (h.search ? h.search : "")), h.href = h.format(), h;
        }
        if (!x.length)
          return h.pathname = null, h.search ? h.path = "/" + h.search : h.path = null, h.href = h.format(), h;
        for (var C = x.slice(-1)[0], I = (h.host || t.host || x.length > 1) && ("." === C || ".." === C) || "" === C, w = 0, N = x.length; N >= 0; N--)
          "." === (C = x[N]) ? x.splice(N, 1) : ".." === C ? (x.splice(N, 1), w++) : w && (x.splice(N, 1), w--);
        if (!j && !q)
          for (; w--; w)
            x.unshift("..");
        !j || "" === x[0] || x[0] && "/" === x[0].charAt(0) || x.unshift(""), I && "/" !== x.join("/").substr(-1) && x.push("");
        var U, k = "" === x[0] || x[0] && "/" === x[0].charAt(0);
        A && (h.hostname = h.host = k ? "" : x.length ? x.shift() : "", (U = !!(h.host && h.host.indexOf("@") > 0) && h.host.split("@")) && (h.auth = U.shift(), h.host = h.hostname = U.shift()));
        return (j = j || h.host && x.length) && !k && x.unshift(""), x.length ? h.pathname = x.join("/") : (h.pathname = null, h.path = null), a.isNull(h.pathname) && a.isNull(h.search) || (h.path = (h.pathname ? h.pathname : "") + (h.search ? h.search : "")), h.auth = t.auth || h.auth, h.slashes = h.slashes || t.slashes, h.href = h.format(), h;
      }, r.prototype.parseHost = function () {
        var t = this.host, s = n.exec(t);
        s && (":" !== (s = s[0]) && (this.port = s.substr(1)), t = t.substr(0, t.length - s.length)), t && (this.hostname = t);
      };
      var exports$2 = {}, _dewExec = false;
      function dew() {
        if (_dewExec)
          return exports$2;
        _dewExec = true;
        var process = T;
        function assertPath(path) {
          if (typeof path !== "string") {
            throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
          }
        }
        function normalizeStringPosix(path, allowAboveRoot) {
          var res = "";
          var lastSegmentLength = 0;
          var lastSlash = -1;
          var dots = 0;
          var code;
          for (var i = 0; i <= path.length; ++i) {
            if (i < path.length)
              code = path.charCodeAt(i);
            else if (code === 47)
              break;
            else
              code = 47;
            if (code === 47) {
              if (lastSlash === i - 1 || dots === 1);
              else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                  if (res.length > 2) {
                    var lastSlashIndex = res.lastIndexOf("/");
                    if (lastSlashIndex !== res.length - 1) {
                      if (lastSlashIndex === -1) {
                        res = "";
                        lastSegmentLength = 0;
                      } else {
                        res = res.slice(0, lastSlashIndex);
                        lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                      }
                      lastSlash = i;
                      dots = 0;
                      continue;
                    }
                  } else if (res.length === 2 || res.length === 1) {
                    res = "";
                    lastSegmentLength = 0;
                    lastSlash = i;
                    dots = 0;
                    continue;
                  }
                }
                if (allowAboveRoot) {
                  if (res.length > 0)
                    res += "/..";
                  else
                    res = "..";
                  lastSegmentLength = 2;
                }
              } else {
                if (res.length > 0)
                  res += "/" + path.slice(lastSlash + 1, i);
                else
                  res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
              }
              lastSlash = i;
              dots = 0;
            } else if (code === 46 && dots !== -1) {
              ++dots;
            } else {
              dots = -1;
            }
          }
          return res;
        }
        function _format(sep, pathObject) {
          var dir = pathObject.dir || pathObject.root;
          var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
          if (!dir) {
            return base;
          }
          if (dir === pathObject.root) {
            return dir + base;
          }
          return dir + sep + base;
        }
        var posix = {
          resolve: function resolve() {
            var resolvedPath = "";
            var resolvedAbsolute = false;
            var cwd;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path;
              if (i >= 0)
                path = arguments[i];
              else {
                if (cwd === undefined)
                  cwd = process.cwd();
                path = cwd;
              }
              assertPath(path);
              if (path.length === 0) {
                continue;
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charCodeAt(0) === 47;
            }
            resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
            if (resolvedAbsolute) {
              if (resolvedPath.length > 0)
                return "/" + resolvedPath;
              else
                return "/";
            } else if (resolvedPath.length > 0) {
              return resolvedPath;
            } else {
              return ".";
            }
          },
          normalize: function normalize(path) {
            assertPath(path);
            if (path.length === 0)
              return ".";
            var isAbsolute = path.charCodeAt(0) === 47;
            var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
            path = normalizeStringPosix(path, !isAbsolute);
            if (path.length === 0 && !isAbsolute)
              path = ".";
            if (path.length > 0 && trailingSeparator)
              path += "/";
            if (isAbsolute)
              return "/" + path;
            return path;
          },
          isAbsolute: function isAbsolute(path) {
            assertPath(path);
            return path.length > 0 && path.charCodeAt(0) === 47;
          },
          join: function join() {
            if (arguments.length === 0)
              return ".";
            var joined;
            for (var i = 0; i < arguments.length; ++i) {
              var arg = arguments[i];
              assertPath(arg);
              if (arg.length > 0) {
                if (joined === undefined)
                  joined = arg;
                else
                  joined += "/" + arg;
              }
            }
            if (joined === undefined)
              return ".";
            return posix.normalize(joined);
          },
          relative: function relative(from, to) {
            assertPath(from);
            assertPath(to);
            if (from === to)
              return "";
            from = posix.resolve(from);
            to = posix.resolve(to);
            if (from === to)
              return "";
            var fromStart = 1;
            for (; fromStart < from.length; ++fromStart) {
              if (from.charCodeAt(fromStart) !== 47)
                break;
            }
            var fromEnd = from.length;
            var fromLen = fromEnd - fromStart;
            var toStart = 1;
            for (; toStart < to.length; ++toStart) {
              if (to.charCodeAt(toStart) !== 47)
                break;
            }
            var toEnd = to.length;
            var toLen = toEnd - toStart;
            var length = fromLen < toLen ? fromLen : toLen;
            var lastCommonSep = -1;
            var i = 0;
            for (; i <= length; ++i) {
              if (i === length) {
                if (toLen > length) {
                  if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                  } else if (i === 0) {
                    return to.slice(toStart + i);
                  }
                } else if (fromLen > length) {
                  if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                  } else if (i === 0) {
                    lastCommonSep = 0;
                  }
                }
                break;
              }
              var fromCode = from.charCodeAt(fromStart + i);
              var toCode = to.charCodeAt(toStart + i);
              if (fromCode !== toCode)
                break;
              else if (fromCode === 47)
                lastCommonSep = i;
            }
            var out = "";
            for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
              if (i === fromEnd || from.charCodeAt(i) === 47) {
                if (out.length === 0)
                  out += "..";
                else
                  out += "/..";
              }
            }
            if (out.length > 0)
              return out + to.slice(toStart + lastCommonSep);
            else {
              toStart += lastCommonSep;
              if (to.charCodeAt(toStart) === 47)
                ++toStart;
              return to.slice(toStart);
            }
          },
          _makeLong: function _makeLong(path) {
            return path;
          },
          dirname: function dirname(path) {
            assertPath(path);
            if (path.length === 0)
              return ".";
            var code = path.charCodeAt(0);
            var hasRoot = code === 47;
            var end = -1;
            var matchedSlash = true;
            for (var i = path.length - 1; i >= 1; --i) {
              code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  end = i;
                  break;
                }
              } else {
                matchedSlash = false;
              }
            }
            if (end === -1)
              return hasRoot ? "/" : ".";
            if (hasRoot && end === 1)
              return "//";
            return path.slice(0, end);
          },
          basename: function basename(path, ext) {
            if (ext !== undefined && typeof ext !== "string")
              throw new TypeError("\"ext\" argument must be a string");
            assertPath(path);
            var start = 0;
            var end = -1;
            var matchedSlash = true;
            var i;
            if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
              if (ext.length === path.length && ext === path)
                return "";
              var extIdx = ext.length - 1;
              var firstNonSlashEnd = -1;
              for (i = path.length - 1; i >= 0; --i) {
                var code = path.charCodeAt(i);
                if (code === 47) {
                  if (!matchedSlash) {
                    start = i + 1;
                    break;
                  }
                } else {
                  if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                  }
                  if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                      if (--extIdx === -1) {
                        end = i;
                      }
                    } else {
                      extIdx = -1;
                      end = firstNonSlashEnd;
                    }
                  }
                }
              }
              if (start === end)
                end = firstNonSlashEnd;
              else if (end === -1)
                end = path.length;
              return path.slice(start, end);
            } else {
              for (i = path.length - 1; i >= 0; --i) {
                if (path.charCodeAt(i) === 47) {
                  if (!matchedSlash) {
                    start = i + 1;
                    break;
                  }
                } else if (end === -1) {
                  matchedSlash = false;
                  end = i + 1;
                }
              }
              if (end === -1)
                return "";
              return path.slice(start, end);
            }
          },
          extname: function extname(path) {
            assertPath(path);
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            var preDotState = 0;
            for (var i = path.length - 1; i >= 0; --i) {
              var code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  startPart = i + 1;
                  break;
                }
                continue;
              }
              if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
              if (code === 46) {
                if (startDot === -1)
                  startDot = i;
                else if (preDotState !== 1)
                  preDotState = 1;
              } else if (startDot !== -1) {
                preDotState = -1;
              }
            }
            if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              return "";
            }
            return path.slice(startDot, end);
          },
          format: function format(pathObject) {
            if (pathObject === null || typeof pathObject !== "object") {
              throw new TypeError("The \"pathObject\" argument must be of type Object. Received type " + typeof pathObject);
            }
            return _format("/", pathObject);
          },
          parse: function parse(path) {
            assertPath(path);
            var ret = {
              root: "",
              dir: "",
              base: "",
              ext: "",
              name: ""
            };
            if (path.length === 0)
              return ret;
            var code = path.charCodeAt(0);
            var isAbsolute = code === 47;
            var start;
            if (isAbsolute) {
              ret.root = "/";
              start = 1;
            } else {
              start = 0;
            }
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            var i = path.length - 1;
            var preDotState = 0;
            for (; i >= start; --i) {
              code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  startPart = i + 1;
                  break;
                }
                continue;
              }
              if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
              if (code === 46) {
                if (startDot === -1)
                  startDot = i;
                else if (preDotState !== 1)
                  preDotState = 1;
              } else if (startDot !== -1) {
                preDotState = -1;
              }
            }
            if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              if (end !== -1) {
                if (startPart === 0 && isAbsolute)
                  ret.base = ret.name = path.slice(1, end);
                else
                  ret.base = ret.name = path.slice(startPart, end);
              }
            } else {
              if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
              } else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
              }
              ret.ext = path.slice(startDot, end);
            }
            if (startPart > 0)
              ret.dir = path.slice(0, startPart - 1);
            else if (isAbsolute)
              ret.dir = "/";
            return ret;
          },
          sep: "/",
          delimiter: ":",
          win32: null,
          posix: null
        };
        posix.posix = posix;
        exports$2 = posix;
        return exports$2;
      }
      var path = dew();
      const processPlatform$1 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : undefined;
      h.URL = typeof URL !== "undefined" ? URL : null;
      h.pathToFileURL = pathToFileURL$1;
      h.fileURLToPath = fileURLToPath$1;
      const CHAR_BACKWARD_SLASH$1 = 92;
      const CHAR_FORWARD_SLASH$1 = 47;
      const CHAR_LOWERCASE_A$1 = 97;
      const CHAR_LOWERCASE_Z$1 = 122;
      const isWindows$1 = processPlatform$1 === "win32";
      const forwardSlashRegEx$1 = /\//g;
      const percentRegEx$1 = /%/g;
      const backslashRegEx$1 = /\\/g;
      const newlineRegEx$1 = /\n/g;
      const carriageReturnRegEx$1 = /\r/g;
      const tabRegEx$1 = /\t/g;
      function fileURLToPath$1(path) {
        if (typeof path === "string")
          path = new URL(path);
        else if (!(path instanceof URL)) {
          throw new Deno.errors.InvalidData("invalid argument path , must be a string or URL");
        }
        if (path.protocol !== "file:") {
          throw new Deno.errors.InvalidData("invalid url scheme");
        }
        return isWindows$1 ? getPathFromURLWin$1(path) : getPathFromURLPosix$1(path);
      }
      function getPathFromURLWin$1(url) {
        const hostname = url.hostname;
        let pathname = url.pathname;
        for (let n = 0; n < pathname.length; n++) {
          if (pathname[n] === "%") {
            const third = pathname.codePointAt(n + 2) || 32;
            if (pathname[n + 1] === "2" && third === 102 || pathname[n + 1] === "5" && third === 99) {
              throw new Deno.errors.InvalidData("must not include encoded \\ or / characters");
            }
          }
        }
        pathname = pathname.replace(forwardSlashRegEx$1, "\\");
        pathname = decodeURIComponent(pathname);
        if (hostname !== "") {
          return `\\\\${ hostname }${ pathname }`;
        } else {
          const letter = pathname.codePointAt(1) | 32;
          const sep = pathname[2];
          if (letter < CHAR_LOWERCASE_A$1 || letter > CHAR_LOWERCASE_Z$1 || sep !== ":") {
            throw new Deno.errors.InvalidData("file url path must be absolute");
          }
          return pathname.slice(1);
        }
      }
      function getPathFromURLPosix$1(url) {
        if (url.hostname !== "") {
          throw new Deno.errors.InvalidData("invalid file url hostname");
        }
        const pathname = url.pathname;
        for (let n = 0; n < pathname.length; n++) {
          if (pathname[n] === "%") {
            const third = pathname.codePointAt(n + 2) || 32;
            if (pathname[n + 1] === "2" && third === 102) {
              throw new Deno.errors.InvalidData("must not include encoded / characters");
            }
          }
        }
        return decodeURIComponent(pathname);
      }
      function pathToFileURL$1(filepath) {
        let resolved = path.resolve(filepath);
        const filePathLast = filepath.charCodeAt(filepath.length - 1);
        if ((filePathLast === CHAR_FORWARD_SLASH$1 || isWindows$1 && filePathLast === CHAR_BACKWARD_SLASH$1) && resolved[resolved.length - 1] !== path.sep) {
          resolved += "/";
        }
        const outURL = new URL("file://");
        if (resolved.includes("%"))
          resolved = resolved.replace(percentRegEx$1, "%25");
        if (!isWindows$1 && resolved.includes("\\")) {
          resolved = resolved.replace(backslashRegEx$1, "%5C");
        }
        if (resolved.includes("\n"))
          resolved = resolved.replace(newlineRegEx$1, "%0A");
        if (resolved.includes("\r")) {
          resolved = resolved.replace(carriageReturnRegEx$1, "%0D");
        }
        if (resolved.includes("\t"))
          resolved = resolved.replace(tabRegEx$1, "%09");
        outURL.pathname = resolved;
        return outURL;
      }
      const processPlatform = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : undefined;
      h.URL = typeof URL !== "undefined" ? URL : null;
      h.pathToFileURL = pathToFileURL;
      h.fileURLToPath = fileURLToPath;
      const _URL = h.URL;
      const CHAR_BACKWARD_SLASH = 92;
      const CHAR_FORWARD_SLASH = 47;
      const CHAR_LOWERCASE_A = 97;
      const CHAR_LOWERCASE_Z = 122;
      const isWindows = processPlatform === "win32";
      const forwardSlashRegEx = /\//g;
      const percentRegEx = /%/g;
      const backslashRegEx = /\\/g;
      const newlineRegEx = /\n/g;
      const carriageReturnRegEx = /\r/g;
      const tabRegEx = /\t/g;
      function fileURLToPath(path) {
        if (typeof path === "string")
          path = new URL(path);
        else if (!(path instanceof URL)) {
          throw new Deno.errors.InvalidData("invalid argument path , must be a string or URL");
        }
        if (path.protocol !== "file:") {
          throw new Deno.errors.InvalidData("invalid url scheme");
        }
        return isWindows ? getPathFromURLWin(path) : getPathFromURLPosix(path);
      }
      function getPathFromURLWin(url) {
        const hostname = url.hostname;
        let pathname = url.pathname;
        for (let n = 0; n < pathname.length; n++) {
          if (pathname[n] === "%") {
            const third = pathname.codePointAt(n + 2) || 32;
            if (pathname[n + 1] === "2" && third === 102 || pathname[n + 1] === "5" && third === 99) {
              throw new Deno.errors.InvalidData("must not include encoded \\ or / characters");
            }
          }
        }
        pathname = pathname.replace(forwardSlashRegEx, "\\");
        pathname = decodeURIComponent(pathname);
        if (hostname !== "") {
          return `\\\\${ hostname }${ pathname }`;
        } else {
          const letter = pathname.codePointAt(1) | 32;
          const sep = pathname[2];
          if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || sep !== ":") {
            throw new Deno.errors.InvalidData("file url path must be absolute");
          }
          return pathname.slice(1);
        }
      }
      function getPathFromURLPosix(url) {
        if (url.hostname !== "") {
          throw new Deno.errors.InvalidData("invalid file url hostname");
        }
        const pathname = url.pathname;
        for (let n = 0; n < pathname.length; n++) {
          if (pathname[n] === "%") {
            const third = pathname.codePointAt(n + 2) || 32;
            if (pathname[n + 1] === "2" && third === 102) {
              throw new Deno.errors.InvalidData("must not include encoded / characters");
            }
          }
        }
        return decodeURIComponent(pathname);
      }
      function pathToFileURL(filepath) {
        let resolved = exports$3.resolve(filepath);
        const filePathLast = filepath.charCodeAt(filepath.length - 1);
        if ((filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== exports$3.sep) {
          resolved += "/";
        }
        const outURL = new URL("file://");
        if (resolved.includes("%"))
          resolved = resolved.replace(percentRegEx, "%25");
        if (!isWindows && resolved.includes("\\")) {
          resolved = resolved.replace(backslashRegEx, "%5C");
        }
        if (resolved.includes("\n"))
          resolved = resolved.replace(newlineRegEx, "%0A");
        if (resolved.includes("\r")) {
          resolved = resolved.replace(carriageReturnRegEx, "%0D");
        }
        if (resolved.includes("\t"))
          resolved = resolved.replace(tabRegEx, "%09");
        outURL.pathname = resolved;
        return outURL;
      }

      var __varRecorder__$r = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/config.js", __contextModule__);
      __varRecorder__$r.dashboardStoreServer = "http://localhost:9999/services/galyleo/";
      var dashboardStoreServer = __varRecorder__$r.dashboardStoreServer;
      __varRecorder__$r.dashboardStoreServer = dashboardStoreServer;
      __varRecorder__$r.studioServer = "https://matt.engageLively.com/users/rick/published";
      var studioServer = __varRecorder__$r.studioServer;
      __varRecorder__$r.studioServer = studioServer;
      __varRecorder__$r.galyleoVersion = "2.0";
      var galyleoVersion = __varRecorder__$r.galyleoVersion;
      __varRecorder__$r.galyleoVersion = galyleoVersion;
      __varRecorder__$r.tableServer = "http://localhost:9999/services/galyleo/";
      var tableServer = __varRecorder__$r.tableServer;
      __varRecorder__$r.tableServer = tableServer;

      var __varRecorder__$q = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/top-bar.cp.js", __contextModule__);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/top-bar.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GalyleoTopBarModel") && typeof __lively_classholder__.GalyleoTopBarModel === "function" ? __lively_classholder__.GalyleoTopBarModel : __lively_classholder__.GalyleoTopBarModel = function GalyleoTopBarModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "viewDidLoad",
          value: function GalyleoTopBarModel_viewDidLoad_() {}
        }, {
          key: "onMouseDown",
          value: function GalyleoTopBarModel_onMouseDown_(evt) {
            var shapeSelector = this.ui.shapeModeButton.get("dropdown");
            var handHaloSelector = this.ui.handOrHaloModeButton.get("dropdown");
            var handOrHaloModeButton = this.ui.handOrHaloModeButton;
            var shapeModeButton = this.ui.shapeModeButton;
            this.primaryTarget || this.world();

            if (evt.targetMorph === shapeSelector) {
              var menu = $world.openWorldMenu(evt, this.getShapeMenuItems());
              menu.position = shapeModeButton.globalBounds().bottomLeft().subPt($world.scroll);
            }

            if (evt.targetMorph === handHaloSelector) {
              var _menu = $world.openWorldMenu(evt, this.getHandAndHaloModeItems());

              _menu.position = handOrHaloModeButton.globalBounds().bottomLeft().subPt($world.scroll);
            }

            if (evt.targetMorph === shapeModeButton) {
              this.setEditMode("Shape");
            }

            if (evt.targetMorph === handOrHaloModeButton) {
              var currentlyShowingHaloIcon = this.ui.handOrHaloModeButton.getIcon()[0] === Icon.textAttribute("arrow-pointer")[0];
              this.setEditMode(currentlyShowingHaloIcon ? "Halo" : "Hand");
            }

            if (evt.targetMorph.name === "text mode button") {
              this.setEditMode("Text");
            }

            if (evt.targetMorph.name === "open component browser") {
              this.interactivelyLoadComponent();
            }

            if (evt.targetMorph.name === "load world button") {
              $world.execCommand("load world");
            }
          }
        }, {
          key: "reportBug",
          value: function GalyleoTopBarModel_reportBug_() {
            signal(this.view, "initiate bug report");
          }
        }, {
          key: "publishDashboard",
          value: function GalyleoTopBarModel_publishDashboard_() {
            signal(this.view, "initiate publication");
          }
        }, {
          key: "updateMiniMapIfNeeded",
          value: function GalyleoTopBarModel_updateMiniMapIfNeeded_() {}
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GalyleoTopBarModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              activeHaloItems: {
                get: function get() {
                  return ["drag", "rotate", "menu", "close"];
                }
              },
              haloFilterFn: {
                get: function get() {
                  var _this = this;

                  return function (m) {
                    return m.owner === _this.primaryTarget || m === _this.primaryTarget;
                  };
                }
              },
              shapeToIcon: {
                get: function get() {
                  return {
                    Rectangle: {
                      shortcut: "R",
                      args: ["square", {
                        textStyleClasses: ["fas"]
                      }]
                    },
                    Ellipse: {
                      shortcut: "E",
                      args: ["circle", {
                        textStyleClasses: ["fas"]
                      }]
                    },
                    Image: {
                      shortcut: "I",
                      args: ["image", {
                        textStyleClasses: ["fas"],
                        paddingTop: "1px"
                      }]
                    }
                  };
                }
              },
              bindings: {
                get: function get() {
                  return initializeClass._get(Object.getPrototypeOf(__lively_class__), "prototype", this).bindings.concat([{
                    target: "help button",
                    signal: "onMouseDown",
                    handler: "reportBug"
                  }, {
                    target: "upload button",
                    signal: "onMouseDown",
                    handler: "publishDashboard"
                  }]);
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/top-bar.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 1339,
          end: 6760
        });
      })({
        referencedAs: "TopBarModel",
        value: TopBarModel
      });

      __varRecorder__$q.GalyleoTopBar = component["for"](function () {
        return component(TopBar, {
          name: "galyleo/top bar",
          fill: Color$1.rgb(208, 211, 212),
          defaultViewModel: __varRecorder__$q.GalyleoTopBarModel,
          submorphs: [{
            name: "tiling layout",
            layout: new TilingLayout({
              padding: rect(13, 13, 0, 0),
              spacing: 13
            }),
            submorphs: [add({
              type: Label,
              name: "help button",
              lineHeight: 1,
              fontColor: Color$1.rgb(102, 102, 102),
              fontSize: 23.064,
              nativeCursor: "pointer",
              scale: 1.1388694516782336,
              textAndAttributes: [].concat(_toConsumableArray(Icon.textAttribute("life-ring")), ["  Help", {
                fontFamily: galyleoFont,
                fontSize: 15,
                fontWeight: "bold",
                paddingTop: "2px"
              }]),
              tooltip: "Report a bug"
            }), add({
              type: Label,
              name: "upload button",
              lineHeight: 1,
              fontColor: Color$1.rgb(102, 102, 102),
              fontSize: 23.064,
              nativeCursor: "pointer",
              scale: 1.1388694516782336,
              textAndAttributes: [].concat(_toConsumableArray(Icon.textAttribute("cloud-upload")), ["  Publish", {
                fontFamily: galyleoFont,
                fontSize: 15,
                fontWeight: "bold",
                paddingTop: "2px"
              }]),
              tooltip: "Publish this dashboard"
            }), add({
              type: Text,
              name: "version",
              fontWeight: "400",
              fontFamily: galyleoFont,
              lineHeight: 1,
              borderColor: Color$1.rgb(23, 160, 251),
              borderWidth: 0,
              dynamicCursorColoring: true,
              extent: pt(67, 40),
              fill: Color$1.rgba(255, 255, 255, 0),
              fixedWidth: true,
              lineWrapping: "by-words",
              padding: rect(1, 1, 0, 0),
              textAndAttributes: ["\n", null, "Version ".concat(galyleoVersion), {}]
            }), without("save button"), without("open component browser"), without("load world button"), without("open asset browser"), without("canvas mode button"), without("right UI wrapper"), add({
              type: Image,
              name: "galyleo logo",
              borderColor: Color$1.rgb(23, 160, 251),
              extent: pt(245.4, 116.6),
              imageUrl: projectAsset("engageLively--galyleo-dashboard__galyleo-logo.webp"),
              naturalExtent: pt(700, 320),
              position: pt(181, 13),
              reactsToPointer: false,
              scale: 0.2505891168205277,
              tooltip: "hand or halo mode button"
            })]
          }, without("right UI wrapper")]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/top-bar.cp.js",
        "export": "GalyleoTopBar",
        range: {
          start: 6768,
          end: 9351
        }
      }, System, __varRecorder__$q, "GalyleoTopBar");
      var GalyleoTopBar = __varRecorder__$q.GalyleoTopBar;
      __varRecorder__$q.GalyleoTopBar = GalyleoTopBar;

      var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      var exports$1 = {};
      (function (global, factory) {
        factory(exports$1);
      }(exports$1, function (exports) {
        var DELETE = "delete";
        var SHIFT = 5;
        var SIZE = 1 << SHIFT;
        var MASK = SIZE - 1;
        var NOT_SET = {};
        function MakeRef() {
          return { value: false };
        }
        function SetRef(ref) {
          if (ref) {
            ref.value = true;
          }
        }
        function OwnerID() {
        }
        function ensureSize(iter) {
          if (iter.size === undefined) {
            iter.size = iter.__iterate(returnTrue);
          }
          return iter.size;
        }
        function wrapIndex(iter, index) {
          if (typeof index !== "number") {
            var uint32Index = index >>> 0;
            if ("" + uint32Index !== index || uint32Index === 4294967295) {
              return NaN;
            }
            index = uint32Index;
          }
          return index < 0 ? ensureSize(iter) + index : index;
        }
        function returnTrue() {
          return true;
        }
        function wholeSlice(begin, end, size) {
          return (begin === 0 && !isNeg(begin) || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);
        }
        function resolveBegin(begin, size) {
          return resolveIndex(begin, size, 0);
        }
        function resolveEnd(end, size) {
          return resolveIndex(end, size, size);
        }
        function resolveIndex(index, size, defaultIndex) {
          return index === undefined ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === undefined || size === index ? index : Math.min(size, index) | 0;
        }
        function isNeg(value) {
          return value < 0 || value === 0 && 1 / value === -Infinity;
        }
        var IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
        function isCollection(maybeCollection) {
          return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
        }
        var IS_KEYED_SYMBOL = "@@__IMMUTABLE_KEYED__@@";
        function isKeyed(maybeKeyed) {
          return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
        }
        var IS_INDEXED_SYMBOL = "@@__IMMUTABLE_INDEXED__@@";
        function isIndexed(maybeIndexed) {
          return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
        }
        function isAssociative(maybeAssociative) {
          return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
        }
        var Collection = function Collection(value) {
          return isCollection(value) ? value : Seq(value);
        };
        var KeyedCollection = function (Collection) {
          function KeyedCollection(value) {
            return isKeyed(value) ? value : KeyedSeq(value);
          }
          if (Collection)
            KeyedCollection.__proto__ = Collection;
          KeyedCollection.prototype = Object.create(Collection && Collection.prototype);
          KeyedCollection.prototype.constructor = KeyedCollection;
          return KeyedCollection;
        }(Collection);
        var IndexedCollection = function (Collection) {
          function IndexedCollection(value) {
            return isIndexed(value) ? value : IndexedSeq(value);
          }
          if (Collection)
            IndexedCollection.__proto__ = Collection;
          IndexedCollection.prototype = Object.create(Collection && Collection.prototype);
          IndexedCollection.prototype.constructor = IndexedCollection;
          return IndexedCollection;
        }(Collection);
        var SetCollection = function (Collection) {
          function SetCollection(value) {
            return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
          }
          if (Collection)
            SetCollection.__proto__ = Collection;
          SetCollection.prototype = Object.create(Collection && Collection.prototype);
          SetCollection.prototype.constructor = SetCollection;
          return SetCollection;
        }(Collection);
        Collection.Keyed = KeyedCollection;
        Collection.Indexed = IndexedCollection;
        Collection.Set = SetCollection;
        var IS_SEQ_SYMBOL = "@@__IMMUTABLE_SEQ__@@";
        function isSeq(maybeSeq) {
          return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
        }
        var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
        function isRecord(maybeRecord) {
          return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
        }
        function isImmutable(maybeImmutable) {
          return isCollection(maybeImmutable) || isRecord(maybeImmutable);
        }
        var IS_ORDERED_SYMBOL = "@@__IMMUTABLE_ORDERED__@@";
        function isOrdered(maybeOrdered) {
          return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
        }
        var ITERATE_KEYS = 0;
        var ITERATE_VALUES = 1;
        var ITERATE_ENTRIES = 2;
        var REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
        var Iterator = function Iterator(next) {
          (this || _global).next = next;
        };
        Iterator.prototype.toString = function toString() {
          return "[Iterator]";
        };
        Iterator.KEYS = ITERATE_KEYS;
        Iterator.VALUES = ITERATE_VALUES;
        Iterator.ENTRIES = ITERATE_ENTRIES;
        Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
          return this.toString();
        };
        Iterator.prototype[ITERATOR_SYMBOL] = function () {
          return this || _global;
        };
        function iteratorValue(type, k, v, iteratorResult) {
          var value = type === 0 ? k : type === 1 ? v : [
            k,
            v
          ];
          iteratorResult ? iteratorResult.value = value : iteratorResult = {
            value: value,
            done: false
          };
          return iteratorResult;
        }
        function iteratorDone() {
          return {
            value: undefined,
            done: true
          };
        }
        function hasIterator(maybeIterable) {
          return !!getIteratorFn(maybeIterable);
        }
        function isIterator(maybeIterator) {
          return maybeIterator && typeof maybeIterator.next === "function";
        }
        function getIterator(iterable) {
          var iteratorFn = getIteratorFn(iterable);
          return iteratorFn && iteratorFn.call(iterable);
        }
        function getIteratorFn(iterable) {
          var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === "function") {
            return iteratorFn;
          }
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function isArrayLike(value) {
          if (Array.isArray(value) || typeof value === "string") {
            return true;
          }
          return value && typeof value === "object" && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ? Object.keys(value).length === 1 : value.hasOwnProperty(value.length - 1));
        }
        var Seq = function (Collection$$1) {
          function Seq(value) {
            return value === null || value === undefined ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);
          }
          if (Collection$$1)
            Seq.__proto__ = Collection$$1;
          Seq.prototype = Object.create(Collection$$1 && Collection$$1.prototype);
          Seq.prototype.constructor = Seq;
          Seq.prototype.toSeq = function toSeq() {
            return this || _global;
          };
          Seq.prototype.toString = function toString() {
            return this.__toString("Seq {", "}");
          };
          Seq.prototype.cacheResult = function cacheResult() {
            if (!(this || _global)._cache && (this || _global).__iterateUncached) {
              (this || _global)._cache = this.entrySeq().toArray();
              (this || _global).size = (this || _global)._cache.length;
            }
            return this || _global;
          };
          Seq.prototype.__iterate = function __iterate(fn, reverse) {
            var cache = (this || _global)._cache;
            if (cache) {
              var size = cache.length;
              var i = 0;
              while (i !== size) {
                var entry = cache[reverse ? size - ++i : i++];
                if (fn(entry[1], entry[0], this || _global) === false) {
                  break;
                }
              }
              return i;
            }
            return this.__iterateUncached(fn, reverse);
          };
          Seq.prototype.__iterator = function __iterator(type, reverse) {
            var cache = (this || _global)._cache;
            if (cache) {
              var size = cache.length;
              var i = 0;
              return new Iterator(function () {
                if (i === size) {
                  return iteratorDone();
                }
                var entry = cache[reverse ? size - ++i : i++];
                return iteratorValue(type, entry[0], entry[1]);
              });
            }
            return this.__iteratorUncached(type, reverse);
          };
          return Seq;
        }(Collection);
        var KeyedSeq = function (Seq) {
          function KeyedSeq(value) {
            return value === null || value === undefined ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
          }
          if (Seq)
            KeyedSeq.__proto__ = Seq;
          KeyedSeq.prototype = Object.create(Seq && Seq.prototype);
          KeyedSeq.prototype.constructor = KeyedSeq;
          KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq() {
            return this || _global;
          };
          return KeyedSeq;
        }(Seq);
        var IndexedSeq = function (Seq) {
          function IndexedSeq(value) {
            return value === null || value === undefined ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
          }
          if (Seq)
            IndexedSeq.__proto__ = Seq;
          IndexedSeq.prototype = Object.create(Seq && Seq.prototype);
          IndexedSeq.prototype.constructor = IndexedSeq;
          IndexedSeq.of = function of() {
            return IndexedSeq(arguments);
          };
          IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq() {
            return this || _global;
          };
          IndexedSeq.prototype.toString = function toString() {
            return this.__toString("Seq [", "]");
          };
          return IndexedSeq;
        }(Seq);
        var SetSeq = function (Seq) {
          function SetSeq(value) {
            return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
          }
          if (Seq)
            SetSeq.__proto__ = Seq;
          SetSeq.prototype = Object.create(Seq && Seq.prototype);
          SetSeq.prototype.constructor = SetSeq;
          SetSeq.of = function of() {
            return SetSeq(arguments);
          };
          SetSeq.prototype.toSetSeq = function toSetSeq() {
            return this || _global;
          };
          return SetSeq;
        }(Seq);
        Seq.isSeq = isSeq;
        Seq.Keyed = KeyedSeq;
        Seq.Set = SetSeq;
        Seq.Indexed = IndexedSeq;
        Seq.prototype[IS_SEQ_SYMBOL] = true;
        var ArraySeq = function (IndexedSeq) {
          function ArraySeq(array) {
            (this || _global)._array = array;
            (this || _global).size = array.length;
          }
          if (IndexedSeq)
            ArraySeq.__proto__ = IndexedSeq;
          ArraySeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
          ArraySeq.prototype.constructor = ArraySeq;
          ArraySeq.prototype.get = function get(index, notSetValue) {
            return this.has(index) ? (this || _global)._array[wrapIndex(this || _global, index)] : notSetValue;
          };
          ArraySeq.prototype.__iterate = function __iterate(fn, reverse) {
            var array = (this || _global)._array;
            var size = array.length;
            var i = 0;
            while (i !== size) {
              var ii = reverse ? size - ++i : i++;
              if (fn(array[ii], ii, this || _global) === false) {
                break;
              }
            }
            return i;
          };
          ArraySeq.prototype.__iterator = function __iterator(type, reverse) {
            var array = (this || _global)._array;
            var size = array.length;
            var i = 0;
            return new Iterator(function () {
              if (i === size) {
                return iteratorDone();
              }
              var ii = reverse ? size - ++i : i++;
              return iteratorValue(type, ii, array[ii]);
            });
          };
          return ArraySeq;
        }(IndexedSeq);
        var ObjectSeq = function (KeyedSeq) {
          function ObjectSeq(object) {
            var keys = Object.keys(object);
            (this || _global)._object = object;
            (this || _global)._keys = keys;
            (this || _global).size = keys.length;
          }
          if (KeyedSeq)
            ObjectSeq.__proto__ = KeyedSeq;
          ObjectSeq.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
          ObjectSeq.prototype.constructor = ObjectSeq;
          ObjectSeq.prototype.get = function get(key, notSetValue) {
            if (notSetValue !== undefined && !this.has(key)) {
              return notSetValue;
            }
            return (this || _global)._object[key];
          };
          ObjectSeq.prototype.has = function has(key) {
            return hasOwnProperty.call((this || _global)._object, key);
          };
          ObjectSeq.prototype.__iterate = function __iterate(fn, reverse) {
            var object = (this || _global)._object;
            var keys = (this || _global)._keys;
            var size = keys.length;
            var i = 0;
            while (i !== size) {
              var key = keys[reverse ? size - ++i : i++];
              if (fn(object[key], key, this || _global) === false) {
                break;
              }
            }
            return i;
          };
          ObjectSeq.prototype.__iterator = function __iterator(type, reverse) {
            var object = (this || _global)._object;
            var keys = (this || _global)._keys;
            var size = keys.length;
            var i = 0;
            return new Iterator(function () {
              if (i === size) {
                return iteratorDone();
              }
              var key = keys[reverse ? size - ++i : i++];
              return iteratorValue(type, key, object[key]);
            });
          };
          return ObjectSeq;
        }(KeyedSeq);
        ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
        var CollectionSeq = function (IndexedSeq) {
          function CollectionSeq(collection) {
            (this || _global)._collection = collection;
            (this || _global).size = collection.length || collection.size;
          }
          if (IndexedSeq)
            CollectionSeq.__proto__ = IndexedSeq;
          CollectionSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
          CollectionSeq.prototype.constructor = CollectionSeq;
          CollectionSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var collection = (this || _global)._collection;
            var iterator = getIterator(collection);
            var iterations = 0;
            if (isIterator(iterator)) {
              var step;
              while (!(step = iterator.next()).done) {
                if (fn(step.value, iterations++, this || _global) === false) {
                  break;
                }
              }
            }
            return iterations;
          };
          CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {
            if (reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var collection = (this || _global)._collection;
            var iterator = getIterator(collection);
            if (!isIterator(iterator)) {
              return new Iterator(iteratorDone);
            }
            var iterations = 0;
            return new Iterator(function () {
              var step = iterator.next();
              return step.done ? step : iteratorValue(type, iterations++, step.value);
            });
          };
          return CollectionSeq;
        }(IndexedSeq);
        var EMPTY_SEQ;
        function emptySequence() {
          return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
        }
        function keyedSeqFromValue(value) {
          var seq = Array.isArray(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;
          if (seq) {
            return seq.fromEntrySeq();
          }
          if (typeof value === "object") {
            return new ObjectSeq(value);
          }
          throw new TypeError("Expected Array or collection object of [k, v] entries, or keyed object: " + value);
        }
        function indexedSeqFromValue(value) {
          var seq = maybeIndexedSeqFromValue(value);
          if (seq) {
            return seq;
          }
          throw new TypeError("Expected Array or collection object of values: " + value);
        }
        function seqFromValue(value) {
          var seq = maybeIndexedSeqFromValue(value);
          if (seq) {
            return seq;
          }
          if (typeof value === "object") {
            return new ObjectSeq(value);
          }
          throw new TypeError("Expected Array or collection object of values, or keyed object: " + value);
        }
        function maybeIndexedSeqFromValue(value) {
          return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;
        }
        var IS_MAP_SYMBOL = "@@__IMMUTABLE_MAP__@@";
        function isMap(maybeMap) {
          return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
        }
        function isOrderedMap(maybeOrderedMap) {
          return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
        }
        function isValueObject(maybeValue) {
          return Boolean(maybeValue && typeof maybeValue.equals === "function" && typeof maybeValue.hashCode === "function");
        }
        function is(valueA, valueB) {
          if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
            return true;
          }
          if (!valueA || !valueB) {
            return false;
          }
          if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
            valueA = valueA.valueOf();
            valueB = valueB.valueOf();
            if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
              return true;
            }
            if (!valueA || !valueB) {
              return false;
            }
          }
          return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
        }
        var imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul(a, b) {
          a |= 0;
          b |= 0;
          var c = a & 65535;
          var d = b & 65535;
          return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0;
        };
        function smi(i32) {
          return i32 >>> 1 & 1073741824 | i32 & 3221225471;
        }
        var defaultValueOf = Object.prototype.valueOf;
        function hash(o) {
          switch (typeof o) {
          case "boolean":
            return o ? 1108378657 : 1108378656;
          case "number":
            return hashNumber(o);
          case "string":
            return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
          case "object":
          case "function":
            if (o === null) {
              return 1108378658;
            }
            if (typeof o.hashCode === "function") {
              return smi(o.hashCode(o));
            }
            if (o.valueOf !== defaultValueOf && typeof o.valueOf === "function") {
              o = o.valueOf(o);
            }
            return hashJSObj(o);
          case "undefined":
            return 1108378659;
          default:
            if (typeof o.toString === "function") {
              return hashString(o.toString());
            }
            throw new Error("Value type " + typeof o + " cannot be hashed.");
          }
        }
        function hashNumber(n) {
          if (n !== n || n === Infinity) {
            return 0;
          }
          var hash = n | 0;
          if (hash !== n) {
            hash ^= n * 4294967295;
          }
          while (n > 4294967295) {
            n /= 4294967295;
            hash ^= n;
          }
          return smi(hash);
        }
        function cachedHashString(string) {
          var hashed = stringHashCache[string];
          if (hashed === undefined) {
            hashed = hashString(string);
            if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
              STRING_HASH_CACHE_SIZE = 0;
              stringHashCache = {};
            }
            STRING_HASH_CACHE_SIZE++;
            stringHashCache[string] = hashed;
          }
          return hashed;
        }
        function hashString(string) {
          var hashed = 0;
          for (var ii = 0; ii < string.length; ii++) {
            hashed = 31 * hashed + string.charCodeAt(ii) | 0;
          }
          return smi(hashed);
        }
        function hashJSObj(obj) {
          var hashed;
          if (usingWeakMap) {
            hashed = weakMap.get(obj);
            if (hashed !== undefined) {
              return hashed;
            }
          }
          hashed = obj[UID_HASH_KEY];
          if (hashed !== undefined) {
            return hashed;
          }
          if (!canDefineProperty) {
            hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
            if (hashed !== undefined) {
              return hashed;
            }
            hashed = getIENodeHash(obj);
            if (hashed !== undefined) {
              return hashed;
            }
          }
          hashed = ++objHashUID;
          if (objHashUID & 1073741824) {
            objHashUID = 0;
          }
          if (usingWeakMap) {
            weakMap.set(obj, hashed);
          } else if (isExtensible !== undefined && isExtensible(obj) === false) {
            throw new Error("Non-extensible objects are not allowed as keys.");
          } else if (canDefineProperty) {
            Object.defineProperty(obj, UID_HASH_KEY, {
              enumerable: false,
              configurable: false,
              writable: false,
              value: hashed
            });
          } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
            obj.propertyIsEnumerable = function () {
              return (this || _global).constructor.prototype.propertyIsEnumerable.apply(this || _global, arguments);
            };
            obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
          } else if (obj.nodeType !== undefined) {
            obj[UID_HASH_KEY] = hashed;
          } else {
            throw new Error("Unable to set a non-enumerable property on object.");
          }
          return hashed;
        }
        var isExtensible = Object.isExtensible;
        var canDefineProperty = (function () {
          try {
            Object.defineProperty({}, "@", {});
            return true;
          } catch (e) {
            return false;
          }
        }());
        function getIENodeHash(node) {
          if (node && node.nodeType > 0) {
            switch (node.nodeType) {
            case 1:
              return node.uniqueID;
            case 9:
              return node.documentElement && node.documentElement.uniqueID;
            }
          }
        }
        var usingWeakMap = typeof WeakMap === "function";
        var weakMap;
        if (usingWeakMap) {
          weakMap = new WeakMap();
        }
        var objHashUID = 0;
        var UID_HASH_KEY = "__immutablehash__";
        if (typeof Symbol === "function") {
          UID_HASH_KEY = Symbol(UID_HASH_KEY);
        }
        var STRING_HASH_CACHE_MIN_STRLEN = 16;
        var STRING_HASH_CACHE_MAX_SIZE = 255;
        var STRING_HASH_CACHE_SIZE = 0;
        var stringHashCache = {};
        var ToKeyedSequence = function (KeyedSeq$$1) {
          function ToKeyedSequence(indexed, useKeys) {
            (this || _global)._iter = indexed;
            (this || _global)._useKeys = useKeys;
            (this || _global).size = indexed.size;
          }
          if (KeyedSeq$$1)
            ToKeyedSequence.__proto__ = KeyedSeq$$1;
          ToKeyedSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);
          ToKeyedSequence.prototype.constructor = ToKeyedSequence;
          ToKeyedSequence.prototype.get = function get(key, notSetValue) {
            return (this || _global)._iter.get(key, notSetValue);
          };
          ToKeyedSequence.prototype.has = function has(key) {
            return (this || _global)._iter.has(key);
          };
          ToKeyedSequence.prototype.valueSeq = function valueSeq() {
            return (this || _global)._iter.valueSeq();
          };
          ToKeyedSequence.prototype.reverse = function reverse() {
            var this$1$1 = this || _global;
            var reversedSequence = reverseFactory(this || _global, true);
            if (!(this || _global)._useKeys) {
              reversedSequence.valueSeq = function () {
                return this$1$1._iter.toSeq().reverse();
              };
            }
            return reversedSequence;
          };
          ToKeyedSequence.prototype.map = function map(mapper, context) {
            var this$1$1 = this || _global;
            var mappedSequence = mapFactory(this || _global, mapper, context);
            if (!(this || _global)._useKeys) {
              mappedSequence.valueSeq = function () {
                return this$1$1._iter.toSeq().map(mapper, context);
              };
            }
            return mappedSequence;
          };
          ToKeyedSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this || _global;
            return (this || _global)._iter.__iterate(function (v, k) {
              return fn(v, k, this$1$1);
            }, reverse);
          };
          ToKeyedSequence.prototype.__iterator = function __iterator(type, reverse) {
            return (this || _global)._iter.__iterator(type, reverse);
          };
          return ToKeyedSequence;
        }(KeyedSeq);
        ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
        var ToIndexedSequence = function (IndexedSeq$$1) {
          function ToIndexedSequence(iter) {
            (this || _global)._iter = iter;
            (this || _global).size = iter.size;
          }
          if (IndexedSeq$$1)
            ToIndexedSequence.__proto__ = IndexedSeq$$1;
          ToIndexedSequence.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
          ToIndexedSequence.prototype.constructor = ToIndexedSequence;
          ToIndexedSequence.prototype.includes = function includes(value) {
            return (this || _global)._iter.includes(value);
          };
          ToIndexedSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this || _global;
            var i = 0;
            reverse && ensureSize(this || _global);
            return (this || _global)._iter.__iterate(function (v) {
              return fn(v, reverse ? this$1$1.size - ++i : i++, this$1$1);
            }, reverse);
          };
          ToIndexedSequence.prototype.__iterator = function __iterator(type, reverse) {
            var this$1$1 = this || _global;
            var iterator = (this || _global)._iter.__iterator(ITERATE_VALUES, reverse);
            var i = 0;
            reverse && ensureSize(this || _global);
            return new Iterator(function () {
              var step = iterator.next();
              return step.done ? step : iteratorValue(type, reverse ? this$1$1.size - ++i : i++, step.value, step);
            });
          };
          return ToIndexedSequence;
        }(IndexedSeq);
        var ToSetSequence = function (SetSeq$$1) {
          function ToSetSequence(iter) {
            (this || _global)._iter = iter;
            (this || _global).size = iter.size;
          }
          if (SetSeq$$1)
            ToSetSequence.__proto__ = SetSeq$$1;
          ToSetSequence.prototype = Object.create(SetSeq$$1 && SetSeq$$1.prototype);
          ToSetSequence.prototype.constructor = ToSetSequence;
          ToSetSequence.prototype.has = function has(key) {
            return (this || _global)._iter.includes(key);
          };
          ToSetSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this || _global;
            return (this || _global)._iter.__iterate(function (v) {
              return fn(v, v, this$1$1);
            }, reverse);
          };
          ToSetSequence.prototype.__iterator = function __iterator(type, reverse) {
            var iterator = (this || _global)._iter.__iterator(ITERATE_VALUES, reverse);
            return new Iterator(function () {
              var step = iterator.next();
              return step.done ? step : iteratorValue(type, step.value, step.value, step);
            });
          };
          return ToSetSequence;
        }(SetSeq);
        var FromEntriesSequence = function (KeyedSeq$$1) {
          function FromEntriesSequence(entries) {
            (this || _global)._iter = entries;
            (this || _global).size = entries.size;
          }
          if (KeyedSeq$$1)
            FromEntriesSequence.__proto__ = KeyedSeq$$1;
          FromEntriesSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);
          FromEntriesSequence.prototype.constructor = FromEntriesSequence;
          FromEntriesSequence.prototype.entrySeq = function entrySeq() {
            return (this || _global)._iter.toSeq();
          };
          FromEntriesSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this || _global;
            return (this || _global)._iter.__iterate(function (entry) {
              if (entry) {
                validateEntry(entry);
                var indexedCollection = isCollection(entry);
                return fn(indexedCollection ? entry.get(1) : entry[1], indexedCollection ? entry.get(0) : entry[0], this$1$1);
              }
            }, reverse);
          };
          FromEntriesSequence.prototype.__iterator = function __iterator(type, reverse) {
            var iterator = (this || _global)._iter.__iterator(ITERATE_VALUES, reverse);
            return new Iterator(function () {
              while (true) {
                var step = iterator.next();
                if (step.done) {
                  return step;
                }
                var entry = step.value;
                if (entry) {
                  validateEntry(entry);
                  var indexedCollection = isCollection(entry);
                  return iteratorValue(type, indexedCollection ? entry.get(0) : entry[0], indexedCollection ? entry.get(1) : entry[1], step);
                }
              }
            });
          };
          return FromEntriesSequence;
        }(KeyedSeq);
        ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
        function flipFactory(collection) {
          var flipSequence = makeSequence(collection);
          flipSequence._iter = collection;
          flipSequence.size = collection.size;
          flipSequence.flip = function () {
            return collection;
          };
          flipSequence.reverse = function () {
            var reversedSequence = collection.reverse.apply(this || _global);
            reversedSequence.flip = function () {
              return collection.reverse();
            };
            return reversedSequence;
          };
          flipSequence.has = function (key) {
            return collection.includes(key);
          };
          flipSequence.includes = function (key) {
            return collection.has(key);
          };
          flipSequence.cacheResult = cacheResultThrough;
          flipSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this || _global;
            return collection.__iterate(function (v, k) {
              return fn(k, v, this$1$1) !== false;
            }, reverse);
          };
          flipSequence.__iteratorUncached = function (type, reverse) {
            if (type === ITERATE_ENTRIES) {
              var iterator = collection.__iterator(type, reverse);
              return new Iterator(function () {
                var step = iterator.next();
                if (!step.done) {
                  var k = step.value[0];
                  step.value[0] = step.value[1];
                  step.value[1] = k;
                }
                return step;
              });
            }
            return collection.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
          };
          return flipSequence;
        }
        function mapFactory(collection, mapper, context) {
          var mappedSequence = makeSequence(collection);
          mappedSequence.size = collection.size;
          mappedSequence.has = function (key) {
            return collection.has(key);
          };
          mappedSequence.get = function (key, notSetValue) {
            var v = collection.get(key, NOT_SET);
            return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);
          };
          mappedSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this || _global;
            return collection.__iterate(function (v, k, c) {
              return fn(mapper.call(context, v, k, c), k, this$1$1) !== false;
            }, reverse);
          };
          mappedSequence.__iteratorUncached = function (type, reverse) {
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            return new Iterator(function () {
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              var entry = step.value;
              var key = entry[0];
              return iteratorValue(type, key, mapper.call(context, entry[1], key, collection), step);
            });
          };
          return mappedSequence;
        }
        function reverseFactory(collection, useKeys) {
          var this$1$1 = this || _global;
          var reversedSequence = makeSequence(collection);
          reversedSequence._iter = collection;
          reversedSequence.size = collection.size;
          reversedSequence.reverse = function () {
            return collection;
          };
          if (collection.flip) {
            reversedSequence.flip = function () {
              var flipSequence = flipFactory(collection);
              flipSequence.reverse = function () {
                return collection.flip();
              };
              return flipSequence;
            };
          }
          reversedSequence.get = function (key, notSetValue) {
            return collection.get(useKeys ? key : -1 - key, notSetValue);
          };
          reversedSequence.has = function (key) {
            return collection.has(useKeys ? key : -1 - key);
          };
          reversedSequence.includes = function (value) {
            return collection.includes(value);
          };
          reversedSequence.cacheResult = cacheResultThrough;
          reversedSequence.__iterate = function (fn, reverse) {
            var this$1$1 = this || _global;
            var i = 0;
            reverse && ensureSize(collection);
            return collection.__iterate(function (v, k) {
              return fn(v, useKeys ? k : reverse ? this$1$1.size - ++i : i++, this$1$1);
            }, !reverse);
          };
          reversedSequence.__iterator = function (type, reverse) {
            var i = 0;
            reverse && ensureSize(collection);
            var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);
            return new Iterator(function () {
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              var entry = step.value;
              return iteratorValue(type, useKeys ? entry[0] : reverse ? this$1$1.size - ++i : i++, entry[1], step);
            });
          };
          return reversedSequence;
        }
        function filterFactory(collection, predicate, context, useKeys) {
          var filterSequence = makeSequence(collection);
          if (useKeys) {
            filterSequence.has = function (key) {
              var v = collection.get(key, NOT_SET);
              return v !== NOT_SET && !!predicate.call(context, v, key, collection);
            };
            filterSequence.get = function (key, notSetValue) {
              var v = collection.get(key, NOT_SET);
              return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;
            };
          }
          filterSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this || _global;
            var iterations = 0;
            collection.__iterate(function (v, k, c) {
              if (predicate.call(context, v, k, c)) {
                iterations++;
                return fn(v, useKeys ? k : iterations - 1, this$1$1);
              }
            }, reverse);
            return iterations;
          };
          filterSequence.__iteratorUncached = function (type, reverse) {
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            var iterations = 0;
            return new Iterator(function () {
              while (true) {
                var step = iterator.next();
                if (step.done) {
                  return step;
                }
                var entry = step.value;
                var key = entry[0];
                var value = entry[1];
                if (predicate.call(context, value, key, collection)) {
                  return iteratorValue(type, useKeys ? key : iterations++, value, step);
                }
              }
            });
          };
          return filterSequence;
        }
        function countByFactory(collection, grouper, context) {
          var groups = Map().asMutable();
          collection.__iterate(function (v, k) {
            groups.update(grouper.call(context, v, k, collection), 0, function (a) {
              return a + 1;
            });
          });
          return groups.asImmutable();
        }
        function groupByFactory(collection, grouper, context) {
          var isKeyedIter = isKeyed(collection);
          var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();
          collection.__iterate(function (v, k) {
            groups.update(grouper.call(context, v, k, collection), function (a) {
              return a = a || [], a.push(isKeyedIter ? [
                k,
                v
              ] : v), a;
            });
          });
          var coerce = collectionClass(collection);
          return groups.map(function (arr) {
            return reify(collection, coerce(arr));
          }).asImmutable();
        }
        function sliceFactory(collection, begin, end, useKeys) {
          var originalSize = collection.size;
          if (wholeSlice(begin, end, originalSize)) {
            return collection;
          }
          var resolvedBegin = resolveBegin(begin, originalSize);
          var resolvedEnd = resolveEnd(end, originalSize);
          if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
            return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
          }
          var resolvedSize = resolvedEnd - resolvedBegin;
          var sliceSize;
          if (resolvedSize === resolvedSize) {
            sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
          }
          var sliceSeq = makeSequence(collection);
          sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || undefined;
          if (!useKeys && isSeq(collection) && sliceSize >= 0) {
            sliceSeq.get = function (index, notSetValue) {
              index = wrapIndex(this || _global, index);
              return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
            };
          }
          sliceSeq.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this || _global;
            if (sliceSize === 0) {
              return 0;
            }
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var skipped = 0;
            var isSkipping = true;
            var iterations = 0;
            collection.__iterate(function (v, k) {
              if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
                iterations++;
                return fn(v, useKeys ? k : iterations - 1, this$1$1) !== false && iterations !== sliceSize;
              }
            });
            return iterations;
          };
          sliceSeq.__iteratorUncached = function (type, reverse) {
            if (sliceSize !== 0 && reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            if (sliceSize === 0) {
              return new Iterator(iteratorDone);
            }
            var iterator = collection.__iterator(type, reverse);
            var skipped = 0;
            var iterations = 0;
            return new Iterator(function () {
              while (skipped++ < resolvedBegin) {
                iterator.next();
              }
              if (++iterations > sliceSize) {
                return iteratorDone();
              }
              var step = iterator.next();
              if (useKeys || type === ITERATE_VALUES || step.done) {
                return step;
              }
              if (type === ITERATE_KEYS) {
                return iteratorValue(type, iterations - 1, undefined, step);
              }
              return iteratorValue(type, iterations - 1, step.value[1], step);
            });
          };
          return sliceSeq;
        }
        function takeWhileFactory(collection, predicate, context) {
          var takeSequence = makeSequence(collection);
          takeSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this || _global;
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var iterations = 0;
            collection.__iterate(function (v, k, c) {
              return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1$1);
            });
            return iterations;
          };
          takeSequence.__iteratorUncached = function (type, reverse) {
            var this$1$1 = this || _global;
            if (reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            var iterating = true;
            return new Iterator(function () {
              if (!iterating) {
                return iteratorDone();
              }
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              var entry = step.value;
              var k = entry[0];
              var v = entry[1];
              if (!predicate.call(context, v, k, this$1$1)) {
                iterating = false;
                return iteratorDone();
              }
              return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
            });
          };
          return takeSequence;
        }
        function skipWhileFactory(collection, predicate, context, useKeys) {
          var skipSequence = makeSequence(collection);
          skipSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this || _global;
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var isSkipping = true;
            var iterations = 0;
            collection.__iterate(function (v, k, c) {
              if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
                iterations++;
                return fn(v, useKeys ? k : iterations - 1, this$1$1);
              }
            });
            return iterations;
          };
          skipSequence.__iteratorUncached = function (type, reverse) {
            var this$1$1 = this || _global;
            if (reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            var skipping = true;
            var iterations = 0;
            return new Iterator(function () {
              var step;
              var k;
              var v;
              do {
                step = iterator.next();
                if (step.done) {
                  if (useKeys || type === ITERATE_VALUES) {
                    return step;
                  }
                  if (type === ITERATE_KEYS) {
                    return iteratorValue(type, iterations++, undefined, step);
                  }
                  return iteratorValue(type, iterations++, step.value[1], step);
                }
                var entry = step.value;
                k = entry[0];
                v = entry[1];
                skipping && (skipping = predicate.call(context, v, k, this$1$1));
              } while (skipping);
              return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
            });
          };
          return skipSequence;
        }
        function concatFactory(collection, values) {
          var isKeyedCollection = isKeyed(collection);
          var iters = [collection].concat(values).map(function (v) {
            if (!isCollection(v)) {
              v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
            } else if (isKeyedCollection) {
              v = KeyedCollection(v);
            }
            return v;
          }).filter(function (v) {
            return v.size !== 0;
          });
          if (iters.length === 0) {
            return collection;
          }
          if (iters.length === 1) {
            var singleton = iters[0];
            if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
              return singleton;
            }
          }
          var concatSeq = new ArraySeq(iters);
          if (isKeyedCollection) {
            concatSeq = concatSeq.toKeyedSeq();
          } else if (!isIndexed(collection)) {
            concatSeq = concatSeq.toSetSeq();
          }
          concatSeq = concatSeq.flatten(true);
          concatSeq.size = iters.reduce(function (sum, seq) {
            if (sum !== undefined) {
              var size = seq.size;
              if (size !== undefined) {
                return sum + size;
              }
            }
          }, 0);
          return concatSeq;
        }
        function flattenFactory(collection, depth, useKeys) {
          var flatSequence = makeSequence(collection);
          flatSequence.__iterateUncached = function (fn, reverse) {
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var iterations = 0;
            var stopped = false;
            function flatDeep(iter, currentDepth) {
              iter.__iterate(function (v, k) {
                if ((!depth || currentDepth < depth) && isCollection(v)) {
                  flatDeep(v, currentDepth + 1);
                } else {
                  iterations++;
                  if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
                    stopped = true;
                  }
                }
                return !stopped;
              }, reverse);
            }
            flatDeep(collection, 0);
            return iterations;
          };
          flatSequence.__iteratorUncached = function (type, reverse) {
            if (reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = collection.__iterator(type, reverse);
            var stack = [];
            var iterations = 0;
            return new Iterator(function () {
              while (iterator) {
                var step = iterator.next();
                if (step.done !== false) {
                  iterator = stack.pop();
                  continue;
                }
                var v = step.value;
                if (type === ITERATE_ENTRIES) {
                  v = v[1];
                }
                if ((!depth || stack.length < depth) && isCollection(v)) {
                  stack.push(iterator);
                  iterator = v.__iterator(type, reverse);
                } else {
                  return useKeys ? step : iteratorValue(type, iterations++, v, step);
                }
              }
              return iteratorDone();
            });
          };
          return flatSequence;
        }
        function flatMapFactory(collection, mapper, context) {
          var coerce = collectionClass(collection);
          return collection.toSeq().map(function (v, k) {
            return coerce(mapper.call(context, v, k, collection));
          }).flatten(true);
        }
        function interposeFactory(collection, separator) {
          var interposedSequence = makeSequence(collection);
          interposedSequence.size = collection.size && collection.size * 2 - 1;
          interposedSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this || _global;
            var iterations = 0;
            collection.__iterate(function (v) {
              return (!iterations || fn(separator, iterations++, this$1$1) !== false) && fn(v, iterations++, this$1$1) !== false;
            }, reverse);
            return iterations;
          };
          interposedSequence.__iteratorUncached = function (type, reverse) {
            var iterator = collection.__iterator(ITERATE_VALUES, reverse);
            var iterations = 0;
            var step;
            return new Iterator(function () {
              if (!step || iterations % 2) {
                step = iterator.next();
                if (step.done) {
                  return step;
                }
              }
              return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
            });
          };
          return interposedSequence;
        }
        function sortFactory(collection, comparator, mapper) {
          if (!comparator) {
            comparator = defaultComparator;
          }
          var isKeyedCollection = isKeyed(collection);
          var index = 0;
          var entries = collection.toSeq().map(function (v, k) {
            return [
              k,
              v,
              index++,
              mapper ? mapper(v, k, collection) : v
            ];
          }).valueSeq().toArray();
          entries.sort(function (a, b) {
            return comparator(a[3], b[3]) || a[2] - b[2];
          }).forEach(isKeyedCollection ? function (v, i) {
            entries[i].length = 2;
          } : function (v, i) {
            entries[i] = v[1];
          });
          return isKeyedCollection ? KeyedSeq(entries) : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);
        }
        function maxFactory(collection, comparator, mapper) {
          if (!comparator) {
            comparator = defaultComparator;
          }
          if (mapper) {
            var entry = collection.toSeq().map(function (v, k) {
              return [
                v,
                mapper(v, k, collection)
              ];
            }).reduce(function (a, b) {
              return maxCompare(comparator, a[1], b[1]) ? b : a;
            });
            return entry && entry[0];
          }
          return collection.reduce(function (a, b) {
            return maxCompare(comparator, a, b) ? b : a;
          });
        }
        function maxCompare(comparator, a, b) {
          var comp = comparator(b, a);
          return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;
        }
        function zipWithFactory(keyIter, zipper, iters, zipAll) {
          var zipSequence = makeSequence(keyIter);
          var sizes = new ArraySeq(iters).map(function (i) {
            return i.size;
          });
          zipSequence.size = zipAll ? sizes.max() : sizes.min();
          zipSequence.__iterate = function (fn, reverse) {
            var iterator = this.__iterator(ITERATE_VALUES, reverse);
            var step;
            var iterations = 0;
            while (!(step = iterator.next()).done) {
              if (fn(step.value, iterations++, this || _global) === false) {
                break;
              }
            }
            return iterations;
          };
          zipSequence.__iteratorUncached = function (type, reverse) {
            var iterators = iters.map(function (i) {
              return i = Collection(i), getIterator(reverse ? i.reverse() : i);
            });
            var iterations = 0;
            var isDone = false;
            return new Iterator(function () {
              var steps;
              if (!isDone) {
                steps = iterators.map(function (i) {
                  return i.next();
                });
                isDone = zipAll ? steps.every(function (s) {
                  return s.done;
                }) : steps.some(function (s) {
                  return s.done;
                });
              }
              if (isDone) {
                return iteratorDone();
              }
              return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {
                return s.value;
              })));
            });
          };
          return zipSequence;
        }
        function reify(iter, seq) {
          return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
        }
        function validateEntry(entry) {
          if (entry !== Object(entry)) {
            throw new TypeError("Expected [K, V] tuple: " + entry);
          }
        }
        function collectionClass(collection) {
          return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
        }
        function makeSequence(collection) {
          return Object.create((isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype);
        }
        function cacheResultThrough() {
          if ((this || _global)._iter.cacheResult) {
            (this || _global)._iter.cacheResult();
            (this || _global).size = (this || _global)._iter.size;
            return this || _global;
          }
          return Seq.prototype.cacheResult.call(this || _global);
        }
        function defaultComparator(a, b) {
          if (a === undefined && b === undefined) {
            return 0;
          }
          if (a === undefined) {
            return 1;
          }
          if (b === undefined) {
            return -1;
          }
          return a > b ? 1 : a < b ? -1 : 0;
        }
        function arrCopy(arr, offset) {
          offset = offset || 0;
          var len = Math.max(0, arr.length - offset);
          var newArr = new Array(len);
          for (var ii = 0; ii < len; ii++) {
            newArr[ii] = arr[ii + offset];
          }
          return newArr;
        }
        function invariant(condition, error) {
          if (!condition) {
            throw new Error(error);
          }
        }
        function assertNotInfinite(size) {
          invariant(size !== Infinity, "Cannot perform this action with an infinite size.");
        }
        function coerceKeyPath(keyPath) {
          if (isArrayLike(keyPath) && typeof keyPath !== "string") {
            return keyPath;
          }
          if (isOrdered(keyPath)) {
            return keyPath.toArray();
          }
          throw new TypeError("Invalid keyPath: expected Ordered Collection or Array: " + keyPath);
        }
        function isPlainObj(value) {
          return value && (typeof value.constructor !== "function" || value.constructor.name === "Object");
        }
        function isDataStructure(value) {
          return typeof value === "object" && (isImmutable(value) || Array.isArray(value) || isPlainObj(value));
        }
        function quoteString(value) {
          try {
            return typeof value === "string" ? JSON.stringify(value) : String(value);
          } catch (_ignoreError) {
            return JSON.stringify(value);
          }
        }
        function has(collection, key) {
          return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty.call(collection, key);
        }
        function get(collection, key, notSetValue) {
          return isImmutable(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === "function" ? collection.get(key) : collection[key];
        }
        function shallowCopy(from) {
          if (Array.isArray(from)) {
            return arrCopy(from);
          }
          var to = {};
          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }
          return to;
        }
        function remove(collection, key) {
          if (!isDataStructure(collection)) {
            throw new TypeError("Cannot update non-data-structure value: " + collection);
          }
          if (isImmutable(collection)) {
            if (!collection.remove) {
              throw new TypeError("Cannot update immutable value without .remove() method: " + collection);
            }
            return collection.remove(key);
          }
          if (!hasOwnProperty.call(collection, key)) {
            return collection;
          }
          var collectionCopy = shallowCopy(collection);
          if (Array.isArray(collectionCopy)) {
            collectionCopy.splice(key, 1);
          } else {
            delete collectionCopy[key];
          }
          return collectionCopy;
        }
        function set(collection, key, value) {
          if (!isDataStructure(collection)) {
            throw new TypeError("Cannot update non-data-structure value: " + collection);
          }
          if (isImmutable(collection)) {
            if (!collection.set) {
              throw new TypeError("Cannot update immutable value without .set() method: " + collection);
            }
            return collection.set(key, value);
          }
          if (hasOwnProperty.call(collection, key) && value === collection[key]) {
            return collection;
          }
          var collectionCopy = shallowCopy(collection);
          collectionCopy[key] = value;
          return collectionCopy;
        }
        function updateIn(collection, keyPath, notSetValue, updater) {
          if (!updater) {
            updater = notSetValue;
            notSetValue = undefined;
          }
          var updatedValue = updateInDeeply(isImmutable(collection), collection, coerceKeyPath(keyPath), 0, notSetValue, updater);
          return updatedValue === NOT_SET ? notSetValue : updatedValue;
        }
        function updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {
          var wasNotSet = existing === NOT_SET;
          if (i === keyPath.length) {
            var existingValue = wasNotSet ? notSetValue : existing;
            var newValue = updater(existingValue);
            return newValue === existingValue ? existing : newValue;
          }
          if (!wasNotSet && !isDataStructure(existing)) {
            throw new TypeError("Cannot update within non-data-structure value in path [" + keyPath.slice(0, i).map(quoteString) + "]: " + existing);
          }
          var key = keyPath[i];
          var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
          var nextUpdated = updateInDeeply(nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting), nextExisting, keyPath, i + 1, notSetValue, updater);
          return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set(wasNotSet ? inImmutable ? emptyMap() : {} : existing, key, nextUpdated);
        }
        function setIn(collection, keyPath, value) {
          return updateIn(collection, keyPath, NOT_SET, function () {
            return value;
          });
        }
        function setIn$1(keyPath, v) {
          return setIn(this || _global, keyPath, v);
        }
        function removeIn(collection, keyPath) {
          return updateIn(collection, keyPath, function () {
            return NOT_SET;
          });
        }
        function deleteIn(keyPath) {
          return removeIn(this || _global, keyPath);
        }
        function update(collection, key, notSetValue, updater) {
          return updateIn(collection, [key], notSetValue, updater);
        }
        function update$1(key, notSetValue, updater) {
          return arguments.length === 1 ? key(this || _global) : update(this || _global, key, notSetValue, updater);
        }
        function updateIn$1(keyPath, notSetValue, updater) {
          return updateIn(this || _global, keyPath, notSetValue, updater);
        }
        function merge() {
          var iters = [], len = arguments.length;
          while (len--)
            iters[len] = arguments[len];
          return mergeIntoKeyedWith(this || _global, iters);
        }
        function mergeWith(merger) {
          var iters = [], len = arguments.length - 1;
          while (len-- > 0)
            iters[len] = arguments[len + 1];
          if (typeof merger !== "function") {
            throw new TypeError("Invalid merger function: " + merger);
          }
          return mergeIntoKeyedWith(this || _global, iters, merger);
        }
        function mergeIntoKeyedWith(collection, collections, merger) {
          var iters = [];
          for (var ii = 0; ii < collections.length; ii++) {
            var collection$1 = KeyedCollection(collections[ii]);
            if (collection$1.size !== 0) {
              iters.push(collection$1);
            }
          }
          if (iters.length === 0) {
            return collection;
          }
          if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {
            return collection.constructor(iters[0]);
          }
          return collection.withMutations(function (collection) {
            var mergeIntoCollection = merger ? function (value, key) {
              update(collection, key, NOT_SET, function (oldVal) {
                return oldVal === NOT_SET ? value : merger(oldVal, value, key);
              });
            } : function (value, key) {
              collection.set(key, value);
            };
            for (var ii = 0; ii < iters.length; ii++) {
              iters[ii].forEach(mergeIntoCollection);
            }
          });
        }
        function merge$1(collection) {
          var sources = [], len = arguments.length - 1;
          while (len-- > 0)
            sources[len] = arguments[len + 1];
          return mergeWithSources(collection, sources);
        }
        function mergeWith$1(merger, collection) {
          var sources = [], len = arguments.length - 2;
          while (len-- > 0)
            sources[len] = arguments[len + 2];
          return mergeWithSources(collection, sources, merger);
        }
        function mergeDeep(collection) {
          var sources = [], len = arguments.length - 1;
          while (len-- > 0)
            sources[len] = arguments[len + 1];
          return mergeDeepWithSources(collection, sources);
        }
        function mergeDeepWith(merger, collection) {
          var sources = [], len = arguments.length - 2;
          while (len-- > 0)
            sources[len] = arguments[len + 2];
          return mergeDeepWithSources(collection, sources, merger);
        }
        function mergeDeepWithSources(collection, sources, merger) {
          return mergeWithSources(collection, sources, deepMergerWith(merger));
        }
        function mergeWithSources(collection, sources, merger) {
          if (!isDataStructure(collection)) {
            throw new TypeError("Cannot merge into non-data-structure value: " + collection);
          }
          if (isImmutable(collection)) {
            return typeof merger === "function" && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
          }
          var isArray = Array.isArray(collection);
          var merged = collection;
          var Collection$$1 = isArray ? IndexedCollection : KeyedCollection;
          var mergeItem = isArray ? function (value) {
            if (merged === collection) {
              merged = shallowCopy(merged);
            }
            merged.push(value);
          } : function (value, key) {
            var hasVal = hasOwnProperty.call(merged, key);
            var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;
            if (!hasVal || nextVal !== merged[key]) {
              if (merged === collection) {
                merged = shallowCopy(merged);
              }
              merged[key] = nextVal;
            }
          };
          for (var i = 0; i < sources.length; i++) {
            Collection$$1(sources[i]).forEach(mergeItem);
          }
          return merged;
        }
        function deepMergerWith(merger) {
          function deepMerger(oldValue, newValue, key) {
            return isDataStructure(oldValue) && isDataStructure(newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;
          }
          return deepMerger;
        }
        function mergeDeep$1() {
          var iters = [], len = arguments.length;
          while (len--)
            iters[len] = arguments[len];
          return mergeDeepWithSources(this || _global, iters);
        }
        function mergeDeepWith$1(merger) {
          var iters = [], len = arguments.length - 1;
          while (len-- > 0)
            iters[len] = arguments[len + 1];
          return mergeDeepWithSources(this || _global, iters, merger);
        }
        function mergeIn(keyPath) {
          var iters = [], len = arguments.length - 1;
          while (len-- > 0)
            iters[len] = arguments[len + 1];
          return updateIn(this || _global, keyPath, emptyMap(), function (m) {
            return mergeWithSources(m, iters);
          });
        }
        function mergeDeepIn(keyPath) {
          var iters = [], len = arguments.length - 1;
          while (len-- > 0)
            iters[len] = arguments[len + 1];
          return updateIn(this || _global, keyPath, emptyMap(), function (m) {
            return mergeDeepWithSources(m, iters);
          });
        }
        function withMutations(fn) {
          var mutable = this.asMutable();
          fn(mutable);
          return mutable.wasAltered() ? mutable.__ensureOwner((this || _global).__ownerID) : this || _global;
        }
        function asMutable() {
          return (this || _global).__ownerID ? this || _global : this.__ensureOwner(new OwnerID());
        }
        function asImmutable() {
          return this.__ensureOwner();
        }
        function wasAltered() {
          return (this || _global).__altered;
        }
        var Map = function (KeyedCollection$$1) {
          function Map(value) {
            return value === null || value === undefined ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {
              var iter = KeyedCollection$$1(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v, k) {
                return map.set(k, v);
              });
            });
          }
          if (KeyedCollection$$1)
            Map.__proto__ = KeyedCollection$$1;
          Map.prototype = Object.create(KeyedCollection$$1 && KeyedCollection$$1.prototype);
          Map.prototype.constructor = Map;
          Map.of = function of() {
            var keyValues = [], len = arguments.length;
            while (len--)
              keyValues[len] = arguments[len];
            return emptyMap().withMutations(function (map) {
              for (var i = 0; i < keyValues.length; i += 2) {
                if (i + 1 >= keyValues.length) {
                  throw new Error("Missing value for key: " + keyValues[i]);
                }
                map.set(keyValues[i], keyValues[i + 1]);
              }
            });
          };
          Map.prototype.toString = function toString() {
            return this.__toString("Map {", "}");
          };
          Map.prototype.get = function get(k, notSetValue) {
            return (this || _global)._root ? (this || _global)._root.get(0, undefined, k, notSetValue) : notSetValue;
          };
          Map.prototype.set = function set(k, v) {
            return updateMap(this || _global, k, v);
          };
          Map.prototype.remove = function remove(k) {
            return updateMap(this || _global, k, NOT_SET);
          };
          Map.prototype.deleteAll = function deleteAll(keys) {
            var collection = Collection(keys);
            if (collection.size === 0) {
              return this || _global;
            }
            return this.withMutations(function (map) {
              collection.forEach(function (key) {
                return map.remove(key);
              });
            });
          };
          Map.prototype.clear = function clear() {
            if ((this || _global).size === 0) {
              return this || _global;
            }
            if ((this || _global).__ownerID) {
              (this || _global).size = 0;
              (this || _global)._root = null;
              (this || _global).__hash = undefined;
              (this || _global).__altered = true;
              return this || _global;
            }
            return emptyMap();
          };
          Map.prototype.sort = function sort(comparator) {
            return OrderedMap(sortFactory(this || _global, comparator));
          };
          Map.prototype.sortBy = function sortBy(mapper, comparator) {
            return OrderedMap(sortFactory(this || _global, comparator, mapper));
          };
          Map.prototype.map = function map(mapper, context) {
            return this.withMutations(function (map) {
              map.forEach(function (value, key) {
                map.set(key, mapper.call(context, value, key, map));
              });
            });
          };
          Map.prototype.__iterator = function __iterator(type, reverse) {
            return new MapIterator(this || _global, type, reverse);
          };
          Map.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this || _global;
            var iterations = 0;
            (this || _global)._root && (this || _global)._root.iterate(function (entry) {
              iterations++;
              return fn(entry[1], entry[0], this$1$1);
            }, reverse);
            return iterations;
          };
          Map.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === (this || _global).__ownerID) {
              return this || _global;
            }
            if (!ownerID) {
              if ((this || _global).size === 0) {
                return emptyMap();
              }
              (this || _global).__ownerID = ownerID;
              (this || _global).__altered = false;
              return this || _global;
            }
            return makeMap((this || _global).size, (this || _global)._root, ownerID, (this || _global).__hash);
          };
          return Map;
        }(KeyedCollection);
        Map.isMap = isMap;
        var MapPrototype = Map.prototype;
        MapPrototype[IS_MAP_SYMBOL] = true;
        MapPrototype[DELETE] = MapPrototype.remove;
        MapPrototype.removeAll = MapPrototype.deleteAll;
        MapPrototype.setIn = setIn$1;
        MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
        MapPrototype.update = update$1;
        MapPrototype.updateIn = updateIn$1;
        MapPrototype.merge = MapPrototype.concat = merge;
        MapPrototype.mergeWith = mergeWith;
        MapPrototype.mergeDeep = mergeDeep$1;
        MapPrototype.mergeDeepWith = mergeDeepWith$1;
        MapPrototype.mergeIn = mergeIn;
        MapPrototype.mergeDeepIn = mergeDeepIn;
        MapPrototype.withMutations = withMutations;
        MapPrototype.wasAltered = wasAltered;
        MapPrototype.asImmutable = asImmutable;
        MapPrototype["@@transducer/init"] = MapPrototype.asMutable = asMutable;
        MapPrototype["@@transducer/step"] = function (result, arr) {
          return result.set(arr[0], arr[1]);
        };
        MapPrototype["@@transducer/result"] = function (obj) {
          return obj.asImmutable();
        };
        var ArrayMapNode = function ArrayMapNode(ownerID, entries) {
          (this || _global).ownerID = ownerID;
          (this || _global).entries = entries;
        };
        ArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          var entries = (this || _global).entries;
          for (var ii = 0, len = entries.length; ii < len; ii++) {
            if (is(key, entries[ii][0])) {
              return entries[ii][1];
            }
          }
          return notSetValue;
        };
        ArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          var removed = value === NOT_SET;
          var entries = (this || _global).entries;
          var idx = 0;
          var len = entries.length;
          for (; idx < len; idx++) {
            if (is(key, entries[idx][0])) {
              break;
            }
          }
          var exists = idx < len;
          if (exists ? entries[idx][1] === value : removed) {
            return this || _global;
          }
          SetRef(didAlter);
          (removed || !exists) && SetRef(didChangeSize);
          if (removed && entries.length === 1) {
            return;
          }
          if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
            return createNodes(ownerID, entries, key, value);
          }
          var isEditable = ownerID && ownerID === (this || _global).ownerID;
          var newEntries = isEditable ? entries : arrCopy(entries);
          if (exists) {
            if (removed) {
              idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
            } else {
              newEntries[idx] = [
                key,
                value
              ];
            }
          } else {
            newEntries.push([
              key,
              value
            ]);
          }
          if (isEditable) {
            (this || _global).entries = newEntries;
            return this || _global;
          }
          return new ArrayMapNode(ownerID, newEntries);
        };
        var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
          (this || _global).ownerID = ownerID;
          (this || _global).bitmap = bitmap;
          (this || _global).nodes = nodes;
        };
        BitmapIndexedNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
          var bitmap = (this || _global).bitmap;
          return (bitmap & bit) === 0 ? notSetValue : (this || _global).nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
        };
        BitmapIndexedNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var bit = 1 << keyHashFrag;
          var bitmap = (this || _global).bitmap;
          var exists = (bitmap & bit) !== 0;
          if (!exists && value === NOT_SET) {
            return this || _global;
          }
          var idx = popCount(bitmap & bit - 1);
          var nodes = (this || _global).nodes;
          var node = exists ? nodes[idx] : undefined;
          var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
          if (newNode === node) {
            return this || _global;
          }
          if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
            return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
          }
          if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
            return nodes[idx ^ 1];
          }
          if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
            return newNode;
          }
          var isEditable = ownerID && ownerID === (this || _global).ownerID;
          var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
          var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
          if (isEditable) {
            (this || _global).bitmap = newBitmap;
            (this || _global).nodes = newNodes;
            return this || _global;
          }
          return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
        };
        var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {
          (this || _global).ownerID = ownerID;
          (this || _global).count = count;
          (this || _global).nodes = nodes;
        };
        HashArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var node = (this || _global).nodes[idx];
          return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
        };
        HashArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var removed = value === NOT_SET;
          var nodes = (this || _global).nodes;
          var node = nodes[idx];
          if (removed && !node) {
            return this || _global;
          }
          var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
          if (newNode === node) {
            return this || _global;
          }
          var newCount = (this || _global).count;
          if (!node) {
            newCount++;
          } else if (!newNode) {
            newCount--;
            if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
              return packNodes(ownerID, nodes, newCount, idx);
            }
          }
          var isEditable = ownerID && ownerID === (this || _global).ownerID;
          var newNodes = setAt(nodes, idx, newNode, isEditable);
          if (isEditable) {
            (this || _global).count = newCount;
            (this || _global).nodes = newNodes;
            return this || _global;
          }
          return new HashArrayMapNode(ownerID, newCount, newNodes);
        };
        var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {
          (this || _global).ownerID = ownerID;
          (this || _global).keyHash = keyHash;
          (this || _global).entries = entries;
        };
        HashCollisionNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          var entries = (this || _global).entries;
          for (var ii = 0, len = entries.length; ii < len; ii++) {
            if (is(key, entries[ii][0])) {
              return entries[ii][1];
            }
          }
          return notSetValue;
        };
        HashCollisionNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var removed = value === NOT_SET;
          if (keyHash !== (this || _global).keyHash) {
            if (removed) {
              return this || _global;
            }
            SetRef(didAlter);
            SetRef(didChangeSize);
            return mergeIntoNode(this || _global, ownerID, shift, keyHash, [
              key,
              value
            ]);
          }
          var entries = (this || _global).entries;
          var idx = 0;
          var len = entries.length;
          for (; idx < len; idx++) {
            if (is(key, entries[idx][0])) {
              break;
            }
          }
          var exists = idx < len;
          if (exists ? entries[idx][1] === value : removed) {
            return this || _global;
          }
          SetRef(didAlter);
          (removed || !exists) && SetRef(didChangeSize);
          if (removed && len === 2) {
            return new ValueNode(ownerID, (this || _global).keyHash, entries[idx ^ 1]);
          }
          var isEditable = ownerID && ownerID === (this || _global).ownerID;
          var newEntries = isEditable ? entries : arrCopy(entries);
          if (exists) {
            if (removed) {
              idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
            } else {
              newEntries[idx] = [
                key,
                value
              ];
            }
          } else {
            newEntries.push([
              key,
              value
            ]);
          }
          if (isEditable) {
            (this || _global).entries = newEntries;
            return this || _global;
          }
          return new HashCollisionNode(ownerID, (this || _global).keyHash, newEntries);
        };
        var ValueNode = function ValueNode(ownerID, keyHash, entry) {
          (this || _global).ownerID = ownerID;
          (this || _global).keyHash = keyHash;
          (this || _global).entry = entry;
        };
        ValueNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          return is(key, (this || _global).entry[0]) ? (this || _global).entry[1] : notSetValue;
        };
        ValueNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          var removed = value === NOT_SET;
          var keyMatch = is(key, (this || _global).entry[0]);
          if (keyMatch ? value === (this || _global).entry[1] : removed) {
            return this || _global;
          }
          SetRef(didAlter);
          if (removed) {
            SetRef(didChangeSize);
            return;
          }
          if (keyMatch) {
            if (ownerID && ownerID === (this || _global).ownerID) {
              (this || _global).entry[1] = value;
              return this || _global;
            }
            return new ValueNode(ownerID, (this || _global).keyHash, [
              key,
              value
            ]);
          }
          SetRef(didChangeSize);
          return mergeIntoNode(this || _global, ownerID, shift, hash(key), [
            key,
            value
          ]);
        };
        ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {
          var entries = (this || _global).entries;
          for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
            if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
              return false;
            }
          }
        };
        BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {
          var nodes = (this || _global).nodes;
          for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
            var node = nodes[reverse ? maxIndex - ii : ii];
            if (node && node.iterate(fn, reverse) === false) {
              return false;
            }
          }
        };
        ValueNode.prototype.iterate = function (fn, reverse) {
          return fn((this || _global).entry);
        };
        var MapIterator = function (Iterator$$1) {
          function MapIterator(map, type, reverse) {
            (this || _global)._type = type;
            (this || _global)._reverse = reverse;
            (this || _global)._stack = map._root && mapIteratorFrame(map._root);
          }
          if (Iterator$$1)
            MapIterator.__proto__ = Iterator$$1;
          MapIterator.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);
          MapIterator.prototype.constructor = MapIterator;
          MapIterator.prototype.next = function next() {
            var type = (this || _global)._type;
            var stack = (this || _global)._stack;
            while (stack) {
              var node = stack.node;
              var index = stack.index++;
              var maxIndex = void 0;
              if (node.entry) {
                if (index === 0) {
                  return mapIteratorValue(type, node.entry);
                }
              } else if (node.entries) {
                maxIndex = node.entries.length - 1;
                if (index <= maxIndex) {
                  return mapIteratorValue(type, node.entries[(this || _global)._reverse ? maxIndex - index : index]);
                }
              } else {
                maxIndex = node.nodes.length - 1;
                if (index <= maxIndex) {
                  var subNode = node.nodes[(this || _global)._reverse ? maxIndex - index : index];
                  if (subNode) {
                    if (subNode.entry) {
                      return mapIteratorValue(type, subNode.entry);
                    }
                    stack = (this || _global)._stack = mapIteratorFrame(subNode, stack);
                  }
                  continue;
                }
              }
              stack = (this || _global)._stack = (this || _global)._stack.__prev;
            }
            return iteratorDone();
          };
          return MapIterator;
        }(Iterator);
        function mapIteratorValue(type, entry) {
          return iteratorValue(type, entry[0], entry[1]);
        }
        function mapIteratorFrame(node, prev) {
          return {
            node: node,
            index: 0,
            __prev: prev
          };
        }
        function makeMap(size, root, ownerID, hash$$1) {
          var map = Object.create(MapPrototype);
          map.size = size;
          map._root = root;
          map.__ownerID = ownerID;
          map.__hash = hash$$1;
          map.__altered = false;
          return map;
        }
        var EMPTY_MAP;
        function emptyMap() {
          return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
        }
        function updateMap(map, k, v) {
          var newRoot;
          var newSize;
          if (!map._root) {
            if (v === NOT_SET) {
              return map;
            }
            newSize = 1;
            newRoot = new ArrayMapNode(map.__ownerID, [[
                k,
                v
              ]]);
          } else {
            var didChangeSize = MakeRef();
            var didAlter = MakeRef();
            newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
            if (!didAlter.value) {
              return map;
            }
            newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
          }
          if (map.__ownerID) {
            map.size = newSize;
            map._root = newRoot;
            map.__hash = undefined;
            map.__altered = true;
            return map;
          }
          return newRoot ? makeMap(newSize, newRoot) : emptyMap();
        }
        function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (!node) {
            if (value === NOT_SET) {
              return node;
            }
            SetRef(didAlter);
            SetRef(didChangeSize);
            return new ValueNode(ownerID, keyHash, [
              key,
              value
            ]);
          }
          return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
        }
        function isLeafNode(node) {
          return node.constructor === ValueNode || node.constructor === HashCollisionNode;
        }
        function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
          if (node.keyHash === keyHash) {
            return new HashCollisionNode(ownerID, keyHash, [
              node.entry,
              entry
            ]);
          }
          var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
          var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var newNode;
          var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [
            node,
            newNode
          ] : [
            newNode,
            node
          ]);
          return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
        }
        function createNodes(ownerID, entries, key, value) {
          if (!ownerID) {
            ownerID = new OwnerID();
          }
          var node = new ValueNode(ownerID, hash(key), [
            key,
            value
          ]);
          for (var ii = 0; ii < entries.length; ii++) {
            var entry = entries[ii];
            node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
          }
          return node;
        }
        function packNodes(ownerID, nodes, count, excluding) {
          var bitmap = 0;
          var packedII = 0;
          var packedNodes = new Array(count);
          for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
            var node = nodes[ii];
            if (node !== undefined && ii !== excluding) {
              bitmap |= bit;
              packedNodes[packedII++] = node;
            }
          }
          return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
        }
        function expandNodes(ownerID, nodes, bitmap, including, node) {
          var count = 0;
          var expandedNodes = new Array(SIZE);
          for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
            expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
          }
          expandedNodes[including] = node;
          return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
        }
        function popCount(x) {
          x -= x >> 1 & 1431655765;
          x = (x & 858993459) + (x >> 2 & 858993459);
          x = x + (x >> 4) & 252645135;
          x += x >> 8;
          x += x >> 16;
          return x & 127;
        }
        function setAt(array, idx, val, canEdit) {
          var newArray = canEdit ? array : arrCopy(array);
          newArray[idx] = val;
          return newArray;
        }
        function spliceIn(array, idx, val, canEdit) {
          var newLen = array.length + 1;
          if (canEdit && idx + 1 === newLen) {
            array[idx] = val;
            return array;
          }
          var newArray = new Array(newLen);
          var after = 0;
          for (var ii = 0; ii < newLen; ii++) {
            if (ii === idx) {
              newArray[ii] = val;
              after = -1;
            } else {
              newArray[ii] = array[ii + after];
            }
          }
          return newArray;
        }
        function spliceOut(array, idx, canEdit) {
          var newLen = array.length - 1;
          if (canEdit && idx === newLen) {
            array.pop();
            return array;
          }
          var newArray = new Array(newLen);
          var after = 0;
          for (var ii = 0; ii < newLen; ii++) {
            if (ii === idx) {
              after = 1;
            }
            newArray[ii] = array[ii + after];
          }
          return newArray;
        }
        var MAX_ARRAY_MAP_SIZE = SIZE / 4;
        var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
        var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
        var IS_LIST_SYMBOL = "@@__IMMUTABLE_LIST__@@";
        function isList(maybeList) {
          return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
        }
        var List = function (IndexedCollection$$1) {
          function List(value) {
            var empty = emptyList();
            if (value === null || value === undefined) {
              return empty;
            }
            if (isList(value)) {
              return value;
            }
            var iter = IndexedCollection$$1(value);
            var size = iter.size;
            if (size === 0) {
              return empty;
            }
            assertNotInfinite(size);
            if (size > 0 && size < SIZE) {
              return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
            }
            return empty.withMutations(function (list) {
              list.setSize(size);
              iter.forEach(function (v, i) {
                return list.set(i, v);
              });
            });
          }
          if (IndexedCollection$$1)
            List.__proto__ = IndexedCollection$$1;
          List.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);
          List.prototype.constructor = List;
          List.of = function of() {
            return (this || _global)(arguments);
          };
          List.prototype.toString = function toString() {
            return this.__toString("List [", "]");
          };
          List.prototype.get = function get(index, notSetValue) {
            index = wrapIndex(this || _global, index);
            if (index >= 0 && index < (this || _global).size) {
              index += (this || _global)._origin;
              var node = listNodeFor(this || _global, index);
              return node && node.array[index & MASK];
            }
            return notSetValue;
          };
          List.prototype.set = function set(index, value) {
            return updateList(this || _global, index, value);
          };
          List.prototype.remove = function remove(index) {
            return !this.has(index) ? this || _global : index === 0 ? this.shift() : index === (this || _global).size - 1 ? this.pop() : this.splice(index, 1);
          };
          List.prototype.insert = function insert(index, value) {
            return this.splice(index, 0, value);
          };
          List.prototype.clear = function clear() {
            if ((this || _global).size === 0) {
              return this || _global;
            }
            if ((this || _global).__ownerID) {
              (this || _global).size = (this || _global)._origin = (this || _global)._capacity = 0;
              (this || _global)._level = SHIFT;
              (this || _global)._root = (this || _global)._tail = null;
              (this || _global).__hash = undefined;
              (this || _global).__altered = true;
              return this || _global;
            }
            return emptyList();
          };
          List.prototype.push = function push() {
            var values = arguments;
            var oldSize = (this || _global).size;
            return this.withMutations(function (list) {
              setListBounds(list, 0, oldSize + values.length);
              for (var ii = 0; ii < values.length; ii++) {
                list.set(oldSize + ii, values[ii]);
              }
            });
          };
          List.prototype.pop = function pop() {
            return setListBounds(this || _global, 0, -1);
          };
          List.prototype.unshift = function unshift() {
            var values = arguments;
            return this.withMutations(function (list) {
              setListBounds(list, -values.length);
              for (var ii = 0; ii < values.length; ii++) {
                list.set(ii, values[ii]);
              }
            });
          };
          List.prototype.shift = function shift() {
            return setListBounds(this || _global, 1);
          };
          List.prototype.concat = function concat() {
            var arguments$1 = arguments;
            var seqs = [];
            for (var i = 0; i < arguments.length; i++) {
              var argument = arguments$1[i];
              var seq = IndexedCollection$$1(typeof argument !== "string" && hasIterator(argument) ? argument : [argument]);
              if (seq.size !== 0) {
                seqs.push(seq);
              }
            }
            if (seqs.length === 0) {
              return this || _global;
            }
            if ((this || _global).size === 0 && !(this || _global).__ownerID && seqs.length === 1) {
              return this.constructor(seqs[0]);
            }
            return this.withMutations(function (list) {
              seqs.forEach(function (seq) {
                return seq.forEach(function (value) {
                  return list.push(value);
                });
              });
            });
          };
          List.prototype.setSize = function setSize(size) {
            return setListBounds(this || _global, 0, size);
          };
          List.prototype.map = function map(mapper, context) {
            var this$1$1 = this || _global;
            return this.withMutations(function (list) {
              for (var i = 0; i < this$1$1.size; i++) {
                list.set(i, mapper.call(context, list.get(i), i, list));
              }
            });
          };
          List.prototype.slice = function slice(begin, end) {
            var size = (this || _global).size;
            if (wholeSlice(begin, end, size)) {
              return this || _global;
            }
            return setListBounds(this || _global, resolveBegin(begin, size), resolveEnd(end, size));
          };
          List.prototype.__iterator = function __iterator(type, reverse) {
            var index = reverse ? (this || _global).size : 0;
            var values = iterateList(this || _global, reverse);
            return new Iterator(function () {
              var value = values();
              return value === DONE ? iteratorDone() : iteratorValue(type, reverse ? --index : index++, value);
            });
          };
          List.prototype.__iterate = function __iterate(fn, reverse) {
            var index = reverse ? (this || _global).size : 0;
            var values = iterateList(this || _global, reverse);
            var value;
            while ((value = values()) !== DONE) {
              if (fn(value, reverse ? --index : index++, this || _global) === false) {
                break;
              }
            }
            return index;
          };
          List.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === (this || _global).__ownerID) {
              return this || _global;
            }
            if (!ownerID) {
              if ((this || _global).size === 0) {
                return emptyList();
              }
              (this || _global).__ownerID = ownerID;
              (this || _global).__altered = false;
              return this || _global;
            }
            return makeList((this || _global)._origin, (this || _global)._capacity, (this || _global)._level, (this || _global)._root, (this || _global)._tail, ownerID, (this || _global).__hash);
          };
          return List;
        }(IndexedCollection);
        List.isList = isList;
        var ListPrototype = List.prototype;
        ListPrototype[IS_LIST_SYMBOL] = true;
        ListPrototype[DELETE] = ListPrototype.remove;
        ListPrototype.merge = ListPrototype.concat;
        ListPrototype.setIn = setIn$1;
        ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
        ListPrototype.update = update$1;
        ListPrototype.updateIn = updateIn$1;
        ListPrototype.mergeIn = mergeIn;
        ListPrototype.mergeDeepIn = mergeDeepIn;
        ListPrototype.withMutations = withMutations;
        ListPrototype.wasAltered = wasAltered;
        ListPrototype.asImmutable = asImmutable;
        ListPrototype["@@transducer/init"] = ListPrototype.asMutable = asMutable;
        ListPrototype["@@transducer/step"] = function (result, arr) {
          return result.push(arr);
        };
        ListPrototype["@@transducer/result"] = function (obj) {
          return obj.asImmutable();
        };
        var VNode = function VNode(array, ownerID) {
          (this || _global).array = array;
          (this || _global).ownerID = ownerID;
        };
        VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
          if (index === level ? 1 << level : (this || _global).array.length === 0) {
            return this || _global;
          }
          var originIndex = index >>> level & MASK;
          if (originIndex >= (this || _global).array.length) {
            return new VNode([], ownerID);
          }
          var removingFirst = originIndex === 0;
          var newChild;
          if (level > 0) {
            var oldChild = (this || _global).array[originIndex];
            newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
            if (newChild === oldChild && removingFirst) {
              return this || _global;
            }
          }
          if (removingFirst && !newChild) {
            return this || _global;
          }
          var editable = editableVNode(this || _global, ownerID);
          if (!removingFirst) {
            for (var ii = 0; ii < originIndex; ii++) {
              editable.array[ii] = undefined;
            }
          }
          if (newChild) {
            editable.array[originIndex] = newChild;
          }
          return editable;
        };
        VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
          if (index === (level ? 1 << level : 0) || (this || _global).array.length === 0) {
            return this || _global;
          }
          var sizeIndex = index - 1 >>> level & MASK;
          if (sizeIndex >= (this || _global).array.length) {
            return this || _global;
          }
          var newChild;
          if (level > 0) {
            var oldChild = (this || _global).array[sizeIndex];
            newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
            if (newChild === oldChild && sizeIndex === (this || _global).array.length - 1) {
              return this || _global;
            }
          }
          var editable = editableVNode(this || _global, ownerID);
          editable.array.splice(sizeIndex + 1);
          if (newChild) {
            editable.array[sizeIndex] = newChild;
          }
          return editable;
        };
        var DONE = {};
        function iterateList(list, reverse) {
          var left = list._origin;
          var right = list._capacity;
          var tailPos = getTailOffset(right);
          var tail = list._tail;
          return iterateNodeOrLeaf(list._root, list._level, 0);
          function iterateNodeOrLeaf(node, level, offset) {
            return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
          }
          function iterateLeaf(node, offset) {
            var array = offset === tailPos ? tail && tail.array : node && node.array;
            var from = offset > left ? 0 : left - offset;
            var to = right - offset;
            if (to > SIZE) {
              to = SIZE;
            }
            return function () {
              if (from === to) {
                return DONE;
              }
              var idx = reverse ? --to : from++;
              return array && array[idx];
            };
          }
          function iterateNode(node, level, offset) {
            var values;
            var array = node && node.array;
            var from = offset > left ? 0 : left - offset >> level;
            var to = (right - offset >> level) + 1;
            if (to > SIZE) {
              to = SIZE;
            }
            return function () {
              while (true) {
                if (values) {
                  var value = values();
                  if (value !== DONE) {
                    return value;
                  }
                  values = null;
                }
                if (from === to) {
                  return DONE;
                }
                var idx = reverse ? --to : from++;
                values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
              }
            };
          }
        }
        function makeList(origin, capacity, level, root, tail, ownerID, hash) {
          var list = Object.create(ListPrototype);
          list.size = capacity - origin;
          list._origin = origin;
          list._capacity = capacity;
          list._level = level;
          list._root = root;
          list._tail = tail;
          list.__ownerID = ownerID;
          list.__hash = hash;
          list.__altered = false;
          return list;
        }
        var EMPTY_LIST;
        function emptyList() {
          return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
        }
        function updateList(list, index, value) {
          index = wrapIndex(list, index);
          if (index !== index) {
            return list;
          }
          if (index >= list.size || index < 0) {
            return list.withMutations(function (list) {
              index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);
            });
          }
          index += list._origin;
          var newTail = list._tail;
          var newRoot = list._root;
          var didAlter = MakeRef();
          if (index >= getTailOffset(list._capacity)) {
            newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
          } else {
            newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
          }
          if (!didAlter.value) {
            return list;
          }
          if (list.__ownerID) {
            list._root = newRoot;
            list._tail = newTail;
            list.__hash = undefined;
            list.__altered = true;
            return list;
          }
          return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
        }
        function updateVNode(node, ownerID, level, index, value, didAlter) {
          var idx = index >>> level & MASK;
          var nodeHas = node && idx < node.array.length;
          if (!nodeHas && value === undefined) {
            return node;
          }
          var newNode;
          if (level > 0) {
            var lowerNode = node && node.array[idx];
            var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
            if (newLowerNode === lowerNode) {
              return node;
            }
            newNode = editableVNode(node, ownerID);
            newNode.array[idx] = newLowerNode;
            return newNode;
          }
          if (nodeHas && node.array[idx] === value) {
            return node;
          }
          if (didAlter) {
            SetRef(didAlter);
          }
          newNode = editableVNode(node, ownerID);
          if (value === undefined && idx === newNode.array.length - 1) {
            newNode.array.pop();
          } else {
            newNode.array[idx] = value;
          }
          return newNode;
        }
        function editableVNode(node, ownerID) {
          if (ownerID && node && ownerID === node.ownerID) {
            return node;
          }
          return new VNode(node ? node.array.slice() : [], ownerID);
        }
        function listNodeFor(list, rawIndex) {
          if (rawIndex >= getTailOffset(list._capacity)) {
            return list._tail;
          }
          if (rawIndex < 1 << list._level + SHIFT) {
            var node = list._root;
            var level = list._level;
            while (node && level > 0) {
              node = node.array[rawIndex >>> level & MASK];
              level -= SHIFT;
            }
            return node;
          }
        }
        function setListBounds(list, begin, end) {
          if (begin !== undefined) {
            begin |= 0;
          }
          if (end !== undefined) {
            end |= 0;
          }
          var owner = list.__ownerID || new OwnerID();
          var oldOrigin = list._origin;
          var oldCapacity = list._capacity;
          var newOrigin = oldOrigin + begin;
          var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
          if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
            return list;
          }
          if (newOrigin >= newCapacity) {
            return list.clear();
          }
          var newLevel = list._level;
          var newRoot = list._root;
          var offsetShift = 0;
          while (newOrigin + offsetShift < 0) {
            newRoot = new VNode(newRoot && newRoot.array.length ? [
              undefined,
              newRoot
            ] : [], owner);
            newLevel += SHIFT;
            offsetShift += 1 << newLevel;
          }
          if (offsetShift) {
            newOrigin += offsetShift;
            oldOrigin += offsetShift;
            newCapacity += offsetShift;
            oldCapacity += offsetShift;
          }
          var oldTailOffset = getTailOffset(oldCapacity);
          var newTailOffset = getTailOffset(newCapacity);
          while (newTailOffset >= 1 << newLevel + SHIFT) {
            newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
            newLevel += SHIFT;
          }
          var oldTail = list._tail;
          var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
          if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
            newRoot = editableVNode(newRoot, owner);
            var node = newRoot;
            for (var level = newLevel; level > SHIFT; level -= SHIFT) {
              var idx = oldTailOffset >>> level & MASK;
              node = node.array[idx] = editableVNode(node.array[idx], owner);
            }
            node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
          }
          if (newCapacity < oldCapacity) {
            newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
          }
          if (newOrigin >= newTailOffset) {
            newOrigin -= newTailOffset;
            newCapacity -= newTailOffset;
            newLevel = SHIFT;
            newRoot = null;
            newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
          } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
            offsetShift = 0;
            while (newRoot) {
              var beginIndex = newOrigin >>> newLevel & MASK;
              if (beginIndex !== newTailOffset >>> newLevel & MASK) {
                break;
              }
              if (beginIndex) {
                offsetShift += (1 << newLevel) * beginIndex;
              }
              newLevel -= SHIFT;
              newRoot = newRoot.array[beginIndex];
            }
            if (newRoot && newOrigin > oldOrigin) {
              newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
            }
            if (newRoot && newTailOffset < oldTailOffset) {
              newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
            }
            if (offsetShift) {
              newOrigin -= offsetShift;
              newCapacity -= offsetShift;
            }
          }
          if (list.__ownerID) {
            list.size = newCapacity - newOrigin;
            list._origin = newOrigin;
            list._capacity = newCapacity;
            list._level = newLevel;
            list._root = newRoot;
            list._tail = newTail;
            list.__hash = undefined;
            list.__altered = true;
            return list;
          }
          return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
        }
        function getTailOffset(size) {
          return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
        }
        var OrderedMap = function (Map$$1) {
          function OrderedMap(value) {
            return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {
              var iter = KeyedCollection(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v, k) {
                return map.set(k, v);
              });
            });
          }
          if (Map$$1)
            OrderedMap.__proto__ = Map$$1;
          OrderedMap.prototype = Object.create(Map$$1 && Map$$1.prototype);
          OrderedMap.prototype.constructor = OrderedMap;
          OrderedMap.of = function of() {
            return (this || _global)(arguments);
          };
          OrderedMap.prototype.toString = function toString() {
            return this.__toString("OrderedMap {", "}");
          };
          OrderedMap.prototype.get = function get(k, notSetValue) {
            var index = (this || _global)._map.get(k);
            return index !== undefined ? (this || _global)._list.get(index)[1] : notSetValue;
          };
          OrderedMap.prototype.clear = function clear() {
            if ((this || _global).size === 0) {
              return this || _global;
            }
            if ((this || _global).__ownerID) {
              (this || _global).size = 0;
              (this || _global)._map.clear();
              (this || _global)._list.clear();
              return this || _global;
            }
            return emptyOrderedMap();
          };
          OrderedMap.prototype.set = function set(k, v) {
            return updateOrderedMap(this || _global, k, v);
          };
          OrderedMap.prototype.remove = function remove(k) {
            return updateOrderedMap(this || _global, k, NOT_SET);
          };
          OrderedMap.prototype.wasAltered = function wasAltered() {
            return (this || _global)._map.wasAltered() || (this || _global)._list.wasAltered();
          };
          OrderedMap.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this || _global;
            return (this || _global)._list.__iterate(function (entry) {
              return entry && fn(entry[1], entry[0], this$1$1);
            }, reverse);
          };
          OrderedMap.prototype.__iterator = function __iterator(type, reverse) {
            return (this || _global)._list.fromEntrySeq().__iterator(type, reverse);
          };
          OrderedMap.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === (this || _global).__ownerID) {
              return this || _global;
            }
            var newMap = (this || _global)._map.__ensureOwner(ownerID);
            var newList = (this || _global)._list.__ensureOwner(ownerID);
            if (!ownerID) {
              if ((this || _global).size === 0) {
                return emptyOrderedMap();
              }
              (this || _global).__ownerID = ownerID;
              (this || _global)._map = newMap;
              (this || _global)._list = newList;
              return this || _global;
            }
            return makeOrderedMap(newMap, newList, ownerID, (this || _global).__hash);
          };
          return OrderedMap;
        }(Map);
        OrderedMap.isOrderedMap = isOrderedMap;
        OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
        OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
        function makeOrderedMap(map, list, ownerID, hash) {
          var omap = Object.create(OrderedMap.prototype);
          omap.size = map ? map.size : 0;
          omap._map = map;
          omap._list = list;
          omap.__ownerID = ownerID;
          omap.__hash = hash;
          return omap;
        }
        var EMPTY_ORDERED_MAP;
        function emptyOrderedMap() {
          return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
        }
        function updateOrderedMap(omap, k, v) {
          var map = omap._map;
          var list = omap._list;
          var i = map.get(k);
          var has = i !== undefined;
          var newMap;
          var newList;
          if (v === NOT_SET) {
            if (!has) {
              return omap;
            }
            if (list.size >= SIZE && list.size >= map.size * 2) {
              newList = list.filter(function (entry, idx) {
                return entry !== undefined && i !== idx;
              });
              newMap = newList.toKeyedSeq().map(function (entry) {
                return entry[0];
              }).flip().toMap();
              if (omap.__ownerID) {
                newMap.__ownerID = newList.__ownerID = omap.__ownerID;
              }
            } else {
              newMap = map.remove(k);
              newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
            }
          } else if (has) {
            if (v === list.get(i)[1]) {
              return omap;
            }
            newMap = map;
            newList = list.set(i, [
              k,
              v
            ]);
          } else {
            newMap = map.set(k, list.size);
            newList = list.set(list.size, [
              k,
              v
            ]);
          }
          if (omap.__ownerID) {
            omap.size = newMap.size;
            omap._map = newMap;
            omap._list = newList;
            omap.__hash = undefined;
            return omap;
          }
          return makeOrderedMap(newMap, newList);
        }
        var IS_STACK_SYMBOL = "@@__IMMUTABLE_STACK__@@";
        function isStack(maybeStack) {
          return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
        }
        var Stack = function (IndexedCollection$$1) {
          function Stack(value) {
            return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
          }
          if (IndexedCollection$$1)
            Stack.__proto__ = IndexedCollection$$1;
          Stack.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);
          Stack.prototype.constructor = Stack;
          Stack.of = function of() {
            return (this || _global)(arguments);
          };
          Stack.prototype.toString = function toString() {
            return this.__toString("Stack [", "]");
          };
          Stack.prototype.get = function get(index, notSetValue) {
            var head = (this || _global)._head;
            index = wrapIndex(this || _global, index);
            while (head && index--) {
              head = head.next;
            }
            return head ? head.value : notSetValue;
          };
          Stack.prototype.peek = function peek() {
            return (this || _global)._head && (this || _global)._head.value;
          };
          Stack.prototype.push = function push() {
            var arguments$1 = arguments;
            if (arguments.length === 0) {
              return this || _global;
            }
            var newSize = (this || _global).size + arguments.length;
            var head = (this || _global)._head;
            for (var ii = arguments.length - 1; ii >= 0; ii--) {
              head = {
                value: arguments$1[ii],
                next: head
              };
            }
            if ((this || _global).__ownerID) {
              (this || _global).size = newSize;
              (this || _global)._head = head;
              (this || _global).__hash = undefined;
              (this || _global).__altered = true;
              return this || _global;
            }
            return makeStack(newSize, head);
          };
          Stack.prototype.pushAll = function pushAll(iter) {
            iter = IndexedCollection$$1(iter);
            if (iter.size === 0) {
              return this || _global;
            }
            if ((this || _global).size === 0 && isStack(iter)) {
              return iter;
            }
            assertNotInfinite(iter.size);
            var newSize = (this || _global).size;
            var head = (this || _global)._head;
            iter.__iterate(function (value) {
              newSize++;
              head = {
                value: value,
                next: head
              };
            }, true);
            if ((this || _global).__ownerID) {
              (this || _global).size = newSize;
              (this || _global)._head = head;
              (this || _global).__hash = undefined;
              (this || _global).__altered = true;
              return this || _global;
            }
            return makeStack(newSize, head);
          };
          Stack.prototype.pop = function pop() {
            return this.slice(1);
          };
          Stack.prototype.clear = function clear() {
            if ((this || _global).size === 0) {
              return this || _global;
            }
            if ((this || _global).__ownerID) {
              (this || _global).size = 0;
              (this || _global)._head = undefined;
              (this || _global).__hash = undefined;
              (this || _global).__altered = true;
              return this || _global;
            }
            return emptyStack();
          };
          Stack.prototype.slice = function slice(begin, end) {
            if (wholeSlice(begin, end, (this || _global).size)) {
              return this || _global;
            }
            var resolvedBegin = resolveBegin(begin, (this || _global).size);
            var resolvedEnd = resolveEnd(end, (this || _global).size);
            if (resolvedEnd !== (this || _global).size) {
              return IndexedCollection$$1.prototype.slice.call(this || _global, begin, end);
            }
            var newSize = (this || _global).size - resolvedBegin;
            var head = (this || _global)._head;
            while (resolvedBegin--) {
              head = head.next;
            }
            if ((this || _global).__ownerID) {
              (this || _global).size = newSize;
              (this || _global)._head = head;
              (this || _global).__hash = undefined;
              (this || _global).__altered = true;
              return this || _global;
            }
            return makeStack(newSize, head);
          };
          Stack.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === (this || _global).__ownerID) {
              return this || _global;
            }
            if (!ownerID) {
              if ((this || _global).size === 0) {
                return emptyStack();
              }
              (this || _global).__ownerID = ownerID;
              (this || _global).__altered = false;
              return this || _global;
            }
            return makeStack((this || _global).size, (this || _global)._head, ownerID, (this || _global).__hash);
          };
          Stack.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this || _global;
            if (reverse) {
              return new ArraySeq(this.toArray()).__iterate(function (v, k) {
                return fn(v, k, this$1$1);
              }, reverse);
            }
            var iterations = 0;
            var node = (this || _global)._head;
            while (node) {
              if (fn(node.value, iterations++, this || _global) === false) {
                break;
              }
              node = node.next;
            }
            return iterations;
          };
          Stack.prototype.__iterator = function __iterator(type, reverse) {
            if (reverse) {
              return new ArraySeq(this.toArray()).__iterator(type, reverse);
            }
            var iterations = 0;
            var node = (this || _global)._head;
            return new Iterator(function () {
              if (node) {
                var value = node.value;
                node = node.next;
                return iteratorValue(type, iterations++, value);
              }
              return iteratorDone();
            });
          };
          return Stack;
        }(IndexedCollection);
        Stack.isStack = isStack;
        var StackPrototype = Stack.prototype;
        StackPrototype[IS_STACK_SYMBOL] = true;
        StackPrototype.shift = StackPrototype.pop;
        StackPrototype.unshift = StackPrototype.push;
        StackPrototype.unshiftAll = StackPrototype.pushAll;
        StackPrototype.withMutations = withMutations;
        StackPrototype.wasAltered = wasAltered;
        StackPrototype.asImmutable = asImmutable;
        StackPrototype["@@transducer/init"] = StackPrototype.asMutable = asMutable;
        StackPrototype["@@transducer/step"] = function (result, arr) {
          return result.unshift(arr);
        };
        StackPrototype["@@transducer/result"] = function (obj) {
          return obj.asImmutable();
        };
        function makeStack(size, head, ownerID, hash) {
          var map = Object.create(StackPrototype);
          map.size = size;
          map._head = head;
          map.__ownerID = ownerID;
          map.__hash = hash;
          map.__altered = false;
          return map;
        }
        var EMPTY_STACK;
        function emptyStack() {
          return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
        }
        var IS_SET_SYMBOL = "@@__IMMUTABLE_SET__@@";
        function isSet(maybeSet) {
          return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
        }
        function isOrderedSet(maybeOrderedSet) {
          return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
        }
        function deepEqual(a, b) {
          if (a === b) {
            return true;
          }
          if (!isCollection(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
            return false;
          }
          if (a.size === 0 && b.size === 0) {
            return true;
          }
          var notAssociative = !isAssociative(a);
          if (isOrdered(a)) {
            var entries = a.entries();
            return b.every(function (v, k) {
              var entry = entries.next().value;
              return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
            }) && entries.next().done;
          }
          var flipped = false;
          if (a.size === undefined) {
            if (b.size === undefined) {
              if (typeof a.cacheResult === "function") {
                a.cacheResult();
              }
            } else {
              flipped = true;
              var _ = a;
              a = b;
              b = _;
            }
          }
          var allEqual = true;
          var bSize = b.__iterate(function (v, k) {
            if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
              allEqual = false;
              return false;
            }
          });
          return allEqual && a.size === bSize;
        }
        function mixin(ctor, methods) {
          var keyCopier = function (key) {
            ctor.prototype[key] = methods[key];
          };
          Object.keys(methods).forEach(keyCopier);
          Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
          return ctor;
        }
        function toJS(value) {
          if (!value || typeof value !== "object") {
            return value;
          }
          if (!isCollection(value)) {
            if (!isDataStructure(value)) {
              return value;
            }
            value = Seq(value);
          }
          if (isKeyed(value)) {
            var result$1 = {};
            value.__iterate(function (v, k) {
              result$1[k] = toJS(v);
            });
            return result$1;
          }
          var result = [];
          value.__iterate(function (v) {
            result.push(toJS(v));
          });
          return result;
        }
        var Set = function (SetCollection$$1) {
          function Set(value) {
            return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {
              var iter = SetCollection$$1(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v) {
                return set.add(v);
              });
            });
          }
          if (SetCollection$$1)
            Set.__proto__ = SetCollection$$1;
          Set.prototype = Object.create(SetCollection$$1 && SetCollection$$1.prototype);
          Set.prototype.constructor = Set;
          Set.of = function of() {
            return (this || _global)(arguments);
          };
          Set.fromKeys = function fromKeys(value) {
            return (this || _global)(KeyedCollection(value).keySeq());
          };
          Set.intersect = function intersect(sets) {
            sets = Collection(sets).toArray();
            return sets.length ? SetPrototype.intersect.apply(Set(sets.pop()), sets) : emptySet();
          };
          Set.union = function union(sets) {
            sets = Collection(sets).toArray();
            return sets.length ? SetPrototype.union.apply(Set(sets.pop()), sets) : emptySet();
          };
          Set.prototype.toString = function toString() {
            return this.__toString("Set {", "}");
          };
          Set.prototype.has = function has(value) {
            return (this || _global)._map.has(value);
          };
          Set.prototype.add = function add(value) {
            return updateSet(this || _global, (this || _global)._map.set(value, value));
          };
          Set.prototype.remove = function remove(value) {
            return updateSet(this || _global, (this || _global)._map.remove(value));
          };
          Set.prototype.clear = function clear() {
            return updateSet(this || _global, (this || _global)._map.clear());
          };
          Set.prototype.map = function map(mapper, context) {
            var this$1$1 = this || _global;
            var removes = [];
            var adds = [];
            this.forEach(function (value) {
              var mapped = mapper.call(context, value, value, this$1$1);
              if (mapped !== value) {
                removes.push(value);
                adds.push(mapped);
              }
            });
            return this.withMutations(function (set) {
              removes.forEach(function (value) {
                return set.remove(value);
              });
              adds.forEach(function (value) {
                return set.add(value);
              });
            });
          };
          Set.prototype.union = function union() {
            var iters = [], len = arguments.length;
            while (len--)
              iters[len] = arguments[len];
            iters = iters.filter(function (x) {
              return x.size !== 0;
            });
            if (iters.length === 0) {
              return this || _global;
            }
            if ((this || _global).size === 0 && !(this || _global).__ownerID && iters.length === 1) {
              return this.constructor(iters[0]);
            }
            return this.withMutations(function (set) {
              for (var ii = 0; ii < iters.length; ii++) {
                SetCollection$$1(iters[ii]).forEach(function (value) {
                  return set.add(value);
                });
              }
            });
          };
          Set.prototype.intersect = function intersect() {
            var iters = [], len = arguments.length;
            while (len--)
              iters[len] = arguments[len];
            if (iters.length === 0) {
              return this || _global;
            }
            iters = iters.map(function (iter) {
              return SetCollection$$1(iter);
            });
            var toRemove = [];
            this.forEach(function (value) {
              if (!iters.every(function (iter) {
                  return iter.includes(value);
                })) {
                toRemove.push(value);
              }
            });
            return this.withMutations(function (set) {
              toRemove.forEach(function (value) {
                set.remove(value);
              });
            });
          };
          Set.prototype.subtract = function subtract() {
            var iters = [], len = arguments.length;
            while (len--)
              iters[len] = arguments[len];
            if (iters.length === 0) {
              return this || _global;
            }
            iters = iters.map(function (iter) {
              return SetCollection$$1(iter);
            });
            var toRemove = [];
            this.forEach(function (value) {
              if (iters.some(function (iter) {
                  return iter.includes(value);
                })) {
                toRemove.push(value);
              }
            });
            return this.withMutations(function (set) {
              toRemove.forEach(function (value) {
                set.remove(value);
              });
            });
          };
          Set.prototype.sort = function sort(comparator) {
            return OrderedSet(sortFactory(this || _global, comparator));
          };
          Set.prototype.sortBy = function sortBy(mapper, comparator) {
            return OrderedSet(sortFactory(this || _global, comparator, mapper));
          };
          Set.prototype.wasAltered = function wasAltered() {
            return (this || _global)._map.wasAltered();
          };
          Set.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this || _global;
            return (this || _global)._map.__iterate(function (k) {
              return fn(k, k, this$1$1);
            }, reverse);
          };
          Set.prototype.__iterator = function __iterator(type, reverse) {
            return (this || _global)._map.__iterator(type, reverse);
          };
          Set.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === (this || _global).__ownerID) {
              return this || _global;
            }
            var newMap = (this || _global)._map.__ensureOwner(ownerID);
            if (!ownerID) {
              if ((this || _global).size === 0) {
                return this.__empty();
              }
              (this || _global).__ownerID = ownerID;
              (this || _global)._map = newMap;
              return this || _global;
            }
            return this.__make(newMap, ownerID);
          };
          return Set;
        }(SetCollection);
        Set.isSet = isSet;
        var SetPrototype = Set.prototype;
        SetPrototype[IS_SET_SYMBOL] = true;
        SetPrototype[DELETE] = SetPrototype.remove;
        SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
        SetPrototype.withMutations = withMutations;
        SetPrototype.asImmutable = asImmutable;
        SetPrototype["@@transducer/init"] = SetPrototype.asMutable = asMutable;
        SetPrototype["@@transducer/step"] = function (result, arr) {
          return result.add(arr);
        };
        SetPrototype["@@transducer/result"] = function (obj) {
          return obj.asImmutable();
        };
        SetPrototype.__empty = emptySet;
        SetPrototype.__make = makeSet;
        function updateSet(set, newMap) {
          if (set.__ownerID) {
            set.size = newMap.size;
            set._map = newMap;
            return set;
          }
          return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
        }
        function makeSet(map, ownerID) {
          var set = Object.create(SetPrototype);
          set.size = map ? map.size : 0;
          set._map = map;
          set.__ownerID = ownerID;
          return set;
        }
        var EMPTY_SET;
        function emptySet() {
          return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
        }
        var Range = function (IndexedSeq$$1) {
          function Range(start, end, step) {
            if (!((this || _global) instanceof Range)) {
              return new Range(start, end, step);
            }
            invariant(step !== 0, "Cannot step a Range by 0");
            start = start || 0;
            if (end === undefined) {
              end = Infinity;
            }
            step = step === undefined ? 1 : Math.abs(step);
            if (end < start) {
              step = -step;
            }
            (this || _global)._start = start;
            (this || _global)._end = end;
            (this || _global)._step = step;
            (this || _global).size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
            if ((this || _global).size === 0) {
              if (EMPTY_RANGE) {
                return EMPTY_RANGE;
              }
              EMPTY_RANGE = this || _global;
            }
          }
          if (IndexedSeq$$1)
            Range.__proto__ = IndexedSeq$$1;
          Range.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
          Range.prototype.constructor = Range;
          Range.prototype.toString = function toString() {
            if ((this || _global).size === 0) {
              return "Range []";
            }
            return "Range [ " + (this || _global)._start + "..." + (this || _global)._end + ((this || _global)._step !== 1 ? " by " + (this || _global)._step : "") + " ]";
          };
          Range.prototype.get = function get(index, notSetValue) {
            return this.has(index) ? (this || _global)._start + wrapIndex(this || _global, index) * (this || _global)._step : notSetValue;
          };
          Range.prototype.includes = function includes(searchValue) {
            var possibleIndex = (searchValue - (this || _global)._start) / (this || _global)._step;
            return possibleIndex >= 0 && possibleIndex < (this || _global).size && possibleIndex === Math.floor(possibleIndex);
          };
          Range.prototype.slice = function slice(begin, end) {
            if (wholeSlice(begin, end, (this || _global).size)) {
              return this || _global;
            }
            begin = resolveBegin(begin, (this || _global).size);
            end = resolveEnd(end, (this || _global).size);
            if (end <= begin) {
              return new Range(0, 0);
            }
            return new Range(this.get(begin, (this || _global)._end), this.get(end, (this || _global)._end), (this || _global)._step);
          };
          Range.prototype.indexOf = function indexOf(searchValue) {
            var offsetValue = searchValue - (this || _global)._start;
            if (offsetValue % (this || _global)._step === 0) {
              var index = offsetValue / (this || _global)._step;
              if (index >= 0 && index < (this || _global).size) {
                return index;
              }
            }
            return -1;
          };
          Range.prototype.lastIndexOf = function lastIndexOf(searchValue) {
            return this.indexOf(searchValue);
          };
          Range.prototype.__iterate = function __iterate(fn, reverse) {
            var size = (this || _global).size;
            var step = (this || _global)._step;
            var value = reverse ? (this || _global)._start + (size - 1) * step : (this || _global)._start;
            var i = 0;
            while (i !== size) {
              if (fn(value, reverse ? size - ++i : i++, this || _global) === false) {
                break;
              }
              value += reverse ? -step : step;
            }
            return i;
          };
          Range.prototype.__iterator = function __iterator(type, reverse) {
            var size = (this || _global).size;
            var step = (this || _global)._step;
            var value = reverse ? (this || _global)._start + (size - 1) * step : (this || _global)._start;
            var i = 0;
            return new Iterator(function () {
              if (i === size) {
                return iteratorDone();
              }
              var v = value;
              value += reverse ? -step : step;
              return iteratorValue(type, reverse ? size - ++i : i++, v);
            });
          };
          Range.prototype.equals = function equals(other) {
            return other instanceof Range ? (this || _global)._start === other._start && (this || _global)._end === other._end && (this || _global)._step === other._step : deepEqual(this || _global, other);
          };
          return Range;
        }(IndexedSeq);
        var EMPTY_RANGE;
        function getIn(collection, searchKeyPath, notSetValue) {
          var keyPath = coerceKeyPath(searchKeyPath);
          var i = 0;
          while (i !== keyPath.length) {
            collection = get(collection, keyPath[i++], NOT_SET);
            if (collection === NOT_SET) {
              return notSetValue;
            }
          }
          return collection;
        }
        function getIn$1(searchKeyPath, notSetValue) {
          return getIn(this || _global, searchKeyPath, notSetValue);
        }
        function hasIn(collection, keyPath) {
          return getIn(collection, keyPath, NOT_SET) !== NOT_SET;
        }
        function hasIn$1(searchKeyPath) {
          return hasIn(this || _global, searchKeyPath);
        }
        function toObject() {
          assertNotInfinite((this || _global).size);
          var object = {};
          this.__iterate(function (v, k) {
            object[k] = v;
          });
          return object;
        }
        Collection.isIterable = isCollection;
        Collection.isKeyed = isKeyed;
        Collection.isIndexed = isIndexed;
        Collection.isAssociative = isAssociative;
        Collection.isOrdered = isOrdered;
        Collection.Iterator = Iterator;
        mixin(Collection, {
          toArray: function toArray() {
            assertNotInfinite((this || _global).size);
            var array = new Array((this || _global).size || 0);
            var useTuples = isKeyed(this || _global);
            var i = 0;
            this.__iterate(function (v, k) {
              array[i++] = useTuples ? [
                k,
                v
              ] : v;
            });
            return array;
          },
          toIndexedSeq: function toIndexedSeq() {
            return new ToIndexedSequence(this || _global);
          },
          toJS: function toJS$1() {
            return toJS(this || _global);
          },
          toKeyedSeq: function toKeyedSeq() {
            return new ToKeyedSequence(this || _global, true);
          },
          toMap: function toMap() {
            return Map(this.toKeyedSeq());
          },
          toObject: toObject,
          toOrderedMap: function toOrderedMap() {
            return OrderedMap(this.toKeyedSeq());
          },
          toOrderedSet: function toOrderedSet() {
            return OrderedSet(isKeyed(this || _global) ? this.valueSeq() : this || _global);
          },
          toSet: function toSet() {
            return Set(isKeyed(this || _global) ? this.valueSeq() : this || _global);
          },
          toSetSeq: function toSetSeq() {
            return new ToSetSequence(this || _global);
          },
          toSeq: function toSeq() {
            return isIndexed(this || _global) ? this.toIndexedSeq() : isKeyed(this || _global) ? this.toKeyedSeq() : this.toSetSeq();
          },
          toStack: function toStack() {
            return Stack(isKeyed(this || _global) ? this.valueSeq() : this || _global);
          },
          toList: function toList() {
            return List(isKeyed(this || _global) ? this.valueSeq() : this || _global);
          },
          toString: function toString() {
            return "[Collection]";
          },
          __toString: function __toString(head, tail) {
            if ((this || _global).size === 0) {
              return head + tail;
            }
            return head + " " + this.toSeq().map((this || _global).__toStringMapper).join(", ") + " " + tail;
          },
          concat: function concat() {
            var values = [], len = arguments.length;
            while (len--)
              values[len] = arguments[len];
            return reify(this || _global, concatFactory(this || _global, values));
          },
          includes: function includes(searchValue) {
            return this.some(function (value) {
              return is(value, searchValue);
            });
          },
          entries: function entries() {
            return this.__iterator(ITERATE_ENTRIES);
          },
          every: function every(predicate, context) {
            assertNotInfinite((this || _global).size);
            var returnValue = true;
            this.__iterate(function (v, k, c) {
              if (!predicate.call(context, v, k, c)) {
                returnValue = false;
                return false;
              }
            });
            return returnValue;
          },
          filter: function filter(predicate, context) {
            return reify(this || _global, filterFactory(this || _global, predicate, context, true));
          },
          find: function find(predicate, context, notSetValue) {
            var entry = this.findEntry(predicate, context);
            return entry ? entry[1] : notSetValue;
          },
          forEach: function forEach(sideEffect, context) {
            assertNotInfinite((this || _global).size);
            return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
          },
          join: function join(separator) {
            assertNotInfinite((this || _global).size);
            separator = separator !== undefined ? "" + separator : ",";
            var joined = "";
            var isFirst = true;
            this.__iterate(function (v) {
              isFirst ? isFirst = false : joined += separator;
              joined += v !== null && v !== undefined ? v.toString() : "";
            });
            return joined;
          },
          keys: function keys() {
            return this.__iterator(ITERATE_KEYS);
          },
          map: function map(mapper, context) {
            return reify(this || _global, mapFactory(this || _global, mapper, context));
          },
          reduce: function reduce$1(reducer, initialReduction, context) {
            return reduce(this || _global, reducer, initialReduction, context, arguments.length < 2, false);
          },
          reduceRight: function reduceRight(reducer, initialReduction, context) {
            return reduce(this || _global, reducer, initialReduction, context, arguments.length < 2, true);
          },
          reverse: function reverse() {
            return reify(this || _global, reverseFactory(this || _global, true));
          },
          slice: function slice(begin, end) {
            return reify(this || _global, sliceFactory(this || _global, begin, end, true));
          },
          some: function some(predicate, context) {
            return !this.every(not(predicate), context);
          },
          sort: function sort(comparator) {
            return reify(this || _global, sortFactory(this || _global, comparator));
          },
          values: function values() {
            return this.__iterator(ITERATE_VALUES);
          },
          butLast: function butLast() {
            return this.slice(0, -1);
          },
          isEmpty: function isEmpty() {
            return (this || _global).size !== undefined ? (this || _global).size === 0 : !this.some(function () {
              return true;
            });
          },
          count: function count(predicate, context) {
            return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this || _global);
          },
          countBy: function countBy(grouper, context) {
            return countByFactory(this || _global, grouper, context);
          },
          equals: function equals(other) {
            return deepEqual(this || _global, other);
          },
          entrySeq: function entrySeq() {
            var collection = this || _global;
            if (collection._cache) {
              return new ArraySeq(collection._cache);
            }
            var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
            entriesSequence.fromEntrySeq = function () {
              return collection.toSeq();
            };
            return entriesSequence;
          },
          filterNot: function filterNot(predicate, context) {
            return this.filter(not(predicate), context);
          },
          findEntry: function findEntry(predicate, context, notSetValue) {
            var found = notSetValue;
            this.__iterate(function (v, k, c) {
              if (predicate.call(context, v, k, c)) {
                found = [
                  k,
                  v
                ];
                return false;
              }
            });
            return found;
          },
          findKey: function findKey(predicate, context) {
            var entry = this.findEntry(predicate, context);
            return entry && entry[0];
          },
          findLast: function findLast(predicate, context, notSetValue) {
            return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
          },
          findLastEntry: function findLastEntry(predicate, context, notSetValue) {
            return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
          },
          findLastKey: function findLastKey(predicate, context) {
            return this.toKeyedSeq().reverse().findKey(predicate, context);
          },
          first: function first(notSetValue) {
            return this.find(returnTrue, null, notSetValue);
          },
          flatMap: function flatMap(mapper, context) {
            return reify(this || _global, flatMapFactory(this || _global, mapper, context));
          },
          flatten: function flatten(depth) {
            return reify(this || _global, flattenFactory(this || _global, depth, true));
          },
          fromEntrySeq: function fromEntrySeq() {
            return new FromEntriesSequence(this || _global);
          },
          get: function get(searchKey, notSetValue) {
            return this.find(function (_, key) {
              return is(key, searchKey);
            }, undefined, notSetValue);
          },
          getIn: getIn$1,
          groupBy: function groupBy(grouper, context) {
            return groupByFactory(this || _global, grouper, context);
          },
          has: function has(searchKey) {
            return this.get(searchKey, NOT_SET) !== NOT_SET;
          },
          hasIn: hasIn$1,
          isSubset: function isSubset(iter) {
            iter = typeof iter.includes === "function" ? iter : Collection(iter);
            return this.every(function (value) {
              return iter.includes(value);
            });
          },
          isSuperset: function isSuperset(iter) {
            iter = typeof iter.isSubset === "function" ? iter : Collection(iter);
            return iter.isSubset(this || _global);
          },
          keyOf: function keyOf(searchValue) {
            return this.findKey(function (value) {
              return is(value, searchValue);
            });
          },
          keySeq: function keySeq() {
            return this.toSeq().map(keyMapper).toIndexedSeq();
          },
          last: function last(notSetValue) {
            return this.toSeq().reverse().first(notSetValue);
          },
          lastKeyOf: function lastKeyOf(searchValue) {
            return this.toKeyedSeq().reverse().keyOf(searchValue);
          },
          max: function max(comparator) {
            return maxFactory(this || _global, comparator);
          },
          maxBy: function maxBy(mapper, comparator) {
            return maxFactory(this || _global, comparator, mapper);
          },
          min: function min(comparator) {
            return maxFactory(this || _global, comparator ? neg(comparator) : defaultNegComparator);
          },
          minBy: function minBy(mapper, comparator) {
            return maxFactory(this || _global, comparator ? neg(comparator) : defaultNegComparator, mapper);
          },
          rest: function rest() {
            return this.slice(1);
          },
          skip: function skip(amount) {
            return amount === 0 ? this || _global : this.slice(Math.max(0, amount));
          },
          skipLast: function skipLast(amount) {
            return amount === 0 ? this || _global : this.slice(0, -Math.max(0, amount));
          },
          skipWhile: function skipWhile(predicate, context) {
            return reify(this || _global, skipWhileFactory(this || _global, predicate, context, true));
          },
          skipUntil: function skipUntil(predicate, context) {
            return this.skipWhile(not(predicate), context);
          },
          sortBy: function sortBy(mapper, comparator) {
            return reify(this || _global, sortFactory(this || _global, comparator, mapper));
          },
          take: function take(amount) {
            return this.slice(0, Math.max(0, amount));
          },
          takeLast: function takeLast(amount) {
            return this.slice(-Math.max(0, amount));
          },
          takeWhile: function takeWhile(predicate, context) {
            return reify(this || _global, takeWhileFactory(this || _global, predicate, context));
          },
          takeUntil: function takeUntil(predicate, context) {
            return this.takeWhile(not(predicate), context);
          },
          update: function update(fn) {
            return fn(this || _global);
          },
          valueSeq: function valueSeq() {
            return this.toIndexedSeq();
          },
          hashCode: function hashCode() {
            return (this || _global).__hash || ((this || _global).__hash = hashCollection(this || _global));
          }
        });
        var CollectionPrototype = Collection.prototype;
        CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
        CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
        CollectionPrototype.toJSON = CollectionPrototype.toArray;
        CollectionPrototype.__toStringMapper = quoteString;
        CollectionPrototype.inspect = CollectionPrototype.toSource = function () {
          return this.toString();
        };
        CollectionPrototype.chain = CollectionPrototype.flatMap;
        CollectionPrototype.contains = CollectionPrototype.includes;
        mixin(KeyedCollection, {
          flip: function flip() {
            return reify(this || _global, flipFactory(this || _global));
          },
          mapEntries: function mapEntries(mapper, context) {
            var this$1$1 = this || _global;
            var iterations = 0;
            return reify(this || _global, this.toSeq().map(function (v, k) {
              return mapper.call(context, [
                k,
                v
              ], iterations++, this$1$1);
            }).fromEntrySeq());
          },
          mapKeys: function mapKeys(mapper, context) {
            var this$1$1 = this || _global;
            return reify(this || _global, this.toSeq().flip().map(function (k, v) {
              return mapper.call(context, k, v, this$1$1);
            }).flip());
          }
        });
        var KeyedCollectionPrototype = KeyedCollection.prototype;
        KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
        KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
        KeyedCollectionPrototype.toJSON = toObject;
        KeyedCollectionPrototype.__toStringMapper = function (v, k) {
          return quoteString(k) + ": " + quoteString(v);
        };
        mixin(IndexedCollection, {
          toKeyedSeq: function toKeyedSeq() {
            return new ToKeyedSequence(this || _global, false);
          },
          filter: function filter(predicate, context) {
            return reify(this || _global, filterFactory(this || _global, predicate, context, false));
          },
          findIndex: function findIndex(predicate, context) {
            var entry = this.findEntry(predicate, context);
            return entry ? entry[0] : -1;
          },
          indexOf: function indexOf(searchValue) {
            var key = this.keyOf(searchValue);
            return key === undefined ? -1 : key;
          },
          lastIndexOf: function lastIndexOf(searchValue) {
            var key = this.lastKeyOf(searchValue);
            return key === undefined ? -1 : key;
          },
          reverse: function reverse() {
            return reify(this || _global, reverseFactory(this || _global, false));
          },
          slice: function slice(begin, end) {
            return reify(this || _global, sliceFactory(this || _global, begin, end, false));
          },
          splice: function splice(index, removeNum) {
            var numArgs = arguments.length;
            removeNum = Math.max(removeNum || 0, 0);
            if (numArgs === 0 || numArgs === 2 && !removeNum) {
              return this || _global;
            }
            index = resolveBegin(index, index < 0 ? this.count() : (this || _global).size);
            var spliced = this.slice(0, index);
            return reify(this || _global, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
          },
          findLastIndex: function findLastIndex(predicate, context) {
            var entry = this.findLastEntry(predicate, context);
            return entry ? entry[0] : -1;
          },
          first: function first(notSetValue) {
            return this.get(0, notSetValue);
          },
          flatten: function flatten(depth) {
            return reify(this || _global, flattenFactory(this || _global, depth, false));
          },
          get: function get(index, notSetValue) {
            index = wrapIndex(this || _global, index);
            return index < 0 || (this || _global).size === Infinity || (this || _global).size !== undefined && index > (this || _global).size ? notSetValue : this.find(function (_, key) {
              return key === index;
            }, undefined, notSetValue);
          },
          has: function has(index) {
            index = wrapIndex(this || _global, index);
            return index >= 0 && ((this || _global).size !== undefined ? (this || _global).size === Infinity || index < (this || _global).size : this.indexOf(index) !== -1);
          },
          interpose: function interpose(separator) {
            return reify(this || _global, interposeFactory(this || _global, separator));
          },
          interleave: function interleave() {
            var collections = [this || _global].concat(arrCopy(arguments));
            var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
            var interleaved = zipped.flatten(true);
            if (zipped.size) {
              interleaved.size = zipped.size * collections.length;
            }
            return reify(this || _global, interleaved);
          },
          keySeq: function keySeq() {
            return Range(0, (this || _global).size);
          },
          last: function last(notSetValue) {
            return this.get(-1, notSetValue);
          },
          skipWhile: function skipWhile(predicate, context) {
            return reify(this || _global, skipWhileFactory(this || _global, predicate, context, false));
          },
          zip: function zip() {
            var collections = [this || _global].concat(arrCopy(arguments));
            return reify(this || _global, zipWithFactory(this || _global, defaultZipper, collections));
          },
          zipAll: function zipAll() {
            var collections = [this || _global].concat(arrCopy(arguments));
            return reify(this || _global, zipWithFactory(this || _global, defaultZipper, collections, true));
          },
          zipWith: function zipWith(zipper) {
            var collections = arrCopy(arguments);
            collections[0] = this || _global;
            return reify(this || _global, zipWithFactory(this || _global, zipper, collections));
          }
        });
        var IndexedCollectionPrototype = IndexedCollection.prototype;
        IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
        IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
        mixin(SetCollection, {
          get: function get(value, notSetValue) {
            return this.has(value) ? value : notSetValue;
          },
          includes: function includes(value) {
            return this.has(value);
          },
          keySeq: function keySeq() {
            return this.valueSeq();
          }
        });
        SetCollection.prototype.has = CollectionPrototype.includes;
        SetCollection.prototype.contains = SetCollection.prototype.includes;
        mixin(KeyedSeq, KeyedCollection.prototype);
        mixin(IndexedSeq, IndexedCollection.prototype);
        mixin(SetSeq, SetCollection.prototype);
        function reduce(collection, reducer, reduction, context, useFirst, reverse) {
          assertNotInfinite(collection.size);
          collection.__iterate(function (v, k, c) {
            if (useFirst) {
              useFirst = false;
              reduction = v;
            } else {
              reduction = reducer.call(context, reduction, v, k, c);
            }
          }, reverse);
          return reduction;
        }
        function keyMapper(v, k) {
          return k;
        }
        function entryMapper(v, k) {
          return [
            k,
            v
          ];
        }
        function not(predicate) {
          return function () {
            return !predicate.apply(this || _global, arguments);
          };
        }
        function neg(predicate) {
          return function () {
            return -predicate.apply(this || _global, arguments);
          };
        }
        function defaultZipper() {
          return arrCopy(arguments);
        }
        function defaultNegComparator(a, b) {
          return a < b ? 1 : a > b ? -1 : 0;
        }
        function hashCollection(collection) {
          if (collection.size === Infinity) {
            return 0;
          }
          var ordered = isOrdered(collection);
          var keyed = isKeyed(collection);
          var h = ordered ? 1 : 0;
          var size = collection.__iterate(keyed ? ordered ? function (v, k) {
            h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
          } : function (v, k) {
            h = h + hashMerge(hash(v), hash(k)) | 0;
          } : ordered ? function (v) {
            h = 31 * h + hash(v) | 0;
          } : function (v) {
            h = h + hash(v) | 0;
          });
          return murmurHashOfSize(size, h);
        }
        function murmurHashOfSize(size, h) {
          h = imul(h, 3432918353);
          h = imul(h << 15 | h >>> -15, 461845907);
          h = imul(h << 13 | h >>> -13, 5);
          h = (h + 3864292196 | 0) ^ size;
          h = imul(h ^ h >>> 16, 2246822507);
          h = imul(h ^ h >>> 13, 3266489909);
          h = smi(h ^ h >>> 16);
          return h;
        }
        function hashMerge(a, b) {
          return a ^ b + 2654435769 + (a << 6) + (a >> 2) | 0;
        }
        var OrderedSet = function (Set$$1) {
          function OrderedSet(value) {
            return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {
              var iter = SetCollection(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v) {
                return set.add(v);
              });
            });
          }
          if (Set$$1)
            OrderedSet.__proto__ = Set$$1;
          OrderedSet.prototype = Object.create(Set$$1 && Set$$1.prototype);
          OrderedSet.prototype.constructor = OrderedSet;
          OrderedSet.of = function of() {
            return (this || _global)(arguments);
          };
          OrderedSet.fromKeys = function fromKeys(value) {
            return (this || _global)(KeyedCollection(value).keySeq());
          };
          OrderedSet.prototype.toString = function toString() {
            return this.__toString("OrderedSet {", "}");
          };
          return OrderedSet;
        }(Set);
        OrderedSet.isOrderedSet = isOrderedSet;
        var OrderedSetPrototype = OrderedSet.prototype;
        OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
        OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
        OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
        OrderedSetPrototype.__empty = emptyOrderedSet;
        OrderedSetPrototype.__make = makeOrderedSet;
        function makeOrderedSet(map, ownerID) {
          var set = Object.create(OrderedSetPrototype);
          set.size = map ? map.size : 0;
          set._map = map;
          set.__ownerID = ownerID;
          return set;
        }
        var EMPTY_ORDERED_SET;
        function emptyOrderedSet() {
          return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
        }
        var Record = function Record(defaultValues, name) {
          var hasInitialized;
          var RecordType = function Record(values) {
            var this$1$1 = this || _global;
            if (values instanceof RecordType) {
              return values;
            }
            if (!((this || _global) instanceof RecordType)) {
              return new RecordType(values);
            }
            if (!hasInitialized) {
              hasInitialized = true;
              var keys = Object.keys(defaultValues);
              var indices = RecordTypePrototype._indices = {};
              RecordTypePrototype._name = name;
              RecordTypePrototype._keys = keys;
              RecordTypePrototype._defaultValues = defaultValues;
              for (var i = 0; i < keys.length; i++) {
                var propName = keys[i];
                indices[propName] = i;
                if (RecordTypePrototype[propName]) {
                  typeof console === "object" && console.warn && console.warn("Cannot define " + recordName(this || _global) + " with property \"" + propName + "\" since that property name is part of the Record API.");
                } else {
                  setProp(RecordTypePrototype, propName);
                }
              }
            }
            (this || _global).__ownerID = undefined;
            (this || _global)._values = List().withMutations(function (l) {
              l.setSize(this$1$1._keys.length);
              KeyedCollection(values).forEach(function (v, k) {
                l.set(this$1$1._indices[k], v === this$1$1._defaultValues[k] ? undefined : v);
              });
            });
          };
          var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
          RecordTypePrototype.constructor = RecordType;
          if (name) {
            RecordType.displayName = name;
          }
          return RecordType;
        };
        Record.prototype.toString = function toString() {
          var str = recordName(this || _global) + " { ";
          var keys = (this || _global)._keys;
          var k;
          for (var i = 0, l = keys.length; i !== l; i++) {
            k = keys[i];
            str += (i ? ", " : "") + k + ": " + quoteString(this.get(k));
          }
          return str + " }";
        };
        Record.prototype.equals = function equals(other) {
          return (this || _global) === other || other && (this || _global)._keys === other._keys && recordSeq(this || _global).equals(recordSeq(other));
        };
        Record.prototype.hashCode = function hashCode() {
          return recordSeq(this || _global).hashCode();
        };
        Record.prototype.has = function has(k) {
          return (this || _global)._indices.hasOwnProperty(k);
        };
        Record.prototype.get = function get(k, notSetValue) {
          if (!this.has(k)) {
            return notSetValue;
          }
          var index = (this || _global)._indices[k];
          var value = (this || _global)._values.get(index);
          return value === undefined ? (this || _global)._defaultValues[k] : value;
        };
        Record.prototype.set = function set(k, v) {
          if (this.has(k)) {
            var newValues = (this || _global)._values.set((this || _global)._indices[k], v === (this || _global)._defaultValues[k] ? undefined : v);
            if (newValues !== (this || _global)._values && !(this || _global).__ownerID) {
              return makeRecord(this || _global, newValues);
            }
          }
          return this || _global;
        };
        Record.prototype.remove = function remove(k) {
          return this.set(k);
        };
        Record.prototype.clear = function clear() {
          var newValues = (this || _global)._values.clear().setSize((this || _global)._keys.length);
          return (this || _global).__ownerID ? this || _global : makeRecord(this || _global, newValues);
        };
        Record.prototype.wasAltered = function wasAltered() {
          return (this || _global)._values.wasAltered();
        };
        Record.prototype.toSeq = function toSeq() {
          return recordSeq(this || _global);
        };
        Record.prototype.toJS = function toJS$1() {
          return toJS(this || _global);
        };
        Record.prototype.entries = function entries() {
          return this.__iterator(ITERATE_ENTRIES);
        };
        Record.prototype.__iterator = function __iterator(type, reverse) {
          return recordSeq(this || _global).__iterator(type, reverse);
        };
        Record.prototype.__iterate = function __iterate(fn, reverse) {
          return recordSeq(this || _global).__iterate(fn, reverse);
        };
        Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
          if (ownerID === (this || _global).__ownerID) {
            return this || _global;
          }
          var newValues = (this || _global)._values.__ensureOwner(ownerID);
          if (!ownerID) {
            (this || _global).__ownerID = ownerID;
            (this || _global)._values = newValues;
            return this || _global;
          }
          return makeRecord(this || _global, newValues, ownerID);
        };
        Record.isRecord = isRecord;
        Record.getDescriptiveName = recordName;
        var RecordPrototype = Record.prototype;
        RecordPrototype[IS_RECORD_SYMBOL] = true;
        RecordPrototype[DELETE] = RecordPrototype.remove;
        RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
        RecordPrototype.getIn = getIn$1;
        RecordPrototype.hasIn = CollectionPrototype.hasIn;
        RecordPrototype.merge = merge;
        RecordPrototype.mergeWith = mergeWith;
        RecordPrototype.mergeIn = mergeIn;
        RecordPrototype.mergeDeep = mergeDeep$1;
        RecordPrototype.mergeDeepWith = mergeDeepWith$1;
        RecordPrototype.mergeDeepIn = mergeDeepIn;
        RecordPrototype.setIn = setIn$1;
        RecordPrototype.update = update$1;
        RecordPrototype.updateIn = updateIn$1;
        RecordPrototype.withMutations = withMutations;
        RecordPrototype.asMutable = asMutable;
        RecordPrototype.asImmutable = asImmutable;
        RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
        RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
        RecordPrototype.inspect = RecordPrototype.toSource = function () {
          return this.toString();
        };
        function makeRecord(likeRecord, values, ownerID) {
          var record = Object.create(Object.getPrototypeOf(likeRecord));
          record._values = values;
          record.__ownerID = ownerID;
          return record;
        }
        function recordName(record) {
          return record.constructor.displayName || record.constructor.name || "Record";
        }
        function recordSeq(record) {
          return keyedSeqFromValue(record._keys.map(function (k) {
            return [
              k,
              record.get(k)
            ];
          }));
        }
        function setProp(prototype, name) {
          try {
            Object.defineProperty(prototype, name, {
              get: function () {
                return this.get(name);
              },
              set: function (value) {
                invariant((this || _global).__ownerID, "Cannot set on an immutable record.");
                this.set(name, value);
              }
            });
          } catch (error) {
          }
        }
        var Repeat = function (IndexedSeq$$1) {
          function Repeat(value, times) {
            if (!((this || _global) instanceof Repeat)) {
              return new Repeat(value, times);
            }
            (this || _global)._value = value;
            (this || _global).size = times === undefined ? Infinity : Math.max(0, times);
            if ((this || _global).size === 0) {
              if (EMPTY_REPEAT) {
                return EMPTY_REPEAT;
              }
              EMPTY_REPEAT = this || _global;
            }
          }
          if (IndexedSeq$$1)
            Repeat.__proto__ = IndexedSeq$$1;
          Repeat.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
          Repeat.prototype.constructor = Repeat;
          Repeat.prototype.toString = function toString() {
            if ((this || _global).size === 0) {
              return "Repeat []";
            }
            return "Repeat [ " + (this || _global)._value + " " + (this || _global).size + " times ]";
          };
          Repeat.prototype.get = function get(index, notSetValue) {
            return this.has(index) ? (this || _global)._value : notSetValue;
          };
          Repeat.prototype.includes = function includes(searchValue) {
            return is((this || _global)._value, searchValue);
          };
          Repeat.prototype.slice = function slice(begin, end) {
            var size = (this || _global).size;
            return wholeSlice(begin, end, size) ? this || _global : new Repeat((this || _global)._value, resolveEnd(end, size) - resolveBegin(begin, size));
          };
          Repeat.prototype.reverse = function reverse() {
            return this || _global;
          };
          Repeat.prototype.indexOf = function indexOf(searchValue) {
            if (is((this || _global)._value, searchValue)) {
              return 0;
            }
            return -1;
          };
          Repeat.prototype.lastIndexOf = function lastIndexOf(searchValue) {
            if (is((this || _global)._value, searchValue)) {
              return (this || _global).size;
            }
            return -1;
          };
          Repeat.prototype.__iterate = function __iterate(fn, reverse) {
            var size = (this || _global).size;
            var i = 0;
            while (i !== size) {
              if (fn((this || _global)._value, reverse ? size - ++i : i++, this || _global) === false) {
                break;
              }
            }
            return i;
          };
          Repeat.prototype.__iterator = function __iterator(type, reverse) {
            var this$1$1 = this || _global;
            var size = (this || _global).size;
            var i = 0;
            return new Iterator(function () {
              return i === size ? iteratorDone() : iteratorValue(type, reverse ? size - ++i : i++, this$1$1._value);
            });
          };
          Repeat.prototype.equals = function equals(other) {
            return other instanceof Repeat ? is((this || _global)._value, other._value) : deepEqual(other);
          };
          return Repeat;
        }(IndexedSeq);
        var EMPTY_REPEAT;
        function fromJS(value, converter) {
          return fromJSWith([], converter || defaultConverter, value, "", converter && converter.length > 2 ? [] : undefined, { "": value });
        }
        function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
          var toSeq = Array.isArray(value) ? IndexedSeq : isPlainObj(value) ? KeyedSeq : null;
          if (toSeq) {
            if (~stack.indexOf(value)) {
              throw new TypeError("Cannot convert circular structure to Immutable");
            }
            stack.push(value);
            keyPath && key !== "" && keyPath.push(key);
            var converted = converter.call(parentValue, key, toSeq(value).map(function (v, k) {
              return fromJSWith(stack, converter, v, k, keyPath, value);
            }), keyPath && keyPath.slice());
            stack.pop();
            keyPath && keyPath.pop();
            return converted;
          }
          return value;
        }
        function defaultConverter(k, v) {
          return isKeyed(v) ? v.toMap() : v.toList();
        }
        var version = "4.0.0-rc.11";
        var Immutable = {
          version: version,
          Collection: Collection,
          Iterable: Collection,
          Seq: Seq,
          Map: Map,
          OrderedMap: OrderedMap,
          List: List,
          Stack: Stack,
          Set: Set,
          OrderedSet: OrderedSet,
          Record: Record,
          Range: Range,
          Repeat: Repeat,
          is: is,
          fromJS: fromJS,
          hash: hash,
          isImmutable: isImmutable,
          isCollection: isCollection,
          isKeyed: isKeyed,
          isIndexed: isIndexed,
          isAssociative: isAssociative,
          isOrdered: isOrdered,
          isValueObject: isValueObject,
          isSeq: isSeq,
          isList: isList,
          isMap: isMap,
          isOrderedMap: isOrderedMap,
          isStack: isStack,
          isSet: isSet,
          isOrderedSet: isOrderedSet,
          isRecord: isRecord,
          get: get,
          getIn: getIn,
          has: has,
          hasIn: hasIn,
          merge: merge$1,
          mergeDeep: mergeDeep,
          mergeWith: mergeWith$1,
          mergeDeepWith: mergeDeepWith,
          remove: remove,
          removeIn: removeIn,
          set: set,
          setIn: setIn,
          update: update,
          updateIn: updateIn
        };
        var Iterable = Collection;
        exports.default = Immutable;
        exports.version = version;
        exports.Collection = Collection;
        exports.Iterable = Iterable;
        exports.Seq = Seq;
        exports.Map = Map;
        exports.OrderedMap = OrderedMap;
        exports.List = List;
        exports.Stack = Stack;
        exports.Set = Set;
        exports.OrderedSet = OrderedSet;
        exports.Record = Record;
        exports.Range = Range;
        exports.Repeat = Repeat;
        exports.is = is;
        exports.fromJS = fromJS;
        exports.hash = hash;
        exports.isImmutable = isImmutable;
        exports.isCollection = isCollection;
        exports.isKeyed = isKeyed;
        exports.isIndexed = isIndexed;
        exports.isAssociative = isAssociative;
        exports.isOrdered = isOrdered;
        exports.isValueObject = isValueObject;
        exports.get = get;
        exports.getIn = getIn;
        exports.has = has;
        exports.hasIn = hasIn;
        exports.merge = merge$1;
        exports.mergeDeep = mergeDeep;
        exports.mergeWith = mergeWith$1;
        exports.mergeDeepWith = mergeDeepWith;
        exports.remove = remove;
        exports.removeIn = removeIn;
        exports.set = set;
        exports.setIn = setIn;
        exports.update = update;
        exports.updateIn = updateIn;
        Object.defineProperty(exports, "__esModule", { value: true });
      }));
      exports$1.version; exports$1.Collection; exports$1.Iterable; exports$1.Seq; exports$1.OrderedMap; exports$1.List; exports$1.Stack; exports$1.OrderedSet; exports$1.Record; exports$1.Range; exports$1.Repeat; exports$1.is; exports$1.fromJS; exports$1.hash; exports$1.isImmutable; exports$1.isCollection; exports$1.isKeyed; exports$1.isIndexed; exports$1.isAssociative; exports$1.isOrdered; exports$1.isValueObject; exports$1.get; exports$1.getIn; exports$1.has; exports$1.hasIn; exports$1.merge; exports$1.mergeDeep; exports$1.mergeWith; exports$1.mergeDeepWith; exports$1.remove; exports$1.removeIn; exports$1.set; exports$1.setIn; exports$1.update; exports$1.updateIn; exports$1.__esModule;
      exports$1.Map; exports$1.Set;

      var __varRecorder__$p = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/view-creator.cp.js", __contextModule__);
      var ViewBuilderModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/view-creator.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ViewBuilderModel") && typeof __lively_classholder__.ViewBuilderModel === "function" ? __lively_classholder__.ViewBuilderModel : __lively_classholder__.ViewBuilderModel = function ViewBuilderModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "init",
          value: function ViewBuilderModel_init_(viewName, dashboard) {
            var _this = this;

            var aView = dashboard.views[viewName];
            this.table = aView.tableName;
            this.dashboard = dashboard;
            this.viewName = viewName;
            this.ui.windowTitle.textString = viewName;
            var allColumns = this.dashboard.dataManager.getColumnsOfTypes([], this.table);
            this.initColumnChooser(allColumns, aView.columns);
            var filterNames = this.dashboard.filterNames;
            filterNames = filterNames.filter(function (filterName) {
              var filterColumn = _this.dashboard.filters[filterName].morph.columnName;
              return allColumns.indexOf(filterColumn) >= 0;
            });
            var chartNames = this.dashboard.chartNames;
            chartNames = chartNames.filter(function (chartName) {
              var chartColumn = _this.dashboard.charts[chartName].filter.column;
              return allColumns.indexOf(chartColumn) >= 0;
            });
            filterNames = filterNames.concat(chartNames);
            this.initViewFilterChooser(filterNames, aView.filterNames);
          }
        }, {
          key: "initColumnChooser",
          value: function ViewBuilderModel_initColumnChooser_(allColumns) {
            var _this2 = this;

            var selectedColumns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            var wrappedColumns = sortBy(allColumns, function (c) {
              var i = selectedColumns.indexOf(c);
              if (i === -1) return Infinity;else return i;
            }).map(function (c) {
              return SelectableEntryModel.wrap(c, {
                entryList: _this2.ui.columnList,
                isSelected: selectedColumns.includes(c)
              });
            });
            this.ui.columnList.items = wrappedColumns;
          }
        }, {
          key: "selectedColumns",
          get: function get() {
            return this.ui.columnList.items.filter(function (entry) {
              return entry.morph.isSelected;
            }).map(function (entry) {
              return entry.morph.entryName;
            });
          }
        }, {
          key: "initViewFilterChooser",
          value: function ViewBuilderModel_initViewFilterChooser_(allFilterNames) {
            var _this3 = this;

            var selectedFilterNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            this.ui.widgetList.items = allFilterNames.map(function (filterName) {
              return SelectableEntryModel.wrap(filterName, {
                isSelected: selectedFilterNames.includes(filterName),
                entryList: _this3.ui.widgetList
              });
            });
          }
        }, {
          key: "selectedFilters",
          get: function get() {
            return this.ui.widgetList.items.filter(function (item) {
              return item.morph.isSelected;
            }).map(function (item) {
              return item.morph.entryName;
            });
          }
        }, {
          key: "viewSpec",
          get: function get() {
            return {
              table: this.table,
              columns: this.selectedColumns,
              filterNames: this.selectedFilters
            };
          }
        }, {
          key: "closeViewBuilder",
          value: function ViewBuilderModel_closeViewBuilder_() {
            delete this.dashboard.viewBuilders[this.viewName];
            this.view.remove();
          }
        }, {
          key: "updateView",
          value: function ViewBuilderModel_updateView_() {
            this.dashboard.addView(this.viewName, this.viewSpec);
            this.dashboard.dirty = true;
            this.view.remove();
          }
        }, {
          key: "selectAllColumns",
          value: function ViewBuilderModel_selectAllColumns_() {
            this.ui.columnList.selectAll();
          }
        }, {
          key: "selectAllWidgets",
          value: function ViewBuilderModel_selectAllWidgets_() {
            this.ui.widgetList.selectAll();
          }
        }, {
          key: "orderColumns",
          value: function ViewBuilderModel_orderColumns_() {
            this.ui.columnList.toggleOrderMode();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ViewBuilderModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["init"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "fire",
                    handler: "closeViewBuilder"
                  }, {
                    target: "update button",
                    signal: "fire",
                    handler: "updateView"
                  }, {
                    target: "select all columns button",
                    signal: "fire",
                    handler: "selectAllColumns"
                  }, {
                    target: "select all widgets button",
                    signal: "fire",
                    handler: "selectAllWidgets"
                  }, {
                    target: "edit columns button",
                    signal: "fire",
                    handler: "orderColumns"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/view-creator.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 1442,
          end: 7657
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$p.ViewBuilderModel = ViewBuilderModel;
      __varRecorder__$p.ViewBuilderModel = ViewBuilderModel;
      __varRecorder__$p.ViewBuilder = component["for"](function () {
        return component(GalyleoWindow, {
          name: "view builder",
          defaultViewModel: __varRecorder__$p.ViewBuilderModel,
          layout: new TilingLayout({
            axis: "column",
            orderByIndex: true,
            resizePolicies: [["window title", {
              height: "fixed",
              width: "fill"
            }], ["contents wrapper", {
              height: "fill",
              width: "fill"
            }]],
            wrapSubmorphs: false
          }),
          extent: pt(409.8, 543.3),
          submorphs: [{
            name: "window title",
            textString: "[View name]"
          }, add({
            name: "contents wrapper",
            borderColor: Color$1.rgb(127, 140, 141),
            borderRadius: 10,
            extent: pt(435.8, 513),
            fill: Color$1.rgba(215, 219, 221, 0),
            layout: new TilingLayout({
              axis: "column",
              axisAlign: "center",
              orderByIndex: true,
              padding: rect(20, 20, 4, 0),
              resizePolicies: [["header", {
                height: "fixed",
                width: "fill"
              }], ["column header", {
                height: "fixed",
                width: "fill"
              }], ["column list", {
                height: "fill",
                width: "fill"
              }], ["widget header", {
                height: "fixed",
                width: "fill"
              }], ["widget list", {
                height: "fill",
                width: "fill"
              }], ["footer", {
                height: "fixed",
                width: "fill"
              }]],
              spacing: 13,
              wrapSubmorphs: false
            }),
            submorphs: [{
              name: "header",
              extent: pt(384, 10),
              fill: Color$1.rgba(0, 0, 0, 0),
              layout: new TilingLayout({
                align: "right",
                orderByIndex: true,
                wrapSubmorphs: false
              }),
              submorphs: [part(MenuBarButton, {
                tooltip: "Close this dialog without loading",
                name: "close button",
                extent: pt(90, 35),
                submorphs: [{
                  name: "label",
                  textAndAttributes: ["CLOSE", null]
                }, {
                  name: "icon",
                  extent: pt(14, 14),
                  imageUrl: projectAsset("engageLively--galyleo-dashboard__close-button-icon-2.svg")
                }]
              })]
            }, {
              name: "column header",
              layout: new TilingLayout({
                align: "center",
                axisAlign: "center",
                justifySubmorphs: "spaced",
                orderByIndex: true,
                resizePolicies: [["buffer", {
                  height: "fixed",
                  width: "fill"
                }]],
                spacing: 3,
                wrapSubmorphs: false
              }),
              fill: Color$1.transparent,
              submorphs: [{
                type: Label,
                name: "columns label",
                fontColor: Color$1.rgb(89, 89, 89),
                fontSize: 15,
                fontWeight: 700,
                textAndAttributes: ["Column selector", null]
              }, {
                name: "buffer",
                borderColor: Color$1.rgb(23, 160, 251),
                borderWidth: 0,
                extent: pt(146, 26.7),
                fill: Color$1.rgba(0, 0, 0, 0)
              }, part(MenuBarButton, {
                name: "select all columns button",
                extent: pt(77.1, 22.9),
                submorphs: [{
                  name: "label",
                  textAndAttributes: ["select all", null]
                }, without("icon")]
              }), part(MenuBarButton, {
                name: "edit columns button",
                extent: pt(27.9, 25.6),
                submorphs: [without("label"), {
                  name: "icon",
                  imageUrl: projectAsset("engageLively--galyleo-dashboard__edit-icon.svg")
                }]
              })]
            }, part(GalyleoList, {
              name: "column list",
              submorphs: [{
                name: "item list",
                extent: pt(386, 163),
                clipMode: "hidden"
              }, {
                name: "scroll bar",
                extent: pt(4.6, 125.7),
                position: pt(353.4, 10.1)
              }]
            }), {
              name: "widget header",
              layout: new TilingLayout({
                align: "center",
                axisAlign: "center",
                justifySubmorphs: "spaced",
                orderByIndex: true,
                wrapSubmorphs: false
              }),
              fill: Color$1.transparent,
              submorphs: [{
                type: Label,
                name: "widget label",
                fontColor: Color$1.rgb(89, 89, 89),
                fontSize: 15,
                fontWeight: 700,
                textAndAttributes: ["Widget selector", null]
              }, part(MenuBarButton, {
                name: "select all widgets button",
                extent: pt(77.1, 22.9),
                submorphs: [{
                  name: "label",
                  textAndAttributes: ["select all", null]
                }, without("icon")]
              })]
            }, part(GalyleoList, {
              name: "widget list",
              submorphs: [{
                name: "item list",
                extent: pt(386, 163),
                clipMode: "hidden"
              }, {
                name: "scroll bar",
                extent: pt(4.6, 125.7),
                position: pt(353.4, 10.1)
              }]
            }), {
              name: "footer",
              extent: pt(384, 10),
              fill: Color$1.rgba(0, 0, 0, 0),
              layout: new TilingLayout({
                align: "right",
                orderByIndex: true,
                wrapSubmorphs: false
              }),
              submorphs: [part(PromptButton, {
                name: "update button",
                extent: pt(139.2, 33.2),
                layout: new TilingLayout({
                  axis: "row",
                  axisAlign: "center",
                  align: "center"
                }),
                submorphs: [{
                  type: Label,
                  name: "label",
                  textAndAttributes: ["Update view", null]
                }, without("icon")]
              })]
            }]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/view-creator.cp.js",
        "export": "ViewBuilder",
        range: {
          start: 7698,
          end: 13167
        }
      }, System, __varRecorder__$p, "ViewBuilder");
      var ViewCreatorPromptModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/view-creator.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ViewCreatorPromptModel") && typeof __lively_classholder__.ViewCreatorPromptModel === "function" ? __lively_classholder__.ViewCreatorPromptModel : __lively_classholder__.ViewCreatorPromptModel = function ViewCreatorPromptModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "init",
          value: function ViewCreatorPromptModel_init_(dashboard) {
            this.models.viewCreator.init(dashboard);
          }
        }, {
          key: "close",
          value: function ViewCreatorPromptModel_close_() {
            this.view.remove();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ViewCreatorPromptModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["init", "close"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "fire",
                    handler: "close"
                  }, {
                    target: "view creator",
                    signal: "viewCreated",
                    handler: "close"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/view-creator.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 13177,
          end: 13720
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$p.ViewCreatorPromptModel = ViewCreatorPromptModel;
      __varRecorder__$p.ViewCreatorPromptModel = ViewCreatorPromptModel;
      var ViewCreatorModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/view-creator.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ViewCreatorModel") && typeof __lively_classholder__.ViewCreatorModel === "function" ? __lively_classholder__.ViewCreatorModel : __lively_classholder__.ViewCreatorModel = function ViewCreatorModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "init",
          value: function ViewCreatorModel_init_(dashboard) {
            var _this$ui = this.ui,
                viewNameInput = _this$ui.viewNameInput,
                tableSelector = _this$ui.tableSelector;
            this.dashboard = dashboard;
            viewNameInput.input = "";
            tableSelector.items = _toConsumableArray(dashboard.tableNames);
            tableSelector.selection = "__no_selection__";
          }
        }, {
          key: "_nameOK",
          value: function ViewCreatorModel__nameOK_() {
            var viewNameInput = this.ui.viewNameInput;
            var input = viewNameInput.textString;

            if (input.length === 0) {
              return false;
            }

            var allNames = this.dashboard.tableNames.concat(this.dashboard.viewNames);
            return allNames.indexOf(input) < 0;
          }
        }, {
          key: "_tableOK",
          value: function ViewCreatorModel__tableOK_() {
            return this.ui.tableSelector.selection !== "__no_selection__";
          }
        }, {
          key: "createView",
          value: function ViewCreatorModel_createView_() {
            var _this$ui2 = this.ui,
                viewNameInput = _this$ui2.viewNameInput,
                tableSelector = _this$ui2.tableSelector;

            if (this._nameOK() && this._tableOK()) {
              var name = viewNameInput.textString;
              var table = tableSelector.selection;
              this.dashboard.addView(name, {
                table: table
              });
              this.dashboard.createViewEditor(name);
              this.init(this.dashboard);
              signal(this, "viewCreated");
            } else {
              if (!this._nameOK()) {
                viewNameInput.indicateError("Please enter a name");
              }
            }
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ViewCreatorModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              viewCreated: {
                derived: true,
                isSignal: true,
                readOnly: true
              },
              expose: {
                get: function get() {
                  return "viewCreated";
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "create view button",
                    signal: "fire",
                    handler: "createView"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/view-creator.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 13732,
          end: 15229
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$p.ViewCreatorModel = ViewCreatorModel;
      __varRecorder__$p.ViewCreatorModel = ViewCreatorModel;
      __varRecorder__$p.ViewCreator = component["for"](function () {
        return component({
          name: "view creator",
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "right",
            orderByIndex: true,
            padding: rect(10, 10, 0, 0),
            resizePolicies: [["header", {
              height: "fixed",
              width: "fill"
            }], ["view name input", {
              height: "fixed",
              width: "fill"
            }], ["table selector", {
              height: "fixed",
              width: "fill"
            }]],
            spacing: 10,
            wrapSubmorphs: false
          }),
          extent: pt(397.9, 182.2),
          fill: Color$1.rgba(255, 255, 255, 0),
          defaultViewModel: __varRecorder__$p.ViewCreatorModel,
          submorphs: [{
            name: "header",
            extent: pt(384, 10),
            fill: Color$1.rgba(0, 0, 0, 0),
            layout: new TilingLayout({
              align: "right",
              orderByIndex: true,
              wrapSubmorphs: false
            }),
            submorphs: [part(MenuBarButton, {
              tooltip: "Close this dialog without loading",
              name: "close button",
              extent: pt(100, 35),
              submorphs: [{
                name: "label",
                textAndAttributes: ["CLOSE", null]
              }, {
                name: "icon",
                extent: pt(14, 14),
                imageUrl: projectAsset("engageLively--galyleo-dashboard__close-button-icon-2.svg")
              }]
            })]
          }, part(GalyleoSearch, {
            name: "view name input",
            placeholder: "View name",
            submorphs: [{
              name: "placeholder",
              extent: pt(91, 28.8),
              textAndAttributes: ["View name", null]
            }]
          }), part(GalyleoDropDown, {
            name: "table selector",
            viewModel: {
              placeholder: "Select table...",
              openListInWorld: true
            }
          }), part(PromptButton, {
            name: "create view button",
            extent: pt(116.2, 30.5),
            submorphs: [{
              name: "label",
              textAndAttributes: ["Create view", null]
            }, without("icon")]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/view-creator.cp.js",
        "export": "ViewCreator",
        range: {
          start: 15269,
          end: 17079
        }
      }, System, __varRecorder__$p, "ViewCreator");
      __varRecorder__$p.ViewCreatorPrompt = component["for"](function () {
        return component(GalyleoWindow, {
          name: "view creator/prompt",
          layout: new TilingLayout({
            axis: "column",
            orderByIndex: true,
            resizePolicies: [["window title", {
              height: "fixed",
              width: "fill"
            }], ["view creator", {
              height: "fixed",
              width: "fill"
            }]],
            hugContentsVertically: true,
            wrapSubmorphs: false
          }),
          defaultViewModel: __varRecorder__$p.ViewCreatorPromptModel,
          submorphs: [{
            name: "window title",
            textString: "View builder"
          }, add(part(__varRecorder__$p.ViewCreator, {
            name: "view creator"
          }))]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/view-creator.cp.js",
        "export": "ViewCreatorPrompt",
        range: {
          start: 17122,
          end: 17675
        }
      }, System, __varRecorder__$p, "ViewCreatorPrompt");
      var ViewBuilder = __varRecorder__$p.ViewBuilder;
      var ViewCreatorPrompt = __varRecorder__$p.ViewCreatorPrompt;
      var ViewCreator = __varRecorder__$p.ViewCreator;
      __varRecorder__$p.ViewBuilder = ViewBuilder;
      __varRecorder__$p.ViewCreatorPrompt = ViewCreatorPrompt;
      __varRecorder__$p.ViewCreator = ViewCreator;

      function noop() {}

      var uid = function () {
        var id = 0;
        return function () {
          return id++;
        };
      }();

      function isNullOrUndef(value) {
        return value === null || typeof value === "undefined";
      }

      function isArray(value) {
        if (Array.isArray && Array.isArray(value)) {
          return true;
        }

        var type = Object.prototype.toString.call(value);

        if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
          return true;
        }

        return false;
      }

      function isObject(value) {
        return value !== null && Object.prototype.toString.call(value) === "[object Object]";
      }

      var isNumberFinite = function isNumberFinite(value) {
        return (typeof value === "number" || value instanceof Number) && isFinite(+value);
      };

      function finiteOrDefault(value, defaultValue) {
        return isNumberFinite(value) ? value : defaultValue;
      }

      function valueOrDefault(value, defaultValue) {
        return typeof value === "undefined" ? defaultValue : value;
      }

      var toPercentage = function toPercentage(value, dimension) {
        return typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
      };

      var toDimension = function toDimension(value, dimension) {
        return typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
      };

      function callback(fn, args, thisArg) {
        if (fn && typeof fn.call === "function") {
          return fn.apply(thisArg, args);
        }
      }

      function each(loopable, fn, thisArg, reverse) {
        var i, len, keys;

        if (isArray(loopable)) {
          len = loopable.length;

          if (reverse) {
            for (i = len - 1; i >= 0; i--) {
              fn.call(thisArg, loopable[i], i);
            }
          } else {
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[i], i);
            }
          }
        } else if (isObject(loopable)) {
          keys = Object.keys(loopable);
          len = keys.length;

          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[keys[i]], keys[i]);
          }
        }
      }

      function _elementsEqual(a0, a1) {
        var i, ilen, v0, v1;

        if (!a0 || !a1 || a0.length !== a1.length) {
          return false;
        }

        for (i = 0, ilen = a0.length; i < ilen; ++i) {
          v0 = a0[i];
          v1 = a1[i];

          if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
            return false;
          }
        }

        return true;
      }

      function clone$1(source) {
        if (isArray(source)) {
          return source.map(clone$1);
        }

        if (isObject(source)) {
          var target = Object.create(null);
          var keys = Object.keys(source);
          var klen = keys.length;
          var k = 0;

          for (; k < klen; ++k) {
            target[keys[k]] = clone$1(source[keys[k]]);
          }

          return target;
        }

        return source;
      }

      function isValidKey(key) {
        return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
      }

      function _merger(key, target, source, options) {
        if (!isValidKey(key)) {
          return;
        }

        var tval = target[key];
        var sval = source[key];

        if (isObject(tval) && isObject(sval)) {
          merge(tval, sval, options);
        } else {
          target[key] = clone$1(sval);
        }
      }

      function merge(target, source, options) {
        var sources = isArray(source) ? source : [source];
        var ilen = sources.length;

        if (!isObject(target)) {
          return target;
        }

        options = options || {};
        var merger = options.merger || _merger;

        for (var i = 0; i < ilen; ++i) {
          source = sources[i];

          if (!isObject(source)) {
            continue;
          }

          var keys = Object.keys(source);

          for (var k = 0, klen = keys.length; k < klen; ++k) {
            merger(keys[k], target, source, options);
          }
        }

        return target;
      }

      function mergeIf(target, source) {
        return merge(target, source, {
          merger: _mergerIf
        });
      }

      function _mergerIf(key, target, source) {
        if (!isValidKey(key)) {
          return;
        }

        var tval = target[key];
        var sval = source[key];

        if (isObject(tval) && isObject(sval)) {
          mergeIf(tval, sval);
        } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
          target[key] = clone$1(sval);
        }
      }

      var keyResolvers = {
        "": function _(v) {
          return v;
        },
        x: function x(o) {
          return o.x;
        },
        y: function y(o) {
          return o.y;
        }
      };

      function resolveObjectKey(obj, key) {
        var resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));

        return resolver(obj);
      }

      function _getKeyResolver(key) {
        var keys = _splitKey(key);

        return function (obj) {
          var _iterator = _createForOfIteratorHelper(keys),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var k = _step.value;

              if (k === "") {
                break;
              }

              obj = obj && obj[k];
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          return obj;
        };
      }

      function _splitKey(key) {
        var parts = key.split(".");
        var keys = [];
        var tmp = "";

        var _iterator2 = _createForOfIteratorHelper(parts),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var part = _step2.value;
            tmp += part;

            if (tmp.endsWith("\\")) {
              tmp = tmp.slice(0, -1) + ".";
            } else {
              keys.push(tmp);
              tmp = "";
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return keys;
      }

      function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }

      var defined = function defined(value) {
        return typeof value !== "undefined";
      };

      var isFunction = function isFunction(value) {
        return typeof value === "function";
      };

      var setsEqual = function setsEqual(a, b) {
        if (a.size !== b.size) {
          return false;
        }

        var _iterator3 = _createForOfIteratorHelper(a),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var item = _step3.value;

            if (!b.has(item)) {
              return false;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return true;
      };

      function _isClickEvent(e) {
        return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
      }

      var PI = Math.PI;
      var TAU = 2 * PI;
      var PITAU = TAU + PI;
      var INFINITY = Number.POSITIVE_INFINITY;
      var RAD_PER_DEG = PI / 180;
      var HALF_PI = PI / 2;
      var QUARTER_PI = PI / 4;
      var TWO_THIRDS_PI = PI * 2 / 3;
      var log10 = Math.log10;
      var sign = Math.sign;

      function niceNum(range) {
        var roundedRange = Math.round(range);
        range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
        var niceRange = Math.pow(10, Math.floor(log10(range)));
        var fraction = range / niceRange;
        var niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
        return niceFraction * niceRange;
      }

      function _factorize(value) {
        var result = [];
        var sqrt = Math.sqrt(value);
        var i;

        for (i = 1; i < sqrt; i++) {
          if (value % i === 0) {
            result.push(i);
            result.push(value / i);
          }
        }

        if (sqrt === (sqrt | 0)) {
          result.push(sqrt);
        }

        result.sort(function (a, b) {
          return a - b;
        }).pop();
        return result;
      }

      function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      }

      function almostEquals(x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
      }

      function almostWhole(x, epsilon) {
        var rounded = Math.round(x);
        return rounded - epsilon <= x && rounded + epsilon >= x;
      }

      function _setMinAndMaxByKey(array, target, property) {
        var i, ilen, value;

        for (i = 0, ilen = array.length; i < ilen; i++) {
          value = array[i][property];

          if (!isNaN(value)) {
            target.min = Math.min(target.min, value);
            target.max = Math.max(target.max, value);
          }
        }
      }

      function toRadians(degrees) {
        return degrees * (PI / 180);
      }

      function toDegrees(radians) {
        return radians * (180 / PI);
      }

      function _decimalPlaces(x) {
        if (!isNumberFinite(x)) {
          return;
        }

        var e = 1;
        var p = 0;

        while (Math.round(x * e) / e !== x) {
          e *= 10;
          p++;
        }

        return p;
      }

      function getAngleFromPoint(centrePoint, anglePoint) {
        var distanceFromXCenter = anglePoint.x - centrePoint.x;
        var distanceFromYCenter = anglePoint.y - centrePoint.y;
        var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
        var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

        if (angle < -0.5 * PI) {
          angle += TAU;
        }

        return {
          angle: angle,
          distance: radialDistanceFromCenter
        };
      }

      function distanceBetweenPoints(pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
      }

      function _angleDiff(a, b) {
        return (a - b + PITAU) % TAU - PI;
      }

      function _normalizeAngle(a) {
        return (a % TAU + TAU) % TAU;
      }

      function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
        var a = _normalizeAngle(angle);

        var s = _normalizeAngle(start);

        var e = _normalizeAngle(end);

        var angleToStart = _normalizeAngle(s - a);

        var angleToEnd = _normalizeAngle(e - a);

        var startToAngle = _normalizeAngle(a - s);

        var endToAngle = _normalizeAngle(a - e);

        return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
      }

      function _limitValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function _int16Range(value) {
        return _limitValue(value, -32768, 32767);
      }

      function _isBetween(value, start, end) {
        var epsilon = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.000001;
        return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
      }

      function _lookup(table, value, cmp) {
        cmp = cmp || function (index) {
          return table[index] < value;
        };

        var hi = table.length - 1;
        var lo = 0;
        var mid;

        while (hi - lo > 1) {
          mid = lo + hi >> 1;

          if (cmp(mid)) {
            lo = mid;
          } else {
            hi = mid;
          }
        }

        return {
          lo: lo,
          hi: hi
        };
      }

      var _lookupByKey = function _lookupByKey(table, key, value, last) {
        return _lookup(table, value, last ? function (index) {
          return table[index][key] <= value;
        } : function (index) {
          return table[index][key] < value;
        });
      };

      var _rlookupByKey = function _rlookupByKey(table, key, value) {
        return _lookup(table, value, function (index) {
          return table[index][key] >= value;
        });
      };

      function _filterBetween(values, min, max) {
        var start = 0;
        var end = values.length;

        while (start < end && values[start] < min) {
          start++;
        }

        while (end > start && values[end - 1] > max) {
          end--;
        }

        return start > 0 || end < values.length ? values.slice(start, end) : values;
      }

      var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];

      function listenArrayEvents(array, listener) {
        if (array._chartjs) {
          array._chartjs.listeners.push(listener);

          return;
        }

        Object.defineProperty(array, "_chartjs", {
          configurable: true,
          enumerable: false,
          value: {
            listeners: [listener]
          }
        });
        arrayEvents.forEach(function (key) {
          var method = "_onData" + _capitalize(key);

          var base = array[key];
          Object.defineProperty(array, key, {
            configurable: true,
            enumerable: false,
            value: function value() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              var res = base.apply(this, args);

              array._chartjs.listeners.forEach(function (object) {
                if (typeof object[method] === "function") {
                  object[method].apply(object, args);
                }
              });

              return res;
            }
          });
        });
      }

      function unlistenArrayEvents(array, listener) {
        var stub = array._chartjs;

        if (!stub) {
          return;
        }

        var listeners = stub.listeners;
        var index = listeners.indexOf(listener);

        if (index !== -1) {
          listeners.splice(index, 1);
        }

        if (listeners.length > 0) {
          return;
        }

        arrayEvents.forEach(function (key) {
          delete array[key];
        });
        delete array._chartjs;
      }

      function _arrayUnique(items) {
        var set = new Set();
        var i, ilen;

        for (i = 0, ilen = items.length; i < ilen; ++i) {
          set.add(items[i]);
        }

        if (set.size === ilen) {
          return items;
        }

        return Array.from(set);
      }

      var requestAnimFrame = function () {
        if (typeof window === "undefined") {
          return function (callback) {
            return callback();
          };
        }

        return window.requestAnimationFrame;
      }();

      function throttled(fn, thisArg, updateFn) {
        var updateArgs = updateFn || function (args) {
          return Array.prototype.slice.call(args);
        };

        var ticking = false;
        var args = [];
        return function () {
          for (var _len2 = arguments.length, rest = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            rest[_key2] = arguments[_key2];
          }

          args = updateArgs(rest);

          if (!ticking) {
            ticking = true;
            requestAnimFrame.call(window, function () {
              ticking = false;
              fn.apply(thisArg, args);
            });
          }
        };
      }

      function debounce(fn, delay) {
        var timeout;
        return function () {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          if (delay) {
            clearTimeout(timeout);
            timeout = setTimeout(fn, delay, args);
          } else {
            fn.apply(this, args);
          }

          return delay;
        };
      }

      var _toLeftRightCenter = function _toLeftRightCenter(align) {
        return align === "start" ? "left" : align === "end" ? "right" : "center";
      };

      var _alignStartEnd = function _alignStartEnd(align, start, end) {
        return align === "start" ? start : align === "end" ? end : (start + end) / 2;
      };

      var _textX = function _textX(align, left, right, rtl) {
        var check = rtl ? "left" : "right";
        return align === check ? right : align === "center" ? (left + right) / 2 : left;
      };

      function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
        var pointCount = points.length;
        var start = 0;
        var count = pointCount;

        if (meta._sorted) {
          var iScale = meta.iScale,
              _parsed = meta._parsed;
          var axis = iScale.axis;

          var _iScale$getUserBounds = iScale.getUserBounds(),
              min = _iScale$getUserBounds.min,
              max = _iScale$getUserBounds.max,
              minDefined = _iScale$getUserBounds.minDefined,
              maxDefined = _iScale$getUserBounds.maxDefined;

          if (minDefined) {
            start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
          }

          if (maxDefined) {
            count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;
          } else {
            count = pointCount - start;
          }
        }

        return {
          start: start,
          count: count
        };
      }

      function _scaleRangesChanged(meta) {
        var xScale = meta.xScale,
            yScale = meta.yScale,
            _scaleRanges = meta._scaleRanges;
        var newRanges = {
          xmin: xScale.min,
          xmax: xScale.max,
          ymin: yScale.min,
          ymax: yScale.max
        };

        if (!_scaleRanges) {
          meta._scaleRanges = newRanges;
          return true;
        }

        var changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
        Object.assign(_scaleRanges, newRanges);
        return changed;
      }

      var atEdge = function atEdge(t) {
        return t === 0 || t === 1;
      };

      var elasticIn = function elasticIn(t, s, p) {
        return -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
      };

      var elasticOut = function elasticOut(t, s, p) {
        return Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
      };

      var effects = {
        linear: function linear(t) {
          return t;
        },
        easeInQuad: function easeInQuad(t) {
          return t * t;
        },
        easeOutQuad: function easeOutQuad(t) {
          return -t * (t - 2);
        },
        easeInOutQuad: function easeInOutQuad(t) {
          return (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1);
        },
        easeInCubic: function easeInCubic(t) {
          return t * t * t;
        },
        easeOutCubic: function easeOutCubic(t) {
          return (t -= 1) * t * t + 1;
        },
        easeInOutCubic: function easeInOutCubic(t) {
          return (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2);
        },
        easeInQuart: function easeInQuart(t) {
          return t * t * t * t;
        },
        easeOutQuart: function easeOutQuart(t) {
          return -((t -= 1) * t * t * t - 1);
        },
        easeInOutQuart: function easeInOutQuart(t) {
          return (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2);
        },
        easeInQuint: function easeInQuint(t) {
          return t * t * t * t * t;
        },
        easeOutQuint: function easeOutQuint(t) {
          return (t -= 1) * t * t * t * t + 1;
        },
        easeInOutQuint: function easeInOutQuint(t) {
          return (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2);
        },
        easeInSine: function easeInSine(t) {
          return -Math.cos(t * HALF_PI) + 1;
        },
        easeOutSine: function easeOutSine(t) {
          return Math.sin(t * HALF_PI);
        },
        easeInOutSine: function easeInOutSine(t) {
          return -0.5 * (Math.cos(PI * t) - 1);
        },
        easeInExpo: function easeInExpo(t) {
          return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
        },
        easeOutExpo: function easeOutExpo(t) {
          return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
        },
        easeInOutExpo: function easeInOutExpo(t) {
          return atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2);
        },
        easeInCirc: function easeInCirc(t) {
          return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1);
        },
        easeOutCirc: function easeOutCirc(t) {
          return Math.sqrt(1 - (t -= 1) * t);
        },
        easeInOutCirc: function easeInOutCirc(t) {
          return (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
        },
        easeInElastic: function easeInElastic(t) {
          return atEdge(t) ? t : elasticIn(t, 0.075, 0.3);
        },
        easeOutElastic: function easeOutElastic(t) {
          return atEdge(t) ? t : elasticOut(t, 0.075, 0.3);
        },
        easeInOutElastic: function easeInOutElastic(t) {
          var s = 0.1125;
          var p = 0.45;
          return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
        },
        easeInBack: function easeInBack(t) {
          var s = 1.70158;
          return t * t * ((s + 1) * t - s);
        },
        easeOutBack: function easeOutBack(t) {
          var s = 1.70158;
          return (t -= 1) * t * ((s + 1) * t + s) + 1;
        },
        easeInOutBack: function easeInOutBack(t) {
          var s = 1.70158;

          if ((t /= 0.5) < 1) {
            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
          }

          return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
        },
        easeInBounce: function easeInBounce(t) {
          return 1 - effects.easeOutBounce(1 - t);
        },
        easeOutBounce: function easeOutBounce(t) {
          var m = 7.5625;
          var d = 2.75;

          if (t < 1 / d) {
            return m * t * t;
          }

          if (t < 2 / d) {
            return m * (t -= 1.5 / d) * t + 0.75;
          }

          if (t < 2.5 / d) {
            return m * (t -= 2.25 / d) * t + 0.9375;
          }

          return m * (t -= 2.625 / d) * t + 0.984375;
        },
        easeInOutBounce: function easeInOutBounce(t) {
          return t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
        }
      };

      function round(v) {
        return v + 0.5 | 0;
      }

      var lim = function lim(v, l, h) {
        return Math.max(Math.min(v, h), l);
      };

      function p2b(v) {
        return lim(round(v * 2.55), 0, 255);
      }

      function n2b(v) {
        return lim(round(v * 255), 0, 255);
      }

      function b2n(v) {
        return lim(round(v / 2.55) / 100, 0, 1);
      }

      function n2p(v) {
        return lim(round(v * 100), 0, 100);
      }

      var map$1 = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15,
        a: 10,
        b: 11,
        c: 12,
        d: 13,
        e: 14,
        f: 15
      };

      var hex = _toConsumableArray("0123456789ABCDEF");

      var h1 = function h1(b) {
        return hex[b & 15];
      };

      var h2 = function h2(b) {
        return hex[(b & 240) >> 4] + hex[b & 15];
      };

      var eq = function eq(b) {
        return (b & 240) >> 4 === (b & 15);
      };

      var isShort = function isShort(v) {
        return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
      };

      function hexParse(str) {
        var len = str.length;
        var ret;

        if (str[0] === "#") {
          if (len === 4 || len === 5) {
            ret = {
              r: 255 & map$1[str[1]] * 17,
              g: 255 & map$1[str[2]] * 17,
              b: 255 & map$1[str[3]] * 17,
              a: len === 5 ? map$1[str[4]] * 17 : 255
            };
          } else if (len === 7 || len === 9) {
            ret = {
              r: map$1[str[1]] << 4 | map$1[str[2]],
              g: map$1[str[3]] << 4 | map$1[str[4]],
              b: map$1[str[5]] << 4 | map$1[str[6]],
              a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
            };
          }
        }

        return ret;
      }

      var alpha = function alpha(a, f) {
        return a < 255 ? f(a) : "";
      };

      function _hexString(v) {
        var f = isShort(v) ? h1 : h2;
        return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : undefined;
      }

      var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;

      function hsl2rgbn(h, s, l) {
        var a = s * Math.min(l, 1 - l);

        var f = function f(n) {
          var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + h / 30) % 12;
          return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        };

        return [f(0), f(8), f(4)];
      }

      function hsv2rgbn(h, s, v) {
        var f = function f(n) {
          var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + h / 60) % 6;
          return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
        };

        return [f(5), f(3), f(1)];
      }

      function hwb2rgbn(h, w, b) {
        var rgb = hsl2rgbn(h, 1, 0.5);
        var i;

        if (w + b > 1) {
          i = 1 / (w + b);
          w *= i;
          b *= i;
        }

        for (i = 0; i < 3; i++) {
          rgb[i] *= 1 - w - b;
          rgb[i] += w;
        }

        return rgb;
      }

      function hueValue(r, g, b, d, max) {
        if (r === max) {
          return (g - b) / d + (g < b ? 6 : 0);
        }

        if (g === max) {
          return (b - r) / d + 2;
        }

        return (r - g) / d + 4;
      }

      function rgb2hsl(v) {
        var range = 255;
        var r = v.r / range;
        var g = v.g / range;
        var b = v.b / range;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var l = (max + min) / 2;
        var h, s, d;

        if (max !== min) {
          d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          h = hueValue(r, g, b, d, max);
          h = h * 60 + 0.5;
        }

        return [h | 0, s || 0, l];
      }

      function calln(f, a, b, c) {
        return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
      }

      function hsl2rgb(h, s, l) {
        return calln(hsl2rgbn, h, s, l);
      }

      function hwb2rgb(h, w, b) {
        return calln(hwb2rgbn, h, w, b);
      }

      function hsv2rgb(h, s, v) {
        return calln(hsv2rgbn, h, s, v);
      }

      function hue(h) {
        return (h % 360 + 360) % 360;
      }

      function hueParse(str) {
        var m = HUE_RE.exec(str);
        var a = 255;
        var v;

        if (!m) {
          return;
        }

        if (m[5] !== v) {
          a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
        }

        var h = hue(+m[2]);
        var p1 = +m[3] / 100;
        var p2 = +m[4] / 100;

        if (m[1] === "hwb") {
          v = hwb2rgb(h, p1, p2);
        } else if (m[1] === "hsv") {
          v = hsv2rgb(h, p1, p2);
        } else {
          v = hsl2rgb(h, p1, p2);
        }

        return {
          r: v[0],
          g: v[1],
          b: v[2],
          a: a
        };
      }

      function _rotate(v, deg) {
        var h = rgb2hsl(v);
        h[0] = hue(h[0] + deg);
        h = hsl2rgb(h);
        v.r = h[0];
        v.g = h[1];
        v.b = h[2];
      }

      function _hslString(v) {
        if (!v) {
          return;
        }

        var a = rgb2hsl(v);
        var h = a[0];
        var s = n2p(a[1]);
        var l = n2p(a[2]);
        return v.a < 255 ? "hsla(".concat(h, ", ").concat(s, "%, ").concat(l, "%, ").concat(b2n(v.a), ")") : "hsl(".concat(h, ", ").concat(s, "%, ").concat(l, "%)");
      }

      var map$2 = {
        x: "dark",
        Z: "light",
        Y: "re",
        X: "blu",
        W: "gr",
        V: "medium",
        U: "slate",
        A: "ee",
        T: "ol",
        S: "or",
        B: "ra",
        C: "lateg",
        D: "ights",
        R: "in",
        Q: "turquois",
        E: "hi",
        P: "ro",
        O: "al",
        N: "le",
        M: "de",
        L: "yello",
        F: "en",
        K: "ch",
        G: "arks",
        H: "ea",
        I: "ightg",
        J: "wh"
      };
      var names$1 = {
        OiceXe: "f0f8ff",
        antiquewEte: "faebd7",
        aqua: "ffff",
        aquamarRe: "7fffd4",
        azuY: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "0",
        blanKedOmond: "ffebcd",
        Xe: "ff",
        XeviTet: "8a2be2",
        bPwn: "a52a2a",
        burlywood: "deb887",
        caMtXe: "5f9ea0",
        KartYuse: "7fff00",
        KocTate: "d2691e",
        cSO: "ff7f50",
        cSnflowerXe: "6495ed",
        cSnsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "ffff",
        xXe: "8b",
        xcyan: "8b8b",
        xgTMnPd: "b8860b",
        xWay: "a9a9a9",
        xgYF: "6400",
        xgYy: "a9a9a9",
        xkhaki: "bdb76b",
        xmagFta: "8b008b",
        xTivegYF: "556b2f",
        xSange: "ff8c00",
        xScEd: "9932cc",
        xYd: "8b0000",
        xsOmon: "e9967a",
        xsHgYF: "8fbc8f",
        xUXe: "483d8b",
        xUWay: "2f4f4f",
        xUgYy: "2f4f4f",
        xQe: "ced1",
        xviTet: "9400d3",
        dAppRk: "ff1493",
        dApskyXe: "bfff",
        dimWay: "696969",
        dimgYy: "696969",
        dodgerXe: "1e90ff",
        fiYbrick: "b22222",
        flSOwEte: "fffaf0",
        foYstWAn: "228b22",
        fuKsia: "ff00ff",
        gaRsbSo: "dcdcdc",
        ghostwEte: "f8f8ff",
        gTd: "ffd700",
        gTMnPd: "daa520",
        Way: "808080",
        gYF: "8000",
        gYFLw: "adff2f",
        gYy: "808080",
        honeyMw: "f0fff0",
        hotpRk: "ff69b4",
        RdianYd: "cd5c5c",
        Rdigo: "4b0082",
        ivSy: "fffff0",
        khaki: "f0e68c",
        lavFMr: "e6e6fa",
        lavFMrXsh: "fff0f5",
        lawngYF: "7cfc00",
        NmoncEffon: "fffacd",
        ZXe: "add8e6",
        ZcSO: "f08080",
        Zcyan: "e0ffff",
        ZgTMnPdLw: "fafad2",
        ZWay: "d3d3d3",
        ZgYF: "90ee90",
        ZgYy: "d3d3d3",
        ZpRk: "ffb6c1",
        ZsOmon: "ffa07a",
        ZsHgYF: "20b2aa",
        ZskyXe: "87cefa",
        ZUWay: "778899",
        ZUgYy: "778899",
        ZstAlXe: "b0c4de",
        ZLw: "ffffe0",
        lime: "ff00",
        limegYF: "32cd32",
        lRF: "faf0e6",
        magFta: "ff00ff",
        maPon: "800000",
        VaquamarRe: "66cdaa",
        VXe: "cd",
        VScEd: "ba55d3",
        VpurpN: "9370db",
        VsHgYF: "3cb371",
        VUXe: "7b68ee",
        VsprRggYF: "fa9a",
        VQe: "48d1cc",
        VviTetYd: "c71585",
        midnightXe: "191970",
        mRtcYam: "f5fffa",
        mistyPse: "ffe4e1",
        moccasR: "ffe4b5",
        navajowEte: "ffdead",
        navy: "80",
        Tdlace: "fdf5e6",
        Tive: "808000",
        TivedBb: "6b8e23",
        Sange: "ffa500",
        SangeYd: "ff4500",
        ScEd: "da70d6",
        pOegTMnPd: "eee8aa",
        pOegYF: "98fb98",
        pOeQe: "afeeee",
        pOeviTetYd: "db7093",
        papayawEp: "ffefd5",
        pHKpuff: "ffdab9",
        peru: "cd853f",
        pRk: "ffc0cb",
        plum: "dda0dd",
        powMrXe: "b0e0e6",
        purpN: "800080",
        YbeccapurpN: "663399",
        Yd: "ff0000",
        Psybrown: "bc8f8f",
        PyOXe: "4169e1",
        saddNbPwn: "8b4513",
        sOmon: "fa8072",
        sandybPwn: "f4a460",
        sHgYF: "2e8b57",
        sHshell: "fff5ee",
        siFna: "a0522d",
        silver: "c0c0c0",
        skyXe: "87ceeb",
        UXe: "6a5acd",
        UWay: "708090",
        UgYy: "708090",
        snow: "fffafa",
        sprRggYF: "ff7f",
        stAlXe: "4682b4",
        tan: "d2b48c",
        teO: "8080",
        tEstN: "d8bfd8",
        tomato: "ff6347",
        Qe: "40e0d0",
        viTet: "ee82ee",
        JHt: "f5deb3",
        wEte: "ffffff",
        wEtesmoke: "f5f5f5",
        Lw: "ffff00",
        LwgYF: "9acd32"
      };

      function unpack() {
        var unpacked = {};
        var keys = Object.keys(names$1);
        var tkeys = Object.keys(map$2);
        var i, j, k, ok, nk;

        for (i = 0; i < keys.length; i++) {
          ok = nk = keys[i];

          for (j = 0; j < tkeys.length; j++) {
            k = tkeys[j];
            nk = nk.replace(k, map$2[k]);
          }

          k = parseInt(names$1[ok], 16);
          unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
        }

        return unpacked;
      }

      var names;

      function nameParse(str) {
        if (!names) {
          names = unpack();
          names.transparent = [0, 0, 0, 0];
        }

        var a = names[str.toLowerCase()];
        return a && {
          r: a[0],
          g: a[1],
          b: a[2],
          a: a.length === 4 ? a[3] : 255
        };
      }

      var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;

      function rgbParse(str) {
        var m = RGB_RE.exec(str);
        var a = 255;
        var r, g, b;

        if (!m) {
          return;
        }

        if (m[7] !== r) {
          var v = +m[7];
          a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
        }

        r = +m[1];
        g = +m[3];
        b = +m[5];
        r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
        g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
        b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
        return {
          r: r,
          g: g,
          b: b,
          a: a
        };
      }

      function _rgbString(v) {
        return v && (v.a < 255 ? "rgba(".concat(v.r, ", ").concat(v.g, ", ").concat(v.b, ", ").concat(b2n(v.a), ")") : "rgb(".concat(v.r, ", ").concat(v.g, ", ").concat(v.b, ")"));
      }

      var to = function to(v) {
        return v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
      };

      var from = function from(v) {
        return v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
      };

      function _interpolate(rgb1, rgb2, t) {
        var r = from(b2n(rgb1.r));
        var g = from(b2n(rgb1.g));
        var b = from(b2n(rgb1.b));
        return {
          r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
          g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
          b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
          a: rgb1.a + t * (rgb2.a - rgb1.a)
        };
      }

      function modHSL(v, i, ratio) {
        if (v) {
          var tmp = rgb2hsl(v);
          tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
          tmp = hsl2rgb(tmp);
          v.r = tmp[0];
          v.g = tmp[1];
          v.b = tmp[2];
        }
      }

      function clone(v, proto) {
        return v ? Object.assign(proto || {}, v) : v;
      }

      function fromObject(input) {
        var v = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        };

        if (Array.isArray(input)) {
          if (input.length >= 3) {
            v = {
              r: input[0],
              g: input[1],
              b: input[2],
              a: 255
            };

            if (input.length > 3) {
              v.a = n2b(input[3]);
            }
          }
        } else {
          v = clone(input, {
            r: 0,
            g: 0,
            b: 0,
            a: 1
          });
          v.a = n2b(v.a);
        }

        return v;
      }

      function functionParse(str) {
        if (str.charAt(0) === "r") {
          return rgbParse(str);
        }

        return hueParse(str);
      }

      var Color = /*#__PURE__*/function () {
        function Color(input) {
          _classCallCheck(this, Color);

          if (input instanceof Color) {
            return input;
          }

          var type = _typeof(input);

          var v;

          if (type === "object") {
            v = fromObject(input);
          } else if (type === "string") {
            v = hexParse(input) || nameParse(input) || functionParse(input);
          }

          this._rgb = v;
          this._valid = !!v;
        }

        _createClass(Color, [{
          key: "rgbString",
          value: function rgbString() {
            return this._valid ? _rgbString(this._rgb) : undefined;
          }
        }, {
          key: "hexString",
          value: function hexString() {
            return this._valid ? _hexString(this._rgb) : undefined;
          }
        }, {
          key: "hslString",
          value: function hslString() {
            return this._valid ? _hslString(this._rgb) : undefined;
          }
        }, {
          key: "mix",
          value: function mix(color, weight) {
            if (color) {
              var c1 = this.rgb;
              var c2 = color.rgb;
              var w2;
              var p = weight === w2 ? 0.5 : weight;
              var w = 2 * p - 1;
              var a = c1.a - c2.a;
              var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
              w2 = 1 - w1;
              c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
              c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
              c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
              c1.a = p * c1.a + (1 - p) * c2.a;
              this.rgb = c1;
            }

            return this;
          }
        }, {
          key: "interpolate",
          value: function interpolate(color, t) {
            if (color) {
              this._rgb = _interpolate(this._rgb, color._rgb, t);
            }

            return this;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new Color(this.rgb);
          }
        }, {
          key: "alpha",
          value: function alpha(a) {
            this._rgb.a = n2b(a);
            return this;
          }
        }, {
          key: "clearer",
          value: function clearer(ratio) {
            var rgb = this._rgb;
            rgb.a *= 1 - ratio;
            return this;
          }
        }, {
          key: "greyscale",
          value: function greyscale() {
            var rgb = this._rgb;
            var val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
            rgb.r = rgb.g = rgb.b = val;
            return this;
          }
        }, {
          key: "opaquer",
          value: function opaquer(ratio) {
            var rgb = this._rgb;
            rgb.a *= 1 + ratio;
            return this;
          }
        }, {
          key: "negate",
          value: function negate() {
            var v = this._rgb;
            v.r = 255 - v.r;
            v.g = 255 - v.g;
            v.b = 255 - v.b;
            return this;
          }
        }, {
          key: "lighten",
          value: function lighten(ratio) {
            modHSL(this._rgb, 2, ratio);
            return this;
          }
        }, {
          key: "darken",
          value: function darken(ratio) {
            modHSL(this._rgb, 2, -ratio);
            return this;
          }
        }, {
          key: "saturate",
          value: function saturate(ratio) {
            modHSL(this._rgb, 1, ratio);
            return this;
          }
        }, {
          key: "desaturate",
          value: function desaturate(ratio) {
            modHSL(this._rgb, 1, -ratio);
            return this;
          }
        }, {
          key: "rotate",
          value: function rotate(deg) {
            _rotate(this._rgb, deg);

            return this;
          }
        }, {
          key: "valid",
          get: function get() {
            return this._valid;
          }
        }, {
          key: "rgb",
          get: function get() {
            var v = clone(this._rgb);

            if (v) {
              v.a = b2n(v.a);
            }

            return v;
          },
          set: function set(obj) {
            this._rgb = fromObject(obj);
          }
        }]);

        return Color;
      }();

      function index_esm(input) {
        return new Color(input);
      }

      function isPatternOrGradient(value) {
        if (value && _typeof(value) === "object") {
          var type = value.toString();
          return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
        }

        return false;
      }

      function color(value) {
        return isPatternOrGradient(value) ? value : index_esm(value);
      }

      function getHoverColor(value) {
        return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
      }

      var overrides = Object.create(null);
      var descriptors = Object.create(null);

      function getScope$1(node, key) {
        if (!key) {
          return node;
        }

        var keys = key.split(".");

        for (var i = 0, n = keys.length; i < n; ++i) {
          var k = keys[i];
          node = node[k] || (node[k] = Object.create(null));
        }

        return node;
      }

      function _set(root, scope, values) {
        if (typeof scope === "string") {
          return merge(getScope$1(root, scope), values);
        }

        return merge(getScope$1(root, ""), scope);
      }

      var Defaults = /*#__PURE__*/function () {
        function Defaults(_descriptors) {
          _classCallCheck(this, Defaults);

          this.animation = undefined;
          this.backgroundColor = "rgba(0,0,0,0.1)";
          this.borderColor = "rgba(0,0,0,0.1)";
          this.color = "#666";
          this.datasets = {};

          this.devicePixelRatio = function (context) {
            return context.chart.platform.getDevicePixelRatio();
          };

          this.elements = {};
          this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"];
          this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: "normal",
            lineHeight: 1.2,
            weight: null
          };
          this.hover = {};

          this.hoverBackgroundColor = function (ctx, options) {
            return getHoverColor(options.backgroundColor);
          };

          this.hoverBorderColor = function (ctx, options) {
            return getHoverColor(options.borderColor);
          };

          this.hoverColor = function (ctx, options) {
            return getHoverColor(options.color);
          };

          this.indexAxis = "x";
          this.interaction = {
            mode: "nearest",
            intersect: true,
            includeInvisible: false
          };
          this.maintainAspectRatio = true;
          this.onHover = null;
          this.onClick = null;
          this.parsing = true;
          this.plugins = {};
          this.responsive = true;
          this.scale = undefined;
          this.scales = {};
          this.showLine = true;
          this.drawActiveElementsOnTop = true;
          this.describe(_descriptors);
        }

        _createClass(Defaults, [{
          key: "set",
          value: function set(scope, values) {
            return _set(this, scope, values);
          }
        }, {
          key: "get",
          value: function get(scope) {
            return getScope$1(this, scope);
          }
        }, {
          key: "describe",
          value: function describe(scope, values) {
            return _set(descriptors, scope, values);
          }
        }, {
          key: "override",
          value: function override(scope, values) {
            return _set(overrides, scope, values);
          }
        }, {
          key: "route",
          value: function route(scope, name, targetScope, targetName) {
            var _Object$definePropert;

            var scopeObject = getScope$1(this, scope);
            var targetScopeObject = getScope$1(this, targetScope);
            var privateName = "_" + name;
            Object.defineProperties(scopeObject, (_Object$definePropert = {}, _defineProperty(_Object$definePropert, privateName, {
              value: scopeObject[name],
              writable: true
            }), _defineProperty(_Object$definePropert, name, {
              enumerable: true,
              get: function get() {
                var local = this[privateName];
                var target = targetScopeObject[targetName];

                if (isObject(local)) {
                  return Object.assign({}, target, local);
                }

                return valueOrDefault(local, target);
              },
              set: function set(value) {
                this[privateName] = value;
              }
            }), _Object$definePropert));
          }
        }]);

        return Defaults;
      }();

      var defaults = new Defaults({
        _scriptable: function _scriptable(name) {
          return !name.startsWith("on");
        },
        _indexable: function _indexable(name) {
          return name !== "events";
        },
        hover: {
          _fallback: "interaction"
        },
        interaction: {
          _scriptable: false,
          _indexable: false
        }
      });

      function toFontString(font) {
        if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
          return null;
        }

        return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
      }

      function _measureText(ctx, data, gc, longest, string) {
        var textWidth = data[string];

        if (!textWidth) {
          textWidth = data[string] = ctx.measureText(string).width;
          gc.push(string);
        }

        if (textWidth > longest) {
          longest = textWidth;
        }

        return longest;
      }

      function _longestText(ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        var data = cache.data = cache.data || {};
        var gc = cache.garbageCollect = cache.garbageCollect || [];

        if (cache.font !== font) {
          data = cache.data = {};
          gc = cache.garbageCollect = [];
          cache.font = font;
        }

        ctx.save();
        ctx.font = font;
        var longest = 0;
        var ilen = arrayOfThings.length;
        var i, j, jlen, thing, nestedThing;

        for (i = 0; i < ilen; i++) {
          thing = arrayOfThings[i];

          if (thing !== undefined && thing !== null && isArray(thing) !== true) {
            longest = _measureText(ctx, data, gc, longest, thing);
          } else if (isArray(thing)) {
            for (j = 0, jlen = thing.length; j < jlen; j++) {
              nestedThing = thing[j];

              if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {
                longest = _measureText(ctx, data, gc, longest, nestedThing);
              }
            }
          }
        }

        ctx.restore();
        var gcLen = gc.length / 2;

        if (gcLen > arrayOfThings.length) {
          for (i = 0; i < gcLen; i++) {
            delete data[gc[i]];
          }

          gc.splice(0, gcLen);
        }

        return longest;
      }

      function _alignPixel(chart, pixel, width) {
        var devicePixelRatio = chart.currentDevicePixelRatio;
        var halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
      }

      function clearCanvas(canvas, ctx) {
        ctx = ctx || canvas.getContext("2d");
        ctx.save();
        ctx.resetTransform();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
      }

      function drawPoint(ctx, options, x, y) {
        drawPointLegend(ctx, options, x, y, null);
      }

      function drawPointLegend(ctx, options, x, y, w) {
        var type, xOffset, yOffset, size, cornerRadius, width;
        var style = options.pointStyle;
        var rotation = options.rotation;
        var radius = options.radius;
        var rad = (rotation || 0) * RAD_PER_DEG;

        if (style && _typeof(style) === "object") {
          type = style.toString();

          if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rad);
            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
            ctx.restore();
            return;
          }
        }

        if (isNaN(radius) || radius <= 0) {
          return;
        }

        ctx.beginPath();

        switch (style) {
          default:
            if (w) {
              ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
            } else {
              ctx.arc(x, y, radius, 0, TAU);
            }

            ctx.closePath();
            break;

          case "triangle":
            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;

          case "rectRounded":
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;

          case "rect":
            if (!rotation) {
              size = Math.SQRT1_2 * radius;
              width = w ? w / 2 : size;
              ctx.rect(x - width, y - size, 2 * width, 2 * size);
              break;
            }

            rad += QUARTER_PI;

          case "rectRot":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + yOffset, y - xOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            ctx.closePath();
            break;

          case "crossRot":
            rad += QUARTER_PI;

          case "cross":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;

          case "star":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            rad += QUARTER_PI;
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;

          case "line":
            xOffset = w ? w / 2 : Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;

          case "dash":
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
            break;
        }

        ctx.fill();

        if (options.borderWidth > 0) {
          ctx.stroke();
        }
      }

      function _isPointInArea(point, area, margin) {
        margin = margin || 0.5;
        return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
      }

      function clipArea(ctx, area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
        ctx.clip();
      }

      function unclipArea(ctx) {
        ctx.restore();
      }

      function _steppedLineTo(ctx, previous, target, flip, mode) {
        if (!previous) {
          return ctx.lineTo(target.x, target.y);
        }

        if (mode === "middle") {
          var midpoint = (previous.x + target.x) / 2;
          ctx.lineTo(midpoint, previous.y);
          ctx.lineTo(midpoint, target.y);
        } else if (mode === "after" !== !!flip) {
          ctx.lineTo(previous.x, target.y);
        } else {
          ctx.lineTo(target.x, previous.y);
        }

        ctx.lineTo(target.x, target.y);
      }

      function _bezierCurveTo(ctx, previous, target, flip) {
        if (!previous) {
          return ctx.lineTo(target.x, target.y);
        }

        ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
      }

      function renderText(ctx, text, x, y, font) {
        var opts = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
        var lines = isArray(text) ? text : [text];
        var stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
        var i, line;
        ctx.save();
        ctx.font = font.string;
        setRenderOpts(ctx, opts);

        for (i = 0; i < lines.length; ++i) {
          line = lines[i];

          if (stroke) {
            if (opts.strokeColor) {
              ctx.strokeStyle = opts.strokeColor;
            }

            if (!isNullOrUndef(opts.strokeWidth)) {
              ctx.lineWidth = opts.strokeWidth;
            }

            ctx.strokeText(line, x, y, opts.maxWidth);
          }

          ctx.fillText(line, x, y, opts.maxWidth);
          decorateText(ctx, x, y, line, opts);
          y += font.lineHeight;
        }

        ctx.restore();
      }

      function setRenderOpts(ctx, opts) {
        if (opts.translation) {
          ctx.translate(opts.translation[0], opts.translation[1]);
        }

        if (!isNullOrUndef(opts.rotation)) {
          ctx.rotate(opts.rotation);
        }

        if (opts.color) {
          ctx.fillStyle = opts.color;
        }

        if (opts.textAlign) {
          ctx.textAlign = opts.textAlign;
        }

        if (opts.textBaseline) {
          ctx.textBaseline = opts.textBaseline;
        }
      }

      function decorateText(ctx, x, y, line, opts) {
        if (opts.strikethrough || opts.underline) {
          var metrics = ctx.measureText(line);
          var left = x - metrics.actualBoundingBoxLeft;
          var right = x + metrics.actualBoundingBoxRight;
          var top = y - metrics.actualBoundingBoxAscent;
          var bottom = y + metrics.actualBoundingBoxDescent;
          var yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
          ctx.strokeStyle = ctx.fillStyle;
          ctx.beginPath();
          ctx.lineWidth = opts.decorationWidth || 2;
          ctx.moveTo(left, yDecoration);
          ctx.lineTo(right, yDecoration);
          ctx.stroke();
        }
      }

      function addRoundedRectPath(ctx, rect) {
        var x = rect.x,
            y = rect.y,
            w = rect.w,
            h = rect.h,
            radius = rect.radius;
        ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
        ctx.lineTo(x, y + h - radius.bottomLeft);
        ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
        ctx.lineTo(x + w - radius.bottomRight, y + h);
        ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
        ctx.lineTo(x + w, y + radius.topRight);
        ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
        ctx.lineTo(x + radius.topLeft, y);
      }

      var LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
      var FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);

      function toLineHeight(value, size) {
        var matches = ("" + value).match(LINE_HEIGHT);

        if (!matches || matches[1] === "normal") {
          return size * 1.2;
        }

        value = +matches[2];

        switch (matches[3]) {
          case "px":
            return value;

          case "%":
            value /= 100;
            break;
        }

        return size * value;
      }

      var numberOrZero = function numberOrZero(v) {
        return +v || 0;
      };

      function _readValueToProps(value, props) {
        var ret = {};
        var objProps = isObject(props);
        var keys = objProps ? Object.keys(props) : props;
        var read = isObject(value) ? objProps ? function (prop) {
          return valueOrDefault(value[prop], value[props[prop]]);
        } : function (prop) {
          return value[prop];
        } : function () {
          return value;
        };

        var _iterator4 = _createForOfIteratorHelper(keys),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var prop = _step4.value;
            ret[prop] = numberOrZero(read(prop));
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return ret;
      }

      function toTRBL(value) {
        return _readValueToProps(value, {
          top: "y",
          right: "x",
          bottom: "y",
          left: "x"
        });
      }

      function toTRBLCorners(value) {
        return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
      }

      function toPadding(value) {
        var obj = toTRBL(value);
        obj.width = obj.left + obj.right;
        obj.height = obj.top + obj.bottom;
        return obj;
      }

      function toFont(options, fallback) {
        options = options || {};
        fallback = fallback || defaults.font;
        var size = valueOrDefault(options.size, fallback.size);

        if (typeof size === "string") {
          size = parseInt(size, 10);
        }

        var style = valueOrDefault(options.style, fallback.style);

        if (style && !("" + style).match(FONT_STYLE)) {
          console.warn("Invalid font style specified: \"" + style + "\"");
          style = "";
        }

        var font = {
          family: valueOrDefault(options.family, fallback.family),
          lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
          size: size,
          style: style,
          weight: valueOrDefault(options.weight, fallback.weight),
          string: ""
        };
        font.string = toFontString(font);
        return font;
      }

      function resolve(inputs, context, index, info) {
        var cacheable = true;
        var i, ilen, value;

        for (i = 0, ilen = inputs.length; i < ilen; ++i) {
          value = inputs[i];

          if (value === undefined) {
            continue;
          }

          if (context !== undefined && typeof value === "function") {
            value = value(context);
            cacheable = false;
          }

          if (index !== undefined && isArray(value)) {
            value = value[index % value.length];
            cacheable = false;
          }

          if (value !== undefined) {
            if (info && !cacheable) {
              info.cacheable = false;
            }

            return value;
          }
        }
      }

      function _addGrace(minmax, grace, beginAtZero) {
        var min = minmax.min,
            max = minmax.max;
        var change = toDimension(grace, (max - min) / 2);

        var keepZero = function keepZero(value, add) {
          return beginAtZero && value === 0 ? 0 : value + add;
        };

        return {
          min: keepZero(min, -Math.abs(change)),
          max: keepZero(max, change)
        };
      }

      function createContext(parentContext, context) {
        return Object.assign(Object.create(parentContext), context);
      }

      function _createResolver(scopes) {
        var _cache;

        var prefixes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [""];
        var rootScopes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : scopes;
        var fallback = arguments.length > 3 ? arguments[3] : undefined;
        var getTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {
          return scopes[0];
        };

        if (!defined(fallback)) {
          fallback = _resolve("_fallback", scopes);
        }

        var cache = (_cache = {}, _defineProperty(_cache, Symbol.toStringTag, "Object"), _defineProperty(_cache, "_cacheable", true), _defineProperty(_cache, "_scopes", scopes), _defineProperty(_cache, "_rootScopes", rootScopes), _defineProperty(_cache, "_fallback", fallback), _defineProperty(_cache, "_getTarget", getTarget), _defineProperty(_cache, "override", function override(scope) {
          return _createResolver([scope].concat(_toConsumableArray(scopes)), prefixes, rootScopes, fallback);
        }), _cache);
        return new Proxy(cache, {
          deleteProperty: function deleteProperty(target, prop) {
            delete target[prop];
            delete target._keys;
            delete scopes[0][prop];
            return true;
          },
          get: function get(target, prop) {
            return _cached(target, prop, function () {
              return _resolveWithPrefixes(prop, prefixes, scopes, target);
            });
          },
          getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, prop) {
            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
          },
          getPrototypeOf: function getPrototypeOf() {
            return Reflect.getPrototypeOf(scopes[0]);
          },
          has: function has(target, prop) {
            return getKeysFromAllScopes(target).includes(prop);
          },
          ownKeys: function ownKeys(target) {
            return getKeysFromAllScopes(target);
          },
          set: function set(target, prop, value) {
            var storage = target._storage || (target._storage = getTarget());
            target[prop] = storage[prop] = value;
            delete target._keys;
            return true;
          }
        });
      }

      function _attachContext(proxy, context, subProxy, descriptorDefaults) {
        var cache = {
          _cacheable: false,
          _proxy: proxy,
          _context: context,
          _subProxy: subProxy,
          _stack: new Set(),
          _descriptors: _descriptors(proxy, descriptorDefaults),
          setContext: function setContext(ctx) {
            return _attachContext(proxy, ctx, subProxy, descriptorDefaults);
          },
          override: function override(scope) {
            return _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults);
          }
        };
        return new Proxy(cache, {
          deleteProperty: function deleteProperty(target, prop) {
            delete target[prop];
            delete proxy[prop];
            return true;
          },
          get: function get(target, prop, receiver) {
            return _cached(target, prop, function () {
              return _resolveWithContext(target, prop, receiver);
            });
          },
          getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, prop) {
            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
              enumerable: true,
              configurable: true
            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);
          },
          getPrototypeOf: function getPrototypeOf() {
            return Reflect.getPrototypeOf(proxy);
          },
          has: function has(target, prop) {
            return Reflect.has(proxy, prop);
          },
          ownKeys: function ownKeys() {
            return Reflect.ownKeys(proxy);
          },
          set: function set(target, prop, value) {
            proxy[prop] = value;
            delete target[prop];
            return true;
          }
        });
      }

      function _descriptors(proxy) {
        var defaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          scriptable: true,
          indexable: true
        };

        var _proxy$_scriptable = proxy._scriptable,
            _scriptable = _proxy$_scriptable === void 0 ? defaults.scriptable : _proxy$_scriptable,
            _proxy$_indexable = proxy._indexable,
            _indexable = _proxy$_indexable === void 0 ? defaults.indexable : _proxy$_indexable,
            _proxy$_allKeys = proxy._allKeys,
            _allKeys = _proxy$_allKeys === void 0 ? defaults.allKeys : _proxy$_allKeys;

        return {
          allKeys: _allKeys,
          scriptable: _scriptable,
          indexable: _indexable,
          isScriptable: isFunction(_scriptable) ? _scriptable : function () {
            return _scriptable;
          },
          isIndexable: isFunction(_indexable) ? _indexable : function () {
            return _indexable;
          }
        };
      }

      var readKey = function readKey(prefix, name) {
        return prefix ? prefix + _capitalize(name) : name;
      };

      var needsSubResolver = function needsSubResolver(prop, value) {
        return isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
      };

      function _cached(target, prop, resolve) {
        if (Object.prototype.hasOwnProperty.call(target, prop)) {
          return target[prop];
        }

        var value = resolve();
        target[prop] = value;
        return value;
      }

      function _resolveWithContext(target, prop, receiver) {
        var _proxy = target._proxy,
            _context = target._context,
            _subProxy = target._subProxy,
            descriptors = target._descriptors;
        var value = _proxy[prop];

        if (isFunction(value) && descriptors.isScriptable(prop)) {
          value = _resolveScriptable(prop, value, target, receiver);
        }

        if (isArray(value) && value.length) {
          value = _resolveArray(prop, value, target, descriptors.isIndexable);
        }

        if (needsSubResolver(prop, value)) {
          value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
        }

        return value;
      }

      function _resolveScriptable(prop, value, target, receiver) {
        var _proxy = target._proxy,
            _context = target._context,
            _subProxy = target._subProxy,
            _stack = target._stack;

        if (_stack.has(prop)) {
          throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
        }

        _stack.add(prop);

        value = value(_context, _subProxy || receiver);

        _stack["delete"](prop);

        if (needsSubResolver(prop, value)) {
          value = createSubResolver(_proxy._scopes, _proxy, prop, value);
        }

        return value;
      }

      function _resolveArray(prop, value, target, isIndexable) {
        var _proxy = target._proxy,
            _context = target._context,
            _subProxy = target._subProxy,
            descriptors = target._descriptors;

        if (defined(_context.index) && isIndexable(prop)) {
          value = value[_context.index % value.length];
        } else if (isObject(value[0])) {
          var arr = value;

          var scopes = _proxy._scopes.filter(function (s) {
            return s !== arr;
          });

          value = [];

          var _iterator5 = _createForOfIteratorHelper(arr),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var item = _step5.value;
              var resolver = createSubResolver(scopes, _proxy, prop, item);
              value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }

        return value;
      }

      function resolveFallback(fallback, prop, value) {
        return isFunction(fallback) ? fallback(prop, value) : fallback;
      }

      var getScope = function getScope(key, parent) {
        return key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : undefined;
      };

      function addScopes(set, parentScopes, key, parentFallback, value) {
        var _iterator6 = _createForOfIteratorHelper(parentScopes),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var parent = _step6.value;
            var scope = getScope(key, parent);

            if (scope) {
              set.add(scope);
              var fallback = resolveFallback(scope._fallback, key, value);

              if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
                return fallback;
              }
            } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
              return null;
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        return false;
      }

      function createSubResolver(parentScopes, resolver, prop, value) {
        var rootScopes = resolver._rootScopes;
        var fallback = resolveFallback(resolver._fallback, prop, value);
        var allScopes = [].concat(_toConsumableArray(parentScopes), _toConsumableArray(rootScopes));
        var set = new Set();
        set.add(value);
        var key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);

        if (key === null) {
          return false;
        }

        if (defined(fallback) && fallback !== prop) {
          key = addScopesFromKey(set, allScopes, fallback, key, value);

          if (key === null) {
            return false;
          }
        }

        return _createResolver(Array.from(set), [""], rootScopes, fallback, function () {
          return subGetTarget(resolver, prop, value);
        });
      }

      function addScopesFromKey(set, allScopes, key, fallback, item) {
        while (key) {
          key = addScopes(set, allScopes, key, fallback, item);
        }

        return key;
      }

      function subGetTarget(resolver, prop, value) {
        var parent = resolver._getTarget();

        if (!(prop in parent)) {
          parent[prop] = {};
        }

        var target = parent[prop];

        if (isArray(target) && isObject(value)) {
          return value;
        }

        return target;
      }

      function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
        var value;

        var _iterator7 = _createForOfIteratorHelper(prefixes),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var prefix = _step7.value;
            value = _resolve(readKey(prefix, prop), scopes);

            if (defined(value)) {
              return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
            }
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
      }

      function _resolve(key, scopes) {
        var _iterator8 = _createForOfIteratorHelper(scopes),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var scope = _step8.value;

            if (!scope) {
              continue;
            }

            var value = scope[key];

            if (defined(value)) {
              return value;
            }
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
      }

      function getKeysFromAllScopes(target) {
        var keys = target._keys;

        if (!keys) {
          keys = target._keys = resolveKeysFromAllScopes(target._scopes);
        }

        return keys;
      }

      function resolveKeysFromAllScopes(scopes) {
        var set = new Set();

        var _iterator9 = _createForOfIteratorHelper(scopes),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var scope = _step9.value;

            var _iterator10 = _createForOfIteratorHelper(Object.keys(scope).filter(function (k) {
              return !k.startsWith("_");
            })),
                _step10;

            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var key = _step10.value;
                set.add(key);
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }

        return Array.from(set);
      }

      function _parseObjectDataRadialScale(meta, data, start, count) {
        var iScale = meta.iScale;
        var _this$_parsing$key = this._parsing.key,
            key = _this$_parsing$key === void 0 ? "r" : _this$_parsing$key;
        var parsed = new Array(count);
        var i, ilen, index, item;

        for (i = 0, ilen = count; i < ilen; ++i) {
          index = i + start;
          item = data[index];
          parsed[i] = {
            r: iScale.parse(resolveObjectKey(item, key), index)
          };
        }

        return parsed;
      }

      var EPSILON = Number.EPSILON || 1e-14;

      var getPoint = function getPoint(points, i) {
        return i < points.length && !points[i].skip && points[i];
      };

      var getValueAxis = function getValueAxis(indexAxis) {
        return indexAxis === "x" ? "y" : "x";
      };

      function splineCurve(firstPoint, middlePoint, afterPoint, t) {
        var previous = firstPoint.skip ? middlePoint : firstPoint;
        var current = middlePoint;
        var next = afterPoint.skip ? middlePoint : afterPoint;
        var d01 = distanceBetweenPoints(current, previous);
        var d12 = distanceBetweenPoints(next, current);
        var s01 = d01 / (d01 + d12);
        var s12 = d12 / (d01 + d12);
        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        var fa = t * s01;
        var fb = t * s12;
        return {
          previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
          },
          next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
          }
        };
      }

      function monotoneAdjust(points, deltaK, mK) {
        var pointsLen = points.length;
        var alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
        var pointAfter = getPoint(points, 0);

        for (var i = 0; i < pointsLen - 1; ++i) {
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);

          if (!pointCurrent || !pointAfter) {
            continue;
          }

          if (almostEquals(deltaK[i], 0, EPSILON)) {
            mK[i] = mK[i + 1] = 0;
            continue;
          }

          alphaK = mK[i] / deltaK[i];
          betaK = mK[i + 1] / deltaK[i];
          squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);

          if (squaredMagnitude <= 9) {
            continue;
          }

          tauK = 3 / Math.sqrt(squaredMagnitude);
          mK[i] = alphaK * tauK * deltaK[i];
          mK[i + 1] = betaK * tauK * deltaK[i];
        }
      }

      function monotoneCompute(points, mK) {
        var indexAxis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "x";
        var valueAxis = getValueAxis(indexAxis);
        var pointsLen = points.length;
        var delta, pointBefore, pointCurrent;
        var pointAfter = getPoint(points, 0);

        for (var i = 0; i < pointsLen; ++i) {
          pointBefore = pointCurrent;
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);

          if (!pointCurrent) {
            continue;
          }

          var iPixel = pointCurrent[indexAxis];
          var vPixel = pointCurrent[valueAxis];

          if (pointBefore) {
            delta = (iPixel - pointBefore[indexAxis]) / 3;
            pointCurrent["cp1".concat(indexAxis)] = iPixel - delta;
            pointCurrent["cp1".concat(valueAxis)] = vPixel - delta * mK[i];
          }

          if (pointAfter) {
            delta = (pointAfter[indexAxis] - iPixel) / 3;
            pointCurrent["cp2".concat(indexAxis)] = iPixel + delta;
            pointCurrent["cp2".concat(valueAxis)] = vPixel + delta * mK[i];
          }
        }
      }

      function splineCurveMonotone(points) {
        var indexAxis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "x";
        var valueAxis = getValueAxis(indexAxis);
        var pointsLen = points.length;
        var deltaK = Array(pointsLen).fill(0);
        var mK = Array(pointsLen);
        var i, pointBefore, pointCurrent;
        var pointAfter = getPoint(points, 0);

        for (i = 0; i < pointsLen; ++i) {
          pointBefore = pointCurrent;
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);

          if (!pointCurrent) {
            continue;
          }

          if (pointAfter) {
            var slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
          }

          mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
        }

        monotoneAdjust(points, deltaK, mK);
        monotoneCompute(points, mK, indexAxis);
      }

      function capControlPoint(pt, min, max) {
        return Math.max(Math.min(pt, max), min);
      }

      function capBezierPoints(points, area) {
        var i, ilen, point, inArea, inAreaPrev;

        var inAreaNext = _isPointInArea(points[0], area);

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          inAreaPrev = inArea;
          inArea = inAreaNext;
          inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);

          if (!inArea) {
            continue;
          }

          point = points[i];

          if (inAreaPrev) {
            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
          }

          if (inAreaNext) {
            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
          }
        }
      }

      function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
        var i, ilen, point, controlPoints;

        if (options.spanGaps) {
          points = points.filter(function (pt) {
            return !pt.skip;
          });
        }

        if (options.cubicInterpolationMode === "monotone") {
          splineCurveMonotone(points, indexAxis);
        } else {
          var prev = loop ? points[points.length - 1] : points[0];

          for (i = 0, ilen = points.length; i < ilen; ++i) {
            point = points[i];
            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
            point.cp1x = controlPoints.previous.x;
            point.cp1y = controlPoints.previous.y;
            point.cp2x = controlPoints.next.x;
            point.cp2y = controlPoints.next.y;
            prev = point;
          }
        }

        if (options.capBezierPoints) {
          capBezierPoints(points, area);
        }
      }

      function _isDomSupported() {
        return typeof window !== "undefined" && typeof document !== "undefined";
      }

      function _getParentNode(domNode) {
        var parent = domNode.parentNode;

        if (parent && parent.toString() === "[object ShadowRoot]") {
          parent = parent.host;
        }

        return parent;
      }

      function parseMaxStyle(styleValue, node, parentProperty) {
        var valueInPixels;

        if (typeof styleValue === "string") {
          valueInPixels = parseInt(styleValue, 10);

          if (styleValue.indexOf("%") !== -1) {
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
          }
        } else {
          valueInPixels = styleValue;
        }

        return valueInPixels;
      }

      var getComputedStyle = function getComputedStyle(element) {
        return window.getComputedStyle(element, null);
      };

      function getStyle(el, property) {
        return getComputedStyle(el).getPropertyValue(property);
      }

      var positions = ["top", "right", "bottom", "left"];

      function getPositionedStyle(styles, style, suffix) {
        var result = {};
        suffix = suffix ? "-" + suffix : "";

        for (var i = 0; i < 4; i++) {
          var pos = positions[i];
          result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
        }

        result.width = result.left + result.right;
        result.height = result.top + result.bottom;
        return result;
      }

      var useOffsetPos = function useOffsetPos(x, y, target) {
        return (x > 0 || y > 0) && (!target || !target.shadowRoot);
      };

      function getCanvasPosition(e, canvas) {
        var touches = e.touches;
        var source = touches && touches.length ? touches[0] : e;
        var offsetX = source.offsetX,
            offsetY = source.offsetY;
        var box = false;
        var x, y;

        if (useOffsetPos(offsetX, offsetY, e.target)) {
          x = offsetX;
          y = offsetY;
        } else {
          var rect = canvas.getBoundingClientRect();
          x = source.clientX - rect.left;
          y = source.clientY - rect.top;
          box = true;
        }

        return {
          x: x,
          y: y,
          box: box
        };
      }

      function getRelativePosition(evt, chart) {
        if ("native" in evt) {
          return evt;
        }

        var canvas = chart.canvas,
            currentDevicePixelRatio = chart.currentDevicePixelRatio;
        var style = getComputedStyle(canvas);
        var borderBox = style.boxSizing === "border-box";
        var paddings = getPositionedStyle(style, "padding");
        var borders = getPositionedStyle(style, "border", "width");

        var _getCanvasPosition = getCanvasPosition(evt, canvas),
            x = _getCanvasPosition.x,
            y = _getCanvasPosition.y,
            box = _getCanvasPosition.box;

        var xOffset = paddings.left + (box && borders.left);
        var yOffset = paddings.top + (box && borders.top);
        var width = chart.width,
            height = chart.height;

        if (borderBox) {
          width -= paddings.width + borders.width;
          height -= paddings.height + borders.height;
        }

        return {
          x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
          y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
        };
      }

      function getContainerSize(canvas, width, height) {
        var maxWidth, maxHeight;

        if (width === undefined || height === undefined) {
          var container = _getParentNode(canvas);

          if (!container) {
            width = canvas.clientWidth;
            height = canvas.clientHeight;
          } else {
            var rect = container.getBoundingClientRect();
            var containerStyle = getComputedStyle(container);
            var containerBorder = getPositionedStyle(containerStyle, "border", "width");
            var containerPadding = getPositionedStyle(containerStyle, "padding");
            width = rect.width - containerPadding.width - containerBorder.width;
            height = rect.height - containerPadding.height - containerBorder.height;
            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
          }
        }

        return {
          width: width,
          height: height,
          maxWidth: maxWidth || INFINITY,
          maxHeight: maxHeight || INFINITY
        };
      }

      var round1 = function round1(v) {
        return Math.round(v * 10) / 10;
      };

      function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
        var style = getComputedStyle(canvas);
        var margins = getPositionedStyle(style, "margin");
        var maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
        var maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
        var containerSize = getContainerSize(canvas, bbWidth, bbHeight);
        var width = containerSize.width,
            height = containerSize.height;

        if (style.boxSizing === "content-box") {
          var borders = getPositionedStyle(style, "border", "width");
          var paddings = getPositionedStyle(style, "padding");
          width -= paddings.width + borders.width;
          height -= paddings.height + borders.height;
        }

        width = Math.max(0, width - margins.width);
        height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
        width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
        height = round1(Math.min(height, maxHeight, containerSize.maxHeight));

        if (width && !height) {
          height = round1(width / 2);
        }

        return {
          width: width,
          height: height
        };
      }

      function retinaScale(chart, forceRatio, forceStyle) {
        var pixelRatio = forceRatio || 1;
        var deviceHeight = Math.floor(chart.height * pixelRatio);
        var deviceWidth = Math.floor(chart.width * pixelRatio);
        chart.height = deviceHeight / pixelRatio;
        chart.width = deviceWidth / pixelRatio;
        var canvas = chart.canvas;

        if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
          canvas.style.height = "".concat(chart.height, "px");
          canvas.style.width = "".concat(chart.width, "px");
        }

        if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
          chart.currentDevicePixelRatio = pixelRatio;
          canvas.height = deviceHeight;
          canvas.width = deviceWidth;
          chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          return true;
        }

        return false;
      }

      var supportsEventListenerOptions = function () {
        var passiveSupported = false;

        try {
          var options = {
            get passive() {
              passiveSupported = true;
              return false;
            }

          };
          window.addEventListener("test", null, options);
          window.removeEventListener("test", null, options);
        } catch (e) {}

        return passiveSupported;
      }();

      function readUsedSize(element, property) {
        var value = getStyle(element, property);
        var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
        return matches ? +matches[1] : undefined;
      }

      function _pointInLine(p1, p2, t, mode) {
        return {
          x: p1.x + t * (p2.x - p1.x),
          y: p1.y + t * (p2.y - p1.y)
        };
      }

      function _steppedInterpolation(p1, p2, t, mode) {
        return {
          x: p1.x + t * (p2.x - p1.x),
          y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
        };
      }

      function _bezierInterpolation(p1, p2, t, mode) {
        var cp1 = {
          x: p1.cp2x,
          y: p1.cp2y
        };
        var cp2 = {
          x: p2.cp1x,
          y: p2.cp1y
        };

        var a = _pointInLine(p1, cp1, t);

        var b = _pointInLine(cp1, cp2, t);

        var c = _pointInLine(cp2, p2, t);

        var d = _pointInLine(a, b, t);

        var e = _pointInLine(b, c, t);

        return _pointInLine(d, e, t);
      }

      var intlCache = new Map();

      function getNumberFormat(locale, options) {
        options = options || {};
        var cacheKey = locale + JSON.stringify(options);
        var formatter = intlCache.get(cacheKey);

        if (!formatter) {
          formatter = new Intl.NumberFormat(locale, options);
          intlCache.set(cacheKey, formatter);
        }

        return formatter;
      }

      function formatNumber(num, locale, options) {
        return getNumberFormat(locale, options).format(num);
      }

      var getRightToLeftAdapter = function getRightToLeftAdapter(rectX, width) {
        return {
          x: function x(_x) {
            return rectX + rectX + width - _x;
          },
          setWidth: function setWidth(w) {
            width = w;
          },
          textAlign: function textAlign(align) {
            if (align === "center") {
              return align;
            }

            return align === "right" ? "left" : "right";
          },
          xPlus: function xPlus(x, value) {
            return x - value;
          },
          leftForLtr: function leftForLtr(x, itemWidth) {
            return x - itemWidth;
          }
        };
      };

      var getLeftToRightAdapter = function getLeftToRightAdapter() {
        return {
          x: function x(_x2) {
            return _x2;
          },
          setWidth: function setWidth(w) {},
          textAlign: function textAlign(align) {
            return align;
          },
          xPlus: function xPlus(x, value) {
            return x + value;
          },
          leftForLtr: function leftForLtr(x, _itemWidth) {
            return x;
          }
        };
      };

      function getRtlAdapter(rtl, rectX, width) {
        return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
      }

      function overrideTextDirection(ctx, direction) {
        var style, original;

        if (direction === "ltr" || direction === "rtl") {
          style = ctx.canvas.style;
          original = [style.getPropertyValue("direction"), style.getPropertyPriority("direction")];
          style.setProperty("direction", direction, "important");
          ctx.prevTextDirection = original;
        }
      }

      function restoreTextDirection(ctx, original) {
        if (original !== undefined) {
          delete ctx.prevTextDirection;
          ctx.canvas.style.setProperty("direction", original[0], original[1]);
        }
      }

      function propertyFn(property) {
        if (property === "angle") {
          return {
            between: _angleBetween,
            compare: _angleDiff,
            normalize: _normalizeAngle
          };
        }

        return {
          between: _isBetween,
          compare: function compare(a, b) {
            return a - b;
          },
          normalize: function normalize(x) {
            return x;
          }
        };
      }

      function normalizeSegment(_ref) {
        var start = _ref.start,
            end = _ref.end,
            count = _ref.count,
            loop = _ref.loop,
            style = _ref.style;
        return {
          start: start % count,
          end: end % count,
          loop: loop && (end - start + 1) % count === 0,
          style: style
        };
      }

      function getSegment(segment, points, bounds) {
        var property = bounds.property,
            startBound = bounds.start,
            endBound = bounds.end;

        var _propertyFn = propertyFn(property),
            between = _propertyFn.between,
            normalize = _propertyFn.normalize;

        var count = points.length;
        var start = segment.start,
            end = segment.end,
            loop = segment.loop;
        var i, ilen;

        if (loop) {
          start += count;
          end += count;

          for (i = 0, ilen = count; i < ilen; ++i) {
            if (!between(normalize(points[start % count][property]), startBound, endBound)) {
              break;
            }

            start--;
            end--;
          }

          start %= count;
          end %= count;
        }

        if (end < start) {
          end += count;
        }

        return {
          start: start,
          end: end,
          loop: loop,
          style: segment.style
        };
      }

      function _boundSegment(segment, points, bounds) {
        if (!bounds) {
          return [segment];
        }

        var property = bounds.property,
            startBound = bounds.start,
            endBound = bounds.end;
        var count = points.length;

        var _propertyFn2 = propertyFn(property),
            compare = _propertyFn2.compare,
            between = _propertyFn2.between,
            normalize = _propertyFn2.normalize;

        var _getSegment = getSegment(segment, points, bounds),
            start = _getSegment.start,
            end = _getSegment.end,
            loop = _getSegment.loop,
            style = _getSegment.style;

        var result = [];
        var inside = false;
        var subStart = null;
        var value, point, prevValue;

        var startIsBefore = function startIsBefore() {
          return between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
        };

        var endIsBefore = function endIsBefore() {
          return compare(endBound, value) === 0 || between(endBound, prevValue, value);
        };

        var shouldStart = function shouldStart() {
          return inside || startIsBefore();
        };

        var shouldStop = function shouldStop() {
          return !inside || endIsBefore();
        };

        for (var i = start, prev = start; i <= end; ++i) {
          point = points[i % count];

          if (point.skip) {
            continue;
          }

          value = normalize(point[property]);

          if (value === prevValue) {
            continue;
          }

          inside = between(value, startBound, endBound);

          if (subStart === null && shouldStart()) {
            subStart = compare(value, startBound) === 0 ? i : prev;
          }

          if (subStart !== null && shouldStop()) {
            result.push(normalizeSegment({
              start: subStart,
              end: i,
              loop: loop,
              count: count,
              style: style
            }));
            subStart = null;
          }

          prev = i;
          prevValue = value;
        }

        if (subStart !== null) {
          result.push(normalizeSegment({
            start: subStart,
            end: end,
            loop: loop,
            count: count,
            style: style
          }));
        }

        return result;
      }

      function _boundSegments(line, bounds) {
        var result = [];
        var segments = line.segments;

        for (var i = 0; i < segments.length; i++) {
          var sub = _boundSegment(segments[i], line.points, bounds);

          if (sub.length) {
            result.push.apply(result, _toConsumableArray(sub));
          }
        }

        return result;
      }

      function findStartAndEnd(points, count, loop, spanGaps) {
        var start = 0;
        var end = count - 1;

        if (loop && !spanGaps) {
          while (start < count && !points[start].skip) {
            start++;
          }
        }

        while (start < count && points[start].skip) {
          start++;
        }

        start %= count;

        if (loop) {
          end += start;
        }

        while (end > start && points[end % count].skip) {
          end--;
        }

        end %= count;
        return {
          start: start,
          end: end
        };
      }

      function solidSegments(points, start, max, loop) {
        var count = points.length;
        var result = [];
        var last = start;
        var prev = points[start];
        var end;

        for (end = start + 1; end <= max; ++end) {
          var cur = points[end % count];

          if (cur.skip || cur.stop) {
            if (!prev.skip) {
              loop = false;
              result.push({
                start: start % count,
                end: (end - 1) % count,
                loop: loop
              });
              start = last = cur.stop ? end : null;
            }
          } else {
            last = end;

            if (prev.skip) {
              start = end;
            }
          }

          prev = cur;
        }

        if (last !== null) {
          result.push({
            start: start % count,
            end: last % count,
            loop: loop
          });
        }

        return result;
      }

      function _computeSegments(line, segmentOptions) {
        var points = line.points;
        var spanGaps = line.options.spanGaps;
        var count = points.length;

        if (!count) {
          return [];
        }

        var loop = !!line._loop;

        var _findStartAndEnd = findStartAndEnd(points, count, loop, spanGaps),
            start = _findStartAndEnd.start,
            end = _findStartAndEnd.end;

        if (spanGaps === true) {
          return splitByStyles(line, [{
            start: start,
            end: end,
            loop: loop
          }], points, segmentOptions);
        }

        var max = end < start ? end + count : end;
        var completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
        return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
      }

      function splitByStyles(line, segments, points, segmentOptions) {
        if (!segmentOptions || !segmentOptions.setContext || !points) {
          return segments;
        }

        return doSplitByStyles(line, segments, points, segmentOptions);
      }

      function doSplitByStyles(line, segments, points, segmentOptions) {
        var chartContext = line._chart.getContext();

        var baseStyle = readStyle(line.options);
        var datasetIndex = line._datasetIndex,
            spanGaps = line.options.spanGaps;
        var count = points.length;
        var result = [];
        var prevStyle = baseStyle;
        var start = segments[0].start;
        var i = start;

        function addStyle(s, e, l, st) {
          var dir = spanGaps ? -1 : 1;

          if (s === e) {
            return;
          }

          s += count;

          while (points[s % count].skip) {
            s -= dir;
          }

          while (points[e % count].skip) {
            e += dir;
          }

          if (s % count !== e % count) {
            result.push({
              start: s % count,
              end: e % count,
              loop: l,
              style: st
            });
            prevStyle = st;
            start = e % count;
          }
        }

        var _iterator11 = _createForOfIteratorHelper(segments),
            _step11;

        try {
          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            var segment = _step11.value;
            start = spanGaps ? start : segment.start;
            var prev = points[start % count];
            var style = void 0;

            for (i = start + 1; i <= segment.end; i++) {
              var pt = points[i % count];
              style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                type: "segment",
                p0: prev,
                p1: pt,
                p0DataIndex: (i - 1) % count,
                p1DataIndex: i % count,
                datasetIndex: datasetIndex
              })));

              if (styleChanged(style, prevStyle)) {
                addStyle(start, i - 1, segment.loop, prevStyle);
              }

              prev = pt;
              prevStyle = style;
            }

            if (start < i - 1) {
              addStyle(start, i - 1, segment.loop, prevStyle);
            }
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }

        return result;
      }

      function readStyle(options) {
        return {
          backgroundColor: options.backgroundColor,
          borderCapStyle: options.borderCapStyle,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderJoinStyle: options.borderJoinStyle,
          borderWidth: options.borderWidth,
          borderColor: options.borderColor
        };
      }

      function styleChanged(style, prevStyle) {
        return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
      }

      class Animator {
        constructor() {
          this._request = null;
          this._charts = new Map();
          this._running = false;
          this._lastDate = undefined;
        }
        _notify(chart, anims, date, type) {
          const callbacks = anims.listeners[type];
          const numSteps = anims.duration;
          callbacks.forEach(fn => fn({
            chart,
            initial: anims.initial,
            numSteps,
            currentStep: Math.min(date - anims.start, numSteps)
          }));
        }
        _refresh() {
          if (this._request) {
            return;
          }
          this._running = true;
          this._request = requestAnimFrame.call(window, () => {
            this._update();
            this._request = null;
            if (this._running) {
              this._refresh();
            }
          });
        }
        _update(date = Date.now()) {
          let remaining = 0;
          this._charts.forEach((anims, chart) => {
            if (!anims.running || !anims.items.length) {
              return;
            }
            const items = anims.items;
            let i = items.length - 1;
            let draw = false;
            let item;
            for (; i >= 0; --i) {
              item = items[i];
              if (item._active) {
                if (item._total > anims.duration) {
                  anims.duration = item._total;
                }
                item.tick(date);
                draw = true;
              } else {
                items[i] = items[items.length - 1];
                items.pop();
              }
            }
            if (draw) {
              chart.draw();
              this._notify(chart, anims, date, "progress");
            }
            if (!items.length) {
              anims.running = false;
              this._notify(chart, anims, date, "complete");
              anims.initial = false;
            }
            remaining += items.length;
          });
          this._lastDate = date;
          if (remaining === 0) {
            this._running = false;
          }
        }
        _getAnims(chart) {
          const charts = this._charts;
          let anims = charts.get(chart);
          if (!anims) {
            anims = {
              running: false,
              initial: true,
              items: [],
              listeners: {
                complete: [],
                progress: []
              }
            };
            charts.set(chart, anims);
          }
          return anims;
        }
        listen(chart, event, cb) {
          this._getAnims(chart).listeners[event].push(cb);
        }
        add(chart, items) {
          if (!items || !items.length) {
            return;
          }
          this._getAnims(chart).items.push(...items);
        }
        has(chart) {
          return this._getAnims(chart).items.length > 0;
        }
        start(chart) {
          const anims = this._charts.get(chart);
          if (!anims) {
            return;
          }
          anims.running = true;
          anims.start = Date.now();
          anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
          this._refresh();
        }
        running(chart) {
          if (!this._running) {
            return false;
          }
          const anims = this._charts.get(chart);
          if (!anims || !anims.running || !anims.items.length) {
            return false;
          }
          return true;
        }
        stop(chart) {
          const anims = this._charts.get(chart);
          if (!anims || !anims.items.length) {
            return;
          }
          const items = anims.items;
          let i = items.length - 1;
          for (; i >= 0; --i) {
            items[i].cancel();
          }
          anims.items = [];
          this._notify(chart, anims, Date.now(), "complete");
        }
        remove(chart) {
          return this._charts.delete(chart);
        }
      }
      var animator = new Animator();
      const transparent = "transparent";
      const interpolators = {
        boolean(from, to, factor) {
          return factor > 0.5 ? to : from;
        },
        color(from, to, factor) {
          const c0 = color(from || transparent);
          const c1 = c0.valid && color(to || transparent);
          return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
        },
        number(from, to, factor) {
          return from + (to - from) * factor;
        }
      };
      class Animation {
        constructor(cfg, target, prop, to) {
          const currentValue = target[prop];
          to = resolve([
            cfg.to,
            to,
            currentValue,
            cfg.from
          ]);
          const from = resolve([
            cfg.from,
            currentValue,
            to
          ]);
          this._active = true;
          this._fn = cfg.fn || interpolators[cfg.type || typeof from];
          this._easing = effects[cfg.easing] || effects.linear;
          this._start = Math.floor(Date.now() + (cfg.delay || 0));
          this._duration = this._total = Math.floor(cfg.duration);
          this._loop = !!cfg.loop;
          this._target = target;
          this._prop = prop;
          this._from = from;
          this._to = to;
          this._promises = undefined;
        }
        active() {
          return this._active;
        }
        update(cfg, to, date) {
          if (this._active) {
            this._notify(false);
            const currentValue = this._target[this._prop];
            const elapsed = date - this._start;
            const remain = this._duration - elapsed;
            this._start = date;
            this._duration = Math.floor(Math.max(remain, cfg.duration));
            this._total += elapsed;
            this._loop = !!cfg.loop;
            this._to = resolve([
              cfg.to,
              to,
              currentValue,
              cfg.from
            ]);
            this._from = resolve([
              cfg.from,
              currentValue,
              to
            ]);
          }
        }
        cancel() {
          if (this._active) {
            this.tick(Date.now());
            this._active = false;
            this._notify(false);
          }
        }
        tick(date) {
          const elapsed = date - this._start;
          const duration = this._duration;
          const prop = this._prop;
          const from = this._from;
          const loop = this._loop;
          const to = this._to;
          let factor;
          this._active = from !== to && (loop || elapsed < duration);
          if (!this._active) {
            this._target[prop] = to;
            this._notify(true);
            return;
          }
          if (elapsed < 0) {
            this._target[prop] = from;
            return;
          }
          factor = elapsed / duration % 2;
          factor = loop && factor > 1 ? 2 - factor : factor;
          factor = this._easing(Math.min(1, Math.max(0, factor)));
          this._target[prop] = this._fn(from, to, factor);
        }
        wait() {
          const promises = this._promises || (this._promises = []);
          return new Promise((res, rej) => {
            promises.push({
              res,
              rej
            });
          });
        }
        _notify(resolved) {
          const method = resolved ? "res" : "rej";
          const promises = this._promises || [];
          for (let i = 0; i < promises.length; i++) {
            promises[i][method]();
          }
        }
      }
      const numbers = [
        "x",
        "y",
        "borderWidth",
        "radius",
        "tension"
      ];
      const colors = [
        "color",
        "borderColor",
        "backgroundColor"
      ];
      defaults.set("animation", {
        delay: undefined,
        duration: 1000,
        easing: "easeOutQuart",
        fn: undefined,
        from: undefined,
        loop: undefined,
        to: undefined,
        type: undefined
      });
      const animationOptions = Object.keys(defaults.animation);
      defaults.describe("animation", {
        _fallback: false,
        _indexable: false,
        _scriptable: name => name !== "onProgress" && name !== "onComplete" && name !== "fn"
      });
      defaults.set("animations", {
        colors: {
          type: "color",
          properties: colors
        },
        numbers: {
          type: "number",
          properties: numbers
        }
      });
      defaults.describe("animations", { _fallback: "animation" });
      defaults.set("transitions", {
        active: { animation: { duration: 400 } },
        resize: { animation: { duration: 0 } },
        show: {
          animations: {
            colors: { from: "transparent" },
            visible: {
              type: "boolean",
              duration: 0
            }
          }
        },
        hide: {
          animations: {
            colors: { to: "transparent" },
            visible: {
              type: "boolean",
              easing: "linear",
              fn: v => v | 0
            }
          }
        }
      });
      class Animations {
        constructor(chart, config) {
          this._chart = chart;
          this._properties = new Map();
          this.configure(config);
        }
        configure(config) {
          if (!isObject(config)) {
            return;
          }
          const animatedProps = this._properties;
          Object.getOwnPropertyNames(config).forEach(key => {
            const cfg = config[key];
            if (!isObject(cfg)) {
              return;
            }
            const resolved = {};
            for (const option of animationOptions) {
              resolved[option] = cfg[option];
            }
            (isArray(cfg.properties) && cfg.properties || [key]).forEach(prop => {
              if (prop === key || !animatedProps.has(prop)) {
                animatedProps.set(prop, resolved);
              }
            });
          });
        }
        _animateOptions(target, values) {
          const newOptions = values.options;
          const options = resolveTargetOptions(target, newOptions);
          if (!options) {
            return [];
          }
          const animations = this._createAnimations(options, newOptions);
          if (newOptions.$shared) {
            awaitAll(target.options.$animations, newOptions).then(() => {
              target.options = newOptions;
            }, () => {
            });
          }
          return animations;
        }
        _createAnimations(target, values) {
          const animatedProps = this._properties;
          const animations = [];
          const running = target.$animations || (target.$animations = {});
          const props = Object.keys(values);
          const date = Date.now();
          let i;
          for (i = props.length - 1; i >= 0; --i) {
            const prop = props[i];
            if (prop.charAt(0) === "$") {
              continue;
            }
            if (prop === "options") {
              animations.push(...this._animateOptions(target, values));
              continue;
            }
            const value = values[prop];
            let animation = running[prop];
            const cfg = animatedProps.get(prop);
            if (animation) {
              if (cfg && animation.active()) {
                animation.update(cfg, value, date);
                continue;
              } else {
                animation.cancel();
              }
            }
            if (!cfg || !cfg.duration) {
              target[prop] = value;
              continue;
            }
            running[prop] = animation = new Animation(cfg, target, prop, value);
            animations.push(animation);
          }
          return animations;
        }
        update(target, values) {
          if (this._properties.size === 0) {
            Object.assign(target, values);
            return;
          }
          const animations = this._createAnimations(target, values);
          if (animations.length) {
            animator.add(this._chart, animations);
            return true;
          }
        }
      }
      function awaitAll(animations, properties) {
        const running = [];
        const keys = Object.keys(properties);
        for (let i = 0; i < keys.length; i++) {
          const anim = animations[keys[i]];
          if (anim && anim.active()) {
            running.push(anim.wait());
          }
        }
        return Promise.all(running);
      }
      function resolveTargetOptions(target, newOptions) {
        if (!newOptions) {
          return;
        }
        let options = target.options;
        if (!options) {
          target.options = newOptions;
          return;
        }
        if (options.$shared) {
          target.options = options = Object.assign({}, options, {
            $shared: false,
            $animations: {}
          });
        }
        return options;
      }
      function scaleClip(scale, allowedOverflow) {
        const opts = scale && scale.options || {};
        const reverse = opts.reverse;
        const min = opts.min === undefined ? allowedOverflow : 0;
        const max = opts.max === undefined ? allowedOverflow : 0;
        return {
          start: reverse ? max : min,
          end: reverse ? min : max
        };
      }
      function defaultClip(xScale, yScale, allowedOverflow) {
        if (allowedOverflow === false) {
          return false;
        }
        const x = scaleClip(xScale, allowedOverflow);
        const y = scaleClip(yScale, allowedOverflow);
        return {
          top: y.end,
          right: x.end,
          bottom: y.start,
          left: x.start
        };
      }
      function toClip(value) {
        let t, r, b, l;
        if (isObject(value)) {
          t = value.top;
          r = value.right;
          b = value.bottom;
          l = value.left;
        } else {
          t = r = b = l = value;
        }
        return {
          top: t,
          right: r,
          bottom: b,
          left: l,
          disabled: value === false
        };
      }
      function getSortedDatasetIndices(chart, filterVisible) {
        const keys = [];
        const metasets = chart._getSortedDatasetMetas(filterVisible);
        let i, ilen;
        for (i = 0, ilen = metasets.length; i < ilen; ++i) {
          keys.push(metasets[i].index);
        }
        return keys;
      }
      function applyStack(stack, value, dsIndex, options = {}) {
        const keys = stack.keys;
        const singleMode = options.mode === "single";
        let i, ilen, datasetIndex, otherValue;
        if (value === null) {
          return;
        }
        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          datasetIndex = +keys[i];
          if (datasetIndex === dsIndex) {
            if (options.all) {
              continue;
            }
            break;
          }
          otherValue = stack.values[datasetIndex];
          if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
            value += otherValue;
          }
        }
        return value;
      }
      function convertObjectDataToArray(data) {
        const keys = Object.keys(data);
        const adata = new Array(keys.length);
        let i, ilen, key;
        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          adata[i] = {
            x: key,
            y: data[key]
          };
        }
        return adata;
      }
      function isStacked(scale, meta) {
        const stacked = scale && scale.options.stacked;
        return stacked || stacked === undefined && meta.stack !== undefined;
      }
      function getStackKey(indexScale, valueScale, meta) {
        return `${ indexScale.id }.${ valueScale.id }.${ meta.stack || meta.type }`;
      }
      function getUserBounds(scale) {
        const {min, max, minDefined, maxDefined} = scale.getUserBounds();
        return {
          min: minDefined ? min : Number.NEGATIVE_INFINITY,
          max: maxDefined ? max : Number.POSITIVE_INFINITY
        };
      }
      function getOrCreateStack(stacks, stackKey, indexValue) {
        const subStack = stacks[stackKey] || (stacks[stackKey] = {});
        return subStack[indexValue] || (subStack[indexValue] = {});
      }
      function getLastIndexInStack(stack, vScale, positive, type) {
        for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
          const value = stack[meta.index];
          if (positive && value > 0 || !positive && value < 0) {
            return meta.index;
          }
        }
        return null;
      }
      function updateStacks(controller, parsed) {
        const {
          chart,
          _cachedMeta: meta
        } = controller;
        const stacks = chart._stacks || (chart._stacks = {});
        const {
          iScale,
          vScale,
          index: datasetIndex
        } = meta;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const key = getStackKey(iScale, vScale, meta);
        const ilen = parsed.length;
        let stack;
        for (let i = 0; i < ilen; ++i) {
          const item = parsed[i];
          const {
            [iAxis]: index,
            [vAxis]: value
          } = item;
          const itemStacks = item._stacks || (item._stacks = {});
          stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
          stack[datasetIndex] = value;
          stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
          stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
        }
      }
      function getFirstScaleId(chart, axis) {
        const scales = chart.scales;
        return Object.keys(scales).filter(key => scales[key].axis === axis).shift();
      }
      function createDatasetContext(parent, index) {
        return createContext(parent, {
          active: false,
          dataset: undefined,
          datasetIndex: index,
          index,
          mode: "default",
          type: "dataset"
        });
      }
      function createDataContext(parent, index, element) {
        return createContext(parent, {
          active: false,
          dataIndex: index,
          parsed: undefined,
          raw: undefined,
          element,
          index,
          mode: "default",
          type: "data"
        });
      }
      function clearStacks(meta, items) {
        const datasetIndex = meta.controller.index;
        const axis = meta.vScale && meta.vScale.axis;
        if (!axis) {
          return;
        }
        items = items || meta._parsed;
        for (const parsed of items) {
          const stacks = parsed._stacks;
          if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {
            return;
          }
          delete stacks[axis][datasetIndex];
        }
      }
      const isDirectUpdateMode = mode => mode === "reset" || mode === "none";
      const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
      const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
        keys: getSortedDatasetIndices(chart, true),
        values: null
      };
      class DatasetController {
        constructor(chart, datasetIndex) {
          this.chart = chart;
          this._ctx = chart.ctx;
          this.index = datasetIndex;
          this._cachedDataOpts = {};
          this._cachedMeta = this.getMeta();
          this._type = this._cachedMeta.type;
          this.options = undefined;
          this._parsing = false;
          this._data = undefined;
          this._objectData = undefined;
          this._sharedOptions = undefined;
          this._drawStart = undefined;
          this._drawCount = undefined;
          this.enableOptionSharing = false;
          this.supportsDecimation = false;
          this.$context = undefined;
          this._syncList = [];
          this.initialize();
        }
        initialize() {
          const meta = this._cachedMeta;
          this.configure();
          this.linkScales();
          meta._stacked = isStacked(meta.vScale, meta);
          this.addElements();
        }
        updateIndex(datasetIndex) {
          if (this.index !== datasetIndex) {
            clearStacks(this._cachedMeta);
          }
          this.index = datasetIndex;
        }
        linkScales() {
          const chart = this.chart;
          const meta = this._cachedMeta;
          const dataset = this.getDataset();
          const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
          const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
          const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
          const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
          const indexAxis = meta.indexAxis;
          const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
          const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
          meta.xScale = this.getScaleForId(xid);
          meta.yScale = this.getScaleForId(yid);
          meta.rScale = this.getScaleForId(rid);
          meta.iScale = this.getScaleForId(iid);
          meta.vScale = this.getScaleForId(vid);
        }
        getDataset() {
          return this.chart.data.datasets[this.index];
        }
        getMeta() {
          return this.chart.getDatasetMeta(this.index);
        }
        getScaleForId(scaleID) {
          return this.chart.scales[scaleID];
        }
        _getOtherScale(scale) {
          const meta = this._cachedMeta;
          return scale === meta.iScale ? meta.vScale : meta.iScale;
        }
        reset() {
          this._update("reset");
        }
        _destroy() {
          const meta = this._cachedMeta;
          if (this._data) {
            unlistenArrayEvents(this._data, this);
          }
          if (meta._stacked) {
            clearStacks(meta);
          }
        }
        _dataCheck() {
          const dataset = this.getDataset();
          const data = dataset.data || (dataset.data = []);
          const _data = this._data;
          if (isObject(data)) {
            this._data = convertObjectDataToArray(data);
          } else if (_data !== data) {
            if (_data) {
              unlistenArrayEvents(_data, this);
              const meta = this._cachedMeta;
              clearStacks(meta);
              meta._parsed = [];
            }
            if (data && Object.isExtensible(data)) {
              listenArrayEvents(data, this);
            }
            this._syncList = [];
            this._data = data;
          }
        }
        addElements() {
          const meta = this._cachedMeta;
          this._dataCheck();
          if (this.datasetElementType) {
            meta.dataset = new this.datasetElementType();
          }
        }
        buildOrUpdateElements(resetNewElements) {
          const meta = this._cachedMeta;
          const dataset = this.getDataset();
          let stackChanged = false;
          this._dataCheck();
          const oldStacked = meta._stacked;
          meta._stacked = isStacked(meta.vScale, meta);
          if (meta.stack !== dataset.stack) {
            stackChanged = true;
            clearStacks(meta);
            meta.stack = dataset.stack;
          }
          this._resyncElements(resetNewElements);
          if (stackChanged || oldStacked !== meta._stacked) {
            updateStacks(this, meta._parsed);
          }
        }
        configure() {
          const config = this.chart.config;
          const scopeKeys = config.datasetScopeKeys(this._type);
          const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
          this.options = config.createResolver(scopes, this.getContext());
          this._parsing = this.options.parsing;
          this._cachedDataOpts = {};
        }
        parse(start, count) {
          const {
            _cachedMeta: meta,
            _data: data
          } = this;
          const {iScale, _stacked} = meta;
          const iAxis = iScale.axis;
          let sorted = start === 0 && count === data.length ? true : meta._sorted;
          let prev = start > 0 && meta._parsed[start - 1];
          let i, cur, parsed;
          if (this._parsing === false) {
            meta._parsed = data;
            meta._sorted = true;
            parsed = data;
          } else {
            if (isArray(data[start])) {
              parsed = this.parseArrayData(meta, data, start, count);
            } else if (isObject(data[start])) {
              parsed = this.parseObjectData(meta, data, start, count);
            } else {
              parsed = this.parsePrimitiveData(meta, data, start, count);
            }
            const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
            for (i = 0; i < count; ++i) {
              meta._parsed[i + start] = cur = parsed[i];
              if (sorted) {
                if (isNotInOrderComparedToPrev()) {
                  sorted = false;
                }
                prev = cur;
              }
            }
            meta._sorted = sorted;
          }
          if (_stacked) {
            updateStacks(this, parsed);
          }
        }
        parsePrimitiveData(meta, data, start, count) {
          const {iScale, vScale} = meta;
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const labels = iScale.getLabels();
          const singleScale = iScale === vScale;
          const parsed = new Array(count);
          let i, ilen, index;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index = i + start;
            parsed[i] = {
              [iAxis]: singleScale || iScale.parse(labels[index], index),
              [vAxis]: vScale.parse(data[index], index)
            };
          }
          return parsed;
        }
        parseArrayData(meta, data, start, count) {
          const {xScale, yScale} = meta;
          const parsed = new Array(count);
          let i, ilen, index, item;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index = i + start;
            item = data[index];
            parsed[i] = {
              x: xScale.parse(item[0], index),
              y: yScale.parse(item[1], index)
            };
          }
          return parsed;
        }
        parseObjectData(meta, data, start, count) {
          const {xScale, yScale} = meta;
          const {xAxisKey = "x", yAxisKey = "y"} = this._parsing;
          const parsed = new Array(count);
          let i, ilen, index, item;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index = i + start;
            item = data[index];
            parsed[i] = {
              x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
              y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
            };
          }
          return parsed;
        }
        getParsed(index) {
          return this._cachedMeta._parsed[index];
        }
        getDataElement(index) {
          return this._cachedMeta.data[index];
        }
        applyStack(scale, parsed, mode) {
          const chart = this.chart;
          const meta = this._cachedMeta;
          const value = parsed[scale.axis];
          const stack = {
            keys: getSortedDatasetIndices(chart, true),
            values: parsed._stacks[scale.axis]
          };
          return applyStack(stack, value, meta.index, { mode });
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
          const parsedValue = parsed[scale.axis];
          let value = parsedValue === null ? NaN : parsedValue;
          const values = stack && parsed._stacks[scale.axis];
          if (stack && values) {
            stack.values = values;
            value = applyStack(stack, parsedValue, this._cachedMeta.index);
          }
          range.min = Math.min(range.min, value);
          range.max = Math.max(range.max, value);
        }
        getMinMax(scale, canStack) {
          const meta = this._cachedMeta;
          const _parsed = meta._parsed;
          const sorted = meta._sorted && scale === meta.iScale;
          const ilen = _parsed.length;
          const otherScale = this._getOtherScale(scale);
          const stack = createStack(canStack, meta, this.chart);
          const range = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
          };
          const {
            min: otherMin,
            max: otherMax
          } = getUserBounds(otherScale);
          let i, parsed;
          function _skip() {
            parsed = _parsed[i];
            const otherValue = parsed[otherScale.axis];
            return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
          }
          for (i = 0; i < ilen; ++i) {
            if (_skip()) {
              continue;
            }
            this.updateRangeFromParsed(range, scale, parsed, stack);
            if (sorted) {
              break;
            }
          }
          if (sorted) {
            for (i = ilen - 1; i >= 0; --i) {
              if (_skip()) {
                continue;
              }
              this.updateRangeFromParsed(range, scale, parsed, stack);
              break;
            }
          }
          return range;
        }
        getAllParsedValues(scale) {
          const parsed = this._cachedMeta._parsed;
          const values = [];
          let i, ilen, value;
          for (i = 0, ilen = parsed.length; i < ilen; ++i) {
            value = parsed[i][scale.axis];
            if (isNumberFinite(value)) {
              values.push(value);
            }
          }
          return values;
        }
        getMaxOverflow() {
          return false;
        }
        getLabelAndValue(index) {
          const meta = this._cachedMeta;
          const iScale = meta.iScale;
          const vScale = meta.vScale;
          const parsed = this.getParsed(index);
          return {
            label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
            value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
          };
        }
        _update(mode) {
          const meta = this._cachedMeta;
          this.update(mode || "default");
          meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
        }
        update(mode) {
        }
        draw() {
          const ctx = this._ctx;
          const chart = this.chart;
          const meta = this._cachedMeta;
          const elements = meta.data || [];
          const area = chart.chartArea;
          const active = [];
          const start = this._drawStart || 0;
          const count = this._drawCount || elements.length - start;
          const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
          let i;
          if (meta.dataset) {
            meta.dataset.draw(ctx, area, start, count);
          }
          for (i = start; i < start + count; ++i) {
            const element = elements[i];
            if (element.hidden) {
              continue;
            }
            if (element.active && drawActiveElementsOnTop) {
              active.push(element);
            } else {
              element.draw(ctx, area);
            }
          }
          for (i = 0; i < active.length; ++i) {
            active[i].draw(ctx, area);
          }
        }
        getStyle(index, active) {
          const mode = active ? "active" : "default";
          return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
        }
        getContext(index, active, mode) {
          const dataset = this.getDataset();
          let context;
          if (index >= 0 && index < this._cachedMeta.data.length) {
            const element = this._cachedMeta.data[index];
            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
            context.parsed = this.getParsed(index);
            context.raw = dataset.data[index];
            context.index = context.dataIndex = index;
          } else {
            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
            context.dataset = dataset;
            context.index = context.datasetIndex = this.index;
          }
          context.active = !!active;
          context.mode = mode;
          return context;
        }
        resolveDatasetElementOptions(mode) {
          return this._resolveElementOptions(this.datasetElementType.id, mode);
        }
        resolveDataElementOptions(index, mode) {
          return this._resolveElementOptions(this.dataElementType.id, mode, index);
        }
        _resolveElementOptions(elementType, mode = "default", index) {
          const active = mode === "active";
          const cache = this._cachedDataOpts;
          const cacheKey = elementType + "-" + mode;
          const cached = cache[cacheKey];
          const sharing = this.enableOptionSharing && defined(index);
          if (cached) {
            return cloneIfNotShared(cached, sharing);
          }
          const config = this.chart.config;
          const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
          const prefixes = active ? [
            `${ elementType }Hover`,
            "hover",
            elementType,
            ""
          ] : [
            elementType,
            ""
          ];
          const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
          const names = Object.keys(defaults.elements[elementType]);
          const context = () => this.getContext(index, active);
          const values = config.resolveNamedOptions(scopes, names, context, prefixes);
          if (values.$shared) {
            values.$shared = sharing;
            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
          }
          return values;
        }
        _resolveAnimations(index, transition, active) {
          const chart = this.chart;
          const cache = this._cachedDataOpts;
          const cacheKey = `animation-${ transition }`;
          const cached = cache[cacheKey];
          if (cached) {
            return cached;
          }
          let options;
          if (chart.options.animation !== false) {
            const config = this.chart.config;
            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            options = config.createResolver(scopes, this.getContext(index, active, transition));
          }
          const animations = new Animations(chart, options && options.animations);
          if (options && options._cacheable) {
            cache[cacheKey] = Object.freeze(animations);
          }
          return animations;
        }
        getSharedOptions(options) {
          if (!options.$shared) {
            return;
          }
          return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
        }
        includeOptions(mode, sharedOptions) {
          return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
        }
        _getSharedOptions(start, mode) {
          const firstOpts = this.resolveDataElementOptions(start, mode);
          const previouslySharedOptions = this._sharedOptions;
          const sharedOptions = this.getSharedOptions(firstOpts);
          const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
          this.updateSharedOptions(sharedOptions, mode, firstOpts);
          return {
            sharedOptions,
            includeOptions
          };
        }
        updateElement(element, index, properties, mode) {
          if (isDirectUpdateMode(mode)) {
            Object.assign(element, properties);
          } else {
            this._resolveAnimations(index, mode).update(element, properties);
          }
        }
        updateSharedOptions(sharedOptions, mode, newOptions) {
          if (sharedOptions && !isDirectUpdateMode(mode)) {
            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
          }
        }
        _setStyle(element, index, mode, active) {
          element.active = active;
          const options = this.getStyle(index, active);
          this._resolveAnimations(index, mode, active).update(element, { options: !active && this.getSharedOptions(options) || options });
        }
        removeHoverStyle(element, datasetIndex, index) {
          this._setStyle(element, index, "active", false);
        }
        setHoverStyle(element, datasetIndex, index) {
          this._setStyle(element, index, "active", true);
        }
        _removeDatasetHoverStyle() {
          const element = this._cachedMeta.dataset;
          if (element) {
            this._setStyle(element, undefined, "active", false);
          }
        }
        _setDatasetHoverStyle() {
          const element = this._cachedMeta.dataset;
          if (element) {
            this._setStyle(element, undefined, "active", true);
          }
        }
        _resyncElements(resetNewElements) {
          const data = this._data;
          const elements = this._cachedMeta.data;
          for (const [method, arg1, arg2] of this._syncList) {
            this[method](arg1, arg2);
          }
          this._syncList = [];
          const numMeta = elements.length;
          const numData = data.length;
          const count = Math.min(numData, numMeta);
          if (count) {
            this.parse(0, count);
          }
          if (numData > numMeta) {
            this._insertElements(numMeta, numData - numMeta, resetNewElements);
          } else if (numData < numMeta) {
            this._removeElements(numData, numMeta - numData);
          }
        }
        _insertElements(start, count, resetNewElements = true) {
          const meta = this._cachedMeta;
          const data = meta.data;
          const end = start + count;
          let i;
          const move = arr => {
            arr.length += count;
            for (i = arr.length - 1; i >= end; i--) {
              arr[i] = arr[i - count];
            }
          };
          move(data);
          for (i = start; i < end; ++i) {
            data[i] = new this.dataElementType();
          }
          if (this._parsing) {
            move(meta._parsed);
          }
          this.parse(start, count);
          if (resetNewElements) {
            this.updateElements(data, start, count, "reset");
          }
        }
        updateElements(element, start, count, mode) {
        }
        _removeElements(start, count) {
          const meta = this._cachedMeta;
          if (this._parsing) {
            const removed = meta._parsed.splice(start, count);
            if (meta._stacked) {
              clearStacks(meta, removed);
            }
          }
          meta.data.splice(start, count);
        }
        _sync(args) {
          if (this._parsing) {
            this._syncList.push(args);
          } else {
            const [method, arg1, arg2] = args;
            this[method](arg1, arg2);
          }
          this.chart._dataChanges.push([
            this.index,
            ...args
          ]);
        }
        _onDataPush() {
          const count = arguments.length;
          this._sync([
            "_insertElements",
            this.getDataset().data.length - count,
            count
          ]);
        }
        _onDataPop() {
          this._sync([
            "_removeElements",
            this._cachedMeta.data.length - 1,
            1
          ]);
        }
        _onDataShift() {
          this._sync([
            "_removeElements",
            0,
            1
          ]);
        }
        _onDataSplice(start, count) {
          if (count) {
            this._sync([
              "_removeElements",
              start,
              count
            ]);
          }
          const newCount = arguments.length - 2;
          if (newCount) {
            this._sync([
              "_insertElements",
              start,
              newCount
            ]);
          }
        }
        _onDataUnshift() {
          this._sync([
            "_insertElements",
            0,
            arguments.length
          ]);
        }
      }
      DatasetController.defaults = {};
      DatasetController.prototype.datasetElementType = null;
      DatasetController.prototype.dataElementType = null;
      function getAllScaleValues(scale, type) {
        if (!scale._cache.$bar) {
          const visibleMetas = scale.getMatchingVisibleMetas(type);
          let values = [];
          for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
          }
          scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
        }
        return scale._cache.$bar;
      }
      function computeMinSampleSize(meta) {
        const scale = meta.iScale;
        const values = getAllScaleValues(scale, meta.type);
        let min = scale._length;
        let i, ilen, curr, prev;
        const updateMinAndPrev = () => {
          if (curr === 32767 || curr === -32768) {
            return;
          }
          if (defined(prev)) {
            min = Math.min(min, Math.abs(curr - prev) || min);
          }
          prev = curr;
        };
        for (i = 0, ilen = values.length; i < ilen; ++i) {
          curr = scale.getPixelForValue(values[i]);
          updateMinAndPrev();
        }
        prev = undefined;
        for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
          curr = scale.getPixelForTick(i);
          updateMinAndPrev();
        }
        return min;
      }
      function computeFitCategoryTraits(index, ruler, options, stackCount) {
        const thickness = options.barThickness;
        let size, ratio;
        if (isNullOrUndef(thickness)) {
          size = ruler.min * options.categoryPercentage;
          ratio = options.barPercentage;
        } else {
          size = thickness * stackCount;
          ratio = 1;
        }
        return {
          chunk: size / stackCount,
          ratio,
          start: ruler.pixels[index] - size / 2
        };
      }
      function computeFlexCategoryTraits(index, ruler, options, stackCount) {
        const pixels = ruler.pixels;
        const curr = pixels[index];
        let prev = index > 0 ? pixels[index - 1] : null;
        let next = index < pixels.length - 1 ? pixels[index + 1] : null;
        const percent = options.categoryPercentage;
        if (prev === null) {
          prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
        }
        if (next === null) {
          next = curr + curr - prev;
        }
        const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
        const size = Math.abs(next - prev) / 2 * percent;
        return {
          chunk: size / stackCount,
          ratio: options.barPercentage,
          start
        };
      }
      function parseFloatBar(entry, item, vScale, i) {
        const startValue = vScale.parse(entry[0], i);
        const endValue = vScale.parse(entry[1], i);
        const min = Math.min(startValue, endValue);
        const max = Math.max(startValue, endValue);
        let barStart = min;
        let barEnd = max;
        if (Math.abs(min) > Math.abs(max)) {
          barStart = max;
          barEnd = min;
        }
        item[vScale.axis] = barEnd;
        item._custom = {
          barStart,
          barEnd,
          start: startValue,
          end: endValue,
          min,
          max
        };
      }
      function parseValue(entry, item, vScale, i) {
        if (isArray(entry)) {
          parseFloatBar(entry, item, vScale, i);
        } else {
          item[vScale.axis] = vScale.parse(entry, i);
        }
        return item;
      }
      function parseArrayOrPrimitive(meta, data, start, count) {
        const iScale = meta.iScale;
        const vScale = meta.vScale;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = [];
        let i, ilen, item, entry;
        for (i = start, ilen = start + count; i < ilen; ++i) {
          entry = data[i];
          item = {};
          item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
          parsed.push(parseValue(entry, item, vScale, i));
        }
        return parsed;
      }
      function isFloatBar(custom) {
        return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
      }
      function barSign(size, vScale, actualBase) {
        if (size !== 0) {
          return sign(size);
        }
        return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
      }
      function borderProps(properties) {
        let reverse, start, end, top, bottom;
        if (properties.horizontal) {
          reverse = properties.base > properties.x;
          start = "left";
          end = "right";
        } else {
          reverse = properties.base < properties.y;
          start = "bottom";
          end = "top";
        }
        if (reverse) {
          top = "end";
          bottom = "start";
        } else {
          top = "start";
          bottom = "end";
        }
        return {
          start,
          end,
          reverse,
          top,
          bottom
        };
      }
      function setBorderSkipped(properties, options, stack, index) {
        let edge = options.borderSkipped;
        const res = {};
        if (!edge) {
          properties.borderSkipped = res;
          return;
        }
        if (edge === true) {
          properties.borderSkipped = {
            top: true,
            right: true,
            bottom: true,
            left: true
          };
          return;
        }
        const {start, end, reverse, top, bottom} = borderProps(properties);
        if (edge === "middle" && stack) {
          properties.enableBorderRadius = true;
          if ((stack._top || 0) === index) {
            edge = top;
          } else if ((stack._bottom || 0) === index) {
            edge = bottom;
          } else {
            res[parseEdge(bottom, start, end, reverse)] = true;
            edge = top;
          }
        }
        res[parseEdge(edge, start, end, reverse)] = true;
        properties.borderSkipped = res;
      }
      function parseEdge(edge, a, b, reverse) {
        if (reverse) {
          edge = swap(edge, a, b);
          edge = startEnd(edge, b, a);
        } else {
          edge = startEnd(edge, a, b);
        }
        return edge;
      }
      function swap(orig, v1, v2) {
        return orig === v1 ? v2 : orig === v2 ? v1 : orig;
      }
      function startEnd(v, start, end) {
        return v === "start" ? start : v === "end" ? end : v;
      }
      function setInflateAmount(properties, {inflateAmount}, ratio) {
        properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
      }
      class BarController extends DatasetController {
        parsePrimitiveData(meta, data, start, count) {
          return parseArrayOrPrimitive(meta, data, start, count);
        }
        parseArrayData(meta, data, start, count) {
          return parseArrayOrPrimitive(meta, data, start, count);
        }
        parseObjectData(meta, data, start, count) {
          const {iScale, vScale} = meta;
          const {xAxisKey = "x", yAxisKey = "y"} = this._parsing;
          const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
          const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
          const parsed = [];
          let i, ilen, item, obj;
          for (i = start, ilen = start + count; i < ilen; ++i) {
            obj = data[i];
            item = {};
            item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
            parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
          }
          return parsed;
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
          super.updateRangeFromParsed(range, scale, parsed, stack);
          const custom = parsed._custom;
          if (custom && scale === this._cachedMeta.vScale) {
            range.min = Math.min(range.min, custom.min);
            range.max = Math.max(range.max, custom.max);
          }
        }
        getMaxOverflow() {
          return 0;
        }
        getLabelAndValue(index) {
          const meta = this._cachedMeta;
          const {iScale, vScale} = meta;
          const parsed = this.getParsed(index);
          const custom = parsed._custom;
          const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
          return {
            label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
            value
          };
        }
        initialize() {
          this.enableOptionSharing = true;
          super.initialize();
          const meta = this._cachedMeta;
          meta.stack = this.getDataset().stack;
        }
        update(mode) {
          const meta = this._cachedMeta;
          this.updateElements(meta.data, 0, meta.data.length, mode);
        }
        updateElements(bars, start, count, mode) {
          const reset = mode === "reset";
          const {
            index,
            _cachedMeta: {vScale}
          } = this;
          const base = vScale.getBasePixel();
          const horizontal = vScale.isHorizontal();
          const ruler = this._getRuler();
          const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
          for (let i = start; i < start + count; i++) {
            const parsed = this.getParsed(i);
            const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
              base,
              head: base
            } : this._calculateBarValuePixels(i);
            const ipixels = this._calculateBarIndexPixels(i, ruler);
            const stack = (parsed._stacks || {})[vScale.axis];
            const properties = {
              horizontal,
              base: vpixels.base,
              enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),
              x: horizontal ? vpixels.head : ipixels.center,
              y: horizontal ? ipixels.center : vpixels.head,
              height: horizontal ? ipixels.size : Math.abs(vpixels.size),
              width: horizontal ? Math.abs(vpixels.size) : ipixels.size
            };
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
            }
            const options = properties.options || bars[i].options;
            setBorderSkipped(properties, options, stack, index);
            setInflateAmount(properties, options, ruler.ratio);
            this.updateElement(bars[i], i, properties, mode);
          }
        }
        _getStacks(last, dataIndex) {
          const {iScale} = this._cachedMeta;
          const metasets = iScale.getMatchingVisibleMetas(this._type).filter(meta => meta.controller.options.grouped);
          const stacked = iScale.options.stacked;
          const stacks = [];
          const skipNull = meta => {
            const parsed = meta.controller.getParsed(dataIndex);
            const val = parsed && parsed[meta.vScale.axis];
            if (isNullOrUndef(val) || isNaN(val)) {
              return true;
            }
          };
          for (const meta of metasets) {
            if (dataIndex !== undefined && skipNull(meta)) {
              continue;
            }
            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {
              stacks.push(meta.stack);
            }
            if (meta.index === last) {
              break;
            }
          }
          if (!stacks.length) {
            stacks.push(undefined);
          }
          return stacks;
        }
        _getStackCount(index) {
          return this._getStacks(undefined, index).length;
        }
        _getStackIndex(datasetIndex, name, dataIndex) {
          const stacks = this._getStacks(datasetIndex, dataIndex);
          const index = name !== undefined ? stacks.indexOf(name) : -1;
          return index === -1 ? stacks.length - 1 : index;
        }
        _getRuler() {
          const opts = this.options;
          const meta = this._cachedMeta;
          const iScale = meta.iScale;
          const pixels = [];
          let i, ilen;
          for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
          }
          const barThickness = opts.barThickness;
          const min = barThickness || computeMinSampleSize(meta);
          return {
            min,
            pixels,
            start: iScale._startPixel,
            end: iScale._endPixel,
            stackCount: this._getStackCount(),
            scale: iScale,
            grouped: opts.grouped,
            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
          };
        }
        _calculateBarValuePixels(index) {
          const {
            _cachedMeta: {vScale, _stacked},
            options: {
              base: baseValue,
              minBarLength
            }
          } = this;
          const actualBase = baseValue || 0;
          const parsed = this.getParsed(index);
          const custom = parsed._custom;
          const floating = isFloatBar(custom);
          let value = parsed[vScale.axis];
          let start = 0;
          let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
          let head, size;
          if (length !== value) {
            start = length - value;
            length = value;
          }
          if (floating) {
            value = custom.barStart;
            length = custom.barEnd - custom.barStart;
            if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
              start = 0;
            }
            start += value;
          }
          const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
          let base = vScale.getPixelForValue(startValue);
          if (this.chart.getDataVisibility(index)) {
            head = vScale.getPixelForValue(start + length);
          } else {
            head = base;
          }
          size = head - base;
          if (Math.abs(size) < minBarLength) {
            size = barSign(size, vScale, actualBase) * minBarLength;
            if (value === actualBase) {
              base -= size / 2;
            }
            const startPixel = vScale.getPixelForDecimal(0);
            const endPixel = vScale.getPixelForDecimal(1);
            const min = Math.min(startPixel, endPixel);
            const max = Math.max(startPixel, endPixel);
            base = Math.max(Math.min(base, max), min);
            head = base + size;
          }
          if (base === vScale.getPixelForValue(actualBase)) {
            const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
            base += halfGrid;
            size -= halfGrid;
          }
          return {
            size,
            base,
            head,
            center: head + size / 2
          };
        }
        _calculateBarIndexPixels(index, ruler) {
          const scale = ruler.scale;
          const options = this.options;
          const skipNull = options.skipNull;
          const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
          let center, size;
          if (ruler.grouped) {
            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
            const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);
            center = range.start + range.chunk * stackIndex + range.chunk / 2;
            size = Math.min(maxBarThickness, range.chunk * range.ratio);
          } else {
            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
          }
          return {
            base: center - size / 2,
            head: center + size / 2,
            center,
            size
          };
        }
        draw() {
          const meta = this._cachedMeta;
          const vScale = meta.vScale;
          const rects = meta.data;
          const ilen = rects.length;
          let i = 0;
          for (; i < ilen; ++i) {
            if (this.getParsed(i)[vScale.axis] !== null) {
              rects[i].draw(this._ctx);
            }
          }
        }
      }
      BarController.id = "bar";
      BarController.defaults = {
        datasetElementType: false,
        dataElementType: "bar",
        categoryPercentage: 0.8,
        barPercentage: 0.9,
        grouped: true,
        animations: {
          numbers: {
            type: "number",
            properties: [
              "x",
              "y",
              "base",
              "width",
              "height"
            ]
          }
        }
      };
      BarController.overrides = {
        scales: {
          _index_: {
            type: "category",
            offset: true,
            grid: { offset: true }
          },
          _value_: {
            type: "linear",
            beginAtZero: true
          }
        }
      };
      class BubbleController extends DatasetController {
        initialize() {
          this.enableOptionSharing = true;
          super.initialize();
        }
        parsePrimitiveData(meta, data, start, count) {
          const parsed = super.parsePrimitiveData(meta, data, start, count);
          for (let i = 0; i < parsed.length; i++) {
            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
          }
          return parsed;
        }
        parseArrayData(meta, data, start, count) {
          const parsed = super.parseArrayData(meta, data, start, count);
          for (let i = 0; i < parsed.length; i++) {
            const item = data[start + i];
            parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
          }
          return parsed;
        }
        parseObjectData(meta, data, start, count) {
          const parsed = super.parseObjectData(meta, data, start, count);
          for (let i = 0; i < parsed.length; i++) {
            const item = data[start + i];
            parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
          }
          return parsed;
        }
        getMaxOverflow() {
          const data = this._cachedMeta.data;
          let max = 0;
          for (let i = data.length - 1; i >= 0; --i) {
            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
          }
          return max > 0 && max;
        }
        getLabelAndValue(index) {
          const meta = this._cachedMeta;
          const {xScale, yScale} = meta;
          const parsed = this.getParsed(index);
          const x = xScale.getLabelForValue(parsed.x);
          const y = yScale.getLabelForValue(parsed.y);
          const r = parsed._custom;
          return {
            label: meta.label,
            value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
          };
        }
        update(mode) {
          const points = this._cachedMeta.data;
          this.updateElements(points, 0, points.length, mode);
        }
        updateElements(points, start, count, mode) {
          const reset = mode === "reset";
          const {iScale, vScale} = this._cachedMeta;
          const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          for (let i = start; i < start + count; i++) {
            const point = points[i];
            const parsed = !reset && this.getParsed(i);
            const properties = {};
            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
            properties.skip = isNaN(iPixel) || isNaN(vPixel);
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
              if (reset) {
                properties.options.radius = 0;
              }
            }
            this.updateElement(point, i, properties, mode);
          }
        }
        resolveDataElementOptions(index, mode) {
          const parsed = this.getParsed(index);
          let values = super.resolveDataElementOptions(index, mode);
          if (values.$shared) {
            values = Object.assign({}, values, { $shared: false });
          }
          const radius = values.radius;
          if (mode !== "active") {
            values.radius = 0;
          }
          values.radius += valueOrDefault(parsed && parsed._custom, radius);
          return values;
        }
      }
      BubbleController.id = "bubble";
      BubbleController.defaults = {
        datasetElementType: false,
        dataElementType: "point",
        animations: {
          numbers: {
            type: "number",
            properties: [
              "x",
              "y",
              "borderWidth",
              "radius"
            ]
          }
        }
      };
      BubbleController.overrides = {
        scales: {
          x: { type: "linear" },
          y: { type: "linear" }
        },
        plugins: {
          tooltip: {
            callbacks: {
              title() {
                return "";
              }
            }
          }
        }
      };
      function getRatioAndOffset(rotation, circumference, cutout) {
        let ratioX = 1;
        let ratioY = 1;
        let offsetX = 0;
        let offsetY = 0;
        if (circumference < TAU) {
          const startAngle = rotation;
          const endAngle = startAngle + circumference;
          const startX = Math.cos(startAngle);
          const startY = Math.sin(startAngle);
          const endX = Math.cos(endAngle);
          const endY = Math.sin(endAngle);
          const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
          const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
          const maxX = calcMax(0, startX, endX);
          const maxY = calcMax(HALF_PI, startY, endY);
          const minX = calcMin(PI, startX, endX);
          const minY = calcMin(PI + HALF_PI, startY, endY);
          ratioX = (maxX - minX) / 2;
          ratioY = (maxY - minY) / 2;
          offsetX = -(maxX + minX) / 2;
          offsetY = -(maxY + minY) / 2;
        }
        return {
          ratioX,
          ratioY,
          offsetX,
          offsetY
        };
      }
      class DoughnutController extends DatasetController {
        constructor(chart, datasetIndex) {
          super(chart, datasetIndex);
          this.enableOptionSharing = true;
          this.innerRadius = undefined;
          this.outerRadius = undefined;
          this.offsetX = undefined;
          this.offsetY = undefined;
        }
        linkScales() {
        }
        parse(start, count) {
          const data = this.getDataset().data;
          const meta = this._cachedMeta;
          if (this._parsing === false) {
            meta._parsed = data;
          } else {
            let getter = i => +data[i];
            if (isObject(data[start])) {
              const {
                key = "value"
              } = this._parsing;
              getter = i => +resolveObjectKey(data[i], key);
            }
            let i, ilen;
            for (i = start, ilen = start + count; i < ilen; ++i) {
              meta._parsed[i] = getter(i);
            }
          }
        }
        _getRotation() {
          return toRadians(this.options.rotation - 90);
        }
        _getCircumference() {
          return toRadians(this.options.circumference);
        }
        _getRotationExtents() {
          let min = TAU;
          let max = -TAU;
          for (let i = 0; i < this.chart.data.datasets.length; ++i) {
            if (this.chart.isDatasetVisible(i)) {
              const controller = this.chart.getDatasetMeta(i).controller;
              const rotation = controller._getRotation();
              const circumference = controller._getCircumference();
              min = Math.min(min, rotation);
              max = Math.max(max, rotation + circumference);
            }
          }
          return {
            rotation: min,
            circumference: max - min
          };
        }
        update(mode) {
          const chart = this.chart;
          const {chartArea} = chart;
          const meta = this._cachedMeta;
          const arcs = meta.data;
          const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
          const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
          const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
          const chartWeight = this._getRingWeight(this.index);
          const {circumference, rotation} = this._getRotationExtents();
          const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);
          const maxWidth = (chartArea.width - spacing) / ratioX;
          const maxHeight = (chartArea.height - spacing) / ratioY;
          const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
          const outerRadius = toDimension(this.options.radius, maxRadius);
          const innerRadius = Math.max(outerRadius * cutout, 0);
          const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
          this.offsetX = offsetX * outerRadius;
          this.offsetY = offsetY * outerRadius;
          meta.total = this.calculateTotal();
          this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
          this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
          this.updateElements(arcs, 0, arcs.length, mode);
        }
        _circumference(i, reset) {
          const opts = this.options;
          const meta = this._cachedMeta;
          const circumference = this._getCircumference();
          if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
            return 0;
          }
          return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
        }
        updateElements(arcs, start, count, mode) {
          const reset = mode === "reset";
          const chart = this.chart;
          const chartArea = chart.chartArea;
          const opts = chart.options;
          const animationOpts = opts.animation;
          const centerX = (chartArea.left + chartArea.right) / 2;
          const centerY = (chartArea.top + chartArea.bottom) / 2;
          const animateScale = reset && animationOpts.animateScale;
          const innerRadius = animateScale ? 0 : this.innerRadius;
          const outerRadius = animateScale ? 0 : this.outerRadius;
          const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
          let startAngle = this._getRotation();
          let i;
          for (i = 0; i < start; ++i) {
            startAngle += this._circumference(i, reset);
          }
          for (i = start; i < start + count; ++i) {
            const circumference = this._circumference(i, reset);
            const arc = arcs[i];
            const properties = {
              x: centerX + this.offsetX,
              y: centerY + this.offsetY,
              startAngle,
              endAngle: startAngle + circumference,
              circumference,
              outerRadius,
              innerRadius
            };
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
            }
            startAngle += circumference;
            this.updateElement(arc, i, properties, mode);
          }
        }
        calculateTotal() {
          const meta = this._cachedMeta;
          const metaData = meta.data;
          let total = 0;
          let i;
          for (i = 0; i < metaData.length; i++) {
            const value = meta._parsed[i];
            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
              total += Math.abs(value);
            }
          }
          return total;
        }
        calculateCircumference(value) {
          const total = this._cachedMeta.total;
          if (total > 0 && !isNaN(value)) {
            return TAU * (Math.abs(value) / total);
          }
          return 0;
        }
        getLabelAndValue(index) {
          const meta = this._cachedMeta;
          const chart = this.chart;
          const labels = chart.data.labels || [];
          const value = formatNumber(meta._parsed[index], chart.options.locale);
          return {
            label: labels[index] || "",
            value
          };
        }
        getMaxBorderWidth(arcs) {
          let max = 0;
          const chart = this.chart;
          let i, ilen, meta, controller, options;
          if (!arcs) {
            for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
              if (chart.isDatasetVisible(i)) {
                meta = chart.getDatasetMeta(i);
                arcs = meta.data;
                controller = meta.controller;
                break;
              }
            }
          }
          if (!arcs) {
            return 0;
          }
          for (i = 0, ilen = arcs.length; i < ilen; ++i) {
            options = controller.resolveDataElementOptions(i);
            if (options.borderAlign !== "inner") {
              max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
            }
          }
          return max;
        }
        getMaxOffset(arcs) {
          let max = 0;
          for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
            const options = this.resolveDataElementOptions(i);
            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
          }
          return max;
        }
        _getRingWeightOffset(datasetIndex) {
          let ringWeightOffset = 0;
          for (let i = 0; i < datasetIndex; ++i) {
            if (this.chart.isDatasetVisible(i)) {
              ringWeightOffset += this._getRingWeight(i);
            }
          }
          return ringWeightOffset;
        }
        _getRingWeight(datasetIndex) {
          return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
        }
        _getVisibleDatasetWeightTotal() {
          return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
        }
      }
      DoughnutController.id = "doughnut";
      DoughnutController.defaults = {
        datasetElementType: false,
        dataElementType: "arc",
        animation: {
          animateRotate: true,
          animateScale: false
        },
        animations: {
          numbers: {
            type: "number",
            properties: [
              "circumference",
              "endAngle",
              "innerRadius",
              "outerRadius",
              "startAngle",
              "x",
              "y",
              "offset",
              "borderWidth",
              "spacing"
            ]
          }
        },
        cutout: "50%",
        rotation: 0,
        circumference: 360,
        radius: "100%",
        spacing: 0,
        indexAxis: "r"
      };
      DoughnutController.descriptors = {
        _scriptable: name => name !== "spacing",
        _indexable: name => name !== "spacing"
      };
      DoughnutController.overrides = {
        aspectRatio: 1,
        plugins: {
          legend: {
            labels: {
              generateLabels(chart) {
                const data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  const {
                    labels: {pointStyle}
                  } = chart.legend.options;
                  return data.labels.map((label, i) => {
                    const meta = chart.getDatasetMeta(0);
                    const style = meta.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      pointStyle: pointStyle,
                      hidden: !chart.getDataVisibility(i),
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick(e, legendItem, legend) {
              legend.chart.toggleDataVisibility(legendItem.index);
              legend.chart.update();
            }
          },
          tooltip: {
            callbacks: {
              title() {
                return "";
              },
              label(tooltipItem) {
                let dataLabel = tooltipItem.label;
                const value = ": " + tooltipItem.formattedValue;
                if (isArray(dataLabel)) {
                  dataLabel = dataLabel.slice();
                  dataLabel[0] += value;
                } else {
                  dataLabel += value;
                }
                return dataLabel;
              }
            }
          }
        }
      };
      class LineController extends DatasetController {
        initialize() {
          this.enableOptionSharing = true;
          this.supportsDecimation = true;
          super.initialize();
        }
        update(mode) {
          const meta = this._cachedMeta;
          const {
            dataset: line,
            data: points = [],
            _dataset
          } = meta;
          const animationsDisabled = this.chart._animationsDisabled;
          let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
          this._drawStart = start;
          this._drawCount = count;
          if (_scaleRangesChanged(meta)) {
            start = 0;
            count = points.length;
          }
          line._chart = this.chart;
          line._datasetIndex = this.index;
          line._decimated = !!_dataset._decimated;
          line.points = points;
          const options = this.resolveDatasetElementOptions(mode);
          if (!this.options.showLine) {
            options.borderWidth = 0;
          }
          options.segment = this.options.segment;
          this.updateElement(line, undefined, {
            animated: !animationsDisabled,
            options
          }, mode);
          this.updateElements(points, start, count, mode);
        }
        updateElements(points, start, count, mode) {
          const reset = mode === "reset";
          const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;
          const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const {spanGaps, segment} = this.options;
          const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
          const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
          let prevParsed = start > 0 && this.getParsed(start - 1);
          for (let i = start; i < start + count; ++i) {
            const point = points[i];
            const parsed = this.getParsed(i);
            const properties = directUpdate ? point : {};
            const nullData = isNullOrUndef(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
            if (segment) {
              properties.parsed = parsed;
              properties.raw = _dataset.data[i];
            }
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
            }
            if (!directUpdate) {
              this.updateElement(point, i, properties, mode);
            }
            prevParsed = parsed;
          }
        }
        getMaxOverflow() {
          const meta = this._cachedMeta;
          const dataset = meta.dataset;
          const border = dataset.options && dataset.options.borderWidth || 0;
          const data = meta.data || [];
          if (!data.length) {
            return border;
          }
          const firstPoint = data[0].size(this.resolveDataElementOptions(0));
          const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
          return Math.max(border, firstPoint, lastPoint) / 2;
        }
        draw() {
          const meta = this._cachedMeta;
          meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
          super.draw();
        }
      }
      LineController.id = "line";
      LineController.defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        showLine: true,
        spanGaps: false
      };
      LineController.overrides = {
        scales: {
          _index_: { type: "category" },
          _value_: { type: "linear" }
        }
      };
      class PolarAreaController extends DatasetController {
        constructor(chart, datasetIndex) {
          super(chart, datasetIndex);
          this.innerRadius = undefined;
          this.outerRadius = undefined;
        }
        getLabelAndValue(index) {
          const meta = this._cachedMeta;
          const chart = this.chart;
          const labels = chart.data.labels || [];
          const value = formatNumber(meta._parsed[index].r, chart.options.locale);
          return {
            label: labels[index] || "",
            value
          };
        }
        parseObjectData(meta, data, start, count) {
          return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
        }
        update(mode) {
          const arcs = this._cachedMeta.data;
          this._updateRadius();
          this.updateElements(arcs, 0, arcs.length, mode);
        }
        getMinMax() {
          const meta = this._cachedMeta;
          const range = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
          };
          meta.data.forEach((element, index) => {
            const parsed = this.getParsed(index).r;
            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {
              if (parsed < range.min) {
                range.min = parsed;
              }
              if (parsed > range.max) {
                range.max = parsed;
              }
            }
          });
          return range;
        }
        _updateRadius() {
          const chart = this.chart;
          const chartArea = chart.chartArea;
          const opts = chart.options;
          const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
          const outerRadius = Math.max(minSize / 2, 0);
          const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
          const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
          this.outerRadius = outerRadius - radiusLength * this.index;
          this.innerRadius = this.outerRadius - radiusLength;
        }
        updateElements(arcs, start, count, mode) {
          const reset = mode === "reset";
          const chart = this.chart;
          const opts = chart.options;
          const animationOpts = opts.animation;
          const scale = this._cachedMeta.rScale;
          const centerX = scale.xCenter;
          const centerY = scale.yCenter;
          const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
          let angle = datasetStartAngle;
          let i;
          const defaultAngle = 360 / this.countVisibleElements();
          for (i = 0; i < start; ++i) {
            angle += this._computeAngle(i, mode, defaultAngle);
          }
          for (i = start; i < start + count; i++) {
            const arc = arcs[i];
            let startAngle = angle;
            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
            angle = endAngle;
            if (reset) {
              if (animationOpts.animateScale) {
                outerRadius = 0;
              }
              if (animationOpts.animateRotate) {
                startAngle = endAngle = datasetStartAngle;
              }
            }
            const properties = {
              x: centerX,
              y: centerY,
              innerRadius: 0,
              outerRadius,
              startAngle,
              endAngle,
              options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
            };
            this.updateElement(arc, i, properties, mode);
          }
        }
        countVisibleElements() {
          const meta = this._cachedMeta;
          let count = 0;
          meta.data.forEach((element, index) => {
            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {
              count++;
            }
          });
          return count;
        }
        _computeAngle(index, mode, defaultAngle) {
          return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
        }
      }
      PolarAreaController.id = "polarArea";
      PolarAreaController.defaults = {
        dataElementType: "arc",
        animation: {
          animateRotate: true,
          animateScale: true
        },
        animations: {
          numbers: {
            type: "number",
            properties: [
              "x",
              "y",
              "startAngle",
              "endAngle",
              "innerRadius",
              "outerRadius"
            ]
          }
        },
        indexAxis: "r",
        startAngle: 0
      };
      PolarAreaController.overrides = {
        aspectRatio: 1,
        plugins: {
          legend: {
            labels: {
              generateLabels(chart) {
                const data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  const {
                    labels: {pointStyle}
                  } = chart.legend.options;
                  return data.labels.map((label, i) => {
                    const meta = chart.getDatasetMeta(0);
                    const style = meta.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      pointStyle: pointStyle,
                      hidden: !chart.getDataVisibility(i),
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick(e, legendItem, legend) {
              legend.chart.toggleDataVisibility(legendItem.index);
              legend.chart.update();
            }
          },
          tooltip: {
            callbacks: {
              title() {
                return "";
              },
              label(context) {
                return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
              }
            }
          }
        },
        scales: {
          r: {
            type: "radialLinear",
            angleLines: { display: false },
            beginAtZero: true,
            grid: { circular: true },
            pointLabels: { display: false },
            startAngle: 0
          }
        }
      };
      class PieController extends DoughnutController {
      }
      PieController.id = "pie";
      PieController.defaults = {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: "100%"
      };
      class RadarController extends DatasetController {
        getLabelAndValue(index) {
          const vScale = this._cachedMeta.vScale;
          const parsed = this.getParsed(index);
          return {
            label: vScale.getLabels()[index],
            value: "" + vScale.getLabelForValue(parsed[vScale.axis])
          };
        }
        parseObjectData(meta, data, start, count) {
          return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
        }
        update(mode) {
          const meta = this._cachedMeta;
          const line = meta.dataset;
          const points = meta.data || [];
          const labels = meta.iScale.getLabels();
          line.points = points;
          if (mode !== "resize") {
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) {
              options.borderWidth = 0;
            }
            const properties = {
              _loop: true,
              _fullLoop: labels.length === points.length,
              options
            };
            this.updateElement(line, undefined, properties, mode);
          }
          this.updateElements(points, 0, points.length, mode);
        }
        updateElements(points, start, count, mode) {
          const scale = this._cachedMeta.rScale;
          const reset = mode === "reset";
          for (let i = start; i < start + count; i++) {
            const point = points[i];
            const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
            const x = reset ? scale.xCenter : pointPosition.x;
            const y = reset ? scale.yCenter : pointPosition.y;
            const properties = {
              x,
              y,
              angle: pointPosition.angle,
              skip: isNaN(x) || isNaN(y),
              options
            };
            this.updateElement(point, i, properties, mode);
          }
        }
      }
      RadarController.id = "radar";
      RadarController.defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        indexAxis: "r",
        showLine: true,
        elements: { line: { fill: "start" } }
      };
      RadarController.overrides = {
        aspectRatio: 1,
        scales: { r: { type: "radialLinear" } }
      };
      class Element {
        constructor() {
          this.x = undefined;
          this.y = undefined;
          this.active = false;
          this.options = undefined;
          this.$animations = undefined;
        }
        tooltipPosition(useFinalPosition) {
          const {x, y} = this.getProps([
            "x",
            "y"
          ], useFinalPosition);
          return {
            x,
            y
          };
        }
        hasValue() {
          return isNumber(this.x) && isNumber(this.y);
        }
        getProps(props, final) {
          const anims = this.$animations;
          if (!final || !anims) {
            return this;
          }
          const ret = {};
          props.forEach(prop => {
            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
          });
          return ret;
        }
      }
      Element.defaults = {};
      Element.defaultRoutes = undefined;
      const formatters = {
        values(value) {
          return isArray(value) ? value : "" + value;
        },
        numeric(tickValue, index, ticks) {
          if (tickValue === 0) {
            return "0";
          }
          const locale = this.chart.options.locale;
          let notation;
          let delta = tickValue;
          if (ticks.length > 1) {
            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
            if (maxTick < 0.0001 || maxTick > 1000000000000000) {
              notation = "scientific";
            }
            delta = calculateDelta(tickValue, ticks);
          }
          const logDelta = log10(Math.abs(delta));
          const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
          const options = {
            notation,
            minimumFractionDigits: numDecimal,
            maximumFractionDigits: numDecimal
          };
          Object.assign(options, this.options.ticks.format);
          return formatNumber(tickValue, locale, options);
        },
        logarithmic(tickValue, index, ticks) {
          if (tickValue === 0) {
            return "0";
          }
          const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
          if (remain === 1 || remain === 2 || remain === 5) {
            return formatters.numeric.call(this, tickValue, index, ticks);
          }
          return "";
        }
      };
      function calculateDelta(tickValue, ticks) {
        let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
        if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
          delta = tickValue - Math.floor(tickValue);
        }
        return delta;
      }
      var Ticks = { formatters };
      defaults.set("scale", {
        display: true,
        offset: false,
        reverse: false,
        beginAtZero: false,
        bounds: "ticks",
        grace: 0,
        grid: {
          display: true,
          lineWidth: 1,
          drawBorder: true,
          drawOnChartArea: true,
          drawTicks: true,
          tickLength: 8,
          tickWidth: (_ctx, options) => options.lineWidth,
          tickColor: (_ctx, options) => options.color,
          offset: false,
          borderDash: [],
          borderDashOffset: 0,
          borderWidth: 1
        },
        title: {
          display: false,
          text: "",
          padding: {
            top: 4,
            bottom: 4
          }
        },
        ticks: {
          minRotation: 0,
          maxRotation: 50,
          mirror: false,
          textStrokeWidth: 0,
          textStrokeColor: "",
          padding: 3,
          display: true,
          autoSkip: true,
          autoSkipPadding: 3,
          labelOffset: 0,
          callback: Ticks.formatters.values,
          minor: {},
          major: {},
          align: "center",
          crossAlign: "near",
          showLabelBackdrop: false,
          backdropColor: "rgba(255, 255, 255, 0.75)",
          backdropPadding: 2
        }
      });
      defaults.route("scale.ticks", "color", "", "color");
      defaults.route("scale.grid", "color", "", "borderColor");
      defaults.route("scale.grid", "borderColor", "", "borderColor");
      defaults.route("scale.title", "color", "", "color");
      defaults.describe("scale", {
        _fallback: false,
        _scriptable: name => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
        _indexable: name => name !== "borderDash" && name !== "tickBorderDash"
      });
      defaults.describe("scales", { _fallback: "scale" });
      defaults.describe("scale.ticks", {
        _scriptable: name => name !== "backdropPadding" && name !== "callback",
        _indexable: name => name !== "backdropPadding"
      });
      function autoSkip(scale, ticks) {
        const tickOpts = scale.options.ticks;
        const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
        const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
        const numMajorIndices = majorIndices.length;
        const first = majorIndices[0];
        const last = majorIndices[numMajorIndices - 1];
        const newTicks = [];
        if (numMajorIndices > ticksLimit) {
          skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
          return newTicks;
        }
        const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
        if (numMajorIndices > 0) {
          let i, ilen;
          const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
          skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
          for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
          }
          skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
          return newTicks;
        }
        skip(ticks, newTicks, spacing);
        return newTicks;
      }
      function determineMaxTicks(scale) {
        const offset = scale.options.offset;
        const tickLength = scale._tickSize();
        const maxScale = scale._length / tickLength + (offset ? 0 : 1);
        const maxChart = scale._maxLength / tickLength;
        return Math.floor(Math.min(maxScale, maxChart));
      }
      function calculateSpacing(majorIndices, ticks, ticksLimit) {
        const evenMajorSpacing = getEvenSpacing(majorIndices);
        const spacing = ticks.length / ticksLimit;
        if (!evenMajorSpacing) {
          return Math.max(spacing, 1);
        }
        const factors = _factorize(evenMajorSpacing);
        for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
          const factor = factors[i];
          if (factor > spacing) {
            return factor;
          }
        }
        return Math.max(spacing, 1);
      }
      function getMajorIndices(ticks) {
        const result = [];
        let i, ilen;
        for (i = 0, ilen = ticks.length; i < ilen; i++) {
          if (ticks[i].major) {
            result.push(i);
          }
        }
        return result;
      }
      function skipMajors(ticks, newTicks, majorIndices, spacing) {
        let count = 0;
        let next = majorIndices[0];
        let i;
        spacing = Math.ceil(spacing);
        for (i = 0; i < ticks.length; i++) {
          if (i === next) {
            newTicks.push(ticks[i]);
            count++;
            next = majorIndices[count * spacing];
          }
        }
      }
      function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
        const start = valueOrDefault(majorStart, 0);
        const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
        let count = 0;
        let length, i, next;
        spacing = Math.ceil(spacing);
        if (majorEnd) {
          length = majorEnd - majorStart;
          spacing = length / Math.floor(length / spacing);
        }
        next = start;
        while (next < 0) {
          count++;
          next = Math.round(start + count * spacing);
        }
        for (i = Math.max(start, 0); i < end; i++) {
          if (i === next) {
            newTicks.push(ticks[i]);
            count++;
            next = Math.round(start + count * spacing);
          }
        }
      }
      function getEvenSpacing(arr) {
        const len = arr.length;
        let i, diff;
        if (len < 2) {
          return false;
        }
        for (diff = arr[0], i = 1; i < len; ++i) {
          if (arr[i] - arr[i - 1] !== diff) {
            return false;
          }
        }
        return diff;
      }
      const reverseAlign = align => align === "left" ? "right" : align === "right" ? "left" : align;
      const offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
      function sample(arr, numItems) {
        const result = [];
        const increment = arr.length / numItems;
        const len = arr.length;
        let i = 0;
        for (; i < len; i += increment) {
          result.push(arr[Math.floor(i)]);
        }
        return result;
      }
      function getPixelForGridLine(scale, index, offsetGridLines) {
        const length = scale.ticks.length;
        const validIndex = Math.min(index, length - 1);
        const start = scale._startPixel;
        const end = scale._endPixel;
        const epsilon = 0.000001;
        let lineValue = scale.getPixelForTick(validIndex);
        let offset;
        if (offsetGridLines) {
          if (length === 1) {
            offset = Math.max(lineValue - start, end - lineValue);
          } else if (index === 0) {
            offset = (scale.getPixelForTick(1) - lineValue) / 2;
          } else {
            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
          }
          lineValue += validIndex < index ? offset : -offset;
          if (lineValue < start - epsilon || lineValue > end + epsilon) {
            return;
          }
        }
        return lineValue;
      }
      function garbageCollect(caches, length) {
        each(caches, cache => {
          const gc = cache.gc;
          const gcLen = gc.length / 2;
          let i;
          if (gcLen > length) {
            for (i = 0; i < gcLen; ++i) {
              delete cache.data[gc[i]];
            }
            gc.splice(0, gcLen);
          }
        });
      }
      function getTickMarkLength(options) {
        return options.drawTicks ? options.tickLength : 0;
      }
      function getTitleHeight(options, fallback) {
        if (!options.display) {
          return 0;
        }
        const font = toFont(options.font, fallback);
        const padding = toPadding(options.padding);
        const lines = isArray(options.text) ? options.text.length : 1;
        return lines * font.lineHeight + padding.height;
      }
      function createScaleContext(parent, scale) {
        return createContext(parent, {
          scale,
          type: "scale"
        });
      }
      function createTickContext(parent, index, tick) {
        return createContext(parent, {
          tick,
          index,
          type: "tick"
        });
      }
      function titleAlign(align, position, reverse) {
        let ret = _toLeftRightCenter(align);
        if (reverse && position !== "right" || !reverse && position === "right") {
          ret = reverseAlign(ret);
        }
        return ret;
      }
      function titleArgs(scale, offset, position, align) {
        const {top, left, bottom, right, chart} = scale;
        const {chartArea, scales} = chart;
        let rotation = 0;
        let maxWidth, titleX, titleY;
        const height = bottom - top;
        const width = right - left;
        if (scale.isHorizontal()) {
          titleX = _alignStartEnd(align, left, right);
          if (isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
          } else if (position === "center") {
            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
          } else {
            titleY = offsetFromEdge(scale, position, offset);
          }
          maxWidth = right - left;
        } else {
          if (isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
          } else if (position === "center") {
            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
          } else {
            titleX = offsetFromEdge(scale, position, offset);
          }
          titleY = _alignStartEnd(align, bottom, top);
          rotation = position === "left" ? -HALF_PI : HALF_PI;
        }
        return {
          titleX,
          titleY,
          maxWidth,
          rotation
        };
      }
      class Scale extends Element {
        constructor(cfg) {
          super();
          this.id = cfg.id;
          this.type = cfg.type;
          this.options = undefined;
          this.ctx = cfg.ctx;
          this.chart = cfg.chart;
          this.top = undefined;
          this.bottom = undefined;
          this.left = undefined;
          this.right = undefined;
          this.width = undefined;
          this.height = undefined;
          this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          };
          this.maxWidth = undefined;
          this.maxHeight = undefined;
          this.paddingTop = undefined;
          this.paddingBottom = undefined;
          this.paddingLeft = undefined;
          this.paddingRight = undefined;
          this.axis = undefined;
          this.labelRotation = undefined;
          this.min = undefined;
          this.max = undefined;
          this._range = undefined;
          this.ticks = [];
          this._gridLineItems = null;
          this._labelItems = null;
          this._labelSizes = null;
          this._length = 0;
          this._maxLength = 0;
          this._longestTextCache = {};
          this._startPixel = undefined;
          this._endPixel = undefined;
          this._reversePixels = false;
          this._userMax = undefined;
          this._userMin = undefined;
          this._suggestedMax = undefined;
          this._suggestedMin = undefined;
          this._ticksLength = 0;
          this._borderValue = 0;
          this._cache = {};
          this._dataLimitsCached = false;
          this.$context = undefined;
        }
        init(options) {
          this.options = options.setContext(this.getContext());
          this.axis = options.axis;
          this._userMin = this.parse(options.min);
          this._userMax = this.parse(options.max);
          this._suggestedMin = this.parse(options.suggestedMin);
          this._suggestedMax = this.parse(options.suggestedMax);
        }
        parse(raw, index) {
          return raw;
        }
        getUserBounds() {
          let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;
          _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
          _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
          _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
          _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
          return {
            min: finiteOrDefault(_userMin, _suggestedMin),
            max: finiteOrDefault(_userMax, _suggestedMax),
            minDefined: isNumberFinite(_userMin),
            maxDefined: isNumberFinite(_userMax)
          };
        }
        getMinMax(canStack) {
          let {min, max, minDefined, maxDefined} = this.getUserBounds();
          let range;
          if (minDefined && maxDefined) {
            return {
              min,
              max
            };
          }
          const metas = this.getMatchingVisibleMetas();
          for (let i = 0, ilen = metas.length; i < ilen; ++i) {
            range = metas[i].controller.getMinMax(this, canStack);
            if (!minDefined) {
              min = Math.min(min, range.min);
            }
            if (!maxDefined) {
              max = Math.max(max, range.max);
            }
          }
          min = maxDefined && min > max ? max : min;
          max = minDefined && min > max ? min : max;
          return {
            min: finiteOrDefault(min, finiteOrDefault(max, min)),
            max: finiteOrDefault(max, finiteOrDefault(min, max))
          };
        }
        getPadding() {
          return {
            left: this.paddingLeft || 0,
            top: this.paddingTop || 0,
            right: this.paddingRight || 0,
            bottom: this.paddingBottom || 0
          };
        }
        getTicks() {
          return this.ticks;
        }
        getLabels() {
          const data = this.chart.data;
          return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
        }
        beforeLayout() {
          this._cache = {};
          this._dataLimitsCached = false;
        }
        beforeUpdate() {
          callback(this.options.beforeUpdate, [this]);
        }
        update(maxWidth, maxHeight, margins) {
          const {
            beginAtZero,
            grace,
            ticks: tickOpts
          } = this.options;
          const sampleSize = tickOpts.sampleSize;
          this.beforeUpdate();
          this.maxWidth = maxWidth;
          this.maxHeight = maxHeight;
          this._margins = margins = Object.assign({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }, margins);
          this.ticks = null;
          this._labelSizes = null;
          this._gridLineItems = null;
          this._labelItems = null;
          this.beforeSetDimensions();
          this.setDimensions();
          this.afterSetDimensions();
          this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
          if (!this._dataLimitsCached) {
            this.beforeDataLimits();
            this.determineDataLimits();
            this.afterDataLimits();
            this._range = _addGrace(this, grace, beginAtZero);
            this._dataLimitsCached = true;
          }
          this.beforeBuildTicks();
          this.ticks = this.buildTicks() || [];
          this.afterBuildTicks();
          const samplingEnabled = sampleSize < this.ticks.length;
          this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
          this.configure();
          this.beforeCalculateLabelRotation();
          this.calculateLabelRotation();
          this.afterCalculateLabelRotation();
          if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
            this.ticks = autoSkip(this, this.ticks);
            this._labelSizes = null;
            this.afterAutoSkip();
          }
          if (samplingEnabled) {
            this._convertTicksToLabels(this.ticks);
          }
          this.beforeFit();
          this.fit();
          this.afterFit();
          this.afterUpdate();
        }
        configure() {
          let reversePixels = this.options.reverse;
          let startPixel, endPixel;
          if (this.isHorizontal()) {
            startPixel = this.left;
            endPixel = this.right;
          } else {
            startPixel = this.top;
            endPixel = this.bottom;
            reversePixels = !reversePixels;
          }
          this._startPixel = startPixel;
          this._endPixel = endPixel;
          this._reversePixels = reversePixels;
          this._length = endPixel - startPixel;
          this._alignToPixels = this.options.alignToPixels;
        }
        afterUpdate() {
          callback(this.options.afterUpdate, [this]);
        }
        beforeSetDimensions() {
          callback(this.options.beforeSetDimensions, [this]);
        }
        setDimensions() {
          if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = 0;
            this.right = this.width;
          } else {
            this.height = this.maxHeight;
            this.top = 0;
            this.bottom = this.height;
          }
          this.paddingLeft = 0;
          this.paddingTop = 0;
          this.paddingRight = 0;
          this.paddingBottom = 0;
        }
        afterSetDimensions() {
          callback(this.options.afterSetDimensions, [this]);
        }
        _callHooks(name) {
          this.chart.notifyPlugins(name, this.getContext());
          callback(this.options[name], [this]);
        }
        beforeDataLimits() {
          this._callHooks("beforeDataLimits");
        }
        determineDataLimits() {
        }
        afterDataLimits() {
          this._callHooks("afterDataLimits");
        }
        beforeBuildTicks() {
          this._callHooks("beforeBuildTicks");
        }
        buildTicks() {
          return [];
        }
        afterBuildTicks() {
          this._callHooks("afterBuildTicks");
        }
        beforeTickToLabelConversion() {
          callback(this.options.beforeTickToLabelConversion, [this]);
        }
        generateTickLabels(ticks) {
          const tickOpts = this.options.ticks;
          let i, ilen, tick;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            tick = ticks[i];
            tick.label = callback(tickOpts.callback, [
              tick.value,
              i,
              ticks
            ], this);
          }
        }
        afterTickToLabelConversion() {
          callback(this.options.afterTickToLabelConversion, [this]);
        }
        beforeCalculateLabelRotation() {
          callback(this.options.beforeCalculateLabelRotation, [this]);
        }
        calculateLabelRotation() {
          const options = this.options;
          const tickOpts = options.ticks;
          const numTicks = this.ticks.length;
          const minRotation = tickOpts.minRotation || 0;
          const maxRotation = tickOpts.maxRotation;
          let labelRotation = minRotation;
          let tickWidth, maxHeight, maxLabelDiagonal;
          if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
            this.labelRotation = minRotation;
            return;
          }
          const labelSizes = this._getLabelSizes();
          const maxLabelWidth = labelSizes.widest.width;
          const maxLabelHeight = labelSizes.highest.height;
          const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
          tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
          if (maxLabelWidth + 6 > tickWidth) {
            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
            labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
          }
          this.labelRotation = labelRotation;
        }
        afterCalculateLabelRotation() {
          callback(this.options.afterCalculateLabelRotation, [this]);
        }
        afterAutoSkip() {
        }
        beforeFit() {
          callback(this.options.beforeFit, [this]);
        }
        fit() {
          const minSize = {
            width: 0,
            height: 0
          };
          const {
            chart,
            options: {
              ticks: tickOpts,
              title: titleOpts,
              grid: gridOpts
            }
          } = this;
          const display = this._isVisible();
          const isHorizontal = this.isHorizontal();
          if (display) {
            const titleHeight = getTitleHeight(titleOpts, chart.options.font);
            if (isHorizontal) {
              minSize.width = this.maxWidth;
              minSize.height = getTickMarkLength(gridOpts) + titleHeight;
            } else {
              minSize.height = this.maxHeight;
              minSize.width = getTickMarkLength(gridOpts) + titleHeight;
            }
            if (tickOpts.display && this.ticks.length) {
              const {first, last, widest, highest} = this._getLabelSizes();
              const tickPadding = tickOpts.padding * 2;
              const angleRadians = toRadians(this.labelRotation);
              const cos = Math.cos(angleRadians);
              const sin = Math.sin(angleRadians);
              if (isHorizontal) {
                const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
              } else {
                const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
              }
              this._calculatePadding(first, last, sin, cos);
            }
          }
          this._handleMargins();
          if (isHorizontal) {
            this.width = this._length = chart.width - this._margins.left - this._margins.right;
            this.height = minSize.height;
          } else {
            this.width = minSize.width;
            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
          }
        }
        _calculatePadding(first, last, sin, cos) {
          const {
            ticks: {align, padding},
            position
          } = this.options;
          const isRotated = this.labelRotation !== 0;
          const labelsBelowTicks = position !== "top" && this.axis === "x";
          if (this.isHorizontal()) {
            const offsetLeft = this.getPixelForTick(0) - this.left;
            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
            let paddingLeft = 0;
            let paddingRight = 0;
            if (isRotated) {
              if (labelsBelowTicks) {
                paddingLeft = cos * first.width;
                paddingRight = sin * last.height;
              } else {
                paddingLeft = sin * first.height;
                paddingRight = cos * last.width;
              }
            } else if (align === "start") {
              paddingRight = last.width;
            } else if (align === "end") {
              paddingLeft = first.width;
            } else if (align !== "inner") {
              paddingLeft = first.width / 2;
              paddingRight = last.width / 2;
            }
            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
          } else {
            let paddingTop = last.height / 2;
            let paddingBottom = first.height / 2;
            if (align === "start") {
              paddingTop = 0;
              paddingBottom = first.height;
            } else if (align === "end") {
              paddingTop = last.height;
              paddingBottom = 0;
            }
            this.paddingTop = paddingTop + padding;
            this.paddingBottom = paddingBottom + padding;
          }
        }
        _handleMargins() {
          if (this._margins) {
            this._margins.left = Math.max(this.paddingLeft, this._margins.left);
            this._margins.top = Math.max(this.paddingTop, this._margins.top);
            this._margins.right = Math.max(this.paddingRight, this._margins.right);
            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
          }
        }
        afterFit() {
          callback(this.options.afterFit, [this]);
        }
        isHorizontal() {
          const {axis, position} = this.options;
          return position === "top" || position === "bottom" || axis === "x";
        }
        isFullSize() {
          return this.options.fullSize;
        }
        _convertTicksToLabels(ticks) {
          this.beforeTickToLabelConversion();
          this.generateTickLabels(ticks);
          let i, ilen;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            if (isNullOrUndef(ticks[i].label)) {
              ticks.splice(i, 1);
              ilen--;
              i--;
            }
          }
          this.afterTickToLabelConversion();
        }
        _getLabelSizes() {
          let labelSizes = this._labelSizes;
          if (!labelSizes) {
            const sampleSize = this.options.ticks.sampleSize;
            let ticks = this.ticks;
            if (sampleSize < ticks.length) {
              ticks = sample(ticks, sampleSize);
            }
            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
          }
          return labelSizes;
        }
        _computeLabelSizes(ticks, length) {
          const {
            ctx,
            _longestTextCache: caches
          } = this;
          const widths = [];
          const heights = [];
          let widestLabelSize = 0;
          let highestLabelSize = 0;
          let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
          for (i = 0; i < length; ++i) {
            label = ticks[i].label;
            tickFont = this._resolveTickFontOptions(i);
            ctx.font = fontString = tickFont.string;
            cache = caches[fontString] = caches[fontString] || {
              data: {},
              gc: []
            };
            lineHeight = tickFont.lineHeight;
            width = height = 0;
            if (!isNullOrUndef(label) && !isArray(label)) {
              width = _measureText(ctx, cache.data, cache.gc, width, label);
              height = lineHeight;
            } else if (isArray(label)) {
              for (j = 0, jlen = label.length; j < jlen; ++j) {
                nestedLabel = label[j];
                if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                  width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                  height += lineHeight;
                }
              }
            }
            widths.push(width);
            heights.push(height);
            widestLabelSize = Math.max(width, widestLabelSize);
            highestLabelSize = Math.max(height, highestLabelSize);
          }
          garbageCollect(caches, length);
          const widest = widths.indexOf(widestLabelSize);
          const highest = heights.indexOf(highestLabelSize);
          const valueAt = idx => ({
            width: widths[idx] || 0,
            height: heights[idx] || 0
          });
          return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest),
            widths,
            heights
          };
        }
        getLabelForValue(value) {
          return value;
        }
        getPixelForValue(value, index) {
          return NaN;
        }
        getValueForPixel(pixel) {
        }
        getPixelForTick(index) {
          const ticks = this.ticks;
          if (index < 0 || index > ticks.length - 1) {
            return null;
          }
          return this.getPixelForValue(ticks[index].value);
        }
        getPixelForDecimal(decimal) {
          if (this._reversePixels) {
            decimal = 1 - decimal;
          }
          const pixel = this._startPixel + decimal * this._length;
          return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
        }
        getDecimalForPixel(pixel) {
          const decimal = (pixel - this._startPixel) / this._length;
          return this._reversePixels ? 1 - decimal : decimal;
        }
        getBasePixel() {
          return this.getPixelForValue(this.getBaseValue());
        }
        getBaseValue() {
          const {min, max} = this;
          return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
        }
        getContext(index) {
          const ticks = this.ticks || [];
          if (index >= 0 && index < ticks.length) {
            const tick = ticks[index];
            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
          }
          return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
        }
        _tickSize() {
          const optionTicks = this.options.ticks;
          const rot = toRadians(this.labelRotation);
          const cos = Math.abs(Math.cos(rot));
          const sin = Math.abs(Math.sin(rot));
          const labelSizes = this._getLabelSizes();
          const padding = optionTicks.autoSkipPadding || 0;
          const w = labelSizes ? labelSizes.widest.width + padding : 0;
          const h = labelSizes ? labelSizes.highest.height + padding : 0;
          return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
        }
        _isVisible() {
          const display = this.options.display;
          if (display !== "auto") {
            return !!display;
          }
          return this.getMatchingVisibleMetas().length > 0;
        }
        _computeGridLineItems(chartArea) {
          const axis = this.axis;
          const chart = this.chart;
          const options = this.options;
          const {grid, position} = options;
          const offset = grid.offset;
          const isHorizontal = this.isHorizontal();
          const ticks = this.ticks;
          const ticksLength = ticks.length + (offset ? 1 : 0);
          const tl = getTickMarkLength(grid);
          const items = [];
          const borderOpts = grid.setContext(this.getContext());
          const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
          const axisHalfWidth = axisWidth / 2;
          const alignBorderValue = function (pixel) {
            return _alignPixel(chart, pixel, axisWidth);
          };
          let borderValue, i, lineValue, alignedLineValue;
          let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
          if (position === "top") {
            borderValue = alignBorderValue(this.bottom);
            ty1 = this.bottom - tl;
            ty2 = borderValue - axisHalfWidth;
            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
            y2 = chartArea.bottom;
          } else if (position === "bottom") {
            borderValue = alignBorderValue(this.top);
            y1 = chartArea.top;
            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
            ty1 = borderValue + axisHalfWidth;
            ty2 = this.top + tl;
          } else if (position === "left") {
            borderValue = alignBorderValue(this.right);
            tx1 = this.right - tl;
            tx2 = borderValue - axisHalfWidth;
            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
            x2 = chartArea.right;
          } else if (position === "right") {
            borderValue = alignBorderValue(this.left);
            x1 = chartArea.left;
            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
            tx1 = borderValue + axisHalfWidth;
            tx2 = this.left + tl;
          } else if (axis === "x") {
            if (position === "center") {
              borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
            } else if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
            }
            y1 = chartArea.top;
            y2 = chartArea.bottom;
            ty1 = borderValue + axisHalfWidth;
            ty2 = ty1 + tl;
          } else if (axis === "y") {
            if (position === "center") {
              borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
            } else if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
            }
            tx1 = borderValue - axisHalfWidth;
            tx2 = tx1 - tl;
            x1 = chartArea.left;
            x2 = chartArea.right;
          }
          const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
          const step = Math.max(1, Math.ceil(ticksLength / limit));
          for (i = 0; i < ticksLength; i += step) {
            const optsAtIndex = grid.setContext(this.getContext(i));
            const lineWidth = optsAtIndex.lineWidth;
            const lineColor = optsAtIndex.color;
            const borderDash = optsAtIndex.borderDash || [];
            const borderDashOffset = optsAtIndex.borderDashOffset;
            const tickWidth = optsAtIndex.tickWidth;
            const tickColor = optsAtIndex.tickColor;
            const tickBorderDash = optsAtIndex.tickBorderDash || [];
            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
            lineValue = getPixelForGridLine(this, i, offset);
            if (lineValue === undefined) {
              continue;
            }
            alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
            if (isHorizontal) {
              tx1 = tx2 = x1 = x2 = alignedLineValue;
            } else {
              ty1 = ty2 = y1 = y2 = alignedLineValue;
            }
            items.push({
              tx1,
              ty1,
              tx2,
              ty2,
              x1,
              y1,
              x2,
              y2,
              width: lineWidth,
              color: lineColor,
              borderDash,
              borderDashOffset,
              tickWidth,
              tickColor,
              tickBorderDash,
              tickBorderDashOffset
            });
          }
          this._ticksLength = ticksLength;
          this._borderValue = borderValue;
          return items;
        }
        _computeLabelItems(chartArea) {
          const axis = this.axis;
          const options = this.options;
          const {
            position,
            ticks: optionTicks
          } = options;
          const isHorizontal = this.isHorizontal();
          const ticks = this.ticks;
          const {align, crossAlign, padding, mirror} = optionTicks;
          const tl = getTickMarkLength(options.grid);
          const tickAndPadding = tl + padding;
          const hTickAndPadding = mirror ? -padding : tickAndPadding;
          const rotation = -toRadians(this.labelRotation);
          const items = [];
          let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
          let textBaseline = "middle";
          if (position === "top") {
            y = this.bottom - hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
          } else if (position === "bottom") {
            y = this.top + hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
          } else if (position === "left") {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
          } else if (position === "right") {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
          } else if (axis === "x") {
            if (position === "center") {
              y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
            } else if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
            }
            textAlign = this._getXAxisLabelAlignment();
          } else if (axis === "y") {
            if (position === "center") {
              x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
            } else if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              x = this.chart.scales[positionAxisID].getPixelForValue(value);
            }
            textAlign = this._getYAxisLabelAlignment(tl).textAlign;
          }
          if (axis === "y") {
            if (align === "start") {
              textBaseline = "top";
            } else if (align === "end") {
              textBaseline = "bottom";
            }
          }
          const labelSizes = this._getLabelSizes();
          for (i = 0, ilen = ticks.length; i < ilen; ++i) {
            tick = ticks[i];
            label = tick.label;
            const optsAtIndex = optionTicks.setContext(this.getContext(i));
            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
            font = this._resolveTickFontOptions(i);
            lineHeight = font.lineHeight;
            lineCount = isArray(label) ? label.length : 1;
            const halfCount = lineCount / 2;
            const color = optsAtIndex.color;
            const strokeColor = optsAtIndex.textStrokeColor;
            const strokeWidth = optsAtIndex.textStrokeWidth;
            let tickTextAlign = textAlign;
            if (isHorizontal) {
              x = pixel;
              if (textAlign === "inner") {
                if (i === ilen - 1) {
                  tickTextAlign = !this.options.reverse ? "right" : "left";
                } else if (i === 0) {
                  tickTextAlign = !this.options.reverse ? "left" : "right";
                } else {
                  tickTextAlign = "center";
                }
              }
              if (position === "top") {
                if (crossAlign === "near" || rotation !== 0) {
                  textOffset = -lineCount * lineHeight + lineHeight / 2;
                } else if (crossAlign === "center") {
                  textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                } else {
                  textOffset = -labelSizes.highest.height + lineHeight / 2;
                }
              } else {
                if (crossAlign === "near" || rotation !== 0) {
                  textOffset = lineHeight / 2;
                } else if (crossAlign === "center") {
                  textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                } else {
                  textOffset = labelSizes.highest.height - lineCount * lineHeight;
                }
              }
              if (mirror) {
                textOffset *= -1;
              }
            } else {
              y = pixel;
              textOffset = (1 - lineCount) * lineHeight / 2;
            }
            let backdrop;
            if (optsAtIndex.showLabelBackdrop) {
              const labelPadding = toPadding(optsAtIndex.backdropPadding);
              const height = labelSizes.heights[i];
              const width = labelSizes.widths[i];
              let top = y + textOffset - labelPadding.top;
              let left = x - labelPadding.left;
              switch (textBaseline) {
              case "middle":
                top -= height / 2;
                break;
              case "bottom":
                top -= height;
                break;
              }
              switch (textAlign) {
              case "center":
                left -= width / 2;
                break;
              case "right":
                left -= width;
                break;
              }
              backdrop = {
                left,
                top,
                width: width + labelPadding.width,
                height: height + labelPadding.height,
                color: optsAtIndex.backdropColor
              };
            }
            items.push({
              rotation,
              label,
              font,
              color,
              strokeColor,
              strokeWidth,
              textOffset,
              textAlign: tickTextAlign,
              textBaseline,
              translation: [
                x,
                y
              ],
              backdrop
            });
          }
          return items;
        }
        _getXAxisLabelAlignment() {
          const {position, ticks} = this.options;
          const rotation = -toRadians(this.labelRotation);
          if (rotation) {
            return position === "top" ? "left" : "right";
          }
          let align = "center";
          if (ticks.align === "start") {
            align = "left";
          } else if (ticks.align === "end") {
            align = "right";
          } else if (ticks.align === "inner") {
            align = "inner";
          }
          return align;
        }
        _getYAxisLabelAlignment(tl) {
          const {
            position,
            ticks: {crossAlign, mirror, padding}
          } = this.options;
          const labelSizes = this._getLabelSizes();
          const tickAndPadding = tl + padding;
          const widest = labelSizes.widest.width;
          let textAlign;
          let x;
          if (position === "left") {
            if (mirror) {
              x = this.right + padding;
              if (crossAlign === "near") {
                textAlign = "left";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x += widest / 2;
              } else {
                textAlign = "right";
                x += widest;
              }
            } else {
              x = this.right - tickAndPadding;
              if (crossAlign === "near") {
                textAlign = "right";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x -= widest / 2;
              } else {
                textAlign = "left";
                x = this.left;
              }
            }
          } else if (position === "right") {
            if (mirror) {
              x = this.left + padding;
              if (crossAlign === "near") {
                textAlign = "right";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x -= widest / 2;
              } else {
                textAlign = "left";
                x -= widest;
              }
            } else {
              x = this.left + tickAndPadding;
              if (crossAlign === "near") {
                textAlign = "left";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x += widest / 2;
              } else {
                textAlign = "right";
                x = this.right;
              }
            }
          } else {
            textAlign = "right";
          }
          return {
            textAlign,
            x
          };
        }
        _computeLabelArea() {
          if (this.options.ticks.mirror) {
            return;
          }
          const chart = this.chart;
          const position = this.options.position;
          if (position === "left" || position === "right") {
            return {
              top: 0,
              left: this.left,
              bottom: chart.height,
              right: this.right
            };
          }
          if (position === "top" || position === "bottom") {
            return {
              top: this.top,
              left: 0,
              bottom: this.bottom,
              right: chart.width
            };
          }
        }
        drawBackground() {
          const {
            ctx,
            options: {backgroundColor},
            left,
            top,
            width,
            height
          } = this;
          if (backgroundColor) {
            ctx.save();
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(left, top, width, height);
            ctx.restore();
          }
        }
        getLineWidthForValue(value) {
          const grid = this.options.grid;
          if (!this._isVisible() || !grid.display) {
            return 0;
          }
          const ticks = this.ticks;
          const index = ticks.findIndex(t => t.value === value);
          if (index >= 0) {
            const opts = grid.setContext(this.getContext(index));
            return opts.lineWidth;
          }
          return 0;
        }
        drawGrid(chartArea) {
          const grid = this.options.grid;
          const ctx = this.ctx;
          const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
          let i, ilen;
          const drawLine = (p1, p2, style) => {
            if (!style.width || !style.color) {
              return;
            }
            ctx.save();
            ctx.lineWidth = style.width;
            ctx.strokeStyle = style.color;
            ctx.setLineDash(style.borderDash || []);
            ctx.lineDashOffset = style.borderDashOffset;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.restore();
          };
          if (grid.display) {
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              const item = items[i];
              if (grid.drawOnChartArea) {
                drawLine({
                  x: item.x1,
                  y: item.y1
                }, {
                  x: item.x2,
                  y: item.y2
                }, item);
              }
              if (grid.drawTicks) {
                drawLine({
                  x: item.tx1,
                  y: item.ty1
                }, {
                  x: item.tx2,
                  y: item.ty2
                }, {
                  color: item.tickColor,
                  width: item.tickWidth,
                  borderDash: item.tickBorderDash,
                  borderDashOffset: item.tickBorderDashOffset
                });
              }
            }
          }
        }
        drawBorder() {
          const {
            chart,
            ctx,
            options: {grid}
          } = this;
          const borderOpts = grid.setContext(this.getContext());
          const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
          if (!axisWidth) {
            return;
          }
          const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
          const borderValue = this._borderValue;
          let x1, x2, y1, y2;
          if (this.isHorizontal()) {
            x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
            x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
          } else {
            y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
            y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
          }
          ctx.save();
          ctx.lineWidth = borderOpts.borderWidth;
          ctx.strokeStyle = borderOpts.borderColor;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.restore();
        }
        drawLabels(chartArea) {
          const optionTicks = this.options.ticks;
          if (!optionTicks.display) {
            return;
          }
          const ctx = this.ctx;
          const area = this._computeLabelArea();
          if (area) {
            clipArea(ctx, area);
          }
          const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
          let i, ilen;
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            const item = items[i];
            const tickFont = item.font;
            const label = item.label;
            if (item.backdrop) {
              ctx.fillStyle = item.backdrop.color;
              ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
            }
            let y = item.textOffset;
            renderText(ctx, label, 0, y, tickFont, item);
          }
          if (area) {
            unclipArea(ctx);
          }
        }
        drawTitle() {
          const {
            ctx,
            options: {position, title, reverse}
          } = this;
          if (!title.display) {
            return;
          }
          const font = toFont(title.font);
          const padding = toPadding(title.padding);
          const align = title.align;
          let offset = font.lineHeight / 2;
          if (position === "bottom" || position === "center" || isObject(position)) {
            offset += padding.bottom;
            if (isArray(title.text)) {
              offset += font.lineHeight * (title.text.length - 1);
            }
          } else {
            offset += padding.top;
          }
          const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);
          renderText(ctx, title.text, 0, 0, font, {
            color: title.color,
            maxWidth,
            rotation,
            textAlign: titleAlign(align, position, reverse),
            textBaseline: "middle",
            translation: [
              titleX,
              titleY
            ]
          });
        }
        draw(chartArea) {
          if (!this._isVisible()) {
            return;
          }
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawBorder();
          this.drawTitle();
          this.drawLabels(chartArea);
        }
        _layers() {
          const opts = this.options;
          const tz = opts.ticks && opts.ticks.z || 0;
          const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
          if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
            return [{
                z: tz,
                draw: chartArea => {
                  this.draw(chartArea);
                }
              }];
          }
          return [
            {
              z: gz,
              draw: chartArea => {
                this.drawBackground();
                this.drawGrid(chartArea);
                this.drawTitle();
              }
            },
            {
              z: gz + 1,
              draw: () => {
                this.drawBorder();
              }
            },
            {
              z: tz,
              draw: chartArea => {
                this.drawLabels(chartArea);
              }
            }
          ];
        }
        getMatchingVisibleMetas(type) {
          const metas = this.chart.getSortedVisibleDatasetMetas();
          const axisID = this.axis + "AxisID";
          const result = [];
          let i, ilen;
          for (i = 0, ilen = metas.length; i < ilen; ++i) {
            const meta = metas[i];
            if (meta[axisID] === this.id && (!type || meta.type === type)) {
              result.push(meta);
            }
          }
          return result;
        }
        _resolveTickFontOptions(index) {
          const opts = this.options.ticks.setContext(this.getContext(index));
          return toFont(opts.font);
        }
        _maxDigits() {
          const fontSize = this._resolveTickFontOptions(0).lineHeight;
          return (this.isHorizontal() ? this.width : this.height) / fontSize;
        }
      }
      class TypedRegistry {
        constructor(type, scope, override) {
          this.type = type;
          this.scope = scope;
          this.override = override;
          this.items = Object.create(null);
        }
        isForType(type) {
          return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
        }
        register(item) {
          const proto = Object.getPrototypeOf(item);
          let parentScope;
          if (isIChartComponent(proto)) {
            parentScope = this.register(proto);
          }
          const items = this.items;
          const id = item.id;
          const scope = this.scope + "." + id;
          if (!id) {
            throw new Error("class does not have id: " + item);
          }
          if (id in items) {
            return scope;
          }
          items[id] = item;
          registerDefaults(item, scope, parentScope);
          if (this.override) {
            defaults.override(item.id, item.overrides);
          }
          return scope;
        }
        get(id) {
          return this.items[id];
        }
        unregister(item) {
          const items = this.items;
          const id = item.id;
          const scope = this.scope;
          if (id in items) {
            delete items[id];
          }
          if (scope && id in defaults[scope]) {
            delete defaults[scope][id];
            if (this.override) {
              delete overrides[id];
            }
          }
        }
      }
      function registerDefaults(item, scope, parentScope) {
        const itemDefaults = merge(Object.create(null), [
          parentScope ? defaults.get(parentScope) : {},
          defaults.get(scope),
          item.defaults
        ]);
        defaults.set(scope, itemDefaults);
        if (item.defaultRoutes) {
          routeDefaults(scope, item.defaultRoutes);
        }
        if (item.descriptors) {
          defaults.describe(scope, item.descriptors);
        }
      }
      function routeDefaults(scope, routes) {
        Object.keys(routes).forEach(property => {
          const propertyParts = property.split(".");
          const sourceName = propertyParts.pop();
          const sourceScope = [scope].concat(propertyParts).join(".");
          const parts = routes[property].split(".");
          const targetName = parts.pop();
          const targetScope = parts.join(".");
          defaults.route(sourceScope, sourceName, targetScope, targetName);
        });
      }
      function isIChartComponent(proto) {
        return "id" in proto && "defaults" in proto;
      }
      class Registry {
        constructor() {
          this.controllers = new TypedRegistry(DatasetController, "datasets", true);
          this.elements = new TypedRegistry(Element, "elements");
          this.plugins = new TypedRegistry(Object, "plugins");
          this.scales = new TypedRegistry(Scale, "scales");
          this._typedRegistries = [
            this.controllers,
            this.scales,
            this.elements
          ];
        }
        add(...args) {
          this._each("register", args);
        }
        remove(...args) {
          this._each("unregister", args);
        }
        addControllers(...args) {
          this._each("register", args, this.controllers);
        }
        addElements(...args) {
          this._each("register", args, this.elements);
        }
        addPlugins(...args) {
          this._each("register", args, this.plugins);
        }
        addScales(...args) {
          this._each("register", args, this.scales);
        }
        getController(id) {
          return this._get(id, this.controllers, "controller");
        }
        getElement(id) {
          return this._get(id, this.elements, "element");
        }
        getPlugin(id) {
          return this._get(id, this.plugins, "plugin");
        }
        getScale(id) {
          return this._get(id, this.scales, "scale");
        }
        removeControllers(...args) {
          this._each("unregister", args, this.controllers);
        }
        removeElements(...args) {
          this._each("unregister", args, this.elements);
        }
        removePlugins(...args) {
          this._each("unregister", args, this.plugins);
        }
        removeScales(...args) {
          this._each("unregister", args, this.scales);
        }
        _each(method, args, typedRegistry) {
          [...args].forEach(arg => {
            const reg = typedRegistry || this._getRegistryForType(arg);
            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
              this._exec(method, reg, arg);
            } else {
              each(arg, item => {
                const itemReg = typedRegistry || this._getRegistryForType(item);
                this._exec(method, itemReg, item);
              });
            }
          });
        }
        _exec(method, registry, component) {
          const camelMethod = _capitalize(method);
          callback(component["before" + camelMethod], [], component);
          registry[method](component);
          callback(component["after" + camelMethod], [], component);
        }
        _getRegistryForType(type) {
          for (let i = 0; i < this._typedRegistries.length; i++) {
            const reg = this._typedRegistries[i];
            if (reg.isForType(type)) {
              return reg;
            }
          }
          return this.plugins;
        }
        _get(id, typedRegistry, type) {
          const item = typedRegistry.get(id);
          if (item === undefined) {
            throw new Error("\"" + id + "\" is not a registered " + type + ".");
          }
          return item;
        }
      }
      var registry = new Registry();
      class ScatterController extends DatasetController {
        update(mode) {
          const meta = this._cachedMeta;
          const {
            data: points = []
          } = meta;
          const animationsDisabled = this.chart._animationsDisabled;
          let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
          this._drawStart = start;
          this._drawCount = count;
          if (_scaleRangesChanged(meta)) {
            start = 0;
            count = points.length;
          }
          if (this.options.showLine) {
            const {
              dataset: line,
              _dataset
            } = meta;
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            options.segment = this.options.segment;
            this.updateElement(line, undefined, {
              animated: !animationsDisabled,
              options
            }, mode);
          }
          this.updateElements(points, start, count, mode);
        }
        addElements() {
          const {showLine} = this.options;
          if (!this.datasetElementType && showLine) {
            this.datasetElementType = registry.getElement("line");
          }
          super.addElements();
        }
        updateElements(points, start, count, mode) {
          const reset = mode === "reset";
          const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;
          const firstOpts = this.resolveDataElementOptions(start, mode);
          const sharedOptions = this.getSharedOptions(firstOpts);
          const includeOptions = this.includeOptions(mode, sharedOptions);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const {spanGaps, segment} = this.options;
          const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
          const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
          let prevParsed = start > 0 && this.getParsed(start - 1);
          for (let i = start; i < start + count; ++i) {
            const point = points[i];
            const parsed = this.getParsed(i);
            const properties = directUpdate ? point : {};
            const nullData = isNullOrUndef(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
            if (segment) {
              properties.parsed = parsed;
              properties.raw = _dataset.data[i];
            }
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
            }
            if (!directUpdate) {
              this.updateElement(point, i, properties, mode);
            }
            prevParsed = parsed;
          }
          this.updateSharedOptions(sharedOptions, mode, firstOpts);
        }
        getMaxOverflow() {
          const meta = this._cachedMeta;
          const data = meta.data || [];
          if (!this.options.showLine) {
            let max = 0;
            for (let i = data.length - 1; i >= 0; --i) {
              max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
            }
            return max > 0 && max;
          }
          const dataset = meta.dataset;
          const border = dataset.options && dataset.options.borderWidth || 0;
          if (!data.length) {
            return border;
          }
          const firstPoint = data[0].size(this.resolveDataElementOptions(0));
          const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
          return Math.max(border, firstPoint, lastPoint) / 2;
        }
      }
      ScatterController.id = "scatter";
      ScatterController.defaults = {
        datasetElementType: false,
        dataElementType: "point",
        showLine: false,
        fill: false
      };
      ScatterController.overrides = {
        interaction: { mode: "point" },
        plugins: {
          tooltip: {
            callbacks: {
              title() {
                return "";
              },
              label(item) {
                return "(" + item.label + ", " + item.formattedValue + ")";
              }
            }
          }
        },
        scales: {
          x: { type: "linear" },
          y: { type: "linear" }
        }
      };
      var controllers = Object.freeze({
        __proto__: null,
        BarController: BarController,
        BubbleController: BubbleController,
        DoughnutController: DoughnutController,
        LineController: LineController,
        PolarAreaController: PolarAreaController,
        PieController: PieController,
        RadarController: RadarController,
        ScatterController: ScatterController
      });
      function abstract() {
        throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
      }
      class DateAdapter {
        constructor(options) {
          this.options = options || {};
        }
        init(chartOptions) {
        }
        formats() {
          return abstract();
        }
        parse(value, format) {
          return abstract();
        }
        format(timestamp, format) {
          return abstract();
        }
        add(timestamp, amount, unit) {
          return abstract();
        }
        diff(a, b, unit) {
          return abstract();
        }
        startOf(timestamp, unit, weekday) {
          return abstract();
        }
        endOf(timestamp, unit) {
          return abstract();
        }
      }
      DateAdapter.override = function (members) {
        Object.assign(DateAdapter.prototype, members);
      };
      var adapters = { _date: DateAdapter };
      function binarySearch(metaset, axis, value, intersect) {
        const {controller, data, _sorted} = metaset;
        const iScale = controller._cachedMeta.iScale;
        if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
          const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
          if (!intersect) {
            return lookupMethod(data, axis, value);
          } else if (controller._sharedOptions) {
            const el = data[0];
            const range = typeof el.getRange === "function" && el.getRange(axis);
            if (range) {
              const start = lookupMethod(data, axis, value - range);
              const end = lookupMethod(data, axis, value + range);
              return {
                lo: start.lo,
                hi: end.hi
              };
            }
          }
        }
        return {
          lo: 0,
          hi: data.length - 1
        };
      }
      function evaluateInteractionItems(chart, axis, position, handler, intersect) {
        const metasets = chart.getSortedVisibleDatasetMetas();
        const value = position[axis];
        for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
          const {index, data} = metasets[i];
          const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);
          for (let j = lo; j <= hi; ++j) {
            const element = data[j];
            if (!element.skip) {
              handler(element, index, j);
            }
          }
        }
      }
      function getDistanceMetricForAxis(axis) {
        const useX = axis.indexOf("x") !== -1;
        const useY = axis.indexOf("y") !== -1;
        return function (pt1, pt2) {
          const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
          const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
          return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
        };
      }
      function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
        const items = [];
        if (!includeInvisible && !chart.isPointInArea(position)) {
          return items;
        }
        const evaluationFunc = function (element, datasetIndex, index) {
          if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
            return;
          }
          if (element.inRange(position.x, position.y, useFinalPosition)) {
            items.push({
              element,
              datasetIndex,
              index
            });
          }
        };
        evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
        return items;
      }
      function getNearestRadialItems(chart, position, axis, useFinalPosition) {
        let items = [];
        function evaluationFunc(element, datasetIndex, index) {
          const {startAngle, endAngle} = element.getProps([
            "startAngle",
            "endAngle"
          ], useFinalPosition);
          const {angle} = getAngleFromPoint(element, {
            x: position.x,
            y: position.y
          });
          if (_angleBetween(angle, startAngle, endAngle)) {
            items.push({
              element,
              datasetIndex,
              index
            });
          }
        }
        evaluateInteractionItems(chart, axis, position, evaluationFunc);
        return items;
      }
      function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
        let items = [];
        const distanceMetric = getDistanceMetricForAxis(axis);
        let minDistance = Number.POSITIVE_INFINITY;
        function evaluationFunc(element, datasetIndex, index) {
          const inRange = element.inRange(position.x, position.y, useFinalPosition);
          if (intersect && !inRange) {
            return;
          }
          const center = element.getCenterPoint(useFinalPosition);
          const pointInArea = !!includeInvisible || chart.isPointInArea(center);
          if (!pointInArea && !inRange) {
            return;
          }
          const distance = distanceMetric(position, center);
          if (distance < minDistance) {
            items = [{
                element,
                datasetIndex,
                index
              }];
            minDistance = distance;
          } else if (distance === minDistance) {
            items.push({
              element,
              datasetIndex,
              index
            });
          }
        }
        evaluateInteractionItems(chart, axis, position, evaluationFunc);
        return items;
      }
      function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
        if (!includeInvisible && !chart.isPointInArea(position)) {
          return [];
        }
        return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
      }
      function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
        const items = [];
        const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
        let intersectsItem = false;
        evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {
          if (element[rangeMethod](position[axis], useFinalPosition)) {
            items.push({
              element,
              datasetIndex,
              index
            });
            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
          }
        });
        if (intersect && !intersectsItem) {
          return [];
        }
        return items;
      }
      var Interaction = {
        evaluateInteractionItems,
        modes: {
          index(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || "x";
            const includeInvisible = options.includeInvisible || false;
            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            const elements = [];
            if (!items.length) {
              return [];
            }
            chart.getSortedVisibleDatasetMetas().forEach(meta => {
              const index = items[0].index;
              const element = meta.data[index];
              if (element && !element.skip) {
                elements.push({
                  element,
                  datasetIndex: meta.index,
                  index
                });
              }
            });
            return elements;
          },
          dataset(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            if (items.length > 0) {
              const datasetIndex = items[0].datasetIndex;
              const data = chart.getDatasetMeta(datasetIndex).data;
              items = [];
              for (let i = 0; i < data.length; ++i) {
                items.push({
                  element: data[i],
                  datasetIndex,
                  index: i
                });
              }
            }
            return items;
          },
          point(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
          },
          nearest(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
          },
          x(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
          },
          y(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
          }
        }
      };
      const STATIC_POSITIONS = [
        "left",
        "top",
        "right",
        "bottom"
      ];
      function filterByPosition(array, position) {
        return array.filter(v => v.pos === position);
      }
      function filterDynamicPositionByAxis(array, axis) {
        return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
      }
      function sortByWeight(array, reverse) {
        return array.sort((a, b) => {
          const v0 = reverse ? b : a;
          const v1 = reverse ? a : b;
          return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
        });
      }
      function wrapBoxes(boxes) {
        const layoutBoxes = [];
        let i, ilen, box, pos, stack, stackWeight;
        for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
          box = boxes[i];
          ({
            position: pos,
            options: {stack, stackWeight = 1}
          } = box);
          layoutBoxes.push({
            index: i,
            box,
            pos,
            horizontal: box.isHorizontal(),
            weight: box.weight,
            stack: stack && pos + stack,
            stackWeight
          });
        }
        return layoutBoxes;
      }
      function buildStacks(layouts) {
        const stacks = {};
        for (const wrap of layouts) {
          const {stack, pos, stackWeight} = wrap;
          if (!stack || !STATIC_POSITIONS.includes(pos)) {
            continue;
          }
          const _stack = stacks[stack] || (stacks[stack] = {
            count: 0,
            placed: 0,
            weight: 0,
            size: 0
          });
          _stack.count++;
          _stack.weight += stackWeight;
        }
        return stacks;
      }
      function setLayoutDims(layouts, params) {
        const stacks = buildStacks(layouts);
        const {vBoxMaxWidth, hBoxMaxHeight} = params;
        let i, ilen, layout;
        for (i = 0, ilen = layouts.length; i < ilen; ++i) {
          layout = layouts[i];
          const {fullSize} = layout.box;
          const stack = stacks[layout.stack];
          const factor = stack && layout.stackWeight / stack.weight;
          if (layout.horizontal) {
            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
            layout.height = hBoxMaxHeight;
          } else {
            layout.width = vBoxMaxWidth;
            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
          }
        }
        return stacks;
      }
      function buildLayoutBoxes(boxes) {
        const layoutBoxes = wrapBoxes(boxes);
        const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);
        const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
        const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
        const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
        const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
        const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
        const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
        return {
          fullSize,
          leftAndTop: left.concat(top),
          rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
          chartArea: filterByPosition(layoutBoxes, "chartArea"),
          vertical: left.concat(right).concat(centerVertical),
          horizontal: top.concat(bottom).concat(centerHorizontal)
        };
      }
      function getCombinedMax(maxPadding, chartArea, a, b) {
        return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
      }
      function updateMaxPadding(maxPadding, boxPadding) {
        maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
        maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
        maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
        maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
      }
      function updateDims(chartArea, params, layout, stacks) {
        const {pos, box} = layout;
        const maxPadding = chartArea.maxPadding;
        if (!isObject(pos)) {
          if (layout.size) {
            chartArea[pos] -= layout.size;
          }
          const stack = stacks[layout.stack] || {
            size: 0,
            count: 1
          };
          stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
          layout.size = stack.size / stack.count;
          chartArea[pos] += layout.size;
        }
        if (box.getPadding) {
          updateMaxPadding(maxPadding, box.getPadding());
        }
        const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
        const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
        const widthChanged = newWidth !== chartArea.w;
        const heightChanged = newHeight !== chartArea.h;
        chartArea.w = newWidth;
        chartArea.h = newHeight;
        return layout.horizontal ? {
          same: widthChanged,
          other: heightChanged
        } : {
          same: heightChanged,
          other: widthChanged
        };
      }
      function handleMaxPadding(chartArea) {
        const maxPadding = chartArea.maxPadding;
        function updatePos(pos) {
          const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
          chartArea[pos] += change;
          return change;
        }
        chartArea.y += updatePos("top");
        chartArea.x += updatePos("left");
        updatePos("right");
        updatePos("bottom");
      }
      function getMargins(horizontal, chartArea) {
        const maxPadding = chartArea.maxPadding;
        function marginForPositions(positions) {
          const margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          };
          positions.forEach(pos => {
            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
          });
          return margin;
        }
        return horizontal ? marginForPositions([
          "left",
          "right"
        ]) : marginForPositions([
          "top",
          "bottom"
        ]);
      }
      function fitBoxes(boxes, chartArea, params, stacks) {
        const refitBoxes = [];
        let i, ilen, layout, box, refit, changed;
        for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
          layout = boxes[i];
          box = layout.box;
          box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
          const {same, other} = updateDims(chartArea, params, layout, stacks);
          refit |= same && refitBoxes.length;
          changed = changed || other;
          if (!box.fullSize) {
            refitBoxes.push(layout);
          }
        }
        return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
      }
      function setBoxDims(box, left, top, width, height) {
        box.top = top;
        box.left = left;
        box.right = left + width;
        box.bottom = top + height;
        box.width = width;
        box.height = height;
      }
      function placeBoxes(boxes, chartArea, params, stacks) {
        const userPadding = params.padding;
        let {x, y} = chartArea;
        for (const layout of boxes) {
          const box = layout.box;
          const stack = stacks[layout.stack] || {
            count: 1,
            placed: 0,
            weight: 1
          };
          const weight = layout.stackWeight / stack.weight || 1;
          if (layout.horizontal) {
            const width = chartArea.w * weight;
            const height = stack.size || box.height;
            if (defined(stack.start)) {
              y = stack.start;
            }
            if (box.fullSize) {
              setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
            } else {
              setBoxDims(box, chartArea.left + stack.placed, y, width, height);
            }
            stack.start = y;
            stack.placed += width;
            y = box.bottom;
          } else {
            const height = chartArea.h * weight;
            const width = stack.size || box.width;
            if (defined(stack.start)) {
              x = stack.start;
            }
            if (box.fullSize) {
              setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
            } else {
              setBoxDims(box, x, chartArea.top + stack.placed, width, height);
            }
            stack.start = x;
            stack.placed += height;
            x = box.right;
          }
        }
        chartArea.x = x;
        chartArea.y = y;
      }
      defaults.set("layout", {
        autoPadding: true,
        padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      });
      var layouts = {
        addBox(chart, item) {
          if (!chart.boxes) {
            chart.boxes = [];
          }
          item.fullSize = item.fullSize || false;
          item.position = item.position || "top";
          item.weight = item.weight || 0;
          item._layers = item._layers || function () {
            return [{
                z: 0,
                draw(chartArea) {
                  item.draw(chartArea);
                }
              }];
          };
          chart.boxes.push(item);
        },
        removeBox(chart, layoutItem) {
          const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
          if (index !== -1) {
            chart.boxes.splice(index, 1);
          }
        },
        configure(chart, item, options) {
          item.fullSize = options.fullSize;
          item.position = options.position;
          item.weight = options.weight;
        },
        update(chart, width, height, minPadding) {
          if (!chart) {
            return;
          }
          const padding = toPadding(chart.options.layout.padding);
          const availableWidth = Math.max(width - padding.width, 0);
          const availableHeight = Math.max(height - padding.height, 0);
          const boxes = buildLayoutBoxes(chart.boxes);
          const verticalBoxes = boxes.vertical;
          const horizontalBoxes = boxes.horizontal;
          each(chart.boxes, box => {
            if (typeof box.beforeLayout === "function") {
              box.beforeLayout();
            }
          });
          const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
          const params = Object.freeze({
            outerWidth: width,
            outerHeight: height,
            padding,
            availableWidth,
            availableHeight,
            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
            hBoxMaxHeight: availableHeight / 2
          });
          const maxPadding = Object.assign({}, padding);
          updateMaxPadding(maxPadding, toPadding(minPadding));
          const chartArea = Object.assign({
            maxPadding,
            w: availableWidth,
            h: availableHeight,
            x: padding.left,
            y: padding.top
          }, padding);
          const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
          fitBoxes(boxes.fullSize, chartArea, params, stacks);
          fitBoxes(verticalBoxes, chartArea, params, stacks);
          if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
            fitBoxes(verticalBoxes, chartArea, params, stacks);
          }
          handleMaxPadding(chartArea);
          placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
          chartArea.x += chartArea.w;
          chartArea.y += chartArea.h;
          placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
          chart.chartArea = {
            left: chartArea.left,
            top: chartArea.top,
            right: chartArea.left + chartArea.w,
            bottom: chartArea.top + chartArea.h,
            height: chartArea.h,
            width: chartArea.w
          };
          each(boxes.chartArea, layout => {
            const box = layout.box;
            Object.assign(box, chart.chartArea);
            box.update(chartArea.w, chartArea.h, {
              left: 0,
              top: 0,
              right: 0,
              bottom: 0
            });
          });
        }
      };
      class BasePlatform {
        acquireContext(canvas, aspectRatio) {
        }
        releaseContext(context) {
          return false;
        }
        addEventListener(chart, type, listener) {
        }
        removeEventListener(chart, type, listener) {
        }
        getDevicePixelRatio() {
          return 1;
        }
        getMaximumSize(element, width, height, aspectRatio) {
          width = Math.max(0, width || element.width);
          height = height || element.height;
          return {
            width,
            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
          };
        }
        isAttached(canvas) {
          return true;
        }
        updateConfig(config) {
        }
      }
      class BasicPlatform extends BasePlatform {
        acquireContext(item) {
          return item && item.getContext && item.getContext("2d") || null;
        }
        updateConfig(config) {
          config.options.animation = false;
        }
      }
      const EXPANDO_KEY = "$chartjs";
      const EVENT_TYPES = {
        touchstart: "mousedown",
        touchmove: "mousemove",
        touchend: "mouseup",
        pointerenter: "mouseenter",
        pointerdown: "mousedown",
        pointermove: "mousemove",
        pointerup: "mouseup",
        pointerleave: "mouseout",
        pointerout: "mouseout"
      };
      const isNullOrEmpty = value => value === null || value === "";
      function initCanvas(canvas, aspectRatio) {
        const style = canvas.style;
        const renderHeight = canvas.getAttribute("height");
        const renderWidth = canvas.getAttribute("width");
        canvas[EXPANDO_KEY] = {
          initial: {
            height: renderHeight,
            width: renderWidth,
            style: {
              display: style.display,
              height: style.height,
              width: style.width
            }
          }
        };
        style.display = style.display || "block";
        style.boxSizing = style.boxSizing || "border-box";
        if (isNullOrEmpty(renderWidth)) {
          const displayWidth = readUsedSize(canvas, "width");
          if (displayWidth !== undefined) {
            canvas.width = displayWidth;
          }
        }
        if (isNullOrEmpty(renderHeight)) {
          if (canvas.style.height === "") {
            canvas.height = canvas.width / (aspectRatio || 2);
          } else {
            const displayHeight = readUsedSize(canvas, "height");
            if (displayHeight !== undefined) {
              canvas.height = displayHeight;
            }
          }
        }
        return canvas;
      }
      const eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
      function addListener(node, type, listener) {
        node.addEventListener(type, listener, eventListenerOptions);
      }
      function removeListener(chart, type, listener) {
        chart.canvas.removeEventListener(type, listener, eventListenerOptions);
      }
      function fromNativeEvent(event, chart) {
        const type = EVENT_TYPES[event.type] || event.type;
        const {x, y} = getRelativePosition(event, chart);
        return {
          type,
          chart,
          native: event,
          x: x !== undefined ? x : null,
          y: y !== undefined ? y : null
        };
      }
      function nodeListContains(nodeList, canvas) {
        for (const node of nodeList) {
          if (node === canvas || node.contains(canvas)) {
            return true;
          }
        }
      }
      function createAttachObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const observer = new MutationObserver(entries => {
          let trigger = false;
          for (const entry of entries) {
            trigger = trigger || nodeListContains(entry.addedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
          }
          if (trigger) {
            listener();
          }
        });
        observer.observe(document, {
          childList: true,
          subtree: true
        });
        return observer;
      }
      function createDetachObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const observer = new MutationObserver(entries => {
          let trigger = false;
          for (const entry of entries) {
            trigger = trigger || nodeListContains(entry.removedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
          }
          if (trigger) {
            listener();
          }
        });
        observer.observe(document, {
          childList: true,
          subtree: true
        });
        return observer;
      }
      const drpListeningCharts = new Map();
      let oldDevicePixelRatio = 0;
      function onWindowResize() {
        const dpr = window.devicePixelRatio;
        if (dpr === oldDevicePixelRatio) {
          return;
        }
        oldDevicePixelRatio = dpr;
        drpListeningCharts.forEach((resize, chart) => {
          if (chart.currentDevicePixelRatio !== dpr) {
            resize();
          }
        });
      }
      function listenDevicePixelRatioChanges(chart, resize) {
        if (!drpListeningCharts.size) {
          window.addEventListener("resize", onWindowResize);
        }
        drpListeningCharts.set(chart, resize);
      }
      function unlistenDevicePixelRatioChanges(chart) {
        drpListeningCharts.delete(chart);
        if (!drpListeningCharts.size) {
          window.removeEventListener("resize", onWindowResize);
        }
      }
      function createResizeObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const container = canvas && _getParentNode(canvas);
        if (!container) {
          return;
        }
        const resize = throttled((width, height) => {
          const w = container.clientWidth;
          listener(width, height);
          if (w < container.clientWidth) {
            listener();
          }
        }, window);
        const observer = new ResizeObserver(entries => {
          const entry = entries[0];
          const width = entry.contentRect.width;
          const height = entry.contentRect.height;
          if (width === 0 && height === 0) {
            return;
          }
          resize(width, height);
        });
        observer.observe(container);
        listenDevicePixelRatioChanges(chart, resize);
        return observer;
      }
      function releaseObserver(chart, type, observer) {
        if (observer) {
          observer.disconnect();
        }
        if (type === "resize") {
          unlistenDevicePixelRatioChanges(chart);
        }
      }
      function createProxyAndListen(chart, type, listener) {
        const canvas = chart.canvas;
        const proxy = throttled(event => {
          if (chart.ctx !== null) {
            listener(fromNativeEvent(event, chart));
          }
        }, chart, args => {
          const event = args[0];
          return [
            event,
            event.offsetX,
            event.offsetY
          ];
        });
        addListener(canvas, type, proxy);
        return proxy;
      }
      class DomPlatform extends BasePlatform {
        acquireContext(canvas, aspectRatio) {
          const context = canvas && canvas.getContext && canvas.getContext("2d");
          if (context && context.canvas === canvas) {
            initCanvas(canvas, aspectRatio);
            return context;
          }
          return null;
        }
        releaseContext(context) {
          const canvas = context.canvas;
          if (!canvas[EXPANDO_KEY]) {
            return false;
          }
          const initial = canvas[EXPANDO_KEY].initial;
          [
            "height",
            "width"
          ].forEach(prop => {
            const value = initial[prop];
            if (isNullOrUndef(value)) {
              canvas.removeAttribute(prop);
            } else {
              canvas.setAttribute(prop, value);
            }
          });
          const style = initial.style || {};
          Object.keys(style).forEach(key => {
            canvas.style[key] = style[key];
          });
          canvas.width = canvas.width;
          delete canvas[EXPANDO_KEY];
          return true;
        }
        addEventListener(chart, type, listener) {
          this.removeEventListener(chart, type);
          const proxies = chart.$proxies || (chart.$proxies = {});
          const handlers = {
            attach: createAttachObserver,
            detach: createDetachObserver,
            resize: createResizeObserver
          };
          const handler = handlers[type] || createProxyAndListen;
          proxies[type] = handler(chart, type, listener);
        }
        removeEventListener(chart, type) {
          const proxies = chart.$proxies || (chart.$proxies = {});
          const proxy = proxies[type];
          if (!proxy) {
            return;
          }
          const handlers = {
            attach: releaseObserver,
            detach: releaseObserver,
            resize: releaseObserver
          };
          const handler = handlers[type] || removeListener;
          handler(chart, type, proxy);
          proxies[type] = undefined;
        }
        getDevicePixelRatio() {
          return window.devicePixelRatio;
        }
        getMaximumSize(canvas, width, height, aspectRatio) {
          return getMaximumSize(canvas, width, height, aspectRatio);
        }
        isAttached(canvas) {
          const container = _getParentNode(canvas);
          return !!(container && container.isConnected);
        }
      }
      function _detectPlatform(canvas) {
        if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
          return BasicPlatform;
        }
        return DomPlatform;
      }
      class PluginService {
        constructor() {
          this._init = [];
        }
        notify(chart, hook, args, filter) {
          if (hook === "beforeInit") {
            this._init = this._createDescriptors(chart, true);
            this._notify(this._init, chart, "install");
          }
          const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
          const result = this._notify(descriptors, chart, hook, args);
          if (hook === "afterDestroy") {
            this._notify(descriptors, chart, "stop");
            this._notify(this._init, chart, "uninstall");
          }
          return result;
        }
        _notify(descriptors, chart, hook, args) {
          args = args || {};
          for (const descriptor of descriptors) {
            const plugin = descriptor.plugin;
            const method = plugin[hook];
            const params = [
              chart,
              args,
              descriptor.options
            ];
            if (callback(method, params, plugin) === false && args.cancelable) {
              return false;
            }
          }
          return true;
        }
        invalidate() {
          if (!isNullOrUndef(this._cache)) {
            this._oldCache = this._cache;
            this._cache = undefined;
          }
        }
        _descriptors(chart) {
          if (this._cache) {
            return this._cache;
          }
          const descriptors = this._cache = this._createDescriptors(chart);
          this._notifyStateChanges(chart);
          return descriptors;
        }
        _createDescriptors(chart, all) {
          const config = chart && chart.config;
          const options = valueOrDefault(config.options && config.options.plugins, {});
          const plugins = allPlugins(config);
          return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
        }
        _notifyStateChanges(chart) {
          const previousDescriptors = this._oldCache || [];
          const descriptors = this._cache;
          const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));
          this._notify(diff(previousDescriptors, descriptors), chart, "stop");
          this._notify(diff(descriptors, previousDescriptors), chart, "start");
        }
      }
      function allPlugins(config) {
        const localIds = {};
        const plugins = [];
        const keys = Object.keys(registry.plugins.items);
        for (let i = 0; i < keys.length; i++) {
          plugins.push(registry.getPlugin(keys[i]));
        }
        const local = config.plugins || [];
        for (let i = 0; i < local.length; i++) {
          const plugin = local[i];
          if (plugins.indexOf(plugin) === -1) {
            plugins.push(plugin);
            localIds[plugin.id] = true;
          }
        }
        return {
          plugins,
          localIds
        };
      }
      function getOpts(options, all) {
        if (!all && options === false) {
          return null;
        }
        if (options === true) {
          return {};
        }
        return options;
      }
      function createDescriptors(chart, {plugins, localIds}, options, all) {
        const result = [];
        const context = chart.getContext();
        for (const plugin of plugins) {
          const id = plugin.id;
          const opts = getOpts(options[id], all);
          if (opts === null) {
            continue;
          }
          result.push({
            plugin,
            options: pluginOpts(chart.config, {
              plugin,
              local: localIds[id]
            }, opts, context)
          });
        }
        return result;
      }
      function pluginOpts(config, {plugin, local}, opts, context) {
        const keys = config.pluginScopeKeys(plugin);
        const scopes = config.getOptionScopes(opts, keys);
        if (local && plugin.defaults) {
          scopes.push(plugin.defaults);
        }
        return config.createResolver(scopes, context, [""], {
          scriptable: false,
          indexable: false,
          allKeys: true
        });
      }
      function getIndexAxis(type, options) {
        const datasetDefaults = defaults.datasets[type] || {};
        const datasetOptions = (options.datasets || {})[type] || {};
        return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
      }
      function getAxisFromDefaultScaleID(id, indexAxis) {
        let axis = id;
        if (id === "_index_") {
          axis = indexAxis;
        } else if (id === "_value_") {
          axis = indexAxis === "x" ? "y" : "x";
        }
        return axis;
      }
      function getDefaultScaleIDFromAxis(axis, indexAxis) {
        return axis === indexAxis ? "_index_" : "_value_";
      }
      function axisFromPosition(position) {
        if (position === "top" || position === "bottom") {
          return "x";
        }
        if (position === "left" || position === "right") {
          return "y";
        }
      }
      function determineAxis(id, scaleOptions) {
        if (id === "x" || id === "y") {
          return id;
        }
        return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
      }
      function mergeScaleConfig(config, options) {
        const chartDefaults = overrides[config.type] || { scales: {} };
        const configScales = options.scales || {};
        const chartIndexAxis = getIndexAxis(config.type, options);
        const firstIDs = Object.create(null);
        const scales = Object.create(null);
        Object.keys(configScales).forEach(id => {
          const scaleConf = configScales[id];
          if (!isObject(scaleConf)) {
            return console.error(`Invalid scale configuration for scale: ${ id }`);
          }
          if (scaleConf._proxy) {
            return console.warn(`Ignoring resolver passed as options for scale: ${ id }`);
          }
          const axis = determineAxis(id, scaleConf);
          const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
          const defaultScaleOptions = chartDefaults.scales || {};
          firstIDs[axis] = firstIDs[axis] || id;
          scales[id] = mergeIf(Object.create(null), [
            { axis },
            scaleConf,
            defaultScaleOptions[axis],
            defaultScaleOptions[defaultId]
          ]);
        });
        config.data.datasets.forEach(dataset => {
          const type = dataset.type || config.type;
          const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
          const datasetDefaults = overrides[type] || {};
          const defaultScaleOptions = datasetDefaults.scales || {};
          Object.keys(defaultScaleOptions).forEach(defaultID => {
            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
            const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
            scales[id] = scales[id] || Object.create(null);
            mergeIf(scales[id], [
              { axis },
              configScales[id],
              defaultScaleOptions[defaultID]
            ]);
          });
        });
        Object.keys(scales).forEach(key => {
          const scale = scales[key];
          mergeIf(scale, [
            defaults.scales[scale.type],
            defaults.scale
          ]);
        });
        return scales;
      }
      function initOptions(config) {
        const options = config.options || (config.options = {});
        options.plugins = valueOrDefault(options.plugins, {});
        options.scales = mergeScaleConfig(config, options);
      }
      function initData(data) {
        data = data || {};
        data.datasets = data.datasets || [];
        data.labels = data.labels || [];
        return data;
      }
      function initConfig(config) {
        config = config || {};
        config.data = initData(config.data);
        initOptions(config);
        return config;
      }
      const keyCache = new Map();
      const keysCached = new Set();
      function cachedKeys(cacheKey, generate) {
        let keys = keyCache.get(cacheKey);
        if (!keys) {
          keys = generate();
          keyCache.set(cacheKey, keys);
          keysCached.add(keys);
        }
        return keys;
      }
      const addIfFound = (set, obj, key) => {
        const opts = resolveObjectKey(obj, key);
        if (opts !== undefined) {
          set.add(opts);
        }
      };
      class Config {
        constructor(config) {
          this._config = initConfig(config);
          this._scopeCache = new Map();
          this._resolverCache = new Map();
        }
        get platform() {
          return this._config.platform;
        }
        get type() {
          return this._config.type;
        }
        set type(type) {
          this._config.type = type;
        }
        get data() {
          return this._config.data;
        }
        set data(data) {
          this._config.data = initData(data);
        }
        get options() {
          return this._config.options;
        }
        set options(options) {
          this._config.options = options;
        }
        get plugins() {
          return this._config.plugins;
        }
        update() {
          const config = this._config;
          this.clearCache();
          initOptions(config);
        }
        clearCache() {
          this._scopeCache.clear();
          this._resolverCache.clear();
        }
        datasetScopeKeys(datasetType) {
          return cachedKeys(datasetType, () => [[
              `datasets.${ datasetType }`,
              ""
            ]]);
        }
        datasetAnimationScopeKeys(datasetType, transition) {
          return cachedKeys(`${ datasetType }.transition.${ transition }`, () => [
            [
              `datasets.${ datasetType }.transitions.${ transition }`,
              `transitions.${ transition }`
            ],
            [
              `datasets.${ datasetType }`,
              ""
            ]
          ]);
        }
        datasetElementScopeKeys(datasetType, elementType) {
          return cachedKeys(`${ datasetType }-${ elementType }`, () => [[
              `datasets.${ datasetType }.elements.${ elementType }`,
              `datasets.${ datasetType }`,
              `elements.${ elementType }`,
              ""
            ]]);
        }
        pluginScopeKeys(plugin) {
          const id = plugin.id;
          const type = this.type;
          return cachedKeys(`${ type }-plugin-${ id }`, () => [[
              `plugins.${ id }`,
              ...plugin.additionalOptionScopes || []
            ]]);
        }
        _cachedScopes(mainScope, resetCache) {
          const _scopeCache = this._scopeCache;
          let cache = _scopeCache.get(mainScope);
          if (!cache || resetCache) {
            cache = new Map();
            _scopeCache.set(mainScope, cache);
          }
          return cache;
        }
        getOptionScopes(mainScope, keyLists, resetCache) {
          const {options, type} = this;
          const cache = this._cachedScopes(mainScope, resetCache);
          const cached = cache.get(keyLists);
          if (cached) {
            return cached;
          }
          const scopes = new Set();
          keyLists.forEach(keys => {
            if (mainScope) {
              scopes.add(mainScope);
              keys.forEach(key => addIfFound(scopes, mainScope, key));
            }
            keys.forEach(key => addIfFound(scopes, options, key));
            keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));
            keys.forEach(key => addIfFound(scopes, defaults, key));
            keys.forEach(key => addIfFound(scopes, descriptors, key));
          });
          const array = Array.from(scopes);
          if (array.length === 0) {
            array.push(Object.create(null));
          }
          if (keysCached.has(keyLists)) {
            cache.set(keyLists, array);
          }
          return array;
        }
        chartOptionScopes() {
          const {options, type} = this;
          return [
            options,
            overrides[type] || {},
            defaults.datasets[type] || {},
            { type },
            defaults,
            descriptors
          ];
        }
        resolveNamedOptions(scopes, names, context, prefixes = [""]) {
          const result = { $shared: true };
          const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);
          let options = resolver;
          if (needContext(resolver, names)) {
            result.$shared = false;
            context = isFunction(context) ? context() : context;
            const subResolver = this.createResolver(scopes, context, subPrefixes);
            options = _attachContext(resolver, context, subResolver);
          }
          for (const prop of names) {
            result[prop] = options[prop];
          }
          return result;
        }
        createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
          const {resolver} = getResolver(this._resolverCache, scopes, prefixes);
          return isObject(context) ? _attachContext(resolver, context, undefined, descriptorDefaults) : resolver;
        }
      }
      function getResolver(resolverCache, scopes, prefixes) {
        let cache = resolverCache.get(scopes);
        if (!cache) {
          cache = new Map();
          resolverCache.set(scopes, cache);
        }
        const cacheKey = prefixes.join();
        let cached = cache.get(cacheKey);
        if (!cached) {
          const resolver = _createResolver(scopes, prefixes);
          cached = {
            resolver,
            subPrefixes: prefixes.filter(p => !p.toLowerCase().includes("hover"))
          };
          cache.set(cacheKey, cached);
        }
        return cached;
      }
      const hasFunction = value => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
      function needContext(proxy, names) {
        const {isScriptable, isIndexable} = _descriptors(proxy);
        for (const prop of names) {
          const scriptable = isScriptable(prop);
          const indexable = isIndexable(prop);
          const value = (indexable || scriptable) && proxy[prop];
          if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
            return true;
          }
        }
        return false;
      }
      var version = "3.9.1";
      const KNOWN_POSITIONS = [
        "top",
        "bottom",
        "left",
        "right",
        "chartArea"
      ];
      function positionIsHorizontal(position, axis) {
        return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
      }
      function compare2Level(l1, l2) {
        return function (a, b) {
          return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
        };
      }
      function onAnimationsComplete(context) {
        const chart = context.chart;
        const animationOptions = chart.options.animation;
        chart.notifyPlugins("afterRender");
        callback(animationOptions && animationOptions.onComplete, [context], chart);
      }
      function onAnimationProgress(context) {
        const chart = context.chart;
        const animationOptions = chart.options.animation;
        callback(animationOptions && animationOptions.onProgress, [context], chart);
      }
      function getCanvas(item) {
        if (_isDomSupported() && typeof item === "string") {
          item = document.getElementById(item);
        } else if (item && item.length) {
          item = item[0];
        }
        if (item && item.canvas) {
          item = item.canvas;
        }
        return item;
      }
      const instances = {};
      const getChart = key => {
        const canvas = getCanvas(key);
        return Object.values(instances).filter(c => c.canvas === canvas).pop();
      };
      function moveNumericKeys(obj, start, move) {
        const keys = Object.keys(obj);
        for (const key of keys) {
          const intKey = +key;
          if (intKey >= start) {
            const value = obj[key];
            delete obj[key];
            if (move > 0 || intKey > start) {
              obj[intKey + move] = value;
            }
          }
        }
      }
      function determineLastEvent(e, lastEvent, inChartArea, isClick) {
        if (!inChartArea || e.type === "mouseout") {
          return null;
        }
        if (isClick) {
          return lastEvent;
        }
        return e;
      }
      class Chart {
        constructor(item, userConfig) {
          const config = this.config = new Config(userConfig);
          const initialCanvas = getCanvas(item);
          const existingChart = getChart(initialCanvas);
          if (existingChart) {
            throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "'" + " must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
          }
          const options = config.createResolver(config.chartOptionScopes(), this.getContext());
          this.platform = new (config.platform || (_detectPlatform(initialCanvas)))();
          this.platform.updateConfig(config);
          const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
          const canvas = context && context.canvas;
          const height = canvas && canvas.height;
          const width = canvas && canvas.width;
          this.id = uid();
          this.ctx = context;
          this.canvas = canvas;
          this.width = width;
          this.height = height;
          this._options = options;
          this._aspectRatio = this.aspectRatio;
          this._layers = [];
          this._metasets = [];
          this._stacks = undefined;
          this.boxes = [];
          this.currentDevicePixelRatio = undefined;
          this.chartArea = undefined;
          this._active = [];
          this._lastEvent = undefined;
          this._listeners = {};
          this._responsiveListeners = undefined;
          this._sortedMetasets = [];
          this.scales = {};
          this._plugins = new PluginService();
          this.$proxies = {};
          this._hiddenIndices = {};
          this.attached = false;
          this._animationsDisabled = undefined;
          this.$context = undefined;
          this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);
          this._dataChanges = [];
          instances[this.id] = this;
          if (!context || !canvas) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
          }
          animator.listen(this, "complete", onAnimationsComplete);
          animator.listen(this, "progress", onAnimationProgress);
          this._initialize();
          if (this.attached) {
            this.update();
          }
        }
        get aspectRatio() {
          const {
            options: {aspectRatio, maintainAspectRatio},
            width,
            height,
            _aspectRatio
          } = this;
          if (!isNullOrUndef(aspectRatio)) {
            return aspectRatio;
          }
          if (maintainAspectRatio && _aspectRatio) {
            return _aspectRatio;
          }
          return height ? width / height : null;
        }
        get data() {
          return this.config.data;
        }
        set data(data) {
          this.config.data = data;
        }
        get options() {
          return this._options;
        }
        set options(options) {
          this.config.options = options;
        }
        _initialize() {
          this.notifyPlugins("beforeInit");
          if (this.options.responsive) {
            this.resize();
          } else {
            retinaScale(this, this.options.devicePixelRatio);
          }
          this.bindEvents();
          this.notifyPlugins("afterInit");
          return this;
        }
        clear() {
          clearCanvas(this.canvas, this.ctx);
          return this;
        }
        stop() {
          animator.stop(this);
          return this;
        }
        resize(width, height) {
          if (!animator.running(this)) {
            this._resize(width, height);
          } else {
            this._resizeBeforeDraw = {
              width,
              height
            };
          }
        }
        _resize(width, height) {
          const options = this.options;
          const canvas = this.canvas;
          const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
          const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
          const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
          const mode = this.width ? "resize" : "attach";
          this.width = newSize.width;
          this.height = newSize.height;
          this._aspectRatio = this.aspectRatio;
          if (!retinaScale(this, newRatio, true)) {
            return;
          }
          this.notifyPlugins("resize", { size: newSize });
          callback(options.onResize, [
            this,
            newSize
          ], this);
          if (this.attached) {
            if (this._doResize(mode)) {
              this.render();
            }
          }
        }
        ensureScalesHaveIDs() {
          const options = this.options;
          const scalesOptions = options.scales || {};
          each(scalesOptions, (axisOptions, axisID) => {
            axisOptions.id = axisID;
          });
        }
        buildOrUpdateScales() {
          const options = this.options;
          const scaleOpts = options.scales;
          const scales = this.scales;
          const updated = Object.keys(scales).reduce((obj, id) => {
            obj[id] = false;
            return obj;
          }, {});
          let items = [];
          if (scaleOpts) {
            items = items.concat(Object.keys(scaleOpts).map(id => {
              const scaleOptions = scaleOpts[id];
              const axis = determineAxis(id, scaleOptions);
              const isRadial = axis === "r";
              const isHorizontal = axis === "x";
              return {
                options: scaleOptions,
                dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
              };
            }));
          }
          each(items, item => {
            const scaleOptions = item.options;
            const id = scaleOptions.id;
            const axis = determineAxis(id, scaleOptions);
            const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
              scaleOptions.position = item.dposition;
            }
            updated[id] = true;
            let scale = null;
            if (id in scales && scales[id].type === scaleType) {
              scale = scales[id];
            } else {
              const scaleClass = registry.getScale(scaleType);
              scale = new scaleClass({
                id,
                type: scaleType,
                ctx: this.ctx,
                chart: this
              });
              scales[scale.id] = scale;
            }
            scale.init(scaleOptions, options);
          });
          each(updated, (hasUpdated, id) => {
            if (!hasUpdated) {
              delete scales[id];
            }
          });
          each(scales, scale => {
            layouts.configure(this, scale, scale.options);
            layouts.addBox(this, scale);
          });
        }
        _updateMetasets() {
          const metasets = this._metasets;
          const numData = this.data.datasets.length;
          const numMeta = metasets.length;
          metasets.sort((a, b) => a.index - b.index);
          if (numMeta > numData) {
            for (let i = numData; i < numMeta; ++i) {
              this._destroyDatasetMeta(i);
            }
            metasets.splice(numData, numMeta - numData);
          }
          this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
        }
        _removeUnreferencedMetasets() {
          const {
            _metasets: metasets,
            data: {datasets}
          } = this;
          if (metasets.length > datasets.length) {
            delete this._stacks;
          }
          metasets.forEach((meta, index) => {
            if (datasets.filter(x => x === meta._dataset).length === 0) {
              this._destroyDatasetMeta(index);
            }
          });
        }
        buildOrUpdateControllers() {
          const newControllers = [];
          const datasets = this.data.datasets;
          let i, ilen;
          this._removeUnreferencedMetasets();
          for (i = 0, ilen = datasets.length; i < ilen; i++) {
            const dataset = datasets[i];
            let meta = this.getDatasetMeta(i);
            const type = dataset.type || this.config.type;
            if (meta.type && meta.type !== type) {
              this._destroyDatasetMeta(i);
              meta = this.getDatasetMeta(i);
            }
            meta.type = type;
            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
            meta.order = dataset.order || 0;
            meta.index = i;
            meta.label = "" + dataset.label;
            meta.visible = this.isDatasetVisible(i);
            if (meta.controller) {
              meta.controller.updateIndex(i);
              meta.controller.linkScales();
            } else {
              const ControllerClass = registry.getController(type);
              const {datasetElementType, dataElementType} = defaults.datasets[type];
              Object.assign(ControllerClass.prototype, {
                dataElementType: registry.getElement(dataElementType),
                datasetElementType: datasetElementType && registry.getElement(datasetElementType)
              });
              meta.controller = new ControllerClass(this, i);
              newControllers.push(meta.controller);
            }
          }
          this._updateMetasets();
          return newControllers;
        }
        _resetElements() {
          each(this.data.datasets, (dataset, datasetIndex) => {
            this.getDatasetMeta(datasetIndex).controller.reset();
          }, this);
        }
        reset() {
          this._resetElements();
          this.notifyPlugins("reset");
        }
        update(mode) {
          const config = this.config;
          config.update();
          const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
          const animsDisabled = this._animationsDisabled = !options.animation;
          this._updateScales();
          this._checkEventBindings();
          this._updateHiddenIndices();
          this._plugins.invalidate();
          if (this.notifyPlugins("beforeUpdate", {
              mode,
              cancelable: true
            }) === false) {
            return;
          }
          const newControllers = this.buildOrUpdateControllers();
          this.notifyPlugins("beforeElementsUpdate");
          let minPadding = 0;
          for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
            const {controller} = this.getDatasetMeta(i);
            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
            controller.buildOrUpdateElements(reset);
            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
          }
          minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
          this._updateLayout(minPadding);
          if (!animsDisabled) {
            each(newControllers, controller => {
              controller.reset();
            });
          }
          this._updateDatasets(mode);
          this.notifyPlugins("afterUpdate", { mode });
          this._layers.sort(compare2Level("z", "_idx"));
          const {_active, _lastEvent} = this;
          if (_lastEvent) {
            this._eventHandler(_lastEvent, true);
          } else if (_active.length) {
            this._updateHoverStyles(_active, _active, true);
          }
          this.render();
        }
        _updateScales() {
          each(this.scales, scale => {
            layouts.removeBox(this, scale);
          });
          this.ensureScalesHaveIDs();
          this.buildOrUpdateScales();
        }
        _checkEventBindings() {
          const options = this.options;
          const existingEvents = new Set(Object.keys(this._listeners));
          const newEvents = new Set(options.events);
          if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
            this.unbindEvents();
            this.bindEvents();
          }
        }
        _updateHiddenIndices() {
          const {_hiddenIndices} = this;
          const changes = this._getUniformDataChanges() || [];
          for (const {method, start, count} of changes) {
            const move = method === "_removeElements" ? -count : count;
            moveNumericKeys(_hiddenIndices, start, move);
          }
        }
        _getUniformDataChanges() {
          const _dataChanges = this._dataChanges;
          if (!_dataChanges || !_dataChanges.length) {
            return;
          }
          this._dataChanges = [];
          const datasetCount = this.data.datasets.length;
          const makeSet = idx => new Set(_dataChanges.filter(c => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
          const changeSet = makeSet(0);
          for (let i = 1; i < datasetCount; i++) {
            if (!setsEqual(changeSet, makeSet(i))) {
              return;
            }
          }
          return Array.from(changeSet).map(c => c.split(",")).map(a => ({
            method: a[1],
            start: +a[2],
            count: +a[3]
          }));
        }
        _updateLayout(minPadding) {
          if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
            return;
          }
          layouts.update(this, this.width, this.height, minPadding);
          const area = this.chartArea;
          const noArea = area.width <= 0 || area.height <= 0;
          this._layers = [];
          each(this.boxes, box => {
            if (noArea && box.position === "chartArea") {
              return;
            }
            if (box.configure) {
              box.configure();
            }
            this._layers.push(...box._layers());
          }, this);
          this._layers.forEach((item, index) => {
            item._idx = index;
          });
          this.notifyPlugins("afterLayout");
        }
        _updateDatasets(mode) {
          if (this.notifyPlugins("beforeDatasetsUpdate", {
              mode,
              cancelable: true
            }) === false) {
            return;
          }
          for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
            this.getDatasetMeta(i).controller.configure();
          }
          for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
            this._updateDataset(i, isFunction(mode) ? mode({ datasetIndex: i }) : mode);
          }
          this.notifyPlugins("afterDatasetsUpdate", { mode });
        }
        _updateDataset(index, mode) {
          const meta = this.getDatasetMeta(index);
          const args = {
            meta,
            index,
            mode,
            cancelable: true
          };
          if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
            return;
          }
          meta.controller._update(mode);
          args.cancelable = false;
          this.notifyPlugins("afterDatasetUpdate", args);
        }
        render() {
          if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
            return;
          }
          if (animator.has(this)) {
            if (this.attached && !animator.running(this)) {
              animator.start(this);
            }
          } else {
            this.draw();
            onAnimationsComplete({ chart: this });
          }
        }
        draw() {
          let i;
          if (this._resizeBeforeDraw) {
            const {width, height} = this._resizeBeforeDraw;
            this._resize(width, height);
            this._resizeBeforeDraw = null;
          }
          this.clear();
          if (this.width <= 0 || this.height <= 0) {
            return;
          }
          if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
            return;
          }
          const layers = this._layers;
          for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
            layers[i].draw(this.chartArea);
          }
          this._drawDatasets();
          for (; i < layers.length; ++i) {
            layers[i].draw(this.chartArea);
          }
          this.notifyPlugins("afterDraw");
        }
        _getSortedDatasetMetas(filterVisible) {
          const metasets = this._sortedMetasets;
          const result = [];
          let i, ilen;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            const meta = metasets[i];
            if (!filterVisible || meta.visible) {
              result.push(meta);
            }
          }
          return result;
        }
        getSortedVisibleDatasetMetas() {
          return this._getSortedDatasetMetas(true);
        }
        _drawDatasets() {
          if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
            return;
          }
          const metasets = this.getSortedVisibleDatasetMetas();
          for (let i = metasets.length - 1; i >= 0; --i) {
            this._drawDataset(metasets[i]);
          }
          this.notifyPlugins("afterDatasetsDraw");
        }
        _drawDataset(meta) {
          const ctx = this.ctx;
          const clip = meta._clip;
          const useClip = !clip.disabled;
          const area = this.chartArea;
          const args = {
            meta,
            index: meta.index,
            cancelable: true
          };
          if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
            return;
          }
          if (useClip) {
            clipArea(ctx, {
              left: clip.left === false ? 0 : area.left - clip.left,
              right: clip.right === false ? this.width : area.right + clip.right,
              top: clip.top === false ? 0 : area.top - clip.top,
              bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
            });
          }
          meta.controller.draw();
          if (useClip) {
            unclipArea(ctx);
          }
          args.cancelable = false;
          this.notifyPlugins("afterDatasetDraw", args);
        }
        isPointInArea(point) {
          return _isPointInArea(point, this.chartArea, this._minPadding);
        }
        getElementsAtEventForMode(e, mode, options, useFinalPosition) {
          const method = Interaction.modes[mode];
          if (typeof method === "function") {
            return method(this, e, options, useFinalPosition);
          }
          return [];
        }
        getDatasetMeta(datasetIndex) {
          const dataset = this.data.datasets[datasetIndex];
          const metasets = this._metasets;
          let meta = metasets.filter(x => x && x._dataset === dataset).pop();
          if (!meta) {
            meta = {
              type: null,
              data: [],
              dataset: null,
              controller: null,
              hidden: null,
              xAxisID: null,
              yAxisID: null,
              order: dataset && dataset.order || 0,
              index: datasetIndex,
              _dataset: dataset,
              _parsed: [],
              _sorted: false
            };
            metasets.push(meta);
          }
          return meta;
        }
        getContext() {
          return this.$context || (this.$context = createContext(null, {
            chart: this,
            type: "chart"
          }));
        }
        getVisibleDatasetCount() {
          return this.getSortedVisibleDatasetMetas().length;
        }
        isDatasetVisible(datasetIndex) {
          const dataset = this.data.datasets[datasetIndex];
          if (!dataset) {
            return false;
          }
          const meta = this.getDatasetMeta(datasetIndex);
          return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
        }
        setDatasetVisibility(datasetIndex, visible) {
          const meta = this.getDatasetMeta(datasetIndex);
          meta.hidden = !visible;
        }
        toggleDataVisibility(index) {
          this._hiddenIndices[index] = !this._hiddenIndices[index];
        }
        getDataVisibility(index) {
          return !this._hiddenIndices[index];
        }
        _updateVisibility(datasetIndex, dataIndex, visible) {
          const mode = visible ? "show" : "hide";
          const meta = this.getDatasetMeta(datasetIndex);
          const anims = meta.controller._resolveAnimations(undefined, mode);
          if (defined(dataIndex)) {
            meta.data[dataIndex].hidden = !visible;
            this.update();
          } else {
            this.setDatasetVisibility(datasetIndex, visible);
            anims.update(meta, { visible });
            this.update(ctx => ctx.datasetIndex === datasetIndex ? mode : undefined);
          }
        }
        hide(datasetIndex, dataIndex) {
          this._updateVisibility(datasetIndex, dataIndex, false);
        }
        show(datasetIndex, dataIndex) {
          this._updateVisibility(datasetIndex, dataIndex, true);
        }
        _destroyDatasetMeta(datasetIndex) {
          const meta = this._metasets[datasetIndex];
          if (meta && meta.controller) {
            meta.controller._destroy();
          }
          delete this._metasets[datasetIndex];
        }
        _stop() {
          let i, ilen;
          this.stop();
          animator.remove(this);
          for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
            this._destroyDatasetMeta(i);
          }
        }
        destroy() {
          this.notifyPlugins("beforeDestroy");
          const {canvas, ctx} = this;
          this._stop();
          this.config.clearCache();
          if (canvas) {
            this.unbindEvents();
            clearCanvas(canvas, ctx);
            this.platform.releaseContext(ctx);
            this.canvas = null;
            this.ctx = null;
          }
          this.notifyPlugins("destroy");
          delete instances[this.id];
          this.notifyPlugins("afterDestroy");
        }
        toBase64Image(...args) {
          return this.canvas.toDataURL(...args);
        }
        bindEvents() {
          this.bindUserEvents();
          if (this.options.responsive) {
            this.bindResponsiveEvents();
          } else {
            this.attached = true;
          }
        }
        bindUserEvents() {
          const listeners = this._listeners;
          const platform = this.platform;
          const _add = (type, listener) => {
            platform.addEventListener(this, type, listener);
            listeners[type] = listener;
          };
          const listener = (e, x, y) => {
            e.offsetX = x;
            e.offsetY = y;
            this._eventHandler(e);
          };
          each(this.options.events, type => _add(type, listener));
        }
        bindResponsiveEvents() {
          if (!this._responsiveListeners) {
            this._responsiveListeners = {};
          }
          const listeners = this._responsiveListeners;
          const platform = this.platform;
          const _add = (type, listener) => {
            platform.addEventListener(this, type, listener);
            listeners[type] = listener;
          };
          const _remove = (type, listener) => {
            if (listeners[type]) {
              platform.removeEventListener(this, type, listener);
              delete listeners[type];
            }
          };
          const listener = (width, height) => {
            if (this.canvas) {
              this.resize(width, height);
            }
          };
          let detached;
          const attached = () => {
            _remove("attach", attached);
            this.attached = true;
            this.resize();
            _add("resize", listener);
            _add("detach", detached);
          };
          detached = () => {
            this.attached = false;
            _remove("resize", listener);
            this._stop();
            this._resize(0, 0);
            _add("attach", attached);
          };
          if (platform.isAttached(this.canvas)) {
            attached();
          } else {
            detached();
          }
        }
        unbindEvents() {
          each(this._listeners, (listener, type) => {
            this.platform.removeEventListener(this, type, listener);
          });
          this._listeners = {};
          each(this._responsiveListeners, (listener, type) => {
            this.platform.removeEventListener(this, type, listener);
          });
          this._responsiveListeners = undefined;
        }
        updateHoverStyle(items, mode, enabled) {
          const prefix = enabled ? "set" : "remove";
          let meta, item, i, ilen;
          if (mode === "dataset") {
            meta = this.getDatasetMeta(items[0].datasetIndex);
            meta.controller["_" + prefix + "DatasetHoverStyle"]();
          }
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            item = items[i];
            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
            if (controller) {
              controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
            }
          }
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(activeElements) {
          const lastActive = this._active || [];
          const active = activeElements.map(({datasetIndex, index}) => {
            const meta = this.getDatasetMeta(datasetIndex);
            if (!meta) {
              throw new Error("No dataset found at index " + datasetIndex);
            }
            return {
              datasetIndex,
              element: meta.data[index],
              index
            };
          });
          const changed = !_elementsEqual(active, lastActive);
          if (changed) {
            this._active = active;
            this._lastEvent = null;
            this._updateHoverStyles(active, lastActive);
          }
        }
        notifyPlugins(hook, args, filter) {
          return this._plugins.notify(this, hook, args, filter);
        }
        _updateHoverStyles(active, lastActive, replay) {
          const hoverOptions = this.options.hover;
          const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));
          const deactivated = diff(lastActive, active);
          const activated = replay ? active : diff(active, lastActive);
          if (deactivated.length) {
            this.updateHoverStyle(deactivated, hoverOptions.mode, false);
          }
          if (activated.length && hoverOptions.mode) {
            this.updateHoverStyle(activated, hoverOptions.mode, true);
          }
        }
        _eventHandler(e, replay) {
          const args = {
            event: e,
            replay,
            cancelable: true,
            inChartArea: this.isPointInArea(e)
          };
          const eventFilter = plugin => (plugin.options.events || this.options.events).includes(e.native.type);
          if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
            return;
          }
          const changed = this._handleEvent(e, replay, args.inChartArea);
          args.cancelable = false;
          this.notifyPlugins("afterEvent", args, eventFilter);
          if (changed || args.changed) {
            this.render();
          }
          return this;
        }
        _handleEvent(e, replay, inChartArea) {
          const {
            _active: lastActive = [],
            options
          } = this;
          const useFinalPosition = replay;
          const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
          const isClick = _isClickEvent(e);
          const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
          if (inChartArea) {
            this._lastEvent = null;
            callback(options.onHover, [
              e,
              active,
              this
            ], this);
            if (isClick) {
              callback(options.onClick, [
                e,
                active,
                this
              ], this);
            }
          }
          const changed = !_elementsEqual(active, lastActive);
          if (changed || replay) {
            this._active = active;
            this._updateHoverStyles(active, lastActive, replay);
          }
          this._lastEvent = lastEvent;
          return changed;
        }
        _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
          if (e.type === "mouseout") {
            return [];
          }
          if (!inChartArea) {
            return lastActive;
          }
          const hoverOptions = this.options.hover;
          return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
        }
      }
      const invalidatePlugins = () => each(Chart.instances, chart => chart._plugins.invalidate());
      const enumerable = true;
      Object.defineProperties(Chart, {
        defaults: {
          enumerable,
          value: defaults
        },
        instances: {
          enumerable,
          value: instances
        },
        overrides: {
          enumerable,
          value: overrides
        },
        registry: {
          enumerable,
          value: registry
        },
        version: {
          enumerable,
          value: version
        },
        getChart: {
          enumerable,
          value: getChart
        },
        register: {
          enumerable,
          value: (...items) => {
            registry.add(...items);
            invalidatePlugins();
          }
        },
        unregister: {
          enumerable,
          value: (...items) => {
            registry.remove(...items);
            invalidatePlugins();
          }
        }
      });
      function clipArc(ctx, element, endAngle) {
        const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;
        let angleMargin = pixelMargin / outerRadius;
        ctx.beginPath();
        ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
        if (innerRadius > pixelMargin) {
          angleMargin = pixelMargin / innerRadius;
          ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
        } else {
          ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
        }
        ctx.closePath();
        ctx.clip();
      }
      function toRadiusCorners(value) {
        return _readValueToProps(value, [
          "outerStart",
          "outerEnd",
          "innerStart",
          "innerEnd"
        ]);
      }
      function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
        const o = toRadiusCorners(arc.options.borderRadius);
        const halfThickness = (outerRadius - innerRadius) / 2;
        const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
        const computeOuterLimit = val => {
          const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
          return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
        };
        return {
          outerStart: computeOuterLimit(o.outerStart),
          outerEnd: computeOuterLimit(o.outerEnd),
          innerStart: _limitValue(o.innerStart, 0, innerLimit),
          innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
        };
      }
      function rThetaToXY(r, theta, x, y) {
        return {
          x: x + r * Math.cos(theta),
          y: y + r * Math.sin(theta)
        };
      }
      function pathArc(ctx, element, offset, spacing, end, circular) {
        const {
          x,
          y,
          startAngle: start,
          pixelMargin,
          innerRadius: innerR
        } = element;
        const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
        const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
        let spacingOffset = 0;
        const alpha = end - start;
        if (spacing) {
          const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
          const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
          const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
          const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
          spacingOffset = (alpha - adjustedAngle) / 2;
        }
        const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;
        const angleOffset = (alpha - beta) / 2;
        const startAngle = start + angleOffset + spacingOffset;
        const endAngle = end - angleOffset - spacingOffset;
        const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
        const outerStartAdjustedRadius = outerRadius - outerStart;
        const outerEndAdjustedRadius = outerRadius - outerEnd;
        const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
        const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
        const innerStartAdjustedRadius = innerRadius + innerStart;
        const innerEndAdjustedRadius = innerRadius + innerEnd;
        const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
        const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
        ctx.beginPath();
        if (circular) {
          ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
          if (outerEnd > 0) {
            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
          }
          const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
          ctx.lineTo(p4.x, p4.y);
          if (innerEnd > 0) {
            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
          }
          ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
          if (innerStart > 0) {
            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
          }
          const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
          ctx.lineTo(p8.x, p8.y);
          if (outerStart > 0) {
            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
          }
        } else {
          ctx.moveTo(x, y);
          const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
          const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
          ctx.lineTo(outerStartX, outerStartY);
          const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
          const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
          ctx.lineTo(outerEndX, outerEndY);
        }
        ctx.closePath();
      }
      function drawArc(ctx, element, offset, spacing, circular) {
        const {fullCircles, startAngle, circumference} = element;
        let endAngle = element.endAngle;
        if (fullCircles) {
          pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);
          for (let i = 0; i < fullCircles; ++i) {
            ctx.fill();
          }
          if (!isNaN(circumference)) {
            endAngle = startAngle + circumference % TAU;
            if (circumference % TAU === 0) {
              endAngle += TAU;
            }
          }
        }
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        ctx.fill();
        return endAngle;
      }
      function drawFullCircleBorders(ctx, element, inner) {
        const {x, y, startAngle, pixelMargin, fullCircles} = element;
        const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
        const innerRadius = element.innerRadius + pixelMargin;
        let i;
        if (inner) {
          clipArc(ctx, element, startAngle + TAU);
        }
        ctx.beginPath();
        ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
        for (i = 0; i < fullCircles; ++i) {
          ctx.stroke();
        }
        ctx.beginPath();
        ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
        for (i = 0; i < fullCircles; ++i) {
          ctx.stroke();
        }
      }
      function drawBorder(ctx, element, offset, spacing, endAngle, circular) {
        const {options} = element;
        const {borderWidth, borderJoinStyle} = options;
        const inner = options.borderAlign === "inner";
        if (!borderWidth) {
          return;
        }
        if (inner) {
          ctx.lineWidth = borderWidth * 2;
          ctx.lineJoin = borderJoinStyle || "round";
        } else {
          ctx.lineWidth = borderWidth;
          ctx.lineJoin = borderJoinStyle || "bevel";
        }
        if (element.fullCircles) {
          drawFullCircleBorders(ctx, element, inner);
        }
        if (inner) {
          clipArc(ctx, element, endAngle);
        }
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        ctx.stroke();
      }
      class ArcElement extends Element {
        constructor(cfg) {
          super();
          this.options = undefined;
          this.circumference = undefined;
          this.startAngle = undefined;
          this.endAngle = undefined;
          this.innerRadius = undefined;
          this.outerRadius = undefined;
          this.pixelMargin = 0;
          this.fullCircles = 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        inRange(chartX, chartY, useFinalPosition) {
          const point = this.getProps([
            "x",
            "y"
          ], useFinalPosition);
          const {angle, distance} = getAngleFromPoint(point, {
            x: chartX,
            y: chartY
          });
          const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius",
            "circumference"
          ], useFinalPosition);
          const rAdjust = this.options.spacing / 2;
          const _circumference = valueOrDefault(circumference, endAngle - startAngle);
          const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
          const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
          return betweenAngles && withinRadius;
        }
        getCenterPoint(useFinalPosition) {
          const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([
            "x",
            "y",
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius",
            "circumference"
          ], useFinalPosition);
          const {offset, spacing} = this.options;
          const halfAngle = (startAngle + endAngle) / 2;
          const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
          return {
            x: x + Math.cos(halfAngle) * halfRadius,
            y: y + Math.sin(halfAngle) * halfRadius
          };
        }
        tooltipPosition(useFinalPosition) {
          return this.getCenterPoint(useFinalPosition);
        }
        draw(ctx) {
          const {options, circumference} = this;
          const offset = (options.offset || 0) / 2;
          const spacing = (options.spacing || 0) / 2;
          const circular = options.circular;
          this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
          this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
          if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
            return;
          }
          ctx.save();
          let radiusOffset = 0;
          if (offset) {
            radiusOffset = offset / 2;
            const halfAngle = (this.startAngle + this.endAngle) / 2;
            ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
            if (this.circumference >= PI) {
              radiusOffset = offset;
            }
          }
          ctx.fillStyle = options.backgroundColor;
          ctx.strokeStyle = options.borderColor;
          const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);
          drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);
          ctx.restore();
        }
      }
      ArcElement.id = "arc";
      ArcElement.defaults = {
        borderAlign: "center",
        borderColor: "#fff",
        borderJoinStyle: undefined,
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        spacing: 0,
        angle: undefined,
        circular: true
      };
      ArcElement.defaultRoutes = { backgroundColor: "backgroundColor" };
      function setStyle(ctx, options, style = options) {
        ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
        ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
        ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
        ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
        ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
        ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
      }
      function lineTo(ctx, previous, target) {
        ctx.lineTo(target.x, target.y);
      }
      function getLineMethod(options) {
        if (options.stepped) {
          return _steppedLineTo;
        }
        if (options.tension || options.cubicInterpolationMode === "monotone") {
          return _bezierCurveTo;
        }
        return lineTo;
      }
      function pathVars(points, segment, params = {}) {
        const count = points.length;
        const {
          start: paramsStart = 0,
          end: paramsEnd = count - 1
        } = params;
        const {
          start: segmentStart,
          end: segmentEnd
        } = segment;
        const start = Math.max(paramsStart, segmentStart);
        const end = Math.min(paramsEnd, segmentEnd);
        const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
        return {
          count,
          start,
          loop: segment.loop,
          ilen: end < start && !outside ? count + end - start : end - start
        };
      }
      function pathSegment(ctx, line, segment, params) {
        const {points, options} = line;
        const {count, start, loop, ilen} = pathVars(points, segment, params);
        const lineMethod = getLineMethod(options);
        let {move = true, reverse} = params || {};
        let i, point, prev;
        for (i = 0; i <= ilen; ++i) {
          point = points[(start + (reverse ? ilen - i : i)) % count];
          if (point.skip) {
            continue;
          } else if (move) {
            ctx.moveTo(point.x, point.y);
            move = false;
          } else {
            lineMethod(ctx, prev, point, reverse, options.stepped);
          }
          prev = point;
        }
        if (loop) {
          point = points[(start + (reverse ? ilen : 0)) % count];
          lineMethod(ctx, prev, point, reverse, options.stepped);
        }
        return !!loop;
      }
      function fastPathSegment(ctx, line, segment, params) {
        const points = line.points;
        const {count, start, ilen} = pathVars(points, segment, params);
        const {move = true, reverse} = params || {};
        let avgX = 0;
        let countX = 0;
        let i, point, prevX, minY, maxY, lastY;
        const pointIndex = index => (start + (reverse ? ilen - index : index)) % count;
        const drawX = () => {
          if (minY !== maxY) {
            ctx.lineTo(avgX, maxY);
            ctx.lineTo(avgX, minY);
            ctx.lineTo(avgX, lastY);
          }
        };
        if (move) {
          point = points[pointIndex(0)];
          ctx.moveTo(point.x, point.y);
        }
        for (i = 0; i <= ilen; ++i) {
          point = points[pointIndex(i)];
          if (point.skip) {
            continue;
          }
          const x = point.x;
          const y = point.y;
          const truncX = x | 0;
          if (truncX === prevX) {
            if (y < minY) {
              minY = y;
            } else if (y > maxY) {
              maxY = y;
            }
            avgX = (countX * avgX + x) / ++countX;
          } else {
            drawX();
            ctx.lineTo(x, y);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
          }
          lastY = y;
        }
        drawX();
      }
      function _getSegmentMethod(line) {
        const opts = line.options;
        const borderDash = opts.borderDash && opts.borderDash.length;
        const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
        return useFastPath ? fastPathSegment : pathSegment;
      }
      function _getInterpolationMethod(options) {
        if (options.stepped) {
          return _steppedInterpolation;
        }
        if (options.tension || options.cubicInterpolationMode === "monotone") {
          return _bezierInterpolation;
        }
        return _pointInLine;
      }
      function strokePathWithCache(ctx, line, start, count) {
        let path = line._path;
        if (!path) {
          path = line._path = new Path2D();
          if (line.path(path, start, count)) {
            path.closePath();
          }
        }
        setStyle(ctx, line.options);
        ctx.stroke(path);
      }
      function strokePathDirect(ctx, line, start, count) {
        const {segments, options} = line;
        const segmentMethod = _getSegmentMethod(line);
        for (const segment of segments) {
          setStyle(ctx, options, segment.style);
          ctx.beginPath();
          if (segmentMethod(ctx, line, segment, {
              start,
              end: start + count - 1
            })) {
            ctx.closePath();
          }
          ctx.stroke();
        }
      }
      const usePath2D = typeof Path2D === "function";
      function draw(ctx, line, start, count) {
        if (usePath2D && !line.options.segment) {
          strokePathWithCache(ctx, line, start, count);
        } else {
          strokePathDirect(ctx, line, start, count);
        }
      }
      class LineElement extends Element {
        constructor(cfg) {
          super();
          this.animated = true;
          this.options = undefined;
          this._chart = undefined;
          this._loop = undefined;
          this._fullLoop = undefined;
          this._path = undefined;
          this._points = undefined;
          this._segments = undefined;
          this._decimated = false;
          this._pointsUpdated = false;
          this._datasetIndex = undefined;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        updateControlPoints(chartArea, indexAxis) {
          const options = this.options;
          if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
            const loop = options.spanGaps ? this._loop : this._fullLoop;
            _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
            this._pointsUpdated = true;
          }
        }
        set points(points) {
          this._points = points;
          delete this._segments;
          delete this._path;
          this._pointsUpdated = false;
        }
        get points() {
          return this._points;
        }
        get segments() {
          return this._segments || (this._segments = _computeSegments(this, this.options.segment));
        }
        first() {
          const segments = this.segments;
          const points = this.points;
          return segments.length && points[segments[0].start];
        }
        last() {
          const segments = this.segments;
          const points = this.points;
          const count = segments.length;
          return count && points[segments[count - 1].end];
        }
        interpolate(point, property) {
          const options = this.options;
          const value = point[property];
          const points = this.points;
          const segments = _boundSegments(this, {
            property,
            start: value,
            end: value
          });
          if (!segments.length) {
            return;
          }
          const result = [];
          const _interpolate = _getInterpolationMethod(options);
          let i, ilen;
          for (i = 0, ilen = segments.length; i < ilen; ++i) {
            const {start, end} = segments[i];
            const p1 = points[start];
            const p2 = points[end];
            if (p1 === p2) {
              result.push(p1);
              continue;
            }
            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
            const interpolated = _interpolate(p1, p2, t, options.stepped);
            interpolated[property] = point[property];
            result.push(interpolated);
          }
          return result.length === 1 ? result[0] : result;
        }
        pathSegment(ctx, segment, params) {
          const segmentMethod = _getSegmentMethod(this);
          return segmentMethod(ctx, this, segment, params);
        }
        path(ctx, start, count) {
          const segments = this.segments;
          const segmentMethod = _getSegmentMethod(this);
          let loop = this._loop;
          start = start || 0;
          count = count || this.points.length - start;
          for (const segment of segments) {
            loop &= segmentMethod(ctx, this, segment, {
              start,
              end: start + count - 1
            });
          }
          return !!loop;
        }
        draw(ctx, chartArea, start, count) {
          const options = this.options || {};
          const points = this.points || [];
          if (points.length && options.borderWidth) {
            ctx.save();
            draw(ctx, this, start, count);
            ctx.restore();
          }
          if (this.animated) {
            this._pointsUpdated = false;
            this._path = undefined;
          }
        }
      }
      LineElement.id = "line";
      LineElement.defaults = {
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderWidth: 3,
        capBezierPoints: true,
        cubicInterpolationMode: "default",
        fill: false,
        spanGaps: false,
        stepped: false,
        tension: 0
      };
      LineElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      };
      LineElement.descriptors = {
        _scriptable: true,
        _indexable: name => name !== "borderDash" && name !== "fill"
      };
      function inRange$1(el, pos, axis, useFinalPosition) {
        const options = el.options;
        const {[axis]: value} = el.getProps([axis], useFinalPosition);
        return Math.abs(pos - value) < options.radius + options.hitRadius;
      }
      class PointElement extends Element {
        constructor(cfg) {
          super();
          this.options = undefined;
          this.parsed = undefined;
          this.skip = undefined;
          this.stop = undefined;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        inRange(mouseX, mouseY, useFinalPosition) {
          const options = this.options;
          const {x, y} = this.getProps([
            "x",
            "y"
          ], useFinalPosition);
          return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
        }
        inXRange(mouseX, useFinalPosition) {
          return inRange$1(this, mouseX, "x", useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
          return inRange$1(this, mouseY, "y", useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
          const {x, y} = this.getProps([
            "x",
            "y"
          ], useFinalPosition);
          return {
            x,
            y
          };
        }
        size(options) {
          options = options || this.options || {};
          let radius = options.radius || 0;
          radius = Math.max(radius, radius && options.hoverRadius || 0);
          const borderWidth = radius && options.borderWidth || 0;
          return (radius + borderWidth) * 2;
        }
        draw(ctx, area) {
          const options = this.options;
          if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
            return;
          }
          ctx.strokeStyle = options.borderColor;
          ctx.lineWidth = options.borderWidth;
          ctx.fillStyle = options.backgroundColor;
          drawPoint(ctx, options, this.x, this.y);
        }
        getRange() {
          const options = this.options || {};
          return options.radius + options.hitRadius;
        }
      }
      PointElement.id = "point";
      PointElement.defaults = {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: "circle",
        radius: 3,
        rotation: 0
      };
      PointElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      };
      function getBarBounds(bar, useFinalPosition) {
        const {x, y, base, width, height} = bar.getProps([
          "x",
          "y",
          "base",
          "width",
          "height"
        ], useFinalPosition);
        let left, right, top, bottom, half;
        if (bar.horizontal) {
          half = height / 2;
          left = Math.min(x, base);
          right = Math.max(x, base);
          top = y - half;
          bottom = y + half;
        } else {
          half = width / 2;
          left = x - half;
          right = x + half;
          top = Math.min(y, base);
          bottom = Math.max(y, base);
        }
        return {
          left,
          top,
          right,
          bottom
        };
      }
      function skipOrLimit(skip, value, min, max) {
        return skip ? 0 : _limitValue(value, min, max);
      }
      function parseBorderWidth(bar, maxW, maxH) {
        const value = bar.options.borderWidth;
        const skip = bar.borderSkipped;
        const o = toTRBL(value);
        return {
          t: skipOrLimit(skip.top, o.top, 0, maxH),
          r: skipOrLimit(skip.right, o.right, 0, maxW),
          b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
          l: skipOrLimit(skip.left, o.left, 0, maxW)
        };
      }
      function parseBorderRadius(bar, maxW, maxH) {
        const {enableBorderRadius} = bar.getProps(["enableBorderRadius"]);
        const value = bar.options.borderRadius;
        const o = toTRBLCorners(value);
        const maxR = Math.min(maxW, maxH);
        const skip = bar.borderSkipped;
        const enableBorder = enableBorderRadius || isObject(value);
        return {
          topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
          topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
          bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
          bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
        };
      }
      function boundingRects(bar) {
        const bounds = getBarBounds(bar);
        const width = bounds.right - bounds.left;
        const height = bounds.bottom - bounds.top;
        const border = parseBorderWidth(bar, width / 2, height / 2);
        const radius = parseBorderRadius(bar, width / 2, height / 2);
        return {
          outer: {
            x: bounds.left,
            y: bounds.top,
            w: width,
            h: height,
            radius
          },
          inner: {
            x: bounds.left + border.l,
            y: bounds.top + border.t,
            w: width - border.l - border.r,
            h: height - border.t - border.b,
            radius: {
              topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
              topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
              bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
              bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
            }
          }
        };
      }
      function inRange(bar, x, y, useFinalPosition) {
        const skipX = x === null;
        const skipY = y === null;
        const skipBoth = skipX && skipY;
        const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
        return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
      }
      function hasRadius(radius) {
        return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
      }
      function addNormalRectPath(ctx, rect) {
        ctx.rect(rect.x, rect.y, rect.w, rect.h);
      }
      function inflateRect(rect, amount, refRect = {}) {
        const x = rect.x !== refRect.x ? -amount : 0;
        const y = rect.y !== refRect.y ? -amount : 0;
        const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
        const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
        return {
          x: rect.x + x,
          y: rect.y + y,
          w: rect.w + w,
          h: rect.h + h,
          radius: rect.radius
        };
      }
      class BarElement extends Element {
        constructor(cfg) {
          super();
          this.options = undefined;
          this.horizontal = undefined;
          this.base = undefined;
          this.width = undefined;
          this.height = undefined;
          this.inflateAmount = undefined;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        draw(ctx) {
          const {
            inflateAmount,
            options: {borderColor, backgroundColor}
          } = this;
          const {inner, outer} = boundingRects(this);
          const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
          ctx.save();
          if (outer.w !== inner.w || outer.h !== inner.h) {
            ctx.beginPath();
            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
            ctx.clip();
            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
            ctx.fillStyle = borderColor;
            ctx.fill("evenodd");
          }
          ctx.beginPath();
          addRectPath(ctx, inflateRect(inner, inflateAmount));
          ctx.fillStyle = backgroundColor;
          ctx.fill();
          ctx.restore();
        }
        inRange(mouseX, mouseY, useFinalPosition) {
          return inRange(this, mouseX, mouseY, useFinalPosition);
        }
        inXRange(mouseX, useFinalPosition) {
          return inRange(this, mouseX, null, useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
          return inRange(this, null, mouseY, useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
          const {x, y, base, horizontal} = this.getProps([
            "x",
            "y",
            "base",
            "horizontal"
          ], useFinalPosition);
          return {
            x: horizontal ? (x + base) / 2 : x,
            y: horizontal ? y : (y + base) / 2
          };
        }
        getRange(axis) {
          return axis === "x" ? this.width / 2 : this.height / 2;
        }
      }
      BarElement.id = "bar";
      BarElement.defaults = {
        borderSkipped: "start",
        borderWidth: 0,
        borderRadius: 0,
        inflateAmount: "auto",
        pointStyle: undefined
      };
      BarElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      };
      var elements = Object.freeze({
        __proto__: null,
        ArcElement: ArcElement,
        LineElement: LineElement,
        PointElement: PointElement,
        BarElement: BarElement
      });
      function lttbDecimation(data, start, count, availableWidth, options) {
        const samples = options.samples || availableWidth;
        if (samples >= count) {
          return data.slice(start, start + count);
        }
        const decimated = [];
        const bucketWidth = (count - 2) / (samples - 2);
        let sampledIndex = 0;
        const endIndex = start + count - 1;
        let a = start;
        let i, maxAreaPoint, maxArea, area, nextA;
        decimated[sampledIndex++] = data[a];
        for (i = 0; i < samples - 2; i++) {
          let avgX = 0;
          let avgY = 0;
          let j;
          const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
          const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
          const avgRangeLength = avgRangeEnd - avgRangeStart;
          for (j = avgRangeStart; j < avgRangeEnd; j++) {
            avgX += data[j].x;
            avgY += data[j].y;
          }
          avgX /= avgRangeLength;
          avgY /= avgRangeLength;
          const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
          const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
          const {
            x: pointAx,
            y: pointAy
          } = data[a];
          maxArea = area = -1;
          for (j = rangeOffs; j < rangeTo; j++) {
            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
            if (area > maxArea) {
              maxArea = area;
              maxAreaPoint = data[j];
              nextA = j;
            }
          }
          decimated[sampledIndex++] = maxAreaPoint;
          a = nextA;
        }
        decimated[sampledIndex++] = data[endIndex];
        return decimated;
      }
      function minMaxDecimation(data, start, count, availableWidth) {
        let avgX = 0;
        let countX = 0;
        let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
        const decimated = [];
        const endIndex = start + count - 1;
        const xMin = data[start].x;
        const xMax = data[endIndex].x;
        const dx = xMax - xMin;
        for (i = start; i < start + count; ++i) {
          point = data[i];
          x = (point.x - xMin) / dx * availableWidth;
          y = point.y;
          const truncX = x | 0;
          if (truncX === prevX) {
            if (y < minY) {
              minY = y;
              minIndex = i;
            } else if (y > maxY) {
              maxY = y;
              maxIndex = i;
            }
            avgX = (countX * avgX + point.x) / ++countX;
          } else {
            const lastIndex = i - 1;
            if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
              const intermediateIndex1 = Math.min(minIndex, maxIndex);
              const intermediateIndex2 = Math.max(minIndex, maxIndex);
              if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
                decimated.push({
                  ...data[intermediateIndex1],
                  x: avgX
                });
              }
              if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
                decimated.push({
                  ...data[intermediateIndex2],
                  x: avgX
                });
              }
            }
            if (i > 0 && lastIndex !== startIndex) {
              decimated.push(data[lastIndex]);
            }
            decimated.push(point);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
            minIndex = maxIndex = startIndex = i;
          }
        }
        return decimated;
      }
      function cleanDecimatedDataset(dataset) {
        if (dataset._decimated) {
          const data = dataset._data;
          delete dataset._decimated;
          delete dataset._data;
          Object.defineProperty(dataset, "data", { value: data });
        }
      }
      function cleanDecimatedData(chart) {
        chart.data.datasets.forEach(dataset => {
          cleanDecimatedDataset(dataset);
        });
      }
      function getStartAndCountOfVisiblePointsSimplified(meta, points) {
        const pointCount = points.length;
        let start = 0;
        let count;
        const {iScale} = meta;
        const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
        if (minDefined) {
          start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
        }
        if (maxDefined) {
          count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
        } else {
          count = pointCount - start;
        }
        return {
          start,
          count
        };
      }
      var plugin_decimation = {
        id: "decimation",
        defaults: {
          algorithm: "min-max",
          enabled: false
        },
        beforeElementsUpdate: (chart, args, options) => {
          if (!options.enabled) {
            cleanDecimatedData(chart);
            return;
          }
          const availableWidth = chart.width;
          chart.data.datasets.forEach((dataset, datasetIndex) => {
            const {_data, indexAxis} = dataset;
            const meta = chart.getDatasetMeta(datasetIndex);
            const data = _data || dataset.data;
            if (resolve([
                indexAxis,
                chart.options.indexAxis
              ]) === "y") {
              return;
            }
            if (!meta.controller.supportsDecimation) {
              return;
            }
            const xAxis = chart.scales[meta.xAxisID];
            if (xAxis.type !== "linear" && xAxis.type !== "time") {
              return;
            }
            if (chart.options.parsing) {
              return;
            }
            let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);
            const threshold = options.threshold || 4 * availableWidth;
            if (count <= threshold) {
              cleanDecimatedDataset(dataset);
              return;
            }
            if (isNullOrUndef(_data)) {
              dataset._data = data;
              delete dataset.data;
              Object.defineProperty(dataset, "data", {
                configurable: true,
                enumerable: true,
                get: function () {
                  return this._decimated;
                },
                set: function (d) {
                  this._data = d;
                }
              });
            }
            let decimated;
            switch (options.algorithm) {
            case "lttb":
              decimated = lttbDecimation(data, start, count, availableWidth, options);
              break;
            case "min-max":
              decimated = minMaxDecimation(data, start, count, availableWidth);
              break;
            default:
              throw new Error(`Unsupported decimation algorithm '${ options.algorithm }'`);
            }
            dataset._decimated = decimated;
          });
        },
        destroy(chart) {
          cleanDecimatedData(chart);
        }
      };
      function _segments(line, target, property) {
        const segments = line.segments;
        const points = line.points;
        const tpoints = target.points;
        const parts = [];
        for (const segment of segments) {
          let {start, end} = segment;
          end = _findSegmentEnd(start, end, points);
          const bounds = _getBounds(property, points[start], points[end], segment.loop);
          if (!target.segments) {
            parts.push({
              source: segment,
              target: bounds,
              start: points[start],
              end: points[end]
            });
            continue;
          }
          const targetSegments = _boundSegments(target, bounds);
          for (const tgt of targetSegments) {
            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
            const fillSources = _boundSegment(segment, points, subBounds);
            for (const fillSource of fillSources) {
              parts.push({
                source: fillSource,
                target: tgt,
                start: { [property]: _getEdge(bounds, subBounds, "start", Math.max) },
                end: { [property]: _getEdge(bounds, subBounds, "end", Math.min) }
              });
            }
          }
        }
        return parts;
      }
      function _getBounds(property, first, last, loop) {
        if (loop) {
          return;
        }
        let start = first[property];
        let end = last[property];
        if (property === "angle") {
          start = _normalizeAngle(start);
          end = _normalizeAngle(end);
        }
        return {
          property,
          start,
          end
        };
      }
      function _pointsFromSegments(boundary, line) {
        const {x = null, y = null} = boundary || {};
        const linePoints = line.points;
        const points = [];
        line.segments.forEach(({start, end}) => {
          end = _findSegmentEnd(start, end, linePoints);
          const first = linePoints[start];
          const last = linePoints[end];
          if (y !== null) {
            points.push({
              x: first.x,
              y
            });
            points.push({
              x: last.x,
              y
            });
          } else if (x !== null) {
            points.push({
              x,
              y: first.y
            });
            points.push({
              x,
              y: last.y
            });
          }
        });
        return points;
      }
      function _findSegmentEnd(start, end, points) {
        for (; end > start; end--) {
          const point = points[end];
          if (!isNaN(point.x) && !isNaN(point.y)) {
            break;
          }
        }
        return end;
      }
      function _getEdge(a, b, prop, fn) {
        if (a && b) {
          return fn(a[prop], b[prop]);
        }
        return a ? a[prop] : b ? b[prop] : 0;
      }
      function _createBoundaryLine(boundary, line) {
        let points = [];
        let _loop = false;
        if (isArray(boundary)) {
          _loop = true;
          points = boundary;
        } else {
          points = _pointsFromSegments(boundary, line);
        }
        return points.length ? new LineElement({
          points,
          options: { tension: 0 },
          _loop,
          _fullLoop: _loop
        }) : null;
      }
      function _shouldApplyFill(source) {
        return source && source.fill !== false;
      }
      function _resolveTarget(sources, index, propagate) {
        const source = sources[index];
        let fill = source.fill;
        const visited = [index];
        let target;
        if (!propagate) {
          return fill;
        }
        while (fill !== false && visited.indexOf(fill) === -1) {
          if (!isNumberFinite(fill)) {
            return fill;
          }
          target = sources[fill];
          if (!target) {
            return false;
          }
          if (target.visible) {
            return fill;
          }
          visited.push(fill);
          fill = target.fill;
        }
        return false;
      }
      function _decodeFill(line, index, count) {
        const fill = parseFillOption(line);
        if (isObject(fill)) {
          return isNaN(fill.value) ? false : fill;
        }
        let target = parseFloat(fill);
        if (isNumberFinite(target) && Math.floor(target) === target) {
          return decodeTargetIndex(fill[0], index, target, count);
        }
        return [
          "origin",
          "start",
          "end",
          "stack",
          "shape"
        ].indexOf(fill) >= 0 && fill;
      }
      function decodeTargetIndex(firstCh, index, target, count) {
        if (firstCh === "-" || firstCh === "+") {
          target = index + target;
        }
        if (target === index || target < 0 || target >= count) {
          return false;
        }
        return target;
      }
      function _getTargetPixel(fill, scale) {
        let pixel = null;
        if (fill === "start") {
          pixel = scale.bottom;
        } else if (fill === "end") {
          pixel = scale.top;
        } else if (isObject(fill)) {
          pixel = scale.getPixelForValue(fill.value);
        } else if (scale.getBasePixel) {
          pixel = scale.getBasePixel();
        }
        return pixel;
      }
      function _getTargetValue(fill, scale, startValue) {
        let value;
        if (fill === "start") {
          value = startValue;
        } else if (fill === "end") {
          value = scale.options.reverse ? scale.min : scale.max;
        } else if (isObject(fill)) {
          value = fill.value;
        } else {
          value = scale.getBaseValue();
        }
        return value;
      }
      function parseFillOption(line) {
        const options = line.options;
        const fillOption = options.fill;
        let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
        if (fill === undefined) {
          fill = !!options.backgroundColor;
        }
        if (fill === false || fill === null) {
          return false;
        }
        if (fill === true) {
          return "origin";
        }
        return fill;
      }
      function _buildStackLine(source) {
        const {scale, index, line} = source;
        const points = [];
        const segments = line.segments;
        const sourcePoints = line.points;
        const linesBelow = getLinesBelow(scale, index);
        linesBelow.push(_createBoundaryLine({
          x: null,
          y: scale.bottom
        }, line));
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i];
          for (let j = segment.start; j <= segment.end; j++) {
            addPointsBelow(points, sourcePoints[j], linesBelow);
          }
        }
        return new LineElement({
          points,
          options: {}
        });
      }
      function getLinesBelow(scale, index) {
        const below = [];
        const metas = scale.getMatchingVisibleMetas("line");
        for (let i = 0; i < metas.length; i++) {
          const meta = metas[i];
          if (meta.index === index) {
            break;
          }
          if (!meta.hidden) {
            below.unshift(meta.dataset);
          }
        }
        return below;
      }
      function addPointsBelow(points, sourcePoint, linesBelow) {
        const postponed = [];
        for (let j = 0; j < linesBelow.length; j++) {
          const line = linesBelow[j];
          const {first, last, point} = findPoint(line, sourcePoint, "x");
          if (!point || first && last) {
            continue;
          }
          if (first) {
            postponed.unshift(point);
          } else {
            points.push(point);
            if (!last) {
              break;
            }
          }
        }
        points.push(...postponed);
      }
      function findPoint(line, sourcePoint, property) {
        const point = line.interpolate(sourcePoint, property);
        if (!point) {
          return {};
        }
        const pointValue = point[property];
        const segments = line.segments;
        const linePoints = line.points;
        let first = false;
        let last = false;
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i];
          const firstValue = linePoints[segment.start][property];
          const lastValue = linePoints[segment.end][property];
          if (_isBetween(pointValue, firstValue, lastValue)) {
            first = pointValue === firstValue;
            last = pointValue === lastValue;
            break;
          }
        }
        return {
          first,
          last,
          point
        };
      }
      class simpleArc {
        constructor(opts) {
          this.x = opts.x;
          this.y = opts.y;
          this.radius = opts.radius;
        }
        pathSegment(ctx, bounds, opts) {
          const {x, y, radius} = this;
          bounds = bounds || {
            start: 0,
            end: TAU
          };
          ctx.arc(x, y, radius, bounds.end, bounds.start, true);
          return !opts.bounds;
        }
        interpolate(point) {
          const {x, y, radius} = this;
          const angle = point.angle;
          return {
            x: x + Math.cos(angle) * radius,
            y: y + Math.sin(angle) * radius,
            angle
          };
        }
      }
      function _getTarget(source) {
        const {chart, fill, line} = source;
        if (isNumberFinite(fill)) {
          return getLineByIndex(chart, fill);
        }
        if (fill === "stack") {
          return _buildStackLine(source);
        }
        if (fill === "shape") {
          return true;
        }
        const boundary = computeBoundary(source);
        if (boundary instanceof simpleArc) {
          return boundary;
        }
        return _createBoundaryLine(boundary, line);
      }
      function getLineByIndex(chart, index) {
        const meta = chart.getDatasetMeta(index);
        const visible = meta && chart.isDatasetVisible(index);
        return visible ? meta.dataset : null;
      }
      function computeBoundary(source) {
        const scale = source.scale || {};
        if (scale.getPointPositionForValue) {
          return computeCircularBoundary(source);
        }
        return computeLinearBoundary(source);
      }
      function computeLinearBoundary(source) {
        const {scale = {}, fill} = source;
        const pixel = _getTargetPixel(fill, scale);
        if (isNumberFinite(pixel)) {
          const horizontal = scale.isHorizontal();
          return {
            x: horizontal ? pixel : null,
            y: horizontal ? null : pixel
          };
        }
        return null;
      }
      function computeCircularBoundary(source) {
        const {scale, fill} = source;
        const options = scale.options;
        const length = scale.getLabels().length;
        const start = options.reverse ? scale.max : scale.min;
        const value = _getTargetValue(fill, scale, start);
        const target = [];
        if (options.grid.circular) {
          const center = scale.getPointPositionForValue(0, start);
          return new simpleArc({
            x: center.x,
            y: center.y,
            radius: scale.getDistanceFromCenterForValue(value)
          });
        }
        for (let i = 0; i < length; ++i) {
          target.push(scale.getPointPositionForValue(i, value));
        }
        return target;
      }
      function _drawfill(ctx, source, area) {
        const target = _getTarget(source);
        const {line, scale, axis} = source;
        const lineOpts = line.options;
        const fillOption = lineOpts.fill;
        const color = lineOpts.backgroundColor;
        const {above = color, below = color} = fillOption || {};
        if (target && line.points.length) {
          clipArea(ctx, area);
          doFill(ctx, {
            line,
            target,
            above,
            below,
            area,
            scale,
            axis
          });
          unclipArea(ctx);
        }
      }
      function doFill(ctx, cfg) {
        const {line, target, above, below, area, scale} = cfg;
        const property = line._loop ? "angle" : cfg.axis;
        ctx.save();
        if (property === "x" && below !== above) {
          clipVertical(ctx, target, area.top);
          fill(ctx, {
            line,
            target,
            color: above,
            scale,
            property
          });
          ctx.restore();
          ctx.save();
          clipVertical(ctx, target, area.bottom);
        }
        fill(ctx, {
          line,
          target,
          color: below,
          scale,
          property
        });
        ctx.restore();
      }
      function clipVertical(ctx, target, clipY) {
        const {segments, points} = target;
        let first = true;
        let lineLoop = false;
        ctx.beginPath();
        for (const segment of segments) {
          const {start, end} = segment;
          const firstPoint = points[start];
          const lastPoint = points[_findSegmentEnd(start, end, points)];
          if (first) {
            ctx.moveTo(firstPoint.x, firstPoint.y);
            first = false;
          } else {
            ctx.lineTo(firstPoint.x, clipY);
            ctx.lineTo(firstPoint.x, firstPoint.y);
          }
          lineLoop = !!target.pathSegment(ctx, segment, { move: lineLoop });
          if (lineLoop) {
            ctx.closePath();
          } else {
            ctx.lineTo(lastPoint.x, clipY);
          }
        }
        ctx.lineTo(target.first().x, clipY);
        ctx.closePath();
        ctx.clip();
      }
      function fill(ctx, cfg) {
        const {line, target, property, color, scale} = cfg;
        const segments = _segments(line, target, property);
        for (const {
              source: src,
              target: tgt,
              start,
              end
            } of segments) {
          const {
            style: {
              backgroundColor = color
            } = {}
          } = src;
          const notShape = target !== true;
          ctx.save();
          ctx.fillStyle = backgroundColor;
          clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
          ctx.beginPath();
          const lineLoop = !!line.pathSegment(ctx, src);
          let loop;
          if (notShape) {
            if (lineLoop) {
              ctx.closePath();
            } else {
              interpolatedLineTo(ctx, target, end, property);
            }
            const targetLoop = !!target.pathSegment(ctx, tgt, {
              move: lineLoop,
              reverse: true
            });
            loop = lineLoop && targetLoop;
            if (!loop) {
              interpolatedLineTo(ctx, target, start, property);
            }
          }
          ctx.closePath();
          ctx.fill(loop ? "evenodd" : "nonzero");
          ctx.restore();
        }
      }
      function clipBounds(ctx, scale, bounds) {
        const {top, bottom} = scale.chart.chartArea;
        const {property, start, end} = bounds || {};
        if (property === "x") {
          ctx.beginPath();
          ctx.rect(start, top, end - start, bottom - top);
          ctx.clip();
        }
      }
      function interpolatedLineTo(ctx, target, point, property) {
        const interpolatedPoint = target.interpolate(point, property);
        if (interpolatedPoint) {
          ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
        }
      }
      var index = {
        id: "filler",
        afterDatasetsUpdate(chart, _args, options) {
          const count = (chart.data.datasets || []).length;
          const sources = [];
          let meta, i, line, source;
          for (i = 0; i < count; ++i) {
            meta = chart.getDatasetMeta(i);
            line = meta.dataset;
            source = null;
            if (line && line.options && line instanceof LineElement) {
              source = {
                visible: chart.isDatasetVisible(i),
                index: i,
                fill: _decodeFill(line, i, count),
                chart,
                axis: meta.controller.options.indexAxis,
                scale: meta.vScale,
                line
              };
            }
            meta.$filler = source;
            sources.push(source);
          }
          for (i = 0; i < count; ++i) {
            source = sources[i];
            if (!source || source.fill === false) {
              continue;
            }
            source.fill = _resolveTarget(sources, i, options.propagate);
          }
        },
        beforeDraw(chart, _args, options) {
          const draw = options.drawTime === "beforeDraw";
          const metasets = chart.getSortedVisibleDatasetMetas();
          const area = chart.chartArea;
          for (let i = metasets.length - 1; i >= 0; --i) {
            const source = metasets[i].$filler;
            if (!source) {
              continue;
            }
            source.line.updateControlPoints(area, source.axis);
            if (draw && source.fill) {
              _drawfill(chart.ctx, source, area);
            }
          }
        },
        beforeDatasetsDraw(chart, _args, options) {
          if (options.drawTime !== "beforeDatasetsDraw") {
            return;
          }
          const metasets = chart.getSortedVisibleDatasetMetas();
          for (let i = metasets.length - 1; i >= 0; --i) {
            const source = metasets[i].$filler;
            if (_shouldApplyFill(source)) {
              _drawfill(chart.ctx, source, chart.chartArea);
            }
          }
        },
        beforeDatasetDraw(chart, args, options) {
          const source = args.meta.$filler;
          if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
            return;
          }
          _drawfill(chart.ctx, source, chart.chartArea);
        },
        defaults: {
          propagate: true,
          drawTime: "beforeDatasetDraw"
        }
      };
      const getBoxSize = (labelOpts, fontSize) => {
        let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;
        if (labelOpts.usePointStyle) {
          boxHeight = Math.min(boxHeight, fontSize);
          boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
        }
        return {
          boxWidth,
          boxHeight,
          itemHeight: Math.max(fontSize, boxHeight)
        };
      };
      const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
      class Legend extends Element {
        constructor(config) {
          super();
          this._added = false;
          this.legendHitBoxes = [];
          this._hoveredItem = null;
          this.doughnutMode = false;
          this.chart = config.chart;
          this.options = config.options;
          this.ctx = config.ctx;
          this.legendItems = undefined;
          this.columnSizes = undefined;
          this.lineWidths = undefined;
          this.maxHeight = undefined;
          this.maxWidth = undefined;
          this.top = undefined;
          this.bottom = undefined;
          this.left = undefined;
          this.right = undefined;
          this.height = undefined;
          this.width = undefined;
          this._margins = undefined;
          this.position = undefined;
          this.weight = undefined;
          this.fullSize = undefined;
        }
        update(maxWidth, maxHeight, margins) {
          this.maxWidth = maxWidth;
          this.maxHeight = maxHeight;
          this._margins = margins;
          this.setDimensions();
          this.buildLabels();
          this.fit();
        }
        setDimensions() {
          if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = this._margins.left;
            this.right = this.width;
          } else {
            this.height = this.maxHeight;
            this.top = this._margins.top;
            this.bottom = this.height;
          }
        }
        buildLabels() {
          const labelOpts = this.options.labels || {};
          let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
          if (labelOpts.filter) {
            legendItems = legendItems.filter(item => labelOpts.filter(item, this.chart.data));
          }
          if (labelOpts.sort) {
            legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
          }
          if (this.options.reverse) {
            legendItems.reverse();
          }
          this.legendItems = legendItems;
        }
        fit() {
          const {options, ctx} = this;
          if (!options.display) {
            this.width = this.height = 0;
            return;
          }
          const labelOpts = options.labels;
          const labelFont = toFont(labelOpts.font);
          const fontSize = labelFont.size;
          const titleHeight = this._computeTitleHeight();
          const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);
          let width, height;
          ctx.font = labelFont.string;
          if (this.isHorizontal()) {
            width = this.maxWidth;
            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
          } else {
            height = this.maxHeight;
            width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
          }
          this.width = Math.min(width, options.maxWidth || this.maxWidth);
          this.height = Math.min(height, options.maxHeight || this.maxHeight);
        }
        _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
          const {
            ctx,
            maxWidth,
            options: {
              labels: {padding}
            }
          } = this;
          const hitboxes = this.legendHitBoxes = [];
          const lineWidths = this.lineWidths = [0];
          const lineHeight = itemHeight + padding;
          let totalHeight = titleHeight;
          ctx.textAlign = "left";
          ctx.textBaseline = "middle";
          let row = -1;
          let top = -lineHeight;
          this.legendItems.forEach((legendItem, i) => {
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
              totalHeight += lineHeight;
              lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
              top += lineHeight;
              row++;
            }
            hitboxes[i] = {
              left: 0,
              top,
              row,
              width: itemWidth,
              height: itemHeight
            };
            lineWidths[lineWidths.length - 1] += itemWidth + padding;
          });
          return totalHeight;
        }
        _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
          const {
            ctx,
            maxHeight,
            options: {
              labels: {padding}
            }
          } = this;
          const hitboxes = this.legendHitBoxes = [];
          const columnSizes = this.columnSizes = [];
          const heightLimit = maxHeight - titleHeight;
          let totalWidth = padding;
          let currentColWidth = 0;
          let currentColHeight = 0;
          let left = 0;
          let col = 0;
          this.legendItems.forEach((legendItem, i) => {
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
              totalWidth += currentColWidth + padding;
              columnSizes.push({
                width: currentColWidth,
                height: currentColHeight
              });
              left += currentColWidth + padding;
              col++;
              currentColWidth = currentColHeight = 0;
            }
            hitboxes[i] = {
              left,
              top: currentColHeight,
              col,
              width: itemWidth,
              height: itemHeight
            };
            currentColWidth = Math.max(currentColWidth, itemWidth);
            currentColHeight += itemHeight + padding;
          });
          totalWidth += currentColWidth;
          columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
          });
          return totalWidth;
        }
        adjustHitBoxes() {
          if (!this.options.display) {
            return;
          }
          const titleHeight = this._computeTitleHeight();
          const {
            legendHitBoxes: hitboxes,
            options: {
              align,
              labels: {padding},
              rtl
            }
          } = this;
          const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
          if (this.isHorizontal()) {
            let row = 0;
            let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
            for (const hitbox of hitboxes) {
              if (row !== hitbox.row) {
                row = hitbox.row;
                left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
              }
              hitbox.top += this.top + titleHeight + padding;
              hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
              left += hitbox.width + padding;
            }
          } else {
            let col = 0;
            let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
            for (const hitbox of hitboxes) {
              if (hitbox.col !== col) {
                col = hitbox.col;
                top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
              }
              hitbox.top = top;
              hitbox.left += this.left + padding;
              hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
              top += hitbox.height + padding;
            }
          }
        }
        isHorizontal() {
          return this.options.position === "top" || this.options.position === "bottom";
        }
        draw() {
          if (this.options.display) {
            const ctx = this.ctx;
            clipArea(ctx, this);
            this._draw();
            unclipArea(ctx);
          }
        }
        _draw() {
          const {
            options: opts,
            columnSizes,
            lineWidths,
            ctx
          } = this;
          const {
            align,
            labels: labelOpts
          } = opts;
          const defaultColor = defaults.color;
          const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
          const labelFont = toFont(labelOpts.font);
          const {
            color: fontColor,
            padding
          } = labelOpts;
          const fontSize = labelFont.size;
          const halfFontSize = fontSize / 2;
          let cursor;
          this.drawTitle();
          ctx.textAlign = rtlHelper.textAlign("left");
          ctx.textBaseline = "middle";
          ctx.lineWidth = 0.5;
          ctx.font = labelFont.string;
          const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);
          const drawLegendBox = function (x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
              return;
            }
            ctx.save();
            const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
            ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
            ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
            ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
            ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
            ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
            if (labelOpts.usePointStyle) {
              const drawOptions = {
                radius: boxHeight * Math.SQRT2 / 2,
                pointStyle: legendItem.pointStyle,
                rotation: legendItem.rotation,
                borderWidth: lineWidth
              };
              const centerX = rtlHelper.xPlus(x, boxWidth / 2);
              const centerY = y + halfFontSize;
              drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
            } else {
              const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
              const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
              const borderRadius = toTRBLCorners(legendItem.borderRadius);
              ctx.beginPath();
              if (Object.values(borderRadius).some(v => v !== 0)) {
                addRoundedRectPath(ctx, {
                  x: xBoxLeft,
                  y: yBoxTop,
                  w: boxWidth,
                  h: boxHeight,
                  radius: borderRadius
                });
              } else {
                ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
              }
              ctx.fill();
              if (lineWidth !== 0) {
                ctx.stroke();
              }
            }
            ctx.restore();
          };
          const fillText = function (x, y, legendItem) {
            renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
              strikethrough: legendItem.hidden,
              textAlign: rtlHelper.textAlign(legendItem.textAlign)
            });
          };
          const isHorizontal = this.isHorizontal();
          const titleHeight = this._computeTitleHeight();
          if (isHorizontal) {
            cursor = {
              x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
              y: this.top + padding + titleHeight,
              line: 0
            };
          } else {
            cursor = {
              x: this.left + padding,
              y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
              line: 0
            };
          }
          overrideTextDirection(this.ctx, opts.textDirection);
          const lineHeight = itemHeight + padding;
          this.legendItems.forEach((legendItem, i) => {
            ctx.strokeStyle = legendItem.fontColor || fontColor;
            ctx.fillStyle = legendItem.fontColor || fontColor;
            const textWidth = ctx.measureText(legendItem.text).width;
            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
            const width = boxWidth + halfFontSize + textWidth;
            let x = cursor.x;
            let y = cursor.y;
            rtlHelper.setWidth(this.width);
            if (isHorizontal) {
              if (i > 0 && x + width + padding > this.right) {
                y = cursor.y += lineHeight;
                cursor.line++;
                x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
              }
            } else if (i > 0 && y + lineHeight > this.bottom) {
              x = cursor.x = x + columnSizes[cursor.line].width + padding;
              cursor.line++;
              y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
            }
            const realX = rtlHelper.x(x);
            drawLegendBox(realX, y, legendItem);
            x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
            fillText(rtlHelper.x(x), y, legendItem);
            if (isHorizontal) {
              cursor.x += width + padding;
            } else {
              cursor.y += lineHeight;
            }
          });
          restoreTextDirection(this.ctx, opts.textDirection);
        }
        drawTitle() {
          const opts = this.options;
          const titleOpts = opts.title;
          const titleFont = toFont(titleOpts.font);
          const titlePadding = toPadding(titleOpts.padding);
          if (!titleOpts.display) {
            return;
          }
          const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
          const ctx = this.ctx;
          const position = titleOpts.position;
          const halfFontSize = titleFont.size / 2;
          const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
          let y;
          let left = this.left;
          let maxWidth = this.width;
          if (this.isHorizontal()) {
            maxWidth = Math.max(...this.lineWidths);
            y = this.top + topPaddingPlusHalfFontSize;
            left = _alignStartEnd(opts.align, left, this.right - maxWidth);
          } else {
            const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
            y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
          }
          const x = _alignStartEnd(position, left, left + maxWidth);
          ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
          ctx.textBaseline = "middle";
          ctx.strokeStyle = titleOpts.color;
          ctx.fillStyle = titleOpts.color;
          ctx.font = titleFont.string;
          renderText(ctx, titleOpts.text, x, y, titleFont);
        }
        _computeTitleHeight() {
          const titleOpts = this.options.title;
          const titleFont = toFont(titleOpts.font);
          const titlePadding = toPadding(titleOpts.padding);
          return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
        }
        _getLegendItemAt(x, y) {
          let i, hitBox, lh;
          if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
            lh = this.legendHitBoxes;
            for (i = 0; i < lh.length; ++i) {
              hitBox = lh[i];
              if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
                return this.legendItems[i];
              }
            }
          }
          return null;
        }
        handleEvent(e) {
          const opts = this.options;
          if (!isListened(e.type, opts)) {
            return;
          }
          const hoveredItem = this._getLegendItemAt(e.x, e.y);
          if (e.type === "mousemove" || e.type === "mouseout") {
            const previous = this._hoveredItem;
            const sameItem = itemsEqual(previous, hoveredItem);
            if (previous && !sameItem) {
              callback(opts.onLeave, [
                e,
                previous,
                this
              ], this);
            }
            this._hoveredItem = hoveredItem;
            if (hoveredItem && !sameItem) {
              callback(opts.onHover, [
                e,
                hoveredItem,
                this
              ], this);
            }
          } else if (hoveredItem) {
            callback(opts.onClick, [
              e,
              hoveredItem,
              this
            ], this);
          }
        }
      }
      function isListened(type, opts) {
        if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
          return true;
        }
        if (opts.onClick && (type === "click" || type === "mouseup")) {
          return true;
        }
        return false;
      }
      var plugin_legend = {
        id: "legend",
        _element: Legend,
        start(chart, _args, options) {
          const legend = chart.legend = new Legend({
            ctx: chart.ctx,
            options,
            chart
          });
          layouts.configure(chart, legend, options);
          layouts.addBox(chart, legend);
        },
        stop(chart) {
          layouts.removeBox(chart, chart.legend);
          delete chart.legend;
        },
        beforeUpdate(chart, _args, options) {
          const legend = chart.legend;
          layouts.configure(chart, legend, options);
          legend.options = options;
        },
        afterUpdate(chart) {
          const legend = chart.legend;
          legend.buildLabels();
          legend.adjustHitBoxes();
        },
        afterEvent(chart, args) {
          if (!args.replay) {
            chart.legend.handleEvent(args.event);
          }
        },
        defaults: {
          display: true,
          position: "top",
          align: "center",
          fullSize: true,
          reverse: false,
          weight: 1000,
          onClick(e, legendItem, legend) {
            const index = legendItem.datasetIndex;
            const ci = legend.chart;
            if (ci.isDatasetVisible(index)) {
              ci.hide(index);
              legendItem.hidden = true;
            } else {
              ci.show(index);
              legendItem.hidden = false;
            }
          },
          onHover: null,
          onLeave: null,
          labels: {
            color: ctx => ctx.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels(chart) {
              const datasets = chart.data.datasets;
              const {
                labels: {usePointStyle, pointStyle, textAlign, color}
              } = chart.legend.options;
              return chart._getSortedDatasetMetas().map(meta => {
                const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
                const borderWidth = toPadding(style.borderWidth);
                return {
                  text: datasets[meta.index].label,
                  fillStyle: style.backgroundColor,
                  fontColor: color,
                  hidden: !meta.visible,
                  lineCap: style.borderCapStyle,
                  lineDash: style.borderDash,
                  lineDashOffset: style.borderDashOffset,
                  lineJoin: style.borderJoinStyle,
                  lineWidth: (borderWidth.width + borderWidth.height) / 4,
                  strokeStyle: style.borderColor,
                  pointStyle: pointStyle || style.pointStyle,
                  rotation: style.rotation,
                  textAlign: textAlign || style.textAlign,
                  borderRadius: 0,
                  datasetIndex: meta.index
                };
              }, this);
            }
          },
          title: {
            color: ctx => ctx.chart.options.color,
            display: false,
            position: "center",
            text: ""
          }
        },
        descriptors: {
          _scriptable: name => !name.startsWith("on"),
          labels: {
            _scriptable: name => ![
              "generateLabels",
              "filter",
              "sort"
            ].includes(name)
          }
        }
      };
      class Title extends Element {
        constructor(config) {
          super();
          this.chart = config.chart;
          this.options = config.options;
          this.ctx = config.ctx;
          this._padding = undefined;
          this.top = undefined;
          this.bottom = undefined;
          this.left = undefined;
          this.right = undefined;
          this.width = undefined;
          this.height = undefined;
          this.position = undefined;
          this.weight = undefined;
          this.fullSize = undefined;
        }
        update(maxWidth, maxHeight) {
          const opts = this.options;
          this.left = 0;
          this.top = 0;
          if (!opts.display) {
            this.width = this.height = this.right = this.bottom = 0;
            return;
          }
          this.width = this.right = maxWidth;
          this.height = this.bottom = maxHeight;
          const lineCount = isArray(opts.text) ? opts.text.length : 1;
          this._padding = toPadding(opts.padding);
          const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
          if (this.isHorizontal()) {
            this.height = textSize;
          } else {
            this.width = textSize;
          }
        }
        isHorizontal() {
          const pos = this.options.position;
          return pos === "top" || pos === "bottom";
        }
        _drawArgs(offset) {
          const {top, left, bottom, right, options} = this;
          const align = options.align;
          let rotation = 0;
          let maxWidth, titleX, titleY;
          if (this.isHorizontal()) {
            titleX = _alignStartEnd(align, left, right);
            titleY = top + offset;
            maxWidth = right - left;
          } else {
            if (options.position === "left") {
              titleX = left + offset;
              titleY = _alignStartEnd(align, bottom, top);
              rotation = PI * -0.5;
            } else {
              titleX = right - offset;
              titleY = _alignStartEnd(align, top, bottom);
              rotation = PI * 0.5;
            }
            maxWidth = bottom - top;
          }
          return {
            titleX,
            titleY,
            maxWidth,
            rotation
          };
        }
        draw() {
          const ctx = this.ctx;
          const opts = this.options;
          if (!opts.display) {
            return;
          }
          const fontOpts = toFont(opts.font);
          const lineHeight = fontOpts.lineHeight;
          const offset = lineHeight / 2 + this._padding.top;
          const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);
          renderText(ctx, opts.text, 0, 0, fontOpts, {
            color: opts.color,
            maxWidth,
            rotation,
            textAlign: _toLeftRightCenter(opts.align),
            textBaseline: "middle",
            translation: [
              titleX,
              titleY
            ]
          });
        }
      }
      function createTitle(chart, titleOpts) {
        const title = new Title({
          ctx: chart.ctx,
          options: titleOpts,
          chart
        });
        layouts.configure(chart, title, titleOpts);
        layouts.addBox(chart, title);
        chart.titleBlock = title;
      }
      var plugin_title = {
        id: "title",
        _element: Title,
        start(chart, _args, options) {
          createTitle(chart, options);
        },
        stop(chart) {
          const titleBlock = chart.titleBlock;
          layouts.removeBox(chart, titleBlock);
          delete chart.titleBlock;
        },
        beforeUpdate(chart, _args, options) {
          const title = chart.titleBlock;
          layouts.configure(chart, title, options);
          title.options = options;
        },
        defaults: {
          align: "center",
          display: false,
          font: { weight: "bold" },
          fullSize: true,
          padding: 10,
          position: "top",
          text: "",
          weight: 2000
        },
        defaultRoutes: { color: "color" },
        descriptors: {
          _scriptable: true,
          _indexable: false
        }
      };
      const map = new WeakMap();
      var plugin_subtitle = {
        id: "subtitle",
        start(chart, _args, options) {
          const title = new Title({
            ctx: chart.ctx,
            options,
            chart
          });
          layouts.configure(chart, title, options);
          layouts.addBox(chart, title);
          map.set(chart, title);
        },
        stop(chart) {
          layouts.removeBox(chart, map.get(chart));
          map.delete(chart);
        },
        beforeUpdate(chart, _args, options) {
          const title = map.get(chart);
          layouts.configure(chart, title, options);
          title.options = options;
        },
        defaults: {
          align: "center",
          display: false,
          font: { weight: "normal" },
          fullSize: true,
          padding: 0,
          position: "top",
          text: "",
          weight: 1500
        },
        defaultRoutes: { color: "color" },
        descriptors: {
          _scriptable: true,
          _indexable: false
        }
      };
      const positioners = {
        average(items) {
          if (!items.length) {
            return false;
          }
          let i, len;
          let x = 0;
          let y = 0;
          let count = 0;
          for (i = 0, len = items.length; i < len; ++i) {
            const el = items[i].element;
            if (el && el.hasValue()) {
              const pos = el.tooltipPosition();
              x += pos.x;
              y += pos.y;
              ++count;
            }
          }
          return {
            x: x / count,
            y: y / count
          };
        },
        nearest(items, eventPosition) {
          if (!items.length) {
            return false;
          }
          let x = eventPosition.x;
          let y = eventPosition.y;
          let minDistance = Number.POSITIVE_INFINITY;
          let i, len, nearestElement;
          for (i = 0, len = items.length; i < len; ++i) {
            const el = items[i].element;
            if (el && el.hasValue()) {
              const center = el.getCenterPoint();
              const d = distanceBetweenPoints(eventPosition, center);
              if (d < minDistance) {
                minDistance = d;
                nearestElement = el;
              }
            }
          }
          if (nearestElement) {
            const tp = nearestElement.tooltipPosition();
            x = tp.x;
            y = tp.y;
          }
          return {
            x,
            y
          };
        }
      };
      function pushOrConcat(base, toPush) {
        if (toPush) {
          if (isArray(toPush)) {
            Array.prototype.push.apply(base, toPush);
          } else {
            base.push(toPush);
          }
        }
        return base;
      }
      function splitNewlines(str) {
        if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
          return str.split("\n");
        }
        return str;
      }
      function createTooltipItem(chart, item) {
        const {element, datasetIndex, index} = item;
        const controller = chart.getDatasetMeta(datasetIndex).controller;
        const {label, value} = controller.getLabelAndValue(index);
        return {
          chart,
          label,
          parsed: controller.getParsed(index),
          raw: chart.data.datasets[datasetIndex].data[index],
          formattedValue: value,
          dataset: controller.getDataset(),
          dataIndex: index,
          datasetIndex,
          element
        };
      }
      function getTooltipSize(tooltip, options) {
        const ctx = tooltip.chart.ctx;
        const {body, footer, title} = tooltip;
        const {boxWidth, boxHeight} = options;
        const bodyFont = toFont(options.bodyFont);
        const titleFont = toFont(options.titleFont);
        const footerFont = toFont(options.footerFont);
        const titleLineCount = title.length;
        const footerLineCount = footer.length;
        const bodyLineItemCount = body.length;
        const padding = toPadding(options.padding);
        let height = padding.height;
        let width = 0;
        let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
        combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
        if (titleLineCount) {
          height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
        }
        if (combinedBodyLength) {
          const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
          height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
        }
        if (footerLineCount) {
          height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
        }
        let widthPadding = 0;
        const maxLineWidth = function (line) {
          width = Math.max(width, ctx.measureText(line).width + widthPadding);
        };
        ctx.save();
        ctx.font = titleFont.string;
        each(tooltip.title, maxLineWidth);
        ctx.font = bodyFont.string;
        each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
        widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
        each(body, bodyItem => {
          each(bodyItem.before, maxLineWidth);
          each(bodyItem.lines, maxLineWidth);
          each(bodyItem.after, maxLineWidth);
        });
        widthPadding = 0;
        ctx.font = footerFont.string;
        each(tooltip.footer, maxLineWidth);
        ctx.restore();
        width += padding.width;
        return {
          width,
          height
        };
      }
      function determineYAlign(chart, size) {
        const {y, height} = size;
        if (y < height / 2) {
          return "top";
        } else if (y > chart.height - height / 2) {
          return "bottom";
        }
        return "center";
      }
      function doesNotFitWithAlign(xAlign, chart, options, size) {
        const {x, width} = size;
        const caret = options.caretSize + options.caretPadding;
        if (xAlign === "left" && x + width + caret > chart.width) {
          return true;
        }
        if (xAlign === "right" && x - width - caret < 0) {
          return true;
        }
      }
      function determineXAlign(chart, options, size, yAlign) {
        const {x, width} = size;
        const {
          width: chartWidth,
          chartArea: {left, right}
        } = chart;
        let xAlign = "center";
        if (yAlign === "center") {
          xAlign = x <= (left + right) / 2 ? "left" : "right";
        } else if (x <= width / 2) {
          xAlign = "left";
        } else if (x >= chartWidth - width / 2) {
          xAlign = "right";
        }
        if (doesNotFitWithAlign(xAlign, chart, options, size)) {
          xAlign = "center";
        }
        return xAlign;
      }
      function determineAlignment(chart, options, size) {
        const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
        return {
          xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
          yAlign
        };
      }
      function alignX(size, xAlign) {
        let {x, width} = size;
        if (xAlign === "right") {
          x -= width;
        } else if (xAlign === "center") {
          x -= width / 2;
        }
        return x;
      }
      function alignY(size, yAlign, paddingAndSize) {
        let {y, height} = size;
        if (yAlign === "top") {
          y += paddingAndSize;
        } else if (yAlign === "bottom") {
          y -= height + paddingAndSize;
        } else {
          y -= height / 2;
        }
        return y;
      }
      function getBackgroundPoint(options, size, alignment, chart) {
        const {caretSize, caretPadding, cornerRadius} = options;
        const {xAlign, yAlign} = alignment;
        const paddingAndSize = caretSize + caretPadding;
        const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
        let x = alignX(size, xAlign);
        const y = alignY(size, yAlign, paddingAndSize);
        if (yAlign === "center") {
          if (xAlign === "left") {
            x += paddingAndSize;
          } else if (xAlign === "right") {
            x -= paddingAndSize;
          }
        } else if (xAlign === "left") {
          x -= Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === "right") {
          x += Math.max(topRight, bottomRight) + caretSize;
        }
        return {
          x: _limitValue(x, 0, chart.width - size.width),
          y: _limitValue(y, 0, chart.height - size.height)
        };
      }
      function getAlignedX(tooltip, align, options) {
        const padding = toPadding(options.padding);
        return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
      }
      function getBeforeAfterBodyLines(callback) {
        return pushOrConcat([], splitNewlines(callback));
      }
      function createTooltipContext(parent, tooltip, tooltipItems) {
        return createContext(parent, {
          tooltip,
          tooltipItems,
          type: "tooltip"
        });
      }
      function overrideCallbacks(callbacks, context) {
        const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
        return override ? callbacks.override(override) : callbacks;
      }
      class Tooltip extends Element {
        constructor(config) {
          super();
          this.opacity = 0;
          this._active = [];
          this._eventPosition = undefined;
          this._size = undefined;
          this._cachedAnimations = undefined;
          this._tooltipItems = [];
          this.$animations = undefined;
          this.$context = undefined;
          this.chart = config.chart || config._chart;
          this._chart = this.chart;
          this.options = config.options;
          this.dataPoints = undefined;
          this.title = undefined;
          this.beforeBody = undefined;
          this.body = undefined;
          this.afterBody = undefined;
          this.footer = undefined;
          this.xAlign = undefined;
          this.yAlign = undefined;
          this.x = undefined;
          this.y = undefined;
          this.height = undefined;
          this.width = undefined;
          this.caretX = undefined;
          this.caretY = undefined;
          this.labelColors = undefined;
          this.labelPointStyles = undefined;
          this.labelTextColors = undefined;
        }
        initialize(options) {
          this.options = options;
          this._cachedAnimations = undefined;
          this.$context = undefined;
        }
        _resolveAnimations() {
          const cached = this._cachedAnimations;
          if (cached) {
            return cached;
          }
          const chart = this.chart;
          const options = this.options.setContext(this.getContext());
          const opts = options.enabled && chart.options.animation && options.animations;
          const animations = new Animations(this.chart, opts);
          if (opts._cacheable) {
            this._cachedAnimations = Object.freeze(animations);
          }
          return animations;
        }
        getContext() {
          return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
        }
        getTitle(context, options) {
          const {callbacks} = options;
          const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
          const title = callbacks.title.apply(this, [context]);
          const afterTitle = callbacks.afterTitle.apply(this, [context]);
          let lines = [];
          lines = pushOrConcat(lines, splitNewlines(beforeTitle));
          lines = pushOrConcat(lines, splitNewlines(title));
          lines = pushOrConcat(lines, splitNewlines(afterTitle));
          return lines;
        }
        getBeforeBody(tooltipItems, options) {
          return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
        }
        getBody(tooltipItems, options) {
          const {callbacks} = options;
          const bodyItems = [];
          each(tooltipItems, context => {
            const bodyItem = {
              before: [],
              lines: [],
              after: []
            };
            const scoped = overrideCallbacks(callbacks, context);
            pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
            pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
            pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
            bodyItems.push(bodyItem);
          });
          return bodyItems;
        }
        getAfterBody(tooltipItems, options) {
          return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
        }
        getFooter(tooltipItems, options) {
          const {callbacks} = options;
          const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
          const footer = callbacks.footer.apply(this, [tooltipItems]);
          const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
          let lines = [];
          lines = pushOrConcat(lines, splitNewlines(beforeFooter));
          lines = pushOrConcat(lines, splitNewlines(footer));
          lines = pushOrConcat(lines, splitNewlines(afterFooter));
          return lines;
        }
        _createItems(options) {
          const active = this._active;
          const data = this.chart.data;
          const labelColors = [];
          const labelPointStyles = [];
          const labelTextColors = [];
          let tooltipItems = [];
          let i, len;
          for (i = 0, len = active.length; i < len; ++i) {
            tooltipItems.push(createTooltipItem(this.chart, active[i]));
          }
          if (options.filter) {
            tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));
          }
          if (options.itemSort) {
            tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
          }
          each(tooltipItems, context => {
            const scoped = overrideCallbacks(options.callbacks, context);
            labelColors.push(scoped.labelColor.call(this, context));
            labelPointStyles.push(scoped.labelPointStyle.call(this, context));
            labelTextColors.push(scoped.labelTextColor.call(this, context));
          });
          this.labelColors = labelColors;
          this.labelPointStyles = labelPointStyles;
          this.labelTextColors = labelTextColors;
          this.dataPoints = tooltipItems;
          return tooltipItems;
        }
        update(changed, replay) {
          const options = this.options.setContext(this.getContext());
          const active = this._active;
          let properties;
          let tooltipItems = [];
          if (!active.length) {
            if (this.opacity !== 0) {
              properties = { opacity: 0 };
            }
          } else {
            const position = positioners[options.position].call(this, active, this._eventPosition);
            tooltipItems = this._createItems(options);
            this.title = this.getTitle(tooltipItems, options);
            this.beforeBody = this.getBeforeBody(tooltipItems, options);
            this.body = this.getBody(tooltipItems, options);
            this.afterBody = this.getAfterBody(tooltipItems, options);
            this.footer = this.getFooter(tooltipItems, options);
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, size);
            const alignment = determineAlignment(this.chart, options, positionAndSize);
            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
            this.xAlign = alignment.xAlign;
            this.yAlign = alignment.yAlign;
            properties = {
              opacity: 1,
              x: backgroundPoint.x,
              y: backgroundPoint.y,
              width: size.width,
              height: size.height,
              caretX: position.x,
              caretY: position.y
            };
          }
          this._tooltipItems = tooltipItems;
          this.$context = undefined;
          if (properties) {
            this._resolveAnimations().update(this, properties);
          }
          if (changed && options.external) {
            options.external.call(this, {
              chart: this.chart,
              tooltip: this,
              replay
            });
          }
        }
        drawCaret(tooltipPoint, ctx, size, options) {
          const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
          ctx.lineTo(caretPosition.x1, caretPosition.y1);
          ctx.lineTo(caretPosition.x2, caretPosition.y2);
          ctx.lineTo(caretPosition.x3, caretPosition.y3);
        }
        getCaretPosition(tooltipPoint, size, options) {
          const {xAlign, yAlign} = this;
          const {caretSize, cornerRadius} = options;
          const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
          const {
            x: ptX,
            y: ptY
          } = tooltipPoint;
          const {width, height} = size;
          let x1, x2, x3, y1, y2, y3;
          if (yAlign === "center") {
            y2 = ptY + height / 2;
            if (xAlign === "left") {
              x1 = ptX;
              x2 = x1 - caretSize;
              y1 = y2 + caretSize;
              y3 = y2 - caretSize;
            } else {
              x1 = ptX + width;
              x2 = x1 + caretSize;
              y1 = y2 - caretSize;
              y3 = y2 + caretSize;
            }
            x3 = x1;
          } else {
            if (xAlign === "left") {
              x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
            } else if (xAlign === "right") {
              x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
            } else {
              x2 = this.caretX;
            }
            if (yAlign === "top") {
              y1 = ptY;
              y2 = y1 - caretSize;
              x1 = x2 - caretSize;
              x3 = x2 + caretSize;
            } else {
              y1 = ptY + height;
              y2 = y1 + caretSize;
              x1 = x2 + caretSize;
              x3 = x2 - caretSize;
            }
            y3 = y1;
          }
          return {
            x1,
            x2,
            x3,
            y1,
            y2,
            y3
          };
        }
        drawTitle(pt, ctx, options) {
          const title = this.title;
          const length = title.length;
          let titleFont, titleSpacing, i;
          if (length) {
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.titleAlign, options);
            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
            ctx.textBaseline = "middle";
            titleFont = toFont(options.titleFont);
            titleSpacing = options.titleSpacing;
            ctx.fillStyle = options.titleColor;
            ctx.font = titleFont.string;
            for (i = 0; i < length; ++i) {
              ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
              pt.y += titleFont.lineHeight + titleSpacing;
              if (i + 1 === length) {
                pt.y += options.titleMarginBottom - titleSpacing;
              }
            }
          }
        }
        _drawColorBox(ctx, pt, i, rtlHelper, options) {
          const labelColors = this.labelColors[i];
          const labelPointStyle = this.labelPointStyles[i];
          const {boxHeight, boxWidth, boxPadding} = options;
          const bodyFont = toFont(options.bodyFont);
          const colorX = getAlignedX(this, "left", options);
          const rtlColorX = rtlHelper.x(colorX);
          const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
          const colorY = pt.y + yOffSet;
          if (options.usePointStyle) {
            const drawOptions = {
              radius: Math.min(boxWidth, boxHeight) / 2,
              pointStyle: labelPointStyle.pointStyle,
              rotation: labelPointStyle.rotation,
              borderWidth: 1
            };
            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
            const centerY = colorY + boxHeight / 2;
            ctx.strokeStyle = options.multiKeyBackground;
            ctx.fillStyle = options.multiKeyBackground;
            drawPoint(ctx, drawOptions, centerX, centerY);
            ctx.strokeStyle = labelColors.borderColor;
            ctx.fillStyle = labelColors.backgroundColor;
            drawPoint(ctx, drawOptions, centerX, centerY);
          } else {
            ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
            ctx.strokeStyle = labelColors.borderColor;
            ctx.setLineDash(labelColors.borderDash || []);
            ctx.lineDashOffset = labelColors.borderDashOffset || 0;
            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
            const borderRadius = toTRBLCorners(labelColors.borderRadius);
            if (Object.values(borderRadius).some(v => v !== 0)) {
              ctx.beginPath();
              ctx.fillStyle = options.multiKeyBackground;
              addRoundedRectPath(ctx, {
                x: outerX,
                y: colorY,
                w: boxWidth,
                h: boxHeight,
                radius: borderRadius
              });
              ctx.fill();
              ctx.stroke();
              ctx.fillStyle = labelColors.backgroundColor;
              ctx.beginPath();
              addRoundedRectPath(ctx, {
                x: innerX,
                y: colorY + 1,
                w: boxWidth - 2,
                h: boxHeight - 2,
                radius: borderRadius
              });
              ctx.fill();
            } else {
              ctx.fillStyle = options.multiKeyBackground;
              ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
              ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
              ctx.fillStyle = labelColors.backgroundColor;
              ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
            }
          }
          ctx.fillStyle = this.labelTextColors[i];
        }
        drawBody(pt, ctx, options) {
          const {body} = this;
          const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;
          const bodyFont = toFont(options.bodyFont);
          let bodyLineHeight = bodyFont.lineHeight;
          let xLinePadding = 0;
          const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
          const fillLineOfText = function (line) {
            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
            pt.y += bodyLineHeight + bodySpacing;
          };
          const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
          let bodyItem, textColor, lines, i, j, ilen, jlen;
          ctx.textAlign = bodyAlign;
          ctx.textBaseline = "middle";
          ctx.font = bodyFont.string;
          pt.x = getAlignedX(this, bodyAlignForCalculation, options);
          ctx.fillStyle = options.bodyColor;
          each(this.beforeBody, fillLineOfText);
          xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
          for (i = 0, ilen = body.length; i < ilen; ++i) {
            bodyItem = body[i];
            textColor = this.labelTextColors[i];
            ctx.fillStyle = textColor;
            each(bodyItem.before, fillLineOfText);
            lines = bodyItem.lines;
            if (displayColors && lines.length) {
              this._drawColorBox(ctx, pt, i, rtlHelper, options);
              bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
            }
            for (j = 0, jlen = lines.length; j < jlen; ++j) {
              fillLineOfText(lines[j]);
              bodyLineHeight = bodyFont.lineHeight;
            }
            each(bodyItem.after, fillLineOfText);
          }
          xLinePadding = 0;
          bodyLineHeight = bodyFont.lineHeight;
          each(this.afterBody, fillLineOfText);
          pt.y -= bodySpacing;
        }
        drawFooter(pt, ctx, options) {
          const footer = this.footer;
          const length = footer.length;
          let footerFont, i;
          if (length) {
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.footerAlign, options);
            pt.y += options.footerMarginTop;
            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
            ctx.textBaseline = "middle";
            footerFont = toFont(options.footerFont);
            ctx.fillStyle = options.footerColor;
            ctx.font = footerFont.string;
            for (i = 0; i < length; ++i) {
              ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
              pt.y += footerFont.lineHeight + options.footerSpacing;
            }
          }
        }
        drawBackground(pt, ctx, tooltipSize, options) {
          const {xAlign, yAlign} = this;
          const {x, y} = pt;
          const {width, height} = tooltipSize;
          const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);
          ctx.fillStyle = options.backgroundColor;
          ctx.strokeStyle = options.borderColor;
          ctx.lineWidth = options.borderWidth;
          ctx.beginPath();
          ctx.moveTo(x + topLeft, y);
          if (yAlign === "top") {
            this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x + width - topRight, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
          if (yAlign === "center" && xAlign === "right") {
            this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x + width, y + height - bottomRight);
          ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
          if (yAlign === "bottom") {
            this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x + bottomLeft, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
          if (yAlign === "center" && xAlign === "left") {
            this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x, y + topLeft);
          ctx.quadraticCurveTo(x, y, x + topLeft, y);
          ctx.closePath();
          ctx.fill();
          if (options.borderWidth > 0) {
            ctx.stroke();
          }
        }
        _updateAnimationTarget(options) {
          const chart = this.chart;
          const anims = this.$animations;
          const animX = anims && anims.x;
          const animY = anims && anims.y;
          if (animX || animY) {
            const position = positioners[options.position].call(this, this._active, this._eventPosition);
            if (!position) {
              return;
            }
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, this._size);
            const alignment = determineAlignment(chart, options, positionAndSize);
            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
            if (animX._to !== point.x || animY._to !== point.y) {
              this.xAlign = alignment.xAlign;
              this.yAlign = alignment.yAlign;
              this.width = size.width;
              this.height = size.height;
              this.caretX = position.x;
              this.caretY = position.y;
              this._resolveAnimations().update(this, point);
            }
          }
        }
        _willRender() {
          return !!this.opacity;
        }
        draw(ctx) {
          const options = this.options.setContext(this.getContext());
          let opacity = this.opacity;
          if (!opacity) {
            return;
          }
          this._updateAnimationTarget(options);
          const tooltipSize = {
            width: this.width,
            height: this.height
          };
          const pt = {
            x: this.x,
            y: this.y
          };
          opacity = Math.abs(opacity) < 0.001 ? 0 : opacity;
          const padding = toPadding(options.padding);
          const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
          if (options.enabled && hasTooltipContent) {
            ctx.save();
            ctx.globalAlpha = opacity;
            this.drawBackground(pt, ctx, tooltipSize, options);
            overrideTextDirection(ctx, options.textDirection);
            pt.y += padding.top;
            this.drawTitle(pt, ctx, options);
            this.drawBody(pt, ctx, options);
            this.drawFooter(pt, ctx, options);
            restoreTextDirection(ctx, options.textDirection);
            ctx.restore();
          }
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(activeElements, eventPosition) {
          const lastActive = this._active;
          const active = activeElements.map(({datasetIndex, index}) => {
            const meta = this.chart.getDatasetMeta(datasetIndex);
            if (!meta) {
              throw new Error("Cannot find a dataset at index " + datasetIndex);
            }
            return {
              datasetIndex,
              element: meta.data[index],
              index
            };
          });
          const changed = !_elementsEqual(lastActive, active);
          const positionChanged = this._positionChanged(active, eventPosition);
          if (changed || positionChanged) {
            this._active = active;
            this._eventPosition = eventPosition;
            this._ignoreReplayEvents = true;
            this.update(true);
          }
        }
        handleEvent(e, replay, inChartArea = true) {
          if (replay && this._ignoreReplayEvents) {
            return false;
          }
          this._ignoreReplayEvents = false;
          const options = this.options;
          const lastActive = this._active || [];
          const active = this._getActiveElements(e, lastActive, replay, inChartArea);
          const positionChanged = this._positionChanged(active, e);
          const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
          if (changed) {
            this._active = active;
            if (options.enabled || options.external) {
              this._eventPosition = {
                x: e.x,
                y: e.y
              };
              this.update(true, replay);
            }
          }
          return changed;
        }
        _getActiveElements(e, lastActive, replay, inChartArea) {
          const options = this.options;
          if (e.type === "mouseout") {
            return [];
          }
          if (!inChartArea) {
            return lastActive;
          }
          const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
          if (options.reverse) {
            active.reverse();
          }
          return active;
        }
        _positionChanged(active, e) {
          const {caretX, caretY, options} = this;
          const position = positioners[options.position].call(this, active, e);
          return position !== false && (caretX !== position.x || caretY !== position.y);
        }
      }
      Tooltip.positioners = positioners;
      var plugin_tooltip = {
        id: "tooltip",
        _element: Tooltip,
        positioners,
        afterInit(chart, _args, options) {
          if (options) {
            chart.tooltip = new Tooltip({
              chart,
              options
            });
          }
        },
        beforeUpdate(chart, _args, options) {
          if (chart.tooltip) {
            chart.tooltip.initialize(options);
          }
        },
        reset(chart, _args, options) {
          if (chart.tooltip) {
            chart.tooltip.initialize(options);
          }
        },
        afterDraw(chart) {
          const tooltip = chart.tooltip;
          if (tooltip && tooltip._willRender()) {
            const args = { tooltip };
            if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
              return;
            }
            tooltip.draw(chart.ctx);
            chart.notifyPlugins("afterTooltipDraw", args);
          }
        },
        afterEvent(chart, args) {
          if (chart.tooltip) {
            const useFinalPosition = args.replay;
            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
              args.changed = true;
            }
          }
        },
        defaults: {
          enabled: true,
          external: null,
          position: "average",
          backgroundColor: "rgba(0,0,0,0.8)",
          titleColor: "#fff",
          titleFont: { weight: "bold" },
          titleSpacing: 2,
          titleMarginBottom: 6,
          titleAlign: "left",
          bodyColor: "#fff",
          bodySpacing: 2,
          bodyFont: {},
          bodyAlign: "left",
          footerColor: "#fff",
          footerSpacing: 2,
          footerMarginTop: 6,
          footerFont: { weight: "bold" },
          footerAlign: "left",
          padding: 6,
          caretPadding: 2,
          caretSize: 5,
          cornerRadius: 6,
          boxHeight: (ctx, opts) => opts.bodyFont.size,
          boxWidth: (ctx, opts) => opts.bodyFont.size,
          multiKeyBackground: "#fff",
          displayColors: true,
          boxPadding: 0,
          borderColor: "rgba(0,0,0,0)",
          borderWidth: 0,
          animation: {
            duration: 400,
            easing: "easeOutQuart"
          },
          animations: {
            numbers: {
              type: "number",
              properties: [
                "x",
                "y",
                "width",
                "height",
                "caretX",
                "caretY"
              ]
            },
            opacity: {
              easing: "linear",
              duration: 200
            }
          },
          callbacks: {
            beforeTitle: noop,
            title(tooltipItems) {
              if (tooltipItems.length > 0) {
                const item = tooltipItems[0];
                const labels = item.chart.data.labels;
                const labelCount = labels ? labels.length : 0;
                if (this && this.options && this.options.mode === "dataset") {
                  return item.dataset.label || "";
                } else if (item.label) {
                  return item.label;
                } else if (labelCount > 0 && item.dataIndex < labelCount) {
                  return labels[item.dataIndex];
                }
              }
              return "";
            },
            afterTitle: noop,
            beforeBody: noop,
            beforeLabel: noop,
            label(tooltipItem) {
              if (this && this.options && this.options.mode === "dataset") {
                return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
              }
              let label = tooltipItem.dataset.label || "";
              if (label) {
                label += ": ";
              }
              const value = tooltipItem.formattedValue;
              if (!isNullOrUndef(value)) {
                label += value;
              }
              return label;
            },
            labelColor(tooltipItem) {
              const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
              const options = meta.controller.getStyle(tooltipItem.dataIndex);
              return {
                borderColor: options.borderColor,
                backgroundColor: options.backgroundColor,
                borderWidth: options.borderWidth,
                borderDash: options.borderDash,
                borderDashOffset: options.borderDashOffset,
                borderRadius: 0
              };
            },
            labelTextColor() {
              return this.options.bodyColor;
            },
            labelPointStyle(tooltipItem) {
              const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
              const options = meta.controller.getStyle(tooltipItem.dataIndex);
              return {
                pointStyle: options.pointStyle,
                rotation: options.rotation
              };
            },
            afterLabel: noop,
            afterBody: noop,
            beforeFooter: noop,
            footer: noop,
            afterFooter: noop
          }
        },
        defaultRoutes: {
          bodyFont: "font",
          footerFont: "font",
          titleFont: "font"
        },
        descriptors: {
          _scriptable: name => name !== "filter" && name !== "itemSort" && name !== "external",
          _indexable: false,
          callbacks: {
            _scriptable: false,
            _indexable: false
          },
          animation: { _fallback: false },
          animations: { _fallback: "animation" }
        },
        additionalOptionScopes: ["interaction"]
      };
      var plugins = Object.freeze({
        __proto__: null,
        Decimation: plugin_decimation,
        Filler: index,
        Legend: plugin_legend,
        SubTitle: plugin_subtitle,
        Title: plugin_title,
        Tooltip: plugin_tooltip
      });
      const addIfString = (labels, raw, index, addedLabels) => {
        if (typeof raw === "string") {
          index = labels.push(raw) - 1;
          addedLabels.unshift({
            index,
            label: raw
          });
        } else if (isNaN(raw)) {
          index = null;
        }
        return index;
      };
      function findOrAddLabel(labels, raw, index, addedLabels) {
        const first = labels.indexOf(raw);
        if (first === -1) {
          return addIfString(labels, raw, index, addedLabels);
        }
        const last = labels.lastIndexOf(raw);
        return first !== last ? index : first;
      }
      const validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
      class CategoryScale extends Scale {
        constructor(cfg) {
          super(cfg);
          this._startValue = undefined;
          this._valueRange = 0;
          this._addedLabels = [];
        }
        init(scaleOptions) {
          const added = this._addedLabels;
          if (added.length) {
            const labels = this.getLabels();
            for (const {index, label} of added) {
              if (labels[index] === label) {
                labels.splice(index, 1);
              }
            }
            this._addedLabels = [];
          }
          super.init(scaleOptions);
        }
        parse(raw, index) {
          if (isNullOrUndef(raw)) {
            return null;
          }
          const labels = this.getLabels();
          index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
          return validIndex(index, labels.length - 1);
        }
        determineDataLimits() {
          const {minDefined, maxDefined} = this.getUserBounds();
          let {min, max} = this.getMinMax(true);
          if (this.options.bounds === "ticks") {
            if (!minDefined) {
              min = 0;
            }
            if (!maxDefined) {
              max = this.getLabels().length - 1;
            }
          }
          this.min = min;
          this.max = max;
        }
        buildTicks() {
          const min = this.min;
          const max = this.max;
          const offset = this.options.offset;
          const ticks = [];
          let labels = this.getLabels();
          labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
          this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
          this._startValue = this.min - (offset ? 0.5 : 0);
          for (let value = min; value <= max; value++) {
            ticks.push({ value });
          }
          return ticks;
        }
        getLabelForValue(value) {
          const labels = this.getLabels();
          if (value >= 0 && value < labels.length) {
            return labels[value];
          }
          return value;
        }
        configure() {
          super.configure();
          if (!this.isHorizontal()) {
            this._reversePixels = !this._reversePixels;
          }
        }
        getPixelForValue(value) {
          if (typeof value !== "number") {
            value = this.parse(value);
          }
          return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
        }
        getPixelForTick(index) {
          const ticks = this.ticks;
          if (index < 0 || index > ticks.length - 1) {
            return null;
          }
          return this.getPixelForValue(ticks[index].value);
        }
        getValueForPixel(pixel) {
          return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
        }
        getBasePixel() {
          return this.bottom;
        }
      }
      CategoryScale.id = "category";
      CategoryScale.defaults = { ticks: { callback: CategoryScale.prototype.getLabelForValue } };
      function generateTicks$1(generationOptions, dataRange) {
        const ticks = [];
        const MIN_SPACING = 1e-14;
        const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;
        const unit = step || 1;
        const maxSpaces = maxTicks - 1;
        const {
          min: rmin,
          max: rmax
        } = dataRange;
        const minDefined = !isNullOrUndef(min);
        const maxDefined = !isNullOrUndef(max);
        const countDefined = !isNullOrUndef(count);
        const minSpacing = (rmax - rmin) / (maxDigits + 1);
        let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
        let factor, niceMin, niceMax, numSpaces;
        if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
          return [
            { value: rmin },
            { value: rmax }
          ];
        }
        numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
        if (numSpaces > maxSpaces) {
          spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
        }
        if (!isNullOrUndef(precision)) {
          factor = Math.pow(10, precision);
          spacing = Math.ceil(spacing * factor) / factor;
        }
        if (bounds === "ticks") {
          niceMin = Math.floor(rmin / spacing) * spacing;
          niceMax = Math.ceil(rmax / spacing) * spacing;
        } else {
          niceMin = rmin;
          niceMax = rmax;
        }
        if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {
          numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
          spacing = (max - min) / numSpaces;
          niceMin = min;
          niceMax = max;
        } else if (countDefined) {
          niceMin = minDefined ? min : niceMin;
          niceMax = maxDefined ? max : niceMax;
          numSpaces = count - 1;
          spacing = (niceMax - niceMin) / numSpaces;
        } else {
          numSpaces = (niceMax - niceMin) / spacing;
          if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
            numSpaces = Math.round(numSpaces);
          } else {
            numSpaces = Math.ceil(numSpaces);
          }
        }
        const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
        factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
        niceMin = Math.round(niceMin * factor) / factor;
        niceMax = Math.round(niceMax * factor) / factor;
        let j = 0;
        if (minDefined) {
          if (includeBounds && niceMin !== min) {
            ticks.push({ value: min });
            if (niceMin < min) {
              j++;
            }
            if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
              j++;
            }
          } else if (niceMin < min) {
            j++;
          }
        }
        for (; j < numSpaces; ++j) {
          ticks.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
        }
        if (maxDefined && includeBounds && niceMax !== max) {
          if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
            ticks[ticks.length - 1].value = max;
          } else {
            ticks.push({ value: max });
          }
        } else if (!maxDefined || niceMax === max) {
          ticks.push({ value: niceMax });
        }
        return ticks;
      }
      function relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {
        const rad = toRadians(minRotation);
        const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
        const length = 0.75 * minSpacing * ("" + value).length;
        return Math.min(minSpacing / ratio, length);
      }
      class LinearScaleBase extends Scale {
        constructor(cfg) {
          super(cfg);
          this.start = undefined;
          this.end = undefined;
          this._startValue = undefined;
          this._endValue = undefined;
          this._valueRange = 0;
        }
        parse(raw, index) {
          if (isNullOrUndef(raw)) {
            return null;
          }
          if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
            return null;
          }
          return +raw;
        }
        handleTickRangeOptions() {
          const {beginAtZero} = this.options;
          const {minDefined, maxDefined} = this.getUserBounds();
          let {min, max} = this;
          const setMin = v => min = minDefined ? min : v;
          const setMax = v => max = maxDefined ? max : v;
          if (beginAtZero) {
            const minSign = sign(min);
            const maxSign = sign(max);
            if (minSign < 0 && maxSign < 0) {
              setMax(0);
            } else if (minSign > 0 && maxSign > 0) {
              setMin(0);
            }
          }
          if (min === max) {
            let offset = 1;
            if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
              offset = Math.abs(max * 0.05);
            }
            setMax(max + offset);
            if (!beginAtZero) {
              setMin(min - offset);
            }
          }
          this.min = min;
          this.max = max;
        }
        getTickLimit() {
          const tickOpts = this.options.ticks;
          let {maxTicksLimit, stepSize} = tickOpts;
          let maxTicks;
          if (stepSize) {
            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
            if (maxTicks > 1000) {
              console.warn(`scales.${ this.id }.ticks.stepSize: ${ stepSize } would result generating up to ${ maxTicks } ticks. Limiting to 1000.`);
              maxTicks = 1000;
            }
          } else {
            maxTicks = this.computeTickLimit();
            maxTicksLimit = maxTicksLimit || 11;
          }
          if (maxTicksLimit) {
            maxTicks = Math.min(maxTicksLimit, maxTicks);
          }
          return maxTicks;
        }
        computeTickLimit() {
          return Number.POSITIVE_INFINITY;
        }
        buildTicks() {
          const opts = this.options;
          const tickOpts = opts.ticks;
          let maxTicks = this.getTickLimit();
          maxTicks = Math.max(2, maxTicks);
          const numericGeneratorOptions = {
            maxTicks,
            bounds: opts.bounds,
            min: opts.min,
            max: opts.max,
            precision: tickOpts.precision,
            step: tickOpts.stepSize,
            count: tickOpts.count,
            maxDigits: this._maxDigits(),
            horizontal: this.isHorizontal(),
            minRotation: tickOpts.minRotation || 0,
            includeBounds: tickOpts.includeBounds !== false
          };
          const dataRange = this._range || this;
          const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
          if (opts.bounds === "ticks") {
            _setMinAndMaxByKey(ticks, this, "value");
          }
          if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
          } else {
            this.start = this.min;
            this.end = this.max;
          }
          return ticks;
        }
        configure() {
          const ticks = this.ticks;
          let start = this.min;
          let end = this.max;
          super.configure();
          if (this.options.offset && ticks.length) {
            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
            start -= offset;
            end += offset;
          }
          this._startValue = start;
          this._endValue = end;
          this._valueRange = end - start;
        }
        getLabelForValue(value) {
          return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
        }
      }
      class LinearScale extends LinearScaleBase {
        determineDataLimits() {
          const {min, max} = this.getMinMax(true);
          this.min = isNumberFinite(min) ? min : 0;
          this.max = isNumberFinite(max) ? max : 1;
          this.handleTickRangeOptions();
        }
        computeTickLimit() {
          const horizontal = this.isHorizontal();
          const length = horizontal ? this.width : this.height;
          const minRotation = toRadians(this.options.ticks.minRotation);
          const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
          const tickFont = this._resolveTickFontOptions(0);
          return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
        }
        getPixelForValue(value) {
          return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
        }
        getValueForPixel(pixel) {
          return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
        }
      }
      LinearScale.id = "linear";
      LinearScale.defaults = { ticks: { callback: Ticks.formatters.numeric } };
      function isMajor(tickVal) {
        const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
        return remain === 1;
      }
      function generateTicks(generationOptions, dataRange) {
        const endExp = Math.floor(log10(dataRange.max));
        const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
        const ticks = [];
        let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
        let exp = Math.floor(log10(tickVal));
        let significand = Math.floor(tickVal / Math.pow(10, exp));
        let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
        do {
          ticks.push({
            value: tickVal,
            major: isMajor(tickVal)
          });
          ++significand;
          if (significand === 10) {
            significand = 1;
            ++exp;
            precision = exp >= 0 ? 1 : precision;
          }
          tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
        } while (exp < endExp || exp === endExp && significand < endSignificand);
        const lastTick = finiteOrDefault(generationOptions.max, tickVal);
        ticks.push({
          value: lastTick,
          major: isMajor(tickVal)
        });
        return ticks;
      }
      class LogarithmicScale extends Scale {
        constructor(cfg) {
          super(cfg);
          this.start = undefined;
          this.end = undefined;
          this._startValue = undefined;
          this._valueRange = 0;
        }
        parse(raw, index) {
          const value = LinearScaleBase.prototype.parse.apply(this, [
            raw,
            index
          ]);
          if (value === 0) {
            this._zero = true;
            return undefined;
          }
          return isNumberFinite(value) && value > 0 ? value : null;
        }
        determineDataLimits() {
          const {min, max} = this.getMinMax(true);
          this.min = isNumberFinite(min) ? Math.max(0, min) : null;
          this.max = isNumberFinite(max) ? Math.max(0, max) : null;
          if (this.options.beginAtZero) {
            this._zero = true;
          }
          this.handleTickRangeOptions();
        }
        handleTickRangeOptions() {
          const {minDefined, maxDefined} = this.getUserBounds();
          let min = this.min;
          let max = this.max;
          const setMin = v => min = minDefined ? min : v;
          const setMax = v => max = maxDefined ? max : v;
          const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
          if (min === max) {
            if (min <= 0) {
              setMin(1);
              setMax(10);
            } else {
              setMin(exp(min, -1));
              setMax(exp(max, +1));
            }
          }
          if (min <= 0) {
            setMin(exp(max, -1));
          }
          if (max <= 0) {
            setMax(exp(min, +1));
          }
          if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
            setMin(exp(min, -1));
          }
          this.min = min;
          this.max = max;
        }
        buildTicks() {
          const opts = this.options;
          const generationOptions = {
            min: this._userMin,
            max: this._userMax
          };
          const ticks = generateTicks(generationOptions, this);
          if (opts.bounds === "ticks") {
            _setMinAndMaxByKey(ticks, this, "value");
          }
          if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
          } else {
            this.start = this.min;
            this.end = this.max;
          }
          return ticks;
        }
        getLabelForValue(value) {
          return value === undefined ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
        }
        configure() {
          const start = this.min;
          super.configure();
          this._startValue = log10(start);
          this._valueRange = log10(this.max) - log10(start);
        }
        getPixelForValue(value) {
          if (value === undefined || value === 0) {
            value = this.min;
          }
          if (value === null || isNaN(value)) {
            return NaN;
          }
          return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
        }
        getValueForPixel(pixel) {
          const decimal = this.getDecimalForPixel(pixel);
          return Math.pow(10, this._startValue + decimal * this._valueRange);
        }
      }
      LogarithmicScale.id = "logarithmic";
      LogarithmicScale.defaults = {
        ticks: {
          callback: Ticks.formatters.logarithmic,
          major: { enabled: true }
        }
      };
      function getTickBackdropHeight(opts) {
        const tickOpts = opts.ticks;
        if (tickOpts.display && opts.display) {
          const padding = toPadding(tickOpts.backdropPadding);
          return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
        }
        return 0;
      }
      function measureLabelSize(ctx, font, label) {
        label = isArray(label) ? label : [label];
        return {
          w: _longestText(ctx, font.string, label),
          h: label.length * font.lineHeight
        };
      }
      function determineLimits(angle, pos, size, min, max) {
        if (angle === min || angle === max) {
          return {
            start: pos - size / 2,
            end: pos + size / 2
          };
        } else if (angle < min || angle > max) {
          return {
            start: pos - size,
            end: pos
          };
        }
        return {
          start: pos,
          end: pos + size
        };
      }
      function fitWithPointLabels(scale) {
        const orig = {
          l: scale.left + scale._padding.left,
          r: scale.right - scale._padding.right,
          t: scale.top + scale._padding.top,
          b: scale.bottom - scale._padding.bottom
        };
        const limits = Object.assign({}, orig);
        const labelSizes = [];
        const padding = [];
        const valueCount = scale._pointLabels.length;
        const pointLabelOpts = scale.options.pointLabels;
        const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
        for (let i = 0; i < valueCount; i++) {
          const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
          padding[i] = opts.padding;
          const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
          const plFont = toFont(opts.font);
          const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
          labelSizes[i] = textSize;
          const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
          const angle = Math.round(toDegrees(angleRadians));
          const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
          const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
          updateLimits(limits, orig, angleRadians, hLimits, vLimits);
        }
        scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
        scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
      }
      function updateLimits(limits, orig, angle, hLimits, vLimits) {
        const sin = Math.abs(Math.sin(angle));
        const cos = Math.abs(Math.cos(angle));
        let x = 0;
        let y = 0;
        if (hLimits.start < orig.l) {
          x = (orig.l - hLimits.start) / sin;
          limits.l = Math.min(limits.l, orig.l - x);
        } else if (hLimits.end > orig.r) {
          x = (hLimits.end - orig.r) / sin;
          limits.r = Math.max(limits.r, orig.r + x);
        }
        if (vLimits.start < orig.t) {
          y = (orig.t - vLimits.start) / cos;
          limits.t = Math.min(limits.t, orig.t - y);
        } else if (vLimits.end > orig.b) {
          y = (vLimits.end - orig.b) / cos;
          limits.b = Math.max(limits.b, orig.b + y);
        }
      }
      function buildPointLabelItems(scale, labelSizes, padding) {
        const items = [];
        const valueCount = scale._pointLabels.length;
        const opts = scale.options;
        const extra = getTickBackdropHeight(opts) / 2;
        const outerDistance = scale.drawingArea;
        const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
        for (let i = 0; i < valueCount; i++) {
          const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
          const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
          const size = labelSizes[i];
          const y = yForAngle(pointLabelPosition.y, size.h, angle);
          const textAlign = getTextAlignForAngle(angle);
          const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
          items.push({
            x: pointLabelPosition.x,
            y,
            textAlign,
            left,
            top: y,
            right: left + size.w,
            bottom: y + size.h
          });
        }
        return items;
      }
      function getTextAlignForAngle(angle) {
        if (angle === 0 || angle === 180) {
          return "center";
        } else if (angle < 180) {
          return "left";
        }
        return "right";
      }
      function leftForTextAlign(x, w, align) {
        if (align === "right") {
          x -= w;
        } else if (align === "center") {
          x -= w / 2;
        }
        return x;
      }
      function yForAngle(y, h, angle) {
        if (angle === 90 || angle === 270) {
          y -= h / 2;
        } else if (angle > 270 || angle < 90) {
          y -= h;
        }
        return y;
      }
      function drawPointLabels(scale, labelCount) {
        const {
          ctx,
          options: {pointLabels}
        } = scale;
        for (let i = labelCount - 1; i >= 0; i--) {
          const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
          const plFont = toFont(optsAtIndex.font);
          const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];
          const {backdropColor} = optsAtIndex;
          if (!isNullOrUndef(backdropColor)) {
            const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
            const padding = toPadding(optsAtIndex.backdropPadding);
            ctx.fillStyle = backdropColor;
            const backdropLeft = left - padding.left;
            const backdropTop = top - padding.top;
            const backdropWidth = right - left + padding.width;
            const backdropHeight = bottom - top + padding.height;
            if (Object.values(borderRadius).some(v => v !== 0)) {
              ctx.beginPath();
              addRoundedRectPath(ctx, {
                x: backdropLeft,
                y: backdropTop,
                w: backdropWidth,
                h: backdropHeight,
                radius: borderRadius
              });
              ctx.fill();
            } else {
              ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
            }
          }
          renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
            color: optsAtIndex.color,
            textAlign: textAlign,
            textBaseline: "middle"
          });
        }
      }
      function pathRadiusLine(scale, radius, circular, labelCount) {
        const {ctx} = scale;
        if (circular) {
          ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
        } else {
          let pointPosition = scale.getPointPosition(0, radius);
          ctx.moveTo(pointPosition.x, pointPosition.y);
          for (let i = 1; i < labelCount; i++) {
            pointPosition = scale.getPointPosition(i, radius);
            ctx.lineTo(pointPosition.x, pointPosition.y);
          }
        }
      }
      function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
        const ctx = scale.ctx;
        const circular = gridLineOpts.circular;
        const {color, lineWidth} = gridLineOpts;
        if (!circular && !labelCount || !color || !lineWidth || radius < 0) {
          return;
        }
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        ctx.setLineDash(gridLineOpts.borderDash);
        ctx.lineDashOffset = gridLineOpts.borderDashOffset;
        ctx.beginPath();
        pathRadiusLine(scale, radius, circular, labelCount);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }
      function createPointLabelContext(parent, index, label) {
        return createContext(parent, {
          label,
          index,
          type: "pointLabel"
        });
      }
      class RadialLinearScale extends LinearScaleBase {
        constructor(cfg) {
          super(cfg);
          this.xCenter = undefined;
          this.yCenter = undefined;
          this.drawingArea = undefined;
          this._pointLabels = [];
          this._pointLabelItems = [];
        }
        setDimensions() {
          const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
          const w = this.width = this.maxWidth - padding.width;
          const h = this.height = this.maxHeight - padding.height;
          this.xCenter = Math.floor(this.left + w / 2 + padding.left);
          this.yCenter = Math.floor(this.top + h / 2 + padding.top);
          this.drawingArea = Math.floor(Math.min(w, h) / 2);
        }
        determineDataLimits() {
          const {min, max} = this.getMinMax(false);
          this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
          this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
          this.handleTickRangeOptions();
        }
        computeTickLimit() {
          return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
        }
        generateTickLabels(ticks) {
          LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
          this._pointLabels = this.getLabels().map((value, index) => {
            const label = callback(this.options.pointLabels.callback, [
              value,
              index
            ], this);
            return label || label === 0 ? label : "";
          }).filter((v, i) => this.chart.getDataVisibility(i));
        }
        fit() {
          const opts = this.options;
          if (opts.display && opts.pointLabels.display) {
            fitWithPointLabels(this);
          } else {
            this.setCenterPoint(0, 0, 0, 0);
          }
        }
        setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
          this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
          this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
          this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
        }
        getIndexAngle(index) {
          const angleMultiplier = TAU / (this._pointLabels.length || 1);
          const startAngle = this.options.startAngle || 0;
          return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
        }
        getDistanceFromCenterForValue(value) {
          if (isNullOrUndef(value)) {
            return NaN;
          }
          const scalingFactor = this.drawingArea / (this.max - this.min);
          if (this.options.reverse) {
            return (this.max - value) * scalingFactor;
          }
          return (value - this.min) * scalingFactor;
        }
        getValueForDistanceFromCenter(distance) {
          if (isNullOrUndef(distance)) {
            return NaN;
          }
          const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
          return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
        }
        getPointLabelContext(index) {
          const pointLabels = this._pointLabels || [];
          if (index >= 0 && index < pointLabels.length) {
            const pointLabel = pointLabels[index];
            return createPointLabelContext(this.getContext(), index, pointLabel);
          }
        }
        getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
          const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
          return {
            x: Math.cos(angle) * distanceFromCenter + this.xCenter,
            y: Math.sin(angle) * distanceFromCenter + this.yCenter,
            angle
          };
        }
        getPointPositionForValue(index, value) {
          return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
        }
        getBasePosition(index) {
          return this.getPointPositionForValue(index || 0, this.getBaseValue());
        }
        getPointLabelPosition(index) {
          const {left, top, right, bottom} = this._pointLabelItems[index];
          return {
            left,
            top,
            right,
            bottom
          };
        }
        drawBackground() {
          const {
            backgroundColor,
            grid: {circular}
          } = this.options;
          if (backgroundColor) {
            const ctx = this.ctx;
            ctx.save();
            ctx.beginPath();
            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
            ctx.closePath();
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
          }
        }
        drawGrid() {
          const ctx = this.ctx;
          const opts = this.options;
          const {angleLines, grid} = opts;
          const labelCount = this._pointLabels.length;
          let i, offset, position;
          if (opts.pointLabels.display) {
            drawPointLabels(this, labelCount);
          }
          if (grid.display) {
            this.ticks.forEach((tick, index) => {
              if (index !== 0) {
                offset = this.getDistanceFromCenterForValue(tick.value);
                const optsAtIndex = grid.setContext(this.getContext(index - 1));
                drawRadiusLine(this, optsAtIndex, offset, labelCount);
              }
            });
          }
          if (angleLines.display) {
            ctx.save();
            for (i = labelCount - 1; i >= 0; i--) {
              const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
              const {color, lineWidth} = optsAtIndex;
              if (!lineWidth || !color) {
                continue;
              }
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = color;
              ctx.setLineDash(optsAtIndex.borderDash);
              ctx.lineDashOffset = optsAtIndex.borderDashOffset;
              offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
              position = this.getPointPosition(i, offset);
              ctx.beginPath();
              ctx.moveTo(this.xCenter, this.yCenter);
              ctx.lineTo(position.x, position.y);
              ctx.stroke();
            }
            ctx.restore();
          }
        }
        drawBorder() {
        }
        drawLabels() {
          const ctx = this.ctx;
          const opts = this.options;
          const tickOpts = opts.ticks;
          if (!tickOpts.display) {
            return;
          }
          const startAngle = this.getIndexAngle(0);
          let offset, width;
          ctx.save();
          ctx.translate(this.xCenter, this.yCenter);
          ctx.rotate(startAngle);
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          this.ticks.forEach((tick, index) => {
            if (index === 0 && !opts.reverse) {
              return;
            }
            const optsAtIndex = tickOpts.setContext(this.getContext(index));
            const tickFont = toFont(optsAtIndex.font);
            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
            if (optsAtIndex.showLabelBackdrop) {
              ctx.font = tickFont.string;
              width = ctx.measureText(tick.label).width;
              ctx.fillStyle = optsAtIndex.backdropColor;
              const padding = toPadding(optsAtIndex.backdropPadding);
              ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
            }
            renderText(ctx, tick.label, 0, -offset, tickFont, { color: optsAtIndex.color });
          });
          ctx.restore();
        }
        drawTitle() {
        }
      }
      RadialLinearScale.id = "radialLinear";
      RadialLinearScale.defaults = {
        display: true,
        animate: true,
        position: "chartArea",
        angleLines: {
          display: true,
          lineWidth: 1,
          borderDash: [],
          borderDashOffset: 0
        },
        grid: { circular: false },
        startAngle: 0,
        ticks: {
          showLabelBackdrop: true,
          callback: Ticks.formatters.numeric
        },
        pointLabels: {
          backdropColor: undefined,
          backdropPadding: 2,
          display: true,
          font: { size: 10 },
          callback(label) {
            return label;
          },
          padding: 5,
          centerPointLabels: false
        }
      };
      RadialLinearScale.defaultRoutes = {
        "angleLines.color": "borderColor",
        "pointLabels.color": "color",
        "ticks.color": "color"
      };
      RadialLinearScale.descriptors = { angleLines: { _fallback: "grid" } };
      const INTERVALS = {
        millisecond: {
          common: true,
          size: 1,
          steps: 1000
        },
        second: {
          common: true,
          size: 1000,
          steps: 60
        },
        minute: {
          common: true,
          size: 60000,
          steps: 60
        },
        hour: {
          common: true,
          size: 3600000,
          steps: 24
        },
        day: {
          common: true,
          size: 86400000,
          steps: 30
        },
        week: {
          common: false,
          size: 604800000,
          steps: 4
        },
        month: {
          common: true,
          size: 2628000000,
          steps: 12
        },
        quarter: {
          common: false,
          size: 7884000000,
          steps: 4
        },
        year: {
          common: true,
          size: 31540000000
        }
      };
      const UNITS = Object.keys(INTERVALS);
      function sorter(a, b) {
        return a - b;
      }
      function parse(scale, input) {
        if (isNullOrUndef(input)) {
          return null;
        }
        const adapter = scale._adapter;
        const {parser, round, isoWeekday} = scale._parseOpts;
        let value = input;
        if (typeof parser === "function") {
          value = parser(value);
        }
        if (!isNumberFinite(value)) {
          value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
        }
        if (value === null) {
          return null;
        }
        if (round) {
          value = round === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round);
        }
        return +value;
      }
      function determineUnitForAutoTicks(minUnit, min, max, capacity) {
        const ilen = UNITS.length;
        for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
          const interval = INTERVALS[UNITS[i]];
          const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
          if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
            return UNITS[i];
          }
        }
        return UNITS[ilen - 1];
      }
      function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
        for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
          const unit = UNITS[i];
          if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
            return unit;
          }
        }
        return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
      }
      function determineMajorUnit(unit) {
        for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
          if (INTERVALS[UNITS[i]].common) {
            return UNITS[i];
          }
        }
      }
      function addTick(ticks, time, timestamps) {
        if (!timestamps) {
          ticks[time] = true;
        } else if (timestamps.length) {
          const {lo, hi} = _lookup(timestamps, time);
          const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
          ticks[timestamp] = true;
        }
      }
      function setMajorTicks(scale, ticks, map, majorUnit) {
        const adapter = scale._adapter;
        const first = +adapter.startOf(ticks[0].value, majorUnit);
        const last = ticks[ticks.length - 1].value;
        let major, index;
        for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
          index = map[major];
          if (index >= 0) {
            ticks[index].major = true;
          }
        }
        return ticks;
      }
      function ticksFromTimestamps(scale, values, majorUnit) {
        const ticks = [];
        const map = {};
        const ilen = values.length;
        let i, value;
        for (i = 0; i < ilen; ++i) {
          value = values[i];
          map[value] = i;
          ticks.push({
            value,
            major: false
          });
        }
        return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
      }
      class TimeScale extends Scale {
        constructor(props) {
          super(props);
          this._cache = {
            data: [],
            labels: [],
            all: []
          };
          this._unit = "day";
          this._majorUnit = undefined;
          this._offsets = {};
          this._normalized = false;
          this._parseOpts = undefined;
        }
        init(scaleOpts, opts) {
          const time = scaleOpts.time || (scaleOpts.time = {});
          const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
          adapter.init(opts);
          mergeIf(time.displayFormats, adapter.formats());
          this._parseOpts = {
            parser: time.parser,
            round: time.round,
            isoWeekday: time.isoWeekday
          };
          super.init(scaleOpts);
          this._normalized = opts.normalized;
        }
        parse(raw, index) {
          if (raw === undefined) {
            return null;
          }
          return parse(this, raw);
        }
        beforeLayout() {
          super.beforeLayout();
          this._cache = {
            data: [],
            labels: [],
            all: []
          };
        }
        determineDataLimits() {
          const options = this.options;
          const adapter = this._adapter;
          const unit = options.time.unit || "day";
          let {min, max, minDefined, maxDefined} = this.getUserBounds();
          function _applyBounds(bounds) {
            if (!minDefined && !isNaN(bounds.min)) {
              min = Math.min(min, bounds.min);
            }
            if (!maxDefined && !isNaN(bounds.max)) {
              max = Math.max(max, bounds.max);
            }
          }
          if (!minDefined || !maxDefined) {
            _applyBounds(this._getLabelBounds());
            if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
              _applyBounds(this.getMinMax(false));
            }
          }
          min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
          max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
          this.min = Math.min(min, max - 1);
          this.max = Math.max(min + 1, max);
        }
        _getLabelBounds() {
          const arr = this.getLabelTimestamps();
          let min = Number.POSITIVE_INFINITY;
          let max = Number.NEGATIVE_INFINITY;
          if (arr.length) {
            min = arr[0];
            max = arr[arr.length - 1];
          }
          return {
            min,
            max
          };
        }
        buildTicks() {
          const options = this.options;
          const timeOpts = options.time;
          const tickOpts = options.ticks;
          const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
          if (options.bounds === "ticks" && timestamps.length) {
            this.min = this._userMin || timestamps[0];
            this.max = this._userMax || timestamps[timestamps.length - 1];
          }
          const min = this.min;
          const max = this.max;
          const ticks = _filterBetween(timestamps, min, max);
          this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
          this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? undefined : determineMajorUnit(this._unit);
          this.initOffsets(timestamps);
          if (options.reverse) {
            ticks.reverse();
          }
          return ticksFromTimestamps(this, ticks, this._majorUnit);
        }
        afterAutoSkip() {
          if (this.options.offsetAfterAutoskip) {
            this.initOffsets(this.ticks.map(tick => +tick.value));
          }
        }
        initOffsets(timestamps) {
          let start = 0;
          let end = 0;
          let first, last;
          if (this.options.offset && timestamps.length) {
            first = this.getDecimalForValue(timestamps[0]);
            if (timestamps.length === 1) {
              start = 1 - first;
            } else {
              start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
            }
            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
            if (timestamps.length === 1) {
              end = last;
            } else {
              end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
            }
          }
          const limit = timestamps.length < 3 ? 0.5 : 0.25;
          start = _limitValue(start, 0, limit);
          end = _limitValue(end, 0, limit);
          this._offsets = {
            start,
            end,
            factor: 1 / (start + 1 + end)
          };
        }
        _generate() {
          const adapter = this._adapter;
          const min = this.min;
          const max = this.max;
          const options = this.options;
          const timeOpts = options.time;
          const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
          const stepSize = valueOrDefault(timeOpts.stepSize, 1);
          const weekday = minor === "week" ? timeOpts.isoWeekday : false;
          const hasWeekday = isNumber(weekday) || weekday === true;
          const ticks = {};
          let first = min;
          let time, count;
          if (hasWeekday) {
            first = +adapter.startOf(first, "isoWeek", weekday);
          }
          first = +adapter.startOf(first, hasWeekday ? "day" : minor);
          if (adapter.diff(max, min, minor) > 100000 * stepSize) {
            throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
          }
          const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
          for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
            addTick(ticks, time, timestamps);
          }
          if (time === max || options.bounds === "ticks" || count === 1) {
            addTick(ticks, time, timestamps);
          }
          return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);
        }
        getLabelForValue(value) {
          const adapter = this._adapter;
          const timeOpts = this.options.time;
          if (timeOpts.tooltipFormat) {
            return adapter.format(value, timeOpts.tooltipFormat);
          }
          return adapter.format(value, timeOpts.displayFormats.datetime);
        }
        _tickFormatFunction(time, index, ticks, format) {
          const options = this.options;
          const formats = options.time.displayFormats;
          const unit = this._unit;
          const majorUnit = this._majorUnit;
          const minorFormat = unit && formats[unit];
          const majorFormat = majorUnit && formats[majorUnit];
          const tick = ticks[index];
          const major = majorUnit && majorFormat && tick && tick.major;
          const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
          const formatter = options.ticks.callback;
          return formatter ? callback(formatter, [
            label,
            index,
            ticks
          ], this) : label;
        }
        generateTickLabels(ticks) {
          let i, ilen, tick;
          for (i = 0, ilen = ticks.length; i < ilen; ++i) {
            tick = ticks[i];
            tick.label = this._tickFormatFunction(tick.value, i, ticks);
          }
        }
        getDecimalForValue(value) {
          return value === null ? NaN : (value - this.min) / (this.max - this.min);
        }
        getPixelForValue(value) {
          const offsets = this._offsets;
          const pos = this.getDecimalForValue(value);
          return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
        }
        getValueForPixel(pixel) {
          const offsets = this._offsets;
          const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
          return this.min + pos * (this.max - this.min);
        }
        _getLabelSize(label) {
          const ticksOpts = this.options.ticks;
          const tickLabelWidth = this.ctx.measureText(label).width;
          const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
          const cosRotation = Math.cos(angle);
          const sinRotation = Math.sin(angle);
          const tickFontSize = this._resolveTickFontOptions(0).size;
          return {
            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
          };
        }
        _getLabelCapacity(exampleTime) {
          const timeOpts = this.options.time;
          const displayFormats = timeOpts.displayFormats;
          const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
          const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
          const size = this._getLabelSize(exampleLabel);
          const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
          return capacity > 0 ? capacity : 1;
        }
        getDataTimestamps() {
          let timestamps = this._cache.data || [];
          let i, ilen;
          if (timestamps.length) {
            return timestamps;
          }
          const metas = this.getMatchingVisibleMetas();
          if (this._normalized && metas.length) {
            return this._cache.data = metas[0].controller.getAllParsedValues(this);
          }
          for (i = 0, ilen = metas.length; i < ilen; ++i) {
            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
          }
          return this._cache.data = this.normalize(timestamps);
        }
        getLabelTimestamps() {
          const timestamps = this._cache.labels || [];
          let i, ilen;
          if (timestamps.length) {
            return timestamps;
          }
          const labels = this.getLabels();
          for (i = 0, ilen = labels.length; i < ilen; ++i) {
            timestamps.push(parse(this, labels[i]));
          }
          return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
        }
        normalize(values) {
          return _arrayUnique(values.sort(sorter));
        }
      }
      TimeScale.id = "time";
      TimeScale.defaults = {
        bounds: "data",
        adapters: {},
        time: {
          parser: false,
          unit: false,
          round: false,
          isoWeekday: false,
          minUnit: "millisecond",
          displayFormats: {}
        },
        ticks: {
          source: "auto",
          major: { enabled: false }
        }
      };
      function interpolate(table, val, reverse) {
        let lo = 0;
        let hi = table.length - 1;
        let prevSource, nextSource, prevTarget, nextTarget;
        if (reverse) {
          if (val >= table[lo].pos && val <= table[hi].pos) {
            ({lo, hi} = _lookupByKey(table, "pos", val));
          }
          ({
            pos: prevSource,
            time: prevTarget
          } = table[lo]);
          ({
            pos: nextSource,
            time: nextTarget
          } = table[hi]);
        } else {
          if (val >= table[lo].time && val <= table[hi].time) {
            ({lo, hi} = _lookupByKey(table, "time", val));
          }
          ({
            time: prevSource,
            pos: prevTarget
          } = table[lo]);
          ({
            time: nextSource,
            pos: nextTarget
          } = table[hi]);
        }
        const span = nextSource - prevSource;
        return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
      }
      class TimeSeriesScale extends TimeScale {
        constructor(props) {
          super(props);
          this._table = [];
          this._minPos = undefined;
          this._tableRange = undefined;
        }
        initOffsets() {
          const timestamps = this._getTimestampsForTable();
          const table = this._table = this.buildLookupTable(timestamps);
          this._minPos = interpolate(table, this.min);
          this._tableRange = interpolate(table, this.max) - this._minPos;
          super.initOffsets(timestamps);
        }
        buildLookupTable(timestamps) {
          const {min, max} = this;
          const items = [];
          const table = [];
          let i, ilen, prev, curr, next;
          for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
            curr = timestamps[i];
            if (curr >= min && curr <= max) {
              items.push(curr);
            }
          }
          if (items.length < 2) {
            return [
              {
                time: min,
                pos: 0
              },
              {
                time: max,
                pos: 1
              }
            ];
          }
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            next = items[i + 1];
            prev = items[i - 1];
            curr = items[i];
            if (Math.round((next + prev) / 2) !== curr) {
              table.push({
                time: curr,
                pos: i / (ilen - 1)
              });
            }
          }
          return table;
        }
        _getTimestampsForTable() {
          let timestamps = this._cache.all || [];
          if (timestamps.length) {
            return timestamps;
          }
          const data = this.getDataTimestamps();
          const label = this.getLabelTimestamps();
          if (data.length && label.length) {
            timestamps = this.normalize(data.concat(label));
          } else {
            timestamps = data.length ? data : label;
          }
          timestamps = this._cache.all = timestamps;
          return timestamps;
        }
        getDecimalForValue(value) {
          return (interpolate(this._table, value) - this._minPos) / this._tableRange;
        }
        getValueForPixel(pixel) {
          const offsets = this._offsets;
          const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
          return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
        }
      }
      TimeSeriesScale.id = "timeseries";
      TimeSeriesScale.defaults = TimeScale.defaults;
      var scales = Object.freeze({
        __proto__: null,
        CategoryScale: CategoryScale,
        LinearScale: LinearScale,
        LogarithmicScale: LogarithmicScale,
        RadialLinearScale: RadialLinearScale,
        TimeScale: TimeScale,
        TimeSeriesScale: TimeSeriesScale
      });
      const registerables = [
        controllers,
        elements,
        plugins,
        scales
      ];

      var __varRecorder__$o = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/controls/fill.cp.js", __contextModule__);
      __varRecorder__$o.placeholderImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAbZJREFUaEPtmT0vBUEUhp/rIyJBJKKQaCQahUKjpVFoFEqVSBCtPyD+gFZC4Rf4bBX+gMRnr6KhIxEhIScZyWays8a9O7M7nCnvvTvnfc77nrnZ3QaJr0bi+lGAqh1UB+ruQC8wA4wAPZHFvgB3wCnw7KpdFCERvwZ0RxZul3sFtl0QRQDzwHjF4r/L3wAHeVqKANYBcaEOSyK09VuADeuCzcgkXvWLHPDaICCUV30FUAfcHdAIeXVAI6QRarEDGqEWG6h/ZP8xQl3Amwe41zEeO0JjwDSwC3z8AFE7gAFgGRAHLoCTOgEMAW3AvUNUpxE/mPn+ELgugIjmgNwzrwDtJhp5N+B5t6fvwA7w5ICIAiAztACMGhEPwJ6V70lg1iHy0UALjL2iAMhATlmVb4F989kwsGjccaXlEjiuAkC6Lt3PO8nOgHNgFejzODKPgCvrd0Ed6De5dz0z+jTZzg5tEUfePAQD6ACWADl5ylz2PAQDmAMmylSe2Ss7D8EAAmmv5hQKCaMOeHUgoAVe9f/0w93kH68n/4JD4p30K6aA81ne1vqatbxeNreTOtBc38q7KnkHvgAu0nMxVZqzQwAAAABJRU5ErkJggg==";
      __varRecorder__$o.GalyleoFillControl = component["for"](function () {
        return component(FillControl, {
          name: "galyleo/fill control",
          layout: new TilingLayout({
            axis: "column",
            hugContentsVertically: true,
            orderByIndex: true,
            padding: rect(0, 10, 0, 0),
            resizePolicies: [["h floater", {
              height: "fixed",
              width: "fill"
            }], ["fill color input", {
              height: "fixed",
              width: "fill"
            }]],
            spacing: 10,
            wrapSubmorphs: false
          }),
          visible: true,
          viewModel: {
            placeholderImage: __varRecorder__$o.placeholderImage
          },
          fill: Color$1.transparent,
          submorphs: [{
            name: "h floater",
            submorphs: [{
              name: "section headline",
              fontColor: Color$1.rgb(66, 73, 73)
            }]
          }, {
            name: "fill color input",
            master: GalyleoColorInput,
            viewModel: {
              activeColor: Color$1.gray
            }
          }, {
            name: "image control",
            submorphs: [{
              name: "image marker",
              fontColor: Color$1.rgbHex("424949")
            }, {
              name: "image cell",
              submorphs: [{
                name: "image container",
                imageUrl: __varRecorder__$o.placeholderImage
              }]
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/fill.cp.js",
        "export": "GalyleoFillControl",
        range: {
          start: 1168,
          end: 2269
        }
      }, System, __varRecorder__$o, "GalyleoFillControl");
      var GalyleoFillControl = __varRecorder__$o.GalyleoFillControl;
      __varRecorder__$o.GalyleoFillControl = GalyleoFillControl;

      var __varRecorder__$n = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/chart-creator.cp.js", __contextModule__);
      var ChartBuilderModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/chart-creator.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ChartBuilderModel") && typeof __lively_classholder__.ChartBuilderModel === "function" ? __lively_classholder__.ChartBuilderModel : __lively_classholder__.ChartBuilderModel = function ChartBuilderModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "cancel",
          value: function ChartBuilderModel_cancel_() {
            this.view.remove();
          }
        }, {
          key: "init",
          value: function ChartBuilderModel_init_(dashboard) {
            this.dashboard = dashboard;
            var allNames = dashboard.tableNames.concat(dashboard.viewNames);
            var viewSelector = this.ui.viewSelector;
            viewSelector.items = allNames;
            viewSelector.selection = allNames[0];
            this.updateChartTypeList();
          }
        }, {
          key: "chartTypes",
          get: function get() {
            return [["AreaChart", "BarChart", "ColumnChart", "LineChart", "SteppedAreaChart"], [], ["CalendarChart", "DonutChart", "GaugeChart", "GeoChart", "Histogram", "PieChart", "ScatterChart"], ["BubbleChart", "Interval", "Map", "OrgChart", "SankeyChart", "Timeline"], ["BubbleChart", "Interval", "OrgChart"], ["BubbleChart", "CandlestickChart", "Interval"], ["CandlestickChart", "Interval"], ["Interval"]];
          }
        }, {
          key: "updateChartTypeList",
          value: function ChartBuilderModel_updateChartTypeList_() {}
        }, {
          key: "_checkSelectionOrSignal",
          value: function ChartBuilderModel__checkSelectionOrSignal_(list) {
            if (list.selection && list.selection !== "__no_selection__") {
              return true;
            } else {
              list.toggleError();
              return false;
            }
          }
        }, {
          key: "_checkInputs",
          value: function ChartBuilderModel__checkInputs_() {
            return this._checkSelectionOrSignal(this.ui.viewSelector) && this._nameOK();
          }
        }, {
          key: "_nameOK",
          value: function ChartBuilderModel__nameOK_() {
            var chartNameInput = this.ui.chartNameInput;
            var chosenName = chartNameInput.textString;

            if (!chosenName || chosenName.length === 0) {
              chartNameInput.indicateError("Enter a chart name!");
              return false;
            }

            var names = this.dashboard.chartNames.concat(this.dashboard.filterNames);

            if (names.indexOf(chosenName) >= 0) {
              chartNameInput.indicateError("That name is already in use!");
              return false;
            }

            return true;
          }
        }, {
          key: "chartSpecification",
          get: function get() {
            return {
              chartType: "Table",
              viewOrTable: this.ui.viewSelector.selection,
              options: {
                width: "100%",
                height: "100%"
              }
            };
          }
        }, {
          key: "_maxTableSize",
          get: function get() {
            return 1000;
          }
        }, {
          key: "checkChartInputsAndCreate",
          value: function () {
            var _ChartBuilderModel_checkChartInputsAndCreate_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var table, message, isConfirmed;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (!this._checkInputs()) {
                        _context.next = 11;
                        break;
                      }

                      table = this.dashboard.prepareData(this.chartSpecification.viewOrTable);

                      if (!(table.getNumberOfRows() > this._maxTableSize)) {
                        _context.next = 10;
                        break;
                      }

                      message = "Warning!  This chart will have ".concat(table.getNumberOfRows(), " entries and drawing may be slow.  Click OK to proceed, cancel to cancel chart creation");
                      _context.next = 6;
                      return this.dashboard.confirm(message);

                    case 6:
                      isConfirmed = _context.sent;

                      if (isConfirmed) {
                        this.createChart();
                      } else {
                        this.view.remove();
                      }

                      _context.next = 11;
                      break;

                    case 10:
                      this.createChart();

                    case 11:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function ChartBuilderModel_checkChartInputsAndCreate_() {
              return _ChartBuilderModel_checkChartInputsAndCreate_.apply(this, arguments);
            }

            return ChartBuilderModel_checkChartInputsAndCreate_;
          }()
        }, {
          key: "createChart",
          value: function ChartBuilderModel_createChart_() {
            if (this._checkInputs()) {
              this.dashboard.addChart(this.ui.chartNameInput.textString, this.chartSpecification);
              this.view.remove();
            }
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ChartBuilderModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["init"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "fire",
                    handler: "cancel"
                  }, {
                    target: "create chart button",
                    signal: "fire",
                    handler: "createChart"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/chart-creator.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 1299,
          end: 9420
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$n.ChartBuilderModel = ChartBuilderModel;
      __varRecorder__$n.ChartBuilderModel = ChartBuilderModel;
      __varRecorder__$n.ChartBuilder = component["for"](function () {
        return component(GalyleoWindow, {
          name: "chart builder",
          defaultViewModel: __varRecorder__$n.ChartBuilderModel,
          extent: pt(340.5, 199.9),
          layout: new TilingLayout({
            axis: "column",
            orderByIndex: true,
            resizePolicies: [["window title", {
              height: "fixed",
              width: "fill"
            }], ["content wrapper", {
              height: "fill",
              width: "fill"
            }]],
            wrapSubmorphs: false
          }),
          submorphs: [{
            name: "window title",
            textString: "Chart builder"
          }, add({
            name: "content wrapper",
            extent: pt(321.5, 227.9),
            layout: new TilingLayout({
              axis: "column",
              axisAlign: "right",
              orderByIndex: true,
              padding: rect(10, 5, 0, -5),
              resizePolicies: [["header", {
                height: "fixed",
                width: "fill"
              }], ["chart name input", {
                height: "fixed",
                width: "fill"
              }], ["view selector", {
                height: "fixed",
                width: "fill"
              }]],
              spacing: 10,
              wrapSubmorphs: false
            }),
            fill: Color$1.transparent,
            submorphs: [{
              name: "header",
              extent: pt(384, 10),
              fill: Color$1.rgba(0, 0, 0, 0),
              layout: new TilingLayout({
                align: "right",
                orderByIndex: true,
                wrapSubmorphs: false
              }),
              submorphs: [part(MenuBarButton, {
                tooltip: "Close this dialog without loading",
                name: "close button",
                extent: pt(100, 35),
                submorphs: [{
                  name: "label",
                  textAndAttributes: ["CLOSE", null]
                }, {
                  name: "icon",
                  extent: pt(14, 14),
                  imageUrl: projectAsset("engageLively--galyleo-dashboard__close-button-icon-2.svg")
                }]
              })]
            }, part(GalyleoSearch, {
              name: "chart name input",
              placeholder: "Chart name"
            }), part(GalyleoDropDown, {
              name: "view selector",
              viewModel: {
                placeholder: "Select view...",
                openListInWorld: true
              }
            }), part(PromptButton, {
              name: "create chart button",
              extent: pt(116.2, 30.5),
              submorphs: [{
                name: "label",
                textAndAttributes: ["Create chart", null]
              }, without("icon")]
            })]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/chart-creator.cp.js",
        "export": "ChartBuilder",
        range: {
          start: 9458,
          end: 11952
        }
      }, System, __varRecorder__$n, "ChartBuilder");
      var GoogleChartHolderMorph = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/chart-creator.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GoogleChartHolderMorph") && typeof __lively_classholder__.GoogleChartHolderMorph === "function" ? __lively_classholder__.GoogleChartHolderMorph : __lively_classholder__.GoogleChartHolderMorph = function GoogleChartHolderMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "isChart",
          get: function get() {
            return true;
          }
        }, {
          key: "init",
          value: function GoogleChartHolderMorph_init_(chartName) {
            this.name = chartName;
            this.html = this.defaultHTML;
            this.getSubmorphNamed("resizer").bottomRight = this.innerBounds().bottomRight();
            connect(this, "extent", this, "requestRedraw");
          }
        }, {
          key: "requestRedraw",
          value: function () {
            var _GoogleChartHolderMorph_requestRedraw_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      if (!this.wrapper) {
                        _context2.next = 4;
                        break;
                      }

                      _context2.next = 3;
                      return this.whenRendered();

                    case 3:
                      this.drawChart(this.wrapper);

                    case 4:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function GoogleChartHolderMorph_requestRedraw_() {
              return _GoogleChartHolderMorph_requestRedraw_.apply(this, arguments);
            }

            return GoogleChartHolderMorph_requestRedraw_;
          }()
        }, {
          key: "drawChart",
          value: function GoogleChartHolderMorph_drawChart_(wrapper) {
            var _this = this;

            wrapper.setOption("width", "100%");
            wrapper.setOption("height", "100%");
            this.whenRendered().then(function (_) {
              wrapper.draw(_this.chartDiv);
              _this.wrapper = wrapper;
            });
          }
        }, {
          key: "resizeChart",
          value: function GoogleChartHolderMorph_resizeChart_(evt) {
            this.resizeBy(evt.state.dragDelta);
            this.requestRedraw();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GoogleChartHolderMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              chartDiv: {
                derived: true,
                get: function get() {
                  return this.domNode;
                }
              },
              defaultHTML: {
                derived: true,
                get: function get() {
                  return "<div id=\"chart-container-".concat(this.id, "\"></div>");
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/chart-creator.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 11962,
          end: 15579
        });
      }({
        referencedAs: "HTMLMorph",
        value: HTMLMorph
      });
      __varRecorder__$n.GoogleChartHolderMorph = GoogleChartHolderMorph;
      __varRecorder__$n.GoogleChartHolderMorph = GoogleChartHolderMorph;
      __varRecorder__$n.GoogleChartHolder = component["for"](function () {
        return component({
          name: "google chart holder",
          type: __varRecorder__$n.GoogleChartHolderMorph,
          submorphs: [{
            name: "resizer"
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/chart-creator.cp.js",
        "export": "GoogleChartHolder",
        range: {
          start: 15587,
          end: 15727
        }
      }, System, __varRecorder__$n, "GoogleChartHolder");
      Chart.register(PieController, ArcElement, plugin_legend);
      Chart.register.apply(Chart, _toConsumableArray(registerables));

      var ChartDiagramModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/chart-creator.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ChartDiagramModel") && typeof __lively_classholder__.ChartDiagramModel === "function" ? __lively_classholder__.ChartDiagramModel : __lively_classholder__.ChartDiagramModel = function ChartDiagramModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "updateSelection",
          value: function ChartDiagramModel_updateSelection_(xValue) {
            this.columnSelection = xValue;
            signal(this, "filterChanged");
          }
        }, {
          key: "dataManagerFilter",
          get: function get() {
            return {
              operator: "IN_LIST",
              column: this.galyleoData.columns[0].name,
              values: [this.columnValueSelection]
            };
          }
        }, {
          key: "filterString",
          get: function get() {
            return "".concat(this.galyleoData.columns[0].name, " = ").concat(this.columnValueSelection);
          }
        }, {
          key: "restoreContent",
          value: function ChartDiagramModel_restoreContent_(oldCanvas, newCanvas) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "restoreContent", this).call(this, oldCanvas, newCanvas);

            this.drawVisualization();
          }
        }, {
          key: "ensureChart",
          value: function ChartDiagramModel_ensureChart_() {
            if (!this.chart) this.drawVisualization();
          }
        }, {
          key: "onRefresh",
          value: function ChartDiagramModel_onRefresh_() {
            if (!this.view.context) return;
            this.ensureChart();
            this.chart.config.type = this.chartJSType;
            this.chart.options = this.config.options;
            this.chart.data = this.config.data;
            this.chart.update();
          }
        }, {
          key: "setData",
          value: function ChartDiagramModel_setData_(galyleoTabularData) {
            this.galyleoData = galyleoTabularData;

            this._setupDatasetOptions();

            this.drawVisualization();
          }
        }, {
          key: "chartTypes",
          get: function get() {
            return ["area", "bar", "bubble", "doughnut", "line", "polarArea", "pie", "radar", "scatter"];
          }
        }, {
          key: "chartTypesMatchingData",
          value: function ChartDiagramModel_chartTypesMatchingData_() {
            var _this2 = this;

            return this.chartTypes.filter(function (type) {
              return _this2.dataMatches(type);
            });
          }
        }, {
          key: "setType",
          value: function ChartDiagramModel_setType_(chartType) {
            if (this.chartTypes.indexOf(chartType) >= 0) {
              this.type = chartType;

              this._setupDatasetOptions();

              this.drawVisualization();
            }
          }
        }, {
          key: "restoreFromSavedForm",
          value: function ChartDiagramModel_restoreFromSavedForm_(savedForm) {
            this.type = savedForm.type;
            this.datasetOptions = savedForm.datasetOptions;
          }
        }, {
          key: "savedForm",
          value: function ChartDiagramModel_savedForm_() {
            return {
              chartMorph: "ChartJSMorph",
              type: this.type,
              datasetOptions: this.datasetOptions
            };
          }
        }, {
          key: "defaultColorSpecs",
          get: function get() {
            var defaultColorSpecs = ["#EBF5C9", "#AFD32E", "#4426CD", "#F65A06", "#110A32", "#FF6384", "#36A2EB", "#FFCD56"];
            var result = defaultColorSpecs.map(function (hexCode) {
              var solid = Color$1.rgbHex(hexCode);
              var background = Color$1.rgbHex(hexCode);
              background.a = 0.2;
              return {
                borderColor: solid,
                backgroundColor: background
              };
            });
            return result;
          }
        }, {
          key: "_setupDatasetOptions",
          value: function ChartDiagramModel__setupDatasetOptions_() {
            var _this3 = this;

            var dataNamesInColumn0 = ["bubble", "doughnut", "polarArea", "pie", "scatter"].indexOf(this.type) >= 0;
            var datasetNames = dataNamesInColumn0 ? this.galyleoData.rows.map(function (row) {
              return row[0];
            }) : this.galyleoData.columns.slice(1).map(function (column) {
              return column.name;
            });

            if (!this.datasetOptions) {
              this.datasetOptions = {};
            }

            Object.keys(this.datasetOptions).forEach(function (datasetName) {
              if (datasetNames.indexOf(datasetName) < 0) {
                delete _this3.datasetOptions[datasetName];
              }
            });
            var colorSpecs = this.defaultColorSpecs;
            datasetNames.forEach(function (datasetName) {
              if (!_this3.datasetOptions[datasetName]) {
                var chosenColor = colorSpecs.pop();
                _this3.datasetOptions[datasetName] = chosenColor;
              }
            });
          }
        }, {
          key: "dataMatches",
          value: function ChartDiagramModel_dataMatches_() {
            var chartType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.type;

            if (!this.galyleoData) {
              return false;
            }

            var columns = this.galyleoData.columns;

            var numericColumns = function numericColumns(columns) {
              return columns.reduce(function (acc, col) {
                return acc && col.type == "number";
              }, true);
            };

            switch (chartType) {
              case "pie":
              case "doughnut":
              case "polarArea":
                return columns.length == 2 && columns[1].type == "number";

              case "line":
              case "area":
              case "bar":
              case "radar":
                return columns.length > 1 && numericColumns(columns.slice(1));

              case "scatter":
                return columns.length == 3 && numericColumns(columns.slice(1));

              case "bubble":
                return columns.length == 4 && numericColumns(columns.slice(1));

              default:
                return false;
            }
          }
        }, {
          key: "_prepareScatterOrBubbleData",
          value: function ChartDiagramModel__prepareScatterOrBubbleData_() {
            var dataDictionary = {};
            this.galyleoData.rows.forEach(function (row) {
              var key = row[0];
              var data = row.slice(1);

              if (key in dataDictionary) {
                dataDictionary[key].push(data);
              } else {
                dataDictionary[key] = [data];
              }
            });
            var mapRow = this.type == "scatter" ? function (row) {
              return {
                x: row[0],
                y: row[1]
              };
            } : function (row) {
              return {
                x: row[0],
                y: row[1],
                r: row[2]
              };
            };
            var datasets = Object.keys(dataDictionary).map(function (key) {
              return {
                label: key,
                data: dataDictionary[key].map(function (row) {
                  return mapRow(row);
                })
              };
            });
            return {
              labels: [],
              datasets: datasets
            };
          }
        }, {
          key: "_prepareLineData",
          value: function ChartDiagramModel__prepareLineData_() {
            var _this4 = this;

            var datasets = this.galyleoData.columns.slice(1).map(function (column, index) {
              return {
                label: column.name,
                data: _this4.galyleoData.rows.map(function (row) {
                  return row[index + 1];
                })
              };
            });
            return {
              labels: this.galyleoData.rows.map(function (row) {
                return row[0];
              }),
              datasets: datasets
            };
          }
        }, {
          key: "_prepareData",
          value: function ChartDiagramModel__prepareData_() {
            var bubbleOrScatter = this.type == "bubble" || this.type == "scatter";
            return bubbleOrScatter ? this._prepareScatterOrBubbleData() : this._prepareLineData();
          }
        }, {
          key: "_prepareChart",
          value: function ChartDiagramModel__prepareChart_() {
            var _this5 = this;

            var data = this._prepareData();

            var pieCharts = ["doughnut", "polarArea", "pie"];

            if (pieCharts.indexOf(this.type) >= 0) {
              data.datasets[0].borderColor = data.labels.map(function (label) {
                return _this5.datasetOptions[label].borderColor.toString();
              });
              data.datasets[0].backgroundColor = data.labels.map(function (label) {
                return _this5.datasetOptions[label].backgroundColor.toString();
              });
            } else {
              data.datasets.forEach(function (dataset) {
                dataset.borderColor = _this5.datasetOptions[dataset.label].borderColor.toString();
                dataset.backgroundColor = _this5.datasetOptions[dataset.label].backgroundColor.toString();

                if (_this5.type == "area") {
                  dataset.fill = "origin";
                } else {
                  if (dataset.fill) {
                    delete dataset.fill;
                  }
                }
              });
            }

            return data;
          }
        }, {
          key: "drawVisualization",
          value: function ChartDiagramModel_drawVisualization_() {
            if (this.view.context) {
              this.data = this._prepareChart();
              this.drawChart();
            }
          }
        }, {
          key: "drawChart",
          value: function ChartDiagramModel_drawChart_() {
            var _this6 = this;

            var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.config;
            this.view.whenRendered().then(function (_) {
              if (_this6.chart) {
                _this6.chart.destroy();
              }

              if (_this6.view.context) {
                _this6.chart = new Chart(_this6.view.context, config);
              }
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ChartDiagramModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              type: {
                type: "Enum",
                values: ["area", "bar", "bubble", "doughnut", "line", "polarArea", "pie", "radar", "scatter"],
                defaultValue: "pie"
              },
              bindings: {
                get: function get() {
                  return [{
                    signal: "onOwnerChanged",
                    handler: "drawVisualization"
                  }];
                }
              },
              data: {
                initialize: function initialize() {
                  this.data = {
                    datasets: [{
                      backgroundColor: ["rgb(204, 0, 0)", "rgb(255, 153, 0)", "rgb(204, 204, 0)", "rgb(0, 204, 0)", "rgb(0, 0, 204)"],
                      borderWidth: 0,
                      data: [50, 60, 100, 200, 300],
                      label: "Dataset 1"
                    }],
                    labels: ["Red", "Orange", "Yellow", "Green", "Blue"]
                  };
                }
              },
              options: {
                initialize: function initialize() {
                  var _this7 = this;

                  this.options = {
                    layout: {
                      padding: 10
                    },
                    plugins: {
                      legend: {
                        display: true,
                        align: "start",
                        labels: {
                          fontColor: Color$1.black,
                          fontFamily: "IBM Plex Sans"
                        },
                        position: "left"
                      }
                    },
                    maintainAspectRatio: false,
                    padding: 50,
                    responsive: true,
                    onClick: function onClick(e) {
                      var canvasPosition = Chart.helpers.getRelativePosition(e, _this7.chart);

                      var dataX = _this7.chart.scales.x.getValueForPixel(canvasPosition.x);

                      _this7.chart.scales.y.getValueForPixel(canvasPosition.y);

                      _this7.updateSelection(dataX);
                    }
                  };
                }
              },
              chartJSType: {
                derived: true,
                get: function get() {
                  return this.type == "area" ? "line" : this.type;
                }
              },
              config: {
                derived: true,
                get: function get() {
                  return copy({
                    type: this.chartJSType,
                    data: this.data,
                    options: this.options
                  });
                }
              },
              datasetOptions: {
                defaultValue: null
              },
              filterChanged: {
                derived: true,
                readOnly: true,
                isSignal: true
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/chart-creator.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 16569,
          end: 31115
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$n.ChartDiagram = component["for"](function () {
        return component({
          type: Canvas,
          defaultViewModel: __varRecorder__$n.ChartDiagramModel,
          borderRadius: 5,
          fill: Color$1.rgb(254, 254, 254),
          extent: pt(465.6, 400.5)
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/chart-creator.cp.js",
        "export": "ChartDiagram",
        range: {
          start: 31123,
          end: 31287
        }
      }, System, __varRecorder__$n, "ChartDiagram");
      __varRecorder__$n._pieData = {
        columns: [{
          name: "Color",
          type: "string"
        }, {
          name: "value",
          type: "number"
        }],
        rows: [["red", 300], ["blue", 50], ["yellow", 100]]
      };
      __varRecorder__$n._testChartModel = {
        type: "pie",
        datasetOptions: {
          blue: {
            backgroundColor: Color$1.rgba(0, 0, 255, 0.2),
            borderColor: Color$1.rgb(0, 0, 255)
          },
          red: {
            backgroundColor: Color$1.rgba(255, 0, 0, 0.2),
            borderColor: Color$1.rgb(255, 0, 0)
          },
          yellow: {
            backgroundColor: Color$1.rgba(255, 255, 0, 0.2),
            borderColor: Color$1.rgb(255, 255, 0)
          }
        }
      };

      __varRecorder__$n.makeTestChart = function (_) {
        var chart = part(__varRecorder__$n.ChartDiagram);
        chart.viewModel.restoreFromSavedForm(__varRecorder__$n._testChartModel);
        chart.viewModel.setData(__varRecorder__$n._pieData);
        return chart;
      };

      __varRecorder__$n.showTestChart = function (_) {
        var chart = __varRecorder__$n.makeTestChart();

        chart.openInWorld();
        chart.viewModel.drawVisualization();
      };

      __varRecorder__$n.editTestChart = function (_) {
        var chart = __varRecorder__$n.makeTestChart();

        var chartEditor = part(__varRecorder__$n.ChartJSEditor);
        chartEditor.viewModel.loadModel(chart.viewModel);
        chartEditor.openInWorld();
        chartEditor.whenRendered().then(function (_) {
          return chartEditor.viewModel.updatePreview();
        });
      };

      var ChartJSEditorModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/chart-creator.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ChartJSEditorModel") && typeof __lively_classholder__.ChartJSEditorModel === "function" ? __lively_classholder__.ChartJSEditorModel : __lively_classholder__.ChartJSEditorModel = function ChartJSEditorModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "close",
          value: function ChartJSEditorModel_close_() {
            this.view.remove();
          }
        }, {
          key: "loadModel",
          value: function ChartJSEditorModel_loadModel_(baseChartModel) {
            var wrapper = baseChartModel.savedForm();
            var previewChart = this.ui.preview.viewModel;
            previewChart.restoreFromSavedForm(wrapper);
            previewChart.setData(baseChartModel.galyleoData);
            this.baseChart = baseChartModel;

            if (this.viewLoaded) {
              this._initItems();
            }
          }
        }, {
          key: "viewDidLoad",
          value: function ChartJSEditorModel_viewDidLoad_() {
            this.acceptDatasetUpdate = true;

            if (this.ui.preview && this.ui.preview.viewModel && this.ui.preview.viewModel.galyleoData) {
              this._initItems();
            } else {
              this.viewLoaded = true;
            }
          }
        }, {
          key: "updateChartSelection",
          value: function ChartJSEditorModel_updateChartSelection_() {
            var chartType = this.ui.chartTypeSelector.selection;

            if (chartType) {
              this.ui.preview.viewModel.setType(chartType);
              this.ui.columnSelector.items = Object.keys(this.ui.preview.viewModel.datasetOptions);
            }
          }
        }, {
          key: "updateDatasetConfiguration",
          value: function ChartJSEditorModel_updateDatasetConfiguration_() {
            var _this8 = this;

            var setColorField = function setColorField(uiField, value) {
              _this8.ui[uiField].viewModel.colorValue = value;

              _this8.ui[uiField].viewModel.update();
            };

            var dataset = this.ui.columnSelector.selection;
            var colorOptions = this.ui.preview.viewModel.datasetOptions[dataset];
            this.acceptDatasetUpdate = false;
            setColorField("fillColor", colorOptions.backgroundColor);
            setColorField("strokeColor", colorOptions.borderColor);
            this.acceptDatasetUpdate = true;
          }
        }, {
          key: "_updateColorField",
          value: function ChartJSEditorModel__updateColorField_(colorValue, datasetColorField) {
            var dataset = this.ui.columnSelector.selection;
            this.ui.preview.viewModel.datasetOptions[dataset][datasetColorField] = colorValue;
            this.ui.preview.viewModel.drawVisualization();
          }
        }, {
          key: "updateStrokeColor",
          value: function ChartJSEditorModel_updateStrokeColor_() {
            if (this.acceptDatasetUpdate) {
              this._updateColorField(this.ui.strokeColor.colorValue, "borderColor");
            }
          }
        }, {
          key: "updateFillColor",
          value: function ChartJSEditorModel_updateFillColor_() {
            if (this.acceptDatasetUpdate) {
              this._updateColorField(this.ui.fillColor.colorValue, "backgroundColor");
            }
          }
        }, {
          key: "updatePreview",
          value: function ChartJSEditorModel_updatePreview_() {
            this.ui.preview.viewModel.drawVisualization();
          }
        }, {
          key: "updateBaseChart",
          value: function ChartJSEditorModel_updateBaseChart_() {
            var previewModel = this.ui.preview.viewModel;
            var saved = previewModel.savedForm();
            this.baseChart.restoreFromSavedForm(saved);
          }
        }, {
          key: "_initItems",
          value: function ChartJSEditorModel__initItems_() {
            this.ui.chartTypeSelector.items = this.ui.preview.viewModel.chartTypesMatchingData();
            this.ui.columnSelector.items = Object.keys(this.ui.preview.viewModel.datasetOptions);
            this.ui.preview.viewModel.drawVisualization();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ChartJSEditorModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              baseChart: {
                defaultValue: null
              },
              bindings: {
                get: function get() {
                  return [{
                    model: "chartTypeSelector",
                    signal: "selection",
                    handler: "updateChartSelection"
                  }, {
                    model: "columnSelector",
                    signal: "selection",
                    handler: "updateDatasetConfiguration"
                  }, {
                    model: "strokeColor",
                    signal: "color",
                    handler: "updateStrokeColor"
                  }, {
                    model: "fillColor",
                    signal: "color",
                    handler: "updateFillColor"
                  }, {
                    model: "close button",
                    signal: "fire",
                    handler: "close"
                  }, {
                    model: "updateChart",
                    signal: "fire",
                    handler: "updateBaseChart"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/chart-creator.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 32855,
          end: 37809
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$n.ChartJSEditorModel = ChartJSEditorModel;
      __varRecorder__$n.ChartJSEditorModel = ChartJSEditorModel;
      __varRecorder__$n.ChartJSEditor = component["for"](function () {
        return component(GalyleoWindow, {
          name: "ChartJS Editor",
          extent: pt(800, 450),
          defaultViewModel: __varRecorder__$n.ChartJSEditorModel,
          layout: new TilingLayout({
            axis: "column",
            orderByIndex: true,
            padding: rect(0, 0, 2, 0),
            resizePolicies: [["window title", {
              height: "fixed",
              width: "fill"
            }], ["editor", {
              height: "fixed",
              width: "fixed"
            }]],
            wrapSubmorphs: false
          }),
          submorphs: [{
            name: "window title",
            textString: "ChartJS Editor",
            reactsToPointer: false
          }, add({
            extent: pt(800, 400),
            name: "editor",
            fill: Color$1.rgba(255, 255, 255, 0),
            submorphs: [part(MenuBarButton, {
              tooltip: "Close this dialog without loading",
              name: "close button",
              extent: pt(100, 35),
              position: pt(680, 10),
              submorphs: [{
                name: "label",
                textAndAttributes: ["CLOSE", null]
              }, {
                name: "icon",
                extent: pt(14, 14),
                imageUrl: projectAsset("engageLively--galyleo-dashboard__close-button-icon-2.svg")
              }]
            }), part(GalyleoDropDown, {
              name: "chartTypeSelector",
              viewModel: {
                placeholder: "Select chart type...",
                openListInWorld: true
              },
              position: pt(490, 40)
            }), part(GalyleoDropDown, {
              name: "columnSelector",
              viewModel: {
                placeholder: "Select column...",
                openListInWorld: true
              },
              position: pt(490, 95)
            }), {
              type: Label,
              name: "Fill Label",
              textAndAttributes: ["Fill", null],
              fontColor: Color$1.rgb(0, 0, 0),
              fontFamily: "Noto Sans",
              fontSize: 14,
              fontWeight: "bold",
              position: pt(490, 170)
            }, part(GalyleoColorInput, {
              name: "fillColor",
              position: pt(540, 165)
            }), {
              type: Label,
              name: "Stroke Label",
              textAndAttributes: ["Stroke", null],
              fontColor: Color$1.rgb(0, 0, 0),
              fontFamily: "Noto Sans",
              fontSize: 14,
              fontWeight: "bold",
              position: pt(490, 200)
            }, part(GalyleoColorInput, {
              name: "strokeColor",
              position: pt(540, 195)
            }), part(__varRecorder__$n.ChartDiagram, {
              name: "preview",
              position: pt(10, 10)
            }), part(PromptButton, {
              name: "updateChart",
              position: pt(610, 360),
              extent: pt(165, 40),
              submorphs: [{
                name: "label",
                textAndAttributes: ["Apply Changes", null]
              }]
            })]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/chart-creator.cp.js",
        "export": "ChartJSEditor",
        range: {
          start: 37817,
          end: 40315
        }
      }, System, __varRecorder__$n, "ChartJSEditor");
      var ChartBuilder = __varRecorder__$n.ChartBuilder;
      var GoogleChartHolder = __varRecorder__$n.GoogleChartHolder;
      var ChartJSEditor = __varRecorder__$n.ChartJSEditor;
      var ChartDiagram = __varRecorder__$n.ChartDiagram;
      __varRecorder__$n.ChartBuilder = ChartBuilder;
      __varRecorder__$n.GoogleChartHolder = GoogleChartHolder;
      __varRecorder__$n.ChartJSEditor = ChartJSEditor;
      __varRecorder__$n.ChartDiagram = ChartDiagram;
      __varRecorder__$n["default"] = ChartDiagramModel;

      var __varRecorder__$m = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/date.cp.js", __contextModule__);
      var GalyleoDate = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/date.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GalyleoDate") && typeof __lively_classholder__.GalyleoDate === "function" ? __lively_classholder__.GalyleoDate : __lively_classholder__.GalyleoDate = function GalyleoDate(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onMouseDown",
          value: function GalyleoDate_onMouseDown_(evt) {
            if (this.dayNum && this.dayNum > 0) {
              this.owner.dateSelected(this);
            } else {
              this.owner.clearSelection();
            }
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GalyleoDate";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              dayNum: {
                after: ["autofit"],
                set: function set(dayNum) {
                  this.textString = dayNum > 9 ? dayNum : dayNum > 0 ? "  ".concat(dayNum) : "  ";
                  this.setProperty("dayNum", dayNum);
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/inputs/date.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 447,
          end: 1339
        });
      }({
        referencedAs: "Label",
        value: Label
      });
      __varRecorder__$m.GalyleoDate = GalyleoDate;
      __varRecorder__$m.GalyleoDate = GalyleoDate;
      var DateArray = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/date.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DateArray") && typeof __lively_classholder__.DateArray === "function" ? __lively_classholder__.DateArray : __lively_classholder__.DateArray = function DateArray(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "assignDates",
          value: function DateArray_assignDates_(firstDate, numDates) {
            this.submorphs.forEach(function (dayMorph) {
              return dayMorph.dayNum = -1;
            });
            var monthDates = this.submorphs.slice(firstDate, firstDate + numDates);
            monthDates.forEach(function (monthDate, index) {
              return monthDate.dayNum = index + 1;
            });
          }
        }, {
          key: "renderDates",
          value: function DateArray_renderDates_() {
            var _this = this;

            this.renderedDates.forEach(function (day, i) {
              var isEmpty = day.value === "  ";

              if (_this.selectedDates.includes(day) && !isEmpty) {
                return;
              }

              day.name = "day ".concat(i);
              day.master = isEmpty ? __varRecorder__$m.DateDefault : {
                auto: __varRecorder__$m.DateDefault,
                hover: __varRecorder__$m.DateHover
              };
            });
            this.selectedDates.forEach(function (d) {
              return d.master = __varRecorder__$m.DateActive;
            });
          }
        }, {
          key: "selectDateForDay",
          value: function DateArray_selectDateForDay_(dayNum) {
            var dates = this.submorphs.filter(function (dayMorph) {
              return dayMorph.dayNum === dayNum;
            });

            if (dates.length !== 1) {
              return;
            }

            this.dateSelected(dates[0]);
          }
        }, {
          key: "dateSelected",
          value: function DateArray_dateSelected_(date) {
            if (this.selectedDates.length > (this.rangeSelection ? 1 : 0)) {
              this.selectedDates = [];
            }

            this.selectedDates.push(date);

            if (this.selectedDates.length === 2) {
              var _arr$sortBy = sortBy(this.selectedDates, function (d) {
                return Number.parseInt(d.dayNum);
              }),
                  _arr$sortBy2 = _slicedToArray(_arr$sortBy, 2),
                  startDate = _arr$sortBy2[0],
                  endDate = _arr$sortBy2[1];

              this.highlightRange(startDate.dayNum, endDate.dayNum);
            } else {
              this.highlightRange();
            }

            signal(this, "selectedDate");
            this.renderDates();
          }
        }, {
          key: "highlightRange",
          value: function () {
            var _DateArray_highlightRange_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(startDay, endDay) {
              var _this2 = this;

              var lineProto, dateHeight;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      lineProto = part(__varRecorder__$m.SelectionBar, {
                        name: "selected line"
                      });
                      lineProto.master = false;
                      this.getAllNamed("selected line").forEach(function (line) {
                        return line.remove();
                      });
                      dateHeight = this.submorphs[0].height;
                      Object.entries(groupBy(this.submorphs.filter(function (d) {
                        return d.value !== "  " && d.value >= startDay && d.value <= endDay;
                      }), function (d) {
                        return d.top;
                      })).forEach(function (_ref) {
                        var _ref2 = _slicedToArray(_ref, 2),
                            top = _ref2[0],
                            dates = _ref2[1];

                        var left = min(dates, function (d) {
                          return d.left;
                        }).left;
                        var right = max(dates, function (d) {
                          return d.right;
                        }).right;
                        var line = lineProto.copy();

                        _this2.addMorphBack(line);

                        line.width = right - left;
                        line.leftCenter = pt(left, Number.parseInt(top) + dateHeight / 2);
                      });

                    case 5:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function DateArray_highlightRange_(_x, _x2) {
              return _DateArray_highlightRange_.apply(this, arguments);
            }

            return DateArray_highlightRange_;
          }()
        }, {
          key: "clearSelection",
          value: function DateArray_clearSelection_() {
            this.selectedDates = [];
            this.highlightRange();
            this.renderDates();
            signal(this, "selectedDate");
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DateArray";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              rangeSelection: {
                defaultValue: false
              },
              renderedDates: {
                get: function get() {
                  return this.submorphs.filter(function (m) {
                    return m.name !== "selected line";
                  });
                }
              },
              selectedDates: {
                initialize: function initialize() {
                  this.selectedDates = [];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/inputs/date.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 1348,
          end: 5151
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$m.DateArray = DateArray;
      __varRecorder__$m.DateArray = DateArray;
      var GalyleoDateInput = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/date.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GalyleoDateInput") && typeof __lively_classholder__.GalyleoDateInput === "function" ? __lively_classholder__.GalyleoDateInput : __lively_classholder__.GalyleoDateInput = function GalyleoDateInput(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "_checkDate_",
          value: function GalyleoDateInput__checkDate__(dateString) {
            var date = new Date(dateString);
            return date === "Invalid Date" ? null : date;
          }
        }, {
          key: "acceptInput",
          value: function GalyleoDateInput_acceptInput_() {
            var date = this._checkDate_(this.input);

            if (date) {
              this.date = date;

              initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "acceptInput", this).call(this);

              this.textString = this.date.toDateString();
            } else {
              this.show();
            }
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GalyleoDateInput";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              date: {}
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/inputs/date.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 5160,
          end: 6635
        });
      }({
        referencedAs: "InputLine",
        value: InputLine
      });
      __varRecorder__$m.GalyleoDateInput = GalyleoDateInput;
      __varRecorder__$m.GalyleoDateInput = GalyleoDateInput;

      var DatePickerModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/date.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DatePickerModel") && typeof __lively_classholder__.DatePickerModel === "function" ? __lively_classholder__.DatePickerModel : __lively_classholder__.DatePickerModel = function DatePickerModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "canSelectDate",
          value: function DatePickerModel_canSelectDate_(day, month, year) {
            if (this.minMonth && month < this.minMonth) return false;
            if (this.minYear && year < this.minYear) return false;
            return true;
          }
        }, {
          key: "viewDidLoad",
          value: function DatePickerModel_viewDidLoad_() {
            this._preserveInputDate_ = false;

            this._setMonthAndYear_();
          }
        }, {
          key: "onRefresh",
          value: function DatePickerModel_onRefresh_() {
            this.ui.dateArray.rangeSelection = this.rangeSelection;
          }
        }, {
          key: "selectInputDate",
          value: function DatePickerModel_selectInputDate_(date) {
            this.selectDate(date);
          }
        }, {
          key: "selectDate",
          value: function DatePickerModel_selectDate_(aDate) {
            var dateArray = this.ui.dateArray;
            var month = aDate.getMonth() + 1;
            var year = aDate.getFullYear();
            var day = aDate.getDate();
            this._preserveInputDate_ = true;
            this.month = month;
            this.year = year;
            this._preserveInputDate_ = false;
            dateArray.selectDateForDay(day);
          }
        }, {
          key: "selectDateRange",
          value: function DatePickerModel_selectDateRange_(startDate, endDate) {
            var dateArray = this.ui.dateArray;
            var month = startDate.getMonth() + 1;
            var year = startDate.getFullYear();
            this._preserveInputDate_ = true;
            this.month = month;
            this.year = year;
            this._preserveInputDate_ = false;
            dateArray.selectDatesForRange(startDate.getDate(), endDate.getDate());
          }
        }, {
          key: "showDate",
          value: function DatePickerModel_showDate_() {
            var dateString = this.selectedDate ? this.selectedDate.toDateString() : "".concat(this.monthName.slice(0, 3), " ").concat(this.year);

            if (this.selectedDateRange.length === 2) {
              var start = dateFormat(this.selectedDateRange[0], "dd");
              var end = dateFormat(this.selectedDateRange[1], "dd");
              dateString = "".concat(this.monthName.slice(0, 3), " ").concat(start, " - ").concat(end, " ").concat(this.year);
            }

            if (!this._preserveInputDate_) {
              signal(this, "dateChanged", dateString);
              this.ui.dateInput.textString = dateString;
            }
          }
        }, {
          key: "_setMonthAndYear_",
          value: function DatePickerModel__setMonthAndYear__() {
            if (!this.view) return;
            var daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            var _this$ui = this.ui,
                dateArray = _this$ui.dateArray,
                monthLabel = _this$ui.monthLabel;
            var day = new Date("".concat(this.month, "-1-").concat(this.year)).getDay();
            var dates = dateArray.selectedDates;
            var lastDay = daysInMonth[this.month];
            monthLabel.value = this.monthName.slice(0, 3);
            dateArray.assignDates(day, daysInMonth[this.month]);

            if (this.rangeSelection) {
              dateArray.clearSelection();
            }

            if (!this._preserveInputDate_) {
              var clamp = function clamp(date) {
                return date ? date.dayNum <= lastDay ? date.dayNum : lastDay : 1;
              };

              if (dates.length > 1) {
                dateArray.selectDateForDay(clamp(dates[0]));
                dateArray.selectDateForDay(clamp(dates[1]));
              } else {
                var _date = dates[0];
                dateArray.selectDateForDay(clamp(_date));
              }

              dateArray.renderDates();
              this.showDate();
            }
          }
        }, {
          key: "goBackYear",
          value: function DatePickerModel_goBackYear_() {
            this.year = this.year - 1;
          }
        }, {
          key: "goBackMonth",
          value: function DatePickerModel_goBackMonth_() {
            if (this.month === 1) {
              this.month = 12;
              this.year = this.year - 1;
            } else {
              this.month = this.month - 1;
            }
          }
        }, {
          key: "advanceMonth",
          value: function DatePickerModel_advanceMonth_() {
            if (this.month === 12) {
              this.month = 1;
              this.year = this.year + 1;
            } else {
              this.month = this.month + 1;
            }
          }
        }, {
          key: "advanceYear",
          value: function DatePickerModel_advanceYear_() {
            this.year = this.year + 1;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DatePickerModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              minMonth: {
                defaultValue: false,
                min: 1,
                max: 12
              },
              minYear: {
                defaultValue: false
              },
              monthName: {
                readOnly: true,
                get: function get() {
                  return ["", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][this.month];
                }
              },
              month: {
                defaultValue: 1,
                set: function set(month) {
                  if (isNaN(month)) {
                    return;
                  }

                  var aMonth = Math.round(month);
                  var minMonth = this.minMonth || 1;

                  if (aMonth > 12) {
                    return;
                  }

                  if (aMonth < minMonth) {
                    aMonth = minMonth;
                  }

                  this.setProperty("month", aMonth);

                  if (isNaN(this.year)) {
                    this.year = new Date().getFullYear();
                  } else {
                    this._setMonthAndYear_();
                  }
                }
              },
              year: {
                defaultValue: 2020,
                set: function set(year) {
                  if (isNaN(year)) {
                    return;
                  }

                  var aYear = Math.round(year);
                  var minYear = this.minYear || 1753;

                  if (aYear < minYear) {
                    aYear = minYear;
                  }

                  this.setProperty("year", aYear);

                  if (isNaN(this.month)) {
                    this.month = 1;
                  } else {
                    this._setMonthAndYear_();
                  }
                }
              },
              selectedDate: {
                derived: true,
                readOnly: true,
                get: function get() {
                  var day = this.ui.dateArray.selectedDates[0];

                  if (day) {
                    return new Date("".concat(this.month, "-").concat(day.dayNum, "-").concat(this.year));
                  }
                }
              },
              dateChanged: {
                derived: true,
                readOnly: true,
                isSignal: true
              },
              rangeSelection: {
                defaultValue: false
              },
              selectedDateRange: {
                derived: true,
                get: function get() {
                  var _this3 = this;

                  return sortBy(this.ui.dateArray.selectedDates, function (day) {
                    return day.dayNum;
                  }).map(function (day) {
                    return new Date("".concat(_this3.month, "-").concat(day.dayNum, "-").concat(_this3.year));
                  });
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "date array",
                    signal: "selectedDate",
                    handler: "showDate"
                  }, {
                    target: "back year",
                    signal: "onMouseDown",
                    handler: "goBackYear"
                  }, {
                    target: "back month",
                    signal: "onMouseDown",
                    handler: "goBackMonth"
                  }, {
                    target: "forward month",
                    signal: "onMouseDown",
                    handler: "advanceMonth"
                  }, {
                    target: "forward year",
                    signal: "onMouseDown",
                    handler: "advanceYear"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/inputs/date.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 6652,
          end: 17409
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/date.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DoubleDatePickerModel") && typeof __lively_classholder__.DoubleDatePickerModel === "function" ? __lively_classholder__.DoubleDatePickerModel : __lively_classholder__.DoubleDatePickerModel = function DoubleDatePickerModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onLoad",
          value: function DoubleDatePickerModel_onLoad_() {
            this._doNothingOnUpdate_ = false;
          }
        }, {
          key: "updateDates",
          value: function DoubleDatePickerModel_updateDates_(selector, dateString) {
            if (this._doNothingOnUpdate_) {
              return;
            }

            var minSelector = this.models.minDateSelector;
            var maxSelector = this.models.maxDateSelector;

            if (minSelector.year > maxSelector.year) {
              maxSelector.year = minSelector.year + (maxSelector.month < 12 ? 0 : 1);
              if (maxSelector.month === 12) maxSelector.month = 1;
              maxSelector.ui.dateArray.clearSelection();
            }

            if (minSelector.year === maxSelector.year && minSelector.month >= maxSelector.month) {
              maxSelector.month = minSelector.month + 1;
              maxSelector.ui.dateArray.clearSelection();
              maxSelector.view.whenRendered().then(function () {
                maxSelector.showDate();
              });
            }

            var range = this.dateRange;

            if (range.min > range.max) {
              this._doNothingOnUpdate_ = true;
              var min = new Date(range.min);
              var max = new Date(range.max);
              this.updates.push({
                min: min,
                max: max
              });
              minSelector.selectDate(max);
              maxSelector.selectDate(min);
              this._doNothingOnUpdate_ = false;
            }

            if (selector === minSelector) {
              this.ui.startInput.textString = dateString;
            }

            if (selector === maxSelector) {
              this.ui.endInput.textString = dateString;
            }

            this.renderRangeMarks(selector);
            signal(this, "datesChanged");
          }
        }, {
          key: "renderRangeMarks",
          value: function () {
            var _DoubleDatePickerModel_renderRangeMarks_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(selector) {
              var minDateSelector, minDateArray, selectedMinDates, maxDateSelector, maxDateArray, selectedMaxDates, maxReset, minReset, totalDates;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      this._doNothingOnUpdate_ = true;
                      minDateSelector = this.models.minDateSelector;
                      minDateArray = minDateSelector.ui.dateArray;
                      selectedMinDates = minDateArray.selectedDates;
                      maxDateSelector = this.models.maxDateSelector;
                      maxDateArray = maxDateSelector.ui.dateArray;
                      selectedMaxDates = maxDateArray.selectedDates;
                      maxReset = selector === maxDateSelector && selectedMaxDates.length === 0;
                      minReset = selector === minDateSelector && selectedMinDates.length === 0;
                      totalDates = [].concat(_toConsumableArray(selectedMinDates), _toConsumableArray(selectedMaxDates));

                      if (maxReset || minReset) {
                        minDateArray.clearSelection();
                        maxDateArray.clearSelection();
                      }

                      if (selector === maxDateSelector && totalDates.length > 2) {
                        minDateArray.clearSelection();
                      }

                      if (selector === minDateSelector && totalDates.length > 2) {
                        maxDateArray.clearSelection();
                      }

                      if (selectedMinDates.length === 1 && selectedMaxDates.length === 1) {
                        minDateArray.highlightRange(selectedMinDates[0].dayNum, last(minDateArray.submorphs.filter(function (m) {
                          return m.dayNum > -1;
                        })).dayNum);
                        maxDateArray.highlightRange(first(maxDateArray.submorphs.filter(function (m) {
                          return m.dayNum > -1;
                        })).dayNum, selectedMaxDates[0].dayNum);
                      } else if (selectedMinDates.length < 2 && selectedMaxDates.length < 2) {
                        minDateArray.highlightRange();
                        maxDateArray.highlightRange();
                      }

                      this._doNothingOnUpdate_ = false;

                    case 15:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function DoubleDatePickerModel_renderRangeMarks_(_x3) {
              return _DoubleDatePickerModel_renderRangeMarks_.apply(this, arguments);
            }

            return DoubleDatePickerModel_renderRangeMarks_;
          }()
        }, {
          key: "collapse",
          value: function DoubleDatePickerModel_collapse_(active) {
            var _this4 = this;

            this.withAnimationDo(function () {
              _this4.height = active ? 90 : _this4.submorphBounds().height;
            }, {
              duration: 200
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DoubleDatePickerModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              collapsed: {
                set: function set(active) {
                  this.setProperty("collapsed", active);
                  this.collapse(active);
                }
              },
              dateRange: {
                derived: true,
                set: function set(aDateRange) {
                  var fieldOK = function fieldOK(field) {
                    return aDateRange[field] && aDateRange[field] instanceof Date;
                  };

                  if (fieldOK("min") && fieldOK("max")) {
                    if (aDateRange.min <= aDateRange.max) {
                      this.models.minDateSelector.selectDate(aDateRange.min);
                      this.models.maxDateSelector.selectDate(aDateRange.max);
                    } else {
                      this.models.minDateSelector.selectDate(aDateRange.min);
                      this.models.maxDateSelector.selectDate(aDateRange.max);
                    }
                  }
                },
                get: function get() {
                  var _ref3 = [].concat(_toConsumableArray(this.models.minDateSelector.selectedDateRange), _toConsumableArray(this.models.maxDateSelector.selectedDateRange)),
                      min = _ref3[0],
                      max = _ref3[1];

                  return {
                    min: min,
                    max: max
                  };
                }
              },
              datesChanged: {
                derived: true,
                readOnly: true,
                isSignal: true
              },
              bindings: {
                get: function get() {
                  return [{
                    model: "min date selector",
                    signal: "dateChanged",
                    handler: "updateDates",
                    updater: "($upd, date) => $upd(source, date)"
                  }, {
                    model: "max date selector",
                    signal: "dateChanged",
                    handler: "updateDates",
                    updater: "($upd, date) => $upd(source, date)"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/inputs/date.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 17411,
          end: 22788
        });
      })({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      __varRecorder__$m.DateInput = component["for"](function () {
        return component({
          type: __varRecorder__$m.GalyleoDateInput,
          name: "date input",
          borderColor: Color$1.rgb(204, 204, 204),
          borderRadius: 20,
          extent: pt(115.8, 23.3),
          fill: Color$1.rgb(253, 254, 254),
          fontColor: Color$1.rgb(66, 73, 73),
          fontFamily: galyleoFont,
          fontSize: 13,
          fontWeight: 500,
          haloShadow: new ShadowObject({
            blur: 6,
            color: Color$1.fromLiteral({
              a: 1,
              b: 0.8588235294117647,
              g: 0.596078431372549,
              r: 0.20392156862745098
            }),
            fast: false,
            distance: 0,
            rotation: 45
          }),
          highlightWhenFocused: true,
          padding: rect(10, 3, 0, 3),
          position: pt(291.6, 759.5),
          renderOnGPU: true,
          textAlign: "left"
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/date.cp.js",
        "export": "DateInput",
        range: {
          start: 22796,
          end: 23461
        }
      }, System, __varRecorder__$m, "DateInput");
      __varRecorder__$m.DateDefault = component["for"](function () {
        return component({
          type: __varRecorder__$m.GalyleoDate,
          name: "date/default",
          autofit: false,
          dayNum: 1,
          fill: Color$1.rgba(255, 255, 255, 0),
          fontColor: Color$1.rgb(81, 90, 90),
          padding: rect(4, 2, 2, 2),
          fontFamily: galyleoFont,
          fontWeight: 500,
          borderRadius: 50
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/date.cp.js",
        "export": "DateDefault",
        range: {
          start: 23499,
          end: 23771
        }
      }, System, __varRecorder__$m, "DateDefault");
      __varRecorder__$m.DateHover = component["for"](function () {
        return component(__varRecorder__$m.DateDefault, {
          name: "date/hover",
          fill: Color$1.rgba(0, 0, 0, 0.15)
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/date.cp.js",
        "export": "DateHover",
        range: {
          start: 23780,
          end: 23875
        }
      }, System, __varRecorder__$m, "DateHover");
      __varRecorder__$m.DateActive = component["for"](function () {
        return component(__varRecorder__$m.DateDefault, {
          name: "date/active",
          fontColor: Color$1.white,
          fill: Color$1.rgb(247, 147, 30)
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/date.cp.js",
        "export": "DateActive",
        range: {
          start: 23912,
          end: 24033
        }
      }, System, __varRecorder__$m, "DateActive");
      __varRecorder__$m.DayOfWeek = component["for"](function () {
        return component({
          type: Label,
          name: "day of week",
          fill: Color$1.rgba(255, 255, 255, 0),
          fontColor: Color$1.rgb(66, 73, 73),
          fontFamily: galyleoFont,
          fontWeight: 600,
          position: pt(367.6, 433),
          renderOnGPU: true,
          textAndAttributes: [" S", null]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/date.cp.js",
        "export": "DayOfWeek",
        range: {
          start: 24042,
          end: 24309
        }
      }, System, __varRecorder__$m, "DayOfWeek");
      __varRecorder__$m.CalendarNavButton = component["for"](function () {
        return component({
          name: "calendar nav button",
          borderColor: Color$1.rgb(149, 165, 166),
          borderRadius: 5,
          extent: pt(25.5, 24.1),
          fill: Color$1.rgba(0, 0, 204, 0),
          nativeCursor: "pointer",
          position: pt(369, 477.3),
          renderOnGPU: true,
          submorphs: [{
            type: Label,
            name: "label",
            fontColor: Color$1.rgb(66, 73, 73),
            fontSize: 14,
            position: pt(7.5, 5),
            reactsToPointer: false,
            textAndAttributes: Icon.textAttribute("angle-double-right")
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/date.cp.js",
        "export": "CalendarNavButton",
        range: {
          start: 24318,
          end: 24810
        }
      }, System, __varRecorder__$m, "CalendarNavButton");
      __varRecorder__$m.SelectionBar = component["for"](function () {
        return component({
          name: "selection bar",
          borderColor: Color$1.rgb(23, 160, 251),
          borderRadius: 10,
          extent: pt(144.3, 13.1),
          fill: Color$1.rgb(247, 147, 30),
          isLayoutable: false,
          opacity: 0.5,
          position: pt(301.4, 660.8),
          reactsToPointer: false
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/date.cp.js",
        "export": "SelectionBar",
        range: {
          start: 24849,
          end: 25117
        }
      }, System, __varRecorder__$m, "SelectionBar");
      __varRecorder__$m.DatePicker = component["for"](function () {
        return component({
          defaultViewModel: __varRecorder__$m.DatePickerModel,
          name: "date picker",
          layout: new TilingLayout({
            axis: "column",
            orderByIndex: true,
            resizePolicies: [["date input", {
              height: "fixed",
              width: "fill"
            }], ["buttonBar", {
              height: "fixed",
              width: "fill"
            }], ["daybar", {
              height: "fixed",
              width: "fill"
            }], ["date array", {
              height: "fixed",
              width: "fill"
            }]],
            wrapSubmorphs: false
          }),
          borderColor: Color$1.rgb(23, 160, 251),
          borderRadius: 6,
          clipMode: "hidden",
          extent: pt(166.6, 245.9),
          fill: Color$1.rgb(247, 180, 30),
          position: pt(327.2, 247.1),
          submorphs: [{
            type: Label,
            name: "monthLabel",
            fontColor: Color$1.rgb(253, 254, 254),
            fontWeight: 300,
            padding: rect(10, 2, -10, 13),
            textAndAttributes: ["Select date", null]
          }, part(__varRecorder__$m.DateInput, {
            name: "date input",
            extent: pt(152, 31),
            fill: Color$1.transparent,
            fontColor: Color$1.white,
            borderRadius: 3,
            fontSize: 18,
            fontWeight: 500
          }), {
            name: "buttonBar",
            borderColor: Color$1.rgb(23, 160, 251),
            extent: pt(153.6, 26),
            fill: Color$1.rgb(242, 242, 242),
            layout: new TilingLayout({
              align: "center",
              axisAlign: "center",
              justifySubmorphs: "spaced",
              orderByIndex: true,
              padding: rect(3, 0, 0, 0)
            }),
            submorphs: [{
              type: Label,
              name: "month label",
              fontColor: Color$1.rgb(66, 73, 73),
              fontFamily: galyleoFont,
              fontSize: 13,
              fontWeight: "bold",
              padding: rect(5, 0, -5, 0),
              reactsToPointer: false,
              textAndAttributes: ["Nov", null]
            }, part(__varRecorder__$m.CalendarNavButton, {
              name: "back year",
              submorphs: [{
                name: "label",
                textAndAttributes: Icon.textAttribute("angle-double-left")
              }],
              tooltip: "Jump to previous year"
            }), part(__varRecorder__$m.CalendarNavButton, {
              name: "back month",
              submorphs: [{
                name: "label",
                textAndAttributes: Icon.textAttribute("angle-left")
              }],
              tooltip: "Jump to previous month"
            }), part(__varRecorder__$m.CalendarNavButton, {
              name: "forward month",
              submorphs: [{
                name: "label",
                textAndAttributes: Icon.textAttribute("angle-right")
              }],
              tooltip: "Jump to next month"
            }), part(__varRecorder__$m.CalendarNavButton, {
              name: "forward year",
              submorphs: [{
                name: "label",
                textAndAttributes: Icon.textAttribute("angle-double-right")
              }],
              tooltip: "Jump to next year"
            })]
          }, {
            name: "daybar",
            layout: new TilingLayout({
              justifySubmorphs: "spaced",
              orderByIndex: true,
              padding: rect(5, 0, 5, 0)
            }),
            borderColor: Color$1.rgb(23, 160, 251),
            extent: pt(154.2, 19),
            fill: Color$1.rgb(242, 242, 242),
            submorphs: [part(__varRecorder__$m.DayOfWeek, {
              name: "sunday",
              textAndAttributes: [" S", null]
            }), part(__varRecorder__$m.DayOfWeek, {
              name: "monday",
              textAndAttributes: [" M", null]
            }), part(__varRecorder__$m.DayOfWeek, {
              name: "tuesday",
              textAndAttributes: [" T", null]
            }), part(__varRecorder__$m.DayOfWeek, {
              name: "wednesday",
              textAndAttributes: [" W", null]
            }), part(__varRecorder__$m.DayOfWeek, {
              name: "thursday",
              textAndAttributes: ["T", null]
            }), part(__varRecorder__$m.DayOfWeek, {
              name: "friday",
              textAndAttributes: [" F", null]
            }), part(__varRecorder__$m.DayOfWeek, {
              name: "saturday",
              textAndAttributes: [" S", null]
            })]
          }, {
            type: __varRecorder__$m.DateArray,
            name: "date array",
            borderColor: Color$1.rgb(23, 160, 251),
            dropShadow: false,
            extent: pt(161, 139.5),
            fill: Color$1.rgb(242, 242, 242),
            layout: new TilingLayout({
              orderByIndex: true,
              padding: rect(3, 0, 0, 0),
              spacing: 2
            }),
            selectedDates: [],
            submorphs: range(1, 41).map(function (i) {
              return part(__varRecorder__$m.DateDefault, {
                master: {
                  auto: __varRecorder__$m.DateDefault,
                  hover: __varRecorder__$m.DateHover
                },
                name: "day " + i,
                dayNum: i
              });
            })
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/date.cp.js",
        "export": "DatePicker",
        range: {
          start: 25250,
          end: 29220
        }
      }, System, __varRecorder__$m, "DatePicker");
      __varRecorder__$m.DoubleDatePicker = component["for"](function () {
        return component({
          name: "double date picker",
          defaultViewModel: __varRecorder__$m.DoubleDatePickerModel,
          extent: pt(123.5, 82.1),
          fill: Color$1.transparent,
          layout: new TilingLayout({
            orderByIndex: true,
            wrapSubmorphs: false,
            hugContentsVertically: true,
            hugContentsHorizontally: true
          }),
          submorphs: [part(__varRecorder__$m.DatePicker, {
            name: "min date selector",
            borderRadius: {
              topLeft: 6,
              topRight: 0,
              bottomLeft: 6,
              bottomRight: 0
            },
            viewModel: {
              rangeSelection: true
            },
            submorphs: [{
              name: "monthLabel",
              textAndAttributes: ["Select date range", null]
            }, {
              name: "date input",
              opacity: 0,
              reactsToPointer: false
            }]
          }), part(__varRecorder__$m.DatePicker, {
            name: "max date selector",
            borderRadius: {
              topLeft: 0,
              topRight: 6,
              bottomLeft: 0,
              bottomRight: 6
            },
            viewModel: {
              rangeSelection: true
            },
            submorphs: [{
              name: "monthLabel",
              opacity: 0
            }, {
              name: "date input",
              opacity: 0,
              reactsToPointer: false
            }]
          }), {
            name: "date inputs",
            position: pt(0, 19),
            isLayoutable: false,
            borderColor: Color$1.rgb(23, 160, 251),
            borderWidth: 0,
            extent: pt(307.4, 45),
            fill: Color$1.rgba(0, 0, 0, 0),
            layout: new TilingLayout({
              justifySubmorphs: "spaced",
              orderByIndex: true,
              padding: rect(10, 10, 0, 0),
              wrapSubmorphs: false
            }),
            reactsToPointer: false,
            submorphs: [part(__varRecorder__$m.DateInput, {
              name: "start input",
              dropShadow: new ShadowObject({
                distance: 0,
                blur: 0
              })
            }), {
              type: Label,
              name: "arrow",
              fontColor: Color$1.rgb(253, 254, 254),
              fontSize: 22,
              fontWeight: 300,
              textAndAttributes: Icon.textAttribute("arrow-alt-circle-right")
            }, part(__varRecorder__$m.DateInput, {
              name: "end input",
              dropShadow: new ShadowObject({
                distance: 0,
                blur: 0
              })
            })]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/date.cp.js",
        "export": "DoubleDatePicker",
        range: {
          start: 29269,
          end: 31290
        }
      }, System, __varRecorder__$m, "DoubleDatePicker");
      var DateDefault = __varRecorder__$m.DateDefault;
      var DateInput = __varRecorder__$m.DateInput;
      var CalendarNavButton = __varRecorder__$m.CalendarNavButton;
      var DayOfWeek = __varRecorder__$m.DayOfWeek;
      var DatePicker = __varRecorder__$m.DatePicker;
      var DoubleDatePicker = __varRecorder__$m.DoubleDatePicker;
      __varRecorder__$m.DateDefault = DateDefault;
      __varRecorder__$m.DateInput = DateInput;
      __varRecorder__$m.CalendarNavButton = CalendarNavButton;
      __varRecorder__$m.DayOfWeek = DayOfWeek;
      __varRecorder__$m.DatePicker = DatePicker;
      __varRecorder__$m.DoubleDatePicker = DoubleDatePicker;
      __varRecorder__$m["default"] = DatePickerModel;

      var __varRecorder__$l = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/slider.cp.js", __contextModule__);
      var SliderModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/slider.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("SliderModel") && typeof __lively_classholder__.SliderModel === "function" ? __lively_classholder__.SliderModel : __lively_classholder__.SliderModel = function SliderModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "knob",
          get: function get() {
            return this.ui.knob;
          }
        }, {
          key: "minPos",
          get: function get() {
            return 0;
          }
        }, {
          key: "signalValueChanged",
          value: function SliderModel_signalValueChanged_() {
            signal(this, "valueChanged");
            signal(this.view, "valueChanged");
          }
        }, {
          key: "maxPos",
          get: function get() {
            return this.view.extent.x - this.knob.extent.x;
          }
        }, {
          key: "_normalizeValue_",
          value: function SliderModel__normalizeValue__(aValue) {
            aValue = Math.round(aValue / this.increment) * this.increment;
            return Math.max(Math.min(aValue, this.maxValue), this.minValue);
          }
        }, {
          key: "_xPosForValue_",
          value: function SliderModel__xPosForValue__(value) {
            if (value >= this.maxValue) {
              return this.maxPos;
            }

            if (value <= this.minValue) {
              return this.minPos;
            }

            value = this._normalizeValue_(value);
            return (value - this.minValue) / (this.maxValue - this.minValue) * (this.maxPos - this.minPos) + this.minPos;
          }
        }, {
          key: "valueForX",
          value: function SliderModel_valueForX_(xPos) {
            var value = (xPos - this.minPos) / (this.maxPos - this.minPos) * (this.maxValue - this.minValue) + this.minValue;
            return this._normalizeValue_(value);
          }
        }, {
          key: "setDefaults",
          value: function SliderModel_setDefaults_() {
            this.minValue = 0;
            this.maxValue = 100;
            this.increment = 1;
            this.value = 50;
          }
        }, {
          key: "_ensureProperties_",
          value: function SliderModel__ensureProperties__() {
            if (isNaN(this.maxValue) && isNaN(this.minValue)) {
              this.setDefaults();
            } else if (isNaN(this.maxValue)) {
              this.maxValue = this.minValue + 100;
              this.increment = 1;
            } else if (isNaN(this.minValue)) {
              this.minValue = this.maxValue - 100;
              this.increment = 1;
            } else if (isNaN(this.increment)) {
              this.increment = (this.maxValue - this.minValue) * 0.01;
            }
          }
        }, {
          key: "onLoad",
          value: function SliderModel_onLoad_() {
            this._ensureProperties_();
          }
        }, {
          key: "incrementValue",
          value: function SliderModel_incrementValue_() {
            this.value += this.increment;
          }
        }, {
          key: "decrementValue",
          value: function SliderModel_decrementValue_() {
            this.value -= this.increment;
          }
        }, {
          key: "_normalizePosition_",
          value: function SliderModel__normalizePosition__(x) {
            var normalX = Math.max(this.minPos, Math.min(this.maxPos, x - this.knob.width / 2));
            this.knob.position = pt(normalX, 0);
          }
        }, {
          key: "_doEvt_",
          value: function SliderModel__doEvt__($super, evt) {
            this._normalizePosition_(evt.positionIn(this.view).x);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "SliderModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              valueChanged: {
                derived: true,
                readOnly: true,
                isSignal: true
              },
              minValue: {
                defaultValue: 0
              },
              maxValue: {
                defaultValue: 100
              },
              increment: {
                defaultValue: 1,
                set: function set(aVal) {
                  this.setProperty("increment", aVal || 1);
                }
              },
              value: {
                after: ["submorphs", "minValue", "maxValue", "increment"],
                set: function set(aValue) {
                  if (aValue === this.value) {
                    return;
                  }

                  aValue = this._normalizeValue_(aValue);

                  var xPos = this._xPosForValue_(aValue);

                  if (this.view) {
                    this.knob.position = pt(xPos, 0);
                  }
                },
                get: function get() {
                  if (this.knob) {
                    return this.valueForX(this.knob.position.x);
                  } else {
                    return this._normalizeValue_((this.maxValue + this.minValue) / 2);
                  }
                }
              },
              expose: {
                get: function get() {
                  return ["value", "maxValue", "minValue", "increment"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "knob",
                    signal: "position",
                    handler: "signalValueChanged"
                  }, {
                    signal: "onMouseDown",
                    handler: "_doEvt_",
                    override: true
                  }, {
                    signal: "onDragStart",
                    handler: "_doEvt_",
                    override: true
                  }, {
                    signal: "onDragEnd",
                    handler: "_doEvt_",
                    override: true
                  }, {
                    signal: "onDrag",
                    handler: "_doEvt_",
                    override: true
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/inputs/slider.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 388,
          end: 6079
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$l.SliderModel = SliderModel;
      __varRecorder__$l.SliderModel = SliderModel;

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/slider.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("SliderInputLabelMorph") && typeof __lively_classholder__.SliderInputLabelMorph === "function" ? __lively_classholder__.SliderInputLabelMorph : __lively_classholder__.SliderInputLabelMorph = function SliderInputLabelMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onInput",
          value: function SliderInputLabelMorph_onInput_() {
            signal(this, "inputChanged");
          }
        }, {
          key: "relayout",
          value: function SliderInputLabelMorph_relayout_() {
            var _this = this;

            if (this.fitting) this[this.fitting]();
            this.submorphs.forEach(function (m) {
              m.center = m.center.withX(_this.width / 2);
            });
          }
        }, {
          key: "scaleToFit",
          value: function SliderInputLabelMorph_scaleToFit_() {
            var defaultFontSize = 13;
            var defaultPadding = 8;
            var valueContainer = this.getSubmorphNamed("sliderValue");
            var nominalWidth = valueContainer.env.fontMetric.measure({
              fontFamily: valueContainer.fontFamily,
              fontSize: 13
            }, valueContainer.input).width + this.defaultWidth / 2;
            valueContainer.fontSize = defaultFontSize * Math.min(1, (this.width - defaultPadding) / nominalWidth);
          }
        }, {
          key: "fitToContent",
          value: function SliderInputLabelMorph_fitToContent_() {
            var valueContainer = this.getSubmorphNamed("sliderValue");
            valueContainer.width = valueContainer.textBounds().width + 10;
          }
        }, {
          key: "clipContent",
          value: function SliderInputLabelMorph_clipContent_() {
            this.getSubmorphNamed("sliderValue").width = this.defaultWidth;
          }
        }, {
          key: "onMouseUp",
          value: function SliderInputLabelMorph_onMouseUp_(evt) {
            var _this2 = this;

            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onMouseUp", this).call(this, evt);

            var actions = {
              "increment button": function incrementButton() {
                return signal(_this2, "increment");
              },
              "decrement button": function decrementButton() {
                return signal(_this2, "decrement");
              }
            };
            var action = actions[evt.targetMorph.name];
            if (action) action();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "SliderInputLabelMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              defaultWidth: {
                readOnly: true,
                get: function get() {
                  return 36;
                }
              },
              fitting: {
                type: "Enum",
                values: ["scaleToFit", "fitToContent", "clipContent"],
                defaultValue: "scaleToFit"
              },
              value: {
                derived: true,
                set: function set(v) {
                  this.getSubmorphNamed("sliderValue").input = String(v);
                  this.relayout();
                },
                get: function get() {
                  return this.getSubmorphNamed("sliderValue").input;
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/inputs/slider.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 6081,
          end: 7845
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/slider.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("SliderKnob") && typeof __lively_classholder__.SliderKnob === "function" ? __lively_classholder__.SliderKnob : __lively_classholder__.SliderKnob = function SliderKnob(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "_normalizePosition_",
          value: function SliderKnob__normalizePosition__() {
            var x = this.position.x;
            var maxPosition = this.owner.extent.x - this.width;
            this.position = pt(Math.max(0, Math.min(maxPosition, x)), 0);

            this._updateValue_();
          }
        }, {
          key: "onDragStart",
          value: function SliderKnob_onDragStart_(evt) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onDragStart", this).call(this, evt);

            this._normalizePosition_();
          }
        }, {
          key: "onDrag",
          value: function SliderKnob_onDrag_(evt) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onDrag", this).call(this, evt);

            this._normalizePosition_();
          }
        }, {
          key: "onDragEnd",
          value: function SliderKnob_onDragEnd_(evt) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onDragEnd", this).call(this, evt);

            this._normalizePosition_();
          }
        }, {
          key: "_updateValue_",
          value: function SliderKnob__updateValue__() {}
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "SliderKnob";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/inputs/slider.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 7847,
          end: 9008
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/slider.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DoubleSliderModel") && typeof __lively_classholder__.DoubleSliderModel === "function" ? __lively_classholder__.DoubleSliderModel : __lively_classholder__.DoubleSliderModel = function DoubleSliderModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "onRefresh",
          value: function DoubleSliderModel_onRefresh_() {
            this.ui.minKnob.position = pt(this._xForValue_(this.range.min), 0);
            this.ui.maxKnob.position = pt(this._xForValue_(this.range.max), 0);
            this.updateConnector();
          }
        }, {
          key: "updateConnector",
          value: function DoubleSliderModel_updateConnector_() {
            var _this$ui = this.ui,
                conn = _this$ui.connector,
                maxKnob = _this$ui.maxKnob,
                minKnob = _this$ui.minKnob,
                sliderCenter = _this$ui.sliderCenter;
            conn.width = maxKnob.center.subPt(minKnob.center).x;
            conn.left = minKnob.center.x;
            conn.position.y = sliderCenter.position.y;
            this.signalRangeChanged();
          }
        }, {
          key: "confirm",
          value: function DoubleSliderModel_confirm_() {
            var _this$ui2 = this.ui,
                minKnob = _this$ui2.minKnob,
                maxKnob = _this$ui2.maxKnob;
            this.range = {
              min: this.valueForX(minKnob.position.x),
              max: this.valueForX(maxKnob.position.x)
            };
          }
        }, {
          key: "signalRangeChanged",
          value: function DoubleSliderModel_signalRangeChanged_() {
            signal(this, "rangeChanged");
            signal(this.view, "rangeChanged");
          }
        }, {
          key: "maxPosition",
          get: function get() {
            return this.view.extent.x - this.ui.maxKnob.width;
          }
        }, {
          key: "positionRanges",
          get: function get() {
            var _this$ui3 = this.ui,
                maxKnob = _this$ui3.maxKnob,
                minKnob = _this$ui3.minKnob;
            return {
              "min knob": {
                min: 0,
                max: maxKnob.position.x - minKnob.width
              },
              "max knob": {
                min: minKnob.position.x + minKnob.width,
                max: this.maxPosition
              }
            };
          }
        }, {
          key: "_normalizeValue_",
          value: function DoubleSliderModel__normalizeValue__(aValue) {
            var increment = isNaN(this.increment) ? 1 : 1;
            var value = Math.round(aValue / increment) * increment;
            return Math.max(Math.min(this.maxValue, value), this.minValue);
          }
        }, {
          key: "_valueRange_",
          get: function get() {
            return this.maxValue - this.minValue;
          }
        }, {
          key: "_proportionalValue_",
          value: function DoubleSliderModel__proportionalValue__(aValue) {
            return (aValue - this.minValue) / this._valueRange_;
          }
        }, {
          key: "_proportionalRange_",
          value: function DoubleSliderModel__proportionalRange__(xPos) {
            return xPos / this.maxPosition;
          }
        }, {
          key: "_xForValue_",
          value: function DoubleSliderModel__xForValue__(aValue) {
            return this._proportionalValue_(aValue) * this.maxPosition;
          }
        }, {
          key: "valueForX",
          value: function DoubleSliderModel_valueForX_(anX) {
            return this._normalizeValue_(this._proportionalRange_(anX) * this._valueRange_ + this.minValue);
          }
        }, {
          key: "_startDraggingClosestHandle",
          value: function DoubleSliderModel__startDraggingClosestHandle_($super, evt) {
            var _this$ui4 = this.ui,
                minKnob = _this$ui4.minKnob,
                maxKnob = _this$ui4.maxKnob;

            if (evt.positionIn(minKnob).r() < evt.positionIn(maxKnob).r()) {
              this._draggedHandle = minKnob;
            } else {
              this._draggedHandle = maxKnob;
            }
          }
        }, {
          key: "_stopDraggingHandle",
          value: function DoubleSliderModel__stopDraggingHandle_() {
            this._draggedHandle = null;
          }
        }, {
          key: "_dragSelectedKnob",
          value: function DoubleSliderModel__dragSelectedKnob_($super, evt) {
            if (this._draggedHandle) {
              this._draggedHandle.onDrag(evt);
            }

            this.confirm();
          }
        }, {
          key: "incrementMinValue",
          value: function DoubleSliderModel_incrementMinValue_() {
            var _this$range = this.range,
                min = _this$range.min,
                max = _this$range.max;
            this.range = {
              min: min + 1,
              max: max
            };
          }
        }, {
          key: "decrementMinValue",
          value: function DoubleSliderModel_decrementMinValue_() {
            var _this$range2 = this.range,
                min = _this$range2.min,
                max = _this$range2.max;
            this.range = {
              min: min - 1,
              max: max
            };
          }
        }, {
          key: "incrementMaxValue",
          value: function DoubleSliderModel_incrementMaxValue_() {
            var _this$range3 = this.range,
                min = _this$range3.min,
                max = _this$range3.max;
            this.range = {
              min: min,
              max: max + 1
            };
          }
        }, {
          key: "decrementMaxValue",
          value: function DoubleSliderModel_decrementMaxValue_() {
            var _this$range4 = this.range,
                min = _this$range4.min,
                max = _this$range4.max;
            this.range = {
              min: min,
              max: max - 1
            };
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DoubleSliderModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              rangeChanged: {
                derived: true,
                readOnly: true,
                isSignal: true
              },
              minValue: {
                defaultValue: 0
              },
              maxValue: {
                defaultValue: 100
              },
              increment: {
                defaultValue: 1
              },
              range: {
                after: ["minValue", "maxValue", "increment"],
                set: function set(aRange) {
                  var minVal = this._normalizeValue_(aRange.min);

                  var maxVal = this._normalizeValue_(aRange.max);

                  if (maxVal === minVal) {
                    if (maxVal === this.maxValue) {
                      minVal = maxVal - this.increment;
                    } else {
                      maxVal = minVal + this.increment;
                    }
                  }

                  if (this.view) {
                    this.ui.minKnob.position = pt(this._xForValue_(minVal), 0);
                    this.ui.maxKnob.position = pt(this._xForValue_(maxVal), 0);
                    this.updateConnector();
                  }
                },
                get: function get() {
                  return this.view ? {
                    min: this.valueForX(this.ui.minKnob.position.x),
                    max: this.valueForX(this.ui.maxKnob.position.x)
                  } : {
                    min: this.minValue,
                    max: this.maxValue
                  };
                }
              },
              expose: {
                get: function get() {
                  return ["rangeChanged", "positionRanges", "updateConnector", "minValue", "maxValue", "increment"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    model: "max knob",
                    signal: "position",
                    handler: "signalRangeChanged"
                  }, {
                    model: "min knob",
                    signal: "position",
                    handler: "signalRangeChanged"
                  }, {
                    signal: "onDragStart",
                    handler: "_startDraggingClosestHandle",
                    override: true
                  }, {
                    signal: "onDragEnd",
                    handler: "_stopDraggingHandle",
                    override: true
                  }, {
                    signal: "onDrag",
                    handler: "_dragSelectedKnob",
                    override: true
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/inputs/slider.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 9010,
          end: 15826
        });
      })({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/slider.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DoubleSliderKnob") && typeof __lively_classholder__.DoubleSliderKnob === "function" ? __lively_classholder__.DoubleSliderKnob : __lively_classholder__.DoubleSliderKnob = function DoubleSliderKnob(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "_normalizePosition_",
          value: function DoubleSliderKnob__normalizePosition__() {
            var positionRange = this.owner.positionRanges[this.name];
            var x = Math.min(positionRange.max, Math.max(positionRange.min, this.position.x));
            this.position = pt(x, 0);

            this._updateValue_();
          }
        }, {
          key: "onDragStart",
          value: function DoubleSliderKnob_onDragStart_(evt) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onDragStart", this).call(this, evt);

            this._normalizePosition_();
          }
        }, {
          key: "onDrag",
          value: function DoubleSliderKnob_onDrag_(evt) {
            this.center = evt.positionIn(this.owner).withY(this.owner.height / 2);

            this._normalizePosition_();
          }
        }, {
          key: "onDragEnd",
          value: function DoubleSliderKnob_onDragEnd_(evt) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onDragEnd", this).call(this, evt);

            this._normalizePosition_();
          }
        }, {
          key: "_updateValue_",
          value: function DoubleSliderKnob__updateValue__() {
            this.owner.updateConnector();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DoubleSliderKnob";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/inputs/slider.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 15828,
          end: 17055
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/slider.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("SliderWithValueModel") && typeof __lively_classholder__.SliderWithValueModel === "function" ? __lively_classholder__.SliderWithValueModel : __lively_classholder__.SliderWithValueModel = function SliderWithValueModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "viewDidLoad",
          value: function SliderWithValueModel_viewDidLoad_() {
            this.updateValue();
          }
        }, {
          key: "signalValueChanged",
          value: function SliderWithValueModel_signalValueChanged_() {
            signal(this, "valueChanged");
            signal(this.view, "valueChanged");
          }
        }, {
          key: "updateValue",
          value: function SliderWithValueModel_updateValue_() {
            this.ui.valueInput.value = this.models.slider.value;
          }
        }, {
          key: "setSliderValue",
          value: function SliderWithValueModel_setSliderValue_() {
            this.models.slider.value = this.ui.valueInput.value;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "SliderWithValueModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              valueChanged: {
                derived: true,
                isSignal: true,
                readOnly: true
              },
              expose: {
                get: function get() {
                  return [["value", {
                    model: "slider"
                  }], ["minValue", {
                    model: "slider"
                  }], ["maxValue", {
                    model: "slider"
                  }], ["increment", {
                    model: "slider"
                  }]];
                }
              },
              bindings: {
                get: function get() {
                  var _this3 = this;

                  return [{
                    target: "slider",
                    signal: "valueChanged",
                    handler: "signalValueChanged"
                  }, {
                    target: "slider",
                    signal: "valueChanged",
                    handler: "updateValue"
                  }, {
                    target: "value input",
                    signal: "onInput",
                    handler: "setSliderValue"
                  }, {
                    target: "value input",
                    signal: "decrement",
                    handler: function handler() {
                      _this3.models.slider.decrementValue();
                    }
                  }, {
                    target: "value input",
                    signal: "increment",
                    handler: function handler() {
                      _this3.models.slider.incrementValue();
                    }
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/inputs/slider.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 17057,
          end: 19465
        });
      })({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/inputs/slider.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DoubleSliderWithValuesModel") && typeof __lively_classholder__.DoubleSliderWithValuesModel === "function" ? __lively_classholder__.DoubleSliderWithValuesModel : __lively_classholder__.DoubleSliderWithValuesModel = function DoubleSliderWithValuesModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "signalRangeChanged",
          value: function DoubleSliderWithValuesModel_signalRangeChanged_() {
            signal(this, "rangeChanged");
            signal(this.view, "rangeChanged");
            this.displayRange();
          }
        }, {
          key: "viewDidLoad",
          value: function DoubleSliderWithValuesModel_viewDidLoad_() {
            this.displayRange();
          }
        }, {
          key: "displayRange",
          value: function DoubleSliderWithValuesModel_displayRange_() {
            var doubleSlider = this.models.doubleSlider;
            var _this$ui5 = this.ui,
                minInput = _this$ui5.minInput,
                maxInput = _this$ui5.maxInput;
            var range = doubleSlider.range;
            minInput.value = range.min;
            maxInput.value = range.max;
          }
        }, {
          key: "setRange",
          value: function DoubleSliderWithValuesModel_setRange_() {
            var _this$ui6 = this.ui,
                minInput = _this$ui6.minInput,
                maxInput = _this$ui6.maxInput;
            var range = {
              min: minInput.value,
              max: maxInput.value
            };
            this.models.doubleSlider.range = range;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DoubleSliderWithValuesModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              rangeChanged: {
                derived: true,
                isSignal: true,
                readOnly: true
              },
              expose: {
                get: function get() {
                  return [["minValue", {
                    model: "double slider"
                  }], ["maxValue", {
                    model: "double slider"
                  }], ["increment", {
                    model: "double slider"
                  }], ["range", {
                    model: "double slider"
                  }], "rangeChanged"];
                }
              },
              bindings: {
                get: function get() {
                  var _this4 = this;

                  return [{
                    target: "double slider",
                    signal: "rangeChanged",
                    handler: "signalRangeChanged"
                  }, {
                    target: "min input",
                    signal: "decrement",
                    handler: function handler() {
                      _this4.models.doubleSlider.decrementMinValue();
                    }
                  }, {
                    target: "min input",
                    signal: "increment",
                    handler: function handler() {
                      _this4.models.doubleSlider.incrementMinValue();
                    }
                  }, {
                    target: "min input",
                    signal: "onInput",
                    handler: "setRange"
                  }, {
                    target: "max input",
                    signal: "decrement",
                    handler: function handler() {
                      _this4.models.doubleSlider.decrementMaxValue();
                    }
                  }, {
                    target: "max input",
                    signal: "increment",
                    handler: function handler() {
                      _this4.models.doubleSlider.incrementMaxValue();
                    }
                  }, {
                    target: "max input",
                    signal: "onInput",
                    handler: "setRange"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/inputs/slider.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 19467,
          end: 22830
        });
      })({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      __varRecorder__$l.IncrementButton = component["for"](function () {
        return component({
          type: Label,
          name: "increment button",
          lineHeight: 1,
          fontColor: Color$1.rgb(151, 154, 154),
          fontSize: 35,
          nativeCursor: "pointer",
          position: pt(1328.8, 186.3),
          textAndAttributes: Icon.textAttribute("caret-up")
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/slider.cp.js",
        "export": "IncrementButton",
        range: {
          start: 22838,
          end: 23095
        }
      }, System, __varRecorder__$l, "IncrementButton");
      __varRecorder__$l.IncrementButtonClick = component["for"](function () {
        return component(__varRecorder__$l.IncrementButton, {
          name: "increment button/click",
          fontColor: Color$1.rgb(112, 123, 124)
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/slider.cp.js",
        "export": "IncrementButtonClick",
        range: {
          start: 23104,
          end: 23230
        }
      }, System, __varRecorder__$l, "IncrementButtonClick");
      __varRecorder__$l.SliderInputLabel = component["for"](function () {
        return component({
          name: "slider value label",
          type: __varRecorder__$l.SliderInputLabelMorph,
          extent: pt(39.6, 94.4),
          fill: Color$1.transparent,
          layout: new TilingLayout({
            align: "center",
            axis: "column",
            axisAlign: "center",
            orderByIndex: true,
            wrapSubmorphs: false
          }),
          submorphs: [part(__varRecorder__$l.IncrementButton, {
            name: "increment button",
            master: {
              auto: __varRecorder__$l.IncrementButton,
              click: __varRecorder__$l.IncrementButtonClick
            }
          }), {
            type: InputLine,
            name: "sliderValue",
            borderWidth: 3,
            borderRadius: 3,
            borderColor: Color$1.gray,
            extent: pt(35.3, 29.2),
            fontSize: 13,
            fontWeight: "bold",
            haloShadow: new ShadowObject({
              blur: 6,
              color: Color$1.fromLiteral({
                a: 1,
                b: 0.8588235294117647,
                g: 0.596078431372549,
                r: 0.20392156862745098
              }),
              distance: 0,
              rotation: 45
            }),
            padding: rect(3, 3, 0, 0),
            placeholder: "Enter Value",
            textAlign: "center",
            textAndAttributes: ["1", null]
          }, part(__varRecorder__$l.IncrementButton, {
            name: "decrement button",
            rotation: Math.PI,
            master: {
              auto: __varRecorder__$l.IncrementButton,
              click: __varRecorder__$l.IncrementButtonClick
            }
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/slider.cp.js",
        "export": "SliderInputLabel",
        range: {
          start: 23239,
          end: 24466
        }
      }, System, __varRecorder__$l, "SliderInputLabel");
      __varRecorder__$l.Slider = component["for"](function () {
        return component({
          defaultViewModel: __varRecorder__$l.SliderModel,
          name: "slider",
          acceptsDrops: false,
          borderColor: Color$1.rgb(23, 160, 251),
          draggable: true,
          extent: pt(200, 30),
          fill: Color$1.rgba(0, 0, 0, 0),
          value: 68,
          submorphs: [{
            name: "slider center",
            borderColor: Color$1.rgb(23, 160, 251),
            borderRadius: 3,
            extent: pt(200, 11.4),
            position: pt(0, 9),
            fill: Color$1.rgb(127, 140, 141),
            reactsToPointer: false
          }, {
            type: __varRecorder__$l.SliderKnob,
            name: "knob",
            borderColor: Color$1.rgb(23, 160, 251),
            borderRadius: 35,
            draggable: true,
            extent: pt(29.7, 30.2),
            fill: Color$1.rgb(66, 73, 73),
            nativeCursor: "grab",
            position: pt(116.5, 0)
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/slider.cp.js",
        "export": "Slider",
        range: {
          start: 24475,
          end: 25170
        }
      }, System, __varRecorder__$l, "Slider");
      __varRecorder__$l.DoubleSlider = component["for"](function () {
        return component({
          defaultViewModel: __varRecorder__$l.DoubleSliderModel,
          name: "double slider",
          borderColor: Color$1.rgb(23, 160, 251),
          draggable: true,
          extent: pt(200, 30),
          fill: Color$1.rgba(0, 0, 0, 0),
          submorphs: [{
            name: "slider center",
            borderColor: Color$1.rgb(23, 160, 251),
            borderRadius: 3,
            extent: pt(200, 11.4),
            fill: Color$1.rgb(127, 140, 141),
            position: pt(0, 10.2),
            reactsToPointer: false
          }, {
            type: __varRecorder__$l.DoubleSliderKnob,
            name: "min knob",
            borderColor: Color$1.rgb(23, 160, 251),
            borderRadius: 35,
            draggable: true,
            extent: pt(29.7, 30.2),
            fill: Color$1.rgb(66, 73, 73),
            nativeCursor: "grab",
            position: pt(29, 0)
          }, {
            type: __varRecorder__$l.DoubleSliderKnob,
            name: "max knob",
            borderColor: Color$1.rgb(23, 160, 251),
            borderRadius: 35,
            draggable: true,
            extent: pt(29.7, 30.2),
            fill: Color$1.rgb(66, 73, 73),
            nativeCursor: "grab",
            position: pt(139.6, 0)
          }, {
            name: "connector",
            borderColor: Color$1.rgb(23, 160, 251),
            extent: pt(110.7, 12.3),
            fill: Color$1.rgb(66, 73, 73),
            position: pt(43.8, 9),
            reactsToPointer: false
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/slider.cp.js",
        "export": "DoubleSlider",
        range: {
          start: 25179,
          end: 26311
        }
      }, System, __varRecorder__$l, "DoubleSlider");
      __varRecorder__$l.SliderWithValue = component["for"](function () {
        return component({
          name: "slider with value",
          defaultViewModel: __varRecorder__$l.SliderWithValueModel,
          extent: pt(250, 100),
          layout: new TilingLayout({
            axisAlign: "center",
            align: "left",
            axis: "row",
            orderByIndex: true,
            spacing: 5,
            wrapSubmorphs: false
          }),
          fill: Color$1.transparent,
          submorphs: [part(__varRecorder__$l.Slider, {
            name: "slider",
            submorphs: [{
              name: "knob",
              position: pt(84.4, 0)
            }]
          }), part(__varRecorder__$l.SliderInputLabel, {
            name: "value input"
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/slider.cp.js",
        "export": "SliderWithValue",
        range: {
          start: 26320,
          end: 26832
        }
      }, System, __varRecorder__$l, "SliderWithValue");
      __varRecorder__$l.DoubleSliderWithValues = component["for"](function () {
        return component({
          name: "double slider with values",
          defaultViewModel: __varRecorder__$l.DoubleSliderWithValuesModel,
          extent: pt(295, 100),
          layout: new TilingLayout({
            axisAlign: "center",
            orderByIndex: true,
            spacing: 5,
            wrapSubmorphs: false
          }),
          fill: Color$1.transparent,
          submorphs: [part(__varRecorder__$l.SliderInputLabel, {
            name: "min input"
          }), part(__varRecorder__$l.DoubleSlider, {
            name: "double slider"
          }), part(__varRecorder__$l.SliderInputLabel, {
            name: "max input"
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/inputs/slider.cp.js",
        "export": "DoubleSliderWithValues",
        range: {
          start: 26841,
          end: 27313
        }
      }, System, __varRecorder__$l, "DoubleSliderWithValues");
      var SliderInputLabel = __varRecorder__$l.SliderInputLabel;
      var Slider = __varRecorder__$l.Slider;
      var DoubleSlider = __varRecorder__$l.DoubleSlider;
      var SliderWithValue = __varRecorder__$l.SliderWithValue;
      var DoubleSliderWithValues = __varRecorder__$l.DoubleSliderWithValues;
      __varRecorder__$l.SliderInputLabel = SliderInputLabel;
      __varRecorder__$l.Slider = Slider;
      __varRecorder__$l.DoubleSlider = DoubleSlider;
      __varRecorder__$l.SliderWithValue = SliderWithValue;
      __varRecorder__$l.DoubleSliderWithValues = DoubleSliderWithValues;

      var __varRecorder__$k = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/filters.cp.js", __contextModule__);
      __varRecorder__$k.VisualFilter = component["for"](function () {
        return component({
          name: "visual filter",
          borderColor: Color$1.rgb(128, 128, 128),
          borderRadius: 10,
          borderWidth: 1,
          nativeCursor: "drag",
          draggable: true,
          dropShadow: false,
          extent: pt(103, 44),
          fill: Color$1.rgba(0, 0, 0, 0.05),
          position: pt(64.9, 294.1),
          reactsToPointer: false,
          layout: new TilingLayout({
            autoResize: true,
            axisAlign: "center",
            align: "top",
            axis: "column",
            hugContentsVertically: true,
            hugContentsHorizontally: true,
            orderByIndex: true,
            padding: rect(0, 0, 0, 0),
            resizeSubmorphs: false,
            spacing: 0,
            wrapSubmorphs: false
          })
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/filters.cp.js",
        "export": "VisualFilter",
        range: {
          start: 718,
          end: 1372
        }
      }, System, __varRecorder__$k, "VisualFilter");
      var BooleanFilterMorph = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/filters.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("BooleanFilterMorph") && typeof __lively_classholder__.BooleanFilterMorph === "function" ? __lively_classholder__.BooleanFilterMorph : __lively_classholder__.BooleanFilterMorph = function BooleanFilterMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "init",
          value: function BooleanFilterMorph_init_(columnName, tableName) {
            this.columnName = columnName;
            this.tableName = tableName;
            var toggle = this.getSubmorphNamed("toggle");
            toggle.state = true;
            connect(toggle, "state", this, "signalFilterChanged");
          }
        }, {
          key: "signalFilterChanged",
          value: function BooleanFilterMorph_signalFilterChanged_() {
            signal(this, "filterChanged");
          }
        }, {
          key: "filter",
          get: function get() {
            return {
              columnName: this.columnName,
              value: this.getSubmorphNamed("toggle").state
            };
          }
        }, {
          key: "dataManagerFilter",
          get: function get() {
            return {
              column: this.columnName,
              operator: "IN_LIST",
              values: [this.getSubmorphNamed("toggle").state]
            };
          }
        }, {
          key: "filterString",
          get: function get() {
            return "".concat(this.columnName, " = ").concat(this.getSubmorphNamed("toggle").state);
          }
        }, {
          key: "persistentForm",
          get: function get() {
            return {
              part: this.part,
              filterType: this.filterType,
              columnName: this.columnName,
              tableName: this.tableName,
              state: this.getSubmorphNamed("toggle").state
            };
          }
        }, {
          key: "restoreFromSavedForm",
          value: function BooleanFilterMorph_restoreFromSavedForm_(savedForm) {
            this.init(savedForm.columnName, savedForm.tableName);
            this.signalEnabled = false;
            this.getSubmorphNamed("toggle").state = savedForm.state;
            this.signalEnabled = true;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "BooleanFilterMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              columnName: {
                defaultValue: null
              },
              tableName: {
                defaultValue: null
              },
              filterType: {
                serialize: false,
                get: function get() {
                  return "Boolean";
                }
              },
              widgetType: {
                serialize: false,
                get: function get() {
                  return "toggle";
                }
              },
              part: {
                serialize: false,
                get: function get() {
                  return __varRecorder__$k.BooleanFilter[Symbol["for"]("lively-module-meta")];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/filters.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 2245,
          end: 5849
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$k.BooleanFilterMorph = BooleanFilterMorph;
      __varRecorder__$k.BooleanFilterMorph = BooleanFilterMorph;
      __varRecorder__$k.BooleanFilter = component["for"](function () {
        return component(__varRecorder__$k.VisualFilter, {
          name: "boolean filter",
          type: __varRecorder__$k.BooleanFilterMorph,
          nativeCursor: "grab",
          submorphs: [add(part(Toggle, {
            name: "toggle"
          }))]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/filters.cp.js",
        "export": "BooleanFilter",
        range: {
          start: 5894,
          end: 6077
        }
      }, System, __varRecorder__$k, "BooleanFilter");
      var DateFilterMorph = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/filters.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DateFilterMorph") && typeof __lively_classholder__.DateFilterMorph === "function" ? __lively_classholder__.DateFilterMorph : __lively_classholder__.DateFilterMorph = function DateFilterMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "init",
          value: function DateFilterMorph_init_(columnName, tableName) {
            this.signalEnabled = false;
            var selector = this.datePicker;
            this.columnName = columnName;
            this.tableName = tableName;
            selector.setDate(new Date());
            this.signalEnabled = true;
          }
        }, {
          key: "dateChanged",
          value: function DateFilterMorph_dateChanged_() {
            signal(this, "filterChanged");
          }
        }, {
          key: "datePicker",
          get: function get() {
            return this.getSubmorphNamed("date picker").viewModel;
          }
        }, {
          key: "filter",
          get: function get() {
            return {
              columnName: this.columnName,
              value: this.datePicker.selectedDate
            };
          }
        }, {
          key: "dataManagerFilter",
          get: function get() {
            return {
              column: this.columnName,
              operator: "IN_LIST",
              values: [this.datePicker.selectedDate]
            };
          }
        }, {
          key: "filterString",
          get: function get() {
            return "".concat(this.columnName, " == ").concat(this.datePicker.selectedDate);
          }
        }, {
          key: "persistentForm",
          get: function get() {
            return {
              part: this.part,
              tableName: this.tableName,
              filterType: this.filterType,
              columnName: this.columnName,
              selectedDate: this.datePicker.selectedDate
            };
          }
        }, {
          key: "restoreFromSavedForm",
          value: function DateFilterMorph_restoreFromSavedForm_(savedForm) {
            this.init(savedForm.columnName, savedForm.tableName);
            var datePicker = this.datePicker;
            noUpdate(function () {
              datePicker.value = datePicker.value;
            });
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DateFilterMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              columnName: {
                defaultValue: null
              },
              tableName: {
                defaultValue: null
              },
              filterType: {
                serialize: false,
                get: function get() {
                  return "DateSelect";
                }
              },
              widgetType: {
                serialize: false,
                get: function get() {
                  return "DatePicker";
                }
              },
              part: {
                serialize: false,
                get: function get() {
                  return __varRecorder__$k.DateFilter[Symbol["for"]("lively-module-meta")];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/filters.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 6974,
          end: 10817
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$k.DateFilterMorph = DateFilterMorph;
      __varRecorder__$k.DateFilterMorph = DateFilterMorph;
      __varRecorder__$k.DateFilter = component["for"](function () {
        return component(__varRecorder__$k.VisualFilter, {
          name: "date filter",
          type: __varRecorder__$k.DateFilterMorph,
          submorphs: [add(part(DatePicker, {
            name: "date picker"
          }))]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/filters.cp.js",
        "export": "DateFilter",
        range: {
          start: 10859,
          end: 11018
        }
      }, System, __varRecorder__$k, "DateFilter");
      var DoubleSliderFilterMorph = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/filters.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DoubleSliderFilterMorph") && typeof __lively_classholder__.DoubleSliderFilterMorph === "function" ? __lively_classholder__.DoubleSliderFilterMorph : __lively_classholder__.DoubleSliderFilterMorph = function DoubleSliderFilterMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "doubleSlider",
          get: function get() {
            return this.getSubmorphNamed("double slider");
          }
        }, {
          key: "init",
          value: function DoubleSliderFilterMorph_init_(columnName, tableName, minVal, maxVal, increment) {
            this.signalEnabled = false;
            var doubleSlider = this.doubleSlider;
            this.minValue = doubleSlider.minValue = minVal;
            this.maxValue = doubleSlider.maxValue = maxVal;
            this.increment = doubleSlider.increment = increment;
            doubleSlider.range = {
              min: minVal,
              max: maxVal
            };
            this.columnName = columnName;
            this.tableName = tableName;
            this.signalEnabled = true;
            connect(doubleSlider, "rangeChanged", this, "signalRangeChanged");
          }
        }, {
          key: "signalRangeChanged",
          value: function DoubleSliderFilterMorph_signalRangeChanged_() {
            var _this = this;

            if (this.signalEnabled) {
              this.signalEnabled = false;
              setTimeout(function (_) {
                signal(_this, "filterChanged");
                _this.signalEnabled = true;
              }, 100);
            }
          }
        }, {
          key: "filter",
          get: function get() {
            var range = this.doubleSlider.range;
            return {
              columnName: this.columnName,
              maxValue: range.max,
              minValue: range.min
            };
          }
        }, {
          key: "dataManagerFilter",
          get: function get() {
            var range = this.doubleSlider.range;
            return {
              operator: "IN_RANGE",
              column: this.columnName,
              max_val: range.max,
              min_val: range.min
            };
          }
        }, {
          key: "filterString",
          get: function get() {
            var range = this.doubleSlider.range;
            return "".concat(range.max, " >= ").concat(this.columnName, " >= ").concat(range.min);
          }
        }, {
          key: "persistentForm",
          get: function get() {
            var doubleSlider = this.doubleSlider;
            var range = doubleSlider.range;
            return {
              part: this.part,
              tableName: this.tableName,
              filterType: this.filterType,
              columnName: this.columnName,
              minVal: doubleSlider.minValue,
              maxVal: doubleSlider.maxValue,
              min: range.min,
              max: range.max,
              increment: doubleSlider.increment
            };
          }
        }, {
          key: "restoreFromSavedForm",
          value: function DoubleSliderFilterMorph_restoreFromSavedForm_(savedForm) {
            this.init(savedForm.columnName, savedForm.tableName, savedForm.minVal, savedForm.maxVal, savedForm.increment);
            this.signalEnabled = false;
            this.increment = savedForm.increment;
            this.doubleSlider.range = {
              min: savedForm.min,
              max: savedForm.max
            };
            this.signalEnabled = true;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DoubleSliderFilterMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              filterChanged: {
                derived: true,
                readOnly: true,
                isSignal: true
              },
              columnName: {
                defaultValue: null
              },
              tableName: {
                defaultValue: null
              },
              minValue: {
                defaultValue: null
              },
              maxValue: {
                defaultValue: null
              },
              signalEnabled: {
                defaultValue: false
              },
              filterType: {
                serialize: false,
                get: function get() {
                  return "Range";
                }
              },
              widgetType: {
                serialize: false,
                get: function get() {
                  return "doubleSlider";
                }
              },
              part: {
                serialize: false,
                get: function get() {
                  return __varRecorder__$k.DoubleSliderFilter[Symbol["for"]("lively-module-meta")];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/filters.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 12137,
          end: 18081
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$k.DoubleSliderFilterMorph = DoubleSliderFilterMorph;
      __varRecorder__$k.DoubleSliderFilterMorph = DoubleSliderFilterMorph;
      __varRecorder__$k.DoubleSliderFilter = component["for"](function () {
        return component(__varRecorder__$k.VisualFilter, {
          name: "double slider filter",
          type: __varRecorder__$k.DoubleSliderFilterMorph,
          layout: new TilingLayout({
            align: "center",
            axis: "column",
            axisAlign: "center",
            hugContentsHorizontally: true,
            hugContentsVertically: true,
            orderByIndex: true,
            padding: rect(10, 0, 0, 0)
          }),
          submorphs: [add(part(DoubleSliderWithValues, {
            name: "double slider"
          }))]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/filters.cp.js",
        "export": "DoubleSliderFilter",
        range: {
          start: 18131,
          end: 18553
        }
      }, System, __varRecorder__$k, "DoubleSliderFilter");
      var ListFilterMorph = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/filters.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ListFilterMorph") && typeof __lively_classholder__.ListFilterMorph === "function" ? __lively_classholder__.ListFilterMorph : __lively_classholder__.ListFilterMorph = function ListFilterMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "valueList",
          get: function get() {
            return this.getSubmorphNamed("value list");
          }
        }, {
          key: "init",
          value: function ListFilterMorph_init_(columnName, choices, tableName) {
            var isString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            this.columnName = columnName;
            this.tableName = tableName;
            this.valueList.items = choices;
            this.valueList.multiSelect = true;
            this.valueList.multiSelectWithSimpleClick = true;
            this.isString = isString;
            this.valueList.selection = choices[0];
            connect(this.valueList, "selection", this, "signalFilterChanged");
          }
        }, {
          key: "signalFilterChanged",
          value: function ListFilterMorph_signalFilterChanged_() {
            signal(this, "filterChanged");
          }
        }, {
          key: "filter",
          get: function get() {
            var valueField = this.valueList.selection;
            var valueValue = this.isString ? "\"".concat(valueField, "\"") : valueField;
            return {
              columnName: this.columnName,
              value: valueValue
            };
          }
        }, {
          key: "dataManagerFilter",
          get: function get() {
            var mapToString = function mapToString(val) {
              return isNaN(val) ? val : "\"".concat(val, "\"");
            };

            var valueField = this.valueList.selections;
            var formattedValues = this.isString ? valueField.map(function (val) {
              return mapToString(val);
            }) : valueField;
            return {
              operator: "IN_LIST",
              column: this.columnName,
              values: formattedValues
            };
          }
        }, {
          key: "filterString",
          get: function get() {
            return "".concat(this.columnName, " IN ").concat(this.valueList.selections);
          }
        }, {
          key: "persistentForm",
          get: function get() {
            return {
              part: this.part,
              columnName: this.columnName,
              choices: this.valueList.items,
              selection: this.valueList.selection,
              isString: this.isString,
              tableName: this.tableName,
              type: this.filterType
            };
          }
        }, {
          key: "restoreFromSavedForm",
          value: function ListFilterMorph_restoreFromSavedForm_(savedForm) {
            this.init(savedForm.columnName, savedForm.choices, savedForm.tableName, savedForm.isString);
            this.signalEnabled = false;
            this.valueList.selection = savedForm.selection;
            this.signalEnabled = true;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ListFilterMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              tableName: {
                defaultValue: null
              },
              columnName: {
                defaultValue: null
              },
              filterType: {
                serialize: false,
                get: function get() {
                  return "Select";
                }
              },
              widgetType: {
                serialize: false,
                get: function get() {
                  return "list";
                }
              },
              part: {
                serialize: false,
                get: function get() {
                  return __varRecorder__$k.ListFilter[Symbol["for"]("lively-module-meta")];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/filters.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 19452,
          end: 23916
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$k.ListFilterMorph = ListFilterMorph;
      __varRecorder__$k.ListFilterMorph = ListFilterMorph;
      __varRecorder__$k.ListFilter = component["for"](function () {
        return component(__varRecorder__$k.VisualFilter, {
          name: "list filter",
          type: __varRecorder__$k.ListFilterMorph,
          submorphs: [add(part(GalyleoDropDownList, {
            name: "value list",
            viewModel: {
              openListInWorld: true
            }
          }))]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/filters.cp.js",
        "export": "ListFilter",
        range: {
          start: 23959,
          end: 24164
        }
      }, System, __varRecorder__$k, "ListFilter");
      var NamedFilterMorph = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/filters.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("NamedFilterMorph") && typeof __lively_classholder__.NamedFilterMorph === "function" ? __lively_classholder__.NamedFilterMorph : __lively_classholder__.NamedFilterMorph = function NamedFilterMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "init",
          value: function NamedFilterMorph_init_(filterMorph, filterName) {
            this.removeAllMorphs();
            this.name = filterName;
            this.addMorph(filterMorph);
            this.filterMorph = filterMorph;
            connect(filterMorph, "filterChanged", this, "signalFilterChanged");
          }
        }, {
          key: "filter",
          get: function get() {
            return this.filterMorph.filter;
          }
        }, {
          key: "dataManagerFilter",
          get: function get() {
            return this.filterMorph.dataManagerFilter;
          }
        }, {
          key: "columnName",
          get: function get() {
            return this.filterMorph.columnName;
          }
        }, {
          key: "signalFilterChanged",
          value: function NamedFilterMorph_signalFilterChanged_() {
            signal(this, "filterChanged");
          }
        }, {
          key: "isFilter",
          get: function get() {
            return true;
          }
        }, {
          key: "filterString",
          get: function get() {
            return this.filterMorph.filterString;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "NamedFilterMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              filterMorph: {
                defaultValue: null
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/filters.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 24174,
          end: 27284
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$k.NamedFilterMorph = NamedFilterMorph;
      __varRecorder__$k.NamedFilterMorph = NamedFilterMorph;
      __varRecorder__$k.NamedFilter = component["for"](function () {
        return component(__varRecorder__$k.VisualFilter, {
          type: __varRecorder__$k.NamedFilterMorph,
          fill: Color$1.white,
          borderWidth: 0,
          reactsToPointer: false,
          submorphs: [add({
            type: Label,
            name: "column name",
            fontColor: Color$1.rgb(81, 90, 90),
            fontFamily: galyleoFont,
            fontSize: 15,
            textAndAttributes: ["I am a label!", null],
            visible: false
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/filters.cp.js",
        "export": "NamedFilter",
        range: {
          start: 27321,
          end: 27698
        }
      }, System, __varRecorder__$k, "NamedFilter");
      var RangeFilterMorph = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/filters.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("RangeFilterMorph") && typeof __lively_classholder__.RangeFilterMorph === "function" ? __lively_classholder__.RangeFilterMorph : __lively_classholder__.RangeFilterMorph = function RangeFilterMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "_setMaxAndMin",
          value: function RangeFilterMorph__setMaxAndMin_(numberWidget, min, max, initVal) {
            var valueInput = numberWidget.getSubmorphNamed("value");
            numberWidget.min = valueInput.min = min;
            numberWidget.max = valueInput.max = max;
            numberWidget.number = initVal;
          }
        }, {
          key: "init",
          value: function RangeFilterMorph_init_(columnName, tableName, minVal, maxVal, increment) {
            this.signalEnabled = false;
            this.minVal = minVal;
            this.maxVal = maxVal;
            var maxInput = this.getSubmorphNamed("max");

            this._setMaxAndMin(maxInput, minVal, maxVal, maxVal);

            var minInput = this.getSubmorphNamed("min");

            this._setMaxAndMin(minInput, minVal, maxVal, minVal);

            this.columnName = columnName;
            this.tableName = tableName;
            this.signalEnabled = true;
          }
        }, {
          key: "_ensureWithinBounds",
          value: function RangeFilterMorph__ensureWithinBounds_() {
            var minInput = this.getSubmorphNamed("min");
            var maxInput = this.getSubmorphNamed("max");
            var doSignal = this.signalEnabled;
            this.signalEnabled = false;

            if (maxInput.number > this.maxVal) {
              maxInput.number = this.maxVal;
            }

            if (minInput.number < this.minVal) {
              minInput.number = this.minVal;
            }

            if (minInput.number >= maxInput.number) {
              minInput.number = maxInput.number;
            }

            this.signalEnabled = doSignal;
          }
        }, {
          key: "entryChanged",
          value: function RangeFilterMorph_entryChanged_() {
            this._ensureWithinBounds();

            if (this.signalEnabled) {
              signal(this, "filterChanged");
            }
          }
        }, {
          key: "_inputValue",
          value: function RangeFilterMorph__inputValue_(submorphName) {
            var inputMorph = this.getSubmorphNamed(submorphName);
            return Number(inputMorph.number);
          }
        }, {
          key: "_minMax",
          value: function RangeFilterMorph__minMax_() {
            var inputMin = this._inputValue("min");

            var inputMax = this._inputValue("max");

            return {
              min: Math.min(inputMin, inputMax),
              max: Math.max(inputMin, inputMax)
            };
          }
        }, {
          key: "filter",
          get: function get() {
            var minMax = this._minMax();

            return {
              columnName: this.columnName,
              maxValue: minMax.max,
              minValue: minMax.min
            };
          }
        }, {
          key: "dataManagerFilter",
          get: function get() {
            var minMax = this._minMax();

            return {
              operator: "IN_RANGE",
              column: this.columnName,
              max_val: minMax.max,
              min_val: minMax.min
            };
          }
        }, {
          key: "filterString",
          get: function get() {
            var minMax = this._minMax();

            return "".concat(minMax.max, " >= ").concat(this.columnName, " >= ").concat(minMax.min);
          }
        }, {
          key: "persistentForm",
          get: function get() {
            return {
              part: this.part,
              tableName: this.tableName,
              filterType: this.filterType,
              columnName: this.columnName,
              minVal: this.minVal,
              maxVal: this.maxVal,
              min: this._inputValue("min"),
              max: this._inputValue("max")
            };
          }
        }, {
          key: "restoreFromSavedForm",
          value: function RangeFilterMorph_restoreFromSavedForm_(savedForm) {
            this.init(savedForm.columnName, savedForm.tableName, savedForm.min, savedForm.max);
            var minInput = this.getSubmorphNamed("min");
            var maxInput = this.getSubmorphNamed("max");
            this.signalEnabled = false;
            minInput.number = savedForm.min;
            this.signalEnabled = false;
            maxInput.number = savedForm.max;
            this.signalEnabled = true;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "RangeFilterMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              columnName: {
                defaultValue: null
              },
              tableName: {
                defaultValue: null
              },
              minVal: {
                defaultValue: null
              },
              maxVal: {
                defaultValue: null
              },
              signalEnabled: {
                defaultValue: false
              },
              filterType: {
                serialize: false,
                get: function get() {
                  return "Range";
                }
              },
              widgetType: {
                serialize: false,
                get: function get() {
                  return "minMax";
                }
              },
              part: {
                serialize: false,
                get: function get() {
                  return __varRecorder__$k.RangeFilter[Symbol["for"]("lively-module-meta")];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "max",
                    signal: "numberChanged",
                    handler: "entryChanged"
                  }, {
                    target: "min",
                    signal: "numberChanged",
                    handler: "entryChanged"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/filters.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 28802,
          end: 36866
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$k.RangeFilterMorph = RangeFilterMorph;
      __varRecorder__$k.RangeFilterMorph = RangeFilterMorph;
      __varRecorder__$k.RangeFilter = component["for"](function () {
        return component(__varRecorder__$k.VisualFilter, {
          name: "range filter",
          type: __varRecorder__$k.RangeFilterMorph,
          extent: pt(141.6, 142.7),
          submorphs: [add({
            name: "controls",
            extent: pt(129.8, 89),
            layout: new TilingLayout({
              hugContentsVertically: true,
              justifySubmorphs: "spaced",
              orderByIndex: true,
              padding: rect(5, 5, 0, 0),
              spacing: 10
            }),
            fill: Color$1.transparent,
            submorphs: [{
              type: Label,
              name: "max label",
              fontColor: Color$1.rgb(48, 48, 48),
              fontFamily: galyleoFont,
              fontWeight: 800,
              fontSize: 14,
              textAndAttributes: ["Max:", null]
            }, part(GalyleoNumberInput, {
              name: "max",
              submorphs: [{
                name: "interactive label",
                fontColor: Color$1.rgba(0, 0, 0, 0.4965358231707328),
                textAndAttributes: Icon.textAttribute("sort-amount-up")
              }]
            }), {
              type: Label,
              name: "min label",
              fontColor: Color$1.rgb(48, 48, 48),
              fontFamily: galyleoFont,
              fontSize: 14,
              fontWeight: 800,
              textAndAttributes: ["Min:", null]
            }, part(GalyleoNumberInput, {
              name: "min",
              submorphs: [{
                name: "interactive label",
                fontColor: Color$1.rgba(0, 0, 0, 0.4965358231707328),
                textAndAttributes: Icon.textAttribute("sort-amount-down")
              }]
            })]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/filters.cp.js",
        "export": "RangeFilter",
        range: {
          start: 36909,
          end: 38426
        }
      }, System, __varRecorder__$k, "RangeFilter");
      var SelectFilterMorph = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/filters.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("SelectFilterMorph") && typeof __lively_classholder__.SelectFilterMorph === "function" ? __lively_classholder__.SelectFilterMorph : __lively_classholder__.SelectFilterMorph = function SelectFilterMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "valueList",
          get: function get() {
            return this.getSubmorphNamed("value list").viewModel;
          }
        }, {
          key: "init",
          value: function SelectFilterMorph_init_(columnName, choices, tableName) {
            var isString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            this.columnName = columnName;
            this.tableName = tableName;
            this.valueList.items = compact(choices);
            this.isString = isString;
            this.valueList.selection = choices[0];
            connect(this.valueList, "selection", this, "signalFilterChanged");
          }
        }, {
          key: "signalFilterChanged",
          value: function SelectFilterMorph_signalFilterChanged_() {
            signal(this, "filterChanged");
          }
        }, {
          key: "filter",
          get: function get() {
            var valueField = this.valueList.selection;
            var valueValue = this.isString ? "\"".concat(valueField, "\"") : valueField;
            return {
              columnName: this.columnName,
              value: valueValue
            };
          }
        }, {
          key: "dataManagerFilter",
          get: function get() {
            var valueField = this.valueList.selection;
            return {
              operator: "IN_LIST",
              column: this.columnName,
              values: [valueField]
            };
          }
        }, {
          key: "filterString",
          get: function get() {
            return "".concat(this.columnName, " = ").concat(this.valueList.selection);
          }
        }, {
          key: "persistentForm",
          get: function get() {
            return {
              part: this.part,
              filterType: this.filterType,
              columnName: this.columnName,
              tableName: this.tableName,
              choices: this.valueList.items,
              selection: this.valueList.selection,
              isString: this.isString
            };
          }
        }, {
          key: "restoreFromSavedForm",
          value: function SelectFilterMorph_restoreFromSavedForm_(savedForm) {
            this.init(savedForm.columnName, savedForm.choices, savedForm.tableName, savedForm.isString);
            this.signalEnabled = false;
            this.valueList.selection = savedForm.selection;
            this.signalEnabled = true;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "SelectFilterMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              columnName: {
                defaultValue: null
              },
              tableName: {
                defaultValue: null
              },
              filterType: {
                serialize: false,
                get: function get() {
                  return "Select";
                }
              },
              widgetType: {
                serialize: false,
                get: function get() {
                  return "dropdown";
                }
              },
              part: {
                serialize: false,
                get: function get() {
                  return __varRecorder__$k.SelectFilter[Symbol["for"]("lively-module-meta")];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/filters.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 39292,
          end: 43745
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$k.SelectFilterMorph = SelectFilterMorph;
      __varRecorder__$k.SelectFilterMorph = SelectFilterMorph;
      __varRecorder__$k.SelectFilter = component["for"](function () {
        return component(__varRecorder__$k.VisualFilter, {
          name: "select filter",
          type: __varRecorder__$k.SelectFilterMorph,
          submorphs: [add(part(GalyleoDropDown, {
            name: "value list",
            viewModel: {
              openListInWorld: true
            }
          }))]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/filters.cp.js",
        "export": "SelectFilter",
        range: {
          start: 43789,
          end: 43996
        }
      }, System, __varRecorder__$k, "SelectFilter");
      var SliderFilterMorph = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/filters.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("SliderFilterMorph") && typeof __lively_classholder__.SliderFilterMorph === "function" ? __lively_classholder__.SliderFilterMorph : __lively_classholder__.SliderFilterMorph = function SliderFilterMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "slider",
          get: function get() {
            return this.getSubmorphNamed("slider");
          }
        }, {
          key: "init",
          value: function SliderFilterMorph_init_(columnName, tableName, minVal, maxVal, increment) {
            this.signalEnabled = false;
            var slider = this.slider;
            slider.minValue = this.minValue = minVal;
            slider.maxValue = this.maxValue = maxVal;
            slider.increment = increment;
            slider.value = (maxVal - minVal) / 2 + minVal;
            slider.viewModel.updateValue();
            this.columnName = columnName;
            this.tableName = tableName;
            this.signalEnabled = true;
            connect(slider, "valueChanged", this, "valueChanged");
          }
        }, {
          key: "valueChanged",
          value: function SliderFilterMorph_valueChanged_() {
            var _this2 = this;

            debounceNamed("filterChanged-" + this.id, 50, function () {
              signal(_this2, "filterChanged");
            })();
          }
        }, {
          key: "filter",
          get: function get() {
            return {
              columnName: this.columnName,
              value: this.slider.value
            };
          }
        }, {
          key: "dataManagerFilter",
          get: function get() {
            return {
              operator: "IN_LIST",
              column: this.columnName,
              values: [this.getSubmorphNamed("slider").value]
            };
          }
        }, {
          key: "filterString",
          get: function get() {
            return "".concat(this.columnName, " == ").concat(this.slider.value);
          }
        }, {
          key: "persistentForm",
          get: function get() {
            var slider = this.slider;
            return {
              part: this.part,
              tableName: this.tableName,
              filterType: this.filterType,
              columnName: this.columnName,
              minVal: slider.minValue,
              maxVal: slider.maxValue,
              value: slider.value,
              increment: slider.increment
            };
          }
        }, {
          key: "restoreFromSavedForm",
          value: function SliderFilterMorph_restoreFromSavedForm_(savedForm) {
            this.init(savedForm.columnName, savedForm.tableName, savedForm.minVal, savedForm.maxVal, savedForm.increment);
            this.signalEnabled = false;
            var slider = this.slider;
            slider.value = savedForm.value;
            this.signalEnabled = true;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "SliderFilterMorph";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              filterChanged: {
                derived: true,
                readOnly: true,
                isSignal: true
              },
              columnName: {
                defaultValue: null
              },
              tableName: {
                defaultValue: null
              },
              minVal: {
                defaultValue: null
              },
              maxVal: {
                defaultValue: null
              },
              signalEnabled: {
                defaultValue: false
              },
              filterType: {
                serialize: false,
                get: function get() {
                  return "NumericSelect";
                }
              },
              widgetType: {
                serialize: false,
                get: function get() {
                  return "SliderWithValue";
                }
              },
              part: {
                serialize: false,
                get: function get() {
                  return __varRecorder__$k.SliderFilter[Symbol["for"]("lively-module-meta")];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/filters.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 45078,
          end: 50192
        });
      }({
        referencedAs: "Morph",
        value: Morph
      });
      __varRecorder__$k.SliderFilterMorph = SliderFilterMorph;
      __varRecorder__$k.SliderFilterMorph = SliderFilterMorph;
      __varRecorder__$k.SliderFilter = component["for"](function () {
        return component(__varRecorder__$k.VisualFilter, {
          name: "slider filter",
          type: __varRecorder__$k.SliderFilterMorph,
          extent: pt(265, 127),
          layout: new TilingLayout({
            align: "top",
            axis: "column",
            axisAlign: "center",
            hugContentsHorizontally: true,
            hugContentsVertically: true,
            orderByIndex: true
          }),
          submorphs: [add(part(SliderWithValue, {
            name: "slider",
            layout: new TilingLayout({
              align: "center",
              axisAlign: "center",
              hugContentsHorizontally: true,
              hugContentsVertically: true,
              orderByIndex: true,
              padding: rect(10, 0, 0, 0),
              spacing: 5
            }),
            submorphs: [{
              name: "value input",
              submorphs: [{
                name: "increment button"
              }]
            }]
          }))]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/filters.cp.js",
        "export": "SliderFilter",
        range: {
          start: 50236,
          end: 51007
        }
      }, System, __varRecorder__$k, "SliderFilter");
      var VisualFilter = __varRecorder__$k.VisualFilter;
      var NamedFilter = __varRecorder__$k.NamedFilter;
      var BooleanFilter$1 = __varRecorder__$k.BooleanFilter;
      var DateFilter = __varRecorder__$k.DateFilter;
      var DoubleSliderFilter = __varRecorder__$k.DoubleSliderFilter;
      var ListFilter = __varRecorder__$k.ListFilter;
      var RangeFilter = __varRecorder__$k.RangeFilter;
      var SelectFilter = __varRecorder__$k.SelectFilter;
      var SliderFilter = __varRecorder__$k.SliderFilter;
      __varRecorder__$k.VisualFilter = VisualFilter;
      __varRecorder__$k.NamedFilter = NamedFilter;
      __varRecorder__$k.BooleanFilter = BooleanFilter$1;
      __varRecorder__$k.DateFilter = DateFilter;
      __varRecorder__$k.DoubleSliderFilter = DoubleSliderFilter;
      __varRecorder__$k.ListFilter = ListFilter;
      __varRecorder__$k.RangeFilter = RangeFilter;
      __varRecorder__$k.SelectFilter = SelectFilter;
      __varRecorder__$k.SliderFilter = SliderFilter;

      var __varRecorder__$j = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/galyleo-data/galyleo-data.js", __contextModule__);

      var __moduleMeta__ = {
        pathInPackage: function pathInPackage() {
          return "./galyleo-data/galyleo-data.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "engageLively--galyleo-dashboard",
            version: "0.2.0"
          };
        }
      };

      var checkSpecValid = __varRecorder__$j["engageLively--galyleo-dashboard/galyleo-data/galyleo-data.js__define__"]("checkSpecValid", "function", function (table, filterSpec) {
        if (!filterSpec) {
          return false;
        }

        try {
          if (filterSpec.operator == "IN_RANGE" || filterSpec.operator == "IN_LIST") {
            var index = table.getColumnIndex(filterSpec.column);

            if (index < 0) {
              return false;
            }

            return filterSpec.operator == "IN_RANGE" ? table.columns[index].type == "number" : true;
          }

          return filterSpec.arguments.reduce(function (acc, spec) {
            return acc && checkSpecValid(table, spec);
          }, true);
        } catch (err) {
          console.log(filterSpec);
          console.log(err);
          return false;
        }
      }, __moduleMeta__);

      __varRecorder__$j.checkSpecValid = checkSpecValid;

      var constructFilter = __varRecorder__$j["engageLively--galyleo-dashboard/galyleo-data/galyleo-data.js__define__"]("constructFilter", "function", function (table, filterSpec) {
        if (filterSpec.operator == "IN_RANGE") {
          return new __varRecorder__$j.InRangeFilter(table, table.getColumnIndex(filterSpec.column), filterSpec.max_val, filterSpec.min_val);
        }

        if (filterSpec.operator == "IN_LIST") {
          return new __varRecorder__$j.InListFilter(table, table.getColumnIndex(filterSpec.column), filterSpec.values);
        }

        var args = filterSpec.arguments.map(function (subFilterSpec) {
          return constructFilter(table, subFilterSpec);
        });

        if (filterSpec.operator == "NONE") {
          return new __varRecorder__$j.NoneFilter(table, args);
        }

        if (filterSpec.operator == "ALL") {
          return new __varRecorder__$j.AllFilter(table, args);
        }

        return new __varRecorder__$j.AnyFilter(table, args);
      }, __moduleMeta__);

      __varRecorder__$j.constructFilter = constructFilter;

      var constructGalyleoTable = __varRecorder__$j["engageLively--galyleo-dashboard/galyleo-data/galyleo-data.js__define__"]("constructGalyleoTable", "function", function (name, galyleoTableSpec) {
        var columns = galyleoTableSpec.columns;

        if (galyleoTableSpec.rows != null) {
          return new __varRecorder__$j.ExplicitGalyleoTable(columns, name, galyleoTableSpec.rows);
        }

        if (galyleoTableSpec.connector != null) {
          return new __varRecorder__$j.RemoteGalyleoTable(columns, name, galyleoTableSpec.connector);
        }

        return null;
      }, __moduleMeta__);

      __varRecorder__$j.constructGalyleoTable = constructGalyleoTable;

      var Filter = /*#__PURE__*/function () {
        function Filter(table) {
          _classCallCheck(this, Filter);

          this.table = table;
        }

        _createClass(Filter, [{
          key: "_getRows_",
          value: function _getRows_(rows) {
            throw "_getRows_(rows) must be implemented!";
          }
        }, {
          key: "getRows",
          value: function getRows(rows) {
            var indexes = this._getRows_(rows);

            return indexes.map(function (index) {
              return rows[index];
            });
          }
        }, {
          key: "equals",
          value: function equals(otherFilter) {
            return this.table == otherFilter.table;
          }
        }]);

        return Filter;
      }();

      __varRecorder__$j.Filter = Filter;

      __varRecorder__$j.filterSetEquality = function (filterList1, filterList2) {
        if (!(filterList1 && filterList2)) {
          return false;
        }

        if (filterList1.size != filterList2.size) {
          return false;
        }

        var matches = filterList1.map(function (_) {
          return [false, false];
        });
        filterList1.forEach(function (filt, index) {
          filterList2.forEach(function (filt2, index2) {
            if (filt.equals(filt2)) {
              matches[index][0] = matches[index2][1] = true;
            }
          });
        });
        return matches.reduce(function (acc, pair) {
          return acc && pair[0] && pair[1];
        }, true);
      };

      var BooleanFilter = /*#__PURE__*/function (_varRecorder__$Filte) {
        _inherits(BooleanFilter, _varRecorder__$Filte);

        var _super = _createSuper(BooleanFilter);

        function BooleanFilter(table, args) {
          var _this;

          _classCallCheck(this, BooleanFilter);

          _this = _super.call(this, table);
          _this.args = args;
          return _this;
        }

        _createClass(BooleanFilter, [{
          key: "equals",
          value: function equals(otherFilter) {
            var _this2 = this;

            var findMatch = function findMatch(filter, filterList) {
              return filterList.reduce(function (matched, other) {
                return matched || other.equals(filter);
              }, false);
            };

            if (_get(_getPrototypeOf(BooleanFilter.prototype), "equals", this).call(this, otherFilter) && this.args.length == otherFilter.args.length) {
              var matched = this.args.map(function (filter) {
                return findMatch(filter, otherFilter.args);
              }).reduce(function (result, bool) {
                return result && bool;
              }, true);
              var otherMatched = otherFilter.args.map(function (filter) {
                return findMatch(filter, _this2.args);
              }).reduce(function (result, bool) {
                return result && bool;
              }, true);
              return matched && otherMatched;
            } else {
              return false;
            }
          }
        }]);

        return BooleanFilter;
      }(__varRecorder__$j.Filter);

      __varRecorder__$j.BooleanFilter = BooleanFilter;

      var AllFilter = /*#__PURE__*/function (_varRecorder__$Boole) {
        _inherits(AllFilter, _varRecorder__$Boole);

        var _super2 = _createSuper(AllFilter);

        function AllFilter() {
          _classCallCheck(this, AllFilter);

          return _super2.apply(this, arguments);
        }

        _createClass(AllFilter, [{
          key: "_getRows_",
          value: function _getRows_(rows) {
            var result = _toConsumableArray(Array(rows.length).keys());

            this.args.forEach(function (containedFilter) {
              result = containedFilter._getRows_(rows).filter(function (index) {
                return result.indexOf(index) >= 0;
              });
            });
            return result;
          }
        }, {
          key: "equals",
          value: function equals(otherFilter) {
            return otherFilter instanceof __varRecorder__$j.AllFilter && _get(_getPrototypeOf(AllFilter.prototype), "equals", this).call(this, otherFilter);
          }
        }]);

        return AllFilter;
      }(__varRecorder__$j.BooleanFilter);

      __varRecorder__$j.AllFilter = AllFilter;

      var AnyFilter = /*#__PURE__*/function (_varRecorder__$Boole2) {
        _inherits(AnyFilter, _varRecorder__$Boole2);

        var _super3 = _createSuper(AnyFilter);

        function AnyFilter() {
          _classCallCheck(this, AnyFilter);

          return _super3.apply(this, arguments);
        }

        _createClass(AnyFilter, [{
          key: "_getRows_",
          value: function _getRows_(rows) {
            var result = new Set();
            this.args.forEach(function (containedFilter) {
              containedFilter._getRows_(rows).forEach(function (index) {
                result.add(index);
              });
            });
            return _toConsumableArray(result).sort(function (a, b) {
              return a - b;
            });
          }
        }, {
          key: "equals",
          value: function equals(otherFilter) {
            return otherFilter instanceof __varRecorder__$j.AnyFilter && _get(_getPrototypeOf(AnyFilter.prototype), "equals", this).call(this, otherFilter);
          }
        }]);

        return AnyFilter;
      }(__varRecorder__$j.BooleanFilter);

      __varRecorder__$j.AnyFilter = AnyFilter;

      var NoneFilter = /*#__PURE__*/function (_varRecorder__$Boole3) {
        _inherits(NoneFilter, _varRecorder__$Boole3);

        var _super4 = _createSuper(NoneFilter);

        function NoneFilter() {
          _classCallCheck(this, NoneFilter);

          return _super4.apply(this, arguments);
        }

        _createClass(NoneFilter, [{
          key: "_getRows_",
          value: function _getRows_(rows) {
            var inverse = this.args[0]._getRows_(rows);

            return _toConsumableArray(Array(rows.length).keys()).filter(function (index) {
              return inverse.indexOf(index) < 0;
            });
          }
        }, {
          key: "equals",
          value: function equals(otherFilter) {
            return otherFilter instanceof __varRecorder__$j.NoneFilter && _get(_getPrototypeOf(NoneFilter.prototype), "equals", this).call(this, otherFilter);
          }
        }]);

        return NoneFilter;
      }(__varRecorder__$j.BooleanFilter);

      __varRecorder__$j.NoneFilter = NoneFilter;

      var PrimitiveFilter = /*#__PURE__*/function (_varRecorder__$Filte2) {
        _inherits(PrimitiveFilter, _varRecorder__$Filte2);

        var _super5 = _createSuper(PrimitiveFilter);

        function PrimitiveFilter(table, column) {
          var _this3;

          _classCallCheck(this, PrimitiveFilter);

          _this3 = _super5.call(this, table);
          _this3.column = column;
          return _this3;
        }

        _createClass(PrimitiveFilter, [{
          key: "equals",
          value: function equals(otherFilter) {
            return _get(_getPrototypeOf(PrimitiveFilter.prototype), "equals", this).call(this, otherFilter) && otherFilter.column == this.column;
          }
        }, {
          key: "_filterValue_",
          value: function _filterValue_(value) {
            throw "_filterValue_ must be implemented";
          }
        }, {
          key: "_getRows_",
          value: function _getRows_(rows) {
            var _this4 = this;

            var values = rows.map(function (row) {
              return row[_this4.column];
            });

            var indices = _toConsumableArray(Array(values.length).keys());

            return indices.filter(function (index) {
              return _this4._filterValue_(values[index]);
            });
          }
        }]);

        return PrimitiveFilter;
      }(__varRecorder__$j.Filter);

      __varRecorder__$j.PrimitiveFilter = PrimitiveFilter;

      var InListFilter = /*#__PURE__*/function (_varRecorder__$Primi) {
        _inherits(InListFilter, _varRecorder__$Primi);

        var _super6 = _createSuper(InListFilter);

        function InListFilter(table, column, valueList) {
          var _this5;

          _classCallCheck(this, InListFilter);

          _this5 = _super6.call(this, table, column);
          _this5.valueSet = new Set(valueList);
          return _this5;
        }

        _createClass(InListFilter, [{
          key: "equals",
          value: function equals(otherFilter) {
            var isEqualSets = function isEqualSets(set1, set2) {
              return set1.size === set2.size && set1.size === new Set([].concat(_toConsumableArray(set1), _toConsumableArray(set2))).size;
            };

            return otherFilter instanceof __varRecorder__$j.InListFilter && _get(_getPrototypeOf(InListFilter.prototype), "equals", this).call(this, otherFilter) && isEqualSets(this.valueSet, otherFilter.valueSet);
          }
        }, {
          key: "_filterValue_",
          value: function _filterValue_(value) {
            return this.valueSet.has(value);
          }
        }]);

        return InListFilter;
      }(__varRecorder__$j.PrimitiveFilter);

      __varRecorder__$j.InListFilter = InListFilter;

      var InRangeFilter = /*#__PURE__*/function (_varRecorder__$Primi2) {
        _inherits(InRangeFilter, _varRecorder__$Primi2);

        var _super7 = _createSuper(InRangeFilter);

        function InRangeFilter(table, column, maxVal, minVal) {
          var _this6;

          _classCallCheck(this, InRangeFilter);

          _this6 = _super7.call(this, table, column);
          _this6.maxVal = maxVal;
          _this6.minVal = minVal;
          return _this6;
        }

        _createClass(InRangeFilter, [{
          key: "equals",
          value: function equals(otherFilter) {
            return otherFilter instanceof __varRecorder__$j.InRangeFilter && _get(_getPrototypeOf(InRangeFilter.prototype), "equals", this).call(this, otherFilter) && this.maxVal == otherFilter.maxVal && this.minVal == otherFilter.minVal;
          }
        }, {
          key: "_filterValue_",
          value: function _filterValue_(value) {
            if (isNaN(value)) {
              return false;
            }

            return value <= this.maxVal && value >= this.minVal;
          }
        }]);

        return InRangeFilter;
      }(__varRecorder__$j.PrimitiveFilter);

      __varRecorder__$j.InRangeFilter = InRangeFilter;

      __varRecorder__$j.convertSDMLValue = function (value, sdmlType) {
        if (sdmlType == "string") {
          return typeof value == "string" ? value : JSON.stringify(value);
        }

        if (sdmlType == "number") {
          return Number(value);
        }

        if (sdmlType == "boolean") {
          value = typeof value == "string" ? JSON.parse(value) : value;
          return !!value;
        }

        value = value.trim();

        if (sdmlType == "datetime") {
          try {
            return new Date(value);
          } catch (err) {
            return new Date("1970-01-01T00:00:00");
          }
        }

        if (sdmlType == "date") {
          try {
            return new Date(value);
          } catch (err1) {
            return new Date("1970-01-01");
          }
        }

        try {
          return new Date(value);
        } catch (err) {
          try {
            return new Date("1970-01-01T" + value);
          } catch (err1) {
            return new Date("1970-01-01T00:00:00");
          }
        }
      };

      __varRecorder__$j.convertSDMLRow = function (values, columns) {
        return values.map(function (value, i) {
          return __varRecorder__$j.convertSDMLValue(value, columns[i].type);
        });
      };

      var GalyleoTable = /*#__PURE__*/function () {
        function GalyleoTable(columns, tableName, getRows) {
          _classCallCheck(this, GalyleoTable);

          this.columns = columns;
          this.tableName = tableName;
          this.getRows = getRows;
          this.updateListeners = new Set();
        }

        _createClass(GalyleoTable, [{
          key: "registerUpdateListener",
          value: function registerUpdateListener(listener) {
            this.updateListeners.add(listener);
          }
        }, {
          key: "deregisterUpdateListener",
          value: function deregisterUpdateListener(listener) {
            this.updateListeners["delete"](listener);
          }
        }, {
          key: "dataUpdated",
          value: function dataUpdated() {
            var _this7 = this;

            this.updateListeners.forEach(function (listenerObject) {
              if (listenerObject && listenerObject.tableUpdated) {
                listenerObject.tableUpdated(_this7);
              }
            });
          }
        }, {
          key: "getColumnIndex",
          value: function getColumnIndex(columnName) {
            return this.columns.map(function (column) {
              return column.name;
            }).indexOf(columnName);
          }
        }, {
          key: "getColumnType",
          value: function getColumnType(columnName) {
            var index = this.getColumnIndex(columnName);
            return index < 0 ? null : this.columns[index].type;
          }
        }, {
          key: "getColumnsOfTypes",
          value: function getColumnsOfTypes(typeList) {
            var columnMatches = function columnMatches(column) {
              return typeList.length > 0 ? typeList.indexOf(column.type) >= 0 : true;
            };

            return this.columns.filter(function (column) {
              return columnMatches(column);
            }).map(function (column) {
              return column.name;
            });
          }
        }, {
          key: "getAllValues",
          value: function () {
            var _getAllValues = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(columnName) {
              var index, rows, result;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      index = this.getColumnIndex(columnName);
                      _context.next = 3;
                      return this.getRows();

                    case 3:
                      rows = _context.sent;
                      result = _toConsumableArray(rows.map(function (row) {
                        return row[index];
                      }));

                      if (this.columns[index].type == "number") {
                        result.sort(function (a, b) {
                          return a - b;
                        });
                      } else {
                        result.sort;
                      }

                      return _context.abrupt("return", result);

                    case 7:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function getAllValues(_x) {
              return _getAllValues.apply(this, arguments);
            }

            return getAllValues;
          }()
        }, {
          key: "getNumericSpec",
          value: function () {
            var _getNumericSpec = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(columnName) {
              var values, shift, deltas, minPositive, incr;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return this.getAllValues(columnName);

                    case 2:
                      values = _context2.sent;
                      shift = values.slice(1);
                      deltas = shift.map(function (val, index) {
                        return val - values[index];
                      });

                      minPositive = function minPositive(a, b) {
                        return a <= 0 ? b : b <= 0 ? a : Math.min(a, b);
                      };

                      incr = deltas.slice(1).reduce(function (acc, cur) {
                        return minPositive(acc, cur);
                      }, deltas[0]);
                      return _context2.abrupt("return", {
                        min_val: values[0],
                        max_val: values[values.length - 1],
                        increment: incr
                      });

                    case 8:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function getNumericSpec(_x2) {
              return _getNumericSpec.apply(this, arguments);
            }

            return getNumericSpec;
          }()
        }, {
          key: "columnNames",
          get: function get() {
            return this.columns.map(function (column) {
              return column.name;
            });
          }
        }]);

        return GalyleoTable;
      }();

      __varRecorder__$j.GalyleoTable = GalyleoTable;

      var ExplicitGalyleoTable = /*#__PURE__*/function (_varRecorder__$Galyl) {
        _inherits(ExplicitGalyleoTable, _varRecorder__$Galyl);

        var _super8 = _createSuper(ExplicitGalyleoTable);

        function ExplicitGalyleoTable(columns, tableName, rows) {
          var _this8;

          _classCallCheck(this, ExplicitGalyleoTable);

          _this8 = _super8.call(this, columns, tableName, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    return _context3.abrupt("return", _this8.rows);

                  case 1:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          })));
          _this8.getRows = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    return _context4.abrupt("return", _this8.rows);

                  case 1:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));
          _this8.rows = rows;
          _this8.tableType = "ExplicitGalyleoTable";
          return _this8;
        }

        _createClass(ExplicitGalyleoTable, [{
          key: "toDictionary",
          value: function toDictionary() {
            return {
              columns: this.columns,
              rows: this.rows
            };
          }
        }, {
          key: "getFilteredRows",
          value: function () {
            var _getFilteredRows = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
              var filterSpec,
                  madeFilter,
                  _args5 = arguments;
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      filterSpec = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : null;

                      if (!filterSpec) {
                        _context5.next = 6;
                        break;
                      }

                      madeFilter = __varRecorder__$j.constructFilter(this, filterSpec);
                      return _context5.abrupt("return", madeFilter.getRows(this.rows));

                    case 6:
                      return _context5.abrupt("return", this.rows);

                    case 7:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function getFilteredRows() {
              return _getFilteredRows.apply(this, arguments);
            }

            return getFilteredRows;
          }()
        }]);

        return ExplicitGalyleoTable;
      }(__varRecorder__$j.GalyleoTable);

      __varRecorder__$j.ExplicitGalyleoTable = ExplicitGalyleoTable;

      var URLFetcher = /*#__PURE__*/function () {
        function URLFetcher(url, tableName) {
          _classCallCheck(this, URLFetcher);

          this.url = url;
          this.tableName = tableName;
          this.headers = {};
          this.body = null;
        }

        _createClass(URLFetcher, [{
          key: "addHeader",
          value: function addHeader(key, value) {
            this.headers[key] = value;
          }
        }, {
          key: "addBody",
          value: function addBody(body) {
            this.body = body;
          }
        }, {
          key: "makeResource",
          value: function makeResource() {
            var _this9 = this;

            this.webResource = resource(this.url);

            if (this.body) {
              this.webResource.body = this.body;
            }

            this.webResource.useCors = true;
            this.webResource.useProxy = false;
            Object.keys(this.headers).forEach(function (key) {
              return _this9.webResource.headers[key] = _this9.headers[key];
            });
            return this.webResource;
          }
        }, {
          key: "post",
          value: function () {
            var _post = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      if (!this.webResource) {
                        this.makeResource();
                      }

                      _context6.next = 3;
                      return this.webResource.post(this.body);

                    case 3:
                      return _context6.abrupt("return", _context6.sent);

                    case 4:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function post() {
              return _post.apply(this, arguments);
            }

            return post;
          }()
        }, {
          key: "readJson",
          value: function () {
            var _readJson = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      if (!this.webResource) {
                        this.makeResource();
                      }

                      return _context7.abrupt("return", this.webResource.readJson());

                    case 2:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7, this);
            }));

            function readJson() {
              return _readJson.apply(this, arguments);
            }

            return readJson;
          }()
        }, {
          key: "read",
          value: function read() {
            if (!this.webResource) {
              this.makeResource();
            }

            return this.webResouce.read();
          }
        }, {
          key: "tableName",
          set: function set(tableName) {
            this.table_name = tableName;
          }
        }, {
          key: "dashboardName",
          set: function set() {
            var dashboardName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            if (dashboardName) {
              this.dashboard_name = dashboardName;
            } else {
              this.dashboard_name = dashboardName;
            }
          }
        }]);

        return URLFetcher;
      }();

      __varRecorder__$j.URLFetcher = URLFetcher;

      __varRecorder__$j._makeURL = function (baseURL, method) {
        return baseURL.endsWith("/") ? "".concat(baseURL).concat(method) : "".concat(baseURL, "/").concat(method);
      };

      var RemoteGalyleoTable = /*#__PURE__*/function (_varRecorder__$Galyl2) {
        _inherits(RemoteGalyleoTable, _varRecorder__$Galyl2);

        var _super9 = _createSuper(RemoteGalyleoTable);

        function RemoteGalyleoTable(columns, tableName, connector) {
          var _this10;

          _classCallCheck(this, RemoteGalyleoTable);

          _this10 = _super9.call(this, columns, tableName, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    _context8.next = 2;
                    return _this10._getRowsFromURL_();

                  case 2:
                    return _context8.abrupt("return", _context8.sent);

                  case 3:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8);
          })));
          _this10.tableType = "RemoteGalyleoTable";
          _this10.url = connector.url;
          _this10.tableName = connector.remoteName ? connector.remoteName : tableName;
          _this10.headers = {};

          if (!isNaN(connector.interval) && connector.interval >= 1) {
            _this10.interval = connector.interval;
            setInterval(function (_) {
              return _this10.dataUpdated();
            }, 1000 * connector.interval);
          }

          return _this10;
        }

        _createClass(RemoteGalyleoTable, [{
          key: "toDictionary",
          value: function toDictionary() {
            var connector = {
              url: this.url,
              remoteName: this.remoteName
            };

            if (this.interval) {
              connector.interval = this.interval;
            }

            return {
              columns: this.columns,
              connector: connector
            };
          }
        }, {
          key: "_getRowsFromURL_",
          value: function () {
            var _getRowsFromURL_2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      _context9.next = 2;
                      return this.getFilteredRows(null);

                    case 2:
                      return _context9.abrupt("return", _context9.sent);

                    case 3:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, this);
            }));

            function _getRowsFromURL_() {
              return _getRowsFromURL_2.apply(this, arguments);
            }

            return _getRowsFromURL_;
          }()
        }, {
          key: "_makeURLFetcher_",
          value: function _makeURLFetcher_(url) {
            var result = new __varRecorder__$j.URLFetcher(url, this.remoteName);
            return result;
          }
        }, {
          key: "getFilteredRows",
          value: function () {
            var _getFilteredRows2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
              var _this11 = this;

              var filterSpec,
                  urlFetcher,
                  body,
                  result,
                  mapped,
                  _args10 = arguments;
              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      filterSpec = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : null;
                      urlFetcher = this._makeURLFetcher_(__varRecorder__$j._makeURL(this.url, "get_filtered_rows"));
                      body = {
                        table: this.tableName
                      };

                      if (filterSpec) {
                        body.filter = filterSpec;
                      }

                      urlFetcher.body = body;
                      urlFetcher.addHeader("Accept", "application/json");
                      urlFetcher.addHeader("Content-Type", "application/json");
                      _context10.prev = 7;
                      _context10.next = 10;
                      return urlFetcher.post();

                    case 10:
                      result = _context10.sent;
                      mapped = result.map(function (row) {
                        return __varRecorder__$j.convertSDMLRow(row, _this11.columns);
                      });
                      return _context10.abrupt("return", mapped);

                    case 15:
                      _context10.prev = 15;
                      _context10.t0 = _context10["catch"](7);
                      return _context10.abrupt("return", []);

                    case 18:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, this, [[7, 15]]);
            }));

            function getFilteredRows() {
              return _getFilteredRows2.apply(this, arguments);
            }

            return getFilteredRows;
          }()
        }, {
          key: "_executeGetRequest_",
          value: function () {
            var _executeGetRequest_2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(request, columnName) {
              var urlFetcher;
              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      urlFetcher = this._makeURLFetcher_(__varRecorder__$j._makeURL(this.url, "".concat(request, "?column=").concat(columnName, "&table=").concat(this.tableName)));
                      _context11.next = 3;
                      return urlFetcher.readJson();

                    case 3:
                      return _context11.abrupt("return", _context11.sent);

                    case 4:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11, this);
            }));

            function _executeGetRequest_(_x3, _x4) {
              return _executeGetRequest_2.apply(this, arguments);
            }

            return _executeGetRequest_;
          }()
        }, {
          key: "getAllValues",
          value: function () {
            var _getAllValues2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(columnName) {
              var values, columnType;
              return regeneratorRuntime.wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      _context12.next = 2;
                      return this._executeGetRequest_("get_all_values", columnName);

                    case 2:
                      values = _context12.sent;
                      columnType = this.getColumnType(columnName);
                      return _context12.abrupt("return", values.map(function (value) {
                        return __varRecorder__$j.convertSDMLValue(value, columnType);
                      }));

                    case 5:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12, this);
            }));

            function getAllValues(_x5) {
              return _getAllValues2.apply(this, arguments);
            }

            return getAllValues;
          }()
        }, {
          key: "getNumericSpec",
          value: function () {
            var _getNumericSpec2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(columnName) {
              var values, columnType, result;
              return regeneratorRuntime.wrap(function _callee13$(_context13) {
                while (1) {
                  switch (_context13.prev = _context13.next) {
                    case 0:
                      _context13.next = 2;
                      return this._executeGetRequest_("get_range_spec", columnName);

                    case 2:
                      values = _context13.sent;
                      columnType = this.getColumnType(columnName);
                      result = values.map(function (value) {
                        return __varRecorder__$j.convertSDMLValue(value, columnType);
                      });
                      return _context13.abrupt("return", {
                        min_val: result[0],
                        max_val: result[1]
                      });

                    case 6:
                    case "end":
                      return _context13.stop();
                  }
                }
              }, _callee13, this);
            }));

            function getNumericSpec(_x6) {
              return _getNumericSpec2.apply(this, arguments);
            }

            return getNumericSpec;
          }()
        }]);

        return RemoteGalyleoTable;
      }(__varRecorder__$j.GalyleoTable);

      __varRecorder__$j.RemoteGalyleoTable = RemoteGalyleoTable;

      var GalyleoView = /*#__PURE__*/function () {
        function GalyleoView(viewSpec) {
          _classCallCheck(this, GalyleoView);

          this.tableName = viewSpec.table;
          this.columns = viewSpec.columns;
          this.filters = viewSpec.filterNames;
        }

        _createClass(GalyleoView, [{
          key: "toDictionary",
          value: function toDictionary() {
            return {
              table: this.tableName,
              columns: this.columns,
              filterNames: this.filters
            };
          }
        }, {
          key: "_getFilter_",
          value: function _getFilter_(filterSpecs, table) {
            var matchingSpecs = this.filters.map(function (filterName) {
              return filterSpecs[filterName];
            });
            var validSpecs = matchingSpecs.filter(function (spec) {
              return __varRecorder__$j.checkSpecValid(table, spec);
            });
            return validSpecs.length == 0 ? null : validSpecs.length == 1 ? validSpecs[0] : {
              operator: "ALL",
              arguments: validSpecs
            };
          }
        }, {
          key: "_getColumnIndexes_",
          value: function _getColumnIndexes_(table) {
            return this.columns.map(function (column) {
              return table.getColumnIndex(column);
            }).filter(function (columnIndex) {
              return columnIndex >= 0;
            });
          }
        }, {
          key: "fullColumns",
          value: function fullColumns(tableDictionary) {
            var table = tableDictionary[this.tableName];

            if (!table) {
              return undefined;
            }

            var columnIndexes = this._getColumnIndexes_(table);

            return columnIndexes.map(function (index) {
              return table.columns[index];
            });
          }
        }, {
          key: "getData",
          value: function () {
            var _getData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(filterSpecs, tableDictionary) {
              var table, columnIndexes, reorderRow, actualFilter, rows, rowsToSend;
              return regeneratorRuntime.wrap(function _callee14$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      table = tableDictionary[this.tableName];

                      if (table) {
                        _context14.next = 3;
                        break;
                      }

                      return _context14.abrupt("return", undefined);

                    case 3:
                      columnIndexes = this._getColumnIndexes_(table);

                      reorderRow = function reorderRow(row) {
                        return columnIndexes.map(function (index) {
                          return row[index];
                        });
                      };

                      if (!(columnIndexes.length <= 0)) {
                        _context14.next = 7;
                        break;
                      }

                      return _context14.abrupt("return", undefined);

                    case 7:
                      actualFilter = this._getFilter_(filterSpecs, table);
                      _context14.next = 10;
                      return table.getFilteredRows(actualFilter);

                    case 10:
                      rows = _context14.sent;
                      rowsToSend = rows.map(function (row) {
                        return reorderRow(row);
                      });
                      return _context14.abrupt("return", rowsToSend);

                    case 13:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee14, this);
            }));

            function getData(_x7, _x8) {
              return _getData.apply(this, arguments);
            }

            return getData;
          }()
        }, {
          key: "filterNames",
          get: function get() {
            return this.filters;
          }
        }]);

        return GalyleoView;
      }();

      __varRecorder__$j.GalyleoView = GalyleoView;

      var GalyleoDataManager = /*#__PURE__*/function () {
        function GalyleoDataManager() {
          var updateListener = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          _classCallCheck(this, GalyleoDataManager);

          this.updateListener = updateListener;
          this.tables = {};
          this.views = {};
        }

        _createClass(GalyleoDataManager, [{
          key: "clear",
          value: function clear() {
            this.tables = {};
            this.views = {};
          }
        }, {
          key: "_generateDictionary_",
          value: function _generateDictionary_(objectToConvert) {
            var names = Object.keys(objectToConvert);
            var result = {};
            names.forEach(function (name) {
              return result[name] = objectToConvert[name].toDictionary();
            });
            return result;
          }
        }, {
          key: "toDictionary",
          value: function toDictionary() {
            return {
              tables: this._generateDictionary_(this.tables),
              views: this._generateDictionary_(this.views)
            };
          }
        }, {
          key: "addTable",
          value: function addTable(name, spec) {
            this.tables[name] = __varRecorder__$j.constructGalyleoTable(name, spec);

            if (this.updateListener) {
              this.tables[name].registerUpdateListener(this.updateListener);
            }
          }
        }, {
          key: "addView",
          value: function addView(name, viewSpec) {
            this.views[name] = new __varRecorder__$j.GalyleoView(viewSpec);
          }
        }, {
          key: "removeTable",
          value: function removeTable(name) {
            var _this12 = this;

            if (name in this.tables) {
              delete this.tables[name];
              Object.keys(this.views).forEach(function (viewName) {
                if (_this12.views[viewName].table == name) {
                  _this12.removeView(viewName);
                }
              });
            }
          }
        }, {
          key: "removeView",
          value: function removeView(name) {
            delete this.views[name];
          }
        }, {
          key: "_getMatchingTables_",
          value: function _getMatchingTables_(columnName, types) {
            var _this13 = this;

            var tableName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
            var allNames = Object.keys(this.tables);

            if (allNames.length == 0) {
              return [];
            }

            var names = tableName ? [tableName] : allNames;
            var tables = names.map(function (name) {
              return _this13.tables[name];
            });
            var matchingTables = tables.filter(function (table) {
              return table.getColumnIndex(columnName) >= 0;
            });

            if (types.size == 0) {
              return matchingTables;
            } else {
              return matchingTables.filter(function (table) {
                return types.has(table.columns[table.getColumnIndex(columnName)].type);
              });
            }
          }
        }, {
          key: "getAllValues",
          value: function () {
            var _getAllValues3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(columnName) {
              var tableName,
                  tables,
                  result,
                  remaining,
                  i,
                  allNumbers,
                  _args15 = arguments;
              return regeneratorRuntime.wrap(function _callee15$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      tableName = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : null;
                      tables = this._getMatchingTables_(columnName, new Set(), tableName);

                      if (!(tables.length == 0)) {
                        _context15.next = 4;
                        break;
                      }

                      return _context15.abrupt("return", []);

                    case 4:
                      _context15.next = 6;
                      return tables[0].getAllValues(columnName);

                    case 6:
                      result = _context15.sent;
                      remaining = tables.slice(1);
                      i = 0;

                    case 9:
                      if (!(i < remaining.length)) {
                        _context15.next = 18;
                        break;
                      }

                      _context15.t0 = result;
                      _context15.next = 13;
                      return remaining[i].getAllValues(columnName);

                    case 13:
                      _context15.t1 = _context15.sent;
                      result = _context15.t0.concat.call(_context15.t0, _context15.t1);

                    case 15:
                      i++;
                      _context15.next = 9;
                      break;

                    case 18:
                      result = _toConsumableArray(new Set(result));
                      allNumbers = tables.reduce(function (result, table) {
                        return result && table.getColumnType(columnName) == "number";
                      }, true);

                      if (allNumbers) {
                        result.sort(function (a, b) {
                          return a - b;
                        });
                      } else {
                        result.sort();
                      }

                      return _context15.abrupt("return", result);

                    case 22:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee15, this);
            }));

            function getAllValues(_x9) {
              return _getAllValues3.apply(this, arguments);
            }

            return getAllValues;
          }()
        }, {
          key: "getNumericSpec",
          value: function () {
            var _getNumericSpec3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(columnName) {
              var tableName,
                  tables,
                  result,
                  i,
                  tableResult,
                  _args16 = arguments;
              return regeneratorRuntime.wrap(function _callee16$(_context16) {
                while (1) {
                  switch (_context16.prev = _context16.next) {
                    case 0:
                      tableName = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : null;
                      tables = this._getMatchingTables_(columnName, new Set(["number"]), tableName);

                      if (!(tables.length == 0)) {
                        _context16.next = 4;
                        break;
                      }

                      return _context16.abrupt("return", null);

                    case 4:
                      _context16.next = 6;
                      return tables[0].getNumericSpec(columnName);

                    case 6:
                      result = _context16.sent;
                      i = 1;

                    case 8:
                      if (!(i < tables.length)) {
                        _context16.next = 18;
                        break;
                      }

                      _context16.next = 11;
                      return tables[i].getNumericSpec(columnName);

                    case 11:
                      tableResult = _context16.sent;
                      result.max_val = Math.max(result.max_val, tableResult.max_val);
                      result.min_val = Math.min(result.min_val, tableResult.min_val);
                      result.increment = Math.min(result.increment, tableResult.increment);

                    case 15:
                      i++;
                      _context16.next = 8;
                      break;

                    case 18:
                      return _context16.abrupt("return", result);

                    case 19:
                    case "end":
                      return _context16.stop();
                  }
                }
              }, _callee16, this);
            }));

            function getNumericSpec(_x10) {
              return _getNumericSpec3.apply(this, arguments);
            }

            return getNumericSpec;
          }()
        }, {
          key: "getColumnsOfTypes",
          value: function getColumnsOfTypes(typeList, tableName) {
            var _this14 = this;

            if (tableName && this.tables[tableName]) {
              return this.tables[tableName].getColumnsOfTypes(typeList);
            }

            var result = [];
            Object.keys(this.tables).forEach(function (table) {
              _this14.tables[table].getColumnsOfTypes(typeList).forEach(function (columnName) {
                if (result.indexOf(columnName) < 0) {
                  result.push(columnName);
                }
              });
            });
            return result;
          }
        }, {
          key: "getTypes",
          value: function getTypes(columnName) {
            var _this15 = this;

            var tableName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            if (tableName && this.tables[tableName]) {
              return [this.tables[tableName].getColumnType(columnName)];
            } else {
              var hasColumn = function hasColumn(table, columnName) {
                return table.columnNames.indexOf(columnName) >= 0;
              };

              var tableNamesWithColumn = this.tableNames.filter(function (name) {
                return hasColumn(_this15.tables[name], columnName);
              });

              if (tableNamesWithColumn.length == 0) {
                return [];
              }

              var tablesWithColumn = tableNamesWithColumn.map(function (name) {
                return _this15.tables[name];
              });
              var result = [tablesWithColumn[0].getColumnType(columnName)];
              tablesWithColumn.slice(1).forEach(function (table) {
                var colType = table.getColumnType(columnName);

                if (result.indexOf(colType) < 0) {
                  result.push(colType);
                }
              });
              return result;
            }
          }
        }, {
          key: "tableNames",
          get: function get() {
            return Object.keys(this.tables);
          }
        }, {
          key: "viewNames",
          get: function get() {
            return Object.keys(this.views);
          }
        }]);

        return GalyleoDataManager;
      }();

      __varRecorder__$j.GalyleoDataManager = GalyleoDataManager;
      var convertSDMLValue = __varRecorder__$j.convertSDMLValue;
      var convertSDMLRow = __varRecorder__$j.convertSDMLRow;
      __varRecorder__$j.GalyleoDataManager = GalyleoDataManager;
      __varRecorder__$j.GalyleoView = GalyleoView;
      __varRecorder__$j.constructGalyleoTable = constructGalyleoTable;
      __varRecorder__$j.URLFetcher = URLFetcher;
      __varRecorder__$j.RemoteGalyleoTable = RemoteGalyleoTable;
      __varRecorder__$j.ExplicitGalyleoTable = ExplicitGalyleoTable;
      __varRecorder__$j.GalyleoTable = GalyleoTable;
      __varRecorder__$j.constructFilter = constructFilter;
      __varRecorder__$j.checkSpecValid = checkSpecValid;
      __varRecorder__$j.Filter = Filter;
      __varRecorder__$j.convertSDMLValue = convertSDMLValue;
      __varRecorder__$j.convertSDMLRow = convertSDMLRow;

      var __varRecorder__$i = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/utils.js", __contextModule__);

      __varRecorder__$i.loadGoogleChartsAndExecute = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(callback) {
          var packageList, check;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  packageList = ["corechart", "geochart", "charteditor", "table", "controls"];

                case 1:
                  if (!(!window.google || !window.google.charts)) {
                    _context.next = 6;
                    break;
                  }

                  _context.next = 4;
                  return loadViaScript("https://www.gstatic.com/charts/loader.js");

                case 4:
                  _context.next = 1;
                  break;

                case 6:
                  check = function check(_) {
                    var _window$google, _window$google$visual;

                    if ((_window$google = window.google) === null || _window$google === void 0 ? void 0 : (_window$google$visual = _window$google.visualization) === null || _window$google$visual === void 0 ? void 0 : _window$google$visual.ChartEditor) {
                      callback();
                    } else {
                      setTimeout(check, 25);
                    }
                  };

                  window.google.charts.load("current", {
                    packages: packageList,
                    mapsApiKey: "AIzaSyA4uHMmgrSNycQGwdF3PSkbuNW49BAwN1I"
                  });
                  check();

                case 9:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }();

      var loadGoogleChartsAndExecute = __varRecorder__$i.loadGoogleChartsAndExecute;
      __varRecorder__$i.loadGoogleChartsAndExecute = loadGoogleChartsAndExecute;

      var GoogleChartLoader = /*#__PURE__*/function () {
        function GoogleChartLoader() {
          var _this = this;

          _classCallCheck(this, GoogleChartLoader);

          this.queuedCharts = [];
          this.chartsReady = false;

          __varRecorder__$i.loadGoogleChartsAndExecute(function (_) {
            _this.googleChartLoaderFinished();
          });
        }

        _createClass(GoogleChartLoader, [{
          key: "queueChart",
          value: function queueChart(dashboard, chartName) {
            this.queuedCharts.push({
              dashboard: dashboard,
              chartName: chartName
            });
          }
        }, {
          key: "googleChartLoaderFinished",
          value: function googleChartLoaderFinished() {
            this.chartsReady = true;
            this.queuedCharts.forEach(function (chartObject) {
              return chartObject.dashboard.drawChart(chartObject.chartName);
            });
          }
        }]);

        return GoogleChartLoader;
      }();

      __varRecorder__$i.GoogleChartLoader = GoogleChartLoader;
      __varRecorder__$i.GOOGLE_CHART_LOADER = new __varRecorder__$i.GoogleChartLoader();
      var GOOGLE_CHART_LOADER = __varRecorder__$i.GOOGLE_CHART_LOADER;
      __varRecorder__$i.GOOGLE_CHART_LOADER = GOOGLE_CHART_LOADER;

      var __varRecorder__$h = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/dashboard-common.cp.js", __contextModule__);

      var DashboardCommon = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/dashboard-common.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DashboardCommon") && typeof __lively_classholder__.DashboardCommon === "function" ? __lively_classholder__.DashboardCommon : __lively_classholder__.DashboardCommon = function DashboardCommon(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "_ensureDataManager_",
          value: function DashboardCommon__ensureDataManager__() {
            if (!this.dataManager) {
              this.dataManager = new GalyleoDataManager();
            }
          }
        }, {
          key: "clear",
          value: function DashboardCommon_clear_() {
            var _this = this;

            this._ensureDataManager_();

            this.dataManager.clear();
            this.filterNames.forEach(function (filterName) {
              _this.filters[filterName].morph.remove();
            });
            this.fill = Color$1.rgb(255, 255, 255);
            this.filters = {};
            this.chartNames.forEach(function (chartName) {
              _this.charts[chartName].chartMorph.remove();
            });
            this.charts = {};
            this.defaultFilters = {};
            this.view.removeAllMorphs();
            this.dirty = false;
          }
        }, {
          key: "_loadAllDemoDashboards",
          value: function () {
            var _DashboardCommon__loadAllDemoDashboards_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var url, jsonForm;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      url = "https://raw.githubusercontent.com/engageLively/galyleo-examples/main/demos/manifest.json";
                      _context.next = 3;
                      return resource(url).readJson();

                    case 3:
                      jsonForm = _context.sent;
                      this._demoDashboards = jsonForm.dashboards;

                    case 5:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function DashboardCommon__loadAllDemoDashboards_() {
              return _DashboardCommon__loadAllDemoDashboards_.apply(this, arguments);
            }

            return DashboardCommon__loadAllDemoDashboards_;
          }()
        }, {
          key: "_loadAllTestDashboards",
          value: function () {
            var _DashboardCommon__loadAllTestDashboards_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
              var prefix, url, jsonForm;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      prefix = "https://raw.githubusercontent.com/engageLively/galyleo-test-dashboards/main";
                      url = "".concat(prefix, "/manifest.json");
                      _context2.next = 4;
                      return resource(url).readJson();

                    case 4:
                      jsonForm = _context2.sent;
                      this._testDashboards = jsonForm.dashboards;

                    case 6:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function DashboardCommon__loadAllTestDashboards_() {
              return _DashboardCommon__loadAllTestDashboards_.apply(this, arguments);
            }

            return DashboardCommon__loadAllTestDashboards_;
          }()
        }, {
          key: "testDashboards",
          get: function get() {
            if (this._testDashboards) {
              var result = {};
              var prefix = "https://raw.githubusercontent.com/engageLively/galyleo-test-dashboards/main";

              this._testDashboards.forEach(function (name) {
                return result[name] = "".concat(prefix, "/").concat(name, ".gd.json");
              });

              return result;
            } else {
              return {};
            }
          }
        }, {
          key: "demoDashboards",
          get: function get() {
            if (this._demoDashboards) {
              var result = {};
              var prefix = "https://raw.githubusercontent.com/engageLively/galyleo-examples/main/demos";

              this._demoDashboards.forEach(function (name) {
                return result[name] = "".concat(prefix, "/").concat(name, ".gd.json");
              });

              return result;
            } else {
              return {};
            }
          }
        }, {
          key: "loadTestDashboard",
          value: function () {
            var _DashboardCommon_loadTestDashboard_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(dashboardName) {
              var dashboardUrl;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      if (this._testDashboards) {
                        _context3.next = 3;
                        break;
                      }

                      _context3.next = 3;
                      return this._loadAllTestDashboards();

                    case 3:
                      dashboardUrl = this.testDashboards[dashboardName];

                      if (dashboardUrl) {
                        this.loadDashboardFromURL(dashboardUrl);
                      }

                    case 5:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function DashboardCommon_loadTestDashboard_(_x) {
              return _DashboardCommon_loadTestDashboard_.apply(this, arguments);
            }

            return DashboardCommon_loadTestDashboard_;
          }()
        }, {
          key: "loadDemoDashboard",
          value: function () {
            var _DashboardCommon_loadDemoDashboard_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(dashboardName) {
              var dashboardUrl;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      if (this._demoDashboards) {
                        _context4.next = 3;
                        break;
                      }

                      _context4.next = 3;
                      return this._loadAllDemoDashboards();

                    case 3:
                      dashboardUrl = this.demoDashboards[dashboardName];

                      if (dashboardUrl) {
                        this.loadDashboardFromURL(dashboardUrl);
                      }

                    case 5:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function DashboardCommon_loadDemoDashboard_(_x2) {
              return _DashboardCommon_loadDemoDashboard_.apply(this, arguments);
            }

            return DashboardCommon_loadDemoDashboard_;
          }()
        }, {
          key: "_normalizeURL",
          value: function DashboardCommon__normalizeURL_(anURL) {
            try {
              var test = new _URL(anURL);
              return anURL;
            } catch (anError) {}

            var test1 = "http://" + anURL;
            var result = new _URL(test1);
            var hostNames = result.host.split(":")[0].split(".");
            var hostValues = hostNames.map(function (name) {
              return Number(name);
            });
            var ipAddress = hostValues.reduce(function (ipAddr, value) {
              return ipAddr && !isNaN(value);
            }, true);

            if (ipAddress) {
              return result.href;
            } else {
              return "https" + result.href.slice(4);
            }
          }
        }, {
          key: "loadDashboardFromURL",
          value: function () {
            var _DashboardCommon_loadDashboardFromURL_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
              var anURL,
                  fixedUrl,
                  loadResource,
                  jsonForm,
                  check,
                  _args5 = arguments;
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      anURL = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : "https://raw.githubusercontent.com/engageLively/galyleo-test-dashboards/main/mtbf_mttr_dashboard.gd.json";
                      _context5.prev = 1;
                      fixedUrl = this._normalizeURL(anURL);
                      loadResource = resource(fixedUrl);
                      loadResource.useCors = false;
                      _context5.next = 7;
                      return loadResource.readJson();

                    case 7:
                      jsonForm = _context5.sent;
                      check = this.checkIntermediateForm(jsonForm);

                      if (!check.valid) {
                        _context5.next = 14;
                        break;
                      }

                      _context5.next = 12;
                      return this._restoreFromSaved(jsonForm);

                    case 12:
                      _context5.next = 15;
                      break;

                    case 14:
                      $world.inform(check.message);

                    case 15:
                      return _context5.abrupt("return", check.valid);

                    case 18:
                      _context5.prev = 18;
                      _context5.t0 = _context5["catch"](1);
                      $world.inform("Error loading from ".concat(anURL));
                      return _context5.abrupt("return", false);

                    case 22:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this, [[1, 18]]);
            }));

            function DashboardCommon_loadDashboardFromURL_() {
              return _DashboardCommon_loadDashboardFromURL_.apply(this, arguments);
            }

            return DashboardCommon_loadDashboardFromURL_;
          }()
        }, {
          key: "checkJSONForm",
          value: function DashboardCommon_checkJSONForm_(string) {
            var dashboardObject = JSON.parse(string);
            return this.checkIntermediateForm(dashboardObject);
          }
        }, {
          key: "checkIntermediateForm",
          value: function DashboardCommon_checkIntermediateForm_(dashboardObject) {
            if (_typeof(dashboardObject) !== "object") {
              return {
                valid: false,
                message: "Parsed JSON was not an Object"
              };
            }

            var fields = Object.keys(dashboardObject);
            var expectedFields = ["tables", "views", "filters", "charts"];
            var optionalFields = ["fill", "morphs", "numMorphs"];
            var missingFields = expectedFields.filter(function (field) {
              return fields.indexOf(field) < 0;
            });
            var allFields = expectedFields.concat(optionalFields);
            var newFields = fields.filter(function (field) {
              return allFields.indexOf(field) < 0;
            });

            if (missingFields.length === 0 && newFields.length === 0) {
              return {
                valid: true
              };
            } else {
              var missingMessage = "was missing fields ".concat(missingFields);
              var unexpectedMessage = "had unexpected fields ".concat(newFields);
              var message = missingFields.length === 0 ? "File ".concat(unexpectedMessage) : newFields.length === 0 ? "File ".concat(missingMessage) : "File ".concat(missingMessage, " and ").concat(unexpectedMessage);
              return {
                valid: false,
                message: message
              };
            }
          }
        }, {
          key: "_getFieldValue",
          value: function DashboardCommon__getFieldValue_(source, field) {
            var value = source[field.name];
            return field.validCheck(value) ? value : field["default"];
          }
        }, {
          key: "_getFields",
          value: function DashboardCommon__getFields_(object, fields) {
            var _this2 = this;

            var result = {};
            fields.forEach(function (field) {
              return result[field.name] = _this2._getFieldValue(object, field);
            });
            return result;
          }
        }, {
          key: "_morphicFields",
          get: function get() {
            var clipModes = ["hidden", "visible", "auto", "scroll"];
            return [{
              name: "rotation",
              validCheck: function validCheck(rotation) {
                return !isNaN(rotation);
              },
              "default": 0
            }, {
              name: "scale",
              validCheck: function validCheck(scale) {
                return !isNaN(scale) && scale > 0;
              },
              "default": 1
            }, {
              name: "clipMode",
              validCheck: function validCheck(mode) {
                return clipModes.indexOf(mode) >= 0;
              },
              "default": "visible"
            }, {
              name: "opacity",
              validCheck: function validCheck(opacity) {
                return !isNaN(opacity) && opacity >= 0 && opacity <= 1;
              },
              "default": 1
            }];
          }
        }, {
          key: "_textFields",
          get: function get() {
            var styles = ["normal", "italic", "oblique"];
            var weights = ["normal", "bold", "bolder", "light", "lighter"];
            var aligns = ["center", "justify", "left", "right"];
            var wrapping = [false, true, "by-words", "anywhere", "only-by-words", "wider", "by-chars", "false", "true"];
            var decorations = ["none", "underline"];
            return [{
              name: "fixedHeight",
              validCheck: function validCheck(value) {
                return typeof value === "boolean";
              },
              "default": false
            }, {
              name: "fixedWidth",
              validCheck: function validCheck(value) {
                return typeof value === "boolean";
              },
              "default": false
            }, {
              name: "fontFamily",
              validCheck: function validCheck(family) {
                return typeof family === "string";
              },
              "default": "Noto Sans"
            }, {
              name: "fontSize",
              validCheck: function validCheck(fontSize) {
                return !isNaN(fontSize) && fontSize > 0;
              },
              "default": 11
            }, {
              name: "fontStyle",
              validCheck: function validCheck(style) {
                return styles.indexOf(style) >= 0;
              },
              "default": "normal"
            }, {
              name: "fontWeight",
              validCheck: function validCheck(weight) {
                return weights.indexOf(weight) >= 0;
              },
              "default": "normal"
            }, {
              name: "lineWrapping",
              validCheck: function validCheck(wrap) {
                return wrapping.indexOf(wrap) >= 0;
              },
              "default": false
            }, {
              name: "textAlign",
              validCheck: function validCheck(align) {
                return aligns.indexOf(align) >= 0;
              },
              "default": "left"
            }, {
              name: "textDecoration",
              validCheck: function validCheck(decoration) {
                return decorations.indexOf(decoration) >= 0;
              },
              "default": "none"
            }, {
              name: "textString",
              validCheck: function validCheck(str) {
                return true;
              },
              "default": ""
            }];
          }
        }, {
          key: "_complexMorphicFields",
          value: function DashboardCommon__complexMorphicFields_(aMorph) {
            var shadow = aMorph.dropShadow ? aMorph.dropShadow.toJson() : null;
            var result = {
              position: aMorph.position,
              extent: aMorph.extent,
              fill: aMorph.fill ? aMorph.fill.toJSExpr() : null,
              border: aMorph.border,
              origin: aMorph.origin
            };

            if (shadow) {
              result.dropShadow = shadow;
            }

            return result;
          }
        }, {
          key: "_complexTextFields",
          value: function DashboardCommon__complexTextFields_(aMorph) {
            return {
              fontColor: aMorph.fontColor,
              padding: aMorph.padding,
              textAndAttributes: aMorph.textAndAttributes
            };
          }
        }, {
          key: "_reorderMorphs",
          value: function DashboardCommon__reorderMorphs_(orderedMorphs) {
            var _this3 = this;

            if (orderedMorphs === null) {
              return;
            }

            var nonNulls = orderedMorphs.filter(function (morph) {
              return morph;
            });
            this.canvas.submorphs.forEach(function (m) {
              if (nonNulls.indexOf(m) < 0) {
                nonNulls.push(m);
              }

              m.remove();
            });
            nonNulls.forEach(function (m) {
              _this3.view.addMorph(m);
            });
          }
        }, {
          key: "_color",
          value: function DashboardCommon__color_(rgba) {
            var defaultColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Color$1.white;

            try {
              if (isString(rgba)) {
                return new ExpressionSerializer().deserializeExprObj({
                  __expr__: rgba,
                  bindings: {
                    "lively.graphics": ["Color", "RadialGradient", "LinearGradient", "pt", "rect"]
                  }
                });
              }

              return Color$1.rgba(rgba.r * 255, rgba.g * 255, rgba.b * 255, rgba.a);
            } catch (error) {
              return defaultColor;
            }
          }
        }, {
          key: "_returnValidPoint",
          value: function DashboardCommon__returnValidPoint_(literal, defaultVal) {
            if (literal) {
              try {
                return Point.fromLiteral(literal);
              } catch (error) {
                return defaultVal;
              }
            } else {
              return defaultVal;
            }
          }
        }, {
          key: "_returnValidNumber",
          value: function DashboardCommon__returnValidNumber_(number, defaultVal) {
            var minVal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            if (isNaN(number)) {
              return defaultVal;
            }

            if (isNaN(minVal)) {
              return number;
            }

            return number >= minVal ? number : defaultVal;
          }
        }, {
          key: "_setComplexFields",
          value: function DashboardCommon__setComplexFields_(aMorph, fieldDescriptor) {
            var _this4 = this;

            var canvas = this.canvas;
            aMorph.position = this._returnValidPoint(fieldDescriptor.position, canvas.extent.scaleBy(0.5));
            aMorph.extent = this._returnValidPoint(fieldDescriptor.extent, pt(50, 50));
            aMorph.origin = this._returnValidPoint(fieldDescriptor.origin, pt(0, 0));
            aMorph.fill = this._color(fieldDescriptor.fill, Color$1.rgba(0, 0, 0, 0));
            var borderStyles = ["none", "hidden", "dashed", "dotted", "solid", "double", "groove", "ridge", "inset", "outset"];
            var newBorder = {
              borderRadius: this._returnValidNumber(fieldDescriptor.border.borderRadius, 0, 0),
              width: this._returnValidNumber(fieldDescriptor.border.width, 0, 0),
              style: borderStyles.indexOf(fieldDescriptor.border.style) >= 0 ? fieldDescriptor.border.style : "none",
              color: {}
            };
            var sides = ["top", "bottom", "left", "right"];
            sides.forEach(function (side) {
              return newBorder.color[side] = _this4._color(fieldDescriptor.border.color[side]);
            }, Color$1.rgba(0, 0, 0, 0));
            aMorph.border = newBorder;

            if (fieldDescriptor.hasOwnProperty("dropShadow")) {
              try {
                aMorph.dropShadow = new ShadowObject(fieldDescriptor.dropShadow);
                aMorph.dropShadow.color = this._color(fieldDescriptor.dropShadow.color, Color$1.rgba(0, 0, 0, 0));
              } catch (error) {}
            }
          }
        }, {
          key: "_setComplexTextFields",
          value: function DashboardCommon__setComplexTextFields_(textMorph, descriptor) {
            textMorph.fontColor = this._color(descriptor.fontColor, Color$1.black);
            textMorph.padding = Rectangle.fromLiteral(descriptor.padding);

            if (descriptor.textAndAttributes) {
              textMorph.textAndAttributes = descriptor.textAndAttributes;
            }
          }
        }, {
          key: "_setFields",
          value: function DashboardCommon__setFields_(morph, descriptor, fields) {
            var _this5 = this;

            fields.forEach(function (field) {
              return morph[field.name] = _this5._getFieldValue(descriptor, field);
            });
          }
        }, {
          key: "restoreFromSavedForm",
          value: function () {
            var _DashboardCommon_restoreFromSavedForm_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(storedForm) {
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      if (!(typeof storedForm === "string")) {
                        _context6.next = 5;
                        break;
                      }

                      _context6.next = 3;
                      return this.restoreFromJSONForm(storedForm);

                    case 3:
                      _context6.next = 8;
                      break;

                    case 5:
                      if (!(_typeof(storedForm) === "object")) {
                        _context6.next = 8;
                        break;
                      }

                      _context6.next = 8;
                      return this._restoreFromSaved(storedForm);

                    case 8:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function DashboardCommon_restoreFromSavedForm_(_x3) {
              return _DashboardCommon_restoreFromSavedForm_.apply(this, arguments);
            }

            return DashboardCommon_restoreFromSavedForm_;
          }()
        }, {
          key: "restoreFromJSONForm",
          value: function () {
            var _DashboardCommon_restoreFromJSONForm_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(storedForm) {
              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      _context7.prev = 0;
                      _context7.next = 3;
                      return this._restoreFromSaved(JSON.parse(storedForm));

                    case 3:
                      _context7.next = 7;
                      break;

                    case 5:
                      _context7.prev = 5;
                      _context7.t0 = _context7["catch"](0);

                    case 7:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7, this, [[0, 5]]);
            }));

            function DashboardCommon_restoreFromJSONForm_(_x4) {
              return _DashboardCommon_restoreFromJSONForm_.apply(this, arguments);
            }

            return DashboardCommon_restoreFromJSONForm_;
          }()
        }, {
          key: "_restoreFromSaved",
          value: function () {
            var _DashboardCommon__restoreFromSaved_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(storedForm) {
              var _this6 = this;

              var unorderedDescriptors, storedFilterNames, i, filterName, savedFilter, getColumnNameTableAndType, storedChartNames, _i, chartName, storedChart, descriptor, filterType, filter, morphNames, morphDescriptors;

              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      if (!this._restore) {
                        _context8.next = 2;
                        break;
                      }

                      return _context8.abrupt("return");

                    case 2:
                      this.storedForm = storedForm;
                      this._restore = true;

                      if (GALYLEO_ENV.debug) {
                        console.log("Restoring from stored form");
                      }

                      _context8.prev = 5;
                      unorderedDescriptors = [];
                      this.clear();

                      if (storedForm.fill) {
                        this.canvas.fill = this._color(storedForm.fill, Color$1.white);

                        if (GALYLEO_ENV.debug) {
                          console.log("Restored fill to ".concat(this.canvas.fill));
                        }
                      }

                      this.dataManager = new GalyleoDataManager(this);

                      if (GALYLEO_ENV.debug) {
                        console.log("Restoring tables ".concat(Object.keys(storedForm.tables)));
                      }

                      Object.keys(storedForm.tables).forEach(function (tableName) {
                        _this6.addTable({
                          name: tableName,
                          table: storedForm.tables[tableName]
                        });
                      });

                      if (GALYLEO_ENV.debug) {
                        console.log("Restoring views ".concat(Object.keys(storedForm.views)));
                      }

                      Object.keys(storedForm.views).forEach(function (viewName) {
                        _this6.dataManager.addView(viewName, storedForm.views[viewName]);
                      });
                      storedFilterNames = Object.keys(storedForm.filters);

                      if (GALYLEO_ENV.debug) {
                        console.log("Restoring filters ".concat(Object.keys(storedForm.filters)));
                      }

                      i = 0;

                    case 17:
                      if (!(i < storedFilterNames.length)) {
                        _context8.next = 27;
                        break;
                      }

                      filterName = storedFilterNames[i];
                      savedFilter = storedForm.filters[filterName].savedForm;
                      _context8.next = 22;
                      return this._makeDefaultFilter(savedFilter.columnName, savedFilter.filterType, savedFilter.tableName);

                    case 22:
                      this.defaultFilters[filterName] = _context8.sent;
                      unorderedDescriptors.push({
                        type: "filter",
                        filterName: filterName,
                        descriptor: storedForm.filters[filterName]
                      });

                    case 24:
                      i++;
                      _context8.next = 17;
                      break;

                    case 27:
                      getColumnNameTableAndType = function getColumnNameTableAndType(viewOrTableName) {
                        if (_this6.dataManager.tables[viewOrTableName]) {
                          var table = _this6.dataManager.tables[viewOrTableName];
                          return {
                            columnName: table.columns[0].name,
                            type: table.columns[0].type,
                            tableName: viewOrTableName
                          };
                        } else {
                          var view = _this6.dataManager.views[viewOrTableName];
                          var _table = _this6.dataManager.tables[view.tableName];
                          return {
                            columnName: view.columns[0],
                            type: _table.getColumnType(view.columns[0]),
                            tableName: view.tableName
                          };
                        }
                      };

                      if (GALYLEO_ENV.debug) {
                        console.log("Restoring charts ".concat(Object.keys(storedForm.charts)));
                      }

                      storedChartNames = Object.keys(storedForm.charts);
                      _i = 0;

                    case 31:
                      if (!(_i < storedChartNames.length)) {
                        _context8.next = 44;
                        break;
                      }

                      chartName = storedChartNames[_i];
                      storedChart = storedForm.charts[chartName];
                      descriptor = getColumnNameTableAndType(storedChart.viewOrTable);
                      filterType = descriptor.type == "number" ? "NumericSelect" : "Select";
                      _context8.next = 38;
                      return this._makeDefaultFilter(descriptor.columnName, filterType, descriptor.tableName);

                    case 38:
                      filter = _context8.sent;
                      this.defaultFilters[chartName] = filter;
                      unorderedDescriptors.push({
                        type: "chart",
                        chartName: chartName,
                        descriptor: storedChart
                      });

                    case 41:
                      _i++;
                      _context8.next = 31;
                      break;

                    case 44:
                      morphNames = Object.keys(storedForm.morphs || []);

                      if (GALYLEO_ENV.debug) {
                        console.log("Restoring morphs ".concat(morphNames));
                      }

                      morphDescriptors = morphNames.map(function (name) {
                        return storedForm.morphs[name];
                      }).filter(function (desc) {
                        return desc;
                      });
                      morphDescriptors.forEach(function (morphDescriptor) {
                        unorderedDescriptors.push({
                          type: "morph",
                          descriptor: morphDescriptor
                        });
                      });
                      _context8.next = 50;
                      return this._restoreMorphsFromDescriptors(unorderedDescriptors);

                    case 50:
                      _context8.next = 55;
                      break;

                    case 52:
                      _context8.prev = 52;
                      _context8.t0 = _context8["catch"](5);
                      console.log("Error in _restoreFromSaved_: ".concat(_context8.t0));

                    case 55:
                      if (GALYLEO_ENV.debug) {
                        console.log("Finished restore and drawing all charts");
                      }

                      this._restore = false;
                      this.drawAllCharts();

                    case 58:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, this, [[5, 52]]);
            }));

            function DashboardCommon__restoreFromSaved_(_x5) {
              return _DashboardCommon__restoreFromSaved_.apply(this, arguments);
            }

            return DashboardCommon__restoreFromSaved_;
          }()
        }, {
          key: "_restoreMorphsFromDescriptors",
          value: function () {
            var _DashboardCommon__restoreMorphsFromDescriptors_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(descriptors) {
              var desc_sort, morphs, i, descriptor;
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      desc_sort = function desc_sort(desc1, desc2) {
                        return desc1.descriptor.morphIndex - desc2.descriptor.morphIndex;
                      };

                      descriptors.sort(desc_sort);
                      morphs = [];
                      i = 0;

                    case 4:
                      if (!(i < descriptors.length)) {
                        _context9.next = 26;
                        break;
                      }

                      descriptor = descriptors[i];

                      if (!(descriptor.type === "chart")) {
                        _context9.next = 14;
                        break;
                      }

                      _context9.t0 = morphs;
                      _context9.next = 10;
                      return this._restoreChartFromSaved(descriptor.chartName, descriptor.descriptor);

                    case 10:
                      _context9.t1 = _context9.sent;

                      _context9.t0.push.call(_context9.t0, _context9.t1);

                      _context9.next = 23;
                      break;

                    case 14:
                      if (!(descriptor.type === "filter")) {
                        _context9.next = 22;
                        break;
                      }

                      _context9.t2 = morphs;
                      _context9.next = 18;
                      return this._restoreFilterFromSaved(descriptor.filterName, descriptor.descriptor);

                    case 18:
                      _context9.t3 = _context9.sent;

                      _context9.t2.push.call(_context9.t2, _context9.t3);

                      _context9.next = 23;
                      break;

                    case 22:
                      morphs.push(this._restoreMorphFromSaved(descriptor.descriptor));

                    case 23:
                      i++;
                      _context9.next = 4;
                      break;

                    case 26:
                      this.dirty = false;
                      return _context9.abrupt("return", morphs);

                    case 28:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, this);
            }));

            function DashboardCommon__restoreMorphsFromDescriptors_(_x6) {
              return _DashboardCommon__restoreMorphsFromDescriptors_.apply(this, arguments);
            }

            return DashboardCommon__restoreMorphsFromDescriptors_;
          }()
        }, {
          key: "_restoreInternalFilterFromSaved",
          value: function () {
            var _DashboardCommon__restoreInternalFilterFromSaved_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(filterName, storedForm) {
              var savedFilter, storedFilter, externalFilterMorph;
              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      savedFilter = storedForm.filters[filterName];
                      storedFilter = savedFilter.savedForm;
                      if (storedFilter.toJS) storedFilter = storedFilter.toJS();
                      _context10.next = 5;
                      return this.createExternalFilter(filterName, storedFilter.columnName, storedFilter.filterType, this._ensurePart(storedFilter.part), storedFilter.tableName);

                    case 5:
                      externalFilterMorph = _context10.sent;
                      externalFilterMorph.filterMorph.restoreFromSavedForm(storedFilter);
                      _context10.next = 9;
                      return this.makeFilterMorph(savedFilter.columnName, savedFilter.filterType, savedFilter.part, savedFilter.tableName);

                    case 9:
                      return _context10.abrupt("return", _context10.sent);

                    case 10:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, this);
            }));

            function DashboardCommon__restoreInternalFilterFromSaved_(_x7, _x8) {
              return _DashboardCommon__restoreInternalFilterFromSaved_.apply(this, arguments);
            }

            return DashboardCommon__restoreInternalFilterFromSaved_;
          }()
        }, {
          key: "_restoreMorphicProperties",
          value: function DashboardCommon__restoreMorphicProperties_(savedForm, morph) {
            var complexPropertySource = savedForm.hasOwnProperty("complexMorphicProperties") ? savedForm.complexMorphicProperties : savedForm.morphicProperties;

            this._setComplexFields(morph, complexPropertySource);

            this._setFields(morph, savedForm.morphicProperties, this._morphicFields);
          }
        }, {
          key: "_restoreFilterFromSaved",
          value: function () {
            var _DashboardCommon__restoreFilterFromSaved_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(filterName, savedFilter) {
              var storedFilter, externalFilterMorph;
              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      storedFilter = savedFilter.savedForm;
                      if (storedFilter.toJS) storedFilter = storedFilter.toJS();
                      _context11.next = 4;
                      return this.createExternalFilter(filterName, storedFilter.columnName, storedFilter.filterType, this._ensurePart(storedFilter.part), storedFilter.tableName);

                    case 4:
                      externalFilterMorph = _context11.sent;

                      this._restoreMorphicProperties(savedFilter, externalFilterMorph);

                      _context11.next = 8;
                      return externalFilterMorph.whenRendered();

                    case 8:
                      return _context11.abrupt("return", externalFilterMorph);

                    case 9:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11, this);
            }));

            function DashboardCommon__restoreFilterFromSaved_(_x9, _x10) {
              return _DashboardCommon__restoreFilterFromSaved_.apply(this, arguments);
            }

            return DashboardCommon__restoreFilterFromSaved_;
          }()
        }, {
          key: "_ensurePart",
          value: function DashboardCommon__ensurePart_(componentOrString) {
            var partName;

            if (componentOrString.exportedName) {
              partName = componentOrString.exportedName;
            } else if (componentOrString.startsWith("part://")) {
              var pathParts = componentOrString.split("/");
              partName = pathParts[pathParts.length - 1];
            } else {
              partName = componentOrString;
            }

            var parts = {
              "select filter": SelectFilter,
              SelectFilter: SelectFilter,
              DateFilter: DateFilter,
              "list filter": ListFilter,
              ListFilter: ListFilter,
              "range filter": RangeFilter,
              RangeFilter: RangeFilter,
              SliderFilter: SliderFilter,
              booleanFilter: BooleanFilter$1,
              BooleanFilter: BooleanFilter$1,
              doubleSliderFilter: DoubleSliderFilter,
              DoubleSliderFilter: DoubleSliderFilter
            };
            return parts[partName];
          }
        }, {
          key: "_restoreChartFromSaved",
          value: function () {
            var _DashboardCommon__restoreChartFromSaved_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(chartName, storedChart) {
              var chartSpecification, chartMorph;
              return regeneratorRuntime.wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      if (storedChart.toJS) storedChart = storedChart.toJS();
                      chartSpecification = {
                        chartType: storedChart.chartType,
                        options: storedChart.options,
                        viewOrTable: storedChart.viewOrTable
                      };
                      _context12.next = 4;
                      return this.addChart(chartName, chartSpecification, false);

                    case 4:
                      chartMorph = this.charts[chartName].chartMorph;

                      this._restoreMorphicProperties(storedChart, chartMorph);

                      if (GALYLEO_ENV.debug) {
                        console.log("Morphic properties restored for ".concat(chartName));
                      }

                      return _context12.abrupt("return", chartMorph);

                    case 8:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12, this);
            }));

            function DashboardCommon__restoreChartFromSaved_(_x11, _x12) {
              return _DashboardCommon__restoreChartFromSaved_.apply(this, arguments);
            }

            return DashboardCommon__restoreChartFromSaved_;
          }()
        }, {
          key: "_restoreMorphFromSaved",
          value: function DashboardCommon__restoreMorphFromSaved_(morphDescriptor) {
            var restoredMorph = morph({
              type: morphDescriptor.type
            });
            restoredMorph.name = morphDescriptor.name;

            this._restoreMorphicProperties(morphDescriptor, restoredMorph);

            if (morphDescriptor.imageUrl) {
              restoredMorph.imageUrl = morphDescriptor.imageUrl;
            }

            this.view.addMorph(restoredMorph);

            if (morphDescriptor.textProperties) {
              var complexTextFieldsSource = morphDescriptor.hasOwnProperty("complexTextProperties") ? morphDescriptor.complexTextProperties : morphDescriptor.textProperties;

              this._setFields(restoredMorph, morphDescriptor.textProperties, this._textFields);

              this._setComplexTextFields(restoredMorph, complexTextFieldsSource);
            }
          }
        }, {
          key: "tableNames",
          get: function get() {
            return this.dataManager ? this.dataManager.tableNames : [];
          }
        }, {
          key: "filterNames",
          get: function get() {
            return this.filters ? Object.keys(this.filters) : [];
          }
        }, {
          key: "viewNames",
          get: function get() {
            return this.dataManager ? this.dataManager.viewNames : [];
          }
        }, {
          key: "chartNames",
          get: function get() {
            return this.charts ? Object.keys(this.charts) : [];
          }
        }, {
          key: "_allNames",
          get: function get() {
            var names = this.canvas.submorphs.map(function (m) {
              return m.name;
            });
            return names.concat(this.filterNames).concat(this.chartNames);
          }
        }, {
          key: "nameOK",
          value: function DashboardCommon_nameOK_(aName) {
            return this._allNames.indexOf(aName) < 0;
          }
        }, {
          key: "_makeDefaultFilter",
          value: function () {
            var _DashboardCommon__makeDefaultFilter_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(columnName, filterType, tableName) {
              var parameters, _parameters, values;

              return regeneratorRuntime.wrap(function _callee13$(_context13) {
                while (1) {
                  switch (_context13.prev = _context13.next) {
                    case 0:
                      if (!(filterType == "Range")) {
                        _context13.next = 7;
                        break;
                      }

                      _context13.next = 3;
                      return this.dataManager.getNumericSpec(columnName, tableName);

                    case 3:
                      parameters = _context13.sent;
                      return _context13.abrupt("return", {
                        operator: "IN_RANGE",
                        column: columnName,
                        max_val: parameters.max,
                        min_val: parameters.min
                      });

                    case 7:
                      if (!(filterType === "NumericSelect")) {
                        _context13.next = 14;
                        break;
                      }

                      _context13.next = 10;
                      return this.dataManager.getNumericSpec(columnName, tableName);

                    case 10:
                      _parameters = _context13.sent;
                      return _context13.abrupt("return", {
                        operator: "IN_LIST",
                        values: [_parameters.min_val]
                      });

                    case 14:
                      _context13.next = 16;
                      return this.dataManager.getAllValues(columnName, tableName);

                    case 16:
                      values = _context13.sent;
                      return _context13.abrupt("return", {
                        operator: "IN_LIST",
                        values: [values[0]]
                      });

                    case 18:
                    case "end":
                      return _context13.stop();
                  }
                }
              }, _callee13, this);
            }));

            function DashboardCommon__makeDefaultFilter_(_x13, _x14, _x15) {
              return _DashboardCommon__makeDefaultFilter_.apply(this, arguments);
            }

            return DashboardCommon__makeDefaultFilter_;
          }()
        }, {
          key: "createExternalFilter",
          value: function () {
            var _DashboardCommon_createExternalFilter_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(filterName, columnName, filterType, filterPart, tableName) {
              var filterMorph, namedFilterMorphProto;
              return regeneratorRuntime.wrap(function _callee14$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      _context14.next = 2;
                      return this.makeFilterMorph(columnName, filterType, filterPart, tableName);

                    case 2:
                      filterMorph = _context14.sent;
                      namedFilterMorphProto = part(NamedFilter);
                      namedFilterMorphProto.init(filterMorph, filterName);
                      namedFilterMorphProto.position = pt(0, 0);
                      connect(namedFilterMorphProto, "filterChanged", this, "drawAllCharts");
                      this.addFilter(filterName, {
                        morph: namedFilterMorphProto
                      });
                      this.canvas.addMorph(namedFilterMorphProto);
                      return _context14.abrupt("return", namedFilterMorphProto);

                    case 10:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee14, this);
            }));

            function DashboardCommon_createExternalFilter_(_x16, _x17, _x18, _x19, _x20) {
              return _DashboardCommon_createExternalFilter_.apply(this, arguments);
            }

            return DashboardCommon_createExternalFilter_;
          }()
        }, {
          key: "makeFilterMorph",
          value: function () {
            var _DashboardCommon_makeFilterMorph_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(columnName, filterType, filterPart) {
              var tableName,
                  morph,
                  parameters,
                  values,
                  shifted,
                  differences,
                  types,
                  isString,
                  _values,
                  _args15 = arguments;

              return regeneratorRuntime.wrap(function _callee15$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      tableName = _args15.length > 3 && _args15[3] !== undefined ? _args15[3] : null;
                      morph = part(filterPart);

                      if (!(filterType === "Range")) {
                        _context15.next = 9;
                        break;
                      }

                      _context15.next = 5;
                      return this.dataManager.getNumericSpec(columnName, tableName);

                    case 5:
                      parameters = _context15.sent;
                      morph.init(columnName, tableName, parameters.min_val, parameters.max_val, parameters.increment);
                      _context15.next = 28;
                      break;

                    case 9:
                      if (!(filterType === "NumericSelect")) {
                        _context15.next = 22;
                        break;
                      }

                      _context15.next = 12;
                      return this.dataManager.getAllValues(columnName, tableName);

                    case 12:
                      values = _context15.sent;
                      values = values.map(function (value) {
                        return Number(value);
                      }).filter(function (value) {
                        return !isNaN(value);
                      });
                      values.sort(function (a, b) {
                        return a - b;
                      });
                      shifted = values.slice(1);
                      differences = shifted.map(function (value, index) {
                        return value - values[index];
                      });
                      differences.sort(function (a, b) {
                        return a - b;
                      });
                      this.createRecord = {
                        column: columnName,
                        type: filterType,
                        values: values
                      };
                      morph.init(columnName, tableName, values[0], values[values.length - 1], differences[0]);
                      _context15.next = 28;
                      break;

                    case 22:
                      types = this.dataManager.getTypes(columnName, tableName);
                      isString = types && types.length === 1 && types[0] === "string";
                      _context15.next = 26;
                      return this.dataManager.getAllValues(columnName);

                    case 26:
                      _values = _context15.sent;
                      morph.init(columnName, _values, tableName, isString);

                    case 28:
                      return _context15.abrupt("return", morph);

                    case 29:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee15, this);
            }));

            function DashboardCommon_makeFilterMorph_(_x21, _x22, _x23) {
              return _DashboardCommon_makeFilterMorph_.apply(this, arguments);
            }

            return DashboardCommon_makeFilterMorph_;
          }()
        }, {
          key: "_createGVizColumn",
          value: function DashboardCommon__createGVizColumn_(galyleoColumn) {
            return {
              id: galyleoColumn.name,
              label: galyleoColumn.name,
              type: galyleoColumn.type
            };
          }
        }, {
          key: "prepareData",
          value: function () {
            var _DashboardCommon_prepareData_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(viewOrTable) {
              var _this7 = this;

              var table, columns, rows, result;
              return regeneratorRuntime.wrap(function _callee16$(_context16) {
                while (1) {
                  switch (_context16.prev = _context16.next) {
                    case 0:
                      if (window.google.visualization) {
                        _context16.next = 2;
                        break;
                      }

                      return _context16.abrupt("return", null);

                    case 2:
                      if (!(this.dataManager.tableNames.indexOf(viewOrTable) >= 0)) {
                        _context16.next = 13;
                        break;
                      }

                      table = this.dataManager.tables[viewOrTable];
                      columns = table.columns.map(function (column) {
                        return _this7._createGVizColumn(column);
                      });
                      _context16.next = 7;
                      return table.getRows();

                    case 7:
                      rows = _context16.sent;
                      result = new window.google.visualization.DataTable({
                        cols: columns
                      });
                      result.addRows(rows);
                      return _context16.abrupt("return", result);

                    case 13:
                      if (!(this.dataManager.viewNames.indexOf(viewOrTable) >= 0)) {
                        _context16.next = 19;
                        break;
                      }

                      _context16.next = 16;
                      return this._prepareViewData(viewOrTable);

                    case 16:
                      return _context16.abrupt("return", _context16.sent);

                    case 19:
                      return _context16.abrupt("return", null);

                    case 20:
                    case "end":
                      return _context16.stop();
                  }
                }
              }, _callee16, this);
            }));

            function DashboardCommon_prepareData_(_x24) {
              return _DashboardCommon_prepareData_.apply(this, arguments);
            }

            return DashboardCommon_prepareData_;
          }()
        }, {
          key: "_getFilterForName",
          value: function DashboardCommon__getFilterForName_(widgetOrChartName) {
            if (this.filters[widgetOrChartName]) {
              return this.filters[widgetOrChartName].morph.dataManagerFilter;
            } else if (this.charts[widgetOrChartName]) {
              return this.charts[widgetOrChartName].dataManagerFilter;
            } else if (this.defaultFilters[widgetOrChartName]) {
              return this.defaultFilters[widgetOrChartName];
            }
          }
        }, {
          key: "_filterValid",
          value: function DashboardCommon__filterValid_(aFilter, table) {
            if (!aFilter) {
              return false;
            }

            var fields = Object.keys(aFilter);

            if (fields.indexOf("operator") >= 0) {
              return checkSpecValid(table, aFilter);
            } else {
              if (fields.indexOf("columnName") < 0) {
                return false;
              }

              if (fields.indexOf("minValue") >= 0) {
                return fields.indexOf("maxValue") >= 0 && !isNaN(aFilter.minValue) && !isNaN(aFilter.maxValue);
              }

              return fields.indexOf("value") >= 0 && aFilter.value !== undefined && aFilter.value !== "__no_selection__";
            }
          }
        }, {
          key: "_getFiltersForView",
          value: function DashboardCommon__getFiltersForView_(view) {
            var _this8 = this;

            var filtersInView = view.filterNames.map(function (name) {
              return _this8._getFilterForName(name);
            });
            var table = this.dataManager.tables[view.tableName];
            return filtersInView.filter(function (filter) {
              return _this8._filterValid(filter, table);
            });
          }
        }, {
          key: "_prepareViewData",
          value: function () {
            var _DashboardCommon__prepareViewData_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(viewName) {
              var _this9 = this;

              var aView, filterSpecs, columns, result, rows;
              return regeneratorRuntime.wrap(function _callee17$(_context17) {
                while (1) {
                  switch (_context17.prev = _context17.next) {
                    case 0:
                      aView = this.dataManager.views[viewName];

                      if (aView) {
                        _context17.next = 3;
                        break;
                      }

                      return _context17.abrupt("return");

                    case 3:
                      filterSpecs = {};
                      aView.filterNames.forEach(function (filterName) {
                        filterSpecs[filterName] = _this9._getFilterForName(filterName);
                      });
                      columns = aView.fullColumns(this.dataManager.tables).map(function (column) {
                        return _this9._createGVizColumn(column);
                      });
                      result = new window.google.visualization.DataTable({
                        cols: columns
                      });
                      _context17.next = 9;
                      return aView.getData(filterSpecs, this.dataManager.tables);

                    case 9:
                      rows = _context17.sent;
                      result.addRows(rows);
                      return _context17.abrupt("return", result);

                    case 12:
                    case "end":
                      return _context17.stop();
                  }
                }
              }, _callee17, this);
            }));

            function DashboardCommon__prepareViewData_(_x25) {
              return _DashboardCommon__prepareViewData_.apply(this, arguments);
            }

            return DashboardCommon__prepareViewData_;
          }()
        }, {
          key: "_makeHeaderString",
          value: function DashboardCommon__makeHeaderString_(categoryColumn, seriesColumns, viewOrTableName) {
            if (seriesColumns.length <= 2 && seriesColumns.length > 0) {
              return "".concat(seriesColumns.join(", "), " v ").concat(categoryColumn);
            } else {
              return viewOrTableName;
            }
          }
        }, {
          key: "_getColumnNames",
          value: function DashboardCommon__getColumnNames_(table) {
            if (table.hasOwnProperty("cols")) {
              return table.cols.map(function (col) {
                return col.id;
              });
            } else {
              return table.columns.map(function (column) {
                return column.name;
              });
            }
          }
        }, {
          key: "_makeTitleForTable",
          value: function DashboardCommon__makeTitleForTable_(aTable, tableName) {
            var columns = this._getColumnNames(aTable);

            return this._makeHeaderString(columns[0], columns.slice(1), tableName);
          }
        }, {
          key: "_filterString",
          value: function DashboardCommon__filterString_(filter) {
            var fields = Object.keys(filter);

            if (fields.indexOf("column") >= 0) {
              if (fields.indexOf("values") >= 0) {
                if (filter.values.length === 0) {
                  return null;
                } else if (filter.values.length === 1) {
                  return "".concat(filter.column, " = ").concat(filter.values[0]);
                } else {
                  return "".concat(filter.column, " in ").concat(filter.values);
                }
              }

              if (fields.indexOf("max_val") >= 0) {
                return "".concat(filter.max_val, " >= ").concat(filter.column, " >= ").concat(filter.min_val);
              }

              return null;
            } else {
              var columnName = filter.columnName;

              if (fields.indexOf("value") >= 0) {
                return "".concat(columnName, " = ").concat(filter.value);
              } else if (fields.indexOf("minValue") >= 0) {
                return "".concat(filter.maxValue, " >= ").concat(columnName, " >= ").concat(filter.minValue);
              }

              return null;
            }
          }
        }, {
          key: "_makeTitleForView",
          value: function DashboardCommon__makeTitleForView_(aView, viewName) {
            var _this10 = this;

            var seriesColumns = aView.columns.slice(1);

            var headerString = this._makeHeaderString(aView.columns[0], seriesColumns, viewName);

            var filters = this._getFiltersForView(aView);

            if (filters.length > 0) {
              var filterStrings = filters.map(function (filter) {
                return _this10._filterString(filter);
              });
              var realStrings = filterStrings.filter(function (string) {
                return string;
              });
              var joinedString = realStrings.join(", ");
              return "".concat(headerString, " where ").concat(joinedString);
            } else {
              return headerString;
            }
          }
        }, {
          key: "_makeTitle",
          value: function DashboardCommon__makeTitle_(chart) {
            if (chart.chartType === "Table") {
              return;
            }

            var title;
            var name = chart.viewOrTable;
            !!this.dataManager;
            var tableDict = this.dataManager.tables;
            var viewDict = this.dataManager.views;
            var tableNames = Object.keys(tableDict);
            var viewNames = Object.keys(viewDict);

            if (tableNames.indexOf(name) >= 0) {
              title = this._makeTitleForTable(tableDict[name], name);
            } else if (viewNames.indexOf(chart.viewOrTable) >= 0) {
              title = this._makeTitleForView(viewDict[name], name);
            } else {
              return null;
            }

            chart.options.title = title;
          }
        }, {
          key: "addView",
          value: function DashboardCommon_addView_(viewName, spec) {
            this.dataManager.addView(viewName, spec);
          }
        }, {
          key: "init",
          value: function () {
            var _DashboardCommon_init_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
              var _this11 = this;

              return regeneratorRuntime.wrap(function _callee18$(_context18) {
                while (1) {
                  switch (_context18.prev = _context18.next) {
                    case 0:
                      ["charts", "filters"].forEach(function (prop) {
                        if (!_this11[prop]) {
                          _this11[prop] = {};
                        }
                      });

                      if (this.gCharts) {
                        this.gCharts.setOnLoadCallback(function () {
                          _this11.drawAllCharts();
                        });
                      }

                      this.dirty = false;

                      if (!this.dataManager) {
                        this.dataManager = new GalyleoDataManager(this);
                      }

                    case 4:
                    case "end":
                      return _context18.stop();
                  }
                }
              }, _callee18, this);
            }));

            function DashboardCommon_init_() {
              return _DashboardCommon_init_.apply(this, arguments);
            }

            return DashboardCommon_init_;
          }()
        }, {
          key: "_loadGoogleChartPackages",
          value: function () {
            var _DashboardCommon__loadGoogleChartPackages_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
              var packageList,
                  _args19 = arguments;
              return regeneratorRuntime.wrap(function _callee19$(_context19) {
                while (1) {
                  switch (_context19.prev = _context19.next) {
                    case 0:
                      packageList = _args19.length > 0 && _args19[0] !== undefined ? _args19[0] : ["corechart", "map", "charteditor", "visualization"];

                    case 1:
                      if (!(!window.google || !window.google.charts)) {
                        _context19.next = 6;
                        break;
                      }

                      _context19.next = 4;
                      return loadViaScript("https://www.gstatic.com/charts/loader.js");

                    case 4:
                      _context19.next = 1;
                      break;

                    case 6:
                      if (window.google.visualization) {
                        _context19.next = 11;
                        break;
                      }

                      _context19.next = 9;
                      return this.gCharts.load("50", {
                        packages: packageList,
                        mapsApiKey: "AIzaSyA4uHMmgrSNycQGwdF3PSkbuNW49BAwN1I"
                      });

                    case 9:
                      _context19.next = 6;
                      break;

                    case 11:
                    case "end":
                      return _context19.stop();
                  }
                }
              }, _callee19, this);
            }));

            function DashboardCommon__loadGoogleChartPackages_() {
              return _DashboardCommon__loadGoogleChartPackages_.apply(this, arguments);
            }

            return DashboardCommon__loadGoogleChartPackages_;
          }()
        }, {
          key: "addTable",
          value: function DashboardCommon_addTable_(tableSpec) {
            this.lastTable = tableSpec;

            if (!this.dataManager) {
              this.dataManager = new GalyleoDataManager(this);
            }

            this.dataManager.addTable(tableSpec.name, tableSpec.table);
          }
        }, {
          key: "displayPreview",
          value: function DashboardCommon_displayPreview_(tableName) {
            if (!this.tables[tableName]) {
              return;
            }

            var tableViewer = part(TableViewer).openInWorld();
            tableViewer.init(tableName, this.tables[tableName]);
          }
        }, {
          key: "addFilter",
          value: function DashboardCommon_addFilter_(filterName, filterSpec) {
            this.filters[filterName] = filterSpec;

            if (this.dashboardController) {
              this.dashboardController.update();
            }

            this.dirty = true;
          }
        }, {
          key: "tableUpdated",
          value: function DashboardCommon_tableUpdated_(table) {
            this.drawAllCharts();
          }
        }, {
          key: "drawAllCharts",
          value: function DashboardCommon_drawAllCharts_() {
            var _this12 = this;

            var chartNames = this.chartNames;
            chartNames.forEach(function (name) {
              return _this12.drawChart(name);
            });
          }
        }, {
          key: "_makeWrapper",
          value: function () {
            var _DashboardCommon__makeWrapper_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(chart, chartName) {
              var _this13 = this;

              var dataTable, filter, wrapper;
              return regeneratorRuntime.wrap(function _callee20$(_context20) {
                while (1) {
                  switch (_context20.prev = _context20.next) {
                    case 0:
                      _context20.next = 2;
                      return this.prepareData(chart.viewOrTable);

                    case 2:
                      dataTable = _context20.sent;

                      if (dataTable) {
                        _context20.next = 5;
                        break;
                      }

                      return _context20.abrupt("return", null);

                    case 5:
                      _context20.next = 7;
                      return this._prepareChartFilter(chart.viewOrTable);

                    case 7:
                      filter = _context20.sent;

                      if (filter) {
                        _context20.next = 10;
                        break;
                      }

                      return _context20.abrupt("return", null);

                    case 10:
                      if (!(chart.filter && chart.filter.columnName === filter.columnName)) {
                        chart.filter = filter;
                      }

                      wrapper = new window.google.visualization.ChartWrapper({
                        chartType: chart.chartType,
                        options: chart.options
                      });
                      this.lastChartType = [chart.chartType, wrapper.getType()];
                      wrapper.setDataTable(dataTable);
                      window.google.visualization.events.addListener(wrapper, "select", function (e) {
                        _this13._updateChartFilter(e, wrapper, chartName);
                      });
                      window.google.visualization.events.addListener(wrapper, "ready", function (e) {
                        _this13._setChartForChartMorph(e, wrapper, chartName);
                      });
                      window.google.visualization.events.addListener(wrapper, "error", function (e) {
                        _this13._setErrorForChart(e, chartName);
                      });
                      return _context20.abrupt("return", wrapper);

                    case 18:
                    case "end":
                      return _context20.stop();
                  }
                }
              }, _callee20, this);
            }));

            function DashboardCommon__makeWrapper_(_x26, _x27) {
              return _DashboardCommon__makeWrapper_.apply(this, arguments);
            }

            return DashboardCommon__makeWrapper_;
          }()
        }, {
          key: "_setChartForChartMorph",
          value: function DashboardCommon__setChartForChartMorph_(e, wrapper, chartName) {
            if (GALYLEO_ENV.debug) {
              console.log("Chart ready event for ".concat(chartName, ": ").concat(wrapper.getChart()));
            }

            this.charts[chartName].actualChart = wrapper.getChart();
          }
        }, {
          key: "_setErrorForChartMorph",
          value: function DashboardCommon__setErrorForChartMorph_(e, chartName) {
            console.log("Error in drawing chart ".concat(chartName, ": ").concat(e.message));
            this.charts[chartName].error = {
              id: e.id,
              message: e.message
            };
          }
        }, {
          key: "_updateChartFilter",
          value: function DashboardCommon__updateChartFilter_(e, wrapper, chartName) {
            this._lastEvent = {
              evt: e,
              wrapper: wrapper,
              chartName: chartName
            };
            var chart = wrapper.getChart();
            this._lastEvent.chart = chart;
            var table = wrapper.getDataTable();
            this._lastEvent.table = table;
            var selection = chart.getSelection();
            this._lastEvent.selection = selection;
            var row = selection[0].row == null ? null : selection[0].row;
            var col = selection[0].col == null ? 0 : selection[0].col;
            this._lastEvent.coords = {
              row: row,
              col: col
            };
            var value = table.getValue(row, col);
            this._lastEvent.value = value;

            if (this.charts[chartName].dataManagerFilter) {
              this.charts[chartName].dataManagerFilter.values = [value];
              this.drawAllCharts();
            }

            var record = {
              event: e,
              wrapper: wrapper,
              chart: chart,
              value: value,
              name: chartName
            };

            if (!this._chartEvents) {
              this._chartEvents = [record];
            } else {
              this._chartEvents.push(record);
            }
          }
        }, {
          key: "_finishDraw",
          value: function () {
            var _DashboardCommon__finishDraw_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(chartName, chart) {
              return regeneratorRuntime.wrap(function _callee21$(_context21) {
                while (1) {
                  switch (_context21.prev = _context21.next) {
                    case 0:
                    case "end":
                      return _context21.stop();
                  }
                }
              }, _callee21);
            }));

            function DashboardCommon__finishDraw_(_x28, _x29) {
              return _DashboardCommon__finishDraw_.apply(this, arguments);
            }

            return DashboardCommon__finishDraw_;
          }()
        }, {
          key: "drawChart",
          value: function () {
            var _DashboardCommon_drawChart_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(chartName) {
              var chart, wrapper;
              return regeneratorRuntime.wrap(function _callee22$(_context22) {
                while (1) {
                  switch (_context22.prev = _context22.next) {
                    case 0:
                      if (!GOOGLE_CHART_LOADER.chartsReady) {
                        _context22.next = 11;
                        break;
                      }

                      chart = this.charts[chartName];

                      if (chart) {
                        _context22.next = 4;
                        break;
                      }

                      return _context22.abrupt("return");

                    case 4:
                      this._makeTitle(chart);

                      _context22.next = 7;
                      return this._makeWrapper(chart, chartName);

                    case 7:
                      wrapper = _context22.sent;

                      if (wrapper) {
                        this.lastWrapper = wrapper;
                        chart.chartMorph.drawChart(wrapper);
                      }

                      _context22.next = 12;
                      break;

                    case 11:
                      GOOGLE_CHART_LOADER.queueChart(this, chartName);

                    case 12:
                    case "end":
                      return _context22.stop();
                  }
                }
              }, _callee22, this);
            }));

            function DashboardCommon_drawChart_(_x30) {
              return _DashboardCommon_drawChart_.apply(this, arguments);
            }

            return DashboardCommon_drawChart_;
          }()
        }, {
          key: "addChart",
          value: function () {
            var _DashboardCommon_addChart_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(chartName, chartSpecification) {
              return regeneratorRuntime.wrap(function _callee23$(_context23) {
                while (1) {
                  switch (_context23.prev = _context23.next) {
                    case 0:
                      _context23.next = 3;
                      return this._getChartMorph(chartName);

                    case 3:
                      chartSpecification.chartMorph = _context23.sent;
                      this.charts[chartName] = chartSpecification;
                      _context23.next = 7;
                      return this._prepareChartFilter(chartSpecification.viewOrTable);

                    case 7:
                      chartSpecification.dataManagerFilter = _context23.sent;
                      this.drawChart(chartName);

                    case 9:
                    case "end":
                      return _context23.stop();
                  }
                }
              }, _callee23, this);
            }));

            function DashboardCommon_addChart_(_x31, _x32) {
              return _DashboardCommon_addChart_.apply(this, arguments);
            }

            return DashboardCommon_addChart_;
          }()
        }, {
          key: "_prepareChartFilter",
          value: function () {
            var _DashboardCommon__prepareChartFilter_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(viewOrTableName) {
              var tableName, dataManagerFilter, view, table, values;
              return regeneratorRuntime.wrap(function _callee24$(_context24) {
                while (1) {
                  switch (_context24.prev = _context24.next) {
                    case 0:
                      dataManagerFilter = {
                        operator: "IN_LIST"
                      };

                      if (!this.dataManager.views[viewOrTableName]) {
                        _context24.next = 7;
                        break;
                      }

                      view = this.dataManager.views[viewOrTableName];
                      dataManagerFilter.column = view.columns[0];
                      tableName = view.tableName;
                      _context24.next = 14;
                      break;

                    case 7:
                      if (!this.dataManager.tables[viewOrTableName]) {
                        _context24.next = 13;
                        break;
                      }

                      table = this.dataManager.tables[viewOrTableName];
                      dataManagerFilter.column = table.columns[0].name;
                      tableName = viewOrTableName;
                      _context24.next = 14;
                      break;

                    case 13:
                      return _context24.abrupt("return", null);

                    case 14:
                      _context24.next = 16;
                      return this.dataManager.getAllValues(dataManagerFilter.column, tableName);

                    case 16:
                      values = _context24.sent;

                      if (values && values.length > 0) {
                        dataManagerFilter.values = [values[0]];
                      }

                      return _context24.abrupt("return", dataManagerFilter);

                    case 19:
                    case "end":
                      return _context24.stop();
                  }
                }
              }, _callee24, this);
            }));

            function DashboardCommon__prepareChartFilter_(_x33) {
              return _DashboardCommon__prepareChartFilter_.apply(this, arguments);
            }

            return DashboardCommon__prepareChartFilter_;
          }()
        }, {
          key: "_getChartMorph",
          value: function () {
            var _DashboardCommon__getChartMorph_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(chartName) {
              var currentMorphsForChart, chartMorph;
              return regeneratorRuntime.wrap(function _callee25$(_context25) {
                while (1) {
                  switch (_context25.prev = _context25.next) {
                    case 0:
                      currentMorphsForChart = this.canvas.submorphs.filter(function (morph) {
                        return morph.isChart && morph.name === chartName;
                      });

                      if (!(currentMorphsForChart && currentMorphsForChart.length > 0)) {
                        _context25.next = 3;
                        break;
                      }

                      return _context25.abrupt("return", currentMorphsForChart[0]);

                    case 3:
                      chartMorph = part(GoogleChartHolder);
                      chartMorph.init(chartName);
                      this.canvas.addMorph(chartMorph);
                      chartMorph.position = pt(0, 0);
                      return _context25.abrupt("return", chartMorph);

                    case 8:
                    case "end":
                      return _context25.stop();
                  }
                }
              }, _callee25, this);
            }));

            function DashboardCommon__getChartMorph_(_x34) {
              return _DashboardCommon__getChartMorph_.apply(this, arguments);
            }

            return DashboardCommon__getChartMorph_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DashboardCommon";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              canvas: {
                get: function get() {
                  return this.view;
                }
              },
              gViz: {
                derived: true,
                get: function get() {
                  return window.google ? window.google.visualization : null;
                }
              },
              gCharts: {
                derived: true,
                get: function get() {
                  return window.google ? window.google.charts : null;
                }
              },
              expose: {
                get: function get() {
                  return ["clear", "checkAndLoad", "checkPossibleRenameFromBrowser", "checkPossibleRename", "displayPreview", "dependencyGraph", "testDashboards", "loadTestDashboard", "loadDashboardFromFile", "checkAndSave", "saveDashboardToFile", "prepareJSONForm", "restoreFromJSONForm", "restoreFromSavedForm", "getColumnsOfType", "openDialog", "confirm", "isDirty", "clearSnapshots", "commands", "init", "tables", "addTable", "tableNames", "views", "viewNames", "update", "addView", "createViewEditor", "filters", "addFilter", "removeFilter", "filterNames", "charts", "chartNames", "addChart", "editChartStyle", "removeChart", "createExternalFilter", "relayout", "dataManager"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    signal: "onSubmorphChange",
                    handler: "onSubmorphChange"
                  }, {
                    signal: "onDrag",
                    handler: "onDrag",
                    override: true
                  }, {
                    signal: "addMorph",
                    handler: "setContext"
                  }, {
                    signal: "removeMorph",
                    handler: "clearSideBarFocus"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/dashboard-common.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 1044,
          end: 67250
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$h.DashboardCommon = DashboardCommon;

      var __varRecorder__$g = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/dashboard.cp.js", __contextModule__);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/dashboard.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("SaveDialogMorph") && typeof __lively_classholder__.SaveDialogMorph === "function" ? __lively_classholder__.SaveDialogMorph : __lively_classholder__.SaveDialogMorph = function SaveDialogMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "init",
          value: function SaveDialogMorph_init_(dashboard, path) {
            this.dashboard = dashboard;

            if (path && path.length > 0) {
              this.getSubmorphNamed("fileInput").textString = path;
            }
          }
        }, {
          key: "save",
          value: function () {
            var _SaveDialogMorph_save_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var filePath;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      filePath = this.getSubmorphNamed("fileInput").textString;
                      _context.next = 3;
                      return this.dashboard.checkAndSave(filePath);

                    case 3:
                      if (!_context.sent) {
                        _context.next = 5;
                        break;
                      }

                      this.remove();

                    case 5:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function SaveDialogMorph_save_() {
              return _SaveDialogMorph_save_.apply(this, arguments);
            }

            return SaveDialogMorph_save_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "SaveDialogMorph";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/dashboard.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 1090,
          end: 2072
        });
      })({
        referencedAs: "Morph",
        value: Morph
      });

      __varRecorder__$g.SaveDialog = component["for"](function () {
        return component(GalyleoWindow, {
          type: __varRecorder__$g.SaveDialogMorph,
          name: "save dialog",
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "center",
            orderByIndex: true,
            resizePolicies: [["window title", {
              height: "fixed",
              width: "fill"
            }]],
            spacing: 15,
            wrapSubmorphs: false
          }),
          extent: pt(340.5, 155.8),
          submorphs: [{
            name: "window title",
            textString: "Save Dashboard to..."
          }, add(part(GalyleoSearch, {
            name: "file input",
            placeholder: "path/to/file"
          })), add({
            name: "button wrapper",
            layout: new TilingLayout({
              align: "center",
              axisAlign: "center",
              justifySubmorphs: "spaced",
              orderByIndex: true,
              padding: rect(26, 26, 0, 0)
            }),
            borderColor: Color$1.rgb(23, 160, 251),
            borderWidth: 0,
            extent: pt(310.9, 57.7),
            fill: Color$1.rgba(0, 0, 0, 0),
            submorphs: [part(PromptButton, {
              name: "save button",
              extent: pt(81.7, 31.8),
              master: PromptButton,
              position: pt(9.6, 8.9),
              submorphs: [without("icon"), {
                name: "label",
                textAndAttributes: ["Save", null]
              }]
            }), part(PromptButton, {
              name: "cancel button",
              extent: pt(92.8, 34.2),
              master: PromptButton,
              position: pt(174.2, 44.5),
              submorphs: [without("icon"), {
                name: "label",
                textAndAttributes: ["Cancel", null]
              }]
            })]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/dashboard.cp.js",
        "export": "SaveDialog",
        range: {
          start: 2080,
          end: 3568
        }
      }, System, __varRecorder__$g, "SaveDialog");

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/dashboard.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("LoadDialogModel") && typeof __lively_classholder__.LoadDialogModel === "function" ? __lively_classholder__.LoadDialogModel : __lively_classholder__.LoadDialogModel = function LoadDialogModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "init",
          value: function LoadDialogModel_init_(dashboard, path) {
            this.dashboard = dashboard;

            if (path && path.length > 0) {
              this.ui.fileInput.textString = path;
            }
          }
        }, {
          key: "load",
          value: function () {
            var _LoadDialogModel_load_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
              var filePath;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      filePath = this.ui.fileInput.textString;
                      _context2.next = 3;
                      return this.dashboard.loadDashboardFromURL(filePath);

                    case 3:
                      if (!_context2.sent) {
                        _context2.next = 5;
                        break;
                      }

                      this.view.remove();

                    case 5:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function LoadDialogModel_load_() {
              return _LoadDialogModel_load_.apply(this, arguments);
            }

            return LoadDialogModel_load_;
          }()
        }, {
          key: "cancel",
          value: function LoadDialogModel_cancel_() {
            this.view.remove();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "LoadDialogModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["init"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    model: "cancel button",
                    signal: "fire",
                    handler: "cancel"
                  }, {
                    model: "load button",
                    signal: "fire",
                    handler: "load"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/dashboard.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 3571,
          end: 4998
        });
      })({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      __varRecorder__$g.LoadDialog = component["for"](function () {
        return component(GalyleoWindow, {
          defaultViewModel: __varRecorder__$g.LoadDialogModel,
          name: "load dialog",
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "center",
            orderByIndex: true,
            resizePolicies: [["window title", {
              height: "fixed",
              width: "fill"
            }]],
            spacing: 15,
            wrapSubmorphs: false
          }),
          extent: pt(340.5, 155.8),
          submorphs: [{
            name: "window title",
            textString: "Load Dashboard from..."
          }, add(part(GalyleoSearch, {
            name: "file input",
            placeholder: "url/to/dashboard"
          })), add({
            name: "button wrapper",
            layout: new TilingLayout({
              align: "center",
              axisAlign: "center",
              justifySubmorphs: "spaced",
              orderByIndex: true,
              padding: rect(26, 26, 0, 0)
            }),
            borderColor: Color$1.rgb(23, 160, 251),
            borderWidth: 0,
            extent: pt(310.9, 57.7),
            fill: Color$1.rgba(0, 0, 0, 0),
            submorphs: [part(PromptButton, {
              name: "load button",
              extent: pt(81.7, 31.8),
              master: PromptButton,
              position: pt(9.6, 8.9),
              submorphs: [without("icon"), {
                name: "label",
                textAndAttributes: ["Load", null]
              }]
            }), part(PromptButton, {
              name: "cancel button",
              extent: pt(92.8, 34.2),
              master: PromptButton,
              position: pt(174.2, 44.5),
              submorphs: [without("icon"), {
                name: "label",
                textAndAttributes: ["Cancel", null]
              }]
            })]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/dashboard.cp.js",
        "export": "LoadDialog",
        range: {
          start: 5034,
          end: 6540
        }
      }, System, __varRecorder__$g, "LoadDialog");
      var Dashboard = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/dashboard.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("Dashboard") && typeof __lively_classholder__.Dashboard === "function" ? __lively_classholder__.Dashboard : __lively_classholder__.Dashboard = function Dashboard(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "tables",
          get: function get() {
            return this.dataManager ? this.dataManager.tables : {};
          }
        }, {
          key: "views",
          get: function get() {
            return this.dataManager ? this.dataManager.views : {};
          }
        }, {
          key: "dependencyGraph",
          get: function get() {
            var _this = this;

            var result = {
              charts: {},
              views: {}
            };
            Object.keys(this.charts).forEach(function (chartName) {
              result.charts[chartName] = _this.charts[chartName].viewOrTable;
            });
            Object.keys(this.views).forEach(function (viewName) {
              result.views[viewName] = {
                filters: _this.views[viewName].filterNames,
                table: _this.views[viewName].table
              };
            });
            return result;
          }
        }, {
          key: "_ensureUserAvatar",
          value: function Dashboard__ensureUserAvatar_() {
            var avatar = this.get("user avatar");
            if (!avatar) return;
            var user = $world.getCurrentUser();
            avatar.imageUrl = resource("https://s.gravatar.com/avatar").join(md5(user.email || "")).withQuery({
              s: 160
            }).url;
          }
        }, {
          key: "_updateProjectName_",
          value: function Dashboard__updateProjectName__() {
            var titleBar = this.get("title bar");
            var projectName = "No Current Project";

            if (window.EXTENSION_INFO && window.EXTENSION_INFO.currentFilePath) {
              projectName = window.EXTENSION_INFO.currentFilePath;
            }

            if (titleBar) {
              titleBar.getSubmorphNamed("projectName").textString = projectName;
            }
          }
        }, {
          key: "checkPossibleRenameFromBrowser",
          value: function Dashboard_checkPossibleRenameFromBrowser_(browserModel, changedArgs) {
            if (changedArgs.oldValue.path === window.EXTENSION_INFO.currentFilePath) {
              window.EXTENSION_INFO.currentFilePath = changedArgs.newValue.path;

              this._updateProjectName_();
            }
          }
        }, {
          key: "checkPossibleRename",
          value: function Dashboard_checkPossibleRename_(drive, changedInfo) {
            if (changedInfo.type !== "rename") {
              return;
            }

            if (changedInfo.oldValue.path === window.EXTENSIONINFO.currentFilePath) {
              window.EXTENSION_INFO.currentFilePath = changedInfo.newValue.path;

              this._updateProjectName_();
            }
          }
        }, {
          key: "clear",
          value: function Dashboard_clear_() {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "clear", this).call(this);

            if (this.dashboardController) {
              this.dashboardController.update();
            }
          }
        }, {
          key: "clearSideBarFocus",
          value: function Dashboard_clearSideBarFocus_() {
            this.dashboardController.viewModel.models.styleControl.clearFocus();
          }
        }, {
          key: "viewDidLoad",
          value: function Dashboard_viewDidLoad_() {
            if (GALYLEO_ENV.debug) {
              console.log("Dashboard: viewDidLoad, initialized = ".concat(this.initialized));
            }

            if (!this.initialized) {
              this.init();
            }

            this.setContext(this.view);
          }
        }, {
          key: "onSubmorphChange",
          value: function Dashboard_onSubmorphChange_(change, submorph) {
            if (!this._restore && change.prop === "position") {
              this._takeSnapshot();
            }
          }
        }, {
          key: "onDrag",
          value: function Dashboard_onDrag_(evt) {}
        }, {
          key: "commands",
          get: function get() {
            var _this2 = this;

            return [{
              name: "undo",
              exec: function exec() {
                _this2._undoChange();
              }
            }, {
              name: "redo",
              exec: function exec() {
                _this2._redoChange();
              }
            }];
          }
        }, {
          key: "dependencyGraph",
          get: function get() {
            var _this3 = this;

            var result = {
              charts: {},
              views: {}
            };
            Object.keys(this.charts).forEach(function (chartName) {
              result.charts[chartName] = _this3.charts[chartName].viewOrTable;
            });
            Object.keys(this.views).forEach(function (viewName) {
              result.views[viewName] = {
                filters: _this3.views[viewName].filterNames,
                table: _this3.views[viewName].table
              };
            });
            return result;
          }
        }, {
          key: "_updateProjectName",
          value: function Dashboard__updateProjectName_(path) {
            window.EXTENSION_INFO.currentFilePath = path;
          }
        }, {
          key: "_initializeJupyterLabCallbacks",
          value: function Dashboard__initializeJupyterLabCallbacks_() {
            var _this4 = this;

            var jupyterObject = window.EXTENSION_INFO;

            if (jupyterObject && !jupyterObject.callbackRegistered) {
              window.EXTENSION_INFO.callbackRegistered = jupyterObject.browserModel.fileChanged.connect(function (model, args) {
                if (GALYLEO_ENV.debug) {
                  console.log("File renamed in browser: ".concat(JSON.stringify(args)));
                }

                _this4.checkPossibleRenameFromBrowser(model, args);
              }, this);
            }
          }
        }, {
          key: "checkPossibleRenameFromBrowser",
          value: function Dashboard_checkPossibleRenameFromBrowser_(browserModel, changedArgs) {
            if (changedArgs.oldValue.path === window.EXTENSION_INFO.currentFilePath) {
              this._updateProjectName(changedArgs.newValue.path);
            }
          }
        }, {
          key: "checkPossibleRename",
          value: function Dashboard_checkPossibleRename_(drive, changedInfo) {
            if (changedInfo.type !== "rename") {
              return;
            }

            if (changedInfo.oldValue.path === window.EXTENSIONINFO.currentFilePath) {
              this._updateProjectName(changedInfo.newValue.path);
            }
          }
        }, {
          key: "prepareJSONForm",
          value: function Dashboard_prepareJSONForm_() {
            return JSON.stringify(this.prepareSerialization());
          }
        }, {
          key: "openDialog",
          value: function Dashboard_openDialog_(componentObject) {
            var dialog = part(componentObject);
            dialog.openInWorld();
            dialog.center = this.view.globalBounds().center();
            return dialog;
          }
        }, {
          key: "confirm",
          value: function () {
            var _Dashboard_confirm_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(ask) {
              var confirmDialog;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      confirmDialog = this.openDialog(GalyleoConfirmPrompt);
                      confirmDialog.title = ask;
                      _context3.next = 4;
                      return confirmDialog.activate();

                    case 4:
                      return _context3.abrupt("return", _context3.sent);

                    case 5:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function Dashboard_confirm_(_x) {
              return _Dashboard_confirm_.apply(this, arguments);
            }

            return Dashboard_confirm_;
          }()
        }, {
          key: "isDirty",
          value: function Dashboard_isDirty_() {
            return this._snapshots.length > 0;
          }
        }, {
          key: "clearSnapshots",
          value: function Dashboard_clearSnapshots_() {
            this._snapshots = [];
            this._changePointer = 0;
          }
        }, {
          key: "_morphSnapshot",
          value: function Dashboard__morphSnapshot_(aMorph) {
            var type = getClassName(aMorph);
            var storedForm = {
              type: type,
              position: aMorph.position,
              extent: aMorph.extent,
              name: aMorph.name,
              morphIndex: this.canvas.submorphs.indexOf(aMorph),
              morphicProperties: this._getFields(aMorph, this._morphicFields),
              complexMorphicProperties: this._complexMorphicFields(aMorph)
            };

            if (type === "Text") {
              storedForm.textProperties = this._getFields(aMorph, this._textFields);
              storedForm.complexTextProperties = this._complexTextFields(aMorph);
            } else if (type === "Image") {
              storedForm.imageUrl = aMorph.imageUrl;
            }

            return storedForm;
          }
        }, {
          key: "_takeSnapshot",
          value: function Dashboard__takeSnapshot_() {
            var _this5 = this;

            var canvas = this.canvas;
            if (!this._snapshots) this._snapshots = [];

            if (typeof this._changePointer === "undefined") {
              this._changePointer = Math.max(0, this._snapshots.length - 1);
            }

            this._snapshots = this._snapshots.slice(0, this._changePointer + 1);
            var allMorphs = canvas.submorphs.filter(function (morph) {
              return !(morph.isFilter || morph.isChart);
            });
            var snap = last(this._snapshots) || exports$1.fromJS(this.prepareSerialization());
            var newSnap = snap.updateIn(["tables"], function (tables) {
              return _this5.tableNames.reduce(function (tables, tableName) {
                return tables.set(tableName, _this5.tables[tableName]);
              }, tables);
            }).updateIn(["views"], function (views) {
              return _this5.viewNames.reduce(function (views, viewName) {
                return views.set(viewName, _this5.views[viewName]);
              }, views);
            }).updateIn(["charts"], function (charts) {
              return _this5.chartNames.reduce(function (charts, chartName) {
                var chart = _this5.charts[chartName];
                var morph = chart.chartMorph;
                return charts.updateIn([chartName], exports$1.Map(), function (current) {
                  return current.mergeDeep({
                    chartType: chart.chartType,
                    options: chart.options,
                    viewOrTable: chart.viewOrTable,
                    name: chartName,
                    position: morph.position,
                    extent: morph.extent,
                    morphIndex: canvas.submorphs.indexOf(morph),
                    morphicProperties: _this5._getFields(morph, _this5._morphicFields),
                    complexMorphicProperties: _this5._complexMorphicFields(morph)
                  });
                });
              }, charts);
            }).updateIn(["filters"], function (filters) {
              return _this5.filterNames.reduce(function (filters, filterName) {
                var externalMorph = _this5.filters[filterName].morph;
                return filters.updateIn([filterName], exports$1.Map(), function (current) {
                  return current.mergeDeep({
                    position: externalMorph.position,
                    extent: externalMorph.extent,
                    name: filterName,
                    savedForm: externalMorph.filterMorph.persistentForm,
                    morphIndex: canvas.submorphs.indexOf(externalMorph),
                    morphicProperties: _this5._getFields(externalMorph, _this5._morphicFields),
                    complexMorphicProperties: _this5._complexMorphicFields(externalMorph)
                  });
                });
              }, filters);
            }).updateIn(["morphs"], function (morphs) {
              return allMorphs.reduce(function (morphs, aMorph) {
                return morphs.updateIn([aMorph.name], exports$1.Map(), function (current) {
                  return current.mergeDeep(_this5._morphSnapshot(aMorph));
                });
              }, morphs);
            });
            newSnap.set("numMorphs", canvas.submorphs.length);

            this._snapshots.push(newSnap);

            this._changePointer = this._snapshots.length - 1;
            var dashboardFilePath = canvas.owner.viewModel.dashboardFilePath;
            window.parent.postMessage({
              method: "galyleo:setDirty",
              dirty: true,
              dashboardFilePath: dashboardFilePath
            }, "*");
          }
        }, {
          key: "prepareSerialization",
          value: function Dashboard_prepareSerialization_() {
            var _this6 = this;

            var canvas = this.canvas;
            var resultObject = {
              fill: canvas.fill ? canvas.fill.toJSExpr() : null,
              tables: {},
              views: {},
              charts: {},
              filters: {},
              morphs: {}
            };
            this.tableNames.forEach(function (tableName) {
              return resultObject.tables[tableName] = _this6.tables[tableName].toDictionary();
            });
            this.viewNames.forEach(function (viewName) {
              return resultObject.views[viewName] = _this6.views[viewName].toDictionary();
            });
            this.chartNames.forEach(function (chartName) {
              var chart = _this6.charts[chartName];
              var morph = chart.chartMorph;
              var result = {
                chartType: chart.chartType,
                options: chart.options,
                viewOrTable: chart.viewOrTable,
                morphIndex: canvas.submorphs.indexOf(morph),
                morphicProperties: _this6._getFields(morph, _this6._morphicFields)
              };
              Object.assign(result.morphicProperties, _this6._complexMorphicFields(morph));
              resultObject.charts[chartName] = result;
            });
            this.filterNames.forEach(function (filterName) {
              var externalMorph = _this6.filters[filterName].morph;
              var result = {
                savedForm: externalMorph.filterMorph.persistentForm,
                morphIndex: canvas.submorphs.indexOf(externalMorph),
                morphicProperties: _this6._getFields(externalMorph, _this6._morphicFields)
              };
              Object.assign(result.morphicProperties, _this6._complexMorphicFields(externalMorph));
              resultObject.filters[filterName] = result;
            });
            resultObject.morphs = canvas.submorphs.map(function (morph) {
              if (morph.isChart || morph.isFilter) {
                return null;
              }

              var result = {
                type: getClassName(morph),
                name: morph.name,
                morphIndex: canvas.submorphs.indexOf(morph),
                morphicProperties: _this6._getFields(morph, _this6._morphicFields)
              };
              Object.assign(result.morphicProperties, _this6._complexMorphicFields(morph));

              if (result.type === "Image") {
                result.imageUrl = morph.imageUrl;
              }

              if (result.type === "Text") {
                result.textProperties = _this6._getFields(morph, _this6._textFields);
                Object.assign(result.textProperties, _this6._complexTextFields(morph));
              }

              return result;
            }).filter(function (morph) {
              return morph;
            });
            resultObject.numMorphs = canvas.submorphs.length;
            return resultObject;
          }
        }, {
          key: "_getObjectsFromSnapshot",
          value: function Dashboard__getObjectsFromSnapshot_(snapObject) {
            var descriptors = [];
            var savedFilters = snapObject.filters.toJS();
            Object.keys(savedFilters).forEach(function (name) {
              descriptors.push({
                type: "filter",
                name: name,
                descriptor: savedFilters[name]
              });
            });
            var savedCharts = snapObject.charts.toJS();
            Object.keys(savedCharts).forEach(function (name) {
              descriptors.push({
                type: "chart",
                name: name,
                descriptor: savedCharts[name]
              });
            });
            var savedMorphs = snapObject.morphs.toJS();
            savedMorphs.forEach(function (savedMorph) {
              descriptors.push({
                type: "morph",
                descriptor: savedMorph
              });
            });
            return descriptors;
          }
        }, {
          key: "_restoreFromSnapshot",
          value: function () {
            var _Dashboard__restoreFromSnapshot_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(snapshot) {
              var snapObject, descriptors;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      if (!this._restore) {
                        _context4.next = 2;
                        break;
                      }

                      return _context4.abrupt("return");

                    case 2:
                      this._restore = true;
                      _context4.prev = 3;
                      this.clear();
                      snapObject = snapshot.toObject();
                      this.dataManager.tables = snapObject.tables.toObject();
                      this.dataManager.views = snapObject.views.toObject();
                      descriptors = this._getObjectsFromSnapshot_(snapObject);
                      _context4.next = 11;
                      return this._restoreMorphsFromDescriptors(descriptors);

                    case 11:
                      this.dashboardController.update();
                      _context4.next = 17;
                      break;

                    case 14:
                      _context4.prev = 14;
                      _context4.t0 = _context4["catch"](3);
                      console.log("Error in _restoreFromSnapshot_ :".concat(_context4.t0));

                    case 17:
                      this._restore = false;

                    case 18:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this, [[3, 14]]);
            }));

            function Dashboard__restoreFromSnapshot_(_x2) {
              return _Dashboard__restoreFromSnapshot_.apply(this, arguments);
            }

            return Dashboard__restoreFromSnapshot_;
          }()
        }, {
          key: "_undoChange",
          value: function Dashboard__undoChange_() {
            if (!this._snapshots || this._snapshots.length === 0) return;
            this._changePointer = Math.max(0, this._changePointer - 1);

            this._restoreFromSnapshot(this._snapshots[this._changePointer]);
          }
        }, {
          key: "_redoChange",
          value: function Dashboard__redoChange_() {
            if (!this._snapshots || this._snapshots.length === 0) return;
            this._changePointer = Math.min(this._snapshots.length - 1, this._changePointer + 1);

            this._restoreFromSnapshot(this._snapshots[this._changePointer]);
          }
        }, {
          key: "_restoreFromSaved",
          value: function () {
            var _Dashboard__restoreFromSaved_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(storedForm) {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.next = 2;
                      return initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "_restoreFromSaved", this).call(this, storedForm);

                    case 2:
                      if (this.dashboardController) {
                        this.dashboardController.update();
                      }

                    case 3:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function Dashboard__restoreFromSaved_(_x3) {
              return _Dashboard__restoreFromSaved_.apply(this, arguments);
            }

            return Dashboard__restoreFromSaved_;
          }()
        }, {
          key: "createViewEditor",
          value: function () {
            var _Dashboard_createViewEditor_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(viewName) {
              var editor;
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      if (!(this.viewNames.indexOf(viewName) < 0)) {
                        _context6.next = 2;
                        break;
                      }

                      return _context6.abrupt("return");

                    case 2:
                      if (!this.viewBuilders) {
                        this.viewBuilders = {};
                      }

                      if (this.viewBuilders[viewName]) {
                        editor = this.viewBuilders[viewName];
                      } else {
                        editor = part(ViewBuilder);
                      }

                      this._initViewEditor(editor, viewName);

                      editor.center = $world.innerBounds().center();

                    case 6:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function Dashboard_createViewEditor_(_x4) {
              return _Dashboard_createViewEditor_.apply(this, arguments);
            }

            return Dashboard_createViewEditor_;
          }()
        }, {
          key: "_initViewEditor",
          value: function Dashboard__initViewEditor_(editor, viewName) {
            this.viewBuilders[viewName] = editor;
            editor.openInWorld();
            editor.center = this.canvas.globalBounds().center();
            editor.init(viewName, this);
          }
        }, {
          key: "_checkFilterUsed",
          value: function Dashboard__checkFilterUsed_(filterName) {
            var _this7 = this;

            var filterUsedInView = function filterUsedInView(viewName) {
              return _this7.views[viewName].filterNames.indexOf(filterName) >= 0;
            };

            return Object.keys(this.views).filter(function (viewName) {
              return filterUsedInView(viewName);
            });
          }
        }, {
          key: "_removeFilterOrChart",
          value: function () {
            var _Dashboard__removeFilterOrChart_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(filterOrChartName, objectDict) {
              var prompt,
                  morph,
                  usage,
                  msg,
                  goAhead,
                  _args7 = arguments;
              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      prompt = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : true;
                      morph = this.canvas.getSubmorphNamed(filterOrChartName);
                      usage = this._checkFilterUsed(filterOrChartName);
                      msg = "".concat(filterOrChartName, " is used in views ").concat(usage.join(", "), ".  Proceed?");

                      if (!(prompt && usage.length > 0)) {
                        _context7.next = 10;
                        break;
                      }

                      _context7.next = 7;
                      return this.confirm(msg);

                    case 7:
                      _context7.t0 = _context7.sent;
                      _context7.next = 11;
                      break;

                    case 10:
                      _context7.t0 = true;

                    case 11:
                      goAhead = _context7.t0;

                      if (goAhead) {
                        delete objectDict[filterOrChartName];

                        if (morph) {
                          morph.remove();
                        }

                        if (this.dashboardController) {
                          this.dashboardController.update();
                        }
                      }

                    case 13:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7, this);
            }));

            function Dashboard__removeFilterOrChart_(_x5, _x6) {
              return _Dashboard__removeFilterOrChart_.apply(this, arguments);
            }

            return Dashboard__removeFilterOrChart_;
          }()
        }, {
          key: "removeFilter",
          value: function () {
            var _Dashboard_removeFilter_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(filterName) {
              var prompt,
                  _args8 = arguments;
              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      prompt = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : true;
                      _context8.next = 3;
                      return this._removeFilterOrChart(filterName, this.filters, prompt);

                    case 3:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, this);
            }));

            function Dashboard_removeFilter_(_x7) {
              return _Dashboard_removeFilter_.apply(this, arguments);
            }

            return Dashboard_removeFilter_;
          }()
        }, {
          key: "removeChart",
          value: function Dashboard_removeChart_(chartName) {
            this._removeFilterOrChart(chartName, this.charts);
          }
        }, {
          key: "removeMorph",
          value: function Dashboard_removeMorph_(aMorph) {
            if (aMorph.isFilter) {
              this.removeFilter(aMorph.name);
            } else if (aMorph.isChart) {
              this.removeChart(aMorph.name);
            } else {
              initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "removeMorph", this).call(this, aMorph);
            }
          }
        }, {
          key: "removeView",
          value: function () {
            var _Dashboard_removeView_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(viewName) {
              var _this8 = this;

              var usesView, usedBy, msg, goAhead;
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      usesView = function usesView(chart) {
                        return chart.viewOrTable === viewName;
                      };

                      usedBy = Object.keys(this.charts).filter(function (chartName) {
                        return usesView(_this8.charts[chartName]);
                      });
                      msg = "".concat(viewName, " is used by charts ").concat(usedBy.join(", "), ".  Proceed?");

                      if (!(usedBy.length > 0)) {
                        _context9.next = 9;
                        break;
                      }

                      _context9.next = 6;
                      return this.confirm(msg);

                    case 6:
                      _context9.t0 = _context9.sent;
                      _context9.next = 10;
                      break;

                    case 9:
                      _context9.t0 = true;

                    case 10:
                      goAhead = _context9.t0;

                      if (goAhead) {
                        this.dataManager.removeView(viewName);
                        this.dashboardController.update();
                      }

                    case 12:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, this);
            }));

            function Dashboard_removeView_(_x8) {
              return _Dashboard_removeView_.apply(this, arguments);
            }

            return Dashboard_removeView_;
          }()
        }, {
          key: "removeTable",
          value: function () {
            var _Dashboard_removeTable_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(tableName) {
              var _this9 = this;

              var chartUsesTable, viewUsesTable, chartUses, viewUses, usedBy, msg, goAhead;
              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      chartUsesTable = function chartUsesTable(chart) {
                        return chart.viewOrTable === tableName;
                      };

                      viewUsesTable = function viewUsesTable(view) {
                        return view.table === tableName;
                      };

                      chartUses = Object.keys(this.charts).filter(function (chartName) {
                        return chartUsesTable(_this9.charts[chartName]);
                      });
                      viewUses = Object.keys(this.views).filter(function (viewName) {
                        return viewUsesTable(_this9.views[viewName]);
                      });
                      usedBy = chartUses.concat(viewUses);
                      msg = "".concat(tableName, " is used by ").concat(usedBy.join(", "), ".  Proceed?");

                      if (!(usedBy.length > 0)) {
                        _context10.next = 12;
                        break;
                      }

                      _context10.next = 9;
                      return this.confirm(msg);

                    case 9:
                      _context10.t0 = _context10.sent;
                      _context10.next = 13;
                      break;

                    case 12:
                      _context10.t0 = true;

                    case 13:
                      goAhead = _context10.t0;

                      if (goAhead) {
                        this.dataManager.removeTable(tableName);
                        this.dashboardController.update();
                      }

                    case 15:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, this);
            }));

            function Dashboard_removeTable_(_x9) {
              return _Dashboard_removeTable_.apply(this, arguments);
            }

            return Dashboard_removeTable_;
          }()
        }, {
          key: "addView",
          value: function Dashboard_addView_(viewName, spec) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "addView", this).call(this, viewName, spec);

            this.dashboardController.update();
          }
        }, {
          key: "init",
          value: function () {
            var _Dashboard_init_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(controller) {
              var parameters, url;
              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      this.initialized = true;
                      this.dashboardController = controller;
                      _context11.next = 4;
                      return initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "init", this).call(this);

                    case 4:
                      this._initializeJupyterLabCallbacks();

                      this.viewBuilders = {};
                      this.availableTables = {};
                      parameters = new URLSearchParams(document.location.search);
                      url = parameters.get("dashboard");

                      if (!url) {
                        _context11.next = 13;
                        break;
                      }

                      if (GALYLEO_ENV.debug) {
                        console.log(url);
                      }

                      _context11.next = 13;
                      return this.loadDashboardFromURL(url);

                    case 13:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11, this);
            }));

            function Dashboard_init_(_x10) {
              return _Dashboard_init_.apply(this, arguments);
            }

            return Dashboard_init_;
          }()
        }, {
          key: "addTable",
          value: function Dashboard_addTable_(tableSpec) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "addTable", this).call(this, tableSpec);

            if (this.dashboardController) {
              this.dashboardController.update();
            }

            this.dirty = true;
          }
        }, {
          key: "_loadTablesFromTableServer_",
          value: function () {
            var _Dashboard__loadTablesFromTableServer__ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
              var _this10 = this;

              var tableServer, tableDict;
              return regeneratorRuntime.wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      if (!this.tableServerUrl) {
                        _context12.next = 11;
                        break;
                      }

                      tableServer = resource("".concat(this.tableServerUrl, "/get_table_schemas"));
                      _context12.prev = 2;
                      _context12.next = 5;
                      return tableServer.readJson();

                    case 5:
                      tableDict = _context12.sent;
                      Object.keys(tableDict).forEach(function (name) {
                        var connector = {
                          url: _this10.tableServerUrl
                        };

                        _this10.addTable({
                          name: name,
                          table: {
                            columns: tableDict[name],
                            connector: connector
                          }
                        });
                      });
                      _context12.next = 11;
                      break;

                    case 9:
                      _context12.prev = 9;
                      _context12.t0 = _context12["catch"](2);

                    case 11:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12, this, [[2, 9]]);
            }));

            function Dashboard__loadTablesFromTableServer__() {
              return _Dashboard__loadTablesFromTableServer__.apply(this, arguments);
            }

            return Dashboard__loadTablesFromTableServer__;
          }()
        }, {
          key: "loadTablesFromServer",
          value: function () {
            var _Dashboard_loadTablesFromServer_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(tableServerUrl) {
              return regeneratorRuntime.wrap(function _callee13$(_context13) {
                while (1) {
                  switch (_context13.prev = _context13.next) {
                    case 0:
                      this.tableServerUrl = tableServerUrl;

                      this._loadTablesFromTableServer_();

                    case 3:
                    case "end":
                      return _context13.stop();
                  }
                }
              }, _callee13, this);
            }));

            function Dashboard_loadTablesFromServer_(_x11) {
              return _Dashboard_loadTablesFromServer_.apply(this, arguments);
            }

            return Dashboard_loadTablesFromServer_;
          }()
        }, {
          key: "_makeURL",
          value: function Dashboard__makeURL_(base, method) {
            return base.endsWith("/") ? "".concat(base).concat(method) : "".concat(base, "/").concat(method);
          }
        }, {
          key: "loadDataFromUrl",
          value: function () {
            var _Dashboard_loadDataFromUrl_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(url, tableName, checkUpdates, updateInterval) {
              var schemaText, schemaDict, connector;
              return regeneratorRuntime.wrap(function _callee14$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      _context14.prev = 0;
                      _context14.next = 3;
                      return resource(url).read();

                    case 3:
                      schemaText = _context14.sent;
                      schemaDict = JSON.parse(schemaText);
                      connector = {
                        url: url
                      };

                      if (checkUpdates) {
                        connector.interval = updateInterval;
                      }

                      if (!schemaDict) {
                        _context14.next = 16;
                        break;
                      }

                      if (!schemaDict[tableName]) {
                        _context14.next = 13;
                        break;
                      }

                      this.addTable({
                        name: tableName,
                        table: {
                          columns: schemaDict[tableName],
                          connector: connector
                        }
                      });
                      return _context14.abrupt("return", {
                        result: true
                      });

                    case 13:
                      return _context14.abrupt("return", {
                        result: false,
                        msg: "No table matching ".concat(tableName, " found at ").concat(url)
                      });

                    case 14:
                      _context14.next = 17;
                      break;

                    case 16:
                      return _context14.abrupt("return", {
                        result: false,
                        msg: "No tables found at {url}"
                      });

                    case 17:
                      _context14.next = 23;
                      break;

                    case 19:
                      _context14.prev = 19;
                      _context14.t0 = _context14["catch"](0);
                      console.log({
                        activity: "loading url ".concat(url),
                        error: _context14.t0
                      });
                      return _context14.abrupt("return", {
                        result: false,
                        msg: "Error return ".concat(_context14.t0, " from ").concat(url)
                      });

                    case 23:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee14, this, [[0, 19]]);
            }));

            function Dashboard_loadDataFromUrl_(_x12, _x13, _x14, _x15) {
              return _Dashboard_loadDataFromUrl_.apply(this, arguments);
            }

            return Dashboard_loadDataFromUrl_;
          }()
        }, {
          key: "consistencyCheck",
          value: function Dashboard_consistencyCheck_() {
            var _this11 = this;

            var result = {
              ok: true,
              messages: []
            };

            var addMessage = function addMessage(message) {
              result.ok = false;
              result.messages.push(message);
            };

            this.chartNames.forEach(function (chartName) {
              var viewOrTableName = _this11.charts[chartName].viewOrTable;

              if (_this11.tables[viewOrTableName] || _this11.views[viewOrTableName]) {
                return;
              }

              addMessage("View ".concat(viewOrTableName, " is required by chart ").concat(chartName, " but is not present"));
            });
            this.viewNames.forEach(function (viewName) {
              var tableName = _this11.views[viewName].table;

              if (!_this11.tables[tableName]) {
                addMessage("Underlying table ".concat(tableName, " for view ").concat(viewName, " is missing"));
                return;
              }

              var tableColumns = function tableColumns(tableName) {
                return _this11.tables[tableName].columns.map(function (column) {
                  return column.name;
                });
              };

              var availableColumns = tableColumns(tableName);

              if (_this11.views[viewName].columns.length === 0) {
                addMessage("View ".concat(viewName, " has no selected columns"));
              }

              var missing_columns = _this11.views[viewName].columns.filter(function (colName) {
                return availableColumns.indexOf(colName) < 0;
              });

              if (missing_columns.length > 0) {
                addMessage("View ".concat(viewName, " references columns ").concat(missing_columns, " which are not present in table ").concat(tableName));
              }
            });
            return result;
          }
        }, {
          key: "editChartStyle",
          value: function () {
            var _Dashboard_editChartStyle_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(chartName) {
              var _this12 = this;

              var chart, editor, wrapper;
              return regeneratorRuntime.wrap(function _callee16$(_context16) {
                while (1) {
                  switch (_context16.prev = _context16.next) {
                    case 0:
                      chart = this.charts[chartName];

                      if (chart) {
                        _context16.next = 3;
                        break;
                      }

                      return _context16.abrupt("return");

                    case 3:
                      if (window.google.visualization.ChartEditor) {
                        _context16.next = 5;
                        break;
                      }

                      return _context16.abrupt("return");

                    case 5:
                      editor = new window.google.visualization.ChartEditor();
                      _context16.next = 8;
                      return this._makeWrapper(chart, chartName);

                    case 8:
                      wrapper = _context16.sent;

                      if (wrapper) {
                        _context16.next = 11;
                        break;
                      }

                      return _context16.abrupt("return");

                    case 11:
                      window.google.visualization.events.addListener(editor, "ok", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
                        var wrapperOut;
                        return regeneratorRuntime.wrap(function _callee15$(_context15) {
                          while (1) {
                            switch (_context15.prev = _context15.next) {
                              case 0:
                                wrapperOut = editor.getChartWrapper();
                                chart.chartType = wrapperOut.getChartType();
                                chart.options = wrapperOut.getOptions();
                                _context15.next = 5;
                                return _this12.drawChart(chartName);

                              case 5:
                                editor.closeDialog();

                              case 6:
                              case "end":
                                return _context15.stop();
                            }
                          }
                        }, _callee15);
                      })));
                      editor.openDialog(wrapper);

                    case 13:
                    case "end":
                      return _context16.stop();
                  }
                }
              }, _callee16, this);
            }));

            function Dashboard_editChartStyle_(_x16) {
              return _Dashboard_editChartStyle_.apply(this, arguments);
            }

            return Dashboard_editChartStyle_;
          }()
        }, {
          key: "addChart",
          value: function () {
            var _Dashboard_addChart_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(chartName, chartSpecification) {
              var editChartStyle,
                  _args17 = arguments;
              return regeneratorRuntime.wrap(function _callee17$(_context17) {
                while (1) {
                  switch (_context17.prev = _context17.next) {
                    case 0:
                      editChartStyle = _args17.length > 2 && _args17[2] !== undefined ? _args17[2] : true;
                      _context17.next = 3;
                      return initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "addChart", this).call(this, chartName, chartSpecification, editChartStyle);

                    case 3:
                      if (this.dashboardController) {
                        this.dashboardController.update();
                      }

                      if (editChartStyle) {
                        this.editChartStyle(chartName);
                      }

                      this.dirty = true;

                    case 6:
                    case "end":
                      return _context17.stop();
                  }
                }
              }, _callee17, this);
            }));

            function Dashboard_addChart_(_x17, _x18) {
              return _Dashboard_addChart_.apply(this, arguments);
            }

            return Dashboard_addChart_;
          }()
        }, {
          key: "getDashboardName",
          value: function Dashboard_getDashboardName_() {
            return this.get("dashboard selector").selection || "some Dashboard";
          }
        }, {
          key: "_getPublicationResourceHandle",
          value: function Dashboard__getPublicationResourceHandle_() {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDashboardName();
            var userName = this.world().getCurrentUser().name;
            return resource(System.baseURL).join("users").join(userName).join("published/").join("dashboards").join(name + ".json");
          }
        }, {
          key: "openPublishedDashboard",
          value: function Dashboard_openPublishedDashboard_() {
            window.open(System.baseURL + "worlds/load?snapshot=".concat(this._getPublicationResourceHandle().url.replace(System.baseURL, ""), "&fastLoad=true"));
          }
        }, {
          key: "_enableLink",
          value: function Dashboard__enableLink_(active) {
            var link = this.get("open published dashboard button");

            if (!link) {
              return;
            }

            this.withAnimationDo(function () {
              link.visible = active;
              link.isLayoutable = active;
            }, {
              duration: 300
            });
          }
        }, {
          key: "setContext",
          value: function Dashboard_setContext_(target) {
            target._context = this.view.owner;
          }
        }, {
          key: "publish",
          value: function () {
            var _Dashboard_publish_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
              var li, snap, frozenPartsDir;
              return regeneratorRuntime.wrap(function _callee18$(_context18) {
                while (1) {
                  switch (_context18.prev = _context18.next) {
                    case 0:
                      li = open("publishing dashboard...");
                      _context18.next = 3;
                      return createMorphSnapshot(this);

                    case 3:
                      snap = _context18.sent;
                      _context18.next = 6;
                      return this._getPublicationResourceHandle().ensureExistance();

                    case 6:
                      frozenPartsDir = _context18.sent;
                      li.status = "writing files...";
                      _context18.next = 10;
                      return frozenPartsDir.writeJson(snap);

                    case 10:
                      this._enableLink(true);

                      li.remove();

                    case 12:
                    case "end":
                      return _context18.stop();
                  }
                }
              }, _callee18, this);
            }));

            function Dashboard_publish_() {
              return _Dashboard_publish_.apply(this, arguments);
            }

            return Dashboard_publish_;
          }()
        }, {
          key: "_logEntry",
          value: function Dashboard__logEntry_(entry) {
            if (!this._log) {
              this._log = [];
            }

            this._log.push({
              entry: entry,
              time: new Date()
            });
          }
        }, {
          key: "_showLog",
          value: function Dashboard__showLog_() {
            window.alert(this._log.map(function (entry) {
              return "".concat(entry.time.toLocaleTimeString(), ": ").concat(entry.entry);
            }).join("\n"));
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "Dashboard";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              dataManager: {
                defaultValue: null,
                serialize: false
              },
              filters: {
                defaultValue: null
              },
              charts: {
                defaultValue: null
              },
              initialized: {
                defaultValue: false
              },
              expose: {
                get: function get() {
                  return ["clear", "checkAndLoad", "checkPossibleRenameFromBrowser", "checkPossibleRename", "dependencyGraph", "testDashboards", "loadTestDashboard", "loadDashboardFromFile", "checkAndSave", "saveDashboardToFile", "prepareJSONForm", "restoreFromJSONForm", "restoreFromSavedForm", "getColumnsOfType", "openDialog", "confirm", "isDirty", "clearSnapshots", "commands", "init", "tables", "addTable", "tableNames", "views", "viewNames", "update", "addView", "createViewEditor", "filters", "addFilter", "removeFilter", "filterNames", "charts", "chartNames", "addChart", "editChartStyle", "removeChart", "createExternalFilter", "relayout", "dataManager", "prepareSerialization"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    signal: "onSubmorphChange",
                    handler: "onSubmorphChange"
                  }, {
                    signal: "onDrag",
                    handler: "onDrag",
                    override: true
                  }, {
                    signal: "addMorph",
                    handler: "setContext"
                  }, {
                    signal: "removeMorph",
                    handler: "clearSideBarFocus"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/dashboard.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 6550,
          end: 50980
        });
      }({
        referencedAs: "DashboardCommon",
        value: DashboardCommon
      });
      __varRecorder__$g.Dashboard = Dashboard;
      __varRecorder__$g.Dashboard = Dashboard;
      var LoadDialog = __varRecorder__$g.LoadDialog;
      var SaveDialog = __varRecorder__$g.SaveDialog;
      __varRecorder__$g.LoadDialog = LoadDialog;
      __varRecorder__$g.SaveDialog = SaveDialog;

      var __varRecorder__$f = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/filter-creator.cp.js", __contextModule__);
      __varRecorder__$f.FilterSettings = component["for"](function () {
        return component({
          name: "filter settings",
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "right",
            orderByIndex: true,
            padding: rect(10, 10, 0, 0),
            resizePolicies: [["header", {
              height: "fixed",
              width: "fill"
            }], ["view name input", {
              height: "fixed",
              width: "fill"
            }], ["filter selector", {
              height: "fixed",
              width: "fill"
            }], ["table selector", {
              height: "fixed",
              width: "fill"
            }], ["column selector", {
              height: "fixed",
              width: "fill"
            }]],
            spacing: 10,
            wrapSubmorphs: false
          }),
          extent: pt(397.9, 200),
          fill: Color$1.rgba(255, 255, 255, 0),
          submorphs: [{
            name: "header",
            extent: pt(384, 10),
            fill: Color$1.rgba(0, 0, 0, 0),
            layout: new TilingLayout({
              align: "right",
              orderByIndex: true,
              wrapSubmorphs: false
            }),
            submorphs: [part(MenuBarButton, {
              tooltip: "Close this dialog without loading",
              name: "close button",
              extent: pt(100, 35),
              submorphs: [{
                name: "label",
                textAndAttributes: ["CLOSE", null]
              }, {
                name: "icon",
                extent: pt(14, 14),
                imageUrl: projectAsset("engageLively--galyleo-dashboard__close-button-icon-2.svg")
              }]
            })]
          }, part(GalyleoSearch, {
            name: "filter name input",
            placeholder: "Filter name"
          }), part(GalyleoDropDown, {
            name: "filter selector",
            viewModel: {
              placeholder: "Select widget...",
              openListInWorld: true
            }
          }), part(GalyleoDropDown, {
            name: "table selector",
            viewModel: {
              placeholder: "Select table...",
              openListInWorld: true
            }
          }), part(GalyleoDropDown, {
            name: "column selector",
            viewModel: {
              placeholder: "Select column...",
              openListInWorld: true
            }
          }), part(PromptButton, {
            name: "confirm button",
            extent: pt(116.2, 30.5),
            submorphs: [{
              name: "label",
              textAndAttributes: ["Create filter", null]
            }, without("icon")]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/filter-creator.cp.js",
        "export": "FilterSettings",
        range: {
          start: 598,
          end: 2640
        }
      }, System, __varRecorder__$f, "FilterSettings");
      var FilterBuilderModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/filter-creator.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("FilterBuilderModel") && typeof __lively_classholder__.FilterBuilderModel === "function" ? __lively_classholder__.FilterBuilderModel : __lively_classholder__.FilterBuilderModel = function FilterBuilderModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "filterTypes",
          get: function get() {
            return {
              dropdown: {
                columnTypes: [],
                filterType: "Select",
                part: SelectFilter
              },
              list: {
                columnTypes: [],
                filterType: "Select",
                part: ListFilter
              },
              minMax: {
                columnTypes: ["number"],
                filterType: "Range",
                part: RangeFilter
              },
              doubleSlider: {
                columnTypes: ["number"],
                filterType: "Range",
                part: DoubleSliderFilter
              },
              slider: {
                columnTypes: ["number"],
                filterType: "NumericSelect",
                part: SliderFilter
              },
              toggle: {
                columnTypes: ["boolean"],
                filterType: "Boolean",
                part: BooleanFilter$1
              }
            };
          }
        }, {
          key: "getColumns",
          value: function FilterBuilderModel_getColumns_(filterType) {
            var tableName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return this.dashboard ? this.dashboard.dataManager.getColumnsOfTypes([], tableName) : [];
          }
        }, {
          key: "getColumnsOfType",
          value: function FilterBuilderModel_getColumnsOfType_(typeArray) {
            var tableName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return this.dashboard ? this.dashboard.dataManager.getColumnsOfTypes(typeArray, tableName) : [];
          }
        }, {
          key: "getTables",
          value: function FilterBuilderModel_getTables_() {
            var columnName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            if (this.dashboard && this.dashboard.dataManager) {
              var mgr = this.dashboard.dataManager;
              return columnName ? mgr.tableNames.filter(function (tableName) {
                return mgr.tables[tableName].getColumnIndex(columnName) >= 0;
              }) : mgr.tableNames;
            }

            return [];
          }
        }, {
          key: "viewDidLoad",
          value: function FilterBuilderModel_viewDidLoad_() {}
        }, {
          key: "init",
          value: function FilterBuilderModel_init_(dashboard) {
            this.dashboard = dashboard;

            this._initDropDowns();
          }
        }, {
          key: "_initDropDowns",
          value: function FilterBuilderModel__initDropDowns_() {
            var items = Object.keys(this.filterTypes);
            var filterDropDown = this.ui.filterSelector;
            filterDropDown.items = items;
            var columnSelector = this.ui.columnSelector;
            var columns = this.getColumnsOfType([]);

            if (columns && columns.length > 0) {
              columnSelector.items = columns;
            }

            var tableSelector = this.ui.tableSelector;
            var tables = this.getTables();

            if (tables && tables.length > 0) {
              tableSelector.items = tables;
            }
          }
        }, {
          key: "_checkConsistency",
          value: function FilterBuilderModel__checkConsistency_(selectedColumn, selectedFilter, selectedFilterName) {
            var columns = this.getColumnsOfType(selectedFilter.columnTypes);

            if (columns && columns.length > 0) {
              if (columns.indexOf(selectedColumn) >= 0) {
                return {
                  valid: true
                };
              } else {
                return {
                  valid: false,
                  message: "Valid column types for ".concat(selectedFilterName, " are ").concat(selectedFilter.columnTypes.join(", "))
                };
              }
            } else {
              return {
                valid: false,
                message: "No matching columns found for  ".concat(selectedFilterName)
              };
            }
          }
        }, {
          key: "createFilter",
          value: function () {
            var _FilterBuilderModel_createFilter_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var _this$ui, filterSelector, columnSelector, tableSelector, selectedFilterName, selectedFilter, selectedColumn, selectedTable, validity;

              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _this$ui = this.ui, filterSelector = _this$ui.filterSelector, columnSelector = _this$ui.columnSelector, tableSelector = _this$ui.tableSelector;
                      selectedFilterName = filterSelector.selection;
                      selectedFilter = this.filterTypes[selectedFilterName];
                      selectedColumn = columnSelector.selection;
                      selectedTable = tableSelector.items.length == 1 ? tableSelector.items[0] : tableSelector.selection;

                      if (selectedFilter) {
                        _context.next = 8;
                        break;
                      }

                      filterSelector.toggleError();
                      return _context.abrupt("return", false);

                    case 8:
                      if (selectedColumn) {
                        _context.next = 11;
                        break;
                      }

                      columnSelector.toggleError();
                      return _context.abrupt("return", false);

                    case 11:
                      if (selectedTable) {
                        _context.next = 14;
                        break;
                      }

                      tableSelector.toggleError();
                      return _context.abrupt("return", false);

                    case 14:
                      validity = this._checkConsistency(selectedColumn, selectedFilter, selectedFilterName);

                      if (validity.valid) {
                        _context.next = 18;
                        break;
                      }

                      this.showError(validity.message);
                      return _context.abrupt("return", false);

                    case 18:
                      _context.next = 20;
                      return this._createFilter(this, selectedFilter.filterType, selectedFilter.part, selectedColumn, selectedTable);

                    case 20:
                      this.view.remove();

                    case 21:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function FilterBuilderModel_createFilter_() {
              return _FilterBuilderModel_createFilter_.apply(this, arguments);
            }

            return FilterBuilderModel_createFilter_;
          }()
        }, {
          key: "getFilterName",
          value: function FilterBuilderModel_getFilterName_() {
            return this.ui.filterNameInput.textString;
          }
        }, {
          key: "_createFilter",
          value: function () {
            var _FilterBuilderModel__createFilter_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(filterBuilder, filterType, filterPart, columnName, tableName) {
              var filterName;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      filterName = this.getFilterName();

                      if (!(filterName.length === 0)) {
                        _context2.next = 4;
                        break;
                      }

                      this.ui.filterName.indicateError("Please enter a name");
                      return _context2.abrupt("return", false);

                    case 4:
                      if (!this.dashboard.filters) {
                        this.dashboard.filters = {};
                      }

                      if (!this.dashboard.filters[filterName]) {
                        _context2.next = 12;
                        break;
                      }

                      if (!this.dashboard.getSubmorphNamed(filterName)) {
                        _context2.next = 11;
                        break;
                      }

                      this.dashboard.getSubmorphNamed(filterName).show();
                      return _context2.abrupt("return", false);

                    case 11:
                      delete this.dashboard.filters[filterName];

                    case 12:
                      _context2.next = 14;
                      return this.dashboard.createExternalFilter(filterName, columnName, filterType, filterPart, tableName);

                    case 14:
                      return _context2.abrupt("return", true);

                    case 15:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function FilterBuilderModel__createFilter_(_x, _x2, _x3, _x4, _x5) {
              return _FilterBuilderModel__createFilter_.apply(this, arguments);
            }

            return FilterBuilderModel__createFilter_;
          }()
        }, {
          key: "updateColumns",
          value: function FilterBuilderModel_updateColumns_() {
            var columnSelector = this.ui.columnSelector;
            var tableSelector = this.ui.tableSelector;
            var selectedFilter = this.filterTypes[this.ui.filterSelector.selection];
            var types = selectedFilter ? selectedFilter.columnTypes : [];
            var columns = this.getColumnsOfType(types, tableSelector.selection);

            if (columns && columns.length > 0) {
              columnSelector.items = columns;
            }
          }
        }, {
          key: "updateTables",
          value: function FilterBuilderModel_updateTables_() {
            var columnSelector = this.ui.columnSelector;
            var tableSelector = this.ui.tableSelector;
            var columnName = columnSelector.selection;

            if (!columnName) {
              return;
            }

            var tableNames = this.getTables();

            if (tableNames && tableNames.length > 0) {
              tableSelector.items = tableNames;
            }
          }
        }, {
          key: "cancelFilterCreation",
          value: function FilterBuilderModel_cancelFilterCreation_() {
            this.filterCreator.cancelFilterCreation(this);
          }
        }, {
          key: "cancel",
          value: function FilterBuilderModel_cancel_() {
            this.view.remove();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "FilterBuilderModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              dashboard: {},
              expose: {
                get: function get() {
                  return ["init"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "fire",
                    handler: "cancel"
                  }, {
                    target: "confirm button",
                    signal: "fire",
                    handler: "createFilter"
                  }, {
                    target: "filter selector",
                    signal: "selection",
                    handler: "updateColumns"
                  }, {
                    target: "column selector",
                    signal: "selection",
                    handler: "updateTables"
                  }, {
                    target: "table selector",
                    signal: "selection",
                    handler: "updateColumns"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/filter-creator.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 2749,
          end: 13214
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$f.FilterBuilderModel = FilterBuilderModel;
      __varRecorder__$f.FilterBuilderModel = FilterBuilderModel;
      var FilterEditorModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/filter-creator.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("FilterEditorModel") && typeof __lively_classholder__.FilterEditorModel === "function" ? __lively_classholder__.FilterEditorModel : __lively_classholder__.FilterEditorModel = function FilterEditorModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "getFilterName",
          value: function FilterEditorModel_getFilterName_() {
            return this._filterName;
          }
        }, {
          key: "init",
          value: function FilterEditorModel_init_(dashboard, filterName) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "init", this).call(this, dashboard);

            var _this$ui2 = this.ui,
                filterSelector = _this$ui2.filterSelector,
                columnSelector = _this$ui2.columnSelector,
                windowTitle = _this$ui2.windowTitle;
            this._filterName = filterName;
            windowTitle.textString = "Filter: ".concat(filterName);
            filterSelector.selection = this.editedFilter.filterMorph.widgetType;
            columnSelector.selection = this.editedFilter.filterMorph.columnName;
          }
        }, {
          key: "applyChanges",
          value: function () {
            var _FilterEditorModel_applyChanges_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
              var pos;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      pos = this.dashboard.filters[this._filterName].morph.position;
                      _context3.next = 3;
                      return this.dashboard.removeFilter(this._filterName, false);

                    case 3:
                      _context3.next = 5;
                      return this.createFilter();

                    case 5:
                      this.dashboard.filters[this._filterName].morph.position = pos;
                      this.dashboard.dirty = true;
                      this.view.remove();

                    case 8:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function FilterEditorModel_applyChanges_() {
              return _FilterEditorModel_applyChanges_.apply(this, arguments);
            }

            return FilterEditorModel_applyChanges_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "FilterEditorModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              editedFilter: {
                serialize: false,
                get: function get() {
                  return this.dashboard.filters[this._filterName].morph;
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "fire",
                    handler: "cancel"
                  }, {
                    target: "confirm button",
                    signal: "fire",
                    handler: "applyChanges"
                  }, {
                    targer: "filter selector",
                    signal: "selection",
                    handler: "updateColumns"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/filter-creator.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 13223,
          end: 14659
        });
      }(__varRecorder__$f.FilterBuilderModel);
      __varRecorder__$f.FilterEditorModel = FilterEditorModel;
      __varRecorder__$f.FilterEditorModel = FilterEditorModel;
      __varRecorder__$f.FilterEditor = component["for"](function () {
        return component(GalyleoWindow, {
          name: "filter settings prompt",
          defaultViewModel: __varRecorder__$f.FilterEditorModel,
          extent: pt(402, 211),
          layout: new TilingLayout({
            axis: "column",
            orderByIndex: true,
            padding: rect(0, 0, 2, 0),
            resizePolicies: [["window title", {
              height: "fixed",
              width: "fill"
            }], ["controls", {
              height: "fill",
              width: "fill"
            }]],
            wrapSubmorphs: false
          }),
          submorphs: [{
            name: "window title",
            textString: "Filter: [filter name]"
          }, add(part(__varRecorder__$f.FilterSettings, {
            name: "controls",
            submorphs: [without("filter name input"), {
              name: "confirm button",
              submorphs: [{
                name: "label",
                textAndAttributes: ["Apply changes", null]
              }]
            }]
          }))]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/filter-creator.cp.js",
        "export": "FilterEditor",
        range: {
          start: 14697,
          end: 15483
        }
      }, System, __varRecorder__$f, "FilterEditor");
      __varRecorder__$f.FilterBuilder = component["for"](function () {
        return component(GalyleoWindow, {
          name: "filter builder",
          defaultViewModel: __varRecorder__$f.FilterBuilderModel,
          extent: pt(343, 290),
          layout: new TilingLayout({
            axis: "column",
            orderByIndex: true,
            padding: rect(0, 0, 2, 0),
            resizePolicies: [["window title", {
              height: "fixed",
              width: "fill"
            }], ["controls", {
              height: "fill",
              width: "fill"
            }]],
            wrapSubmorphs: false
          }),
          submorphs: [{
            name: "window title",
            textString: "Filter builder"
          }, add(part(__varRecorder__$f.FilterSettings, {
            name: "controls"
          }))]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/filter-creator.cp.js",
        "export": "FilterBuilder",
        range: {
          start: 15523,
          end: 16081
        }
      }, System, __varRecorder__$f, "FilterBuilder");
      var FilterEditor = __varRecorder__$f.FilterEditor;
      var FilterBuilder = __varRecorder__$f.FilterBuilder;
      __varRecorder__$f.FilterEditor = FilterEditor;
      __varRecorder__$f.FilterBuilder = FilterBuilder;

      var __varRecorder__$e = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/controls/section.cp.js", __contextModule__);
      __varRecorder__$e.GalyleoPropertySection = component["for"](function () {
        return component(PropertySection, {
          name: "galyleo/property section",
          fill: Color$1.transparent,
          submorphs: [{
            name: "h floater",
            submorphs: [{
              name: "section headline",
              fontColor: Color$1.rgb(66, 73, 73)
            }, {
              name: "add button",
              master: GalyleoAddButton
            }, {
              name: "remove button",
              master: GalyleoAddButton,
              visible: false
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/section.cp.js",
        "export": "GalyleoPropertySection",
        range: {
          start: 239,
          end: 741
        }
      }, System, __varRecorder__$e, "GalyleoPropertySection");
      __varRecorder__$e.GalyleoPropertySectionInactive = component["for"](function () {
        return component(__varRecorder__$e.GalyleoPropertySection, {
          name: "galyleo/property section/inactive",
          submorphs: [{
            name: "h floater",
            opacity: 0.5
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/section.cp.js",
        "export": "GalyleoPropertySectionInactive",
        range: {
          start: 798,
          end: 973
        }
      }, System, __varRecorder__$e, "GalyleoPropertySectionInactive");
      var GalyleoPropertySectionInactive = __varRecorder__$e.GalyleoPropertySectionInactive;
      var GalyleoPropertySection = __varRecorder__$e.GalyleoPropertySection;
      __varRecorder__$e.GalyleoPropertySectionInactive = GalyleoPropertySectionInactive;
      __varRecorder__$e.GalyleoPropertySection = GalyleoPropertySection;

      var __varRecorder__$d = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/controls/constraints.cp.js", __contextModule__);
      __varRecorder__$d.GalyleoConstraintMarker = component["for"](function () {
        return component(ConstraintMarker, {
          name: "galyleo/constraint marker",
          submorphs: [{
            name: "accent",
            fill: Color$1.rgba(102, 102, 102, 0.75)
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/constraints.cp.js",
        "export": "GalyleoConstraintMarker",
        range: {
          start: 594,
          end: 772
        }
      }, System, __varRecorder__$d, "GalyleoConstraintMarker");
      __varRecorder__$d.GalyleoConstraintMarkerActive = component["for"](function () {
        return component(ConstraintMarkerActive, {
          name: "galyleo/constraint marker/active",
          submorphs: [{
            name: "accent",
            fill: Color$1.orange,
            borderColor: Color$1.orange
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/constraints.cp.js",
        "export": "GalyleoConstraintMarkerActive",
        range: {
          start: 781,
          end: 990
        }
      }, System, __varRecorder__$d, "GalyleoConstraintMarkerActive");
      __varRecorder__$d.GalyleoConstraintsSimulator = component["for"](function () {
        return component(ConstraintsSimulator, {
          name: "galyleo/constraints simulator",
          submorphs: [{
            name: "top marker",
            master: __varRecorder__$d.GalyleoConstraintMarker
          }, {
            name: "right marker",
            master: __varRecorder__$d.GalyleoConstraintMarker
          }, {
            name: "bottom marker",
            master: __varRecorder__$d.GalyleoConstraintMarker
          }, {
            name: "left marker",
            master: __varRecorder__$d.GalyleoConstraintMarker
          }, {
            name: "inner constraints",
            borderColor: Color$1.rgba(102, 102, 102, 0.75),
            submorphs: [{
              name: "vertical marker",
              master: __varRecorder__$d.GalyleoConstraintMarker
            }, {
              name: "horizontal marker",
              master: __varRecorder__$d.GalyleoConstraintMarker
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/constraints.cp.js",
        "export": "GalyleoConstraintsSimulator",
        range: {
          start: 999,
          end: 1637
        }
      }, System, __varRecorder__$d, "GalyleoConstraintsSimulator");
      __varRecorder__$d.GalyleoConstraintSizeSelector = component["for"](function () {
        return component(ConstraintSizeSelectorDefault, {
          name: "galyleo/constraint size selector",
          submorphs: [{
            name: "caret",
            fontColor: Color$1.rgba(102, 102, 102, 0.75)
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/constraints.cp.js",
        "export": "GalyleoConstraintSizeSelector",
        range: {
          start: 1646,
          end: 1854
        }
      }, System, __varRecorder__$d, "GalyleoConstraintSizeSelector");
      __varRecorder__$d.GalyleoConstraintSizeSelectorHovered = component["for"](function () {
        return component(__varRecorder__$d.GalyleoConstraintSizeSelector, {
          name: "galyleo/constraint size selector/hovered",
          fill: Color$1.orange.withA(0.5)
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/constraints.cp.js",
        "export": "GalyleoConstraintSizeSelectorHovered",
        range: {
          start: 1863,
          end: 2030
        }
      }, System, __varRecorder__$d, "GalyleoConstraintSizeSelectorHovered");
      __varRecorder__$d.GalyleoResizingSimulator = component["for"](function () {
        return component(_missingExportShim, {
          name: "galyleo/resizing simulator",
          submorphs: [{
            name: "inner constraints",
            borderColor: Color$1.rgba(102, 102, 102, 0.75)
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/constraints.cp.js",
        "export": "GalyleoResizingSimulator",
        range: {
          start: 2039,
          end: 2238
        }
      }, System, __varRecorder__$d, "GalyleoResizingSimulator");
      __varRecorder__$d.GalyleoAlignmentControl = component["for"](function () {
        return component(ConstraintsManager, {
          name: "galyleo/alignment control",
          master: GalyleoPropertySection,
          submorphs: [{
            name: "h floater",
            submorphs: [{
              name: "section headline",
              fontColor: Color$1.rgb(66, 73, 73)
            }]
          }, {
            name: "constraints",
            extent: pt(243.4, 84.9),
            viewModel: {
              activeMarkerComponent: __varRecorder__$d.GalyleoConstraintMarkerActive,
              defaultMarkerComponent: __varRecorder__$d.GalyleoConstraintMarker
            },
            submorphs: [{
              name: "constraints simulator",
              master: __varRecorder__$d.GalyleoConstraintsSimulator
            }, {
              name: "horizontal alignment selector",
              master: GalyleoDropDown,
              viewModelClass: GalyleoDropDownListModel,
              viewModel: {
                listMaster: GalyleoDropDownList
              },
              submorphs: [{
                name: "interactive label",
                fontColor: Color$1.rgbHex("808080")
              }]
            }, {
              name: "vertical alignment selector",
              master: GalyleoDropDown,
              viewModelClass: GalyleoDropDownListModel,
              viewModel: {
                listMaster: GalyleoDropDownList
              },
              submorphs: [{
                name: "interactive label",
                fontColor: Color$1.rgbHex("808080")
              }]
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/constraints.cp.js",
        "export": "GalyleoAlignmentControl",
        range: {
          start: 2247,
          end: 3586
        }
      }, System, __varRecorder__$d, "GalyleoAlignmentControl");
      var GalyleoConstraintMarker = __varRecorder__$d.GalyleoConstraintMarker;
      var GalyleoConstraintMarkerActive = __varRecorder__$d.GalyleoConstraintMarkerActive;
      var GalyleoConstraintsSimulator = __varRecorder__$d.GalyleoConstraintsSimulator;
      var GalyleoConstraintSizeSelector = __varRecorder__$d.GalyleoConstraintSizeSelector;
      var GalyleoConstraintSizeSelectorHovered = __varRecorder__$d.GalyleoConstraintSizeSelectorHovered;
      var GalyleoResizingSimulator = __varRecorder__$d.GalyleoResizingSimulator;
      var GalyleoAlignmentControl = __varRecorder__$d.GalyleoAlignmentControl;
      __varRecorder__$d.GalyleoConstraintMarker = GalyleoConstraintMarker;
      __varRecorder__$d.GalyleoConstraintMarkerActive = GalyleoConstraintMarkerActive;
      __varRecorder__$d.GalyleoConstraintsSimulator = GalyleoConstraintsSimulator;
      __varRecorder__$d.GalyleoConstraintSizeSelector = GalyleoConstraintSizeSelector;
      __varRecorder__$d.GalyleoConstraintSizeSelectorHovered = GalyleoConstraintSizeSelectorHovered;
      __varRecorder__$d.GalyleoResizingSimulator = GalyleoResizingSimulator;
      __varRecorder__$d.GalyleoAlignmentControl = GalyleoAlignmentControl;

      var __varRecorder__$c = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/controls/layout.cp.js", __contextModule__);
      __varRecorder__$c.GalyleoMiniLayoutPreview = component["for"](function () {
        return component(MiniLayoutPreview, {
          name: "galyleo/mini layout preview",
          submorphs: [{
            name: "outer border",
            borderColor: Color$1.rgb(66, 73, 73),
            submorphs: [{
              name: "mini bar 1",
              fill: Color$1.rgb(66, 73, 73)
            }, {
              name: "mini bar 2",
              fill: Color$1.rgb(66, 73, 73)
            }, {
              name: "mini bar 3",
              fill: Color$1.rgb(66, 73, 73)
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/layout.cp.js",
        "export": "GalyleoMiniLayoutPreview",
        range: {
          start: 596,
          end: 1036
        }
      }, System, __varRecorder__$c, "GalyleoMiniLayoutPreview");
      __varRecorder__$c.GalyleoLayoutFlap = component["for"](function () {
        return component(AutoLayoutAlignmentFlap, {
          name: "galyleo/layout flap",
          fill: Color$1.rgb(215, 219, 221),
          submorphs: [{
            name: "padding and spacing",
            submorphs: [{
              name: "container placeholder",
              submorphs: [{
                name: "mini bar 1",
                fill: Color$1.rgb(255, 152, 0)
              }, {
                name: "mini bar 2",
                fill: Color$1.rgb(255, 152, 0)
              }, {
                name: "mini bar 3",
                fill: Color$1.rgb(255, 152, 0)
              }]
            }, {
              name: "spacing preview",
              submorphs: [{
                name: "mini bar 1",
                fill: Color$1.rgb(255, 152, 0)
              }, {
                name: "mini bar 2",
                fill: Color$1.rgb(255, 152, 0)
              }, {
                name: "mini bar 3",
                fill: Color$1.rgb(255, 152, 0)
              }]
            }, {
              name: "padding top",
              master: GalyleoNumberInput,
              borderWidth: 0
            }, {
              name: "padding bottom",
              master: GalyleoNumberInput,
              borderWidth: 0
            }, {
              name: "padding left",
              master: GalyleoNumberInput,
              borderWidth: 0
            }, {
              name: "padding right",
              master: GalyleoNumberInput,
              borderWidth: 0
            }]
          }, {
            name: "spacing selector",
            master: GalyleoDropDown,
            viewModel: {
              listMaster: GalyleoDropDownList
            },
            extent: pt(156, 25)
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/layout.cp.js",
        "export": "GalyleoLayoutFlap",
        range: {
          start: 1080,
          end: 2622
        }
      }, System, __varRecorder__$c, "GalyleoLayoutFlap");
      __varRecorder__$c.GalyleoMiniLayoutPreviewActive = component["for"](function () {
        return component(MiniLayoutPreviewActive, {
          name: "glayleo/mini layout preview/active",
          fill: Color$1.orange
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/layout.cp.js",
        "export": "GalyleoMiniLayoutPreviewActive",
        range: {
          start: 2679,
          end: 2818
        }
      }, System, __varRecorder__$c, "GalyleoMiniLayoutPreviewActive");
      __varRecorder__$c.GalyleoLayoutControl = component["for"](function () {
        return component(LayoutControl, {
          name: "galyleo/layout control",
          master: GalyleoPropertySection,
          viewModel: {
            hoverSectionComponent: GalyleoPropertySection,
            inactiveSectionComponent: GalyleoPropertySectionInactive,
            controlFlapComponent: __varRecorder__$c.GalyleoLayoutFlap,
            buttonActiveComponent: GalyleoAddButtonHovered,
            buttonInactiveComponent: GalyleoAddButton
          },
          submorphs: [{
            name: "controls",
            submorphs: [{
              name: "vertical",
              master: GalyleoPropertyLabel
            }, {
              name: "horizontal",
              master: GalyleoPropertyLabel
            }, {
              name: "spacing input",
              master: GalyleoNumberInput
            }, {
              name: "total padding input",
              master: GalyleoNumberInput
            }, {
              name: "mini layout preview",
              master: __varRecorder__$c.GalyleoMiniLayoutPreview,
              activeComponent: __varRecorder__$c.GalyleoMiniLayoutPreviewActive,
              inactiveComponent: __varRecorder__$c.GalyleoMiniLayoutPreview
            }]
          }, {
            name: "wrap checkbox wrapper",
            submorphs: [{
              name: "wrap submorphs checkbox",
              submorphs: [{
                name: "checkbox",
                master: {
                  auto: GalyleoCheckboxUnchecked,
                  states: {
                    active: GalyleoCheckboxChecked
                  }
                },
                viewModel: {
                  checkedCheckboxComponent: GalyleoCheckboxChecked,
                  uncheckedCheckboxComponent: GalyleoCheckboxUnchecked
                }
              }, {
                name: "label",
                fontColor: Color$1.rgb(66, 73, 73)
              }]
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/layout.cp.js",
        "export": "GalyleoLayoutControl",
        range: {
          start: 2865,
          end: 4452
        }
      }, System, __varRecorder__$c, "GalyleoLayoutControl");
      var GalyleoMiniLayoutPreviewActive = __varRecorder__$c.GalyleoMiniLayoutPreviewActive;
      var GalyleoLayoutFlap = __varRecorder__$c.GalyleoLayoutFlap;
      var GalyleoMiniLayoutPreview = __varRecorder__$c.GalyleoMiniLayoutPreview;
      var GalyleoLayoutControl = __varRecorder__$c.GalyleoLayoutControl;
      __varRecorder__$c.GalyleoMiniLayoutPreviewActive = GalyleoMiniLayoutPreviewActive;
      __varRecorder__$c.GalyleoLayoutFlap = GalyleoLayoutFlap;
      __varRecorder__$c.GalyleoMiniLayoutPreview = GalyleoMiniLayoutPreview;
      __varRecorder__$c.GalyleoLayoutControl = GalyleoLayoutControl;

      var __varRecorder__$b = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/controls/border.cp.js", __contextModule__);
      __varRecorder__$b.GalyleoBorderPopup = component["for"](function () {
        return component(BorderPopup, {
          name: "galyleo/border popup",
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "right",
            hugContentsHorizontally: true,
            hugContentsVertically: true
          }),
          fill: Color$1.rgb(215, 219, 221),
          viewModel: {
            propertyLabelComponent: GalyleoAddButtonDefault,
            propertyLabelComponentHover: GalyleoAddButtonHovered,
            propertyLabelComponentActive: GalyleoAddButtonActive
          },
          submorphs: [{
            name: "header menu",
            reactsToPointer: false,
            master: WindowHeader,
            submorphs: [without("close button")]
          }, add(part(CloseButtonFloat, {
            name: "h float",
            submorphs: [{
              tooltip: "Close this dialog without loading",
              name: "close button"
            }]
          }), "multi border control"), {
            name: "multi border control",
            extent: pt(241, 120),
            submorphs: [{
              name: "border selector wrapper",
              submorphs: [_defineProperty({
                name: "left border",
                fontSize: 16,
                master: GalyleoAddButton
              }, "master", {
                auto: GalyleoAddButton,
                states: {
                  active: GalyleoAddButtonActive
                }
              }), _defineProperty({
                name: "top border",
                fontSize: 16,
                master: GalyleoAddButton
              }, "master", {
                auto: GalyleoAddButton,
                states: {
                  active: GalyleoAddButtonActive
                }
              }), _defineProperty({
                name: "right border",
                fontSize: 16,
                master: GalyleoAddButton
              }, "master", {
                auto: GalyleoAddButton,
                states: {
                  active: GalyleoAddButtonActive
                }
              }), {
                name: "bottom border",
                fontSize: 16,
                master: {
                  auto: GalyleoAddButton,
                  states: {
                    active: GalyleoAddButtonActive
                  }
                }
              }]
            }, {
              name: "border control",
              extent: pt(10, 62),
              submorphs: [{
                name: "border color input",
                master: GalyleoColorInput,
                viewModel: {
                  activeColor: Color$1.gray
                }
              }, {
                name: "border width control",
                layout: new TilingLayout({
                  axisAlign: "center",
                  justifySubmorphs: "spaced",
                  orderByIndex: true,
                  padding: rect(18, 0, -13, 0),
                  spacing: 10,
                  wrapSubmorphs: false
                }),
                submorphs: [{
                  name: "border width input",
                  master: GalyleoNumberInput
                }, {
                  name: "border style selector",
                  master: GalyleoDropDown,
                  submorphs: [{
                    name: "interactive label",
                    fontColor: Color$1.rgb(128, 128, 128)
                  }]
                }]
              }]
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/border.cp.js",
        "export": "GalyleoBorderPopup",
        range: {
          start: 632,
          end: 3642
        }
      }, System, __varRecorder__$b, "GalyleoBorderPopup");
      __varRecorder__$b.GalyleoBorderControl = component["for"](function () {
        return component(BorderControl, {
          name: "galyleo/border control",
          layout: new TilingLayout({
            axis: "column",
            hugContentsVertically: true,
            orderByIndex: true,
            padding: rect(0, 10, 0, 0),
            resizePolicies: [["h floater", {
              height: "fixed",
              width: "fill"
            }], ["elements wrapper", {
              width: "fill"
            }]],
            spacing: 10,
            wrapSubmorphs: false
          }),
          extent: pt(288.1, 96.7),
          visible: true,
          master: GalyleoPropertySection,
          viewModel: {
            hoverSectionComponent: GalyleoPropertySection,
            inactiveSectionComponent: GalyleoPropertySectionInactive,
            propertyLabelComponent: GalyleoAddButtonDefault,
            propertyLabelComponentHover: GalyleoAddButtonHovered,
            propertyLabelComponentActive: GalyleoAddButtonActive,
            borderPopupComponent: __varRecorder__$b.GalyleoBorderPopup
          },
          submorphs: [{
            name: "elements wrapper",
            layout: new TilingLayout({
              hugContentsVertically: true,
              orderByIndex: true,
              wrapSubmorphs: true,
              spacing: 10
            }),
            extent: pt(275.9, 102),
            submorphs: [{
              name: "border color input",
              extent: pt(288.4, 27),
              master: GalyleoColorInput
            }, {
              name: "border width control",
              submorphs: [{
                name: "border width input",
                master: GalyleoNumberInput
              }, {
                name: "border style selector",
                master: GalyleoDropDown,
                viewModelClass: GalyleoDropDownListModel,
                extent: pt(101.9, 22),
                viewModel: {
                  listAlign: "selection",
                  openListInWorld: true,
                  listHeight: 500,
                  items: Morph.prototype.borderOptions,
                  listMaster: GalyleoDropDownList
                },
                submorphs: [{
                  name: "interactive label",
                  fontColor: Color$1.rgb(128, 128, 128)
                }]
              }]
            }, {
              name: "more button",
              fontSize: 16,
              master: GalyleoAddButton
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/border.cp.js",
        "export": "GalyleoBorderControl",
        range: {
          start: 3651,
          end: 5645
        }
      }, System, __varRecorder__$b, "GalyleoBorderControl");
      var GalyleoBorderPopup = __varRecorder__$b.GalyleoBorderPopup;
      var GalyleoBorderControl = __varRecorder__$b.GalyleoBorderControl;
      __varRecorder__$b.GalyleoBorderPopup = GalyleoBorderPopup;
      __varRecorder__$b.GalyleoBorderControl = GalyleoBorderControl;

      var __varRecorder__$a = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/controls/popups.cp.js", __contextModule__);
      __varRecorder__$a.GalyleoShadowPopup = component["for"](function () {
        return component(ShadowPopup, {
          name: "galyleo/shadow popup",
          fill: Color$1.rgb(215, 219, 221),
          submorphs: [{
            name: "header menu",
            master: WindowHeader,
            submorphs: [without("close button")]
          }, add(part(CloseButtonFloat, {
            name: "h float"
          }), "shadow controls"), {
            name: "shadow controls",
            layout: new TilingLayout({
              justifySubmorphs: "spaced",
              orderByIndex: true,
              padding: rect(19, 10, 21, 0),
              spacing: 10
            }),
            submorphs: [{
              name: "x offset",
              master: GalyleoNumberInput
            }, {
              name: "blur input",
              master: GalyleoNumberInput
            }, {
              name: "y offset",
              master: GalyleoNumberInput
            }, {
              name: "spread input",
              master: GalyleoNumberInput
            }]
          }, {
            name: "shadow color input",
            master: GalyleoColorInput
          }, {
            name: "footer",
            borderWidth: {
              left: 0,
              top: 1,
              right: 0,
              bottom: 0
            },
            submorphs: [{
              name: "h wrapper",
              submorphs: [{
                name: "fast shadow checkbox",
                submorphs: [{
                  name: "checkbox",
                  viewModel: {
                    checkedCheckboxComponent: GalyleoCheckboxChecked,
                    uncheckedCheckboxComponent: GalyleoCheckboxUnchecked
                  }
                }, {
                  name: "label",
                  fontColor: Color$1.rgb(68, 68, 68)
                }]
              }]
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/popups.cp.js",
        "export": "GalyleoShadowPopup",
        range: {
          start: 578,
          end: 2059
        }
      }, System, __varRecorder__$a, "GalyleoShadowPopup");
      __varRecorder__$a.GalyleoInsetShadowPopup = component["for"](function () {
        return component(__varRecorder__$a.GalyleoShadowPopup, {
          name: "galyleo/inset shadow popup",
          submorphs: [{
            name: "header menu",
            submorphs: [{
              name: "title",
              textAndAttributes: ["Inset Shadow", null]
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/popups.cp.js",
        "export": "GalyleoInsetShadowPopup",
        range: {
          start: 2068,
          end: 2306
        }
      }, System, __varRecorder__$a, "GalyleoInsetShadowPopup");
      __varRecorder__$a.GalyleoOpacityPopup = component["for"](function () {
        return component(OpacityPopup, {
          name: "galyleo/opacity popup",
          fill: Color$1.rgb(215, 219, 221),
          submorphs: [{
            name: "header menu",
            master: WindowHeader,
            submorphs: [without("close button")]
          }, add(part(CloseButtonFloat, {
            name: "h float"
          }), "footer"), {
            name: "footer",
            submorphs: [{
              name: "value input",
              master: GalyleoNumberInput
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/popups.cp.js",
        "export": "GalyleoOpacityPopup",
        range: {
          start: 2352,
          end: 2902
        }
      }, System, __varRecorder__$a, "GalyleoOpacityPopup");
      __varRecorder__$a.GalyleoBlurPopup = component["for"](function () {
        return component(BlurPopup, {
          name: "galyleo/blur popup",
          master: __varRecorder__$a.GalyleoOpacityPopup,
          submorphs: [{
            name: "header menu",
            submorphs: [without("close button")]
          }, add(part(CloseButtonFloat, {
            name: "h float"
          }), "footer")]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/popups.cp.js",
        "export": "GalyleoBlurPopup",
        range: {
          start: 2945,
          end: 3231
        }
      }, System, __varRecorder__$a, "GalyleoBlurPopup");
      __varRecorder__$a.GalyleoCursorPopup = component["for"](function () {
        return component(CursorPopup, {
          name: "galyleo/cursor popup",
          master: __varRecorder__$a.GalyleoOpacityPopup,
          submorphs: [{
            name: "header menu",
            submorphs: [without("close button")]
          }, add(part(CloseButtonFloat, {
            name: "h float"
          }), "footer"), {
            name: "footer",
            submorphs: [{
              name: "selection input",
              master: GalyleoDropDown
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/popups.cp.js",
        "export": "GalyleoCursorPopup",
        range: {
          start: 3276,
          end: 3691
        }
      }, System, __varRecorder__$a, "GalyleoCursorPopup");
      __varRecorder__$a.GalyleoTiltPopup = component["for"](function () {
        return component(TiltPopup, {
          name: "galyleo/tilt popup",
          master: __varRecorder__$a.GalyleoOpacityPopup,
          submorphs: [{
            name: "header menu",
            submorphs: [without("close button")]
          }, add(part(CloseButtonFloat, {
            name: "h float"
          }), "footer")]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/popups.cp.js",
        "export": "GalyleoTiltPopup",
        range: {
          start: 3734,
          end: 4020
        }
      }, System, __varRecorder__$a, "GalyleoTiltPopup");
      __varRecorder__$a.GalyleoFlipPopup = component["for"](function () {
        return component(FlipPopup, {
          name: "galyleo/flip popup",
          master: __varRecorder__$a.GalyleoOpacityPopup,
          submorphs: [{
            name: "header menu",
            submorphs: [without("close button")]
          }, add(part(CloseButtonFloat, {
            name: "h float"
          }), "footer")]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/popups.cp.js",
        "export": "GalyleoFlipPopup",
        range: {
          start: 4063,
          end: 4349
        }
      }, System, __varRecorder__$a, "GalyleoFlipPopup");
      __varRecorder__$a.PROP_CONFIG = {
        "Drop shadow": {
          accessor: "dropShadow",
          defaultModelProps: function defaultModelProps(target) {
            var v = target.dropShadow;
            var opts = {
              fastShadow: v && v.fast,
              insetShadow: false
            };
            if (v) opts.shadowValue = v;
            return opts;
          },
          popupComponent: __varRecorder__$a.GalyleoShadowPopup,
          resetValue: null
        },
        "Inner shadow": {
          accessor: "dropShadow",
          defaultModelProps: function defaultModelProps(target) {
            var v = target.dropShadow;
            var opts = {
              fastShadow: v && v.fast,
              insetShadow: true
            };
            if (v) opts.shadowValue = v;
            return opts;
          },
          popupComponent: __varRecorder__$a.GalyleoInsetShadowPopup,
          resetValue: null
        },
        Opacity: {
          accessor: "opacity",
          defaultModelProps: function defaultModelProps(target) {
            return {
              value: target.opacity
            };
          },
          popupComponent: __varRecorder__$a.GalyleoOpacityPopup,
          resetValue: 1
        },
        Blur: {
          accessor: "blur",
          defaultModelProps: function defaultModelProps(target) {
            return {
              value: target.blur
            };
          },
          popupComponent: __varRecorder__$a.GalyleoBlurPopup,
          resetValue: 0
        },
        Cursor: {
          accessor: "nativeCursor",
          popupComponent: __varRecorder__$a.GalyleoCursorPopup,
          resetValue: "auto",
          defaultModelProps: function defaultModelProps(target) {
            return {
              selection: target.nativeCursor
            };
          }
        },
        Tilted: {
          accessor: "tilted",
          popupComponent: __varRecorder__$a.GalyleoTiltPopup,
          resetValue: 0,
          defaultModelProps: function defaultModelProps(target) {
            return {
              value: target.tilted
            };
          }
        },
        Flipped: {
          accessor: "flipped",
          popupComponent: __varRecorder__$a.GalyleoFlipPopup,
          resetValue: 0,
          defaultModelProps: function defaultModelProps(target) {
            return {
              value: target.flipped
            };
          }
        }
      };
      var PROP_CONFIG = __varRecorder__$a.PROP_CONFIG;
      __varRecorder__$a.PROP_CONFIG = PROP_CONFIG;
      var GalyleoShadowPopup = __varRecorder__$a.GalyleoShadowPopup;
      var GalyleoOpacityPopup = __varRecorder__$a.GalyleoOpacityPopup;
      var GalyleoBlurPopup = __varRecorder__$a.GalyleoBlurPopup;
      var GalyleoCursorPopup = __varRecorder__$a.GalyleoCursorPopup;
      var GalyleoTiltPopup = __varRecorder__$a.GalyleoTiltPopup;
      var GalyleoFlipPopup = __varRecorder__$a.GalyleoFlipPopup;
      __varRecorder__$a.GalyleoShadowPopup = GalyleoShadowPopup;
      __varRecorder__$a.GalyleoOpacityPopup = GalyleoOpacityPopup;
      __varRecorder__$a.GalyleoBlurPopup = GalyleoBlurPopup;
      __varRecorder__$a.GalyleoCursorPopup = GalyleoCursorPopup;
      __varRecorder__$a.GalyleoTiltPopup = GalyleoTiltPopup;
      __varRecorder__$a.GalyleoFlipPopup = GalyleoFlipPopup;

      var __varRecorder__$9 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/controls/body.cp.js", __contextModule__);
      var GalyleoBodyControlModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/controls/body.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GalyleoBodyControlModel") && typeof __lively_classholder__.GalyleoBodyControlModel === "function" ? __lively_classholder__.GalyleoBodyControlModel : __lively_classholder__.GalyleoBodyControlModel = function GalyleoBodyControlModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, undefined, [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GalyleoBodyControlModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              propConfig: {
                get: function get() {
                  return PROP_CONFIG;
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/controls/body.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 336,
          end: 532
        });
      }({
        referencedAs: "BodyControlModel",
        value: BodyControlModel
      });
      __varRecorder__$9.GalyleoBodyControlModel = GalyleoBodyControlModel;
      __varRecorder__$9.GalyleoBodyControlModel = GalyleoBodyControlModel;
      __varRecorder__$9.GalyleoDynamicProperty = component["for"](function () {
        return component(DynamicProperty, {
          name: "galyleo/dynamic property",
          extent: pt(208.3, 30),
          submorphs: [{
            name: "open popup",
            master: GalyleoAddButton
          }, {
            name: "effect selector",
            extent: pt(127, 25),
            master: GalyleoDropDown,
            viewModel: {
              listMaster: GalyleoDropDownList
            }
          }, {
            name: "remove",
            master: GalyleoAddButton
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/body.cp.js",
        "export": "GalyleoDynamicProperty",
        range: {
          start: 580,
          end: 989
        }
      }, System, __varRecorder__$9, "GalyleoDynamicProperty");
      var GalyleoDynamicProperty = __varRecorder__$9.GalyleoDynamicProperty;
      __varRecorder__$9.GalyleoDynamicProperty = GalyleoDynamicProperty;

      var __varRecorder__$8 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/controls/shape.cp.js", __contextModule__);
      __varRecorder__$8.GalyleoShapeControl = component["for"](function () {
        return component(ShapeControl, {
          name: "galyleo/shape control",
          layout: new TilingLayout({
            axisAlign: "center",
            wrapSubmorphs: true,
            hugContentsVertically: true,
            orderByIndex: true,
            padding: rect(20, 20, 0, 0),
            spacing: 16
          }),
          fill: Color$1.transparent,
          viewModel: {
            propertyLabelComponent: GalyleoAddButtonDefault,
            propertyLabelComponentHover: GalyleoAddButtonHovered,
            propertyLabelComponentActive: GalyleoAddButtonActive
          },
          submorphs: [{
            name: "x input",
            master: GalyleoNumberInput,
            submorphs: [{
              name: "interactive label",
              fontFamily: "IBM Plex Mono"
            }]
          }, {
            name: "y input",
            master: GalyleoNumberInput,
            submorphs: [{
              name: "interactive label",
              fontFamily: "IBM Plex Mono"
            }]
          }, {
            name: "width input",
            master: GalyleoNumberInput
          }, {
            name: "height input",
            master: GalyleoNumberInput
          }, {
            name: "proportional resize toggle",
            master: GalyleoAddButton
          }, {
            name: "width mode selector",
            master: GalyleoEnumSelector,
            viewModel: {
              listMaster: GalyleoDropDownList
            },
            submorphs: [{
              name: "interactive label",
              fontColor: Color$1.rgba(100, 100, 100, 0.5)
            }, {
              name: "label",
              fontSize: 12
            }]
          }, {
            name: "height mode selector",
            master: GalyleoEnumSelector,
            viewModel: {
              listMaster: GalyleoDropDownList
            },
            submorphs: [{
              name: "interactive label",
              fontColor: Color$1.rgba(100, 100, 100, 0.5)
            }, {
              name: "label",
              fontSize: 12
            }]
          }, {
            name: "rotation input",
            master: GalyleoNumberInput
          }, {
            name: "radius input",
            master: GalyleoNumberInput
          }, {
            name: "independent corner toggle",
            fontSize: 16,
            master: GalyleoAddButton
          }, {
            name: "multi radius container",
            submorphs: [{
              name: "centering wrapper",
              submorphs: [{
                name: "border indicator",
                fontColor: Color$1.rgb(66, 73, 73)
              }]
            }, {
              name: "radius input top left",
              master: GalyleoNumberInput
            }, {
              name: "radius input top right",
              master: GalyleoNumberInput
            }, {
              name: "radius input bottom right",
              master: GalyleoNumberInput
            }, {
              name: "radius input bottom left",
              master: GalyleoNumberInput
            }]
          }, {
            name: "clip mode selector",
            master: GalyleoDropDown,
            viewModelClass: GalyleoDropDownListModel,
            viewModel: {
              listMaster: GalyleoDropDownList
            },
            submorphs: [{
              name: "interactive label",
              fontColor: Color$1.rgb(128, 128, 128)
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/shape.cp.js",
        "export": "GalyleoShapeControl",
        range: {
          start: 577,
          end: 3301
        }
      }, System, __varRecorder__$8, "GalyleoShapeControl");
      var GalyleoShapeControl = __varRecorder__$8.GalyleoShapeControl;
      __varRecorder__$8.GalyleoShapeControl = GalyleoShapeControl;

      var __varRecorder__$7 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/controls/text.cp.js", __contextModule__);
      __varRecorder__$7.GalyleoPaddingControls = component["for"](function () {
        return component(PaddingControlsLight, {
          viewModel: {
            propertyLabelComponent: GalyleoAddButtonDefault,
            propertyLabelComponentActive: GalyleoAddButtonActive,
            propertyLabelComponentHover: GalyleoAddButtonHovered
          },
          submorphs: [{
            name: "padding all",
            master: GalyleoNumberInput
          }, {
            name: "multi padding control",
            submorphs: [{
              name: "padding left",
              master: GalyleoNumberInput
            }, {
              name: "padding top",
              master: GalyleoNumberInput
            }, {
              name: "padding right",
              master: GalyleoNumberInput
            }, {
              name: "padding bottom",
              master: GalyleoNumberInput
            }, {
              name: "centering wrapper",
              submorphs: [{
                name: "padding indicator",
                master: GalyleoAddButton
              }]
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/text.cp.js",
        "export": "GalyleoPaddingControls",
        range: {
          start: 605,
          end: 1454
        }
      }, System, __varRecorder__$7, "GalyleoPaddingControls");
      __varRecorder__$7.GalyleoRichTextControl = component["for"](function () {
        return component(RichTextControl, {
          name: "galyleo/rich text control",
          layout: new TilingLayout({
            axis: "column",
            hugContentsVertically: true,
            orderByIndex: true,
            padding: rect(0, 10, 0, 0),
            resizePolicies: [["h floater", {
              height: "fixed",
              width: "fill"
            }], ["font color input", {
              height: "fixed",
              width: "fill"
            }]],
            spacing: 10,
            wrapSubmorphs: false
          }),
          viewModel: {
            hoveredButtonComponent: GalyleoAddButtonHovered,
            activeButtonComponent: GalyleoAddButton
          },
          fill: Color$1.transparent,
          submorphs: [{
            name: "h floater",
            submorphs: [{
              name: "section headline",
              fontColor: Color$1.rgb(66, 73, 73)
            }, {
              name: "add button",
              visible: false
            }]
          }, {
            name: "text controls",
            submorphs: [{
              name: "font family selector",
              master: GalyleoDropDown,
              viewModelClass: GalyleoDropDownListModel,
              viewModel: {
                listMaster: GalyleoDropDownList
              }
            }, {
              name: "weight and styles",
              submorphs: [{
                name: "font weight selector",
                viewModelClass: GalyleoDropDownListModel,
                master: GalyleoDropDown,
                viewModel: {
                  listMaster: GalyleoDropDownList
                }
              }, {
                name: "styling controls",
                submorphs: [{
                  name: "italic style",
                  master: GalyleoAddButton
                }, {
                  name: "underline style",
                  master: GalyleoAddButton
                }, {
                  name: "inline link",
                  master: GalyleoAddButton
                }, {
                  name: "quote",
                  master: GalyleoAddButton
                }]
              }]
            }, {
              name: "font size input",
              master: GalyleoNumberInput
            }, {
              name: "line height input",
              master: GalyleoNumberInput
            }, {
              name: "letter spacing input",
              master: GalyleoNumberInput
            }]
          }, {
            name: "font color input",
            master: GalyleoColorInput
          }, {
            name: "bottom wrapper",
            submorphs: [{
              name: "alignment controls",
              submorphs: [{
                name: "left align",
                master: GalyleoAddButton
              }, {
                name: "center align",
                master: GalyleoAddButton
              }, {
                name: "right align",
                master: GalyleoAddButton
              }, {
                name: "block align",
                master: GalyleoAddButton
              }]
            }, {
              name: "line wrapping selector",
              viewModelClass: GalyleoDropDownListModel,
              master: GalyleoDropDown,
              viewModel: {
                listMaster: GalyleoDropDownList
              }
            }]
          }, {
            name: "padding controls",
            viewModel: {
              propertyLabelComponent: GalyleoAddButtonDefault,
              propertyLabelComponentActive: GalyleoAddButtonActive,
              propertyLabelComponentHover: GalyleoAddButtonHovered
            },
            master: __varRecorder__$7.GalyleoPaddingControls
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/controls/text.cp.js",
        "export": "GalyleoRichTextControl",
        range: {
          start: 1463,
          end: 4631
        }
      }, System, __varRecorder__$7, "GalyleoRichTextControl");
      var GalyleoRichTextControl = __varRecorder__$7.GalyleoRichTextControl;
      __varRecorder__$7.GalyleoRichTextControl = GalyleoRichTextControl;

      var __varRecorder__$6 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/color-picker.cp.js", __contextModule__);
      __varRecorder__$6.GalyleoColorPicker = component["for"](function () {
        return component(ColorPicker, {
          name: "galyleo/color picker",
          borderRadius: {
            topLeft: 10,
            topRight: 10,
            bottomLeft: 3,
            bottomRight: 3
          },
          fill: Color$1.rgb(215, 219, 221),
          submorphs: [add({
            name: "galyleo title bar",
            layout: new TilingLayout({
              align: "center",
              axisAlign: "center",
              orderByIndex: true
            }),
            reactsToPointer: false,
            extent: pt(241, 27.3),
            fill: Color$1.rgb(127, 140, 141),
            submorphs: [{
              name: "title",
              type: "label",
              fontWeight: 700,
              fontSize: 14,
              fontFamily: galyleoFont,
              textString: "Color Picker",
              fontColor: Color$1.rgb(255, 255, 255)
            }]
          }, "header menu"), {
            name: "header menu",
            submorphs: [{
              name: "color type selector",
              master: GalyleoDropDown,
              width: 100,
              viewModel: {
                listMaster: GalyleoDropDownList
              }
            }, {
              name: "close button",
              fontColor: Color$1.rgb(128, 128, 128),
              fontWeight: 700,
              fontSize: 15,
              fontFamily: galyleoFont,
              textAndAttributes: ["CLOSE ", null, "\uE5CD", {
                fontFamily: "Material Icons",
                fontSize: 20,
                textStyleClasses: ["material-icons"]
              }]
            }]
          }, {
            name: "color controls",
            submorphs: [{
              name: "color encoding",
              submorphs: [{
                name: "color code selector",
                layout: new TilingLayout({
                  align: "center",
                  axisAlign: "center",
                  justifySubmorphs: "spaced",
                  orderByIndex: true,
                  padding: rect(5, 0, 5, 0),
                  spacing: 5,
                  wrapSubmorphs: false
                }),
                extent: pt(53.3, 25),
                master: GalyleoDropDown,
                viewModel: {
                  listMaster: GalyleoDropDownList
                }
              }, {
                name: "controls",
                submorphs: [{
                  name: "hex encoding",
                  fill: Color$1.rgba(189, 195, 199, 0),
                  submorphs: [{
                    name: "hex opacity control",
                    master: GalyleoNumberInput,
                    borderRadius: 2
                  }, {
                    name: "hex input",
                    master: GalyleoTextInput
                  }]
                }, {
                  name: "3 val encoding",
                  fill: Color$1.transparent,
                  submorphs: [{
                    name: "opacity control",
                    master: GalyleoNumberInput,
                    borderRadius: 2
                  }, {
                    name: "first value",
                    master: GalyleoNumberInput,
                    borderRadius: 2
                  }, {
                    name: "second value",
                    master: GalyleoNumberInput,
                    borderRadius: 2
                  }, {
                    name: "third value",
                    master: GalyleoNumberInput,
                    borderRadius: 2
                  }]
                }, {
                  name: "css encoding",
                  submorphs: [{
                    name: "css input",
                    master: GalyleoTextInput,
                    borderRadius: 2
                  }]
                }]
              }]
            }]
          }, {
            name: "color palettes",
            submorphs: [{
              name: "color palette selector",
              master: GalyleoDropDown,
              viewModel: {
                listMaster: GalyleoDropDownList
              }
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/color-picker.cp.js",
        "export": "GalyleoColorPicker",
        range: {
          start: 312,
          end: 3939
        }
      }, System, __varRecorder__$6, "GalyleoColorPicker");
      var GalyleoColorPicker = __varRecorder__$6.GalyleoColorPicker;
      __varRecorder__$6.GalyleoColorPicker = GalyleoColorPicker;

      var __varRecorder__$5 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/side-bar.cp.js", __contextModule__);
      __varRecorder__$5.placeholderImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAbZJREFUaEPtmT0vBUEUhp/rIyJBJKKQaCQahUKjpVFoFEqVSBCtPyD+gFZC4Rf4bBX+gMRnr6KhIxEhIScZyWays8a9O7M7nCnvvTvnfc77nrnZ3QaJr0bi+lGAqh1UB+ruQC8wA4wAPZHFvgB3wCnw7KpdFCERvwZ0RxZul3sFtl0QRQDzwHjF4r/L3wAHeVqKANYBcaEOSyK09VuADeuCzcgkXvWLHPDaICCUV30FUAfcHdAIeXVAI6QRarEDGqEWG6h/ZP8xQl3Amwe41zEeO0JjwDSwC3z8AFE7gAFgGRAHLoCTOgEMAW3AvUNUpxE/mPn+ELgugIjmgNwzrwDtJhp5N+B5t6fvwA7w5ICIAiAztACMGhEPwJ6V70lg1iHy0UALjL2iAMhATlmVb4F989kwsGjccaXlEjiuAkC6Lt3PO8nOgHNgFejzODKPgCvrd0Ed6De5dz0z+jTZzg5tEUfePAQD6ACWADl5ylz2PAQDmAMmylSe2Ss7D8EAAmmv5hQKCaMOeHUgoAVe9f/0w93kH68n/4JD4p30K6aA81ne1vqatbxeNreTOtBc38q7KnkHvgAu0nMxVZqzQwAAAABJRU5ErkJggg==";
      __varRecorder__$5.SideBarTab = component["for"](function () {
        return component({
          name: "side bar/tab",
          borderColor: Color$1.rgb(128, 128, 128),
          borderWidth: {
            top: 1,
            left: 0,
            right: 1,
            bottom: 1
          },
          extent: pt(69.3, 32.7),
          fill: Color$1.rgba(0, 0, 0, 0),
          layout: new TilingLayout({
            align: "center",
            axis: "row",
            axisAlign: "center",
            autoResize: false,
            direction: "centered",
            orderByIndex: true,
            reactToSubmorphAnimations: false,
            renderViaCSS: true,
            resizeSubmorphs: false
          }),
          submorphs: [{
            type: Label,
            name: "tab label",
            fontSize: 14,
            fontColor: Color$1.rgb(81, 90, 90),
            fontFamily: galyleoFont,
            fontWeight: 700,
            nativeCursor: "pointer",
            textAndAttributes: ["Tab Name", null]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/side-bar.cp.js",
        "export": "SideBarTab",
        range: {
          start: 2580,
          end: 3286
        }
      }, System, __varRecorder__$5, "SideBarTab");
      __varRecorder__$5.SideBarTabSelected = component["for"](function () {
        return component(__varRecorder__$5.SideBarTab, {
          name: "side bar/tab/selected",
          fill: Color$1.rgb(241, 90, 36),
          submorphs: [{
            name: "tab label",
            fontColor: Color$1.rgb(255, 255, 255)
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/side-bar.cp.js",
        "export": "SideBarTabSelected",
        range: {
          start: 3295,
          end: 3489
        }
      }, System, __varRecorder__$5, "SideBarTabSelected");
      var DashboardControl = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/side-bar.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("DashboardControl") && typeof __lively_classholder__.DashboardControl === "function" ? __lively_classholder__.DashboardControl : __lively_classholder__.DashboardControl = function DashboardControl(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "selectTarget",
          value: function DashboardControl_selectTarget_(target) {
            if (_missingExportShim$1(target)) return;
            this.slideIn();
            this.focusMorph(target);
          }
        }, {
          key: "deselectTarget",
          value: function () {
            var _DashboardControl_deselectTarget_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      this.models.styleControl.attachToTarget;

                    case 1:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function DashboardControl_deselectTarget_() {
              return _DashboardControl_deselectTarget_.apply(this, arguments);
            }

            return DashboardControl_deselectTarget_;
          }()
        }, {
          key: "focusMorph",
          value: function DashboardControl_focusMorph_(target) {
            this.ui.styleControl.focusOn(target);
          }
        }, {
          key: "selectTab",
          value: function () {
            var _DashboardControl_selectTab_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(tabName) {
              var tabToControl, controlFrame, selectedControl;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      tabToControl = {
                        tables: "tableControl",
                        filters: "filterControl",
                        charts: "chartControl",
                        views: "viewControl"
                      };
                      this.ui.tabSwitcher.submorphs.forEach(function (m) {
                        return m.master.setState(null);
                      });
                      this.ui[tabName + "Tab"].master.setState("selected");
                      controlFrame = this.ui.controlContainer;
                      selectedControl = this.ui[tabToControl[tabName]];
                      controlFrame.submorphs.forEach(function (m) {
                        m.visible = m.isLayoutable = m === selectedControl;
                      });

                    case 6:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function DashboardControl_selectTab_(_x) {
              return _DashboardControl_selectTab_.apply(this, arguments);
            }

            return DashboardControl_selectTab_;
          }()
        }, {
          key: "init",
          value: function DashboardControl_init_(dashboard) {
            this.dashboard = dashboard;
            dashboard.init(this);
            this.models.tableControl.init(this);
            this.models.filterControl.init(this);
            this.models.chartControl.init(this);
            this.models.viewControl.init(this);
            this.models.styleControl.attachToTarget(dashboard);
            this.models.styleControl.clearFocus();
            this.ui.controls.visible = false;
            this.adjustIndicator();
          }
        }, {
          key: "viewDidLoad",
          value: function DashboardControl_viewDidLoad_() {
            this.toggleSlide();
            this.toggleSlide();
          }
        }, {
          key: "clearFocus",
          value: function DashboardControl_clearFocus_() {
            this.models.styleControl.clearFocus();
          }
        }, {
          key: "toggleSlide",
          value: function DashboardControl_toggleSlide_() {
            if (this.isToggled) {
              this._userAskedToStay = false;
              this.slideOut();
            } else {
              this._userAskedToStay = true;
              this.slideIn();
            }
          }
        }, {
          key: "adjustIndicator",
          value: function DashboardControl_adjustIndicator_() {
            var collapseIndicator = this.ui.collapseIndicator;
            collapseIndicator.rotation = this.isToggled ? Math.PI : 2 * Math.PI;
            this.relayout();
          }
        }, {
          key: "slideOut",
          value: function () {
            var _DashboardControl_slideOut_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
              var _this = this;

              var world, view;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      world = this.world();
                      view = this.view;
                      this.isToggled = false;
                      _context3.next = 5;
                      return view.owner.withAnimationDo(function () {
                        _this.adjustIndicator();
                      }, {
                        easing: easings.inOutExpo,
                        duration: 300
                      });

                    case 5:
                      this.ui.controls.visible = false;

                      if (world) {
                        world.halos().forEach(function (h) {
                          return h.maskBounds = world.getHaloMask();
                        });
                      }

                    case 7:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function DashboardControl_slideOut_() {
              return _DashboardControl_slideOut_.apply(this, arguments);
            }

            return DashboardControl_slideOut_;
          }()
        }, {
          key: "slideIn",
          value: function () {
            var _DashboardControl_slideIn_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
              var _this2 = this;

              var view, world;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      view = this.view;
                      world = this.world();
                      this.isToggled = true;

                      if (!(view.right === view.owner.width)) {
                        _context4.next = 5;
                        break;
                      }

                      return _context4.abrupt("return");

                    case 5:
                      this.ui.controls.visible = true;
                      _context4.next = 8;
                      return view.owner.withAnimationDo(function () {
                        _this2.adjustIndicator();
                      }, {
                        easing: easings.inOutExpo,
                        duration: 300
                      });

                    case 8:
                      if (world) {
                        world.halos().forEach(function (h) {
                          return h.maskBounds = world.getHaloMask();
                        });
                      }

                    case 9:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function DashboardControl_slideIn_() {
              return _DashboardControl_slideIn_.apply(this, arguments);
            }

            return DashboardControl_slideIn_;
          }()
        }, {
          key: "relayout",
          value: function DashboardControl_relayout_() {
            var view = this.view;
            var collapseIndicator = this.ui.collapseIndicator;
            collapseIndicator.leftCenter = this.view.innerBounds().leftCenter();

            if (this.isToggled) {
              view.right = view.owner.width;
            } else {
              view.left = view.owner.width - collapseIndicator.width - view.borderWidth;
            }
          }
        }, {
          key: "_wrapData",
          value: function DashboardControl__wrapData_(dataEntries) {
            return dataEntries.map(function (d) {
              return TableEntry.wrapDataEntry(d);
            });
          }
        }, {
          key: "_wrapVisual",
          value: function DashboardControl__wrapVisual_(visualEntries) {
            return visualEntries.map(function (v) {
              return TableEntry.wrapVisualEntry(v);
            });
          }
        }, {
          key: "update",
          value: function DashboardControl_update_() {
            var _this$models = this.models,
                tableControl = _this$models.tableControl,
                chartControl = _this$models.chartControl,
                viewControl = _this$models.viewControl,
                filterControl = _this$models.filterControl;
            var tables = this.dashboard.tableNames.map(function (tableName) {
              return TableEntryMorph.wrapVisualOnlyEntry(tableName, {
                onDelete: function onDelete() {
                  return tableControl.removeTable(tableName);
                },
                onConfig: function onConfig() {
                  return tableControl.previewTable(tableName);
                }
              });
            });
            var charts = this.dashboard.chartNames.map(function (chartName) {
              return TableEntryMorph.wrapVisualEntry(chartName, {
                onData: function onData() {
                  return chartControl.editChart(chartName);
                },
                onDelete: function onDelete() {
                  return chartControl.removeChart(chartName);
                }
              });
            });
            var views = this.dashboard.viewNames.map(function (viewName) {
              return TableEntryMorph.wrapVisualEntry(viewName, {
                onData: function onData() {
                  return viewControl.editView(viewName);
                },
                onDelete: function onDelete() {
                  return viewControl.removeView(viewName);
                }
              });
            });
            var filters = this.dashboard.filterNames.map(function (filterName) {
              return TableEntryMorph.wrapVisualDataEntry(filterName, {
                onConfig: function onConfig() {
                  return filterControl.highlightFilter(filterName);
                },
                onData: function onData() {
                  return filterControl.editFilter(filterName);
                },
                onDelete: function onDelete() {
                  return filterControl.removeFilter(filterName);
                }
              });
            });
            tableControl.items = tables;
            chartControl.items = charts;
            viewControl.items = views;
            filterControl.items = filters;
          }
        }, {
          key: "openDialog",
          value: function () {
            var _DashboardControl_openDialog_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(dialogPart) {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.next = 2;
                      return this.dashboard.openDialog(dialogPart);

                    case 2:
                      return _context5.abrupt("return", _context5.sent);

                    case 3:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function DashboardControl_openDialog_(_x2) {
              return _DashboardControl_openDialog_.apply(this, arguments);
            }

            return DashboardControl_openDialog_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "DashboardControl";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              isHaloItem: {
                defaultValue: true
              },
              dashboard: {},
              topBar: {},
              isToggled: {
                defaultValue: false
              },
              expose: {
                get: function get() {
                  return ["isHaloItem", "init", "update", "clearFocus"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    signal: "extent",
                    handler: "relayout"
                  }, {
                    target: "close button",
                    signal: "fire",
                    handler: "slideOut"
                  }, {
                    target: "collapse indicator",
                    signal: "onMouseDown",
                    handler: "toggleSlide"
                  }, {
                    target: "tables tab",
                    signal: "onMouseDown",
                    handler: "selectTab",
                    converter: function converter() {
                      return "tables";
                    }
                  }, {
                    target: "charts tab",
                    signal: "onMouseDown",
                    handler: "selectTab",
                    converter: function converter() {
                      return "charts";
                    }
                  }, {
                    target: "filters tab",
                    signal: "onMouseDown",
                    handler: "selectTab",
                    converter: function converter() {
                      return "filters";
                    }
                  }, {
                    target: "views tab",
                    signal: "onMouseDown",
                    handler: "selectTab",
                    converter: function converter() {
                      return "views";
                    }
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/side-bar.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 3499,
          end: 11289
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$5.DashboardControl = DashboardControl;
      __varRecorder__$5.DashboardControl = DashboardControl;
      var EntityControlModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/side-bar.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("EntityControlModel") && typeof __lively_classholder__.EntityControlModel === "function" ? __lively_classholder__.EntityControlModel : __lively_classholder__.EntityControlModel = function EntityControlModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "init",
          value: function EntityControlModel_init_(controller) {
            this.controller = controller;
          }
        }, {
          key: "dashboard",
          get: function get() {
            return this.controller.dashboard;
          }
        }, {
          key: "toggleEdit",
          value: function EntityControlModel_toggleEdit_() {
            this.ui.entryList.toggleEdit();
          }
        }, {
          key: "build",
          value: function EntityControlModel_build_() {}
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "EntityControlModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["init"];
                }
              },
              items: {
                derived: true,
                set: function set(items) {
                  this.ui.entryList.items = items;
                },
                get: function get() {
                  var _this$ui$entryList;

                  return (_this$ui$entryList = this.ui.entryList) === null || _this$ui$entryList === void 0 ? void 0 : _this$ui$entryList.items;
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "edit button",
                    signal: "onMouseDown",
                    handler: "toggleEdit"
                  }, {
                    target: "add button",
                    signal: "onMouseDown",
                    handler: "build"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/side-bar.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 11298,
          end: 12311
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$5.EntityControlModel = EntityControlModel;
      __varRecorder__$5.EntityControlModel = EntityControlModel;
      var TableControlModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/side-bar.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("TableControlModel") && typeof __lively_classholder__.TableControlModel === "function" ? __lively_classholder__.TableControlModel : __lively_classholder__.TableControlModel = function TableControlModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "build",
          value: function () {
            var _TableControlModel_build_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
              var tableBuilder;
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      _context6.next = 2;
                      return this.controller.openDialog(DataLoader);

                    case 2:
                      tableBuilder = _context6.sent;
                      tableBuilder.viewModel.init(this.dashboard.viewModel);

                    case 4:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function TableControlModel_build_() {
              return _TableControlModel_build_.apply(this, arguments);
            }

            return TableControlModel_build_;
          }()
        }, {
          key: "removeTable",
          value: function TableControlModel_removeTable_(tableName) {
            if (this.dashboard.tables[tableName]) {
              delete this.dashboard.tables[tableName];
            }

            this.dashboard.dirty = true;
            this.controller.update();
          }
        }, {
          key: "previewTable",
          value: function TableControlModel_previewTable_(table) {
            this.dashboard.viewModel.displayPreview(table);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "TableControlModel";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/side-bar.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 12320,
          end: 12802
        });
      }(__varRecorder__$5.EntityControlModel);
      __varRecorder__$5.TableControlModel = TableControlModel;
      __varRecorder__$5.TableControlModel = TableControlModel;
      var FilterControlModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/side-bar.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("FilterControlModel") && typeof __lively_classholder__.FilterControlModel === "function" ? __lively_classholder__.FilterControlModel : __lively_classholder__.FilterControlModel = function FilterControlModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "build",
          value: function () {
            var _FilterControlModel_build_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
              var filterBuilder;
              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      _context7.next = 2;
                      return this.controller.openDialog(FilterBuilder);

                    case 2:
                      filterBuilder = _context7.sent;
                      filterBuilder.init(this.dashboard);

                    case 4:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7, this);
            }));

            function FilterControlModel_build_() {
              return _FilterControlModel_build_.apply(this, arguments);
            }

            return FilterControlModel_build_;
          }()
        }, {
          key: "editFilter",
          value: function () {
            var _FilterControlModel_editFilter_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(filterName) {
              var filterEditor;
              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      _context8.next = 2;
                      return this.controller.openDialog(FilterEditor);

                    case 2:
                      filterEditor = _context8.sent;
                      filterEditor.init(this.dashboard, filterName);

                    case 4:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, this);
            }));

            function FilterControlModel_editFilter_(_x3) {
              return _FilterControlModel_editFilter_.apply(this, arguments);
            }

            return FilterControlModel_editFilter_;
          }()
        }, {
          key: "removeFilter",
          value: function FilterControlModel_removeFilter_(filterName) {
            this.dashboard.removeFilter(filterName);
          }
        }, {
          key: "highlightFilter",
          value: function FilterControlModel_highlightFilter_(filterName) {
            this.dashboard.getSubmorphNamed(filterName).show();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "FilterControlModel";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/side-bar.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 12811,
          end: 13341
        });
      }(__varRecorder__$5.EntityControlModel);
      __varRecorder__$5.FilterControlModel = FilterControlModel;
      __varRecorder__$5.FilterControlModel = FilterControlModel;
      var ChartControlModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/side-bar.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ChartControlModel") && typeof __lively_classholder__.ChartControlModel === "function" ? __lively_classholder__.ChartControlModel : __lively_classholder__.ChartControlModel = function ChartControlModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "build",
          value: function () {
            var _ChartControlModel_build_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
              var chartBuilder;
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      _context9.next = 2;
                      return this.controller.openDialog(ChartBuilder);

                    case 2:
                      chartBuilder = _context9.sent;
                      chartBuilder.init(this.dashboard);

                    case 4:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, this);
            }));

            function ChartControlModel_build_() {
              return _ChartControlModel_build_.apply(this, arguments);
            }

            return ChartControlModel_build_;
          }()
        }, {
          key: "editChart",
          value: function ChartControlModel_editChart_(chartName) {
            this.dashboard.editChartStyle(chartName);
          }
        }, {
          key: "removeChart",
          value: function ChartControlModel_removeChart_(chartName) {
            this.dashboard.removeChart(chartName);
          }
        }, {
          key: "highlightChart",
          value: function ChartControlModel_highlightChart_(chartName) {
            this.dashboard.get(chartName).show();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ChartControlModel";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/side-bar.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 13350,
          end: 14002
        });
      }(__varRecorder__$5.EntityControlModel);
      __varRecorder__$5.ChartControlModel = ChartControlModel;
      __varRecorder__$5.ChartControlModel = ChartControlModel;
      var ViewControlModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/side-bar.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("ViewControlModel") && typeof __lively_classholder__.ViewControlModel === "function" ? __lively_classholder__.ViewControlModel : __lively_classholder__.ViewControlModel = function ViewControlModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "build",
          value: function () {
            var _ViewControlModel_build_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
              var newViewPrompt;
              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      _context10.next = 2;
                      return this.controller.openDialog(ViewCreatorPrompt);

                    case 2:
                      newViewPrompt = _context10.sent;
                      newViewPrompt.init(this.dashboard);

                    case 4:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, this);
            }));

            function ViewControlModel_build_() {
              return _ViewControlModel_build_.apply(this, arguments);
            }

            return ViewControlModel_build_;
          }()
        }, {
          key: "editView",
          value: function ViewControlModel_editView_(viewName) {
            this.dashboard.createViewEditor(viewName);
          }
        }, {
          key: "removeView",
          value: function ViewControlModel_removeView_(viewName) {
            delete this.dashboard.views[viewName];
            this.controller.update();
            this.dashboard.dirty = true;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "ViewControlModel";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/side-bar.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 14011,
          end: 14442
        });
      }(__varRecorder__$5.EntityControlModel);
      __varRecorder__$5.ViewControlModel = ViewControlModel;
      __varRecorder__$5.ViewControlModel = ViewControlModel;

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/side-bar.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GalyleoPropertiesPanelModel") && typeof __lively_classholder__.GalyleoPropertiesPanelModel === "function" ? __lively_classholder__.GalyleoPropertiesPanelModel : __lively_classholder__.GalyleoPropertiesPanelModel = function GalyleoPropertiesPanelModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "focusOn",
          value: function GalyleoPropertiesPanelModel_focusOn_(aMorph) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "focusOn", this).call(this, aMorph);

            this.ui.componentControl.visible = false;
            this.ui.responsiveControl.visible = false;
            this.ui.componentStatesControl.visible = false;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GalyleoPropertiesPanelModel";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/side-bar.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 14444,
          end: 14707
        });
      })({
        referencedAs: "PropertiesPanelModel",
        value: PropertiesPanelModel
      });

      __varRecorder__$5.GalyleoPropertiesPanel = component["for"](function () {
        return component(PropertiesPanel, {
          defaultViewModel: __varRecorder__$5.GalyleoPropertiesPanelModel,
          name: "galyleo/properties panel",
          fill: Color$1.rgb(215, 219, 221),
          extent: pt(267.9, 1000),
          submorphs: [{
            name: "background control",
            layout: new TilingLayout({
              axis: "column",
              hugContentsVertically: true,
              orderByIndex: true,
              padding: rect(0, 10, 0, 0),
              resizePolicies: [["h floater", {
                height: "fixed",
                width: "fill"
              }], ["background fill input", {
                height: "fixed",
                width: "fill"
              }]],
              spacing: 10,
              wrapSubmorphs: false
            }),
            extent: pt(250, 98),
            master: GalyleoPropertySection,
            submorphs: [{
              name: "background fill input",
              master: GalyleoColorInput,
              viewModel: {
                activeColor: Color$1.gray,
                gradientEnabled: true,
                colorPickerComponent: GalyleoColorPicker
              }
            }]
          }, {
            name: "shape control",
            master: GalyleoShapeControl,
            visible: true,
            viewModel: {
              propertyLabelComponent: GalyleoAddButtonDefault,
              propertyLabelComponentHover: GalyleoAddButtonHovered,
              propertyLabelComponentActive: GalyleoAddButtonActive
            },
            submorphs: [{
              name: "width mode selector",
              viewModel: {
                listMaster: GalyleoDropDownList
              }
            }, {
              name: "height mode selector",
              viewModel: {
                listMaster: GalyleoDropDownList
              }
            }, {
              name: "clip mode selector",
              viewModelClass: GalyleoDropDownListModel,
              viewModel: {
                listMaster: GalyleoDropDownList
              }
            }]
          }, {
            name: "text control",
            master: GalyleoRichTextControl,
            visible: true,
            viewModel: {
              activeButtonComponent: GalyleoAddButtonActive,
              hoveredButtonComponent: GalyleoAddButtonHovered
            },
            submorphs: [{
              name: "text controls",
              submorphs: [{
                name: "font family selector",
                viewModelClass: GalyleoDropDownListModel,
                viewModel: {
                  listMaster: GalyleoDropDownList
                }
              }, {
                name: "font weight selector",
                viewModelClass: GalyleoDropDownListModel,
                viewModel: {
                  listMaster: GalyleoDropDownList
                }
              }]
            }, {
              name: "font color input",
              viewModel: {
                activeColor: Color$1.gray,
                colorPickerComponent: GalyleoColorPicker
              }
            }, {
              name: "bottom wrapper",
              submorphs: [{
                name: "line wrapping selector",
                viewModelClass: GalyleoDropDownListModel,
                viewModel: {
                  listMaster: GalyleoDropDownList
                }
              }]
            }, {
              name: "padding controls",
              viewModel: {
                propertyLabelComponent: GalyleoAddButtonDefault,
                propertyLabelComponentActive: GalyleoAddButtonActive,
                propertyLabelComponentHover: GalyleoAddButtonHovered
              }
            }]
          }, {
            name: "layout control",
            visible: true,
            master: GalyleoLayoutControl,
            viewModel: {
              activeSectionComponent: GalyleoLayoutControl,
              hoverSectionComponent: GalyleoPropertySection,
              inactiveSectionComponent: GalyleoPropertySectionInactive,
              controlFlapComponent: GalyleoLayoutFlap,
              buttonActiveComponent: GalyleoAddButtonHovered,
              buttonInactiveComponent: GalyleoAddButton
            },
            submorphs: [{
              name: "controls",
              submorphs: [{
                name: "mini layout preview",
                activeComponent: GalyleoMiniLayoutPreviewActive,
                inactiveComponent: GalyleoMiniLayoutPreview
              }]
            }, {
              name: "wrap checkbox wrapper",
              submorphs: [{
                name: "wrap submorphs checkbox",
                submorphs: [{
                  name: "checkbox",
                  viewModel: {
                    checkedCheckboxComponent: GalyleoCheckboxChecked,
                    uncheckedCheckboxComponent: GalyleoCheckboxUnchecked
                  }
                }]
              }]
            }]
          }, {
            name: "constraints control",
            visible: true,
            master: GalyleoAlignmentControl,
            submorphs: [{
              name: "constraints",
              viewModel: {
                activeMarkerComponent: GalyleoConstraintMarkerActive,
                defaultMarkerComponent: GalyleoConstraintMarker
              },
              submorphs: [{
                name: "horizontal alignment selector",
                viewModelClass: GalyleoDropDownListModel,
                viewModel: {
                  listMaster: GalyleoDropDownList
                }
              }, {
                name: "vertical alignment selector",
                viewModelClass: GalyleoDropDownListModel,
                viewModel: {
                  listMaster: GalyleoDropDownList
                }
              }]
            }, {
              name: "resizing",
              submorphs: [{
                name: "horizontal alignment selector",
                viewModelClass: GalyleoDropDownListModel,
                viewModel: {
                  listMaster: GalyleoDropDownList
                }
              }, {
                name: "vertical alignment selector",
                viewModelClass: GalyleoDropDownListModel,
                viewModel: {
                  listMaster: GalyleoDropDownList
                }
              }]
            }]
          }, {
            name: "fill control",
            visible: true,
            master: GalyleoFillControl,
            viewModel: {
              placeholderImage: __varRecorder__$5.placeholderImage
            },
            submorphs: [{
              name: "fill color input",
              viewModel: {
                activeColor: Color$1.gray,
                gradientEnabled: true,
                colorPickerComponent: GalyleoColorPicker
              }
            }]
          }, {
            name: "border control",
            visible: true,
            master: GalyleoBorderControl,
            viewModel: {
              activeSectionComponent: GalyleoBorderControl,
              hoverSectionComponent: GalyleoPropertySection,
              inactiveSectionComponent: GalyleoPropertySectionInactive,
              propertyLabelComponent: GalyleoAddButtonDefault,
              propertyLabelComponentHover: GalyleoAddButtonHovered,
              propertyLabelComponentActive: GalyleoAddButtonActive,
              borderPopupComponent: GalyleoBorderPopup
            },
            submorphs: [{
              name: "elements wrapper",
              submorphs: [{
                name: "border color input",
                viewModel: {
                  activeColor: Color$1.gray,
                  colorPickerComponent: GalyleoColorPicker
                }
              }, {
                name: "border width control",
                submorphs: [{
                  name: "border style selector",
                  viewModelClass: GalyleoDropDownListModel,
                  viewModel: {
                    listMaster: GalyleoDropDownList
                  }
                }]
              }]
            }]
          }, {
            name: "effects control",
            visible: true,
            master: GalyleoPropertySection,
            defaultViewModel: GalyleoBodyControlModel,
            viewModel: {
              activeSectionComponent: GalyleoPropertySection,
              hoverSectionComponent: GalyleoPropertySection,
              inactiveSectionComponent: GalyleoPropertySectionInactive,
              dynamicPropertyComponent: GalyleoDynamicProperty
            }
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/side-bar.cp.js",
        "export": "GalyleoPropertiesPanel",
        range: {
          start: 14715,
          end: 22851
        }
      }, System, __varRecorder__$5, "GalyleoPropertiesPanel");
      __varRecorder__$5.ControlPanel = component["for"](function () {
        return component({
          name: "control panel",
          extent: pt(262.6, 238.8),
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "right",
            orderByIndex: true,
            padding: rect(10, 10, 0, 0),
            resizePolicies: [["v wrapper", {
              height: "fixed",
              width: "fill"
            }], ["entry list", {
              height: "fixed",
              width: "fill"
            }]],
            spacing: 10,
            wrapSubmorphs: false
          }),
          fill: Color$1.transparent,
          submorphs: [{
            name: "v wrapper",
            layout: new TilingLayout({
              axisAlign: "center",
              justifySubmorphs: "spaced",
              orderByIndex: true
            }),
            extent: pt(243, 28.7),
            fill: Color$1.transparent,
            submorphs: [{
              type: Label,
              name: "control label",
              fontColor: Color$1.rgb(81, 90, 90),
              fontFamily: galyleoFont,
              fontSize: 14,
              fontWeight: 700,
              nativeCursor: "pointer",
              position: pt(16, 39.9),
              textAndAttributes: ["Control name", null]
            }, {
              type: Image,
              name: "edit button",
              autoResize: false,
              extent: pt(20.2, 19.3),
              imageUrl: projectAsset("engageLively--galyleo-dashboard__edit-icon.svg"),
              nativeCursor: "pointer"
            }]
          }, part(GalyleoList, {
            name: "entry list",
            submorphs: [{
              name: "item list",
              extent: pt(263, 148.8),
              clipMode: "hidden"
            }, {
              name: "scroll bar",
              position: pt(230.4, 8)
            }]
          }), part(PromptButton, {
            name: "add button",
            extent: pt(122.1, 34.4)
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/side-bar.cp.js",
        "export": "ControlPanel",
        range: {
          start: 22860,
          end: 24439
        }
      }, System, __varRecorder__$5, "ControlPanel");
      __varRecorder__$5.GalyleoSideBarControls = component["for"](function () {
        return component({
          name: "galyleo/side bar controls",
          clipMode: "hidden",
          fill: Color$1.rgb(215, 219, 221),
          layout: new TilingLayout({
            axis: "column",
            orderByIndex: true,
            resizePolicies: [["tab switcher", {
              height: "fixed",
              width: "fill"
            }], ["control container", {
              height: "fixed",
              width: "fill"
            }], ["style control", {
              height: "fill",
              width: "fill"
            }]],
            wrapSubmorphs: false
          }),
          extent: pt(277.2, 812.7),
          submorphs: [{
            name: "tab switcher",
            borderWidth: {
              top: 1,
              left: 0,
              right: 0,
              bottom: 1
            },
            borderColor: Color$1.rgb(128, 128, 128),
            clipMode: "hidden",
            extent: pt(322.8, 32.7),
            fill: Color$1.rgba(0, 0, 0, 0),
            layout: new TilingLayout({
              align: "top",
              axis: "row",
              autoResize: false,
              direction: "leftToRight",
              orderByIndex: true,
              reactToSubmorphAnimations: false,
              renderViaCSS: true,
              resizeSubmorphs: false
            }),
            submorphs: [part(__varRecorder__$5.SideBarTab, {
              master: {
                states: {
                  selected: __varRecorder__$5.SideBarTabSelected
                }
              },
              name: "tables tab",
              submorphs: [{
                name: "tab label",
                textAndAttributes: ["Tables", null]
              }]
            }), part(__varRecorder__$5.SideBarTab, {
              master: {
                states: {
                  selected: __varRecorder__$5.SideBarTabSelected
                }
              },
              name: "filters tab",
              submorphs: [{
                name: "tab label",
                textAndAttributes: ["Filters", null]
              }]
            }), part(__varRecorder__$5.SideBarTab, {
              master: {
                states: {
                  selected: __varRecorder__$5.SideBarTabSelected
                }
              },
              name: "views tab",
              submorphs: [{
                name: "tab label",
                textAndAttributes: ["Views", null]
              }]
            }), part(__varRecorder__$5.SideBarTab, {
              master: {
                states: {
                  selected: __varRecorder__$5.SideBarTabSelected
                }
              },
              name: "charts tab",
              submorphs: [{
                name: "tab label",
                textAndAttributes: ["Charts", null]
              }]
            })]
          }, {
            name: "control container",
            extent: pt(364, 245.2),
            clipMode: "hidden",
            layout: new TilingLayout({
              axis: "column",
              orderByIndex: true,
              padding: rect(10, 0, 0, 0),
              resizePolicies: [["chart control", {
                height: "fixed",
                width: "fill"
              }], ["view control", {
                height: "fixed",
                width: "fill"
              }], ["table control", {
                height: "fixed",
                width: "fill"
              }], ["filter control", {
                height: "fixed",
                width: "fill"
              }]],
              wrapSubmorphs: false
            }),
            fill: Color$1.transparent,
            submorphs: [part(__varRecorder__$5.ControlPanel, {
              name: "chart control",
              viewModelClass: __varRecorder__$5.ChartControlModel,
              submorphs: [{
                name: "v wrapper",
                submorphs: [{
                  name: "control label",
                  textAndAttributes: ["Charts", null]
                }]
              }, {
                name: "add button",
                submorphs: [{
                  name: "label",
                  textAndAttributes: ["Add chart", null]
                }]
              }]
            }), part(__varRecorder__$5.ControlPanel, {
              name: "view control",
              viewModelClass: __varRecorder__$5.ViewControlModel,
              position: pt(288.5, 233.5),
              submorphs: [{
                name: "v wrapper",
                submorphs: [{
                  name: "control label",
                  textAndAttributes: ["Views", null]
                }]
              }, {
                name: "add button",
                submorphs: [{
                  name: "label",
                  textAndAttributes: ["Add view", null]
                }]
              }]
            }), part(__varRecorder__$5.ControlPanel, {
              name: "table control",
              viewModelClass: __varRecorder__$5.TableControlModel,
              position: pt(12.7, 510.6),
              submorphs: [{
                name: "v wrapper",
                submorphs: [{
                  name: "control label",
                  textAndAttributes: ["Tables", null]
                }]
              }, {
                name: "add button",
                submorphs: [{
                  name: "label",
                  textAndAttributes: ["Add table", null]
                }]
              }]
            }), part(__varRecorder__$5.ControlPanel, {
              name: "filter control",
              viewModelClass: __varRecorder__$5.FilterControlModel,
              position: pt(16.8, 258.7),
              submorphs: [{
                name: "v wrapper",
                submorphs: [{
                  name: "control label",
                  textAndAttributes: ["Filters", null]
                }]
              }, {
                name: "entry list",
                submorphs: [{
                  name: "item list",
                  clipMode: "hidden",
                  extent: pt(257, 148.8)
                }, {
                  name: "scroll bar",
                  position: pt(224.4, 8)
                }]
              }, {
                name: "add button",
                submorphs: [{
                  name: "label",
                  textAndAttributes: ["Add filter", null]
                }]
              }]
            })]
          }, part(__varRecorder__$5.GalyleoPropertiesPanel, {
            name: "style control",
            dropShadow: new ShadowObject({
              distance: 1.414213562373095,
              rotation: 90,
              color: Color$1.rgba(0, 0, 0, 0.3),
              inset: true,
              blur: 11
            }),
            borderColor: Color$1.rgbHex("7F8C8D"),
            borderWidth: {
              top: 3,
              left: 0,
              right: 0,
              bottom: 0
            },
            layout: new TilingLayout({
              axis: "column",
              orderByIndex: true,
              resizePolicies: [["background control", {
                width: "fill"
              }], ["shape control", {
                width: "fill"
              }], ["text control", {
                width: "fill"
              }], ["layout control", {
                width: "fill"
              }], ["constraints control", {
                height: "fixed",
                width: "fill"
              }], ["fill control", {
                height: "fixed",
                width: "fill"
              }], ["border control", {
                height: "fixed",
                width: "fill"
              }], ["effects control", {
                height: "fixed",
                width: "fill"
              }]],
              wrapSubmorphs: false
            }),
            extent: pt(318.2, 535),
            submorphs: [{
              name: "shape control",
              extent: pt(242, 177)
            }, {
              name: "text control",
              extent: pt(335.8, 264)
            }, {
              name: "layout control",
              extent: pt(334.8, 133)
            }]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/side-bar.cp.js",
        "export": "GalyleoSideBarControls",
        range: {
          start: 24448,
          end: 30583
        }
      }, System, __varRecorder__$5, "GalyleoSideBarControls");
      __varRecorder__$5.GalyleoSideBar = component["for"](function () {
        return component({
          viewModelClass: __varRecorder__$5.DashboardControl,
          name: "galyleo/side bar",
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "right",
            orderByIndex: true,
            resizePolicies: [["button wrapper", {
              height: "fixed",
              width: "fixed"
            }], ["controls", {
              height: "fill",
              width: "fill"
            }]],
            wrapSubmorphs: false
          }),
          borderColor: Color$1.rgb(241, 90, 36),
          borderWidth: {
            bottom: 0,
            left: 4,
            right: 0,
            top: 0
          },
          clipMode: "hidden",
          extent: pt(296.3, 1124.2),
          fill: Color$1.rgb(215, 219, 221),
          position: pt(366.9, 119.8),
          submorphs: [{
            name: "button wrapper",
            fill: Color$1.rgba(255, 255, 255, 0),
            extent: pt(297, 45.1),
            layout: new TilingLayout({
              align: "right",
              axisAlign: "center",
              axis: "row",
              orderByIndex: true,
              padding: rect(10, 0, 10, 0),
              wrapSubmorphs: true
            }),
            submorphs: [part(MenuBarButton, {
              tooltip: "Close this dialog without loading",
              name: "close button",
              extent: pt(84.3, 28),
              layout: new TilingLayout({
                align: "center",
                axisAlign: "center",
                padding: rect(0, 0, 5, 0),
                spacing: 8
              }),
              submorphs: [{
                name: "label",
                textAndAttributes: ["CLOSE", null],
                fontFamily: galyleoFont
              }, {
                name: "icon",
                extent: pt(14, 14),
                imageUrl: projectAsset("engageLively--galyleo-dashboard__close-button-icon-2.svg")
              }]
            })]
          }, part(__varRecorder__$5.GalyleoSideBarControls, {
            name: "controls"
          }), {
            type: Polygon,
            name: "collapse indicator",
            position: pt(6, 548.9),
            borderColor: Color$1.rgb(23, 160, 251),
            extent: pt(13.9, 26.5),
            fill: Color$1.rgb(241, 90, 36),
            isLayoutable: false,
            nativeCursor: "pointer",
            origin: pt(7, 13.3),
            rotation: 3.141592653589793,
            vertices: [{
              position: pt(13.913458455121425, 26.513896059782553),
              isSmooth: false,
              controlPoints: {
                next: pt(0, 0),
                previous: pt(0, 0)
              }
            }, {
              position: pt(0, 13.221250152706657),
              isSmooth: false,
              controlPoints: {
                next: pt(0, 0),
                previous: pt(0, 0)
              }
            }, {
              position: pt(13.832109662787806, 0),
              isSmooth: false,
              controlPoints: {
                next: pt(0, 0),
                previous: pt(0, 0)
              }
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/side-bar.cp.js",
        "export": "GalyleoSideBar",
        range: {
          start: 30592,
          end: 32995
        }
      }, System, __varRecorder__$5, "GalyleoSideBar");
      var GalyleoSideBar = __varRecorder__$5.GalyleoSideBar;
      var GalyleoPropertiesPanel = __varRecorder__$5.GalyleoPropertiesPanel;
      var SideBarTabSelected = __varRecorder__$5.SideBarTabSelected;
      var ControlPanel = __varRecorder__$5.ControlPanel;
      __varRecorder__$5.GalyleoSideBar = GalyleoSideBar;
      __varRecorder__$5.GalyleoPropertiesPanel = GalyleoPropertiesPanel;
      __varRecorder__$5.SideBarTabSelected = SideBarTabSelected;
      __varRecorder__$5.GalyleoBorderPopup = GalyleoBorderPopup;
      __varRecorder__$5.GalyleoDynamicProperty = GalyleoDynamicProperty;
      __varRecorder__$5.GalyleoResizingSimulator = GalyleoResizingSimulator;
      __varRecorder__$5.ControlPanel = ControlPanel;

      var __varRecorder__$4 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/ui.cp.js", __contextModule__);

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/ui.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GalyleoEnvObject") && typeof __lively_classholder__.GalyleoEnvObject === "function" ? __lively_classholder__.GalyleoEnvObject : __lively_classholder__.GalyleoEnvObject = function GalyleoEnvObject(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "galyleoServer",
          get: function get() {
            return this._galyleoServer ? this._galyleoServer : null;
          }
        }, {
          key: "galyleoServer",
          set: function set(url) {
            this._galyleoServer = url;
          }
        }, {
          key: "dashboardStoreServer",
          get: function get() {
            if (this.galyleoServer) {
              return this.galyleoServer;
            }

            if (this._dashboardStoreServer) {
              return this._dashboardStoreServer;
            }

            return dashboardStoreServer;
          }
        }, {
          key: "dashboardStoreServer",
          set: function set(url) {
            this._dashboardStoreServer = url;
          }
        }, {
          key: "tableServer",
          get: function get() {
            if (this.galyleoServer) {
              return this.galyleoServer;
            }

            if (this._tableServer) {
              return this._tableServer;
            }

            return tableServer;
          }
        }, {
          key: "tableServer",
          set: function set(url) {
            this._tableServer = url;
          }
        }, {
          key: "user",
          get: function get() {
            return this._user;
          }
        }, {
          key: "user",
          set: function set(name) {
            this._user = name;
          }
        }, {
          key: "debug",
          get: function get() {
            return this._debug;
          }
        }, {
          key: "debug",
          set: function set(true_false) {
            this._debug = false;
          }
        }, {
          key: Symbol["for"]("lively-instance-initialize"),
          value: function GalyleoEnvObject_initialize_() {
            var urlString = window.location.search;
            var urlParams = new URLSearchParams(urlString);
            this._galyleoServer = urlParams.has("galyleo_server") ? urlParams.get("galyleo_server") : null;
            this._user = urlParams.has("user") ? urlParams.get("user") : null;
            this._debug = urlParams.has("debug") ? urlParams.get("debug") != "false" : false;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GalyleoEnvObject";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/ui.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 722,
          end: 2028
        });
      })(undefined);

      __varRecorder__$4.GALYLEO_ENV = new __varRecorder__$4.GalyleoEnvObject();
      var GalyleoStudioWorld = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/ui.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GalyleoStudioWorld") && typeof __lively_classholder__.GalyleoStudioWorld === "function" ? __lively_classholder__.GalyleoStudioWorld : __lively_classholder__.GalyleoStudioWorld = function GalyleoStudioWorld(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "__loading_html__",
          get: function get() {
            return "\n      <style>\n        ".concat(this.loadingScreen.cssDeclaration, "\n      </style>\n      ").concat(this.loadingScreen.html, "\n    ");
          }
        }, {
          key: "withTopBarDo",
          value: function GalyleoStudioWorld_withTopBarDo_(cb) {
            var dashboard = this.getSubmorphNamed("dashboard");

            if (dashboard) {
              var topBar = dashboard.get("top bar");
              cb(topBar);
            }
          }
        }, {
          key: "serverURL",
          get: function get() {
            if (this._serverURLFromStart) {
              return this._serverURLFromStart;
            }

            return studioServer;
          }
        }, {
          key: "commands",
          get: function get() {
            var _this = this;

            return [{
              name: "galyleo save",
              exec: function exec() {
                return _this.requestSave();
              }
            }].concat(_toConsumableArray(initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "commands", this)));
          }
        }, {
          key: "keybindings",
          get: function get() {
            if (lively.FreezerRuntime) {
              return [{
                command: "galyleo save",
                keys: {
                  mac: "Meta-S",
                  win: "Ctrl-S"
                }
              }];
            } else {
              return initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "keybindings", this);
            }
          }
        }, {
          key: "requestSave",
          value: function GalyleoStudioWorld_requestSave_() {
            this.getSubmorphNamed("galyleo dashboard studio").requestSave();
            return true;
          }
        }, {
          key: "onContextMenu",
          value: function GalyleoStudioWorld_onContextMenu_(evt) {
            var _this2 = this;

            evt.stop();
            evt.targetMorphs.forEach(function (m) {
              return m !== _this2 && m.onContextMenu(evt);
            });
          }
        }, {
          key: "__head_html__",
          get: function get() {
            return "\n<script> window.SERVER_URL=\"".concat(this.serverURL, "\" </script>\n<script type=\"text/javascript\" src=\"https://www.gstatic.com/charts/loader.js\"></script>\n<link type=\"text/css\" rel=\"stylesheet\" id=\"lively-font-awesome\" href=\"/lively.morphic/assets/font-awesome/css/font-awesome.css\">\n<link type=\"text/css\" rel=\"stylesheet\" id=\"lively-font-inconsolata\" href=\"/lively.morphic/assets/inconsolata/inconsolata.css\">\n<style type=\"text/css\" id=\"WorldLandingPage_7068CDA9_749E_4EC1_9BC4_50DF06EAA2BA-Nunito\">@import url(\"https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i&display=swap\");</style>");
          }
        }, {
          key: "onLoad",
          value: function GalyleoStudioWorld_onLoad_() {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onLoad", this).call(this);

            __varRecorder__$4.GALYLEO_ENV = new __varRecorder__$4.GalyleoEnvObject();
            var parameters = new URLSearchParams(document.location.search);
            var serverURL = parameters.get("serverURL");

            if (serverURL) {
              this._serverURLFromStart = serverURL;
            }

            var storeServer = parameters.get("dashboardStoreServer");

            if (storeServer) {
              dashboardStoreServer.url = storeServer;
            }

            this.opacity = 1;
          }
        }, {
          key: "defaultMenuItems",
          value: function GalyleoStudioWorld_defaultMenuItems_(morph, evt) {
            var halo = evt && evt.targetMorph.ownerChain().find(function (m) {
              return m.isHalo;
            });

            if (halo && halo.activeItems.includes("*")) {
              return initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "defaultMenuItems", this).call(this, morph, evt);
            }

            if (morph.owner !== this.getSubmorphNamed("dashboard")) {
              return [];
            }

            return [["Bring to front", function () {
              return morph.bringToFront();
            }], ["Send to back", function () {
              return morph.owner.addMorphBack(morph);
            }]];
          }
        }, {
          key: "keepHalo",
          value: function GalyleoStudioWorld_keepHalo_(evt) {
            var pos = evt.positionIn(this);
            var insideDashboard = this.getSubmorphNamed("dashboard").fullContainsWorldPoint(pos);
            var insideSideBar = this.getSubmorphNamed("side bar").fullContainsWorldPoint(pos);
            var inColorPicker = this.getSubmorphsByStyleClassName("ColorPicker").find(function (cp) {
              return cp.fullContainsWorldPoint(pos);
            });
            return !insideDashboard || insideSideBar || inColorPicker;
          }
        }, {
          key: "getHaloMask",
          value: function GalyleoStudioWorld_getHaloMask_() {
            var dashboard = this.getSubmorphNamed("dashboard");
            var sideBar = this.getSubmorphNamed("side bar");
            return dashboard.globalBounds().withWidth(this.width - (sideBar.viewModel.isToggled ? sideBar.width : 0));
          }
        }, {
          key: "showHaloFor",
          value: function GalyleoStudioWorld_showHaloFor_(target) {
            var pointerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.firstHand && this.firstHand.pointerId;
            var focus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            var dashboard = this.getSubmorphNamed("dashboard");

            if (target.owner !== dashboard) {
              return initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "showHaloFor", this).call(this, target, pointerId, focus);
            }

            var halo = new Halo({
              pointerId: pointerId,
              target: target,
              maskBounds: this.getHaloMask()
            });
            var submorphsToDrop = ["grab", "copy", "inspect", "edit", "component", "responsive"];
            halo.submorphs.forEach(function (sm) {
              if (submorphsToDrop.indexOf(sm.name) >= 0) {
                sm.remove();
              }
            });
            this.addMorph(halo);
            if (focus) halo.focus();
            halo.alignWithTarget();
            return halo;
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GalyleoStudioWorld";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              loadingScreen: {}
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/ui.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 2080,
          end: 6352
        });
      }({
        referencedAs: "LivelyWorld",
        value: LivelyWorld
      });
      __varRecorder__$4.GalyleoStudioWorld = GalyleoStudioWorld;
      __varRecorder__$4.GalyleoStudioWorld = GalyleoStudioWorld;

      var Galyleo = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/ui.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("Galyleo") && typeof __lively_classholder__.Galyleo === "function" ? __lively_classholder__.Galyleo : __lively_classholder__.Galyleo = function Galyleo(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "commands",
          get: function get() {
            var _this3 = this;

            return [{
              name: "resize on client",
              exec: function exec() {
                _this3.relayout();
              }
            }];
          }
        }, {
          key: "clearFocus",
          value: function Galyleo_clearFocus_() {
            if (this.world().focusedMorph === this.ui.dashboard) {
              this.models.sideBar.ui.styleControl.clearFocus();
            }
          }
        }, {
          key: "requestSave",
          value: function Galyleo_requestSave_() {
            var dashboardFilePath = this.dashboardFilePath;
            window.parent.postMessage({
              method: "galyleo:requestSave",
              dashboardFilePath: dashboardFilePath
            }, "*");
          }
        }, {
          key: "viewDidLoad",
          value: function Galyleo_viewDidLoad_() {
            if (this.inJupyterLab) {
              this._initMessageListeners();

              this.view.addKeyBindings([{
                command: "save",
                keys: {
                  mac: "Meta-S",
                  win: "Ctrl-S"
                }
              }]);
            }

            this.relayout();
            this._messages = [];
            this.ui.topBar.stylingPalette = this.ui.sideBar;
            this.ui.topBar.attachToTarget(this.ui.dashboard);
            this.models.sideBar.init(this.ui.dashboard);
            this.models.dashboard.init(this.ui.sideBar);
            var tableServer = __varRecorder__$4.GALYLEO_ENV.tableServer;

            if (tableServer) {
              this.models.dashboard.loadTablesFromServer(tableServer);
            }

            this.focusStealer = this.view.addMorph({
              opacity: 0,
              type: "text"
            });
            this.focusStealer.stealFocus = true;
          }
        }, {
          key: "resizeDashboard",
          value: function Galyleo_resizeDashboard_() {
            this.ui.dashboard.extent = pt(this.ui.sideBar.left, this.view.height - this.ui.topBar.bottom);
            this.ui.dashboard.top = this.ui.topBar.bottom;
          }
        }, {
          key: "reportBug",
          value: function () {
            var _Galyleo_reportBug_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var reportMorph, li;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      reportMorph = part(this.bugReporterComponent);
                      li = open("loading reporting form...");
                      _context.next = 4;
                      return li.whenRendered();

                    case 4:
                      reportMorph.init(this.user, this.dashboardFilePath);
                      reportMorph.openInWorld();
                      li.remove();

                    case 7:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function Galyleo_reportBug_() {
              return _Galyleo_reportBug_.apply(this, arguments);
            }

            return Galyleo_reportBug_;
          }()
        }, {
          key: "publishDashboard",
          value: function () {
            var _Galyleo_publishDashboard_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
              var publishMorph, li;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      publishMorph = part(this.publishPromptComponent);
                      publishMorph.name = "Publish Window";
                      li = open("loading publishing form...");
                      _context2.next = 5;
                      return li.whenRendered();

                    case 5:
                      publishMorph.init(this.user, this.dashboardFilePath, this.models.dashboard);
                      publishMorph.openInWorld();
                      li.remove();

                    case 8:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function Galyleo_publishDashboard_() {
              return _Galyleo_publishDashboard_.apply(this, arguments);
            }

            return Galyleo_publishDashboard_;
          }()
        }, {
          key: "getHelpMenu",
          value: function Galyleo_getHelpMenu_() {
            var _this4 = this;

            return [["Create new Galyleo Dashboard", function () {
              window.parent.postMessage({
                method: "galyleo:newDashboard"
              }, "*");
            }], ["Open Example Dashboard", [["Presidential Election", function () {
              window.parent.postMessage({
                method: "galyleo:openExample",
                name: "Presidential Election"
              }, "*");
            }], ["Senate Election", function () {
              window.parent.postMessage({
                method: "galyleo:openExample",
                name: "Senate Election"
              }, "*");
            }], ["Florence Nightingale", function () {
              window.parent.postMessage({
                method: "galyleo:openExample",
                name: "Florence Nightingale"
              }, "*");
            }], ["UFO Sightings", function () {
              window.parent.postMessage({
                method: "galyleo:openExample",
                name: "UFO Sightings"
              }, "*");
            }]]], ["Galyleo Reference", function () {
              window.parent.postMessage({
                method: "galyleo:openReference"
              }, "*");
            }], {
              isDivider: true
            }, ["Report Bug", function () {
              return _this4.reportBug();
            }], {
              isDivider: true
            }, ["Galyleo Studio Version: ".concat(this.version), function () {}]];
          }
        }, {
          key: "_initMessageListeners",
          value: function Galyleo__initMessageListeners_() {
            var _this5 = this;

            var handlers = {
              "galyleo:fixLabels": function () {
                var _galyleoFixLabels = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                  return regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                }));

                function galyleoFixLabels() {
                  return _galyleoFixLabels.apply(this, arguments);
                }

                return galyleoFixLabels;
              }(),
              "galyleo:loadTable": function galyleoLoadTable(data) {
                if (data.table && data.table.name && data.table.table) {
                  var matched = true;

                  if (data.table.dashboard) {
                    var currentPath = _this5.dashboardFilePath;
                    var recipientDashboard = data.table.dashboard;

                    var filePart = function filePart(pathName) {
                      var parts = pathName.split("/");
                      return parts[parts.length - 1];
                    };

                    var namePart = function namePart(fileName) {
                      var parts = fileName.split(".");
                      var result = parts.filter(function (part) {
                        return part.length > 0;
                      });
                      return result && result.length > 0 ? result[0] : null;
                    };

                    var nonNull = function nonNull(filePath) {
                      return filePath && filePath.length > 0;
                    };

                    if (nonNull(currentPath) && nonNull(recipientDashboard)) {
                      var thisFileKernel = namePart(filePart(currentPath));
                      var requestedFileKernel = namePart(filePart(recipientDashboard));

                      if (nonNull(thisFileKernel) && nonNull(requestedFileKernel)) {
                        matched = thisFileKernel === requestedFileKernel;
                      }
                    }
                  }

                  if (matched) {
                    _this5.ui.dashboard.addTable(data.table);
                  }
                }
              },
              "galyleo:load": function () {
                var _galyleoLoad = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(data) {
                  var loadScreen;
                  return regeneratorRuntime.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          _this5.lastData = data;
                          _context4.next = 3;
                          return _this5.ui.dashboard.restoreFromSavedForm(data.savedForm);

                        case 3:
                          _context4.next = 5;
                          return _this5.view.whenRendered();

                        case 5:
                          loadScreen = document.getElementById("loading-screen");

                          if (loadScreen) {
                            loadScreen.remove();
                          }

                          _this5.relayout();

                        case 8:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                }));

                function galyleoLoad(_x) {
                  return _galyleoLoad.apply(this, arguments);
                }

                return galyleoLoad;
              }(),
              "galyleo:save": function galyleoSave(data) {
                var dashboard = _this5.ui.dashboard;

                if (data.path) {
                  _this5.dashboardFilePath = data.path;
                }

                var dashboardFilePath = _this5.dashboardFilePath;
                var jsonForm = dashboard.prepareSerialization();
                dashboard.clearSnapshots();
                window.parent.postMessage({
                  method: "galyleo:writeFile",
                  jsonForm: jsonForm,
                  dashboardFilePath: dashboardFilePath
                }, "*");
                window.parent.postMessage({
                  method: "galyleo:setDirty",
                  dirty: false,
                  dashboardFilePath: dashboardFilePath
                }, "*");
              },
              "galyleo:rename": function galyleoRename(data) {
                if (data.path) {
                  _this5.dashboardFilePath = data.path;
                }
              },
              "galyleo:undo": function galyleoUndo(data) {
                var dashboardFilePath = _this5.dashboardFilePath;
                var dashboard = _this5.ui.dashboard;
                dashboard.execCommand("undo");
                window.parent.postMessage({
                  method: "galyleo:setDirty",
                  dirty: dashboard.isDirty(),
                  dashboardFilePath: dashboardFilePath
                }, "*");
              },
              "galyleo:redo": function galyleoRedo(data) {
                var dashboardFilePath = _this5.dashboardFilePath;
                var dashboard = _this5.ui.dashboard;
                dashboard.execCommand("redo");
                window.parent.postMessage({
                  method: "galyleo:setDirty",
                  dirty: dashboard.isDirty(),
                  dashboardFilePath: dashboardFilePath
                }, "*");
              }
            };
            window.addEventListener("message", function (evt) {
              if (!_this5._messages_) {
                _this5._messages_ = [];
              }

              _this5._messages_.push(evt.data);

              handlers[evt.data.method](evt.data);
            });
            window.parent.postMessage({
              method: "galyleo:ready",
              dashboardFilePath: this.dashboardFilePath
            }, "*");
          }
        }, {
          key: "toggleJupyterFrame",
          value: function Galyleo_toggleJupyterFrame_(active) {
            var _this$ui = this.ui,
                resizer = _this$ui.resizer,
                notebook = _this$ui.notebook;

            if (active) {
              if (notebook.visible) return;
              resizer.visible = true;
              resizer.movedHorizontallyBy(800);
              notebook.visible = true;
            } else {
              if (!notebook.visible) return;
              resizer.visible = false;
              resizer.movedHorizontallyBy(-resizer.left);
              notebook.visible = false;
            }
          }
        }, {
          key: "onHoverOut",
          value: function Galyleo_onHoverOut_(evt) {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onHoverOut", this).call(this, evt);

            if (!this.innerBounds().insetBy(5).containsPoint(evt.positionIn(this))) {
              this.focusStealer.focus();
            }
          }
        }, {
          key: "relayout",
          value: function Galyleo_relayout_() {
            var _this$ui2 = this.ui,
                sideBar = _this$ui2.sideBar,
                topBar = _this$ui2.topBar,
                view = this.view;

            if (view.respondsToVisibleWindow) {
              view.extent = this.world().visibleBounds().extent();
            }

            sideBar.height = view.height;
            topBar.width = view.width;
          }
        }, {
          key: "halos",
          value: function Galyleo_halos_() {
            var _this6 = this;

            return this.world().halos().filter(function (h) {
              return h.target.ownerChain().includes(_this6.view);
            });
          }
        }, {
          key: "withTopBarDo",
          value: function () {
            var _Galyleo_withTopBarDo_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(cb) {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.next = 2;
                      return cb(this.ui.topBar);

                    case 2:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function Galyleo_withTopBarDo_(_x2) {
              return _Galyleo_withTopBarDo_.apply(this, arguments);
            }

            return Galyleo_withTopBarDo_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "Galyleo";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              focusStealer: {},
              _titleBar: {},
              _undoButton: {},
              _redoButton: {},
              _saveButton: {},
              _topBarNetworkIndicator: {},
              bugReporterComponent: {
                get: function get() {
                  return this.getProperty("bugReporterComponent") || BugReporter;
                }
              },
              publishPromptComponent: {
                get: function get() {
                  return this.getProperty("publishPromptComponent") || Publisher;
                }
              },
              dashboardFilePath: {
                serialize: false,
                initialize: function initialize() {
                  this.dashboardFilePath = resource(document.location).query().dashboard_file;
                }
              },
              session: {
                get: function get() {
                  return resource(document.location).query().session;
                }
              },
              inJupyterLab: {
                get: function get() {
                  return !!resource(document.location).query().inJupyterLab;
                }
              },
              user: {
                get: function get() {
                  return resource(document.location).query().user;
                }
              },
              version: {
                get: function get() {
                  return "0.0.1";
                },
                readOnly: true
              },
              expose: {
                get: function get() {
                  return ["halos", "withTopBarDo", "relayout", "requestSave", "clearFocus"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    signal: "extent",
                    handler: "relayout"
                  }, {
                    target: "side bar",
                    signal: "position",
                    handler: "resizeDashboard"
                  }, {
                    target: "dashboard",
                    signal: "onHaloRemoved",
                    handler: "clearFocus"
                  }, {
                    target: "top bar",
                    signal: "initiate bug report",
                    handler: "reportBug"
                  }, {
                    target: "top bar",
                    signal: "initiate publication",
                    handler: "publishDashboard"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/ui.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 6369,
          end: 16793
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$4.GalyleoDashboardStudio = component["for"](function () {
        return component({
          name: "galyleo dashboard studio",
          defaultViewModel: __varRecorder__$4.Galyleo,
          extent: pt(800, 800),
          fill: Color$1.darkGray,
          clipMode: "hidden",
          submorphs: [part(GalyleoTopBar, {
            name: "top bar"
          }), {
            defaultViewModel: Dashboard,
            name: "dashboard",
            extent: pt(715.4, 788.5),
            position: pt(0.9, 48.8),
            clipMode: "auto"
          }, part(GalyleoSideBar, {
            name: "side bar",
            position: pt(651.9, 0),
            height: 800,
            viewModel: {
              isHaloItem: false
            }
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/ui.cp.js",
        "export": "GalyleoDashboardStudio",
        range: {
          start: 16846,
          end: 17404
        }
      }, System, __varRecorder__$4, "GalyleoDashboardStudio");
      var GalyleoDashboardStudio = __varRecorder__$4.GalyleoDashboardStudio;
      var GALYLEO_ENV = __varRecorder__$4.GALYLEO_ENV;
      __varRecorder__$4.GalyleoDashboardStudio = GalyleoDashboardStudio;
      __varRecorder__$4.GALYLEO_ENV = GALYLEO_ENV;
      __varRecorder__$4["default"] = Galyleo;

      var __varRecorder__$3 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/helpers.cp.js", __contextModule__);
      var BugReporterModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/helpers.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("BugReporterModel") && typeof __lively_classholder__.BugReporterModel === "function" ? __lively_classholder__.BugReporterModel : __lively_classholder__.BugReporterModel = function BugReporterModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "init",
          value: function BugReporterModel_init_(userName, filePath) {
            this._initInputField_("userNameInput", userName);

            this._initInputField_("fileInput", filePath);
          }
        }, {
          key: "_initInputField_",
          value: function BugReporterModel__initInputField__(inputFieldName, value) {
            if (value && value.length > 0) {
              this.ui[inputFieldName].textString = value;
            }
          }
        }, {
          key: "reportBug",
          value: function BugReporterModel_reportBug_() {
            var _this$ui = this.ui,
                userNameInput = _this$ui.userNameInput,
                fileInput = _this$ui.fileInput,
                messageInput = _this$ui.message;
            var user = userNameInput.textString;
            var filePath = fileInput.textString;
            var message = messageInput.textString;

            if (message.length === 0) {
              messageInput.show();
            } else {
              var body = {
                user: user.length > 0 ? user : "No user name entered",
                file_path: filePath.length > 0 ? user : "No file path  entered",
                message: message
              };
              var r = resource(this.url, {
                headers: {
                  "Content-Type": "application/json"
                }
              });
              r.contentType = "application/json";
              r.useProxy = true;
              r.post(JSON.stringify(body));
              this.close();
            }
          }
        }, {
          key: "url",
          get: function get() {
            return "https://galyleo-tickets.uw.r.appspot.com/ticket";
          }
        }, {
          key: "close",
          value: function BugReporterModel_close_() {
            this.view.remove();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "BugReporterModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["init"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "fire",
                    handler: "close"
                  }, {
                    target: "report button",
                    signal: "fire",
                    handler: "reportBug"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/helpers.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 1354,
          end: 3788
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$3.BugReporterModel = BugReporterModel;
      __varRecorder__$3.BugReporterModel = BugReporterModel;
      __varRecorder__$3.BugReporter = component["for"](function () {
        return component(GalyleoWindow, {
          defaultViewModel: __varRecorder__$3.BugReporterModel,
          extent: pt(415, 459.2),
          submorphs: [{
            name: "window title",
            textString: "Report a Bug"
          }, add({
            name: "contents wrapper",
            layout: new TilingLayout({
              axis: "column",
              axisAlign: "center",
              orderByIndex: true,
              padding: rect(15, 15, 0, 0),
              resizePolicies: [["header", {
                height: "fixed",
                width: "fill"
              }], ["user name input", {
                height: "fixed",
                width: "fill"
              }], ["file input", {
                height: "fixed",
                width: "fill"
              }], ["message", {
                height: "fill",
                width: "fill"
              }], ["footer", {
                height: "fixed",
                width: "fill"
              }]],
              spacing: 13,
              wrapSubmorphs: false
            }),
            borderColor: Color$1.rgb(127, 140, 141),
            borderRadius: 10,
            extent: pt(414.3, 428.3),
            fill: Color$1.rgba(215, 219, 221, 0),
            submorphs: [{
              name: "header",
              layout: new TilingLayout({
                align: "right",
                orderByIndex: true,
                wrapSubmorphs: false
              }),
              fill: Color$1.transparent,
              submorphs: [part(MenuBarButton, {
                name: "close button",
                extent: pt(100, 35),
                tooltip: "Close this dialog without loading",
                submorphs: [{
                  name: "label",
                  textAndAttributes: ["CLOSE", null]
                }, {
                  name: "icon",
                  extent: pt(14, 14),
                  imageUrl: projectAsset("engageLively--galyleo-dashboard__close-button-icon-2.svg")
                }]
              })]
            }, part(GalyleoSearch, {
              name: "user name input",
              placeholder: "User name",
              submorphs: [{
                name: "placeholder",
                extent: pt(90, 28.8),
                textAndAttributes: ["User name", null]
              }]
            }), part(GalyleoSearch, {
              name: "file input",
              placeholder: "Dashboard file",
              submorphs: [{
                name: "placeholder",
                extent: pt(114, 28.8),
                textAndAttributes: ["Dashboard file", null]
              }]
            }), {
              type: Label,
              name: "message label",
              fontColor: Color$1.rgb(89, 89, 89),
              fontWeight: 700,
              fontSize: 15,
              textString: "Message"
            }, {
              type: Text,
              name: "message",
              clipMode: "auto",
              fill: Color$1.rgb(190, 190, 190),
              borderRadius: 20,
              fontSize: 18,
              lineWrapping: true,
              fontFamily: galyleoFont,
              padding: rect(10, 10, 0, 0),
              extent: pt(318, 58.4),
              fixedWidth: true,
              fixedHeight: true,
              readOnly: false
            }, {
              name: "footer",
              layout: new TilingLayout({
                align: "right",
                orderByIndex: true,
                wrapSubmorphs: false
              }),
              fill: Color$1.transparent,
              submorphs: [part(PromptButton, {
                name: "report button",
                extent: pt(106.5, 30.9),
                submorphs: [without("icon"), {
                  name: "label",
                  textAndAttributes: ["Report", null]
                }]
              })]
            }]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/helpers.cp.js",
        "export": "BugReporter",
        range: {
          start: 3831,
          end: 7055
        }
      }, System, __varRecorder__$3, "BugReporter");

      (function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/helpers.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("URLDisplayModel") && typeof __lively_classholder__.URLDisplayModel === "function" ? __lively_classholder__.URLDisplayModel : __lively_classholder__.URLDisplayModel = function URLDisplayModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "_setURL",
          value: function URLDisplayModel__setURL_(htmlMorph, prefixString, url) {
            htmlMorph.html = "\n    <div style=\"display: flex;\n            align-items: center;\n            justify-content: center;\n            height: 100%;\n            background: rgb(215,219,221)\">\n     <p style=\"font: bold 10pt Arial\">".concat(prefixString, " <a href=").concat(url, " target=_blank>").concat(url, "</a></p></div>");
          }
        }, {
          key: "init",
          value: function URLDisplayModel_init_(dashboardURL) {
            var dashboardStoreServer = GALYLEO_ENV.dashboardStoreServer;
            var viewJSONString = "".concat(dashboardStoreServer, "/view_dashboard_as_json?dashboard=").concat(dashboardURL.dashboard);

            this._setURL(this.ui.dashboardUrl, "The Dashboard is published at:", viewJSONString);

            var viewString = "".concat(dashboardStoreServer, "/view_dashboard?dashboard=").concat(dashboardURL.dashboard);

            this._setURL(this.ui.dashboardViewUrl, "The Dashboard can be viewed  at:", viewString);
          }
        }, {
          key: "close",
          value: function URLDisplayModel_close_() {
            this.view.remove();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "URLDisplayModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["init"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "fire",
                    handler: "close"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/helpers.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 7058,
          end: 8442
        });
      })({
        referencedAs: "ViewModel",
        value: ViewModel
      });

      __varRecorder__$3.URLDisplay = component["for"](function () {
        return component(GalyleoWindow, {
          defaultViewModel: __varRecorder__$3.URLDisplayModel,
          name: "Dashboard URLs",
          extent: pt(415, 318),
          submorphs: [{
            name: "window title",
            textString: "Dashboard URLs"
          }, add({
            name: "contents wrapper",
            layout: new TilingLayout({
              axis: "column",
              axisAlign: "center",
              orderByIndex: true,
              padding: rect(15, 15, 0, 0),
              resizePolicies: [["header", {
                height: "fixed",
                width: "fill"
              }], ["dashboard url", {
                height: "fixed",
                width: "fill"
              }], ["dashboard view url", {
                height: "fixed",
                width: "fill"
              }], ["footer", {
                height: "fixed",
                width: "fill"
              }]],
              spacing: 13,
              wrapSubmorphs: false
            }),
            borderColor: Color$1.rgb(127, 140, 141),
            borderRadius: 10,
            extent: pt(414.3, 328.3),
            fill: Color$1.rgba(215, 219, 221, 0),
            submorphs: [{
              name: "header",
              layout: new TilingLayout({
                align: "right",
                orderByIndex: true,
                wrapSubmorphs: false
              }),
              fill: Color$1.transparent,
              submorphs: [part(MenuBarButton, {
                name: "close button",
                extent: pt(100, 35),
                tooltip: "Close this dialog",
                submorphs: [{
                  name: "label",
                  textAndAttributes: ["CLOSE", null]
                }, {
                  name: "icon",
                  extent: pt(14, 14),
                  imageUrl: projectAsset("engageLively--galyleo-dashboard__close-button-icon-2.svg")
                }]
              })]
            }, {
              type: HTMLMorph,
              name: "dashboard url",
              extent: pt(400, 60)
            }, {
              type: HTMLMorph,
              name: "dashboard view url",
              extent: pt(400, 120)
            }, {
              name: "footer",
              fill: Color$1.transparent
            }]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/helpers.cp.js",
        "export": "URLDisplay",
        range: {
          start: 8558,
          end: 10441
        }
      }, System, __varRecorder__$3, "URLDisplay");
      var PublisherModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/helpers.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("PublisherModel") && typeof __lively_classholder__.PublisherModel === "function" ? __lively_classholder__.PublisherModel : __lively_classholder__.PublisherModel = function PublisherModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "_getFilename",
          value: function PublisherModel__getFilename_(path) {
            if (path && path.length > 0) {
              var elements = path.split("/");
              var nonEmpty = elements.filter(function (elt) {
                return elt.length > 0;
              });

              var last = function last(list) {
                return list[list.length - 1];
              };

              return nonEmpty.length > 0 ? last(nonEmpty) : "";
            } else {
              return "";
            }
          }
        }, {
          key: "init",
          value: function PublisherModel_init_(userName, filePath, dashboard) {
            var _this = this;

            var fileName = this._getFilename(filePath);

            if (fileName && fileName.length > 0) {
              this.ui.fileInput.textString = fileName;
            }

            var dashboardStoreServer = GALYLEO_ENV.dashboardStoreServer;
            var listDashboards = dashboardStoreServer.endsWith("/") ? "list_dashboards" : "/list_dashboards";
            var urlQuery = dashboardStoreServer + listDashboards;

            if (userName) {
              this.userName = userName;
            }

            var reader = resource(urlQuery);
            reader.readJson().then(function (result) {
              _this.currentDashboards = result;
              _this.ui.dashboardList.items = result;
            });
            this.dashboard = dashboard;
          }
        }, {
          key: "_showError",
          value: function PublisherModel__showError_(errorString) {
            var _this2 = this;

            this.ui.errorMessage.textString = errorString;
            setTimeout(function (_) {
              return _this2.ui.errorMessage.textString = "";
            }, 5000);
            return false;
          }
        }, {
          key: "_sanityCheck",
          value: function () {
            var _PublisherModel__sanityCheck_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(dashboardName) {
              var fileRegex;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (!(dashboardName.length <= 0)) {
                        _context.next = 2;
                        break;
                      }

                      return _context.abrupt("return", this._showError("dashboard name must not be empty"));

                    case 2:
                      if (dashboardName.endsWith(".gd.json")) {
                        _context.next = 4;
                        break;
                      }

                      return _context.abrupt("return", this._showError("dashboard name must end with .gd.json, not ".concat(dashboardName)));

                    case 4:
                      fileRegex = /^[^\\/:\*\?"<>\|]+$/;

                      if (fileRegex.test(dashboardName)) {
                        _context.next = 7;
                        break;
                      }

                      return _context.abrupt("return", this._showError("dashboard name ".concat(dashboardName, " cannot contain \"\\/<>?:")));

                    case 7:
                      if (!(this.currentDashboards.indexOf(dashboardName) >= 0)) {
                        _context.next = 11;
                        break;
                      }

                      _context.next = 10;
                      return $world.confirm("Action will overwrite ".concat(dashboardName, ".  OK?"));

                    case 10:
                      return _context.abrupt("return", _context.sent);

                    case 11:
                      return _context.abrupt("return", true);

                    case 12:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function PublisherModel__sanityCheck_(_x) {
              return _PublisherModel__sanityCheck_.apply(this, arguments);
            }

            return PublisherModel__sanityCheck_;
          }()
        }, {
          key: "_getDashboard",
          value: function PublisherModel__getDashboard_() {}
        }, {
          key: "publishDashboard",
          value: function () {
            var _PublisherModel_publishDashboard_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
              var fileInput, filePath, dashboardStoreServer, publish, r, body, response, responseObject, urlDisplay;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      fileInput = this.ui.fileInput;
                      filePath = fileInput.textString;

                      if (!this.dashboard) {
                        $world.inform("No Dashboard Present!");
                        this.close();
                      }

                      _context2.next = 5;
                      return this._sanityCheck(filePath);

                    case 5:
                      if (!_context2.sent) {
                        _context2.next = 21;
                        break;
                      }

                      dashboardStoreServer = GALYLEO_ENV.dashboardStoreServer;
                      publish = dashboardStoreServer.endsWith("/") ? "publish" : "/publish";
                      r = resource("".concat(dashboardStoreServer).concat(publish), {
                        headers: {
                          "Content-Type": "application/json"
                        }
                      });
                      body = {
                        name: filePath,
                        dashboard: this.dashboard.prepareSerialization()
                      };

                      if (this.userName) {
                        body.user = this.userName;
                      }

                      r.contentType = "application/json";
                      r.useCors = true;
                      _context2.next = 15;
                      return r.post(body);

                    case 15:
                      response = _context2.sent;
                      responseObject = _typeof(response) == "object" ? response : {
                        dashboard: response
                      };
                      urlDisplay = part(__varRecorder__$3.URLDisplay);
                      urlDisplay.init(responseObject);
                      urlDisplay.openInWorld();
                      this.close();

                    case 21:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function PublisherModel_publishDashboard_() {
              return _PublisherModel_publishDashboard_.apply(this, arguments);
            }

            return PublisherModel_publishDashboard_;
          }()
        }, {
          key: "close",
          value: function PublisherModel_close_() {
            this.view.remove();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "PublisherModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["init"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "fire",
                    handler: "close"
                  }, {
                    target: "report button",
                    signal: "fire",
                    handler: "publishDashboard"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/helpers.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 10648,
          end: 14950
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$3.PublisherModel = PublisherModel;
      __varRecorder__$3.PublisherModel = PublisherModel;
      __varRecorder__$3.Publisher = component["for"](function () {
        return component(GalyleoWindow, {
          defaultViewModel: __varRecorder__$3.PublisherModel,
          extent: pt(415, 360),
          name: "Galyleo Publisher",
          submorphs: [{
            name: "window title",
            textString: "Publish A Dashboard"
          }, add({
            name: "contents wrapper",
            layout: new TilingLayout({
              axis: "column",
              axisAlign: "center",
              orderByIndex: true,
              padding: rect(15, 15, 0, 0),
              resizePolicies: [["header", {
                height: "fixed",
                width: "fill"
              }], ["dashboard list", {
                height: "fixed",
                width: "fill"
              }], ["dashboard label", {
                height: "fixed",
                width: "fill"
              }], ["file input", {
                height: "fixed",
                width: "fill"
              }], ["error message", {
                height: "fixed",
                width: "fill"
              }], ["footer", {
                height: "fixed",
                width: "fill"
              }]],
              spacing: 13,
              wrapSubmorphs: false
            }),
            borderColor: Color$1.rgb(127, 140, 141),
            borderRadius: 10,
            extent: pt(414.3, 328.3),
            fill: Color$1.rgba(215, 219, 221, 0),
            submorphs: [{
              name: "header",
              layout: new TilingLayout({
                align: "right",
                orderByIndex: true,
                wrapSubmorphs: false
              }),
              fill: Color$1.transparent,
              submorphs: [part(MenuBarButton, {
                name: "close button",
                extent: pt(100, 35),
                tooltip: "Close this dialog without publishing",
                submorphs: [{
                  name: "label",
                  textAndAttributes: ["CLOSE", null]
                }, {
                  name: "icon",
                  extent: pt(14, 14),
                  imageUrl: projectAsset("engageLively--galyleo-dashboard__close-button-icon-2.svg")
                }]
              })]
            }, part(DefaultList, {
              name: "dashboard list"
            }), {
              type: Label,
              name: "error message",
              fontColor: Color$1.rgb(255, 89, 89),
              fontWeight: 700,
              fontSize: 15,
              textString: ""
            }, part(GalyleoSearch, {
              name: "file input",
              placeholder: "Dashboard file",
              submorphs: [{
                name: "placeholder",
                extent: pt(114, 28.8),
                textAndAttributes: ["Dashboard file", null]
              }]
            }), {
              type: Label,
              name: "dashboard label",
              fontColor: Color$1.rgb(89, 89, 89),
              fontWeight: 700,
              fontSize: 15,
              textString: "Published Dashboards"
            }, {
              name: "footer",
              layout: new TilingLayout({
                align: "right",
                orderByIndex: true,
                wrapSubmorphs: false
              }),
              fill: Color$1.transparent,
              submorphs: [part(PromptButton, {
                name: "report button",
                extent: pt(106.5, 30.9),
                submorphs: [without("icon"), {
                  name: "label",
                  textAndAttributes: ["Publish", null]
                }]
              })]
            }]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/helpers.cp.js",
        "export": "Publisher",
        range: {
          start: 14991,
          end: 17969
        }
      }, System, __varRecorder__$3, "Publisher");
      var TableViewMorph = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/helpers.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("TableViewMorph") && typeof __lively_classholder__.TableViewMorph === "function" ? __lively_classholder__.TableViewMorph : __lively_classholder__.TableViewMorph = function TableViewMorph(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "init",
          value: function TableViewMorph_init_(tableName, table) {
            var columnHeaders = table.columns.map(function (column) {
              return "<th>".concat(column.name, "</th>");
            });
            var caption = "<caption>".concat(tableName, "</caption>");
            var header = "<tr>".concat(columnHeaders.join(""), "</tr>");

            if (table.rows) {
              var numRows = Math.min(table.rows.length, 10);
              var values = table.rows.slice(0, numRows);

              var valueRow = function valueRow(row) {
                return row.map(function (val) {
                  return "<td>".concat(val, "</td>");
                }).join("");
              };

              var valueRows = values.map(function (row) {
                return "<tr>".concat(valueRow(row), "</tr>");
              }).join("\n");
              this.html = "<table>\n".concat(caption, "\n").concat(header, "\n").concat(valueRows, "\n</table>");
            } else {
              this.html = "<table>\n".concat(caption, "\n").concat(header, "\n</table>");
            }
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "TableViewMorph";
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/helpers.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 18197,
          end: 19020
        });
      }({
        referencedAs: "HTMLMorph",
        value: HTMLMorph
      });
      __varRecorder__$3.TableViewMorph = TableViewMorph;
      __varRecorder__$3.TableViewMorph = TableViewMorph;
      var TableViewModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/helpers.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("TableViewModel") && typeof __lively_classholder__.TableViewModel === "function" ? __lively_classholder__.TableViewModel : __lively_classholder__.TableViewModel = function TableViewModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "init",
          value: function TableViewModel_init_(tableName, table) {
            this.ui.tableViewer.init(tableName, table);
            this.ui.windowTitle.textString = "Galyleo Table ".concat(tableName);
          }
        }, {
          key: "close",
          value: function TableViewModel_close_() {
            this.view.remove();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "TableViewModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["init"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "fire",
                    handler: "close"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/helpers.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 19203,
          end: 19968
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$3.TableViewModel = TableViewModel;
      __varRecorder__$3.TableViewModel = TableViewModel;
      __varRecorder__$3.TableViewer = component["for"](function () {
        return component(GalyleoWindow, {
          defaultViewModel: __varRecorder__$3.TableViewModel,
          extent: pt(415, 360),
          name: "Galyleo Table Viewer",
          submorphs: [{
            name: "windowTitle",
            textString: "Galyleo Table"
          }, add({
            name: "contents wrapper",
            layout: new TilingLayout({
              axis: "column",
              axisAlign: "center",
              orderByIndex: true,
              padding: rect(5, 5, 0, 0),
              resizePolicies: [["header", {
                height: "fixed",
                width: "fill"
              }], ["tableViewer", {
                height: "fixed",
                width: "fill"
              }]],
              spacing: 5,
              wrapSubmorphs: false
            }),
            borderColor: Color$1.rgb(127, 140, 141),
            borderRadius: 10,
            extent: pt(414.3, 328.3),
            fill: Color$1.rgba(215, 219, 221, 0),
            submorphs: [{
              name: "header",
              layout: new TilingLayout({
                align: "right",
                orderByIndex: true,
                wrapSubmorphs: false
              }),
              fill: Color$1.transparent,
              submorphs: [part(MenuBarButton, {
                name: "close button",
                extent: pt(100, 35),
                tooltip: "Close this dialog without loading",
                submorphs: [{
                  name: "label",
                  textAndAttributes: ["CLOSE", null]
                }, {
                  name: "icon",
                  extent: pt(14, 14),
                  imageUrl: projectAsset("engageLively--galyleo-dashboard__close-button-icon-2.svg")
                }]
              })]
            }, {
              type: __varRecorder__$3.TableViewMorph,
              name: "tableViewer"
            }]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/helpers.cp.js",
        "export": "TableViewer",
        range: {
          start: 20018,
          end: 21560
        }
      }, System, __varRecorder__$3, "TableViewer");
      var TableViewer = __varRecorder__$3.TableViewer;
      __varRecorder__$3.TableViewer = TableViewer;

      __varRecorder__$3._checkUrl = function (url) {
        if (typeof url != "string") {
          return {
            action: "failed",
            resultString: null
          };
        }

        var tmp;

        try {
          tmp = new _URL(url);
          return {
            action: "ok",
            resultString: tmp.toString()
          };
        } catch (error) {}

        try {
          tmp = new _URL("https://".concat(url));
          return {
            action: "rewritten",
            resultString: tmp.toString()
          };
        } catch (error) {
          return {
            action: "failed",
            resultString: null
          };
        }
      };

      var TableLoaderModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/helpers.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("TableLoaderModel") && typeof __lively_classholder__.TableLoaderModel === "function" ? __lively_classholder__.TableLoaderModel : __lively_classholder__.TableLoaderModel = function TableLoaderModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "close",
          value: function TableLoaderModel_close_() {
            this.view.remove();
          }
        }, {
          key: "init",
          value: function TableLoaderModel_init_(dashboard) {
            this.dashboard = dashboard;
          }
        }, {
          key: "viewDidLoad",
          value: function TableLoaderModel_viewDidLoad_() {
            var _this3 = this;

            this.ui.loadToggle.state = false;
            var tableServer = GALYLEO_ENV.tableServer;
            var tableSource = resource("".concat(tableServer, "/get_table_names"));
            tableSource.readJson().then(function (tableList) {
              tableList.forEach(function (tableName) {
                _this3.ui.tableList.addItem(tableName);
              });
            });
          }
        }, {
          key: "updateSelectedTable",
          value: function TableLoaderModel_updateSelectedTable_(selection) {
            this.ui.url.textString = "".concat(GALYLEO_ENV.tableServer).concat(selection);
            this.ui.table.textString = "".concat(selection);
          }
        }, {
          key: "loadURL",
          value: function () {
            var _TableLoaderModel_loadURL_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
              var url, table, checkResult, doLoad, r, result, tableSpec;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      url = this.ui.url;

                      if (!(url.input.length === 0)) {
                        _context3.next = 4;
                        break;
                      }

                      url.indicateError("Please enter url to Galyleo Data Server");
                      return _context3.abrupt("return");

                    case 4:
                      table = this.ui.table;

                      if (!(table.input.length === 0)) {
                        _context3.next = 8;
                        break;
                      }

                      table.indicateError("Please enter the table name");
                      return _context3.abrupt("return");

                    case 8:
                      checkResult = __varRecorder__$3._checkUrl(url.textString);

                      if (!(checkResult.action === "failed")) {
                        _context3.next = 12;
                        break;
                      }

                      url.indicateError("".concat(url.textString, " is not a valid URL"));
                      return _context3.abrupt("return");

                    case 12:
                      doLoad = this.ui.loadToggle.state;
                      r = resource(checkResult.resultString);
                      _context3.prev = 14;
                      _context3.next = 17;
                      return r.readJson();

                    case 17:
                      result = _context3.sent;

                      if (result.schema) {
                        tableSpec = {
                          columns: result.schema
                        };

                        if (result.rows && doLoad) {
                          tableSpec.rows = result.rows.map(function (row) {
                            return convertSDMLRow(row, result.schema);
                          });
                        } else {
                          tableSpec.connector = {
                            url: GALYLEO_ENV.tableServer
                          };
                        }

                        this.dashboard.addTable({
                          name: table.textString,
                          table: tableSpec
                        });
                        this.view.remove();
                      } else {
                        this.dashboard.confirm("No table found at ".concat(checkResult.resultString));
                      }

                      _context3.next = 24;
                      break;

                    case 21:
                      _context3.prev = 21;
                      _context3.t0 = _context3["catch"](14);
                      this.dashboard.confirm(_context3.t0);

                    case 24:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this, [[14, 21]]);
            }));

            function TableLoaderModel_loadURL_() {
              return _TableLoaderModel_loadURL_.apply(this, arguments);
            }

            return TableLoaderModel_loadURL_;
          }()
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "TableLoaderModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              bindings: {
                get: function get() {
                  return [{
                    target: "close button",
                    signal: "onMouseDown",
                    handler: "close"
                  }, {
                    target: "load button",
                    signal: "onMouseDown",
                    handler: "loadURL"
                  }, {
                    target: "table list",
                    signal: "selection",
                    handler: "updateSelectedTable"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/helpers.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 22910,
          end: 26391
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$3.TableLoaderModel = TableLoaderModel;
      __varRecorder__$3.TableLoaderModel = TableLoaderModel;
      __varRecorder__$3.CloseButton = component["for"](function () {
        return component(MenuBarButton, {
          name: "close button",
          extent: pt(90, 35),
          layout: new TilingLayout({
            align: "right",
            axisAlign: "center",
            justifySubmorphs: "spaced",
            orderByIndex: true,
            padding: rect(5, 0, 0, 0)
          }),
          submorphs: [{
            name: "label",
            textAndAttributes: ["CLOSE", null]
          }, {
            name: "icon",
            extent: pt(14, 18),
            imageUrl: projectAsset("engageLively--galyleo-dashboard__close-button-icon-2.svg")
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/helpers.cp.js",
        "export": "CloseButton",
        range: {
          start: 26434,
          end: 26900
        }
      }, System, __varRecorder__$3, "CloseButton");
      __varRecorder__$3.DataLoader = component["for"](function () {
        return component(GalyleoWindow, {
          defaultViewModel: __varRecorder__$3.TableLoaderModel,
          name: "data loader",
          extent: pt(340.5, 400),
          submorphs: [{
            name: "window title",
            textString: "Load Data"
          }, add({
            name: "table loader",
            borderColor: Color$1.rgb(127, 140, 141),
            borderRadius: 10,
            extent: pt(311, 360),
            fill: Color$1.rgba(215, 219, 221, 0),
            submorphs: [part(MenuBarButton, {
              name: "close button",
              extent: pt(100, 35),
              position: pt(230, 5),
              tooltip: "Close this dialog without loading",
              submorphs: [{
                name: "label",
                textAndAttributes: ["CLOSE", null]
              }, {
                name: "icon",
                extent: pt(14, 14),
                imageUrl: projectAsset("engageLively--galyleo-dashboard__close-button-icon-2.svg")
              }]
            }), part(DefaultList, {
              name: "table list",
              position: pt(15, 45),
              extent: pt(311, 135),
              fill: Color$1.rgba(215, 219, 221, 0),
              borderWidth: 1
            }), part(GalyleoSearch, {
              name: "url",
              placeholder: "Enter URL to datasource",
              position: pt(15, 190)
            }), part(GalyleoSearch, {
              name: "table",
              placeholder: "Enter name of table",
              position: pt(15, 230)
            }), {
              name: "update_panel",
              borderColor: Color$1.rgb(127, 140, 141),
              borderRadius: 10,
              extent: pt(311, 50),
              position: pt(15, 270),
              fill: Color$1.rgba(215, 219, 221, 0),
              layout: new TilingLayout({
                align: "top",
                axis: "row",
                autoResize: true,
                direction: "leftToRight",
                orderByIndex: true,
                resizeSubmorphs: false,
                spacing: 10
              }),
              submorphs: [{
                type: Label,
                name: "label",
                fontColor: Color$1.rgb(0, 0, 0),
                fontFamily: "IBM Plex Sans",
                fontSize: 14,
                fontWeight: "bold",
                position: pt(13.5, 11.5),
                reactsToPointer: false,
                textAndAttributes: ["Cache rows if available", null]
              }, add(part(Toggle, {
                name: "loadToggle"
              }))]
            }, part(PromptButton, {
              name: "load button",
              extent: pt(106.5, 30.9),
              position: pt(228, 315),
              submorphs: [without("icon"), {
                name: "label",
                textAndAttributes: ["Load table", null]
              }]
            })]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/helpers.cp.js",
        "export": "DataLoader",
        range: {
          start: 26943,
          end: 29871
        }
      }, System, __varRecorder__$3, "DataLoader");
      var LoadURLDialogModel = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/studio/helpers.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("LoadURLDialogModel") && typeof __lively_classholder__.LoadURLDialogModel === "function" ? __lively_classholder__.LoadURLDialogModel : __lively_classholder__.LoadURLDialogModel = function LoadURLDialogModel(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "init",
          value: function LoadURLDialogModel_init_(dashboard, path) {
            this.dashboard = dashboard;
            this.originalPath = path;

            if (path && path.length > 0 && this.ui && this.ui.urlInput) {
              this.ui.urlInput.textString = path;
            }
          }
        }, {
          key: "viewDidLoad",
          value: function LoadURLDialogModel_viewDidLoad_() {
            if (this.originalPath) {
              this.ui.urlInput.textString = this.originalPath;
            }
          }
        }, {
          key: "loadURL",
          value: function () {
            var _LoadURLDialogModel_loadURL_ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
              var url;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      url = this.ui.urlInput.textString;
                      _context4.next = 3;
                      return this.dashboard.loadDashboardFromURL(url);

                    case 3:
                      if (!_context4.sent) {
                        _context4.next = 5;
                        break;
                      }

                      this.view.remove();

                    case 5:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function LoadURLDialogModel_loadURL_() {
              return _LoadURLDialogModel_loadURL_.apply(this, arguments);
            }

            return LoadURLDialogModel_loadURL_;
          }()
        }, {
          key: "cancelLoad",
          value: function LoadURLDialogModel_cancelLoad_() {
            this.view.remove();
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "LoadURLDialogModel";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              expose: {
                get: function get() {
                  return ["init"];
                }
              },
              bindings: {
                get: function get() {
                  return [{
                    target: "cancel button",
                    signal: "fire",
                    handler: "cancelLoad"
                  }, {
                    target: "load button",
                    signal: "fire",
                    handler: "loadURL"
                  }];
                }
              }
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./studio/helpers.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 29881,
          end: 31216
        });
      }({
        referencedAs: "ViewModel",
        value: ViewModel
      });
      __varRecorder__$3.LoadURLDialogModel = LoadURLDialogModel;
      __varRecorder__$3.LoadURLDialogModel = LoadURLDialogModel;
      __varRecorder__$3.LoadFromURLDialog = component["for"](function () {
        return component(GalyleoWindow, {
          defaultViewModel: __varRecorder__$3.LoadURLDialogModel,
          name: "load dialog",
          layout: new TilingLayout({
            axis: "column",
            axisAlign: "center",
            orderByIndex: true,
            resizePolicies: [["window title", {
              height: "fixed",
              width: "fill"
            }]],
            spacing: 15,
            wrapSubmorphs: false
          }),
          extent: pt(340.5, 155.8),
          submorphs: [{
            name: "window title",
            textString: "Load Dashboard from..."
          }, add(part(GalyleoSearch, {
            name: "urlInput",
            placeholder: "url/to/dashboard"
          })), add({
            name: "button wrapper",
            layout: new TilingLayout({
              align: "center",
              axisAlign: "center",
              justifySubmorphs: "spaced",
              orderByIndex: true,
              padding: rect(26, 26, 0, 0)
            }),
            borderColor: Color$1.rgb(23, 160, 251),
            borderWidth: 0,
            extent: pt(310.9, 57.7),
            fill: Color$1.rgba(0, 0, 0, 0),
            submorphs: [part(PromptButton, {
              name: "load button",
              extent: pt(81.7, 31.8),
              master: PromptButton,
              position: pt(9.6, 8.9),
              submorphs: [without("icon"), {
                name: "label",
                textAndAttributes: ["Load", null]
              }]
            }), part(PromptButton, {
              name: "cancel button",
              extent: pt(92.8, 34.2),
              master: PromptButton,
              position: pt(174.2, 44.5),
              submorphs: [without("icon"), {
                name: "label",
                textAndAttributes: ["Cancel", null]
              }]
            })]
          })]
        });
      }, {
        module: "engageLively--galyleo-dashboard/studio/helpers.cp.js",
        "export": "LoadFromURLDialog",
        range: {
          start: 31267,
          end: 32781
        }
      }, System, __varRecorder__$3, "LoadFromURLDialog");
      var DataLoader = __varRecorder__$3.DataLoader;
      var CloseButton = __varRecorder__$3.CloseButton;
      var BugReporter = __varRecorder__$3.BugReporter;
      var Publisher = __varRecorder__$3.Publisher;
      var LoadFromURLDialog = __varRecorder__$3.LoadFromURLDialog;
      __varRecorder__$3.DataLoader = DataLoader;
      __varRecorder__$3.CloseButton = CloseButton;
      __varRecorder__$3.BugReporter = BugReporter;
      __varRecorder__$3.Publisher = Publisher;
      __varRecorder__$3.LoadFromURLDialog = LoadFromURLDialog;

      var __varRecorder__$2 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/publication/dashboard.js", __contextModule__);

      var PublishedDashboard = /*#__PURE__*/function (_DashboardCommon) {
        _inherits(PublishedDashboard, _DashboardCommon);

        var _super = _createSuper(PublishedDashboard);

        function PublishedDashboard() {
          _classCallCheck(this, PublishedDashboard);

          return _super.apply(this, arguments);
        }

        _createClass(PublishedDashboard, [{
          key: "relayout",
          value: function relayout() {
            this.ui.galyleoLogo.bottomRight = this.view.innerBounds().insetBy(25).bottomRight();
            this.ui.galyleoLogo.bringToFront();
          }
        }, {
          key: "clear",
          value: function clear() {
            var logo = this.ui.galyleoLogo;

            _get(_getPrototypeOf(PublishedDashboard.prototype), "clear", this).call(this);

            if (logo) {
              this.view.addMorph(logo);
            }
          }
        }, {
          key: "_initURLPrompt_",
          value: function _initURLPrompt_(url, message) {
            if (message) {
              $world.inform(message);
            }

            var loadDialog = part(LoadFromURLDialog);
            loadDialog.openInWorld();
            loadDialog.init(this, url);
          }
        }, {
          key: "restoreFromJSONForm",
          value: function () {
            var _restoreFromJSONForm = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(storedForm) {
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return this._restoreFromSaved_(JSON.parse(storedForm));

                    case 2:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function restoreFromJSONForm(_x) {
              return _restoreFromJSONForm.apply(this, arguments);
            }

            return restoreFromJSONForm;
          }()
        }, {
          key: "_restoreFromSaved",
          value: function () {
            var _restoreFromSaved2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
              var storedForm,
                  _args2 = arguments;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      storedForm = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : this.storedForm;
                      _context2.next = 3;
                      return _get(_getPrototypeOf(PublishedDashboard.prototype), "_restoreFromSaved", this).call(this, storedForm);

                    case 3:
                      this._repositionAfterRestore_();

                      _context2.next = 6;
                      return this.drawAllCharts();

                    case 6:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function _restoreFromSaved() {
              return _restoreFromSaved2.apply(this, arguments);
            }

            return _restoreFromSaved;
          }()
        }, {
          key: "_repositionAfterRestore_",
          value: function _repositionAfterRestore_() {
            var _this = this;

            this.logo = this.ui.galyleoLogo;

            if (!this.logo) {
              return;
            }

            var logoRequirement = this.logo.height + 10;
            var morphs = this.view.submorphs.filter(function (m) {
              return m != _this.logo;
            });
            var morphsWidth = morphs.reduce(function (acc, morph) {
              return Math.max(acc, morph.bounds().right());
            }, 0);
            var morphsHeight = morphs.reduce(function (acc, morph) {
              return Math.max(acc, morph.bounds().bottom());
            }, 0);
            var morphsRequirement = pt(morphsWidth, morphsHeight).addPt(pt(0, logoRequirement));
            this.view.extent = pt(Math.max(morphsRequirement.x, window.innerWidth), Math.max(morphsRequirement.y, window.innerHeight));
          }
        }, {
          key: "viewDidLoad",
          value: function viewDidLoad() {
            this.init();
          }
        }, {
          key: "_getDashboardName",
          value: function _getDashboardName(dashboardURL) {
            if (dashboardURL.length == 0) {
              return "";
            }

            var elements = dashboardURL.split("/");
            var nonEmpty = elements.filter(function (elt) {
              return elt.length > 0;
            });

            if (nonEmpty.length == 0) {
              return "";
            }

            var dashboardName = nonEmpty[nonEmpty.length - 1];

            if (dashboardName.endsWith(".gd.json")) {
              return dashboardName.substring(0, dashboardName.length - 8);
            }

            if (dashboardName.endsWith(".json")) {
              return dashboardName.substring(0, dashboardName.length - 5);
            }

            return dashboardName;
          }
        }, {
          key: "init",
          value: function () {
            var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
              var parameters, url, valid, name;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return _get(_getPrototypeOf(PublishedDashboard.prototype), "init", this).call(this);

                    case 2:
                      parameters = new URLSearchParams(document.location.search);
                      url = parameters.get("dashboard");

                      if (!url) {
                        _context3.next = 13;
                        break;
                      }

                      _context3.next = 7;
                      return this.loadDashboardFromURL(url);

                    case 7:
                      valid = _context3.sent;

                      if (!valid) {
                        this._initURLPrompt_(url);
                      }

                      name = this._getDashboardName(url);

                      if (name.length > 0) {
                        document.title = name;
                      }

                      _context3.next = 14;
                      break;

                    case 13:
                      this._initURLPrompt_(null);

                    case 14:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function init() {
              return _init.apply(this, arguments);
            }

            return init;
          }()
        }, {
          key: "commands",
          get: function get() {
            var _this2 = this;

            return [{
              name: "resize on client",
              exec: function exec() {
                _this2.view.extent = pt(window.innerWidth, window.innerHeight);
                _this2.view.position = pt(0, 0);
              }
            }];
          }
        }], [{
          key: "properties",
          get: function get() {
            return {
              bindings: {
                get: function get() {
                  return [{
                    signal: "extent",
                    handler: "relayout"
                  }];
                }
              },
              expose: {
                get: function get() {
                  return ["relayout", "init", "commands"];
                }
              }
            };
          }
        }]);

        return PublishedDashboard;
      }(DashboardCommon);
      __varRecorder__$2.PublishedDashboard = PublishedDashboard;
      __varRecorder__$2["default"] = PublishedDashboard;

      var __varRecorder__$1 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/publication/ui.cp.js", __contextModule__);
      var GalyleoDashboardWorld = function (superclass) {
        var __lively_classholder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/publication/ui.cp.js", __contextModule__);

        var __lively_class__ = __lively_classholder__.hasOwnProperty("GalyleoDashboardWorld") && typeof __lively_classholder__.GalyleoDashboardWorld === "function" ? __lively_classholder__.GalyleoDashboardWorld : __lively_classholder__.GalyleoDashboardWorld = function GalyleoDashboardWorld(__first_arg__) {
          if (__first_arg__ && __first_arg__[Symbol["for"]("lively-instance-restorer")]) ; else {
            return this[Symbol["for"]("lively-instance-initialize")].apply(this, arguments);
          }
        };

        if (Object.isFrozen(__lively_classholder__)) {
          return __lively_class__;
        }

        return initializeClass(__lively_class__, superclass, [{
          key: "__loading_html__",
          get: function get() {
            return "\n      <style>\n        ".concat(this.loadingScreen.cssDeclaration, "\n      </style>\n      ").concat(this.loadingScreen.html, "\n    ");
          }
        }, {
          key: "serverURL",
          get: function get() {
            return "https://matt.engagelively.com";
          }
        }, {
          key: "__head_html__",
          get: function get() {
            return "\n<script> window.SERVER_URL=\"".concat(this.serverURL, "\" </script>");
          }
        }, {
          key: "onLoad",
          value: function GalyleoDashboardWorld_onLoad_() {
            initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onLoad", this).call(this);
          }
        }], [{
          key: Symbol["for"]("__LivelyClassName__"),
          get: function get() {
            return "GalyleoDashboardWorld";
          }
        }, {
          key: "properties",
          get: function get() {
            return {
              loadingScreen: {}
            };
          }
        }], __lively_classholder__, {
          pathInPackage: function pathInPackage() {
            return "./publication/ui.cp.js";
          },
          unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
            return function () {};
          },
          subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
            return function () {};
          },
          "package": function _package() {
            return {
              name: "engageLively--galyleo-dashboard",
              version: "0.2.0"
            };
          }
        }, {
          start: 309,
          end: 867
        });
      }({
        referencedAs: "LivelyWorld",
        value: LivelyWorld
      });
      __varRecorder__$1.GalyleoDashboardWorld = GalyleoDashboardWorld;
      __varRecorder__$1.GalyleoDashboardWorld = GalyleoDashboardWorld;
      __varRecorder__$1.GalyleoDashboardPublication = component["for"](function () {
        return component({
          name: "galyleo dashboard",
          defaultViewModel: PublishedDashboard,
          extent: pt(800, 800),
          fill: Color$1.darkGray,
          clipMode: "hidden",
          submorphs: [{
            position: pt(255, 84),
            extent: pt(255, 84),
            name: "galyleo-logo",
            submorphs: [{
              type: "text",
              position: pt(7, 33),
              fontFamily: galyleoFont,
              fontSize: 16,
              textString: "powered By",
              extent: pt(80, 19)
            }, {
              type: "image",
              imageUrl: "https://repository-images.githubusercontent.com/359242321/7b12b200-b586-11eb-9cb5-397325021b06",
              extent: pt(700, 320),
              scale: 0.22,
              position: pt(94, 7),
              name: "logo"
            }]
          }]
        });
      }, {
        module: "engageLively--galyleo-dashboard/publication/ui.cp.js",
        "export": "GalyleoDashboardPublication",
        range: {
          start: 927,
          end: 1533
        }
      }, System, __varRecorder__$1, "GalyleoDashboardPublication");
      var GalyleoDashboardPublication = exports('GalyleoDashboardPublication', __varRecorder__$1.GalyleoDashboardPublication);
      __varRecorder__$1.GalyleoDashboardPublication = GalyleoDashboardPublication;

      var __varRecorder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("engageLively--galyleo-dashboard/publication/int/en/index.js", __contextModule__);
      __varRecorder__.GalyleoDashboardPublication = GalyleoDashboardPublication;

    })
  };
}));
