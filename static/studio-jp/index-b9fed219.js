System.register(['./__rootModule___commonjs-entry-183fbc6c.js'], (function (exports) {
  var __contextModule__ = typeof module !== 'undefined' ? module : arguments[1];
;
  var _createClass, _classCallCheck, _inherits, _createSuper, _get, _getPrototypeOf, Path, dissoc, _typeof, _createForOfIteratorHelper, clone, pushIfNotIncluded, withoutAll, extend, without, newUUID, filter, last, _toConsumableArray, compact, _toArray, _slicedToArray, between, pluck, wrap, uniqBy, _defineProperty, clone$1, remove, printTree, print, peekLeft, inspect, chain, sortBy, equals, merge, pushAll, startsWith, removeAt, lines;
  return {
    setters: [function (module) {
      _createClass = module.g;
      _classCallCheck = module.f;
      _inherits = module.d;
      _createSuper = module.e;
      _get = module.bG;
      _getPrototypeOf = module.bH;
      Path = module.bw;
      dissoc = module.y;
      _typeof = module.a5;
      _createForOfIteratorHelper = module.a6;
      clone = module.dq;
      pushIfNotIncluded = module.bP;
      withoutAll = module.x;
      extend = module.dr;
      without = module.aQ;
      newUUID = module.cl;
      filter = module.d6;
      last = module.q;
      _toConsumableArray = module.r;
      compact = module.aT;
      _toArray = module.ds;
      _slicedToArray = module.o;
      between = module.aN;
      pluck = module.c9;
      wrap = module.c2;
      uniqBy = module.ae;
      _defineProperty = module.ah;
      clone$1 = module.dt;
      remove = module.w;
      printTree = module.bW;
      print = module.c3;
      peekLeft = module.du;
      inspect = module.aA;
      chain = module.cv;
      sortBy = module.aP;
      equals = module.dv;
      merge = module.bR;
      pushAll = module.dw;
      startsWith = module.dx;
      removeAt = module.dy;
      lines = module.a$;
    }],
    execute: (function () {

      exports({
        M: findNodeAfter,
        W: recursive
      });

      var __varRecorder__$e = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/generated/estree-visitor.js", __contextModule__);

      var Visitor = exports('V', /*#__PURE__*/function () {
        function Visitor() {
          _classCallCheck(this, Visitor);
        }

        _createClass(Visitor, [{
          key: "accept",
          value: function accept(node, state, path) {
            if (!node) throw new Error("Undefined AST node in Visitor.accept:\n  " + path.join(".") + "\n  " + node);
            if (!node.type) throw new Error("Strangee AST node without type in Visitor.accept:\n  " + path.join(".") + "\n  " + JSON.stringify(node));

            switch (node.type) {
              case "Node":
                return this.visitNode(node, state, path);

              case "SourceLocation":
                return this.visitSourceLocation(node, state, path);

              case "Position":
                return this.visitPosition(node, state, path);

              case "Program":
                return this.visitProgram(node, state, path);

              case "Function":
                return this.visitFunction(node, state, path);

              case "Statement":
                return this.visitStatement(node, state, path);

              case "SwitchCase":
                return this.visitSwitchCase(node, state, path);

              case "CatchClause":
                return this.visitCatchClause(node, state, path);

              case "VariableDeclarator":
                return this.visitVariableDeclarator(node, state, path);

              case "Expression":
                return this.visitExpression(node, state, path);

              case "Property":
                return this.visitProperty(node, state, path);

              case "Pattern":
                return this.visitPattern(node, state, path);

              case "Super":
                return this.visitSuper(node, state, path);

              case "SpreadElement":
                return this.visitSpreadElement(node, state, path);

              case "TemplateElement":
                return this.visitTemplateElement(node, state, path);

              case "Class":
                return this.visitClass(node, state, path);

              case "ClassBody":
                return this.visitClassBody(node, state, path);

              case "MethodDefinition":
                return this.visitMethodDefinition(node, state, path);

              case "ModuleDeclaration":
                return this.visitModuleDeclaration(node, state, path);

              case "ModuleSpecifier":
                return this.visitModuleSpecifier(node, state, path);

              case "JSXEmptyExpression":
                return this.visitJSXEmptyExpression(node, state, path);

              case "JSXExpressionContainer":
                return this.visitJSXExpressionContainer(node, state, path);

              case "JSXSpreadChild":
                return this.visitJSXSpreadChild(node, state, path);

              case "JSXBoundaryElement":
                return this.visitJSXBoundaryElement(node, state, path);

              case "JSXAttribute":
                return this.visitJSXAttribute(node, state, path);

              case "JSXText":
                return this.visitJSXText(node, state, path);

              case "JSXOpeningFragment":
                return this.visitJSXOpeningFragment(node, state, path);

              case "JSXClosingFragment":
                return this.visitJSXClosingFragment(node, state, path);

              case "ChainElement":
                return this.visitChainElement(node, state, path);

              case "PropertyDefinition":
                return this.visitPropertyDefinition(node, state, path);

              case "PrivateIdentifier":
                return this.visitPrivateIdentifier(node, state, path);

              case "Decorator":
                return this.visitDecorator(node, state, path);

              case "AccessorProperty":
                return this.visitAccessorProperty(node, state, path);

              case "Identifier":
                return this.visitIdentifier(node, state, path);

              case "Literal":
                return this.visitLiteral(node, state, path);

              case "ExpressionStatement":
                return this.visitExpressionStatement(node, state, path);

              case "BlockStatement":
                return this.visitBlockStatement(node, state, path);

              case "EmptyStatement":
                return this.visitEmptyStatement(node, state, path);

              case "DebuggerStatement":
                return this.visitDebuggerStatement(node, state, path);

              case "WithStatement":
                return this.visitWithStatement(node, state, path);

              case "ReturnStatement":
                return this.visitReturnStatement(node, state, path);

              case "LabeledStatement":
                return this.visitLabeledStatement(node, state, path);

              case "BreakStatement":
                return this.visitBreakStatement(node, state, path);

              case "ContinueStatement":
                return this.visitContinueStatement(node, state, path);

              case "IfStatement":
                return this.visitIfStatement(node, state, path);

              case "SwitchStatement":
                return this.visitSwitchStatement(node, state, path);

              case "ThrowStatement":
                return this.visitThrowStatement(node, state, path);

              case "TryStatement":
                return this.visitTryStatement(node, state, path);

              case "WhileStatement":
                return this.visitWhileStatement(node, state, path);

              case "DoWhileStatement":
                return this.visitDoWhileStatement(node, state, path);

              case "ForStatement":
                return this.visitForStatement(node, state, path);

              case "ForInStatement":
                return this.visitForInStatement(node, state, path);

              case "Declaration":
                return this.visitDeclaration(node, state, path);

              case "ThisExpression":
                return this.visitThisExpression(node, state, path);

              case "ArrayExpression":
                return this.visitArrayExpression(node, state, path);

              case "ObjectExpression":
                return this.visitObjectExpression(node, state, path);

              case "FunctionExpression":
                return this.visitFunctionExpression(node, state, path);

              case "UnaryExpression":
                return this.visitUnaryExpression(node, state, path);

              case "UpdateExpression":
                return this.visitUpdateExpression(node, state, path);

              case "BinaryExpression":
                return this.visitBinaryExpression(node, state, path);

              case "AssignmentExpression":
                return this.visitAssignmentExpression(node, state, path);

              case "LogicalExpression":
                return this.visitLogicalExpression(node, state, path);

              case "MemberExpression":
                return this.visitMemberExpression(node, state, path);

              case "ConditionalExpression":
                return this.visitConditionalExpression(node, state, path);

              case "CallExpression":
                return this.visitCallExpression(node, state, path);

              case "NewExpression":
                return this.visitNewExpression(node, state, path);

              case "SequenceExpression":
                return this.visitSequenceExpression(node, state, path);

              case "ArrowFunctionExpression":
                return this.visitArrowFunctionExpression(node, state, path);

              case "YieldExpression":
                return this.visitYieldExpression(node, state, path);

              case "TemplateLiteral":
                return this.visitTemplateLiteral(node, state, path);

              case "TaggedTemplateExpression":
                return this.visitTaggedTemplateExpression(node, state, path);

              case "AssignmentProperty":
                return this.visitAssignmentProperty(node, state, path);

              case "ObjectPattern":
                return this.visitObjectPattern(node, state, path);

              case "ArrayPattern":
                return this.visitArrayPattern(node, state, path);

              case "RestElement":
                return this.visitRestElement(node, state, path);

              case "AssignmentPattern":
                return this.visitAssignmentPattern(node, state, path);

              case "ClassExpression":
                return this.visitClassExpression(node, state, path);

              case "MetaProperty":
                return this.visitMetaProperty(node, state, path);

              case "ImportDeclaration":
                return this.visitImportDeclaration(node, state, path);

              case "ImportSpecifier":
                return this.visitImportSpecifier(node, state, path);

              case "ImportDefaultSpecifier":
                return this.visitImportDefaultSpecifier(node, state, path);

              case "ImportNamespaceSpecifier":
                return this.visitImportNamespaceSpecifier(node, state, path);

              case "ExportNamedDeclaration":
                return this.visitExportNamedDeclaration(node, state, path);

              case "ExportSpecifier":
                return this.visitExportSpecifier(node, state, path);

              case "AnonymousDefaultExportedFunctionDeclaration":
                return this.visitAnonymousDefaultExportedFunctionDeclaration(node, state, path);

              case "AnonymousDefaultExportedClassDeclaration":
                return this.visitAnonymousDefaultExportedClassDeclaration(node, state, path);

              case "ExportDefaultDeclaration":
                return this.visitExportDefaultDeclaration(node, state, path);

              case "ExportAllDeclaration":
                return this.visitExportAllDeclaration(node, state, path);

              case "AwaitExpression":
                return this.visitAwaitExpression(node, state, path);

              case "JSXMemberExpression":
                return this.visitJSXMemberExpression(node, state, path);

              case "JSXNamespacedName":
                return this.visitJSXNamespacedName(node, state, path);

              case "JSXOpeningElement":
                return this.visitJSXOpeningElement(node, state, path);

              case "JSXClosingElement":
                return this.visitJSXClosingElement(node, state, path);

              case "JSXSpreadAttribute":
                return this.visitJSXSpreadAttribute(node, state, path);

              case "JSXElement":
                return this.visitJSXElement(node, state, path);

              case "JSXFragment":
                return this.visitJSXFragment(node, state, path);

              case "ChainExpression":
                return this.visitChainExpression(node, state, path);

              case "ImportExpression":
                return this.visitImportExpression(node, state, path);

              case "RegExpLiteral":
                return this.visitRegExpLiteral(node, state, path);

              case "Directive":
                return this.visitDirective(node, state, path);

              case "FunctionBody":
                return this.visitFunctionBody(node, state, path);

              case "FunctionDeclaration":
                return this.visitFunctionDeclaration(node, state, path);

              case "VariableDeclaration":
                return this.visitVariableDeclaration(node, state, path);

              case "ForOfStatement":
                return this.visitForOfStatement(node, state, path);

              case "ClassDeclaration":
                return this.visitClassDeclaration(node, state, path);

              case "JSXIdentifier":
                return this.visitJSXIdentifier(node, state, path);

              case "BigIntLiteral":
                return this.visitBigIntLiteral(node, state, path);

              case "StaticBlock":
                return this.visitStaticBlock(node, state, path);
            }

            throw new Error("No visit function in AST visitor Visitor for:\n  " + path.join(".") + "\n  " + JSON.stringify(node));
          }
        }, {
          key: "visitNode",
          value: function visitNode(node, state, path) {
            return node;
          }
        }, {
          key: "visitSourceLocation",
          value: function visitSourceLocation(node, state, path) {
            var visitor = this;
            node.start = visitor.accept(node.start, state, path.concat(["start"]));
            node.end = visitor.accept(node.end, state, path.concat(["end"]));
            return node;
          }
        }, {
          key: "visitPosition",
          value: function visitPosition(node, state, path) {
            return node;
          }
        }, {
          key: "visitProgram",
          value: function visitProgram(node, state, path) {
            var visitor = this;
            var newElements = [];

            for (var i = 0; i < node.body.length; i++) {
              var ea = node.body[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["body", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.body = newElements;
            return node;
          }
        }, {
          key: "visitFunction",
          value: function visitFunction(node, state, path) {
            var visitor = this;

            if (node.id) {
              node.id = visitor.accept(node.id, state, path.concat(["id"]));
            }

            var newElements = [];

            for (var i = 0; i < node.params.length; i++) {
              var ea = node.params[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["params", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.params = newElements;
            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitStatement",
          value: function visitStatement(node, state, path) {
            return node;
          }
        }, {
          key: "visitSwitchCase",
          value: function visitSwitchCase(node, state, path) {
            var visitor = this;

            if (node.test) {
              node.test = visitor.accept(node.test, state, path.concat(["test"]));
            }

            var newElements = [];

            for (var i = 0; i < node.consequent.length; i++) {
              var ea = node.consequent[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["consequent", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.consequent = newElements;
            return node;
          }
        }, {
          key: "visitCatchClause",
          value: function visitCatchClause(node, state, path) {
            var visitor = this;

            if (node.param) {
              node.param = visitor.accept(node.param, state, path.concat(["param"]));
            }

            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitVariableDeclarator",
          value: function visitVariableDeclarator(node, state, path) {
            var visitor = this;
            node.id = visitor.accept(node.id, state, path.concat(["id"]));

            if (node.init) {
              node.init = visitor.accept(node.init, state, path.concat(["init"]));
            }

            return node;
          }
        }, {
          key: "visitExpression",
          value: function visitExpression(node, state, path) {
            return node;
          }
        }, {
          key: "visitProperty",
          value: function visitProperty(node, state, path) {
            var visitor = this;
            node.key = visitor.accept(node.key, state, path.concat(["key"]));
            node.value = visitor.accept(node.value, state, path.concat(["value"]));
            return node;
          }
        }, {
          key: "visitPattern",
          value: function visitPattern(node, state, path) {
            return node;
          }
        }, {
          key: "visitSuper",
          value: function visitSuper(node, state, path) {
            return node;
          }
        }, {
          key: "visitSpreadElement",
          value: function visitSpreadElement(node, state, path) {
            var visitor = this;
            node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
            return node;
          }
        }, {
          key: "visitTemplateElement",
          value: function visitTemplateElement(node, state, path) {
            return node;
          }
        }, {
          key: "visitClass",
          value: function visitClass(node, state, path) {
            var visitor = this;

            if (node.id) {
              node.id = visitor.accept(node.id, state, path.concat(["id"]));
            }

            if (node.superClass) {
              node.superClass = visitor.accept(node.superClass, state, path.concat(["superClass"]));
            }

            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            var newElements = [];

            for (var i = 0; i < node.decorators.length; i++) {
              var ea = node.decorators[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["decorators", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.decorators = newElements;
            return node;
          }
        }, {
          key: "visitClassBody",
          value: function visitClassBody(node, state, path) {
            var visitor = this;
            var newElements = [];

            for (var i = 0; i < node.body.length; i++) {
              var ea = node.body[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["body", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.body = newElements;
            return node;
          }
        }, {
          key: "visitMethodDefinition",
          value: function visitMethodDefinition(node, state, path) {
            var visitor = this;
            node.key = visitor.accept(node.key, state, path.concat(["key"]));
            node.value = visitor.accept(node.value, state, path.concat(["value"]));
            var newElements = [];

            for (var i = 0; i < node.decorators.length; i++) {
              var ea = node.decorators[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["decorators", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.decorators = newElements;
            return node;
          }
        }, {
          key: "visitModuleDeclaration",
          value: function visitModuleDeclaration(node, state, path) {
            return node;
          }
        }, {
          key: "visitModuleSpecifier",
          value: function visitModuleSpecifier(node, state, path) {
            var visitor = this;
            node.local = visitor.accept(node.local, state, path.concat(["local"]));
            return node;
          }
        }, {
          key: "visitJSXEmptyExpression",
          value: function visitJSXEmptyExpression(node, state, path) {
            return node;
          }
        }, {
          key: "visitJSXExpressionContainer",
          value: function visitJSXExpressionContainer(node, state, path) {
            var visitor = this;
            node.expression = visitor.accept(node.expression, state, path.concat(["expression"]));
            return node;
          }
        }, {
          key: "visitJSXSpreadChild",
          value: function visitJSXSpreadChild(node, state, path) {
            var visitor = this;
            node.expression = visitor.accept(node.expression, state, path.concat(["expression"]));
            return node;
          }
        }, {
          key: "visitJSXBoundaryElement",
          value: function visitJSXBoundaryElement(node, state, path) {
            var visitor = this;
            node.name = visitor.accept(node.name, state, path.concat(["name"]));
            return node;
          }
        }, {
          key: "visitJSXAttribute",
          value: function visitJSXAttribute(node, state, path) {
            var visitor = this;
            node.name = visitor.accept(node.name, state, path.concat(["name"]));

            if (node.value) {
              node.value = visitor.accept(node.value, state, path.concat(["value"]));
            }

            return node;
          }
        }, {
          key: "visitJSXText",
          value: function visitJSXText(node, state, path) {
            return node;
          }
        }, {
          key: "visitJSXOpeningFragment",
          value: function visitJSXOpeningFragment(node, state, path) {
            return node;
          }
        }, {
          key: "visitJSXClosingFragment",
          value: function visitJSXClosingFragment(node, state, path) {
            return node;
          }
        }, {
          key: "visitChainElement",
          value: function visitChainElement(node, state, path) {
            return node;
          }
        }, {
          key: "visitPropertyDefinition",
          value: function visitPropertyDefinition(node, state, path) {
            var visitor = this;
            node.key = visitor.accept(node.key, state, path.concat(["key"]));

            if (node.value) {
              node.value = visitor.accept(node.value, state, path.concat(["value"]));
            }

            var newElements = [];

            for (var i = 0; i < node.decorators.length; i++) {
              var ea = node.decorators[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["decorators", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.decorators = newElements;
            return node;
          }
        }, {
          key: "visitPrivateIdentifier",
          value: function visitPrivateIdentifier(node, state, path) {
            return node;
          }
        }, {
          key: "visitDecorator",
          value: function visitDecorator(node, state, path) {
            var visitor = this;
            node.expression = visitor.accept(node.expression, state, path.concat(["expression"]));
            return node;
          }
        }, {
          key: "visitAccessorProperty",
          value: function visitAccessorProperty(node, state, path) {
            var visitor = this;
            node.key = visitor.accept(node.key, state, path.concat(["key"]));

            if (node.value) {
              node.value = visitor.accept(node.value, state, path.concat(["value"]));
            }

            var newElements = [];

            for (var i = 0; i < node.decorators.length; i++) {
              var ea = node.decorators[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["decorators", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.decorators = newElements;
            return node;
          }
        }, {
          key: "visitIdentifier",
          value: function visitIdentifier(node, state, path) {
            return node;
          }
        }, {
          key: "visitLiteral",
          value: function visitLiteral(node, state, path) {
            return node;
          }
        }, {
          key: "visitExpressionStatement",
          value: function visitExpressionStatement(node, state, path) {
            var visitor = this;
            node.expression = visitor.accept(node.expression, state, path.concat(["expression"]));
            return node;
          }
        }, {
          key: "visitBlockStatement",
          value: function visitBlockStatement(node, state, path) {
            var visitor = this;
            var newElements = [];

            for (var i = 0; i < node.body.length; i++) {
              var ea = node.body[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["body", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.body = newElements;
            return node;
          }
        }, {
          key: "visitEmptyStatement",
          value: function visitEmptyStatement(node, state, path) {
            return node;
          }
        }, {
          key: "visitDebuggerStatement",
          value: function visitDebuggerStatement(node, state, path) {
            return node;
          }
        }, {
          key: "visitWithStatement",
          value: function visitWithStatement(node, state, path) {
            var visitor = this;
            node.object = visitor.accept(node.object, state, path.concat(["object"]));
            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitReturnStatement",
          value: function visitReturnStatement(node, state, path) {
            var visitor = this;

            if (node.argument) {
              node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
            }

            return node;
          }
        }, {
          key: "visitLabeledStatement",
          value: function visitLabeledStatement(node, state, path) {
            var visitor = this;
            node.label = visitor.accept(node.label, state, path.concat(["label"]));
            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitBreakStatement",
          value: function visitBreakStatement(node, state, path) {
            var visitor = this;

            if (node.label) {
              node.label = visitor.accept(node.label, state, path.concat(["label"]));
            }

            return node;
          }
        }, {
          key: "visitContinueStatement",
          value: function visitContinueStatement(node, state, path) {
            var visitor = this;

            if (node.label) {
              node.label = visitor.accept(node.label, state, path.concat(["label"]));
            }

            return node;
          }
        }, {
          key: "visitIfStatement",
          value: function visitIfStatement(node, state, path) {
            var visitor = this;
            node.test = visitor.accept(node.test, state, path.concat(["test"]));
            node.consequent = visitor.accept(node.consequent, state, path.concat(["consequent"]));

            if (node.alternate) {
              node.alternate = visitor.accept(node.alternate, state, path.concat(["alternate"]));
            }

            return node;
          }
        }, {
          key: "visitSwitchStatement",
          value: function visitSwitchStatement(node, state, path) {
            var visitor = this;
            node.discriminant = visitor.accept(node.discriminant, state, path.concat(["discriminant"]));
            var newElements = [];

            for (var i = 0; i < node.cases.length; i++) {
              var ea = node.cases[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["cases", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.cases = newElements;
            return node;
          }
        }, {
          key: "visitThrowStatement",
          value: function visitThrowStatement(node, state, path) {
            var visitor = this;
            node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
            return node;
          }
        }, {
          key: "visitTryStatement",
          value: function visitTryStatement(node, state, path) {
            var visitor = this;
            node.block = visitor.accept(node.block, state, path.concat(["block"]));

            if (node.handler) {
              node.handler = visitor.accept(node.handler, state, path.concat(["handler"]));
            }

            if (node.finalizer) {
              node.finalizer = visitor.accept(node.finalizer, state, path.concat(["finalizer"]));
            }

            return node;
          }
        }, {
          key: "visitWhileStatement",
          value: function visitWhileStatement(node, state, path) {
            var visitor = this;
            node.test = visitor.accept(node.test, state, path.concat(["test"]));
            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitDoWhileStatement",
          value: function visitDoWhileStatement(node, state, path) {
            var visitor = this;
            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            node.test = visitor.accept(node.test, state, path.concat(["test"]));
            return node;
          }
        }, {
          key: "visitForStatement",
          value: function visitForStatement(node, state, path) {
            var visitor = this;

            if (node.init) {
              node.init = visitor.accept(node.init, state, path.concat(["init"]));
            }

            if (node.test) {
              node.test = visitor.accept(node.test, state, path.concat(["test"]));
            }

            if (node.update) {
              node.update = visitor.accept(node.update, state, path.concat(["update"]));
            }

            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitForInStatement",
          value: function visitForInStatement(node, state, path) {
            var visitor = this;
            node.left = visitor.accept(node.left, state, path.concat(["left"]));
            node.right = visitor.accept(node.right, state, path.concat(["right"]));
            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitDeclaration",
          value: function visitDeclaration(node, state, path) {
            return node;
          }
        }, {
          key: "visitThisExpression",
          value: function visitThisExpression(node, state, path) {
            return node;
          }
        }, {
          key: "visitArrayExpression",
          value: function visitArrayExpression(node, state, path) {
            var visitor = this;

            if (node.elements) {
              var newElements = [];

              for (var i = 0; i < node.elements.length; i++) {
                var ea = node.elements[i];
                var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["elements", i])) : ea;
                if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
              }

              node.elements = newElements;
            }

            return node;
          }
        }, {
          key: "visitObjectExpression",
          value: function visitObjectExpression(node, state, path) {
            var visitor = this;
            var newElements = [];

            for (var i = 0; i < node.properties.length; i++) {
              var ea = node.properties[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["properties", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.properties = newElements;
            return node;
          }
        }, {
          key: "visitFunctionExpression",
          value: function visitFunctionExpression(node, state, path) {
            var visitor = this;

            if (node.id) {
              node.id = visitor.accept(node.id, state, path.concat(["id"]));
            }

            var newElements = [];

            for (var i = 0; i < node.params.length; i++) {
              var ea = node.params[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["params", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.params = newElements;
            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitUnaryExpression",
          value: function visitUnaryExpression(node, state, path) {
            var visitor = this;
            node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
            return node;
          }
        }, {
          key: "visitUpdateExpression",
          value: function visitUpdateExpression(node, state, path) {
            var visitor = this;
            node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
            return node;
          }
        }, {
          key: "visitBinaryExpression",
          value: function visitBinaryExpression(node, state, path) {
            var visitor = this;
            node.left = visitor.accept(node.left, state, path.concat(["left"]));
            node.right = visitor.accept(node.right, state, path.concat(["right"]));
            return node;
          }
        }, {
          key: "visitAssignmentExpression",
          value: function visitAssignmentExpression(node, state, path) {
            var visitor = this;
            node.left = visitor.accept(node.left, state, path.concat(["left"]));
            node.right = visitor.accept(node.right, state, path.concat(["right"]));
            return node;
          }
        }, {
          key: "visitLogicalExpression",
          value: function visitLogicalExpression(node, state, path) {
            var visitor = this;
            node.left = visitor.accept(node.left, state, path.concat(["left"]));
            node.right = visitor.accept(node.right, state, path.concat(["right"]));
            return node;
          }
        }, {
          key: "visitMemberExpression",
          value: function visitMemberExpression(node, state, path) {
            var visitor = this;
            node.object = visitor.accept(node.object, state, path.concat(["object"]));
            node.property = visitor.accept(node.property, state, path.concat(["property"]));
            return node;
          }
        }, {
          key: "visitConditionalExpression",
          value: function visitConditionalExpression(node, state, path) {
            var visitor = this;
            node.test = visitor.accept(node.test, state, path.concat(["test"]));
            node.alternate = visitor.accept(node.alternate, state, path.concat(["alternate"]));
            node.consequent = visitor.accept(node.consequent, state, path.concat(["consequent"]));
            return node;
          }
        }, {
          key: "visitCallExpression",
          value: function visitCallExpression(node, state, path) {
            var visitor = this;
            node.callee = visitor.accept(node.callee, state, path.concat(["callee"]));
            var newElements = [];

            for (var i = 0; i < node.arguments.length; i++) {
              var ea = node.arguments[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["arguments", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.arguments = newElements;
            return node;
          }
        }, {
          key: "visitNewExpression",
          value: function visitNewExpression(node, state, path) {
            var visitor = this;
            node.callee = visitor.accept(node.callee, state, path.concat(["callee"]));
            var newElements = [];

            for (var i = 0; i < node.arguments.length; i++) {
              var ea = node.arguments[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["arguments", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.arguments = newElements;
            return node;
          }
        }, {
          key: "visitSequenceExpression",
          value: function visitSequenceExpression(node, state, path) {
            var visitor = this;
            var newElements = [];

            for (var i = 0; i < node.expressions.length; i++) {
              var ea = node.expressions[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["expressions", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.expressions = newElements;
            return node;
          }
        }, {
          key: "visitArrowFunctionExpression",
          value: function visitArrowFunctionExpression(node, state, path) {
            var visitor = this;
            node.body = visitor.accept(node.body, state, path.concat(["body"]));

            if (node.id) {
              node.id = visitor.accept(node.id, state, path.concat(["id"]));
            }

            var newElements = [];

            for (var i = 0; i < node.params.length; i++) {
              var ea = node.params[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["params", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.params = newElements;
            return node;
          }
        }, {
          key: "visitYieldExpression",
          value: function visitYieldExpression(node, state, path) {
            var visitor = this;

            if (node.argument) {
              node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
            }

            return node;
          }
        }, {
          key: "visitTemplateLiteral",
          value: function visitTemplateLiteral(node, state, path) {
            var visitor = this;
            var newElements = [];

            for (var i = 0; i < node.quasis.length; i++) {
              var ea = node.quasis[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["quasis", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.quasis = newElements;
            newElements = [];

            for (var _i = 0; _i < node.expressions.length; _i++) {
              var _ea = node.expressions[_i];

              var _acceptedNodes = _ea ? visitor.accept(_ea, state, path.concat(["expressions", _i])) : _ea;

              if (Array.isArray(_acceptedNodes)) newElements.push.apply(newElements, _acceptedNodes);else newElements.push(_acceptedNodes);
            }

            node.expressions = newElements;
            return node;
          }
        }, {
          key: "visitTaggedTemplateExpression",
          value: function visitTaggedTemplateExpression(node, state, path) {
            var visitor = this;
            node.tag = visitor.accept(node.tag, state, path.concat(["tag"]));
            node.quasi = visitor.accept(node.quasi, state, path.concat(["quasi"]));
            return node;
          }
        }, {
          key: "visitAssignmentProperty",
          value: function visitAssignmentProperty(node, state, path) {
            var visitor = this;
            node.value = visitor.accept(node.value, state, path.concat(["value"]));
            node.key = visitor.accept(node.key, state, path.concat(["key"]));
            return node;
          }
        }, {
          key: "visitObjectPattern",
          value: function visitObjectPattern(node, state, path) {
            var visitor = this;
            var newElements = [];

            for (var i = 0; i < node.properties.length; i++) {
              var ea = node.properties[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["properties", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.properties = newElements;
            return node;
          }
        }, {
          key: "visitArrayPattern",
          value: function visitArrayPattern(node, state, path) {
            var visitor = this;

            if (node.elements) {
              var newElements = [];

              for (var i = 0; i < node.elements.length; i++) {
                var ea = node.elements[i];
                var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["elements", i])) : ea;
                if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
              }

              node.elements = newElements;
            }

            return node;
          }
        }, {
          key: "visitRestElement",
          value: function visitRestElement(node, state, path) {
            var visitor = this;
            node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
            return node;
          }
        }, {
          key: "visitAssignmentPattern",
          value: function visitAssignmentPattern(node, state, path) {
            var visitor = this;
            node.left = visitor.accept(node.left, state, path.concat(["left"]));
            node.right = visitor.accept(node.right, state, path.concat(["right"]));
            return node;
          }
        }, {
          key: "visitClassExpression",
          value: function visitClassExpression(node, state, path) {
            var visitor = this;

            if (node.id) {
              node.id = visitor.accept(node.id, state, path.concat(["id"]));
            }

            if (node.superClass) {
              node.superClass = visitor.accept(node.superClass, state, path.concat(["superClass"]));
            }

            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            var newElements = [];

            for (var i = 0; i < node.decorators.length; i++) {
              var ea = node.decorators[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["decorators", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.decorators = newElements;
            return node;
          }
        }, {
          key: "visitMetaProperty",
          value: function visitMetaProperty(node, state, path) {
            var visitor = this;
            node.meta = visitor.accept(node.meta, state, path.concat(["meta"]));
            node.property = visitor.accept(node.property, state, path.concat(["property"]));
            return node;
          }
        }, {
          key: "visitImportDeclaration",
          value: function visitImportDeclaration(node, state, path) {
            var visitor = this;
            var newElements = [];

            for (var i = 0; i < node.specifiers.length; i++) {
              var ea = node.specifiers[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["specifiers", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.specifiers = newElements;
            node.source = visitor.accept(node.source, state, path.concat(["source"]));
            return node;
          }
        }, {
          key: "visitImportSpecifier",
          value: function visitImportSpecifier(node, state, path) {
            var visitor = this;
            node.imported = visitor.accept(node.imported, state, path.concat(["imported"]));
            node.local = visitor.accept(node.local, state, path.concat(["local"]));
            return node;
          }
        }, {
          key: "visitImportDefaultSpecifier",
          value: function visitImportDefaultSpecifier(node, state, path) {
            var visitor = this;
            node.local = visitor.accept(node.local, state, path.concat(["local"]));
            return node;
          }
        }, {
          key: "visitImportNamespaceSpecifier",
          value: function visitImportNamespaceSpecifier(node, state, path) {
            var visitor = this;
            node.local = visitor.accept(node.local, state, path.concat(["local"]));
            return node;
          }
        }, {
          key: "visitExportNamedDeclaration",
          value: function visitExportNamedDeclaration(node, state, path) {
            var visitor = this;

            if (node.declaration) {
              node.declaration = visitor.accept(node.declaration, state, path.concat(["declaration"]));
            }

            var newElements = [];

            for (var i = 0; i < node.specifiers.length; i++) {
              var ea = node.specifiers[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["specifiers", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.specifiers = newElements;

            if (node.source) {
              node.source = visitor.accept(node.source, state, path.concat(["source"]));
            }

            return node;
          }
        }, {
          key: "visitExportSpecifier",
          value: function visitExportSpecifier(node, state, path) {
            var visitor = this;
            node.exported = visitor.accept(node.exported, state, path.concat(["exported"]));
            node.local = visitor.accept(node.local, state, path.concat(["local"]));
            return node;
          }
        }, {
          key: "visitAnonymousDefaultExportedFunctionDeclaration",
          value: function visitAnonymousDefaultExportedFunctionDeclaration(node, state, path) {
            var visitor = this;

            if (node.id) {
              node.id = visitor.accept(node.id, state, path.concat(["id"]));
            }

            var newElements = [];

            for (var i = 0; i < node.params.length; i++) {
              var ea = node.params[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["params", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.params = newElements;
            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitAnonymousDefaultExportedClassDeclaration",
          value: function visitAnonymousDefaultExportedClassDeclaration(node, state, path) {
            var visitor = this;

            if (node.id) {
              node.id = visitor.accept(node.id, state, path.concat(["id"]));
            }

            if (node.superClass) {
              node.superClass = visitor.accept(node.superClass, state, path.concat(["superClass"]));
            }

            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            var newElements = [];

            for (var i = 0; i < node.decorators.length; i++) {
              var ea = node.decorators[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["decorators", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.decorators = newElements;
            return node;
          }
        }, {
          key: "visitExportDefaultDeclaration",
          value: function visitExportDefaultDeclaration(node, state, path) {
            var visitor = this;
            node.declaration = visitor.accept(node.declaration, state, path.concat(["declaration"]));
            return node;
          }
        }, {
          key: "visitExportAllDeclaration",
          value: function visitExportAllDeclaration(node, state, path) {
            var visitor = this;
            node.source = visitor.accept(node.source, state, path.concat(["source"]));

            if (node.exported) {
              node.exported = visitor.accept(node.exported, state, path.concat(["exported"]));
            }

            return node;
          }
        }, {
          key: "visitAwaitExpression",
          value: function visitAwaitExpression(node, state, path) {
            var visitor = this;
            node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
            return node;
          }
        }, {
          key: "visitJSXMemberExpression",
          value: function visitJSXMemberExpression(node, state, path) {
            var visitor = this;
            node.object = visitor.accept(node.object, state, path.concat(["object"]));
            node.property = visitor.accept(node.property, state, path.concat(["property"]));
            return node;
          }
        }, {
          key: "visitJSXNamespacedName",
          value: function visitJSXNamespacedName(node, state, path) {
            var visitor = this;
            node.namespace = visitor.accept(node.namespace, state, path.concat(["namespace"]));
            node.name = visitor.accept(node.name, state, path.concat(["name"]));
            return node;
          }
        }, {
          key: "visitJSXOpeningElement",
          value: function visitJSXOpeningElement(node, state, path) {
            var visitor = this;
            var newElements = [];

            for (var i = 0; i < node.attributes.length; i++) {
              var ea = node.attributes[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["attributes", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.attributes = newElements;
            node.name = visitor.accept(node.name, state, path.concat(["name"]));
            return node;
          }
        }, {
          key: "visitJSXClosingElement",
          value: function visitJSXClosingElement(node, state, path) {
            var visitor = this;
            node.name = visitor.accept(node.name, state, path.concat(["name"]));
            return node;
          }
        }, {
          key: "visitJSXSpreadAttribute",
          value: function visitJSXSpreadAttribute(node, state, path) {
            var visitor = this;
            node.argument = visitor.accept(node.argument, state, path.concat(["argument"]));
            return node;
          }
        }, {
          key: "visitJSXElement",
          value: function visitJSXElement(node, state, path) {
            var visitor = this;
            node.openingElement = visitor.accept(node.openingElement, state, path.concat(["openingElement"]));
            var newElements = [];

            for (var i = 0; i < node.children.length; i++) {
              var ea = node.children[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["children", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.children = newElements;

            if (node.closingElement) {
              node.closingElement = visitor.accept(node.closingElement, state, path.concat(["closingElement"]));
            }

            return node;
          }
        }, {
          key: "visitJSXFragment",
          value: function visitJSXFragment(node, state, path) {
            var visitor = this;
            node.openingFragment = visitor.accept(node.openingFragment, state, path.concat(["openingFragment"]));
            var newElements = [];

            for (var i = 0; i < node.children.length; i++) {
              var ea = node.children[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["children", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.children = newElements;
            node.closingFragment = visitor.accept(node.closingFragment, state, path.concat(["closingFragment"]));
            return node;
          }
        }, {
          key: "visitChainExpression",
          value: function visitChainExpression(node, state, path) {
            var visitor = this;
            node.expression = visitor.accept(node.expression, state, path.concat(["expression"]));
            return node;
          }
        }, {
          key: "visitImportExpression",
          value: function visitImportExpression(node, state, path) {
            var visitor = this;
            node.source = visitor.accept(node.source, state, path.concat(["source"]));
            return node;
          }
        }, {
          key: "visitRegExpLiteral",
          value: function visitRegExpLiteral(node, state, path) {
            return node;
          }
        }, {
          key: "visitDirective",
          value: function visitDirective(node, state, path) {
            var visitor = this;
            node.expression = visitor.accept(node.expression, state, path.concat(["expression"]));
            return node;
          }
        }, {
          key: "visitFunctionBody",
          value: function visitFunctionBody(node, state, path) {
            var visitor = this;
            var newElements = [];

            for (var i = 0; i < node.body.length; i++) {
              var ea = node.body[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["body", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.body = newElements;
            return node;
          }
        }, {
          key: "visitFunctionDeclaration",
          value: function visitFunctionDeclaration(node, state, path) {
            var visitor = this;

            if (node.id) {
              node.id = visitor.accept(node.id, state, path.concat(["id"]));
            }

            var newElements = [];

            for (var i = 0; i < node.params.length; i++) {
              var ea = node.params[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["params", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.params = newElements;
            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitVariableDeclaration",
          value: function visitVariableDeclaration(node, state, path) {
            var visitor = this;
            var newElements = [];

            for (var i = 0; i < node.declarations.length; i++) {
              var ea = node.declarations[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["declarations", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.declarations = newElements;
            return node;
          }
        }, {
          key: "visitForOfStatement",
          value: function visitForOfStatement(node, state, path) {
            var visitor = this;
            node.left = visitor.accept(node.left, state, path.concat(["left"]));
            node.right = visitor.accept(node.right, state, path.concat(["right"]));
            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitClassDeclaration",
          value: function visitClassDeclaration(node, state, path) {
            var visitor = this;
            node.id = visitor.accept(node.id, state, path.concat(["id"]));

            if (node.superClass) {
              node.superClass = visitor.accept(node.superClass, state, path.concat(["superClass"]));
            }

            node.body = visitor.accept(node.body, state, path.concat(["body"]));
            var newElements = [];
            if (!node.decorators) debugger;

            for (var i = 0; i < node.decorators.length; i++) {
              var ea = node.decorators[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["decorators", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.decorators = newElements;
            return node;
          }
        }, {
          key: "visitJSXIdentifier",
          value: function visitJSXIdentifier(node, state, path) {
            return node;
          }
        }, {
          key: "visitBigIntLiteral",
          value: function visitBigIntLiteral(node, state, path) {
            return node;
          }
        }, {
          key: "visitStaticBlock",
          value: function visitStaticBlock(node, state, path) {
            var visitor = this;
            var newElements = [];

            for (var i = 0; i < node.body.length; i++) {
              var ea = node.body[i];
              var acceptedNodes = ea ? visitor.accept(ea, state, path.concat(["body", i])) : ea;
              if (Array.isArray(acceptedNodes)) newElements.push.apply(newElements, acceptedNodes);else newElements.push(acceptedNodes);
            }

            node.body = newElements;
            return node;
          }
        }]);

        return Visitor;
      }());

      __varRecorder__$e.Visitor = Visitor;
      __varRecorder__$e["default"] = Visitor;

      var __varRecorder__$d = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/lib/mozilla-ast-visitors.js", __contextModule__);

      var PrinterVisitor = /*#__PURE__*/function (_Visitor) {
        _inherits(PrinterVisitor, _Visitor);

        var _super = _createSuper(PrinterVisitor);

        function PrinterVisitor() {
          _classCallCheck(this, PrinterVisitor);

          return _super.apply(this, arguments);
        }

        _createClass(PrinterVisitor, [{
          key: "accept",
          value: function accept(node, state, path) {
            var pathString = path.map(function (ea) {
              return typeof ea === "string" ? ".".concat(ea) : "[".concat(ea, "]");
            }).join("");
            var myChildren = [];

            var result = _get(_getPrototypeOf(PrinterVisitor.prototype), "accept", this).call(this, node, {
              index: state.index,
              tree: myChildren
            }, path);

            state.tree.push({
              node: node,
              path: pathString,
              index: state.index++,
              children: myChildren
            });
            return result;
          }
        }]);

        return PrinterVisitor;
      }(Visitor);

      __varRecorder__$d.PrinterVisitor = PrinterVisitor;

      var ComparisonVisitor = /*#__PURE__*/function (_Visitor2) {
        _inherits(ComparisonVisitor, _Visitor2);

        var _super2 = _createSuper(ComparisonVisitor);

        function ComparisonVisitor() {
          _classCallCheck(this, ComparisonVisitor);

          return _super2.apply(this, arguments);
        }

        _createClass(ComparisonVisitor, [{
          key: "recordNotEqual",
          value: function recordNotEqual(node1, node2, state, msg) {
            state.comparisons.errors.push({
              node1: node1,
              node2: node2,
              path: state.completePath,
              msg: msg
            });
          }
        }, {
          key: "compareType",
          value: function compareType(node1, node2, state) {
            return this.compareField("type", node1, node2, state);
          }
        }, {
          key: "compareField",
          value: function compareField(field, node1, node2, state) {
            node2 = Path(state.completePath.join(".")).get(node2);
            if (node1 && node2 && node1[field] === node2[field]) return true;
            if (node1 && node1[field] === "*" || node2 && node2[field] === "*") return true;
            var fullPath = state.completePath.join(".") + "." + field;
            var msg;
            if (!node1) msg = "node1 on " + fullPath + " not defined";else if (!node2) msg = "node2 not defined but node1 (" + fullPath + ") is: " + node1[field];else msg = fullPath + " is not equal: " + node1[field] + " vs. " + node2[field];
            this.recordNotEqual(node1, node2, state, msg);
            return false;
          }
        }, {
          key: "accept",
          value: function accept(node1, node2, state, path) {
            var patternNode = Path(path.join(".")).get(node2);
            if (node1 === "*" || patternNode === "*") return;
            var nextState = {
              completePath: path,
              comparisons: state.comparisons
            };

            if (this.compareType(node1, node2, nextState)) {
              this["visit" + node1.type](node1, node2, nextState, path);
            }
          }
        }, {
          key: "visitFunction",
          value: function visitFunction(node1, node2, state, path) {
            if (node1.generator) {
              this.compareField("generator", node1, node2, state);
            }

            if (node1.expression) {
              this.compareField("expression", node1, node2, state);
            }

            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitFunction", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitSwitchStatement",
          value: function visitSwitchStatement(node1, node2, state, path) {
            if (node1.lexical) {
              this.compareField("lexical", node1, node2, state);
            }

            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitSwitchStatement", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitForInStatement",
          value: function visitForInStatement(node1, node2, state, path) {
            if (node1.each) {
              this.compareField("each", node1, node2, state);
            }

            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitForInStatement", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitFunctionDeclaration",
          value: function visitFunctionDeclaration(node1, node2, state, path) {
            if (node1.generator) {
              this.compareField("generator", node1, node2, state);
            }

            if (node1.expression) {
              this.compareField("expression", node1, node2, state);
            }

            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitFunctionDeclaration", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitVariableDeclaration",
          value: function visitVariableDeclaration(node1, node2, state, path) {
            this.compareField("kind", node1, node2, state);
            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitVariableDeclaration", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitUnaryExpression",
          value: function visitUnaryExpression(node1, node2, state, path) {
            this.compareField("operator", node1, node2, state);

            if (node1.prefix) {
              this.compareField("prefix", node1, node2, state);
            }

            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitUnaryExpression", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitBinaryExpression",
          value: function visitBinaryExpression(node1, node2, state, path) {
            this.compareField("operator", node1, node2, state);
            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitBinaryExpression", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitAssignmentExpression",
          value: function visitAssignmentExpression(node1, node2, state, path) {
            this.compareField("operator", node1, node2, state);
            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitAssignmentExpression", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitUpdateExpression",
          value: function visitUpdateExpression(node1, node2, state, path) {
            this.compareField("operator", node1, node2, state);

            if (node1.prefix) {
              this.compareField("prefix", node1, node2, state);
            }

            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitUpdateExpression", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitLogicalExpression",
          value: function visitLogicalExpression(node1, node2, state, path) {
            this.compareField("operator", node1, node2, state);
            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitLogicalExpression", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitMemberExpression",
          value: function visitMemberExpression(node1, node2, state, path) {
            if (node1.computed) {
              this.compareField("computed", node1, node2, state);
            }

            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitMemberExpression", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitComprehensionBlock",
          value: function visitComprehensionBlock(node1, node2, state, path) {
            if (node1.each) {
              this.compareField("each", node1, node2, state);
            }

            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitComprehensionBlock", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitIdentifier",
          value: function visitIdentifier(node1, node2, state, path) {
            this.compareField("name", node1, node2, state);
            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitIdentifier", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitLiteral",
          value: function visitLiteral(node1, node2, state, path) {
            this.compareField("value", node1, node2, state);
            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitLiteral", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitClassDeclaration",
          value: function visitClassDeclaration(node1, node2, state, path) {
            this.compareField("id", node1, node2, state);

            if (node1.superClass) {
              this.compareField("superClass", node1, node2, state);
            }

            this.compareField("body", node1, node2, state);
            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitClassDeclaration", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitClassBody",
          value: function visitClassBody(node1, node2, state, path) {
            this.compareField("body", node1, node2, state);
            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitClassBody", this).call(this, node1, node2, state, path);
          }
        }, {
          key: "visitMethodDefinition",
          value: function visitMethodDefinition(node1, node2, state, path) {
            this.compareField("static", node1, node2, state);
            this.compareField("computed", node1, node2, state);
            this.compareField("kind", node1, node2, state);
            this.compareField("key", node1, node2, state);
            this.compareField("value", node1, node2, state);
            return _get(_getPrototypeOf(ComparisonVisitor.prototype), "visitMethodDefinition", this).call(this, node1, node2, state, path);
          }
        }]);

        return ComparisonVisitor;
      }(Visitor);

      __varRecorder__$d.ComparisonVisitor = ComparisonVisitor;

      var ScopeVisitor = /*#__PURE__*/function (_Visitor3) {
        _inherits(ScopeVisitor, _Visitor3);

        var _super3 = _createSuper(ScopeVisitor);

        function ScopeVisitor() {
          _classCallCheck(this, ScopeVisitor);

          return _super3.apply(this, arguments);
        }

        _createClass(ScopeVisitor, [{
          key: "newScope",
          value: function newScope(scopeNode, parentScope) {
            var scope = {
              node: scopeNode,
              varDecls: [],
              varDeclPaths: [],
              funcDecls: [],
              funcDeclPaths: [],
              classDecls: [],
              classDeclPaths: [],
              classExprs: [],
              classExprPaths: [],
              methodDecls: [],
              methodDeclPaths: [],
              importSpecifiers: [],
              importSpecifierPaths: [],
              exportDecls: [],
              exportDeclPaths: [],
              refs: [],
              thisRefs: [],
              params: [],
              catches: [],
              subScopes: [],
              resolvedRefMap: new Map()
            };
            if (parentScope) parentScope.subScopes.push(scope);
            return scope;
          }
        }, {
          key: "visitVariableDeclaration",
          value: function visitVariableDeclaration(node, scope, path) {
            scope.varDecls.push(node);
            scope.varDeclPaths.push(path);
            return _get(_getPrototypeOf(ScopeVisitor.prototype), "visitVariableDeclaration", this).call(this, node, scope, path);
          }
        }, {
          key: "visitVariableDeclarator",
          value: function visitVariableDeclarator(node, scope, path) {
            var visitor = this;

            if (node.init) {
              node.init = visitor.accept(node.init, scope, path.concat(["init"]));
            }

            return node;
          }
        }, {
          key: "visitFunctionParameters",
          value: function visitFunctionParameters(params, scope, path) {
            var _this = this;

            params.forEach(function (param, i) {
              if (param.type === "ObjectPattern") {
                _this.visitFunctionParameters(param.properties, scope, path.concat(i, "properties"));
              }

              if (param.type === "Property" && param.value.type === "AssignmentPattern") {
                _this.accept(param.value.right, scope, path.concat(i, "value", "right"));
              }

              if (param.type === "AssignmentPattern") {
                _this.accept(param.right, scope, path.concat(i, "right"));
              }
            });
          }
        }, {
          key: "visitFunction",
          value: function visitFunction(node, scope, path) {
            var visitor = this;
            var newScope = this.newScope(node, scope);
            visitor.visitFunctionParameters(node.params, newScope, path.concat("params"));
            newScope.params = Array.prototype.slice.call(node.params);
            return newScope;
          }
        }, {
          key: "visitFunctionDeclaration",
          value: function visitFunctionDeclaration(node, scope, path) {
            var newScope = this.visitFunction(node, scope, path);
            scope.funcDecls.push(node);
            scope.funcDeclPaths.push(path);
            var visitor = this;

            if (node.defaults) {
              node.defaults = node.defaults.reduce(function (results, ea, i) {
                var result = visitor.accept(ea, newScope, path.concat(["defaults", i]));
                if (Array.isArray(result)) results.push.apply(results, result);else results.push(result);
                return results;
              }, []);
            }

            if (node.rest) {
              node.rest = visitor.accept(node.rest, newScope, path.concat(["rest"]));
            }

            node.body = visitor.accept(node.body, newScope, path.concat(["body"]));

            if (node.loc) {
              node.loc = visitor.accept(node.loc, newScope, path.concat(["loc"]));
            }

            return node;
          }
        }, {
          key: "visitFunctionExpression",
          value: function visitFunctionExpression(node, scope, path) {
            var newScope = this.visitFunction(node, scope, path);
            var visitor = this;

            if (node.defaults) {
              node.defaults = node.defaults.reduce(function (results, ea, i) {
                var result = visitor.accept(ea, newScope, path.concat(["defaults", i]));
                if (Array.isArray(result)) results.push.apply(results, result);else results.push(result);
                return results;
              }, []);
            }

            if (node.rest) {
              node.rest = visitor.accept(node.rest, newScope, path.concat(["rest"]));
            }

            node.body = visitor.accept(node.body, newScope, path.concat(["body"]));

            if (node.loc) {
              node.loc = visitor.accept(node.loc, newScope, path.concat(["loc"]));
            }

            return node;
          }
        }, {
          key: "visitArrowFunctionExpression",
          value: function visitArrowFunctionExpression(node, scope, path) {
            var newScope = this.visitFunction(node, scope, path);
            var visitor = this;

            if (node.defaults) {
              node.defaults = node.defaults.reduce(function (results, ea, i) {
                var result = visitor.accept(ea, newScope, path.concat(["defaults", i]));
                if (Array.isArray(result)) results.push.apply(results, result);else results.push(result);
                return results;
              }, []);
            }

            if (node.rest) {
              node.rest = visitor.accept(node.rest, newScope, path.concat(["rest"]));
            }

            node.body = visitor.accept(node.body, newScope, path.concat(["body"]));

            if (node.loc) {
              node.loc = visitor.accept(node.loc, newScope, path.concat(["loc"]));
            }

            if (node.generator) ;

            if (node.expression) ;

            return node;
          }
        }, {
          key: "visitIdentifier",
          value: function visitIdentifier(node, scope, path) {
            scope.refs.push(node);
            return _get(_getPrototypeOf(ScopeVisitor.prototype), "visitIdentifier", this).call(this, node, scope, path);
          }
        }, {
          key: "visitMemberExpression",
          value: function visitMemberExpression(node, scope, path) {
            var visitor = this;
            node.object = visitor.accept(node.object, scope, path.concat(["object"]));

            if (node.computed) {
              node.property = visitor.accept(node.property, scope, path.concat(["property"]));
            }

            return node;
          }
        }, {
          key: "visitProperty",
          value: function visitProperty(node, scope, path) {
            var visitor = this;

            if (node.computed) {
              node.key = visitor.accept(node.key, scope, path.concat(["key"]));
            }

            node.value = visitor.accept(node.value, scope, path.concat(["value"]));
            return node;
          }
        }, {
          key: "visitThisExpression",
          value: function visitThisExpression(node, scope, path) {
            scope.thisRefs.push(node);
            return _get(_getPrototypeOf(ScopeVisitor.prototype), "visitThisExpression", this).call(this, node, scope, path);
          }
        }, {
          key: "visitTryStatement",
          value: function visitTryStatement(node, scope, path) {
            var visitor = this;
            node.block = visitor.accept(node.block, scope, path.concat(["block"]));

            if (node.handler) {
              node.handler = visitor.accept(node.handler, scope, path.concat(["handler"]));
              scope.catches.push(node.handler.param);
            }

            if (node.finalizer) {
              node.finalizer = visitor.accept(node.finalizer, scope, path.concat(["finalizer"]));
            }

            return node;
          }
        }, {
          key: "visitForStatement",
          value: function visitForStatement(node, scope, path) {
            var visitor = this;

            if (node.init) {
              node.init = visitor.accept(node.init, scope, path.concat(["init"]));
            }

            if (node.test) {
              node.test = visitor.accept(node.test, scope, path.concat(["test"]));
            }

            if (node.update) {
              node.update = visitor.accept(node.update, scope, path.concat(["update"]));
            }

            node.body = visitor.accept(node.body, this.newScope(node, scope), path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitForInStatement",
          value: function visitForInStatement(node, scope, path) {
            var visitor = this;
            node.left = visitor.accept(node.left, scope, path.concat(["left"]));
            node.right = visitor.accept(node.right, scope, path.concat(["right"]));
            node.body = visitor.accept(node.body, this.newScope(node, scope), path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitIfStatement",
          value: function visitIfStatement(node, scope, path) {
            var visitor = this;
            node.test = visitor.accept(node.test, scope, path.concat(["test"]));
            var consequentScope = this.newScope(node, scope);
            node.consequent = visitor.accept(node.consequent, consequentScope, path.concat(["consequent"]));

            if (node.alternate) {
              var alternateScope = this.newScope(node, scope);
              node.alternate = visitor.accept(node.alternate, alternateScope, path.concat(["alternate"]));
            }

            return node;
          }
        }, {
          key: "visitLabeledStatement",
          value: function visitLabeledStatement(node, scope, path) {
            var visitor = this;
            node.body = visitor.accept(node.body, scope, path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitClassDeclaration",
          value: function visitClassDeclaration(node, scope, path) {
            scope.classDecls.push(node);
            scope.classDeclPaths.push(path);
            var visitor = this;

            if (node.superClass) {
              node.superClass = visitor.accept(node.superClass, scope, path.concat(["superClass"]));
            }

            node.body = visitor.accept(node.body, scope, path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitClassExpression",
          value: function visitClassExpression(node, scope, path) {
            if (node.id) {
              scope.classExprs.push(node);
              scope.classExprPaths.push(path);
            }

            var visitor = this;

            if (node.superClass) {
              node.superClass = visitor.accept(node.superClass, scope, path.concat(["superClass"]));
            }

            node.body = visitor.accept(node.body, scope, path.concat(["body"]));
            return node;
          }
        }, {
          key: "visitMethodDefinition",
          value: function visitMethodDefinition(node, scope, path) {
            var visitor = this;

            if (node.computed) {
              var curr = node.key;

              while (curr.type === "MemberExpression") {
                curr = curr.object;
              }

              if (curr.type === "Identifier") {
                scope.refs.push(node.key);
              }
            }

            node.value = visitor.accept(node.value, scope, path.concat(["value"]));
            return node;
          }
        }, {
          key: "visitMetaProperty",
          value: function visitMetaProperty(node, scope, path) {
            return node;
          }
        }, {
          key: "visitBreakStatement",
          value: function visitBreakStatement(node, scope, path) {
            return node;
          }
        }, {
          key: "visitContinueStatement",
          value: function visitContinueStatement(node, scope, path) {
            return node;
          }
        }, {
          key: "visitImportSpecifier",
          value: function visitImportSpecifier(node, scope, path) {
            scope.importSpecifiers.push(node.local);
            scope.importSpecifierPaths.push(path);
            return node;
          }
        }, {
          key: "visitImportDefaultSpecifier",
          value: function visitImportDefaultSpecifier(node, scope, path) {
            scope.importSpecifiers.push(node.local);
            scope.importSpecifierPaths.push(path);
            return node;
          }
        }, {
          key: "visitImportNamespaceSpecifier",
          value: function visitImportNamespaceSpecifier(node, scope, path) {
            scope.importSpecifiers.push(node.local);
            scope.importSpecifierPaths.push(path);
            return node;
          }
        }, {
          key: "visitExportSpecifier",
          value: function visitExportSpecifier(node, scope, path) {
            var visitor = this;
            node.local = visitor.accept(node.local, scope, path.concat(["local"]));
            return node;
          }
        }, {
          key: "visitExportNamedDeclaration",
          value: function visitExportNamedDeclaration(node, scope, path) {
            scope.exportDecls.push(node);
            scope.exportDeclPaths.push(path);
            if (!node.source) _get(_getPrototypeOf(ScopeVisitor.prototype), "visitExportNamedDeclaration", this).call(this, node, scope, path);
            return node;
          }
        }, {
          key: "visitExportDefaultDeclaration",
          value: function visitExportDefaultDeclaration(node, scope, path) {
            scope.exportDecls.push(node);
            scope.exportDeclPaths.push(path);
            return _get(_getPrototypeOf(ScopeVisitor.prototype), "visitExportDefaultDeclaration", this).call(this, node, scope, path);
          }
        }, {
          key: "visitExportAllDeclaration",
          value: function visitExportAllDeclaration(node, scope, path) {
            scope.exportDecls.push(node);
            scope.exportDeclPaths.push(path);
            return _get(_getPrototypeOf(ScopeVisitor.prototype), "visitExportAllDeclaration", this).call(this, node, scope, path);
          }
        }]);

        return ScopeVisitor;
      }(Visitor);

      __varRecorder__$d.ScopeVisitor = ScopeVisitor;
      __varRecorder__$d.Visitor = Visitor;
      __varRecorder__$d.PrinterVisitor = PrinterVisitor;
      __varRecorder__$d.ComparisonVisitor = ComparisonVisitor;
      __varRecorder__$d.ScopeVisitor = ScopeVisitor;

      var _global$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      var exports$a = {};
      (function clone(exports) {
        var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
        function deepCopy(obj) {
          var ret = {}, key, val;
          for (key in obj) {
            if (obj.hasOwnProperty(key)) {
              val = obj[key];
              if (typeof val === "object" && val !== null) {
                ret[key] = deepCopy(val);
              } else {
                ret[key] = val;
              }
            }
          }
          return ret;
        }
        function upperBound(array, func) {
          var diff, len, i, current;
          len = array.length;
          i = 0;
          while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
              len = diff;
            } else {
              i = current + 1;
              len -= diff + 1;
            }
          }
          return i;
        }
        Syntax = {
          AssignmentExpression: "AssignmentExpression",
          AssignmentPattern: "AssignmentPattern",
          ArrayExpression: "ArrayExpression",
          ArrayPattern: "ArrayPattern",
          ArrowFunctionExpression: "ArrowFunctionExpression",
          AwaitExpression: "AwaitExpression",
          BlockStatement: "BlockStatement",
          BinaryExpression: "BinaryExpression",
          BreakStatement: "BreakStatement",
          CallExpression: "CallExpression",
          CatchClause: "CatchClause",
          ChainExpression: "ChainExpression",
          ClassBody: "ClassBody",
          ClassDeclaration: "ClassDeclaration",
          ClassExpression: "ClassExpression",
          ComprehensionBlock: "ComprehensionBlock",
          ComprehensionExpression: "ComprehensionExpression",
          ConditionalExpression: "ConditionalExpression",
          ContinueStatement: "ContinueStatement",
          DebuggerStatement: "DebuggerStatement",
          DirectiveStatement: "DirectiveStatement",
          DoWhileStatement: "DoWhileStatement",
          EmptyStatement: "EmptyStatement",
          ExportAllDeclaration: "ExportAllDeclaration",
          ExportDefaultDeclaration: "ExportDefaultDeclaration",
          ExportNamedDeclaration: "ExportNamedDeclaration",
          ExportSpecifier: "ExportSpecifier",
          ExpressionStatement: "ExpressionStatement",
          ForStatement: "ForStatement",
          ForInStatement: "ForInStatement",
          ForOfStatement: "ForOfStatement",
          FunctionDeclaration: "FunctionDeclaration",
          FunctionExpression: "FunctionExpression",
          GeneratorExpression: "GeneratorExpression",
          Identifier: "Identifier",
          IfStatement: "IfStatement",
          ImportExpression: "ImportExpression",
          ImportDeclaration: "ImportDeclaration",
          ImportDefaultSpecifier: "ImportDefaultSpecifier",
          ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
          ImportSpecifier: "ImportSpecifier",
          Literal: "Literal",
          LabeledStatement: "LabeledStatement",
          LogicalExpression: "LogicalExpression",
          MemberExpression: "MemberExpression",
          MetaProperty: "MetaProperty",
          MethodDefinition: "MethodDefinition",
          ModuleSpecifier: "ModuleSpecifier",
          NewExpression: "NewExpression",
          ObjectExpression: "ObjectExpression",
          ObjectPattern: "ObjectPattern",
          PrivateIdentifier: "PrivateIdentifier",
          Program: "Program",
          Property: "Property",
          PropertyDefinition: "PropertyDefinition",
          RestElement: "RestElement",
          ReturnStatement: "ReturnStatement",
          SequenceExpression: "SequenceExpression",
          SpreadElement: "SpreadElement",
          StaticBlock: "StaticBlock",
          Super: "Super",
          SwitchStatement: "SwitchStatement",
          SwitchCase: "SwitchCase",
          TaggedTemplateExpression: "TaggedTemplateExpression",
          TemplateElement: "TemplateElement",
          TemplateLiteral: "TemplateLiteral",
          ThisExpression: "ThisExpression",
          ThrowStatement: "ThrowStatement",
          TryStatement: "TryStatement",
          UnaryExpression: "UnaryExpression",
          UpdateExpression: "UpdateExpression",
          VariableDeclaration: "VariableDeclaration",
          VariableDeclarator: "VariableDeclarator",
          WhileStatement: "WhileStatement",
          WithStatement: "WithStatement",
          YieldExpression: "YieldExpression"
        };
        VisitorKeys = {
          AssignmentExpression: [
            "left",
            "right"
          ],
          AssignmentPattern: [
            "left",
            "right"
          ],
          ArrayExpression: ["elements"],
          ArrayPattern: ["elements"],
          ArrowFunctionExpression: [
            "params",
            "body"
          ],
          AwaitExpression: ["argument"],
          BlockStatement: ["body"],
          BinaryExpression: [
            "left",
            "right"
          ],
          BreakStatement: ["label"],
          CallExpression: [
            "callee",
            "arguments"
          ],
          CatchClause: [
            "param",
            "body"
          ],
          ChainExpression: ["expression"],
          ClassBody: ["body"],
          ClassDeclaration: [
            "id",
            "superClass",
            "body"
          ],
          ClassExpression: [
            "id",
            "superClass",
            "body"
          ],
          ComprehensionBlock: [
            "left",
            "right"
          ],
          ComprehensionExpression: [
            "blocks",
            "filter",
            "body"
          ],
          ConditionalExpression: [
            "test",
            "consequent",
            "alternate"
          ],
          ContinueStatement: ["label"],
          DebuggerStatement: [],
          DirectiveStatement: [],
          DoWhileStatement: [
            "body",
            "test"
          ],
          EmptyStatement: [],
          ExportAllDeclaration: ["source"],
          ExportDefaultDeclaration: ["declaration"],
          ExportNamedDeclaration: [
            "declaration",
            "specifiers",
            "source"
          ],
          ExportSpecifier: [
            "exported",
            "local"
          ],
          ExpressionStatement: ["expression"],
          ForStatement: [
            "init",
            "test",
            "update",
            "body"
          ],
          ForInStatement: [
            "left",
            "right",
            "body"
          ],
          ForOfStatement: [
            "left",
            "right",
            "body"
          ],
          FunctionDeclaration: [
            "id",
            "params",
            "body"
          ],
          FunctionExpression: [
            "id",
            "params",
            "body"
          ],
          GeneratorExpression: [
            "blocks",
            "filter",
            "body"
          ],
          Identifier: [],
          IfStatement: [
            "test",
            "consequent",
            "alternate"
          ],
          ImportExpression: ["source"],
          ImportDeclaration: [
            "specifiers",
            "source"
          ],
          ImportDefaultSpecifier: ["local"],
          ImportNamespaceSpecifier: ["local"],
          ImportSpecifier: [
            "imported",
            "local"
          ],
          Literal: [],
          LabeledStatement: [
            "label",
            "body"
          ],
          LogicalExpression: [
            "left",
            "right"
          ],
          MemberExpression: [
            "object",
            "property"
          ],
          MetaProperty: [
            "meta",
            "property"
          ],
          MethodDefinition: [
            "key",
            "value"
          ],
          ModuleSpecifier: [],
          NewExpression: [
            "callee",
            "arguments"
          ],
          ObjectExpression: ["properties"],
          ObjectPattern: ["properties"],
          PrivateIdentifier: [],
          Program: ["body"],
          Property: [
            "key",
            "value"
          ],
          PropertyDefinition: [
            "key",
            "value"
          ],
          RestElement: ["argument"],
          ReturnStatement: ["argument"],
          SequenceExpression: ["expressions"],
          SpreadElement: ["argument"],
          StaticBlock: ["body"],
          Super: [],
          SwitchStatement: [
            "discriminant",
            "cases"
          ],
          SwitchCase: [
            "test",
            "consequent"
          ],
          TaggedTemplateExpression: [
            "tag",
            "quasi"
          ],
          TemplateElement: [],
          TemplateLiteral: [
            "quasis",
            "expressions"
          ],
          ThisExpression: [],
          ThrowStatement: ["argument"],
          TryStatement: [
            "block",
            "handler",
            "finalizer"
          ],
          UnaryExpression: ["argument"],
          UpdateExpression: ["argument"],
          VariableDeclaration: ["declarations"],
          VariableDeclarator: [
            "id",
            "init"
          ],
          WhileStatement: [
            "test",
            "body"
          ],
          WithStatement: [
            "object",
            "body"
          ],
          YieldExpression: ["argument"]
        };
        BREAK = {};
        SKIP = {};
        REMOVE = {};
        VisitorOption = {
          Break: BREAK,
          Skip: SKIP,
          Remove: REMOVE
        };
        function Reference(parent, key) {
          (this || _global$2).parent = parent;
          (this || _global$2).key = key;
        }
        Reference.prototype.replace = function replace(node) {
          (this || _global$2).parent[(this || _global$2).key] = node;
        };
        Reference.prototype.remove = function remove() {
          if (Array.isArray((this || _global$2).parent)) {
            (this || _global$2).parent.splice((this || _global$2).key, 1);
            return true;
          } else {
            this.replace(null);
            return false;
          }
        };
        function Element(node, path, wrap, ref) {
          (this || _global$2).node = node;
          (this || _global$2).path = path;
          (this || _global$2).wrap = wrap;
          (this || _global$2).ref = ref;
        }
        function Controller() {
        }
        Controller.prototype.path = function path() {
          var i, iz, j, jz, result, element;
          function addToPath(result, path) {
            if (Array.isArray(path)) {
              for (j = 0, jz = path.length; j < jz; ++j) {
                result.push(path[j]);
              }
            } else {
              result.push(path);
            }
          }
          if (!(this || _global$2).__current.path) {
            return null;
          }
          result = [];
          for (i = 2, iz = (this || _global$2).__leavelist.length; i < iz; ++i) {
            element = (this || _global$2).__leavelist[i];
            addToPath(result, element.path);
          }
          addToPath(result, (this || _global$2).__current.path);
          return result;
        };
        Controller.prototype.type = function () {
          var node = this.current();
          return node.type || (this || _global$2).__current.wrap;
        };
        Controller.prototype.parents = function parents() {
          var i, iz, result;
          result = [];
          for (i = 1, iz = (this || _global$2).__leavelist.length; i < iz; ++i) {
            result.push((this || _global$2).__leavelist[i].node);
          }
          return result;
        };
        Controller.prototype.current = function current() {
          return (this || _global$2).__current.node;
        };
        Controller.prototype.__execute = function __execute(callback, element) {
          var previous, result;
          result = undefined;
          previous = (this || _global$2).__current;
          (this || _global$2).__current = element;
          (this || _global$2).__state = null;
          if (callback) {
            result = callback.call(this || _global$2, element.node, (this || _global$2).__leavelist[(this || _global$2).__leavelist.length - 1].node);
          }
          (this || _global$2).__current = previous;
          return result;
        };
        Controller.prototype.notify = function notify(flag) {
          (this || _global$2).__state = flag;
        };
        Controller.prototype.skip = function () {
          this.notify(SKIP);
        };
        Controller.prototype["break"] = function () {
          this.notify(BREAK);
        };
        Controller.prototype.remove = function () {
          this.notify(REMOVE);
        };
        Controller.prototype.__initialize = function (root, visitor) {
          (this || _global$2).visitor = visitor;
          (this || _global$2).root = root;
          (this || _global$2).__worklist = [];
          (this || _global$2).__leavelist = [];
          (this || _global$2).__current = null;
          (this || _global$2).__state = null;
          (this || _global$2).__fallback = null;
          if (visitor.fallback === "iteration") {
            (this || _global$2).__fallback = Object.keys;
          } else if (typeof visitor.fallback === "function") {
            (this || _global$2).__fallback = visitor.fallback;
          }
          (this || _global$2).__keys = VisitorKeys;
          if (visitor.keys) {
            (this || _global$2).__keys = Object.assign(Object.create((this || _global$2).__keys), visitor.keys);
          }
        };
        function isNode(node) {
          if (node == null) {
            return false;
          }
          return typeof node === "object" && typeof node.type === "string";
        }
        function isProperty(nodeType, key) {
          return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
        }
        function candidateExistsInLeaveList(leavelist, candidate) {
          for (var i = leavelist.length - 1; i >= 0; --i) {
            if (leavelist[i].node === candidate) {
              return true;
            }
          }
          return false;
        }
        Controller.prototype.traverse = function traverse(root, visitor) {
          var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
          this.__initialize(root, visitor);
          sentinel = {};
          worklist = (this || _global$2).__worklist;
          leavelist = (this || _global$2).__leavelist;
          worklist.push(new Element(root, null, null, null));
          leavelist.push(new Element(null, null, null, null));
          while (worklist.length) {
            element = worklist.pop();
            if (element === sentinel) {
              element = leavelist.pop();
              ret = this.__execute(visitor.leave, element);
              if ((this || _global$2).__state === BREAK || ret === BREAK) {
                return;
              }
              continue;
            }
            if (element.node) {
              ret = this.__execute(visitor.enter, element);
              if ((this || _global$2).__state === BREAK || ret === BREAK) {
                return;
              }
              worklist.push(sentinel);
              leavelist.push(element);
              if ((this || _global$2).__state === SKIP || ret === SKIP) {
                continue;
              }
              node = element.node;
              nodeType = node.type || element.wrap;
              candidates = (this || _global$2).__keys[nodeType];
              if (!candidates) {
                if ((this || _global$2).__fallback) {
                  candidates = this.__fallback(node);
                } else {
                  throw new Error("Unknown node type " + nodeType + ".");
                }
              }
              current = candidates.length;
              while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                  continue;
                }
                if (Array.isArray(candidate)) {
                  current2 = candidate.length;
                  while ((current2 -= 1) >= 0) {
                    if (!candidate[current2]) {
                      continue;
                    }
                    if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                      continue;
                    }
                    if (isProperty(nodeType, candidates[current])) {
                      element = new Element(candidate[current2], [
                        key,
                        current2
                      ], "Property", null);
                    } else if (isNode(candidate[current2])) {
                      element = new Element(candidate[current2], [
                        key,
                        current2
                      ], null, null);
                    } else {
                      continue;
                    }
                    worklist.push(element);
                  }
                } else if (isNode(candidate)) {
                  if (candidateExistsInLeaveList(leavelist, candidate)) {
                    continue;
                  }
                  worklist.push(new Element(candidate, key, null, null));
                }
              }
            }
          }
        };
        Controller.prototype.replace = function replace(root, visitor) {
          var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
          function removeElem(element) {
            var i, key, nextElem, parent;
            if (element.ref.remove()) {
              key = element.ref.key;
              parent = element.ref.parent;
              i = worklist.length;
              while (i--) {
                nextElem = worklist[i];
                if (nextElem.ref && nextElem.ref.parent === parent) {
                  if (nextElem.ref.key < key) {
                    break;
                  }
                  --nextElem.ref.key;
                }
              }
            }
          }
          this.__initialize(root, visitor);
          sentinel = {};
          worklist = (this || _global$2).__worklist;
          leavelist = (this || _global$2).__leavelist;
          outer = { root: root };
          element = new Element(root, null, null, new Reference(outer, "root"));
          worklist.push(element);
          leavelist.push(element);
          while (worklist.length) {
            element = worklist.pop();
            if (element === sentinel) {
              element = leavelist.pop();
              target = this.__execute(visitor.leave, element);
              if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                element.ref.replace(target);
              }
              if ((this || _global$2).__state === REMOVE || target === REMOVE) {
                removeElem(element);
              }
              if ((this || _global$2).__state === BREAK || target === BREAK) {
                return outer.root;
              }
              continue;
            }
            target = this.__execute(visitor.enter, element);
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
              element.ref.replace(target);
              element.node = target;
            }
            if ((this || _global$2).__state === REMOVE || target === REMOVE) {
              removeElem(element);
              element.node = null;
            }
            if ((this || _global$2).__state === BREAK || target === BREAK) {
              return outer.root;
            }
            node = element.node;
            if (!node) {
              continue;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if ((this || _global$2).__state === SKIP || target === SKIP) {
              continue;
            }
            nodeType = node.type || element.wrap;
            candidates = (this || _global$2).__keys[nodeType];
            if (!candidates) {
              if ((this || _global$2).__fallback) {
                candidates = this.__fallback(node);
              } else {
                throw new Error("Unknown node type " + nodeType + ".");
              }
            }
            current = candidates.length;
            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (Array.isArray(candidate)) {
                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                  if (!candidate[current2]) {
                    continue;
                  }
                  if (isProperty(nodeType, candidates[current])) {
                    element = new Element(candidate[current2], [
                      key,
                      current2
                    ], "Property", new Reference(candidate, current2));
                  } else if (isNode(candidate[current2])) {
                    element = new Element(candidate[current2], [
                      key,
                      current2
                    ], null, new Reference(candidate, current2));
                  } else {
                    continue;
                  }
                  worklist.push(element);
                }
              } else if (isNode(candidate)) {
                worklist.push(new Element(candidate, key, null, new Reference(node, key)));
              }
            }
          }
          return outer.root;
        };
        function traverse(root, visitor) {
          var controller = new Controller();
          return controller.traverse(root, visitor);
        }
        function replace(root, visitor) {
          var controller = new Controller();
          return controller.replace(root, visitor);
        }
        function extendCommentRange(comment, tokens) {
          var target;
          target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
          });
          comment.extendedRange = [
            comment.range[0],
            comment.range[1]
          ];
          if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
          }
          target -= 1;
          if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
          }
          return comment;
        }
        function attachComments(tree, providedComments, tokens) {
          var comments = [], comment, len, i, cursor;
          if (!tree.range) {
            throw new Error("attachComments needs range information");
          }
          if (!tokens.length) {
            if (providedComments.length) {
              for (i = 0, len = providedComments.length; i < len; i += 1) {
                comment = deepCopy(providedComments[i]);
                comment.extendedRange = [
                  0,
                  tree.range[0]
                ];
                comments.push(comment);
              }
              tree.leadingComments = comments;
            }
            return tree;
          }
          for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
          }
          cursor = 0;
          traverse(tree, {
            enter: function (node) {
              var comment;
              while (cursor < comments.length) {
                comment = comments[cursor];
                if (comment.extendedRange[1] > node.range[0]) {
                  break;
                }
                if (comment.extendedRange[1] === node.range[0]) {
                  if (!node.leadingComments) {
                    node.leadingComments = [];
                  }
                  node.leadingComments.push(comment);
                  comments.splice(cursor, 1);
                } else {
                  cursor += 1;
                }
              }
              if (cursor === comments.length) {
                return VisitorOption.Break;
              }
              if (comments[cursor].extendedRange[0] > node.range[1]) {
                return VisitorOption.Skip;
              }
            }
          });
          cursor = 0;
          traverse(tree, {
            leave: function (node) {
              var comment;
              while (cursor < comments.length) {
                comment = comments[cursor];
                if (node.range[1] < comment.extendedRange[0]) {
                  break;
                }
                if (node.range[1] === comment.extendedRange[0]) {
                  if (!node.trailingComments) {
                    node.trailingComments = [];
                  }
                  node.trailingComments.push(comment);
                  comments.splice(cursor, 1);
                } else {
                  cursor += 1;
                }
              }
              if (cursor === comments.length) {
                return VisitorOption.Break;
              }
              if (comments[cursor].extendedRange[0] > node.range[1]) {
                return VisitorOption.Skip;
              }
            }
          });
          return tree;
        }
        exports.Syntax = Syntax;
        exports.traverse = traverse;
        exports.replace = replace;
        exports.attachComments = attachComments;
        exports.VisitorKeys = VisitorKeys;
        exports.VisitorOption = VisitorOption;
        exports.Controller = Controller;
        exports.cloneEnvironment = function () {
          return clone({});
        };
        return exports;
      }(exports$a));
      exports$a.Syntax; exports$a.traverse; exports$a.replace; exports$a.attachComments; exports$a.VisitorKeys; exports$a.VisitorOption; exports$a.Controller; exports$a.cloneEnvironment;

      var exports$9 = {};
      (function () {
        function isExpression(node) {
          if (node == null) {
            return false;
          }
          switch (node.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
          }
          return false;
        }
        function isIterationStatement(node) {
          if (node == null) {
            return false;
          }
          switch (node.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
          }
          return false;
        }
        function isStatement(node) {
          if (node == null) {
            return false;
          }
          switch (node.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
          }
          return false;
        }
        function isSourceElement(node) {
          return isStatement(node) || node != null && node.type === "FunctionDeclaration";
        }
        function trailingStatement(node) {
          switch (node.type) {
          case "IfStatement":
            if (node.alternate != null) {
              return node.alternate;
            }
            return node.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return node.body;
          }
          return null;
        }
        function isProblematicIfStatement(node) {
          var current;
          if (node.type !== "IfStatement") {
            return false;
          }
          if (node.alternate == null) {
            return false;
          }
          current = node.consequent;
          do {
            if (current.type === "IfStatement") {
              if (current.alternate == null) {
                return true;
              }
            }
            current = trailingStatement(current);
          } while (current);
          return false;
        }
        exports$9 = {
          isExpression: isExpression,
          isStatement: isStatement,
          isIterationStatement: isIterationStatement,
          isSourceElement: isSourceElement,
          isProblematicIfStatement: isProblematicIfStatement,
          trailingStatement: trailingStatement
        };
      }());
      var _ast = exports$9;
      exports$9.isExpression; exports$9.isStatement; exports$9.isIterationStatement; exports$9.isSourceElement; exports$9.isProblematicIfStatement; exports$9.trailingStatement;

      var exports$8 = {};
      (function () {
        var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
        ES5Regex = {
          NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
          NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
        };
        ES6Regex = {
          NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
          NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
        };
        function isDecimalDigit(ch) {
          return 48 <= ch && ch <= 57;
        }
        function isHexDigit(ch) {
          return 48 <= ch && ch <= 57 || 97 <= ch && ch <= 102 || 65 <= ch && ch <= 70;
        }
        function isOctalDigit(ch) {
          return ch >= 48 && ch <= 55;
        }
        NON_ASCII_WHITESPACES = [
          5760,
          8192,
          8193,
          8194,
          8195,
          8196,
          8197,
          8198,
          8199,
          8200,
          8201,
          8202,
          8239,
          8287,
          12288,
          65279
        ];
        function isWhiteSpace(ch) {
          return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
        }
        function isLineTerminator(ch) {
          return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
        }
        function fromCodePoint(cp) {
          if (cp <= 65535) {
            return String.fromCharCode(cp);
          }
          var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
          var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
          return cu1 + cu2;
        }
        IDENTIFIER_START = new Array(128);
        for (ch = 0; ch < 128; ++ch) {
          IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch === 36 || ch === 95;
        }
        IDENTIFIER_PART = new Array(128);
        for (ch = 0; ch < 128; ++ch) {
          IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57 || ch === 36 || ch === 95;
        }
        function isIdentifierStartES5(ch) {
          return ch < 128 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
        }
        function isIdentifierPartES5(ch) {
          return ch < 128 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
        }
        function isIdentifierStartES6(ch) {
          return ch < 128 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
        }
        function isIdentifierPartES6(ch) {
          return ch < 128 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
        }
        exports$8 = {
          isDecimalDigit: isDecimalDigit,
          isHexDigit: isHexDigit,
          isOctalDigit: isOctalDigit,
          isWhiteSpace: isWhiteSpace,
          isLineTerminator: isLineTerminator,
          isIdentifierStartES5: isIdentifierStartES5,
          isIdentifierPartES5: isIdentifierPartES5,
          isIdentifierStartES6: isIdentifierStartES6,
          isIdentifierPartES6: isIdentifierPartES6
        };
      }());
      var _code = exports$8;
      var exports$1$6 = {};
      (function () {
        var code = _code;
        function isStrictModeReservedWordES6(id) {
          switch (id) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
          }
        }
        function isKeywordES5(id, strict) {
          if (!strict && id === "yield") {
            return false;
          }
          return isKeywordES6(id, strict);
        }
        function isKeywordES6(id, strict) {
          if (strict && isStrictModeReservedWordES6(id)) {
            return true;
          }
          switch (id.length) {
          case 2:
            return id === "if" || id === "in" || id === "do";
          case 3:
            return id === "var" || id === "for" || id === "new" || id === "try";
          case 4:
            return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
          case 5:
            return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
          case 6:
            return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
          case 7:
            return id === "default" || id === "finally" || id === "extends";
          case 8:
            return id === "function" || id === "continue" || id === "debugger";
          case 10:
            return id === "instanceof";
          default:
            return false;
          }
        }
        function isReservedWordES5(id, strict) {
          return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
        }
        function isReservedWordES6(id, strict) {
          return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
        }
        function isRestrictedWord(id) {
          return id === "eval" || id === "arguments";
        }
        function isIdentifierNameES5(id) {
          var i, iz, ch;
          if (id.length === 0) {
            return false;
          }
          ch = id.charCodeAt(0);
          if (!code.isIdentifierStartES5(ch)) {
            return false;
          }
          for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPartES5(ch)) {
              return false;
            }
          }
          return true;
        }
        function decodeUtf16(lead, trail) {
          return (lead - 55296) * 1024 + (trail - 56320) + 65536;
        }
        function isIdentifierNameES6(id) {
          var i, iz, ch, lowCh, check;
          if (id.length === 0) {
            return false;
          }
          check = code.isIdentifierStartES6;
          for (i = 0, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (55296 <= ch && ch <= 56319) {
              ++i;
              if (i >= iz) {
                return false;
              }
              lowCh = id.charCodeAt(i);
              if (!(56320 <= lowCh && lowCh <= 57343)) {
                return false;
              }
              ch = decodeUtf16(ch, lowCh);
            }
            if (!check(ch)) {
              return false;
            }
            check = code.isIdentifierPartES6;
          }
          return true;
        }
        function isIdentifierES5(id, strict) {
          return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
        }
        function isIdentifierES6(id, strict) {
          return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
        }
        exports$1$6 = {
          isKeywordES5: isKeywordES5,
          isKeywordES6: isKeywordES6,
          isReservedWordES5: isReservedWordES5,
          isReservedWordES6: isReservedWordES6,
          isRestrictedWord: isRestrictedWord,
          isIdentifierNameES5: isIdentifierNameES5,
          isIdentifierNameES6: isIdentifierNameES6,
          isIdentifierES5: isIdentifierES5,
          isIdentifierES6: isIdentifierES6
        };
      }());
      var _keyword = exports$1$6;
      var exports$2$1 = exports('al', {});
      (function () {
        exports$2$1.ast = _ast;
        exports$2$1.code = _code;
        exports$2$1.keyword = _keyword;
      }());
      const ast = exports$2$1.ast, code = exports$2$1.code, keyword = exports$2$1.keyword; exports({ am: ast, an: code, ao: keyword });

      var __varRecorder__$c = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/lib/stringify.js", __contextModule__);

      var __moduleMeta__$b = {
        pathInPackage: function pathInPackage() {
          return "./lib/stringify.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ast",
            version: "0.11.3"
          };
        }
      };

      var ESCODEGEN = __varRecorder__$c["lively.ast/lib/stringify.js__define__"]("ESCODEGEN", "function", function () {
        var Syntax, Precedence, BinaryPrecedence, SourceNode, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;
        Syntax = exports$a.Syntax;

        function isExpression(node) {
          return CodeGenerator.Expression.hasOwnProperty(node.type);
        }

        function isStatement(node) {
          return CodeGenerator.Statement.hasOwnProperty(node.type);
        }

        Precedence = {
          Sequence: 0,
          Yield: 1,
          Assignment: 1,
          Conditional: 2,
          ArrowFunction: 2,
          NullishCoalescing: 3,
          LogicalOR: 3,
          LogicalAND: 4,
          BitwiseOR: 5,
          BitwiseXOR: 6,
          BitwiseAND: 7,
          Equality: 8,
          Relational: 9,
          BitwiseSHIFT: 10,
          Additive: 11,
          Multiplicative: 12,
          Exponentiation: 13,
          Await: 14,
          Unary: 14,
          Postfix: 15,
          OptionalChaining: 16,
          Call: 17,
          New: 18,
          TaggedTemplate: 19,
          Member: 20,
          Primary: 21
        };
        BinaryPrecedence = {
          "??": Precedence.NullishCoalescing,
          "||": Precedence.LogicalOR,
          "&&": Precedence.LogicalAND,
          "|": Precedence.BitwiseOR,
          "^": Precedence.BitwiseXOR,
          "&": Precedence.BitwiseAND,
          "==": Precedence.Equality,
          "!=": Precedence.Equality,
          "===": Precedence.Equality,
          "!==": Precedence.Equality,
          is: Precedence.Equality,
          isnt: Precedence.Equality,
          "<": Precedence.Relational,
          ">": Precedence.Relational,
          "<=": Precedence.Relational,
          ">=": Precedence.Relational,
          "in": Precedence.Relational,
          "instanceof": Precedence.Relational,
          "<<": Precedence.BitwiseSHIFT,
          ">>": Precedence.BitwiseSHIFT,
          ">>>": Precedence.BitwiseSHIFT,
          "+": Precedence.Additive,
          "-": Precedence.Additive,
          "*": Precedence.Multiplicative,
          "%": Precedence.Multiplicative,
          "/": Precedence.Multiplicative,
          "**": Precedence.Exponentiation
        };
        var F_ALLOW_IN = 1;
        var F_ALLOW_CALL = 1 << 1;
        var F_ALLOW_UNPARATH_NEW = 1 << 2;
        var F_FUNC_BODY = 1 << 3;
        var F_DIRECTIVE_CTX = 1 << 4;
        var F_SEMICOLON_OPT = 1 << 5;
        var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW;
        var E_TTF = F_ALLOW_IN | F_ALLOW_CALL;
        var E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW;
        var E_TFF = F_ALLOW_IN;
        var E_FFT = F_ALLOW_UNPARATH_NEW;
        var E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;
        var S_TFFF = F_ALLOW_IN;
        var S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT;
        var S_FFFF = 0;
        var S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX;
        var S_TTFF = F_ALLOW_IN | F_FUNC_BODY;

        function getDefaultOptions() {
          return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
              indent: {
                style: "    ",
                base: 0,
                adjustMultilineComment: false
              },
              newline: "\n",
              space: " ",
              json: false,
              renumber: false,
              hexadecimal: false,
              quotes: "single",
              escapeless: false,
              compact: false,
              parentheses: true,
              semicolons: true,
              safeConcatenation: false,
              preserveBlankLines: false
            },
            moz: {
              comprehensionExpressionStartsWithAssignment: false,
              starlessGenerator: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            raw: true,
            verbatim: null,
            sourceCode: null
          };
        }

        function stringRepeat(str, num) {
          var result = "";

          for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
              result += str;
            }
          }

          return result;
        }

        function hasLineTerminator(str) {
          return /[\r\n]/g.test(str);
        }

        function endsWithLineTerminator(str) {
          var len = str.length;
          return len && exports$2$1.code.isLineTerminator(str.charCodeAt(len - 1));
        }

        function merge(target, override) {
          var key;

          for (key in override) {
            if (override.hasOwnProperty(key)) {
              target[key] = override[key];
            }
          }

          return target;
        }

        function updateDeeply(target, override) {
          var key, val;

          function isHashObject(target) {
            return _typeof(target) === "object" && target instanceof Object && !(target instanceof RegExp);
          }

          for (key in override) {
            if (override.hasOwnProperty(key)) {
              val = override[key];

              if (isHashObject(val)) {
                if (isHashObject(target[key])) {
                  updateDeeply(target[key], val);
                } else {
                  target[key] = updateDeeply({}, val);
                }
              } else {
                target[key] = val;
              }
            }
          }

          return target;
        }

        function generateNumber(value) {
          var result, point, temp, exponent, pos;

          if (value !== value) {
            throw new Error("Numeric literal whose value is NaN");
          }

          if (value < 0 || value === 0 && 1 / value < 0) {
            throw new Error("Numeric literal whose value is negative");
          }

          if (value === 1 / 0) {
            return json ? "null" : renumber ? "1e400" : "1e+400";
          }

          result = "" + value;

          if (!renumber || result.length < 3) {
            return result;
          }

          point = result.indexOf(".");

          if (!json && result.charCodeAt(0) === 48 && point === 1) {
            point = 0;
            result = result.slice(1);
          }

          temp = result;
          result = result.replace("e+", "e");
          exponent = 0;

          if ((pos = temp.indexOf("e")) > 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
          }

          if (point >= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + "";
          }

          pos = 0;

          while (temp.charCodeAt(temp.length + pos - 1) === 48) {
            --pos;
          }

          if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
          }

          if (exponent !== 0) {
            temp += "e" + exponent;
          }

          if ((temp.length < result.length || hexadecimal && value > 1000000000000 && Math.floor(value) === value && (temp = "0x" + value.toString(16)).length < result.length) && +temp === value) {
            result = temp;
          }

          return result;
        }

        function escapeRegExpCharacter(ch, previousIsBackslash) {
          if ((ch & ~1) === 8232) {
            return (previousIsBackslash ? "u" : "\\u") + (ch === 8232 ? "2028" : "2029");
          } else if (ch === 10 || ch === 13) {
            return (previousIsBackslash ? "" : "\\") + (ch === 10 ? "n" : "r");
          }

          return String.fromCharCode(ch);
        }

        function generateRegExp(reg) {
          var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;
          result = reg.toString();

          if (reg.source) {
            match = result.match(/\/([^/]*)$/);

            if (!match) {
              return result;
            }

            flags = match[1];
            result = "";
            characterInBrack = false;
            previousIsBackslash = false;

            for (i = 0, iz = reg.source.length; i < iz; ++i) {
              ch = reg.source.charCodeAt(i);

              if (!previousIsBackslash) {
                if (characterInBrack) {
                  if (ch === 93) {
                    characterInBrack = false;
                  }
                } else {
                  if (ch === 47) {
                    result += "\\";
                  } else if (ch === 91) {
                    characterInBrack = true;
                  }
                }

                result += escapeRegExpCharacter(ch, previousIsBackslash);
                previousIsBackslash = ch === 92;
              } else {
                result += escapeRegExpCharacter(ch, previousIsBackslash);
                previousIsBackslash = false;
              }
            }

            return "/" + result + "/" + flags;
          }

          return result;
        }

        function escapeAllowedCharacter(code, next) {
          var hex;

          if (code === 8) {
            return "\\b";
          }

          if (code === 12) {
            return "\\f";
          }

          if (code === 9) {
            return "\\t";
          }

          hex = code.toString(16).toUpperCase();

          if (json || code > 255) {
            return "\\u" + "0000".slice(hex.length) + hex;
          } else if (code === 0 && !exports$2$1.code.isDecimalDigit(next)) {
            return "\\0";
          } else if (code === 11) {
            return "\\x0B";
          } else {
            return "\\x" + "00".slice(hex.length) + hex;
          }
        }

        function escapeDisallowedCharacter(code) {
          if (code === 92) {
            return "\\\\";
          }

          if (code === 10) {
            return "\\n";
          }

          if (code === 13) {
            return "\\r";
          }

          if (code === 8232) {
            return "\\u2028";
          }

          if (code === 8233) {
            return "\\u2029";
          }

          throw new Error("Incorrectly classified character");
        }

        function escapeDirective(str) {
          var i, iz, code, quote;
          quote = quotes === "double" ? "\"" : "'";

          for (i = 0, iz = str.length; i < iz; ++i) {
            code = str.charCodeAt(i);

            if (code === 39) {
              quote = "\"";
              break;
            } else if (code === 34) {
              quote = "'";
              break;
            } else if (code === 92) {
              ++i;
            }
          }

          return quote + str + quote;
        }

        function escapeString(str) {
          var result = "";
          var i;
          var len;
          var code;
          var singleQuotes = 0;
          var doubleQuotes = 0;
          var single;
          var quote;

          for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);

            if (code === 39) {
              ++singleQuotes;
            } else if (code === 34) {
              ++doubleQuotes;
            } else if (code === 47 && json) {
              result += "\\";
            } else if (exports$2$1.code.isLineTerminator(code) || code === 92) {
              result += escapeDisallowedCharacter(code);
              continue;
            } else if (!exports$2$1.code.isIdentifierPartES5(code) && (json && code < 32 || !json && !escapeless && (code < 32 || code > 126))) {
              result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
              continue;
            }

            result += String.fromCharCode(code);
          }

          single = !(quotes === "double" || quotes === "auto" && doubleQuotes < singleQuotes);
          quote = single ? "'" : "\"";

          if (!(single ? singleQuotes : doubleQuotes)) {
            return quote + result + quote;
          }

          str = result;
          result = quote;

          for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);

            if (code === 39 && single || code === 34 && !single) {
              result += "\\";
            }

            result += String.fromCharCode(code);
          }

          return result + quote;
        }

        function flattenToString(arr) {
          var i;
          var iz;
          var elem;
          var result = "";

          for (i = 0, iz = arr.length; i < iz; ++i) {
            elem = arr[i];
            result += Array.isArray(elem) ? flattenToString(elem) : elem;
          }

          return result;
        }

        function toSourceNodeWhenNeeded(generated, node) {
          if (!sourceMap) {
            if (Array.isArray(generated)) {
              return flattenToString(generated);
            } else {
              return generated;
            }
          }

          if (node == null) {
            if (generated instanceof SourceNode) {
              return generated;
            } else {
              node = {};
            }
          }

          if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
          }

          return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);
        }

        function noEmptySpace() {
          return space || " ";
        }

        function join(left, right) {
          var leftSource, rightSource, leftCharCode, rightCharCode;
          leftSource = toSourceNodeWhenNeeded(left).toString();

          if (leftSource.length === 0) {
            return [right];
          }

          rightSource = toSourceNodeWhenNeeded(right).toString();

          if (rightSource.length === 0) {
            return [left];
          }

          leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
          rightCharCode = rightSource.charCodeAt(0);

          if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || exports$2$1.code.isIdentifierPartES5(leftCharCode) && exports$2$1.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 47 && rightCharCode === 105) {
            return [left, noEmptySpace(), right];
          } else if (exports$2$1.code.isWhiteSpace(leftCharCode) || exports$2$1.code.isLineTerminator(leftCharCode) || exports$2$1.code.isWhiteSpace(rightCharCode) || exports$2$1.code.isLineTerminator(rightCharCode)) {
            return [left, right];
          }

          return [left, space, right];
        }

        function addIndent(stmt) {
          return [base, stmt];
        }

        function withIndent(fn) {
          var previousBase;
          previousBase = base;
          base += indent;
          fn(base);
          base = previousBase;
        }

        function calculateSpaces(str) {
          var i;

          for (i = str.length - 1; i >= 0; --i) {
            if (exports$2$1.code.isLineTerminator(str.charCodeAt(i))) {
              break;
            }
          }

          return str.length - 1 - i;
        }

        function adjustMultilineComment(value, specialBase) {
          var array, i, len, line, j, spaces, previousBase, sn;
          array = value.split(/\r\n|[\r\n]/);
          spaces = Number.MAX_VALUE;

          for (i = 1, len = array.length; i < len; ++i) {
            line = array[i];
            j = 0;

            while (j < line.length && exports$2$1.code.isWhiteSpace(line.charCodeAt(j))) {
              ++j;
            }

            if (spaces > j) {
              spaces = j;
            }
          }

          if (typeof specialBase !== "undefined") {
            previousBase = base;

            if (array[1][spaces] === "*") {
              specialBase += " ";
            }

            base = specialBase;
          } else {
            if (spaces & 1) {
              --spaces;
            }

            previousBase = base;
          }

          for (i = 1, len = array.length; i < len; ++i) {
            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
            array[i] = sourceMap ? sn.join("") : sn;
          }

          base = previousBase;
          return array.join("\n");
        }

        function generateComment(comment, specialBase) {
          if (comment.type === "Line") {
            if (endsWithLineTerminator(comment.value)) {
              return "//" + comment.value;
            } else {
              var result = "//" + comment.value;

              if (!preserveBlankLines) {
                result += "\n";
              }

              return result;
            }
          }

          if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment("/*" + comment.value + "*/", specialBase);
          }

          return "/*" + comment.value + "*/";
        }

        function addComments(stmt, result) {
          var i, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range, prevRange, prefix, infix, suffix, count;

          if (stmt.leadingComments && stmt.leadingComments.length > 0) {
            save = result;

            if (preserveBlankLines) {
              comment = stmt.leadingComments[0];
              result = [];
              extRange = comment.extendedRange;
              range = comment.range;
              prefix = sourceCode.substring(extRange[0], range[0]);
              count = (prefix.match(/\n/g) || []).length;

              if (count > 0) {
                result.push(stringRepeat("\n", count));
                result.push(addIndent(generateComment(comment)));
              } else {
                result.push(prefix);
                result.push(generateComment(comment));
              }

              prevRange = range;

              for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
                comment = stmt.leadingComments[i];
                range = comment.range;
                infix = sourceCode.substring(prevRange[1], range[0]);
                count = (infix.match(/\n/g) || []).length;
                result.push(stringRepeat("\n", count));
                result.push(addIndent(generateComment(comment)));
                prevRange = range;
              }

              suffix = sourceCode.substring(range[1], extRange[1]);
              count = (suffix.match(/\n/g) || []).length;
              result.push(stringRepeat("\n", count));
            } else {
              comment = stmt.leadingComments[0];
              result = [];

              if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                result.push("\n");
              }

              result.push(generateComment(comment));

              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push("\n");
              }

              for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                comment = stmt.leadingComments[i];
                fragment = [generateComment(comment)];

                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                  fragment.push("\n");
                }

                result.push(addIndent(fragment));
              }
            }

            result.push(addIndent(save));
          }

          if (stmt.trailingComments) {
            if (preserveBlankLines) {
              comment = stmt.trailingComments[0];
              extRange = comment.extendedRange;
              range = comment.range;
              prefix = sourceCode.substring(extRange[0], range[0]);
              count = (prefix.match(/\n/g) || []).length;

              if (count > 0) {
                result.push(stringRepeat("\n", count));
                result.push(addIndent(generateComment(comment)));
              } else {
                result.push(prefix);
                result.push(generateComment(comment));
              }
            } else {
              tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
              specialBase = stringRepeat(" ", calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));

              for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                comment = stmt.trailingComments[i];

                if (tailingToStatement) {
                  if (i === 0) {
                    result = [result, indent];
                  } else {
                    result = [result, specialBase];
                  }

                  result.push(generateComment(comment, specialBase));
                } else {
                  result = [result, addIndent(generateComment(comment))];
                }

                if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                  result = [result, "\n"];
                }
              }
            }
          }

          return result;
        }

        function generateBlankLines(start, end, result) {
          var j;
          var newlineCount = 0;

          for (j = start; j < end; j++) {
            if (sourceCode[j] === "\n") {
              newlineCount++;
            }
          }

          for (j = 1; j < newlineCount; j++) {
            result.push(newline);
          }
        }

        function parenthesize(text, current, should) {
          if (current < should) {
            return ["(", text, ")"];
          }

          return text;
        }

        function generateVerbatimString(string) {
          var i, iz, result;
          result = string.split(/\r\n|\n/);

          for (i = 1, iz = result.length; i < iz; i++) {
            result[i] = newline + base + result[i];
          }

          return result;
        }

        function generateVerbatim(expr, precedence) {
          var verbatim, result, prec;
          verbatim = expr[extra.verbatim];

          if (typeof verbatim === "string") {
            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
          } else {
            result = generateVerbatimString(verbatim.content);
            prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;
            result = parenthesize(result, prec, precedence);
          }

          return toSourceNodeWhenNeeded(result, expr);
        }

        function CodeGenerator() {}

        CodeGenerator.prototype.maybeBlock = function (stmt, flags) {
          var result;
          var noLeadingComment;
          var that = this;
          noLeadingComment = !extra.comment || !stmt.leadingComments;

          if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
            return [space, this.generateStatement(stmt, flags)];
          }

          if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
            return ";";
          }

          withIndent(function () {
            result = [newline, addIndent(that.generateStatement(stmt, flags))];
          });
          return result;
        };

        CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {
          var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());

          if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
            return [result, space];
          }

          if (ends) {
            return [result, base];
          }

          return [result, newline, base];
        };

        function generateIdentifier(node) {
          var identifierName = node.name;

          if (node.type === Syntax.PrivateIdentifier) {
            identifierName = "#" + identifierName;
          }

          return toSourceNodeWhenNeeded(identifierName, node);
        }

        function generateAsyncPrefix(node, spaceRequired) {
          return node.async ? "async" + (spaceRequired ? noEmptySpace() : space) : "";
        }

        function generateStarSuffix(node) {
          var isGenerator = node.generator && !extra.moz.starlessGenerator;
          return isGenerator ? "*" + space : "";
        }

        function generateMethodPrefix(prop) {
          var func = prop.value;
          var prefix = "";

          if (func.async) {
            prefix += generateAsyncPrefix(func, !prop.computed);
          }

          if (func.generator) {
            prefix += generateStarSuffix(func) ? "*" : "";
          }

          return prefix;
        }

        CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {
          if (node.type === Syntax.Identifier) {
            return generateIdentifier(node);
          }

          return this.generateExpression(node, precedence, flags);
        };

        CodeGenerator.prototype.generateFunctionParams = function (node) {
          var i, iz, result, hasDefault;
          hasDefault = false;

          if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
            result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
          } else {
            result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
            result.push("(");

            if (node.defaults) {
              hasDefault = true;
            }

            for (i = 0, iz = node.params.length; i < iz; ++i) {
              if (hasDefault && node.defaults[i]) {
                result.push(this.generateAssignment(node.params[i], node.defaults[i], "=", Precedence.Assignment, E_TTT));
              } else {
                result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
              }

              if (i + 1 < iz) {
                result.push("," + space);
              }
            }

            if (node.rest) {
              if (node.params.length) {
                result.push("," + space);
              }

              result.push("...");
              result.push(generateIdentifier(node.rest));
            }

            result.push(")");
          }

          return result;
        };

        CodeGenerator.prototype.generateFunctionBody = function (node) {
          var result, expr;
          result = this.generateFunctionParams(node);

          if (node.type === Syntax.ArrowFunctionExpression) {
            result.push(space);
            result.push("=>");
          }

          if (node.expression) {
            result.push(space);
            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);

            if (expr.toString().charAt(0) === "{") {
              expr = ["(", expr, ")"];
            }

            result.push(expr);
          } else {
            result.push(this.maybeBlock(node.body, S_TTFF));
          }

          return result;
        };

        CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {
          var result = ["for" + (stmt["await"] ? noEmptySpace() + "await" : "") + space + "("];
          var that = this;
          withIndent(function () {
            if (stmt.left.type === Syntax.VariableDeclaration) {
              withIndent(function () {
                result.push(stmt.left.kind + noEmptySpace());
                result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
              });
            } else {
              result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
            }

            result = join(result, operator);
            result = [join(result, that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)), ")"];
          });
          result.push(this.maybeBlock(stmt.body, flags));
          return result;
        };

        CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {
          var result = [];

          if (computed) {
            result.push("[");
          }

          result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));

          if (computed) {
            result.push("]");
          }

          return result;
        };

        CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {
          if (Precedence.Assignment < precedence) {
            flags |= F_ALLOW_IN;
          }

          return parenthesize([this.generateExpression(left, Precedence.Call, flags), space + operator + space, this.generateExpression(right, Precedence.Assignment, flags)], Precedence.Assignment, precedence);
        };

        CodeGenerator.prototype.semicolon = function (flags) {
          if (!semicolons && flags & F_SEMICOLON_OPT) {
            return "";
          }

          return ";";
        };

        CodeGenerator.Statement = {
          BlockStatement: function BlockStatement(stmt, flags) {
            var range;
            var content;
            var result = ["{", newline];
            var that = this;
            withIndent(function () {
              if (stmt.body.length === 0 && preserveBlankLines) {
                range = stmt.range;

                if (range[1] - range[0] > 2) {
                  content = sourceCode.substring(range[0] + 1, range[1] - 1);

                  if (content[0] === "\n") {
                    result = ["{"];
                  }

                  result.push(content);
                }
              }

              var i, iz, fragment, bodyFlags;
              bodyFlags = S_TFFF;

              if (flags & F_FUNC_BODY) {
                bodyFlags |= F_DIRECTIVE_CTX;
              }

              for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                if (preserveBlankLines) {
                  if (i === 0) {
                    if (stmt.body[0].leadingComments) {
                      range = stmt.body[0].leadingComments[0].extendedRange;
                      content = sourceCode.substring(range[0], range[1]);

                      if (content[0] === "\n") {
                        result = ["{"];
                      }
                    }

                    if (!stmt.body[0].leadingComments) {
                      generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                    }
                  }

                  if (i > 0) {
                    if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                      generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                    }
                  }
                }

                if (i === iz - 1) {
                  bodyFlags |= F_SEMICOLON_OPT;
                }

                if (stmt.body[i].leadingComments && preserveBlankLines) {
                  fragment = that.generateStatement(stmt.body[i], bodyFlags);
                } else {
                  fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
                }

                result.push(fragment);

                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                  if (preserveBlankLines && i < iz - 1) {
                    if (!stmt.body[i + 1].leadingComments) {
                      result.push(newline);
                    }
                  } else {
                    result.push(newline);
                  }
                }

                if (preserveBlankLines) {
                  if (i === iz - 1) {
                    if (!stmt.body[i].trailingComments) {
                      generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                    }
                  }
                }
              }
            });
            result.push(addIndent("}"));
            return result;
          },
          BreakStatement: function BreakStatement(stmt, flags) {
            if (stmt.label) {
              return "break " + stmt.label.name + this.semicolon(flags);
            }

            return "break" + this.semicolon(flags);
          },
          ContinueStatement: function ContinueStatement(stmt, flags) {
            if (stmt.label) {
              return "continue " + stmt.label.name + this.semicolon(flags);
            }

            return "continue" + this.semicolon(flags);
          },
          ClassBody: function ClassBody(stmt, flags) {
            var result = ["{", newline];
            var that = this;
            withIndent(function (indent) {
              var i, iz;

              for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                result.push(indent);
                result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));

                if (i + 1 < iz) {
                  result.push(newline);
                }
              }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }

            result.push(base);
            result.push("}");
            return result;
          },
          ClassDeclaration: function ClassDeclaration(stmt, flags) {
            var result = [];
            var fragment;

            if (stmt.decorators.length) {
              var _iterator = _createForOfIteratorHelper(stmt.decorators),
                  _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var dec = _step.value;
                  result.push(this.generateStatement(dec));
                  result.push(base);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }

            result.push("class");

            if (stmt.id) {
              result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
            }

            if (stmt.superClass) {
              fragment = join("extends", this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));
              result = join(result, fragment);
            }

            result.push(space);
            result.push(this.generateStatement(stmt.body, S_TFFT));
            return result;
          },
          DirectiveStatement: function DirectiveStatement(stmt, flags) {
            if (extra.raw && stmt.raw) {
              return stmt.raw + this.semicolon(flags);
            }

            return escapeDirective(stmt.directive) + this.semicolon(flags);
          },
          DoWhileStatement: function DoWhileStatement(stmt, flags) {
            var result = join("do", this.maybeBlock(stmt.body, S_TFFF));
            result = this.maybeBlockSuffix(stmt.body, result);
            return join(result, ["while" + space + "(", this.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ")" + this.semicolon(flags)]);
          },
          CatchClause: function CatchClause(stmt, flags) {
            var result;
            var that = this;
            withIndent(function () {
              var guard;

              if (stmt.param) {
                result = ["catch" + space + "(", that.generateExpression(stmt.param, Precedence.Sequence, E_TTT), ")"];

                if (stmt.guard) {
                  guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
                  result.splice(2, 0, " if ", guard);
                }
              } else {
                result = ["catch"];
              }
            });
            result.push(this.maybeBlock(stmt.body, S_TFFF));
            return result;
          },
          DebuggerStatement: function DebuggerStatement(stmt, flags) {
            return "debugger" + this.semicolon(flags);
          },
          EmptyStatement: function EmptyStatement(stmt, flags) {
            return ";";
          },
          ExportDefaultDeclaration: function ExportDefaultDeclaration(stmt, flags) {
            var result = ["export"];
            var bodyFlags;
            bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
            result = join(result, "default");

            if (isStatement(stmt.declaration)) {
              result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
            } else {
              result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
            }

            return result;
          },
          ExportNamedDeclaration: function ExportNamedDeclaration(stmt, flags) {
            var result = ["export"];
            var bodyFlags;
            var that = this;
            bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;

            if (stmt.declaration) {
              return join(result, this.generateStatement(stmt.declaration, bodyFlags));
            }

            if (stmt.specifiers) {
              if (stmt.specifiers.length === 0) {
                result = join(result, "{" + space + "}");
              } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
                result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
              } else {
                result = join(result, "{");
                withIndent(function (indent) {
                  var i, iz;
                  result.push(newline);

                  for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                    result.push(indent);
                    result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));

                    if (i + 1 < iz) {
                      result.push("," + newline);
                    }
                  }
                });

                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                  result.push(newline);
                }

                result.push(base + "}");
              }

              if (stmt.source) {
                result = join(result, ["from" + space, this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);
              } else {
                result.push(this.semicolon(flags));
              }
            }

            return result;
          },
          ExportAllDeclaration: function ExportAllDeclaration(stmt, flags) {
            var result = ["export" + space, "*" + space];

            if (stmt.exported) {
              result.push("as " + stmt.exported.name + " ");
            }

            result = join(result, ["from" + space, this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);
            return result;
          },
          ExpressionStatement: function ExpressionStatement(stmt, flags) {
            var result, fragment;

            function isClassPrefixed(fragment) {
              var code;

              if (fragment.slice(0, 5) !== "class") {
                return false;
              }

              code = fragment.charCodeAt(5);
              return code === 123 || exports$2$1.code.isWhiteSpace(code) || exports$2$1.code.isLineTerminator(code);
            }

            function isFunctionPrefixed(fragment) {
              var code;

              if (fragment.slice(0, 8) !== "function") {
                return false;
              }

              code = fragment.charCodeAt(8);
              return code === 40 || exports$2$1.code.isWhiteSpace(code) || code === 42 || exports$2$1.code.isLineTerminator(code);
            }

            function isAsyncPrefixed(fragment) {
              var code, i, iz;

              if (fragment.slice(0, 5) !== "async") {
                return false;
              }

              if (!exports$2$1.code.isWhiteSpace(fragment.charCodeAt(5))) {
                return false;
              }

              for (i = 6, iz = fragment.length; i < iz; ++i) {
                if (!exports$2$1.code.isWhiteSpace(fragment.charCodeAt(i))) {
                  break;
                }
              }

              if (i === iz) {
                return false;
              }

              if (fragment.slice(i, i + 8) !== "function") {
                return false;
              }

              code = fragment.charCodeAt(i + 8);
              return code === 40 || exports$2$1.code.isWhiteSpace(code) || code === 42 || exports$2$1.code.isLineTerminator(code);
            }

            result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
            fragment = toSourceNodeWhenNeeded(result).toString();

            if (fragment.charCodeAt(0) === 123 || isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === "string") {
              result = ["(", result, ")" + this.semicolon(flags)];
            } else {
              result.push(this.semicolon(flags));
            }

            return result;
          },
          ImportDeclaration: function ImportDeclaration(stmt, flags) {
            var result;
            var cursor;
            var that = this;

            if (stmt.specifiers.length === 0) {
              return ["import", space, this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)];
            }

            result = ["import"];
            cursor = 0;

            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
              result = join(result, [this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);
              ++cursor;
            }

            if (stmt.specifiers[cursor]) {
              if (cursor !== 0) {
                result.push(",");
              }

              if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
                result = join(result, [space, this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);
              } else {
                result.push(space + "{");

                if (stmt.specifiers.length - cursor === 1) {
                  result.push(space);
                  result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
                  result.push(space + "}" + space);
                } else {
                  withIndent(function (indent) {
                    var i, iz;
                    result.push(newline);

                    for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                      result.push(indent);
                      result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));

                      if (i + 1 < iz) {
                        result.push("," + newline);
                      }
                    }
                  });

                  if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                  }

                  result.push(base + "}" + space);
                }
              }
            }

            result = join(result, ["from" + space, this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);
            return result;
          },
          VariableDeclarator: function VariableDeclarator(stmt, flags) {
            var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;

            if (stmt.init) {
              return [this.generateExpression(stmt.id, Precedence.Assignment, itemFlags), space, "=", space, this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)];
            }

            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
          },
          VariableDeclaration: function VariableDeclaration(stmt, flags) {
            var result;
            var i;
            var iz;
            var node;
            var bodyFlags;
            var that = this;
            result = [stmt.kind];
            bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;

            function block() {
              node = stmt.declarations[0];

              if (extra.comment && node.leadingComments) {
                result.push("\n");
                result.push(addIndent(that.generateStatement(node, bodyFlags)));
              } else {
                result.push(noEmptySpace());
                result.push(that.generateStatement(node, bodyFlags));
              }

              for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
                node = stmt.declarations[i];

                if (extra.comment && node.leadingComments) {
                  result.push("," + newline);
                  result.push(addIndent(that.generateStatement(node, bodyFlags)));
                } else {
                  result.push("," + space);
                  result.push(that.generateStatement(node, bodyFlags));
                }
              }
            }

            if (stmt.declarations.length > 1) {
              withIndent(block);
            } else {
              block();
            }

            result.push(this.semicolon(flags));
            return result;
          },
          StaticBlock: function StaticBlock(stmt, flags) {
            return ["static" + space, this.BlockStatement(stmt, flags)];
          },
          ThrowStatement: function ThrowStatement(stmt, flags) {
            return [join("throw", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];
          },
          TryStatement: function TryStatement(stmt, flags) {
            var result, i, iz, guardedHandlers;
            result = ["try", this.maybeBlock(stmt.block, S_TFFF)];
            result = this.maybeBlockSuffix(stmt.block, result);

            if (stmt.handlers) {
              for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
                result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));

                if (stmt.finalizer || i + 1 !== iz) {
                  result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
                }
              }
            } else {
              guardedHandlers = stmt.guardedHandlers || [];

              for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
                result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));

                if (stmt.finalizer || i + 1 !== iz) {
                  result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
                }
              }

              if (stmt.handler) {
                if (Array.isArray(stmt.handler)) {
                  for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));

                    if (stmt.finalizer || i + 1 !== iz) {
                      result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                    }
                  }
                } else {
                  result = join(result, this.generateStatement(stmt.handler, S_TFFF));

                  if (stmt.finalizer) {
                    result = this.maybeBlockSuffix(stmt.handler.body, result);
                  }
                }
              }
            }

            if (stmt.finalizer) {
              result = join(result, ["finally", this.maybeBlock(stmt.finalizer, S_TFFF)]);
            }

            return result;
          },
          SwitchStatement: function SwitchStatement(stmt, flags) {
            var result;
            var fragment;
            var i;
            var iz;
            var bodyFlags;
            var that = this;
            withIndent(function () {
              result = ["switch" + space + "(", that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT), ")" + space + "{" + newline];
            });

            if (stmt.cases) {
              bodyFlags = S_TFFF;

              for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
                if (i === iz - 1) {
                  bodyFlags |= F_SEMICOLON_OPT;
                }

                fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
                result.push(fragment);

                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                  result.push(newline);
                }
              }
            }

            result.push(addIndent("}"));
            return result;
          },
          SwitchCase: function SwitchCase(stmt, flags) {
            var result;
            var fragment;
            var i;
            var iz;
            var bodyFlags;
            var that = this;
            withIndent(function () {
              if (stmt.test) {
                result = [join("case", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)), ":"];
              } else {
                result = ["default:"];
              }

              i = 0;
              iz = stmt.consequent.length;

              if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
                fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
                result.push(fragment);
                i = 1;
              }

              if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
              }

              bodyFlags = S_TFFF;

              for (; i < iz; ++i) {
                if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
                  bodyFlags |= F_SEMICOLON_OPT;
                }

                fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
                result.push(fragment);

                if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                  result.push(newline);
                }
              }
            });
            return result;
          },
          IfStatement: function IfStatement(stmt, flags) {
            var result;
            var bodyFlags;
            var semicolonOptional;
            var that = this;
            withIndent(function () {
              result = ["if" + space + "(", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ")"];
            });
            semicolonOptional = flags & F_SEMICOLON_OPT;
            bodyFlags = S_TFFF;

            if (semicolonOptional) {
              bodyFlags |= F_SEMICOLON_OPT;
            }

            if (stmt.alternate) {
              result.push(this.maybeBlock(stmt.consequent, S_TFFF));
              result = this.maybeBlockSuffix(stmt.consequent, result);

              if (stmt.alternate.type === Syntax.IfStatement) {
                result = join(result, ["else ", this.generateStatement(stmt.alternate, bodyFlags)]);
              } else {
                result = join(result, join("else", this.maybeBlock(stmt.alternate, bodyFlags)));
              }
            } else {
              result.push(this.maybeBlock(stmt.consequent, bodyFlags));
            }

            return result;
          },
          ForStatement: function ForStatement(stmt, flags) {
            var result;
            var that = this;
            withIndent(function () {
              result = ["for" + space + "("];

              if (stmt.init) {
                if (stmt.init.type === Syntax.VariableDeclaration) {
                  result.push(that.generateStatement(stmt.init, S_FFFF));
                } else {
                  result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
                  result.push(";");
                }
              } else {
                result.push(";");
              }

              if (stmt.test) {
                result.push(space);
                result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
                result.push(";");
              } else {
                result.push(";");
              }

              if (stmt.update) {
                result.push(space);
                result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
                result.push(")");
              } else {
                result.push(")");
              }
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
          },
          ForInStatement: function ForInStatement(stmt, flags) {
            return this.generateIterationForStatement("in", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
          },
          ForOfStatement: function ForOfStatement(stmt, flags) {
            return this.generateIterationForStatement("of", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
          },
          LabeledStatement: function LabeledStatement(stmt, flags) {
            return [stmt.label.name + ":", this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
          },
          Program: function Program(stmt, flags) {
            var result, fragment, i, iz, bodyFlags;
            iz = stmt.body.length;
            result = [safeConcatenation && iz > 0 ? "\n" : ""];
            bodyFlags = S_TFTF;

            for (i = 0; i < iz; ++i) {
              if (!safeConcatenation && i === iz - 1) {
                bodyFlags |= F_SEMICOLON_OPT;
              }

              if (preserveBlankLines) {
                if (i === 0) {
                  if (!stmt.body[0].leadingComments) {
                    generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
                  }
                }

                if (i > 0) {
                  if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                    generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                  }
                }
              }

              fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
              result.push(fragment);

              if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                if (preserveBlankLines) {
                  if (!stmt.body[i + 1].leadingComments) {
                    result.push(newline);
                  }
                } else {
                  result.push(newline);
                }
              }

              if (preserveBlankLines) {
                if (i === iz - 1) {
                  if (!stmt.body[i].trailingComments) {
                    generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                  }
                }
              }
            }

            return result;
          },
          FunctionDeclaration: function FunctionDeclaration(stmt, flags) {
            return [generateAsyncPrefix(stmt, true), "function", generateStarSuffix(stmt) || noEmptySpace(), stmt.id ? generateIdentifier(stmt.id) : "", this.generateFunctionBody(stmt)];
          },
          ReturnStatement: function ReturnStatement(stmt, flags) {
            if (stmt.argument) {
              return [join("return", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];
            }

            return ["return" + this.semicolon(flags)];
          },
          WhileStatement: function WhileStatement(stmt, flags) {
            var result;
            var that = this;
            withIndent(function () {
              result = ["while" + space + "(", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ")"];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
          },
          WithStatement: function WithStatement(stmt, flags) {
            var result;
            var that = this;
            withIndent(function () {
              result = ["with" + space + "(", that.generateExpression(stmt.object, Precedence.Sequence, E_TTT), ")"];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
          }
        };
        merge(CodeGenerator.prototype, CodeGenerator.Statement);
        CodeGenerator.Expression = {
          SequenceExpression: function SequenceExpression(expr, precedence, flags) {
            var result, i, iz;

            if (Precedence.Sequence < precedence) {
              flags |= F_ALLOW_IN;
            }

            result = [];

            for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
              result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));

              if (i + 1 < iz) {
                result.push("," + space);
              }
            }

            return parenthesize(result, Precedence.Sequence, precedence);
          },
          AssignmentExpression: function AssignmentExpression(expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
          },
          ArrowFunctionExpression: function ArrowFunctionExpression(expr, precedence, flags) {
            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
          },
          ConditionalExpression: function ConditionalExpression(expr, precedence, flags) {
            if (Precedence.Conditional < precedence) {
              flags |= F_ALLOW_IN;
            }

            return parenthesize([this.generateExpression(expr.test, Precedence.LogicalOR, flags), space + "?" + space, this.generateExpression(expr.consequent, Precedence.Assignment, flags), space + ":" + space, this.generateExpression(expr.alternate, Precedence.Assignment, flags)], Precedence.Conditional, precedence);
          },
          LogicalExpression: function LogicalExpression(expr, precedence, flags) {
            return this.BinaryExpression(expr, precedence, flags);
          },
          BinaryExpression: function BinaryExpression(expr, precedence, flags) {
            var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;
            currentPrecedence = BinaryPrecedence[expr.operator];
            leftPrecedence = currentPrecedence;
            rightPrecedence = currentPrecedence + 1;

            switch (expr.operator) {
              case "**":
                leftPrecedence = Precedence.Postfix;
                rightPrecedence = currentPrecedence;
                break;

              case "??":
                if (expr.left.type === Syntax.LogicalExpression && (expr.left.operator === "||" || expr.left.operator === "&&")) {
                  leftPrecedence = BinaryPrecedence[expr.left.operator] + 1;
                }

                if (expr.right.type === Syntax.LogicalExpression && expr.right.operator === "&&") {
                  rightPrecedence = BinaryPrecedence[expr.right.operator] + 1;
                }

                break;

              case "||":
                if (expr.left.type === Syntax.LogicalExpression && expr.left.operator === "??") {
                  leftPrecedence = BinaryPrecedence[expr.left.operator] + 1;
                }

                break;
            }

            if (currentPrecedence < precedence) {
              flags |= F_ALLOW_IN;
            }

            fragment = this.generateExpression(expr.left, leftPrecedence, flags);
            leftSource = fragment.toString();

            if (leftSource.charCodeAt(leftSource.length - 1) === 47 && exports$2$1.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
              result = [fragment, noEmptySpace(), expr.operator];
            } else {
              result = join(fragment, expr.operator);
            }

            fragment = this.generateExpression(expr.right, rightPrecedence, flags);

            if (expr.operator === "/" && fragment.toString().charAt(0) === "/" || expr.operator.slice(-1) === "<" && fragment.toString().slice(0, 3) === "!--") {
              result.push(noEmptySpace());
              result.push(fragment);
            } else {
              result = join(result, fragment);
            }

            if (expr.operator === "in" && !(flags & F_ALLOW_IN)) {
              return ["(", result, ")"];
            }

            return parenthesize(result, currentPrecedence, precedence);
          },
          CallExpression: function CallExpression(expr, precedence, flags) {
            var result, i, iz, isIIFE;
            result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];

            if (expr.optional) {
              result.push("?.");
            }

            result.push("(");

            for (i = 0, iz = expr["arguments"].length; i < iz; ++i) {
              result.push(this.generateExpression(expr["arguments"][i], Precedence.Assignment, E_TTT));

              if (i + 1 < iz) {
                result.push("," + space);
              }
            }

            result.push(")");

            if (!(flags & F_ALLOW_CALL)) {
              return ["(", result, ")"];
            }

            isIIFE = expr.callee.id === null && expr.callee.params.length === 0;
            return isIIFE ? parenthesize(result, precedence, Precedence.Call) : parenthesize(result, Precedence.Call, precedence);
          },
          ChainExpression: function ChainExpression(expr, precedence, flags) {
            if (Precedence.OptionalChaining < precedence) {
              flags |= F_ALLOW_CALL;
            }

            var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);
            return parenthesize(result, Precedence.OptionalChaining, precedence);
          },
          NewExpression: function NewExpression(expr, precedence, flags) {
            var result, length, i, iz, itemFlags;
            length = expr["arguments"].length;
            itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;
            result = join("new", this.generateExpression(expr.callee, Precedence.New, itemFlags));

            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
              result.push("(");

              for (i = 0, iz = length; i < iz; ++i) {
                result.push(this.generateExpression(expr["arguments"][i], Precedence.Assignment, E_TTT));

                if (i + 1 < iz) {
                  result.push("," + space);
                }
              }

              result.push(")");
            }

            return parenthesize(result, Precedence.New, precedence);
          },
          MemberExpression: function MemberExpression(expr, precedence, flags) {
            var result, fragment;
            result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)];

            if (expr.computed) {
              if (expr.optional) {
                result.push("?.");
              }

              result.push("[");
              result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
              result.push("]");
            } else {
              if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === "number") {
                fragment = toSourceNodeWhenNeeded(result).toString();

                if (fragment.indexOf(".") < 0 && !/[eExX]/.test(fragment) && exports$2$1.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)) {
                  result.push(" ");
                }
              }

              result.push(expr.optional ? "?." : ".");
              result.push(generateIdentifier(expr.property));
            }

            return parenthesize(result, Precedence.Member, precedence);
          },
          MetaProperty: function MetaProperty(expr, precedence, flags) {
            var result;
            result = [];
            result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
            result.push(".");
            result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
            return parenthesize(result, Precedence.Member, precedence);
          },
          UnaryExpression: function UnaryExpression(expr, precedence, flags) {
            var result, fragment, rightCharCode, leftSource, leftCharCode;
            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);

            if (space === "") {
              result = join(expr.operator, fragment);
            } else {
              result = [expr.operator];

              if (expr.operator.length > 2) {
                result = join(result, fragment);
              } else {
                leftSource = toSourceNodeWhenNeeded(result).toString();
                leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                rightCharCode = fragment.toString().charCodeAt(0);

                if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || exports$2$1.code.isIdentifierPartES5(leftCharCode) && exports$2$1.code.isIdentifierPartES5(rightCharCode)) {
                  result.push(noEmptySpace());
                  result.push(fragment);
                } else {
                  result.push(fragment);
                }
              }
            }

            return parenthesize(result, Precedence.Unary, precedence);
          },
          YieldExpression: function YieldExpression(expr, precedence, flags) {
            var result;

            if (expr.delegate) {
              result = "yield*";
            } else {
              result = "yield";
            }

            if (expr.argument) {
              result = join(result, this.generateExpression(expr.argument, Precedence.Yield, E_TTT));
            }

            return parenthesize(result, Precedence.Yield, precedence);
          },
          AwaitExpression: function AwaitExpression(expr, precedence, flags) {
            var result = join(expr.all ? "await*" : "await", this.generateExpression(expr.argument, Precedence.Await, E_TTT));
            return parenthesize(result, Precedence.Await, precedence);
          },
          UpdateExpression: function UpdateExpression(expr, precedence, flags) {
            if (expr.prefix) {
              return parenthesize([expr.operator, this.generateExpression(expr.argument, Precedence.Unary, E_TTT)], Precedence.Unary, precedence);
            }

            return parenthesize([this.generateExpression(expr.argument, Precedence.Postfix, E_TTT), expr.operator], Precedence.Postfix, precedence);
          },
          FunctionExpression: function FunctionExpression(expr, precedence, flags) {
            var result = [generateAsyncPrefix(expr, true), "function"];

            if (expr.id) {
              result.push(generateStarSuffix(expr) || noEmptySpace());
              result.push(generateIdentifier(expr.id));
            } else {
              result.push(generateStarSuffix(expr) || space);
            }

            result.push(this.generateFunctionBody(expr));
            return result;
          },
          ArrayPattern: function ArrayPattern(expr, precedence, flags) {
            return this.ArrayExpression(expr, precedence, flags, true);
          },
          ArrayExpression: function ArrayExpression(expr, precedence, flags, isPattern) {
            var result;
            var multiline;
            var that = this;

            if (!expr.elements.length) {
              return "[]";
            }

            multiline = isPattern ? false : expr.elements.length > 1;
            result = ["[", multiline ? newline : ""];
            withIndent(function (indent) {
              var i, iz;

              for (i = 0, iz = expr.elements.length; i < iz; ++i) {
                if (!expr.elements[i]) {
                  if (multiline) {
                    result.push(indent);
                  }

                  if (i + 1 === iz) {
                    result.push(",");
                  }
                } else {
                  result.push(multiline ? indent : "");
                  result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
                }

                if (i + 1 < iz) {
                  result.push("," + (multiline ? newline : space));
                }
              }
            });

            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }

            result.push(multiline ? base : "");
            result.push("]");
            return result;
          },
          RestElement: function RestElement(expr, precedence, flags) {
            return "..." + this.generatePattern(expr.argument);
          },
          ClassExpression: function ClassExpression(expr, precedence, flags) {
            var result, fragment;
            result = ["class"];

            if (expr.id) {
              result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
            }

            if (expr.superClass) {
              fragment = join("extends", this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));
              result = join(result, fragment);
            }

            result.push(space);
            result.push(this.generateStatement(expr.body, S_TFFT));
            return result;
          },
          MethodDefinition: function MethodDefinition(expr, precedence, flags) {
            var result = [];
            var fragment;

            if (expr.decorators.length) {
              var _iterator2 = _createForOfIteratorHelper(expr.decorators),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var dec = _step2.value;
                  result.push(this.generateStatement(dec));
                  result.push(base);
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }

            if (expr["static"]) {
              result.push("static" + space);
            }

            if (expr.kind === "get" || expr.kind === "set") {
              fragment = [join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)), this.generateFunctionBody(expr.value)];
            } else {
              fragment = [generateMethodPrefix(expr), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];
            }

            return join(result, fragment);
          },
          PrivateIdentifier: function PrivateIdentifier(expr, precedence, flags) {
            return generateIdentifier(expr);
          },
          Decorator: function Decorator(expr, precedence, flags) {
            return ["@", this.generateExpression(expr.expression, Precedence.Call, F_ALLOW_CALL), newline];
          },
          Property: function Property(expr, precedence, flags) {
            if (expr.kind === "get" || expr.kind === "set") {
              return [expr.kind, noEmptySpace(), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];
            }

            if (expr.shorthand) {
              if (expr.value.type === "AssignmentPattern") {
                return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
              }

              return this.generatePropertyKey(expr.key, expr.computed);
            }

            if (expr.method) {
              return [generateMethodPrefix(expr), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];
            }

            return [this.generatePropertyKey(expr.key, expr.computed), ":" + space, this.generateExpression(expr.value, Precedence.Assignment, E_TTT)];
          },
          PropertyDefinition: function PropertyDefinition(expr, precedence, flags) {
            var result;

            if (expr["static"]) {
              result = ["static "];
            } else {
              result = [];
            }

            result.push(this.generatePropertyKey(expr.key, expr.computed));

            if (expr.value) {
              result.push(space + "=" + space);
              result.push(this.generateExpression(expr.value, Precedence.Assignment, E_TTT));
            }

            result.push(this.semicolon(flags));
            return result;
          },
          ObjectExpression: function ObjectExpression(expr, precedence, flags) {
            var multiline;
            var result;
            var fragment;
            var that = this;

            if (!expr.properties.length) {
              return "{}";
            }

            multiline = expr.properties.length > 1;
            withIndent(function () {
              fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
            });

            if (!multiline) {
              if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                return ["{", space, fragment, space, "}"];
              }
            }

            withIndent(function (indent) {
              var i, iz;
              result = ["{", newline, indent, fragment];

              if (multiline) {
                result.push("," + newline);

                for (i = 1, iz = expr.properties.length; i < iz; ++i) {
                  result.push(indent);
                  result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));

                  if (i + 1 < iz) {
                    result.push("," + newline);
                  }
                }
              }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }

            result.push(base);
            result.push("}");
            return result;
          },
          AssignmentPattern: function AssignmentPattern(expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, "=", precedence, flags);
          },
          ObjectPattern: function ObjectPattern(expr, precedence, flags) {
            var result;
            var i;
            var iz;
            var multiline;
            var property;
            var that = this;

            if (!expr.properties.length) {
              return "{}";
            }

            multiline = false;

            if (expr.properties.length === 1) {
              property = expr.properties[0];

              if (property.type === Syntax.Property && property.value.type !== Syntax.Identifier) {
                multiline = true;
              }
            } else {
              for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                property = expr.properties[i];

                if (property.type === Syntax.Property && !property.shorthand) {
                  multiline = true;
                  break;
                }
              }
            }

            result = ["{", multiline ? newline : ""];
            withIndent(function (indent) {
              var i, iz;

              for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                result.push(multiline ? indent : "");
                result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));

                if (i + 1 < iz) {
                  result.push("," + (multiline ? newline : space));
                }
              }
            });

            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }

            result.push(multiline ? base : "");
            result.push("}");
            return result;
          },
          ThisExpression: function ThisExpression(expr, precedence, flags) {
            return "this";
          },
          Super: function Super(expr, precedence, flags) {
            return "super";
          },
          Identifier: function Identifier(expr, precedence, flags) {
            return generateIdentifier(expr);
          },
          ImportDefaultSpecifier: function ImportDefaultSpecifier(expr, precedence, flags) {
            return generateIdentifier(expr.id || expr.local);
          },
          ImportNamespaceSpecifier: function ImportNamespaceSpecifier(expr, precedence, flags) {
            var result = ["*"];
            var id = expr.id || expr.local;

            if (id) {
              result.push(space + "as" + noEmptySpace() + generateIdentifier(id));
            }

            return result;
          },
          ImportSpecifier: function ImportSpecifier(expr, precedence, flags) {
            var imported = expr.imported;
            var result = [imported.name];
            var local = expr.local;

            if (local && local.name !== imported.name) {
              result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(local));
            }

            return result;
          },
          ExportSpecifier: function ExportSpecifier(expr, precedence, flags) {
            var local = expr.local;
            var result = [local.name];
            var exported = expr.exported;

            if (exported && exported.name !== local.name) {
              result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(exported));
            }

            return result;
          },
          Literal: function Literal(expr, precedence, flags) {
            var raw;

            if (expr.hasOwnProperty("raw") && parse && extra.raw) {
              try {
                raw = parse(expr.raw).body[0].expression;

                if (raw.type === Syntax.Literal) {
                  if (raw.value === expr.value) {
                    return expr.raw;
                  }
                }
              } catch (e) {}
            }

            if (expr.regex) {
              return "/" + expr.regex.pattern + "/" + expr.regex.flags;
            }

            if (typeof expr.bigint === "string" && expr.raw) {
              return expr.raw;
            }

            if (expr.value === null) {
              return "null";
            }

            if (typeof expr.value === "string") {
              return escapeString(expr.value);
            }

            if (typeof expr.value === "number") {
              if (expr.raw && expr.raw.indexOf("_") !== -1) {
                return expr.raw;
              }

              return generateNumber(expr.value);
            }

            if (typeof expr.value === "boolean") {
              return expr.value ? "true" : "false";
            }

            return generateRegExp(expr.value);
          },
          GeneratorExpression: function GeneratorExpression(expr, precedence, flags) {
            return this.ComprehensionExpression(expr, precedence, flags);
          },
          ComprehensionExpression: function ComprehensionExpression(expr, precedence, flags) {
            var result;
            var i;
            var iz;
            var fragment;
            var that = this;
            result = expr.type === Syntax.GeneratorExpression ? ["("] : ["["];

            if (extra.moz.comprehensionExpressionStartsWithAssignment) {
              fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
              result.push(fragment);
            }

            if (expr.blocks) {
              withIndent(function () {
                for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
                  fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);

                  if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                    result = join(result, fragment);
                  } else {
                    result.push(fragment);
                  }
                }
              });
            }

            if (expr.filter) {
              result = join(result, "if" + space);
              fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
              result = join(result, ["(", fragment, ")"]);
            }

            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
              fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
              result = join(result, fragment);
            }

            result.push(expr.type === Syntax.GeneratorExpression ? ")" : "]");
            return result;
          },
          ComprehensionBlock: function ComprehensionBlock(expr, precedence, flags) {
            var fragment;

            if (expr.left.type === Syntax.VariableDeclaration) {
              fragment = [expr.left.kind, noEmptySpace(), this.generateStatement(expr.left.declarations[0], S_FFFF)];
            } else {
              fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
            }

            fragment = join(fragment, expr.of ? "of" : "in");
            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));
            return ["for" + space + "(", fragment, ")"];
          },
          SpreadElement: function SpreadElement(expr, precedence, flags) {
            return ["...", this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)];
          },
          TaggedTemplateExpression: function TaggedTemplateExpression(expr, precedence, flags) {
            var itemFlags = E_TTF;

            if (!(flags & F_ALLOW_CALL)) {
              itemFlags = E_TFF;
            }

            var result = [this.generateExpression(expr.tag, Precedence.Call, itemFlags), this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)];
            return parenthesize(result, Precedence.TaggedTemplate, precedence);
          },
          TemplateElement: function TemplateElement(expr, precedence, flags) {
            return expr.value.raw;
          },
          TemplateLiteral: function TemplateLiteral(expr, precedence, flags) {
            var result, i, iz;
            result = ["`"];

            for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
              result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));

              if (i + 1 < iz) {
                result.push("${" + space);
                result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
                result.push(space + "}");
              }
            }

            result.push("`");
            return result;
          },
          ModuleSpecifier: function ModuleSpecifier(expr, precedence, flags) {
            return this.Literal(expr, precedence, flags);
          },
          ImportExpression: function ImportExpression(expr, precedence, flag) {
            return parenthesize(["import(", this.generateExpression(expr.source, Precedence.Assignment, E_TTT), ")"], Precedence.Call, precedence);
          }
        };
        merge(CodeGenerator.prototype, CodeGenerator.Expression);

        CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {
          var result, type;
          type = expr.type || Syntax.Property;

          if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
            return generateVerbatim(expr, precedence);
          }

          result = this[type](expr, precedence, flags);

          if (extra.comment) {
            result = addComments(expr, result);
          }

          return toSourceNodeWhenNeeded(result, expr);
        };

        CodeGenerator.prototype.generateStatement = function (stmt, flags) {
          var result, fragment;
          result = this[stmt.type](stmt, flags);

          if (extra.comment) {
            result = addComments(stmt, result);
          }

          fragment = toSourceNodeWhenNeeded(result).toString();

          if (stmt.type === Syntax.Program && !safeConcatenation && newline === "" && fragment.charAt(fragment.length - 1) === "\n") {
            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, "") : fragment.replace(/\s+$/, "");
          }

          return toSourceNodeWhenNeeded(result, stmt);
        };

        function generateInternal(node) {
          var codegen;
          codegen = new CodeGenerator();

          if (isStatement(node)) {
            return codegen.generateStatement(node, S_TFFF);
          }

          if (isExpression(node)) {
            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
          }

          throw new Error("Unknown node type: " + node.type);
        }

        function generate(node, options) {
          var defaultOptions = getDefaultOptions();
          var result;
          var pair;

          if (options != null) {
            if (typeof options.indent === "string") {
              defaultOptions.format.indent.style = options.indent;
            }

            if (typeof options.base === "number") {
              defaultOptions.format.indent.base = options.base;
            }

            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;

            if (typeof options.base === "string") {
              base = options.base;
            } else {
              base = stringRepeat(indent, options.format.indent.base);
            }
          } else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
          }

          json = options.format.json;
          renumber = options.format.renumber;
          hexadecimal = json ? false : options.format.hexadecimal;
          quotes = json ? "double" : options.format.quotes;
          escapeless = options.format.escapeless;
          newline = options.format.newline;
          space = options.format.space;

          if (options.format.compact) {
            newline = space = indent = base = "";
          }

          parentheses = options.format.parentheses;
          semicolons = options.format.semicolons;
          safeConcatenation = options.format.safeConcatenation;
          directive = options.directive;
          parse = json ? null : options.parse;
          sourceMap = options.sourceMap;
          sourceCode = options.sourceCode;
          preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
          extra = options;

          if (sourceMap) {
            if (!exports.browser) {
              SourceNode = System._nodeRequire("source-map").SourceNode;
            } else {
              SourceNode = global.sourceMap.SourceNode;
            }
          }

          result = generateInternal(node);

          if (!sourceMap) {
            pair = {
              code: result.toString(),
              map: null
            };
            return options.sourceMapWithCode ? pair : pair.code;
          }

          pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
          });

          if (options.sourceContent) {
            pair.map.setSourceContent(options.sourceMap, options.sourceContent);
          }

          if (options.sourceMapWithCode) {
            return pair;
          }

          return pair.map.toString();
        }

        FORMAT_MINIFY = {
          indent: {
            style: "",
            base: 0
          },
          renumber: true,
          hexadecimal: true,
          quotes: "auto",
          escapeless: true,
          compact: true,
          parentheses: false,
          semicolons: false
        };
        var exports = {};
        FORMAT_DEFAULTS = getDefaultOptions().format;
        exports.generate = generate;
        exports.attachComments = exports$a.attachComments;
        exports.Precedence = updateDeeply({}, Precedence);
        exports.browser = false;
        exports.FORMAT_MINIFY = FORMAT_MINIFY;
        exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
        return exports;
      }, __moduleMeta__$b);

      __varRecorder__$c.ESCODEGEN = ESCODEGEN;

      var stringify = exports('s', __varRecorder__$c["lively.ast/lib/stringify.js__define__"]("stringify", "function", function (node) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var optsIndent = opts && opts.format && opts.format.indent || {};
        var indent = {
          style: "  ",
          base: 0,
          adjustMultilineComment: false,
          optsIndent: optsIndent
        };
        var optsFormat = opts && opts.format || {};
        var format = Object.assign({
          indent: indent,
          quotes: "double"
        }, dissoc(optsFormat, ["indent"]));
        opts = Object.assign({
          format: format,
          comment: false
        }, dissoc(opts, ["format"]));
        return __varRecorder__$c.es.generate(node, opts);
      }, __moduleMeta__$b));

      __varRecorder__$c.stringify = stringify;
      __varRecorder__$c.es = __varRecorder__$c.ESCODEGEN();
      var es = __varRecorder__$c.es;
      __varRecorder__$c.es = es;
      __varRecorder__$c["default"] = stringify;

      function getAugmentedNamespace(n) {
        var f = n.default;
      	if (typeof f == "function") {
      		var a = function () {
      			return f.apply(this, arguments);
      		};
      		a.prototype = f.prototype;
        } else a = {};
        Object.defineProperty(a, '__esModule', {value: true});
      	Object.keys(n).forEach(function (k) {
      		var d = Object.getOwnPropertyDescriptor(n, k);
      		Object.defineProperty(a, k, d.get ? d : {
      			enumerable: true,
      			get: function () {
      				return n[k];
      			}
      		});
      	});
      	return a;
      }

      var reservedWords$1 = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords$1 = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$2 = {
        5: ecma5AndLessKeywords$1,
        "5module": ecma5AndLessKeywords$1 + " export import",
        6: ecma5AndLessKeywords$1 + " const class extends export import super"
      };
      var keywordRelationalOperator$1 = /^in(stanceof)?$/;
      var nonASCIIidentifierStartChars$1 = "-------------\u0560-\u0588-\u05EF---------\u0860-\u086A--\u08C7--------\u09FC------------------------------\u0D04------------\u0E86-\u0E8C--------------------------------------------\u1878-----------------\u1C90-\u1CBA\u1CBD-\u1CBF--\u1CFA------------------\u2118-------------------------\u309B----\u312F--\u31BF--\u4DBF-\u9FFC----------\uA7BF\uA7C2-\uA7CA\uA7F5-------\uA8FE-----------------------\uAB69-------------------------";
      var nonASCIIidentifierChars$1 = "\xB7-\u0387------------\u07FD-----\u08D3----------\u09FE---------\u0AFA-\u0AFF---\u0B55-------\u0C04---------\u0D00-\u0D3B\u0D3C----\u0D81------------------------\u1369-\u1371----------\u19DA------\u1ABF\u1AC0-------------\u1CF7--\u1DF9---------\uA82C---\uA8FF------------------";
      var nonASCIIidentifierStart$1 = new RegExp("[" + nonASCIIidentifierStartChars$1 + "]");
      var nonASCIIidentifier$1 = new RegExp("[" + nonASCIIidentifierStartChars$1 + nonASCIIidentifierChars$1 + "]");
      nonASCIIidentifierStartChars$1 = nonASCIIidentifierChars$1 = null;
      var astralIdentifierStartCodes$1 = [
        0,
        11,
        2,
        25,
        2,
        18,
        2,
        1,
        2,
        14,
        3,
        13,
        35,
        122,
        70,
        52,
        268,
        28,
        4,
        48,
        48,
        31,
        14,
        29,
        6,
        37,
        11,
        29,
        3,
        35,
        5,
        7,
        2,
        4,
        43,
        157,
        19,
        35,
        5,
        35,
        5,
        39,
        9,
        51,
        157,
        310,
        10,
        21,
        11,
        7,
        153,
        5,
        3,
        0,
        2,
        43,
        2,
        1,
        4,
        0,
        3,
        22,
        11,
        22,
        10,
        30,
        66,
        18,
        2,
        1,
        11,
        21,
        11,
        25,
        71,
        55,
        7,
        1,
        65,
        0,
        16,
        3,
        2,
        2,
        2,
        28,
        43,
        28,
        4,
        28,
        36,
        7,
        2,
        27,
        28,
        53,
        11,
        21,
        11,
        18,
        14,
        17,
        111,
        72,
        56,
        50,
        14,
        50,
        14,
        35,
        349,
        41,
        7,
        1,
        79,
        28,
        11,
        0,
        9,
        21,
        107,
        20,
        28,
        22,
        13,
        52,
        76,
        44,
        33,
        24,
        27,
        35,
        30,
        0,
        3,
        0,
        9,
        34,
        4,
        0,
        13,
        47,
        15,
        3,
        22,
        0,
        2,
        0,
        36,
        17,
        2,
        24,
        85,
        6,
        2,
        0,
        2,
        3,
        2,
        14,
        2,
        9,
        8,
        46,
        39,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        4,
        0,
        19,
        0,
        13,
        4,
        159,
        52,
        19,
        3,
        21,
        2,
        31,
        47,
        21,
        1,
        2,
        0,
        185,
        46,
        42,
        3,
        37,
        47,
        21,
        0,
        60,
        42,
        14,
        0,
        72,
        26,
        230,
        43,
        117,
        63,
        32,
        7,
        3,
        0,
        3,
        7,
        2,
        1,
        2,
        23,
        16,
        0,
        2,
        0,
        95,
        7,
        3,
        38,
        17,
        0,
        2,
        0,
        29,
        0,
        11,
        39,
        8,
        0,
        22,
        0,
        12,
        45,
        20,
        0,
        35,
        56,
        264,
        8,
        2,
        36,
        18,
        0,
        50,
        29,
        113,
        6,
        2,
        1,
        2,
        37,
        22,
        0,
        26,
        5,
        2,
        1,
        2,
        31,
        15,
        0,
        328,
        18,
        190,
        0,
        80,
        921,
        103,
        110,
        18,
        195,
        2749,
        1070,
        4050,
        582,
        8634,
        568,
        8,
        30,
        114,
        29,
        19,
        47,
        17,
        3,
        32,
        20,
        6,
        18,
        689,
        63,
        129,
        74,
        6,
        0,
        67,
        12,
        65,
        1,
        2,
        0,
        29,
        6135,
        9,
        1237,
        43,
        8,
        8952,
        286,
        50,
        2,
        18,
        3,
        9,
        395,
        2309,
        106,
        6,
        12,
        4,
        8,
        8,
        9,
        5991,
        84,
        2,
        70,
        2,
        1,
        3,
        0,
        3,
        1,
        3,
        3,
        2,
        11,
        2,
        0,
        2,
        6,
        2,
        64,
        2,
        3,
        3,
        7,
        2,
        6,
        2,
        27,
        2,
        3,
        2,
        4,
        2,
        0,
        4,
        6,
        2,
        339,
        3,
        24,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        7,
        2357,
        44,
        11,
        6,
        17,
        0,
        370,
        43,
        1301,
        196,
        60,
        67,
        8,
        0,
        1205,
        3,
        2,
        26,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        9,
        2,
        3,
        2,
        0,
        2,
        0,
        7,
        0,
        5,
        0,
        2,
        0,
        2,
        0,
        2,
        2,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        1,
        2,
        0,
        3,
        3,
        2,
        6,
        2,
        3,
        2,
        3,
        2,
        0,
        2,
        9,
        2,
        16,
        6,
        2,
        2,
        4,
        2,
        16,
        4421,
        42717,
        35,
        4148,
        12,
        221,
        3,
        5761,
        15,
        7472,
        3104,
        541,
        1507,
        4938
      ];
      var astralIdentifierCodes$1 = [
        509,
        0,
        227,
        0,
        150,
        4,
        294,
        9,
        1368,
        2,
        2,
        1,
        6,
        3,
        41,
        2,
        5,
        0,
        166,
        1,
        574,
        3,
        9,
        9,
        370,
        1,
        154,
        10,
        176,
        2,
        54,
        14,
        32,
        9,
        16,
        3,
        46,
        10,
        54,
        9,
        7,
        2,
        37,
        13,
        2,
        9,
        6,
        1,
        45,
        0,
        13,
        2,
        49,
        13,
        9,
        3,
        2,
        11,
        83,
        11,
        7,
        0,
        161,
        11,
        6,
        9,
        7,
        3,
        56,
        1,
        2,
        6,
        3,
        1,
        3,
        2,
        10,
        0,
        11,
        1,
        3,
        6,
        4,
        4,
        193,
        17,
        10,
        9,
        5,
        0,
        82,
        19,
        13,
        9,
        214,
        6,
        3,
        8,
        28,
        1,
        83,
        16,
        16,
        9,
        82,
        12,
        9,
        9,
        84,
        14,
        5,
        9,
        243,
        14,
        166,
        9,
        71,
        5,
        2,
        1,
        3,
        3,
        2,
        0,
        2,
        1,
        13,
        9,
        120,
        6,
        3,
        6,
        4,
        0,
        29,
        9,
        41,
        6,
        2,
        3,
        9,
        0,
        10,
        10,
        47,
        15,
        406,
        7,
        2,
        7,
        17,
        9,
        57,
        21,
        2,
        13,
        123,
        5,
        4,
        0,
        2,
        1,
        2,
        6,
        2,
        0,
        9,
        9,
        49,
        4,
        2,
        1,
        2,
        4,
        9,
        9,
        330,
        3,
        19306,
        9,
        135,
        4,
        60,
        6,
        26,
        9,
        1014,
        0,
        2,
        54,
        8,
        3,
        82,
        0,
        12,
        1,
        19628,
        1,
        5319,
        4,
        4,
        5,
        9,
        7,
        3,
        6,
        31,
        3,
        149,
        2,
        1418,
        49,
        513,
        54,
        5,
        49,
        9,
        0,
        15,
        0,
        23,
        4,
        2,
        14,
        1361,
        6,
        2,
        16,
        3,
        6,
        2,
        1,
        2,
        4,
        262,
        6,
        10,
        9,
        419,
        13,
        1495,
        6,
        110,
        6,
        6,
        9,
        4759,
        9,
        787719,
        239
      ];
      function isInAstralSet$1(code, set) {
        var pos = 65536;
        for (var i = 0; i < set.length; i += 2) {
          pos += set[i];
          if (pos > code) {
            return false;
          }
          pos += set[i + 1];
          if (pos >= code) {
            return true;
          }
        }
      }
      function isIdentifierStart$2(code, astral) {
        if (code < 65) {
          return code === 36;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart$1.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet$1(code, astralIdentifierStartCodes$1);
      }
      function isIdentifierChar$2(code, astral) {
        if (code < 48) {
          return code === 36;
        }
        if (code < 58) {
          return true;
        }
        if (code < 65) {
          return false;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier$1.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet$1(code, astralIdentifierStartCodes$1) || isInAstralSet$1(code, astralIdentifierCodes$1);
      }
      var TokenType$2 = function TokenType(label, conf) {
        if (conf === void 0)
          conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop$1(name, prec) {
        return new TokenType$2(name, {
          beforeExpr: true,
          binop: prec
        });
      }
      var beforeExpr$1 = { beforeExpr: true }, startsExpr$1 = { startsExpr: true };
      var keywords$1$1 = {};
      function kw$1(name, options) {
        if (options === void 0)
          options = {};
        options.keyword = name;
        return keywords$1$1[name] = new TokenType$2(name, options);
      }
      var types$2 = {
        num: new TokenType$2("num", startsExpr$1),
        regexp: new TokenType$2("regexp", startsExpr$1),
        string: new TokenType$2("string", startsExpr$1),
        name: new TokenType$2("name", startsExpr$1),
        eof: new TokenType$2("eof"),
        bracketL: new TokenType$2("[", {
          beforeExpr: true,
          startsExpr: true
        }),
        bracketR: new TokenType$2("]"),
        braceL: new TokenType$2("{", {
          beforeExpr: true,
          startsExpr: true
        }),
        braceR: new TokenType$2("}"),
        parenL: new TokenType$2("(", {
          beforeExpr: true,
          startsExpr: true
        }),
        parenR: new TokenType$2(")"),
        comma: new TokenType$2(",", beforeExpr$1),
        semi: new TokenType$2(";", beforeExpr$1),
        colon: new TokenType$2(":", beforeExpr$1),
        dot: new TokenType$2("."),
        question: new TokenType$2("?", beforeExpr$1),
        questionDot: new TokenType$2("?."),
        arrow: new TokenType$2("=>", beforeExpr$1),
        template: new TokenType$2("template"),
        invalidTemplate: new TokenType$2("invalidTemplate"),
        ellipsis: new TokenType$2("...", beforeExpr$1),
        backQuote: new TokenType$2("`", startsExpr$1),
        dollarBraceL: new TokenType$2("${", {
          beforeExpr: true,
          startsExpr: true
        }),
        eq: new TokenType$2("=", {
          beforeExpr: true,
          isAssign: true
        }),
        assign: new TokenType$2("_=", {
          beforeExpr: true,
          isAssign: true
        }),
        incDec: new TokenType$2("++/--", {
          prefix: true,
          postfix: true,
          startsExpr: true
        }),
        prefix: new TokenType$2("!/~", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        logicalOR: binop$1("||", 1),
        logicalAND: binop$1("&&", 2),
        bitwiseOR: binop$1("|", 3),
        bitwiseXOR: binop$1("^", 4),
        bitwiseAND: binop$1("&", 5),
        equality: binop$1("==/!=/===/!==", 6),
        relational: binop$1("</>/<=/>=", 7),
        bitShift: binop$1("<</>>/>>>", 8),
        plusMin: new TokenType$2("+/-", {
          beforeExpr: true,
          binop: 9,
          prefix: true,
          startsExpr: true
        }),
        modulo: binop$1("%", 10),
        star: binop$1("*", 10),
        slash: binop$1("/", 10),
        starstar: new TokenType$2("**", { beforeExpr: true }),
        coalesce: binop$1("??", 1),
        _break: kw$1("break"),
        _case: kw$1("case", beforeExpr$1),
        _catch: kw$1("catch"),
        _continue: kw$1("continue"),
        _debugger: kw$1("debugger"),
        _default: kw$1("default", beforeExpr$1),
        _do: kw$1("do", {
          isLoop: true,
          beforeExpr: true
        }),
        _else: kw$1("else", beforeExpr$1),
        _finally: kw$1("finally"),
        _for: kw$1("for", { isLoop: true }),
        _function: kw$1("function", startsExpr$1),
        _if: kw$1("if"),
        _return: kw$1("return", beforeExpr$1),
        _switch: kw$1("switch"),
        _throw: kw$1("throw", beforeExpr$1),
        _try: kw$1("try"),
        _var: kw$1("var"),
        _const: kw$1("const"),
        _while: kw$1("while", { isLoop: true }),
        _with: kw$1("with"),
        _new: kw$1("new", {
          beforeExpr: true,
          startsExpr: true
        }),
        _this: kw$1("this", startsExpr$1),
        _super: kw$1("super", startsExpr$1),
        _class: kw$1("class", startsExpr$1),
        _extends: kw$1("extends", beforeExpr$1),
        _export: kw$1("export"),
        _import: kw$1("import", startsExpr$1),
        _null: kw$1("null", startsExpr$1),
        _true: kw$1("true", startsExpr$1),
        _false: kw$1("false", startsExpr$1),
        _in: kw$1("in", {
          beforeExpr: true,
          binop: 7
        }),
        _instanceof: kw$1("instanceof", {
          beforeExpr: true,
          binop: 7
        }),
        _typeof: kw$1("typeof", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        _void: kw$1("void", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        _delete: kw$1("delete", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        })
      };
      var lineBreak$2 = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG$2 = new RegExp(lineBreak$2.source, "g");
      function isNewLine$2(code, ecma2019String) {
        return code === 10 || code === 13 || !ecma2019String && (code === 8232 || code === 8233);
      }
      var nonASCIIwhitespace$2 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace$1 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref$1 = Object.prototype;
      var hasOwnProperty$1 = ref$1.hasOwnProperty;
      var toString$1 = ref$1.toString;
      function has(obj, propName) {
        return hasOwnProperty$1.call(obj, propName);
      }
      var isArray$1 = Array.isArray || function (obj) {
        return toString$1.call(obj) === "[object Array]";
      };
      function wordsRegexp$1(words) {
        return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
      }
      var Position$2 = function Position(line, col) {
        this.line = line;
        this.column = col;
      };
      Position$2.prototype.offset = function offset(n) {
        return new Position$2(this.line, this.column + n);
      };
      var SourceLocation$2 = function SourceLocation(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo$2(input, offset) {
        for (var line = 1, cur = 0;;) {
          lineBreakG$2.lastIndex = cur;
          var match = lineBreakG$2.exec(input);
          if (match && match.index < offset) {
            ++line;
            cur = match.index + match[0].length;
          } else {
            return new Position$2(line, offset - cur);
          }
        }
      }
      var defaultOptions$2 = {
        ecmaVersion: null,
        sourceType: "script",
        onInsertedSemicolon: null,
        onTrailingComma: null,
        allowReserved: null,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowAwaitOutsideFunction: false,
        allowHashBang: false,
        locations: false,
        onToken: null,
        onComment: null,
        ranges: false,
        program: null,
        sourceFile: null,
        directSourceFile: null,
        preserveParens: false
      };
      var warnedAboutEcmaVersion$1 = false;
      function getOptions$1(opts) {
        var options = {};
        for (var opt in defaultOptions$2) {
          options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions$2[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 100000000;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion$1 && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion$1 = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (isArray$1(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function (token) {
            return tokens.push(token);
          };
        }
        if (isArray$1(options.onComment)) {
          options.onComment = pushComment$1(options, options.onComment);
        }
        return options;
      }
      function pushComment$1(options, array) {
        return function (block, text, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start: start,
            end: end
          };
          if (options.locations) {
            comment.loc = new SourceLocation$2(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [
              start,
              end
            ];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP$1 = 1, SCOPE_FUNCTION$1 = 2, SCOPE_VAR$1 = SCOPE_TOP$1 | SCOPE_FUNCTION$1, SCOPE_ASYNC$1 = 4, SCOPE_GENERATOR$1 = 8, SCOPE_ARROW$1 = 16, SCOPE_SIMPLE_CATCH$1 = 32, SCOPE_SUPER$1 = 64, SCOPE_DIRECT_SUPER$1 = 128;
      function functionFlags$1(async, generator) {
        return SCOPE_FUNCTION$1 | (async ? SCOPE_ASYNC$1 : 0) | (generator ? SCOPE_GENERATOR$1 : 0);
      }
      var BIND_NONE$1 = 0, BIND_VAR$1 = 1, BIND_LEXICAL$1 = 2, BIND_FUNCTION$1 = 3, BIND_SIMPLE_CATCH$1 = 4, BIND_OUTSIDE$1 = 5;
      var Parser$2 = function Parser(options, input, startPos) {
        this.options = options = getOptions$1(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp$1(keywords$2[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords$1[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp$1(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords$1.strict;
        this.reservedWordsStrict = wordsRegexp$1(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp$1(reservedStrict + " " + reservedWords$1.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak$2).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$2.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = {};
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP$1);
        this.regexpState = null;
      };
      var prototypeAccessors$1 = {
        inFunction: { configurable: true },
        inGenerator: { configurable: true },
        inAsync: { configurable: true },
        allowSuper: { configurable: true },
        allowDirectSuper: { configurable: true },
        treatFunctionsAsVar: { configurable: true },
        inNonArrowFunction: { configurable: true }
      };
      Parser$2.prototype.parse = function parse() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
      prototypeAccessors$1.inFunction.get = function () {
        return (this.currentVarScope().flags & SCOPE_FUNCTION$1) > 0;
      };
      prototypeAccessors$1.inGenerator.get = function () {
        return (this.currentVarScope().flags & SCOPE_GENERATOR$1) > 0;
      };
      prototypeAccessors$1.inAsync.get = function () {
        return (this.currentVarScope().flags & SCOPE_ASYNC$1) > 0;
      };
      prototypeAccessors$1.allowSuper.get = function () {
        return (this.currentThisScope().flags & SCOPE_SUPER$1) > 0;
      };
      prototypeAccessors$1.allowDirectSuper.get = function () {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER$1) > 0;
      };
      prototypeAccessors$1.treatFunctionsAsVar.get = function () {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors$1.inNonArrowFunction.get = function () {
        return (this.currentThisScope().flags & SCOPE_FUNCTION$1) > 0;
      };
      Parser$2.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--)
          plugins[len] = arguments[len];
        var cls = this;
        for (var i = 0; i < plugins.length; i++) {
          cls = plugins[i](cls);
        }
        return cls;
      };
      Parser$2.parse = function parse(input, options) {
        return new this(options, input).parse();
      };
      Parser$2.parseExpressionAt = function parseExpressionAt(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser$2.tokenizer = function tokenizer(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser$2.prototype, prototypeAccessors$1);
      var pp$a = Parser$2.prototype;
      var literal$2 = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
      pp$a.strictDirective = function (start) {
        for (;;) {
          skipWhiteSpace$1.lastIndex = start;
          start += skipWhiteSpace$1.exec(this.input)[0].length;
          var match = literal$2.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace$1.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace$1.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak$2.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace$1.lastIndex = start;
          start += skipWhiteSpace$1.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp$a.eat = function (type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$a.isContextual = function (name) {
        return this.type === types$2.name && this.value === name && !this.containsEsc;
      };
      pp$a.eatContextual = function (name) {
        if (!this.isContextual(name)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$a.expectContextual = function (name) {
        if (!this.eatContextual(name)) {
          this.unexpected();
        }
      };
      pp$a.canInsertSemicolon = function () {
        return this.type === types$2.eof || this.type === types$2.braceR || lineBreak$2.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$a.insertSemicolon = function () {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$a.semicolon = function () {
        if (!this.eat(types$2.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$a.afterTrailingComma = function (tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$a.expect = function (type) {
        this.eat(type) || this.unexpected();
      };
      pp$a.unexpected = function (pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      function DestructuringErrors$1() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      }
      pp$a.checkPatternErrors = function (refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, "Parenthesized pattern");
        }
      };
      pp$a.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$a.checkYieldAwaitInDefaultParams = function () {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$a.isSimpleAssignTarget = function (expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$1$1 = Parser$2.prototype;
      pp$1$1.parseTopLevel = function (node) {
        var exports = {};
        if (!node.body) {
          node.body = [];
        }
        while (this.type !== types$2.eof) {
          var stmt = this.parseStatement(null, true, exports);
          node.body.push(stmt);
        }
        if (this.inModule) {
          for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
            var name = list[i];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      var loopLabel$1 = { kind: "loop" }, switchLabel$1 = { kind: "switch" };
      pp$1$1.isLet = function (context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace$1.lastIndex = this.pos;
        var skip = skipWhiteSpace$1.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123) {
          return true;
        }
        if (isIdentifierStart$2(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar$2(this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator$1.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$1$1.isAsyncFunction = function () {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace$1.lastIndex = this.pos;
        var skip = skipWhiteSpace$1.exec(this.input);
        var next = this.pos + skip[0].length;
        return !lineBreak$2.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !isIdentifierChar$2(this.input.charAt(next + 8)));
      };
      pp$1$1.parseStatement = function (context, topLevel, exports) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$2._var;
          kind = "let";
        }
        switch (starttype) {
        case types$2._break:
        case types$2._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);
        case types$2._debugger:
          return this.parseDebuggerStatement(node);
        case types$2._do:
          return this.parseDoStatement(node);
        case types$2._for:
          return this.parseForStatement(node);
        case types$2._function:
          if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
            this.unexpected();
          }
          return this.parseFunctionStatement(node, false, !context);
        case types$2._class:
          if (context) {
            this.unexpected();
          }
          return this.parseClass(node, true);
        case types$2._if:
          return this.parseIfStatement(node);
        case types$2._return:
          return this.parseReturnStatement(node);
        case types$2._switch:
          return this.parseSwitchStatement(node);
        case types$2._throw:
          return this.parseThrowStatement(node);
        case types$2._try:
          return this.parseTryStatement(node);
        case types$2._const:
        case types$2._var:
          kind = kind || this.value;
          if (context && kind !== "var") {
            this.unexpected();
          }
          return this.parseVarStatement(node, kind);
        case types$2._while:
          return this.parseWhileStatement(node);
        case types$2._with:
          return this.parseWithStatement(node);
        case types$2.braceL:
          return this.parseBlock(true, node);
        case types$2.semi:
          return this.parseEmptyStatement(node);
        case types$2._export:
        case types$2._import:
          if (this.options.ecmaVersion > 10 && starttype === types$2._import) {
            skipWhiteSpace$1.lastIndex = this.pos;
            var skip = skipWhiteSpace$1.exec(this.input);
            var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
            if (nextCh === 40 || nextCh === 46) {
              return this.parseExpressionStatement(node, this.parseExpression());
            }
          }
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) {
              this.raise(this.start, "'import' and 'export' may only appear at the top level");
            }
            if (!this.inModule) {
              this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
          }
          return starttype === types$2._import ? this.parseImport(node) : this.parseExport(node, exports);
        default:
          if (this.isAsyncFunction()) {
            if (context) {
              this.unexpected();
            }
            this.next();
            return this.parseFunctionStatement(node, true, !context);
          }
          var maybeName = this.value, expr = this.parseExpression();
          if (starttype === types$2.name && expr.type === "Identifier" && this.eat(types$2.colon)) {
            return this.parseLabeledStatement(node, maybeName, expr, context);
          } else {
            return this.parseExpressionStatement(node, expr);
          }
        }
      };
      pp$1$1.parseBreakContinueStatement = function (node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$2.semi) || this.insertSemicolon()) {
          node.label = null;
        } else if (this.type !== types$2.name) {
          this.unexpected();
        } else {
          node.label = this.parseIdent();
          this.semicolon();
        }
        var i = 0;
        for (; i < this.labels.length; ++i) {
          var lab = this.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node.label && isBreak) {
              break;
            }
          }
        }
        if (i === this.labels.length) {
          this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$1$1.parseDebuggerStatement = function (node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };
      pp$1$1.parseDoStatement = function (node) {
        this.next();
        this.labels.push(loopLabel$1);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$2._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$2.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
      };
      pp$1$1.parseForStatement = function (node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel$1);
        this.enterScope(0);
        this.expect(types$2.parenL);
        if (this.type === types$2.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types$2._var || this.type === types$2._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          if ((this.type === types$2._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types$2._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node.await = awaitAt > -1;
              }
            }
            return this.parseForIn(node, init$1);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init$1);
        }
        var refDestructuringErrors = new DestructuringErrors$1();
        var init = this.parseExpression(true, refDestructuringErrors);
        if (this.type === types$2._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$2._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLValPattern(init);
          return this.parseForIn(node, init);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      };
      pp$1$1.parseFunctionStatement = function (node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT$1 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT$1), false, isAsync);
      };
      pp$1$1.parseIfStatement = function (node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$2._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };
      pp$1$1.parseReturnStatement = function (node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$2.semi) || this.insertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };
      pp$1$1.parseSwitchStatement = function (node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types$2.braceL);
        this.labels.push(switchLabel$1);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types$2.braceR;) {
          if (this.type === types$2._case || this.type === types$2._default) {
            var isCase = this.type === types$2._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$2.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };
      pp$1$1.parseThrowStatement = function (node) {
        this.next();
        if (lineBreak$2.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };
      var empty$3 = [];
      pp$1$1.parseTryStatement = function (node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types$2._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$2.parenL)) {
            clause.param = this.parseBindingAtom();
            var simple = clause.param.type === "Identifier";
            this.enterScope(simple ? SCOPE_SIMPLE_CATCH$1 : 0);
            this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH$1 : BIND_LEXICAL$1);
            this.expect(types$2.parenR);
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$2._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
      };
      pp$1$1.parseVarStatement = function (node, kind) {
        this.next();
        this.parseVar(node, false, kind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };
      pp$1$1.parseWhileStatement = function (node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel$1);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };
      pp$1$1.parseWithStatement = function (node) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
      };
      pp$1$1.parseEmptyStatement = function (node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };
      pp$1$1.parseLabeledStatement = function (node, maybeName, expr, context) {
        for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
          var label = list[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$2._switch ? "switch" : null;
        for (var i = this.labels.length - 1; i >= 0; i--) {
          var label$1 = this.labels[i];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({
          name: maybeName,
          kind: kind,
          statementStart: this.start
        });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };
      pp$1$1.parseExpressionStatement = function (node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };
      pp$1$1.parseBlock = function (createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0)
          createNewLexicalScope = true;
        if (node === void 0)
          node = this.startNode();
        node.body = [];
        this.expect(types$2.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$2.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
      };
      pp$1$1.parseFor = function (node, init) {
        node.init = init;
        this.expect(types$2.semi);
        node.test = this.type === types$2.semi ? null : this.parseExpression();
        this.expect(types$2.semi);
        node.update = this.type === types$2.parenR ? null : this.parseExpression();
        this.expect(types$2.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };
      pp$1$1.parseForIn = function (node, init) {
        var isForIn = this.type === types$2._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$2.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$1$1.parseVar = function (node, isFor, kind) {
        node.declarations = [];
        node.kind = kind;
        for (;;) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$2.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (kind === "const" && !(this.type === types$2._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$2._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$2.comma)) {
            break;
          }
        }
        return node;
      };
      pp$1$1.parseVarId = function (decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR$1 : BIND_LEXICAL$1, false);
      };
      var FUNC_STATEMENT$1 = 1, FUNC_HANGING_STATEMENT$1 = 2, FUNC_NULLABLE_ID$1 = 4;
      pp$1$1.parseFunction = function (node, statement, allowExpressionBody, isAsync) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$2.star && statement & FUNC_HANGING_STATEMENT$1) {
            this.unexpected();
          }
          node.generator = this.eat(types$2.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT$1) {
          node.id = statement & FUNC_NULLABLE_ID$1 && this.type !== types$2.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT$1)) {
            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR$1 : BIND_LEXICAL$1 : BIND_FUNCTION$1);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags$1(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT$1)) {
          node.id = this.type === types$2.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT$1 ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$1$1.parseFunctionParams = function (node) {
        this.expect(types$2.parenL);
        node.params = this.parseBindingList(types$2.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$1$1.parseClass = function (node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$2.braceL);
        while (this.type !== types$2.braceR) {
          var element = this.parseClassElement(node.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) {
                this.raise(element.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$1$1.parseClassElement = function (constructorAllowsSuper) {
        var this$1$1 = this;
        if (this.eat(types$2.semi)) {
          return null;
        }
        var method = this.startNode();
        var tryContextual = function (k, noLineBreak) {
          if (noLineBreak === void 0)
            noLineBreak = false;
          var start = this$1$1.start, startLoc = this$1$1.startLoc;
          if (!this$1$1.eatContextual(k)) {
            return false;
          }
          if (this$1$1.type !== types$2.parenL && (!noLineBreak || !this$1$1.canInsertSemicolon())) {
            return true;
          }
          if (method.key) {
            this$1$1.unexpected();
          }
          method.computed = false;
          method.key = this$1$1.startNodeAt(start, startLoc);
          method.key.name = k;
          this$1$1.finishNode(method.key, "Identifier");
          return false;
        };
        method.kind = "method";
        method.static = tryContextual("static");
        var isGenerator = this.eat(types$2.star);
        var isAsync = false;
        if (!isGenerator) {
          if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
            isAsync = true;
            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$2.star);
          } else if (tryContextual("get")) {
            method.kind = "get";
          } else if (tryContextual("set")) {
            method.kind = "set";
          }
        }
        if (!method.key) {
          this.parsePropertyName(method);
        }
        var key = method.key;
        var allowsDirectSuper = false;
        if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
          if (method.kind !== "method") {
            this.raise(key.start, "Constructor can't have get/set modifier");
          }
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
          method.kind = "constructor";
          allowsDirectSuper = constructorAllowsSuper;
        } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && method.value.params.length !== 0) {
          this.raiseRecoverable(method.value.start, "getter should have no params");
        }
        if (method.kind === "set" && method.value.params.length !== 1) {
          this.raiseRecoverable(method.value.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && method.value.params[0].type === "RestElement") {
          this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params");
        }
        return method;
      };
      pp$1$1.parseClassMethod = function (method, isGenerator, isAsync, allowsDirectSuper) {
        method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        return this.finishNode(method, "MethodDefinition");
      };
      pp$1$1.parseClassId = function (node, isStatement) {
        if (this.type === types$2.name) {
          node.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node.id, BIND_LEXICAL$1, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node.id = null;
        }
      };
      pp$1$1.parseClassSuper = function (node) {
        node.superClass = this.eat(types$2._extends) ? this.parseExprSubscripts() : null;
      };
      pp$1$1.parseExport = function (node, exports) {
        this.next();
        if (this.eat(types$2.star)) {
          if (this.options.ecmaVersion >= 11) {
            if (this.eatContextual("as")) {
              node.exported = this.parseIdent(true);
              this.checkExport(exports, node.exported.name, this.lastTokStart);
            } else {
              node.exported = null;
            }
          }
          this.expectContextual("from");
          if (this.type !== types$2.string) {
            this.unexpected();
          }
          node.source = this.parseExprAtom();
          this.semicolon();
          return this.finishNode(node, "ExportAllDeclaration");
        }
        if (this.eat(types$2._default)) {
          this.checkExport(exports, "default", this.lastTokStart);
          var isAsync;
          if (this.type === types$2._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) {
              this.next();
            }
            node.declaration = this.parseFunction(fNode, FUNC_STATEMENT$1 | FUNC_NULLABLE_ID$1, false, isAsync);
          } else if (this.type === types$2._class) {
            var cNode = this.startNode();
            node.declaration = this.parseClass(cNode, "nullableID");
          } else {
            node.declaration = this.parseMaybeAssign();
            this.semicolon();
          }
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseStatement(null);
          if (node.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports, node.declaration.declarations);
          } else {
            this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
          }
          node.specifiers = [];
          node.source = null;
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports);
          if (this.eatContextual("from")) {
            if (this.type !== types$2.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
          } else {
            for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
              var spec = list[i];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
            }
            node.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      pp$1$1.checkExport = function (exports, name, pos) {
        if (!exports) {
          return;
        }
        if (has(exports, name)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
        }
        exports[name] = true;
      };
      pp$1$1.checkPatternExport = function (exports, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports, pat.name, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i = 0, list = pat.properties; i < list.length; i += 1) {
            var prop = list[i];
            this.checkPatternExport(exports, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports, pat.argument);
        } else if (type === "ParenthesizedExpression") {
          this.checkPatternExport(exports, pat.expression);
        }
      };
      pp$1$1.checkVariableExport = function (exports, decls) {
        if (!exports) {
          return;
        }
        for (var i = 0, list = decls; i < list.length; i += 1) {
          var decl = list[i];
          this.checkPatternExport(exports, decl.id);
        }
      };
      pp$1$1.shouldParseExportStatement = function () {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$1$1.parseExportSpecifiers = function (exports) {
        var nodes = [], first = true;
        this.expect(types$2.braceL);
        while (!this.eat(types$2.braceR)) {
          if (!first) {
            this.expect(types$2.comma);
            if (this.afterTrailingComma(types$2.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var node = this.startNode();
          node.local = this.parseIdent(true);
          node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
          this.checkExport(exports, node.exported.name, node.exported.start);
          nodes.push(this.finishNode(node, "ExportSpecifier"));
        }
        return nodes;
      };
      pp$1$1.parseImport = function (node) {
        this.next();
        if (this.type === types$2.string) {
          node.specifiers = empty$3;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types$2.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      pp$1$1.parseImportSpecifiers = function () {
        var nodes = [], first = true;
        if (this.type === types$2.name) {
          var node = this.startNode();
          node.local = this.parseIdent();
          this.checkLValSimple(node.local, BIND_LEXICAL$1);
          nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
          if (!this.eat(types$2.comma)) {
            return nodes;
          }
        }
        if (this.type === types$2.star) {
          var node$1 = this.startNode();
          this.next();
          this.expectContextual("as");
          node$1.local = this.parseIdent();
          this.checkLValSimple(node$1.local, BIND_LEXICAL$1);
          nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
          return nodes;
        }
        this.expect(types$2.braceL);
        while (!this.eat(types$2.braceR)) {
          if (!first) {
            this.expect(types$2.comma);
            if (this.afterTrailingComma(types$2.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var node$2 = this.startNode();
          node$2.imported = this.parseIdent(true);
          if (this.eatContextual("as")) {
            node$2.local = this.parseIdent();
          } else {
            this.checkUnreserved(node$2.imported);
            node$2.local = node$2.imported;
          }
          this.checkLValSimple(node$2.local, BIND_LEXICAL$1);
          nodes.push(this.finishNode(node$2, "ImportSpecifier"));
        }
        return nodes;
      };
      pp$1$1.adaptDirectivePrologue = function (statements) {
        for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
          statements[i].directive = statements[i].expression.raw.slice(1, -1);
        }
      };
      pp$1$1.isDirectiveCandidate = function (statement) {
        return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === "\"" || this.input[statement.start] === "'");
      };
      var pp$2$1 = Parser$2.prototype;
      pp$2$1.toAssignable = function (node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
          case "Identifier":
            if (this.inAsync && node.name === "await") {
              this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
            }
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            for (var i = 0, list = node.properties; i < list.length; i += 1) {
              var prop = list[i];
              this.toAssignable(prop, isBinding);
              if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                this.raise(prop.argument.start, "Unexpected token");
              }
            }
            break;
          case "Property":
            if (node.kind !== "init") {
              this.raise(node.key.start, "Object pattern can't contain getter or setter");
            }
            this.toAssignable(node.value, isBinding);
            break;
          case "ArrayExpression":
            node.type = "ArrayPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            this.toAssignableList(node.elements, isBinding);
            break;
          case "SpreadElement":
            node.type = "RestElement";
            this.toAssignable(node.argument, isBinding);
            if (node.argument.type === "AssignmentPattern") {
              this.raise(node.argument.start, "Rest elements cannot have a default value");
            }
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isBinding);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isBinding, refDestructuringErrors);
            break;
          case "ChainExpression":
            this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!isBinding) {
              break;
            }
          default:
            this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
      };
      pp$2$1.toAssignableList = function (exprList, isBinding) {
        var end = exprList.length;
        for (var i = 0; i < end; i++) {
          var elt = exprList[i];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$2$1.parseSpread = function (refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
      };
      pp$2$1.parseRestBinding = function () {
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$2.name) {
          this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };
      pp$2$1.parseBindingAtom = function () {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
          case types$2.bracketL:
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types$2.bracketR, true, true);
            return this.finishNode(node, "ArrayPattern");
          case types$2.braceL:
            return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$2$1.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$2.comma);
          }
          if (allowEmpty && this.type === types$2.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types$2.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$2.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            var elem = this.parseMaybeDefault(this.start, this.startLoc);
            this.parseBindingListItem(elem);
            elts.push(elem);
          }
        }
        return elts;
      };
      pp$2$1.parseBindingListItem = function (param) {
        return param;
      };
      pp$2$1.parseMaybeDefault = function (startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$2.eq)) {
          return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };
      pp$2$1.checkLValSimple = function (expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE$1;
        var isBind = bindingType !== BIND_NONE$1;
        switch (expr.type) {
        case "Identifier":
          if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
            this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          }
          if (isBind) {
            if (bindingType === BIND_LEXICAL$1 && expr.name === "let") {
              this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
            }
            if (checkClashes) {
              if (has(checkClashes, expr.name)) {
                this.raiseRecoverable(expr.start, "Argument name clash");
              }
              checkClashes[expr.name] = true;
            }
            if (bindingType !== BIND_OUTSIDE$1) {
              this.declareName(expr.name, bindingType, expr.start);
            }
          }
          break;
        case "ChainExpression":
          this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding member expression");
          }
          break;
        case "ParenthesizedExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding parenthesized expression");
          }
          return this.checkLValSimple(expr.expression, bindingType, checkClashes);
        default:
          this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$2$1.checkLValPattern = function (expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE$1;
        switch (expr.type) {
        case "ObjectPattern":
          for (var i = 0, list = expr.properties; i < list.length; i += 1) {
            var prop = list[i];
            this.checkLValInnerPattern(prop, bindingType, checkClashes);
          }
          break;
        case "ArrayPattern":
          for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
            var elem = list$1[i$1];
            if (elem) {
              this.checkLValInnerPattern(elem, bindingType, checkClashes);
            }
          }
          break;
        default:
          this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$2$1.checkLValInnerPattern = function (expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE$1;
        switch (expr.type) {
        case "Property":
          this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
          break;
        case "AssignmentPattern":
          this.checkLValPattern(expr.left, bindingType, checkClashes);
          break;
        case "RestElement":
          this.checkLValPattern(expr.argument, bindingType, checkClashes);
          break;
        default:
          this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var pp$3$1 = Parser$2.prototype;
      pp$3$1.checkPropClash = function (prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key = prop.key;
        var name;
        switch (key.type) {
        case "Identifier":
          name = key.name;
          break;
        case "Literal":
          name = String(key.value);
          break;
        default:
          return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$3$1.parseExpression = function (noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
        if (this.type === types$2.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types$2.comma)) {
            node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      pp$3$1.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(noIn);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors$1();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$2.parenL || this.type === types$2.name) {
          this.potentialArrowAt = this.start;
        }
        var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === types$2.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$2.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(noIn);
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$3$1.parseMaybeConditional = function (noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(noIn, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$2.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types$2.colon);
          node.alternate = this.parseMaybeAssign(noIn);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      pp$3$1.parseExprOps = function (noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
      };
      pp$3$1.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
        var prec = this.type.binop;
        if (prec != null && (!noIn || this.type !== types$2._in)) {
          if (prec > minPrec) {
            var logical = this.type === types$2.logicalOR || this.type === types$2.logicalAND;
            var coalesce = this.type === types$2.coalesce;
            if (coalesce) {
              prec = types$2.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$2.coalesce || coalesce && (this.type === types$2.logicalOR || this.type === types$2.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
          }
        }
        return left;
      };
      pp$3$1.buildBinary = function (startPos, startLoc, left, right, op, logical) {
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$3$1.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {
          expr = this.parseAwait();
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update = this.type === types$2.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node.argument);
          } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!sawUnary && this.eat(types$2.starstar)) {
          return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);
        } else {
          return expr;
        }
      };
      pp$3$1.parseExprSubscripts = function (refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
        }
        return result;
      };
      pp$3$1.parseSubscripts = function (base, startPos, startLoc, noCalls) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while (true) {
          var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);
          if (element.optional) {
            optionalChained = true;
          }
          if (element === base || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element;
              element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base = element;
        }
      };
      pp$3$1.parseSubscript = function (base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$2.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$2.bracketL);
        if (computed || optional && this.type !== types$2.parenL && this.type !== types$2.backQuote || this.eat(types$2.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
          node.computed = !!computed;
          if (computed) {
            this.expect(types$2.bracketR);
          }
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types$2.parenL)) {
          var refDestructuringErrors = new DestructuringErrors$1(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$2.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$2.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$2.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
      };
      pp$3$1.parseExprAtom = function (refDestructuringErrors) {
        if (this.type === types$2.slash) {
          this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
        case types$2._super:
          if (!this.allowSuper) {
            this.raise(this.start, "'super' keyword outside a method");
          }
          node = this.startNode();
          this.next();
          if (this.type === types$2.parenL && !this.allowDirectSuper) {
            this.raise(node.start, "super() call outside constructor of a subclass");
          }
          if (this.type !== types$2.dot && this.type !== types$2.bracketL && this.type !== types$2.parenL) {
            this.unexpected();
          }
          return this.finishNode(node, "Super");
        case types$2._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");
        case types$2.name:
          var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          var id = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$2._function)) {
            return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true);
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(types$2.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);
            }
            if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$2.name && !containsEsc) {
              id = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(types$2.arrow)) {
                this.unexpected();
              }
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);
            }
          }
          return id;
        case types$2.regexp:
          var value = this.value;
          node = this.parseLiteral(value.value);
          node.regex = {
            pattern: value.pattern,
            flags: value.flags
          };
          return node;
        case types$2.num:
        case types$2.string:
          return this.parseLiteral(this.value);
        case types$2._null:
        case types$2._true:
        case types$2._false:
          node = this.startNode();
          node.value = this.type === types$2._null ? null : this.type === types$2._true;
          node.raw = this.type.keyword;
          this.next();
          return this.finishNode(node, "Literal");
        case types$2.parenL:
          var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
          if (refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
              refDestructuringErrors.parenthesizedAssign = start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = start;
            }
          }
          return expr;
        case types$2.bracketL:
          node = this.startNode();
          this.next();
          node.elements = this.parseExprList(types$2.bracketR, true, true, refDestructuringErrors);
          return this.finishNode(node, "ArrayExpression");
        case types$2.braceL:
          return this.parseObj(false, refDestructuringErrors);
        case types$2._function:
          node = this.startNode();
          this.next();
          return this.parseFunction(node, 0);
        case types$2._class:
          return this.parseClass(this.startNode(), false);
        case types$2._new:
          return this.parseNew();
        case types$2.backQuote:
          return this.parseTemplate();
        case types$2._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport();
          } else {
            return this.unexpected();
          }
        default:
          this.unexpected();
        }
      };
      pp$3$1.parseExprImport = function () {
        var node = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        var meta = this.parseIdent(true);
        switch (this.type) {
        case types$2.parenL:
          return this.parseDynamicImport(node);
        case types$2.dot:
          node.meta = meta;
          return this.parseImportMeta(node);
        default:
          this.unexpected();
        }
      };
      pp$3$1.parseDynamicImport = function (node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (!this.eat(types$2.parenR)) {
          var errorPos = this.start;
          if (this.eat(types$2.comma) && this.eat(types$2.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node, "ImportExpression");
      };
      pp$3$1.parseImportMeta = function (node) {
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module") {
          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
      };
      pp$3$1.parseLiteral = function (value) {
        var node = this.startNode();
        node.value = value;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      };
      pp$3$1.parseParenExpression = function () {
        this.expect(types$2.parenL);
        var val = this.parseExpression();
        this.expect(types$2.parenR);
        return val;
      };
      pp$3$1.parseParenAndDistinguishExpression = function (canBeArrow) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors$1(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$2.parenR) {
            first ? first = false : this.expect(types$2.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$2.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$2.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$2.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.start, innerEndLoc = this.startLoc;
          this.expect(types$2.parenR);
          if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$2.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$3$1.parseParenItem = function (item) {
        return item;
      };
      pp$3$1.parseParenArrowList = function (startPos, startLoc, exprList) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
      };
      var empty$1$1 = [];
      pp$3$1.parseNew = function () {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(types$2.dot)) {
          node.meta = meta;
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.inNonArrowFunction) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$2._import;
        node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
        if (isImport && node.callee.type === "ImportExpression") {
          this.raise(startPos, "Cannot use new with import()");
        }
        if (this.eat(types$2.parenL)) {
          node.arguments = this.parseExprList(types$2.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = empty$1$1;
        }
        return this.finishNode(node, "NewExpression");
      };
      pp$3$1.parseTemplateElement = function (ref) {
        var isTagged = ref.isTagged;
        var elem = this.startNode();
        if (this.type === types$2.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value,
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$2.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$3$1.parseTemplate = function (ref) {
        if (ref === void 0)
          ref = {};
        var isTagged = ref.isTagged;
        if (isTagged === void 0)
          isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged: isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$2.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$2.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types$2.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged: isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };
      pp$3$1.isAsyncProp = function (prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$2.name || this.type === types$2.num || this.type === types$2.string || this.type === types$2.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$2.star) && !lineBreak$2.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$3$1.parseObj = function (isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types$2.braceR)) {
          if (!first) {
            this.expect(types$2.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$2.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$3$1.parseProperty = function (isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$2.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types$2.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          if (this.type === types$2.parenL && refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0) {
              refDestructuringErrors.parenthesizedAssign = this.start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = this.start;
            }
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$2.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$2.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$2.star);
          this.parsePropertyName(prop, refDestructuringErrors);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$3$1.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$2.colon) {
          this.unexpected();
        }
        if (this.eat(types$2.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$2.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.kind = "init";
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$2.comma && this.type !== types$2.braceR && this.type !== types$2.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          prop.kind = prop.key.name;
          this.parsePropertyName(prop);
          prop.value = this.parseMethod(false);
          var paramCount = prop.kind === "get" ? 0 : 1;
          if (prop.value.params.length !== paramCount) {
            var start = prop.value.start;
            if (prop.kind === "get") {
              this.raiseRecoverable(start, "getter should have no params");
            } else {
              this.raiseRecoverable(start, "setter should have exactly one param");
            }
          } else {
            if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
              this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
            }
          }
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          prop.kind = "init";
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types$2.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$3$1.parsePropertyName = function (prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$2.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types$2.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types$2.num || this.type === types$2.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$3$1.initFunction = function (node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      pp$3$1.parseMethod = function (isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags$1(isAsync, node.generator) | SCOPE_SUPER$1 | (allowDirectSuper ? SCOPE_DIRECT_SUPER$1 : 0));
        this.expect(types$2.parenL);
        node.params = this.parseBindingList(types$2.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
      };
      pp$3$1.parseArrowExpression = function (node, params, isAsync) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags$1(isAsync, false) | SCOPE_ARROW$1);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      pp$3$1.parseFunctionBody = function (node, isArrowFunction, isMethod) {
        var isExpression = isArrowFunction && this.type !== types$2.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node.body = this.parseMaybeAssign();
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          if (this.strict && node.id) {
            this.checkLValSimple(node.id, BIND_OUTSIDE$1);
          }
          node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$3$1.isSimpleParamList = function (params) {
        for (var i = 0, list = params; i < list.length; i += 1) {
          var param = list[i];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$3$1.checkParams = function (node, allowDuplicates) {
        var nameHash = {};
        for (var i = 0, list = node.params; i < list.length; i += 1) {
          var param = list[i];
          this.checkLValInnerPattern(param, BIND_VAR$1, allowDuplicates ? null : nameHash);
        }
      };
      pp$3$1.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types$2.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$2.comma) {
            elt = null;
          } else if (this.type === types$2.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$2.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$3$1.checkUnreserved = function (ref) {
        var start = ref.start;
        var end = ref.end;
        var name = ref.name;
        if (this.inGenerator && name === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (this.keywords.test(name)) {
          this.raise(start, "Unexpected keyword '" + name + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
          if (!this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
      };
      pp$3$1.parseIdent = function (liberal, isBinding) {
        var node = this.startNode();
        if (this.type === types$2.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;
          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
        } else {
          this.unexpected();
        }
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node.start;
          }
        }
        return node;
      };
      pp$3$1.parseYield = function (noIn) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types$2.semi || this.canInsertSemicolon() || this.type !== types$2.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types$2.star);
          node.argument = this.parseMaybeAssign(noIn);
        }
        return this.finishNode(node, "YieldExpression");
      };
      pp$3$1.parseAwait = function () {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        return this.finishNode(node, "AwaitExpression");
      };
      var pp$4$1 = Parser$2.prototype;
      pp$4$1.raise = function (pos, message) {
        var loc = getLineInfo$2(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$4$1.raiseRecoverable = pp$4$1.raise;
      pp$4$1.curPosition = function () {
        if (this.options.locations) {
          return new Position$2(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$5$1 = Parser$2.prototype;
      var Scope$1 = function Scope(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
      };
      pp$5$1.enterScope = function (flags) {
        this.scopeStack.push(new Scope$1(flags));
      };
      pp$5$1.exitScope = function () {
        this.scopeStack.pop();
      };
      pp$5$1.treatFunctionsAsVarInScope = function (scope) {
        return scope.flags & SCOPE_FUNCTION$1 || !this.inModule && scope.flags & SCOPE_TOP$1;
      };
      pp$5$1.declareName = function (name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL$1) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
          scope.lexical.push(name);
          if (this.inModule && scope.flags & SCOPE_TOP$1) {
            delete this.undefinedExports[name];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH$1) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION$1) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
          }
          scope$2.functions.push(name);
        } else {
          for (var i = this.scopeStack.length - 1; i >= 0; --i) {
            var scope$3 = this.scopeStack[i];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH$1 && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP$1) {
              delete this.undefinedExports[name];
            }
            if (scope$3.flags & SCOPE_VAR$1) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
        }
      };
      pp$5$1.checkLocalExport = function (id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$5$1.currentScope = function () {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$5$1.currentVarScope = function () {
        for (var i = this.scopeStack.length - 1;; i--) {
          var scope = this.scopeStack[i];
          if (scope.flags & SCOPE_VAR$1) {
            return scope;
          }
        }
      };
      pp$5$1.currentThisScope = function () {
        for (var i = this.scopeStack.length - 1;; i--) {
          var scope = this.scopeStack[i];
          if (scope.flags & SCOPE_VAR$1 && !(scope.flags & SCOPE_ARROW$1)) {
            return scope;
          }
        }
      };
      var Node$3 = function Node(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation$2(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [
            pos,
            0
          ];
        }
      };
      var pp$6$1 = Parser$2.prototype;
      pp$6$1.startNode = function () {
        return new Node$3(this, this.start, this.startLoc);
      };
      pp$6$1.startNodeAt = function (pos, loc) {
        return new Node$3(this, pos, loc);
      };
      function finishNodeAt$1(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations) {
          node.loc.end = loc;
        }
        if (this.options.ranges) {
          node.range[1] = pos;
        }
        return node;
      }
      pp$6$1.finishNode = function (node, type) {
        return finishNodeAt$1.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$6$1.finishNodeAt = function (node, type, pos, loc) {
        return finishNodeAt$1.call(this, node, type, pos, loc);
      };
      pp$6$1.copyNode = function (node) {
        var newNode = new Node$3(this, node.start, this.startLoc);
        for (var prop in node) {
          newNode[prop] = node[prop];
        }
        return newNode;
      };
      var TokContext$2 = function TokContext(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types$1$1 = {
        b_stat: new TokContext$2("{", false),
        b_expr: new TokContext$2("{", true),
        b_tmpl: new TokContext$2("${", false),
        p_stat: new TokContext$2("(", false),
        p_expr: new TokContext$2("(", true),
        q_tmpl: new TokContext$2("`", true, true, function (p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext$2("function", false),
        f_expr: new TokContext$2("function", true),
        f_expr_gen: new TokContext$2("function", true, false, null, true),
        f_gen: new TokContext$2("function", false, false, null, true)
      };
      var pp$7$1 = Parser$2.prototype;
      pp$7$1.initialContext = function () {
        return [types$1$1.b_stat];
      };
      pp$7$1.braceIsBlock = function (prevType) {
        var parent = this.curContext();
        if (parent === types$1$1.f_expr || parent === types$1$1.f_stat) {
          return true;
        }
        if (prevType === types$2.colon && (parent === types$1$1.b_stat || parent === types$1$1.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$2._return || prevType === types$2.name && this.exprAllowed) {
          return lineBreak$2.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$2._else || prevType === types$2.semi || prevType === types$2.eof || prevType === types$2.parenR || prevType === types$2.arrow) {
          return true;
        }
        if (prevType === types$2.braceL) {
          return parent === types$1$1.b_stat;
        }
        if (prevType === types$2._var || prevType === types$2._const || prevType === types$2.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$7$1.inGeneratorContext = function () {
        for (var i = this.context.length - 1; i >= 1; i--) {
          var context = this.context[i];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$7$1.updateContext = function (prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types$2.dot) {
          this.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      types$2.parenR.updateContext = types$2.braceR.updateContext = function () {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types$1$1.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$2.braceL.updateContext = function (prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types$1$1.b_stat : types$1$1.b_expr);
        this.exprAllowed = true;
      };
      types$2.dollarBraceL.updateContext = function () {
        this.context.push(types$1$1.b_tmpl);
        this.exprAllowed = true;
      };
      types$2.parenL.updateContext = function (prevType) {
        var statementParens = prevType === types$2._if || prevType === types$2._for || prevType === types$2._with || prevType === types$2._while;
        this.context.push(statementParens ? types$1$1.p_stat : types$1$1.p_expr);
        this.exprAllowed = true;
      };
      types$2.incDec.updateContext = function () {
      };
      types$2._function.updateContext = types$2._class.updateContext = function (prevType) {
        if (prevType.beforeExpr && prevType !== types$2._else && !(prevType === types$2.semi && this.curContext() !== types$1$1.p_stat) && !(prevType === types$2._return && lineBreak$2.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$2.colon || prevType === types$2.braceL) && this.curContext() === types$1$1.b_stat)) {
          this.context.push(types$1$1.f_expr);
        } else {
          this.context.push(types$1$1.f_stat);
        }
        this.exprAllowed = false;
      };
      types$2.backQuote.updateContext = function () {
        if (this.curContext() === types$1$1.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types$1$1.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$2.star.updateContext = function (prevType) {
        if (prevType === types$2._function) {
          var index = this.context.length - 1;
          if (this.context[index] === types$1$1.f_expr) {
            this.context[index] = types$1$1.f_expr_gen;
          } else {
            this.context[index] = types$1$1.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$2.name.updateContext = function (prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$2.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var ecma9BinaryProperties$1 = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties$1 = ecma9BinaryProperties$1 + " Extended_Pictographic";
      var ecma11BinaryProperties$1 = ecma10BinaryProperties$1;
      var ecma12BinaryProperties$1 = ecma11BinaryProperties$1 + " EBase EComp EMod EPres ExtPict";
      var unicodeBinaryProperties$1 = {
        9: ecma9BinaryProperties$1,
        10: ecma10BinaryProperties$1,
        11: ecma11BinaryProperties$1,
        12: ecma12BinaryProperties$1
      };
      var unicodeGeneralCategoryValues$1 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues$1 = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues$1 = ecma9ScriptValues$1 + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues$1 = ecma10ScriptValues$1 + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues$1 = ecma11ScriptValues$1 + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var unicodeScriptValues$1 = {
        9: ecma9ScriptValues$1,
        10: ecma10ScriptValues$1,
        11: ecma11ScriptValues$1,
        12: ecma12ScriptValues$1
      };
      var data$1 = {};
      function buildUnicodeData$1(ecmaVersion) {
        var d = data$1[ecmaVersion] = {
          binary: wordsRegexp$1(unicodeBinaryProperties$1[ecmaVersion] + " " + unicodeGeneralCategoryValues$1),
          nonBinary: {
            General_Category: wordsRegexp$1(unicodeGeneralCategoryValues$1),
            Script: wordsRegexp$1(unicodeScriptValues$1[ecmaVersion])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      buildUnicodeData$1(9);
      buildUnicodeData$1(10);
      buildUnicodeData$1(11);
      buildUnicodeData$1(12);
      var pp$8$1 = Parser$2.prototype;
      var RegExpValidationState$1 = function RegExpValidationState(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
        this.unicodeProperties = data$1[parser.options.ecmaVersion >= 12 ? 12 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = [];
        this.backReferenceNames = [];
      };
      RegExpValidationState$1.prototype.reset = function reset(start, pattern, flags) {
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
      };
      RegExpValidationState$1.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState$1.prototype.at = function at(i, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) {
          return -1;
        }
        var c = s.charCodeAt(i);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState$1.prototype.nextIndex = function nextIndex(i, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) {
          return l;
        }
        var c = s.charCodeAt(i), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
          return i + 1;
        }
        return i + 2;
      };
      RegExpValidationState$1.prototype.current = function current(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState$1.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState$1.prototype.advance = function advance(forceU) {
        if (forceU === void 0)
          forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState$1.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0)
          forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      function codePointToString$1(ch) {
        if (ch <= 65535) {
          return String.fromCharCode(ch);
        }
        ch -= 65536;
        return String.fromCharCode((ch >> 10) + 55296, (ch & 1023) + 56320);
      }
      pp$8$1.validateRegExpFlags = function (state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        for (var i = 0; i < flags.length; i++) {
          var flag = flags.charAt(i);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
        }
      };
      pp$8$1.validateRegExpPattern = function (state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$8$1.regexp_pattern = function (state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames.length = 0;
        state.backReferenceNames.length = 0;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(41)) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(93) || state.eat(125)) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
          var name = list[i];
          if (state.groupNames.indexOf(name) === -1) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$8$1.regexp_disjunction = function (state) {
        this.regexp_alternative(state);
        while (state.eat(124)) {
          this.regexp_alternative(state);
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(123)) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$8$1.regexp_alternative = function (state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$8$1.regexp_eatTerm = function (state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$8$1.regexp_eatAssertion = function (state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(94) || state.eat(36)) {
          return true;
        }
        if (state.eat(92)) {
          if (state.eat(66) || state.eat(98)) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(40) && state.eat(63)) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(60);
          }
          if (state.eat(61) || state.eat(33)) {
            this.regexp_disjunction(state);
            if (!state.eat(41)) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$8$1.regexp_eatQuantifier = function (state, noError) {
        if (noError === void 0)
          noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(63);
          return true;
        }
        return false;
      };
      pp$8$1.regexp_eatQuantifierPrefix = function (state, noError) {
        return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$8$1.regexp_eatBracedQuantifier = function (state, noError) {
        var start = state.pos;
        if (state.eat(123)) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(125)) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8$1.regexp_eatAtom = function (state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$8$1.regexp_eatReverseSolidusAtomEscape = function (state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8$1.regexp_eatUncapturingGroup = function (state) {
        var start = state.pos;
        if (state.eat(40)) {
          if (state.eat(63) && state.eat(58)) {
            this.regexp_disjunction(state);
            if (state.eat(41)) {
              return true;
            }
            state.raise("Unterminated group");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8$1.regexp_eatCapturingGroup = function (state) {
        if (state.eat(40)) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$8$1.regexp_eatExtendedAtom = function (state) {
        return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$8$1.regexp_eatInvalidBracedQuantifier = function (state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$8$1.regexp_eatSyntaxCharacter = function (state) {
        var ch = state.current();
        if (isSyntaxCharacter$1(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter$1(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$8$1.regexp_eatPatternCharacters = function (state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter$1(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$8$1.regexp_eatExtendedPatternCharacter = function (state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$8$1.regexp_groupSpecifier = function (state) {
        if (state.eat(63)) {
          if (this.regexp_eatGroupName(state)) {
            if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
              state.raise("Duplicate capture group name");
            }
            state.groupNames.push(state.lastStringValue);
            return;
          }
          state.raise("Invalid group");
        }
      };
      pp$8$1.regexp_eatGroupName = function (state) {
        state.lastStringValue = "";
        if (state.eat(60)) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$8$1.regexp_eatRegExpIdentifierName = function (state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString$1(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString$1(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$8$1.regexp_eatRegExpIdentifierStart = function (state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart$1(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart$1(ch) {
        return isIdentifierStart$2(ch, true) || ch === 36 || ch === 95;
      }
      pp$8$1.regexp_eatRegExpIdentifierPart = function (state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart$1(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart$1(ch) {
        return isIdentifierChar$2(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$8$1.regexp_eatAtomEscape = function (state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$8$1.regexp_eatBackReference = function (state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n = state.lastIntValue;
          if (state.switchU) {
            if (n > state.maxBackReference) {
              state.maxBackReference = n;
            }
            return true;
          }
          if (n <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8$1.regexp_eatKGroupName = function (state) {
        if (state.eat(107)) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$8$1.regexp_eatCharacterEscape = function (state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$8$1.regexp_eatCControlLetter = function (state) {
        var start = state.pos;
        if (state.eat(99)) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8$1.regexp_eatZero = function (state) {
        if (state.current() === 48 && !isDecimalDigit$1(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8$1.regexp_eatControlEscape = function (state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8$1.regexp_eatControlLetter = function (state) {
        var ch = state.current();
        if (isControlLetter$1(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter$1(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$8$1.regexp_eatRegExpUnicodeEscapeSequence = function (state, forceU) {
        if (forceU === void 0)
          forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(117)) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode$1(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode$1(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$8$1.regexp_eatIdentityEscape = function (state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(47)) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8$1.regexp_eatDecimalEscape = function (state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      pp$8$1.regexp_eatCharacterClassEscape = function (state) {
        var ch = state.current();
        if (isCharacterClassEscape$1(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return true;
        }
        if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
            return true;
          }
          state.raise("Invalid property name");
        }
        return false;
      };
      function isCharacterClassEscape$1(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$8$1.regexp_eatUnicodePropertyValueExpression = function (state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
          var name = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
            return true;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
          return true;
        }
        return false;
      };
      pp$8$1.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {
        if (!has(state.unicodeProperties.nonBinary, name)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name].test(value)) {
          state.raise("Invalid property value");
        }
      };
      pp$8$1.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {
        if (!state.unicodeProperties.binary.test(nameOrValue)) {
          state.raise("Invalid property name");
        }
      };
      pp$8$1.regexp_eatUnicodePropertyName = function (state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter$1(ch = state.current())) {
          state.lastStringValue += codePointToString$1(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter$1(ch) {
        return isControlLetter$1(ch) || ch === 95;
      }
      pp$8$1.regexp_eatUnicodePropertyValue = function (state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter$1(ch = state.current())) {
          state.lastStringValue += codePointToString$1(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter$1(ch) {
        return isUnicodePropertyNameCharacter$1(ch) || isDecimalDigit$1(ch);
      }
      pp$8$1.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$8$1.regexp_eatCharacterClass = function (state) {
        if (state.eat(91)) {
          state.eat(94);
          this.regexp_classRanges(state);
          if (state.eat(93)) {
            return true;
          }
          state.raise("Unterminated character class");
        }
        return false;
      };
      pp$8$1.regexp_classRanges = function (state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(45) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$8$1.regexp_eatClassAtom = function (state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit$1(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8$1.regexp_eatClassEscape = function (state) {
        var start = state.pos;
        if (state.eat(98)) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(45)) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(99)) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$8$1.regexp_eatClassControlLetter = function (state) {
        var ch = state.current();
        if (isDecimalDigit$1(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8$1.regexp_eatHexEscapeSequence = function (state) {
        var start = state.pos;
        if (state.eat(120)) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8$1.regexp_eatDecimalDigits = function (state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit$1(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit$1(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$8$1.regexp_eatHexDigits = function (state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit$1(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt$1(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit$1(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt$1(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$8$1.regexp_eatLegacyOctalEscapeSequence = function (state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$8$1.regexp_eatOctalDigit = function (state) {
        var ch = state.current();
        if (isOctalDigit$1(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit$1(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$8$1.regexp_eatFixedHexDigits = function (state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i = 0; i < length; ++i) {
          var ch = state.current();
          if (!isHexDigit$1(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt$1(ch);
          state.advance();
        }
        return true;
      };
      var Token$2 = function Token(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation$2(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [
            p.start,
            p.end
          ];
        }
      };
      var pp$9$1 = Parser$2.prototype;
      pp$9$1.next = function (ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token$2(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp$9$1.getToken = function () {
        this.next();
        return new Token$2(this);
      };
      if (typeof Symbol !== "undefined") {
        pp$9$1[Symbol.iterator] = function () {
          var this$1$1 = this;
          return {
            next: function () {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$2.eof,
                value: token
              };
            }
          };
        };
      }
      pp$9$1.curContext = function () {
        return this.context[this.context.length - 1];
      };
      pp$9$1.nextToken = function () {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$2.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp$9$1.readToken = function (code) {
        if (isIdentifierStart$2(code, this.options.ecmaVersion >= 6) || code === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code);
      };
      pp$9$1.fullCharCodeAtPos = function () {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 57344) {
          return code;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return (code << 10) + next - 56613888;
      };
      pp$9$1.skipBlockComment = function () {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          lineBreakG$2.lastIndex = start;
          var match;
          while ((match = lineBreakG$2.exec(this.input)) && match.index < this.pos) {
            ++this.curLine;
            this.lineStart = match.index + match[0].length;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp$9$1.skipLineComment = function (startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine$2(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp$9$1.skipSpace = function () {
        loop:
          while (this.pos < this.input.length) {
            var ch = this.input.charCodeAt(this.pos);
            switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;
              case 47:
                this.skipLineComment(2);
                break;
              default:
                break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace$2.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
            }
          }
      };
      pp$9$1.finishToken = function (type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp$9$1.readToken_dot = function () {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$2.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$2.dot);
        }
      };
      pp$9$1.readToken_slash = function () {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$2.assign, 2);
        }
        return this.finishOp(types$2.slash, 1);
      };
      pp$9$1.readToken_mult_modulo_exp = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types$2.star : types$2.modulo;
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types$2.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$2.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp$9$1.readToken_pipe_amp = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$2.assign, 3);
            }
          }
          return this.finishOp(code === 124 ? types$2.logicalOR : types$2.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$2.assign, 2);
        }
        return this.finishOp(code === 124 ? types$2.bitwiseOR : types$2.bitwiseAND, 1);
      };
      pp$9$1.readToken_caret = function () {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$2.assign, 2);
        }
        return this.finishOp(types$2.bitwiseXOR, 1);
      };
      pp$9$1.readToken_plus_min = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak$2.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$2.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$2.assign, 2);
        }
        return this.finishOp(types$2.plusMin, 1);
      };
      pp$9$1.readToken_lt_gt = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types$2.assign, size + 1);
          }
          return this.finishOp(types$2.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types$2.relational, size);
      };
      pp$9$1.readToken_eq_excl = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$2.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$2.arrow);
        }
        return this.finishOp(code === 61 ? types$2.eq : types$2.prefix, 1);
      };
      pp$9$1.readToken_question = function () {
        var ecmaVersion = this.options.ecmaVersion;
        if (ecmaVersion >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$2.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$2.assign, 3);
              }
            }
            return this.finishOp(types$2.coalesce, 2);
          }
        }
        return this.finishOp(types$2.question, 1);
      };
      pp$9$1.getTokenFromCode = function (code) {
        switch (code) {
        case 46:
          return this.readToken_dot();
        case 40:
          ++this.pos;
          return this.finishToken(types$2.parenL);
        case 41:
          ++this.pos;
          return this.finishToken(types$2.parenR);
        case 59:
          ++this.pos;
          return this.finishToken(types$2.semi);
        case 44:
          ++this.pos;
          return this.finishToken(types$2.comma);
        case 91:
          ++this.pos;
          return this.finishToken(types$2.bracketL);
        case 93:
          ++this.pos;
          return this.finishToken(types$2.bracketR);
        case 123:
          ++this.pos;
          return this.finishToken(types$2.braceL);
        case 125:
          ++this.pos;
          return this.finishToken(types$2.braceR);
        case 58:
          ++this.pos;
          return this.finishToken(types$2.colon);
        case 96:
          if (this.options.ecmaVersion < 6) {
            break;
          }
          ++this.pos;
          return this.finishToken(types$2.backQuote);
        case 48:
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) {
            return this.readRadixNumber(16);
          }
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) {
              return this.readRadixNumber(8);
            }
            if (next === 98 || next === 66) {
              return this.readRadixNumber(2);
            }
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(code);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(code);
        case 124:
        case 38:
          return this.readToken_pipe_amp(code);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(code);
        case 60:
        case 62:
          return this.readToken_lt_gt(code);
        case 61:
        case 33:
          return this.readToken_eq_excl(code);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(types$2.prefix, 1);
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString$1$1(code) + "'");
      };
      pp$9$1.finishOp = function (type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };
      pp$9$1.readRegexp = function () {
        var escaped, inClass, start = this.pos;
        for (;;) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak$2.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState$1(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value = null;
        try {
          value = new RegExp(pattern, flags);
        } catch (e) {
        }
        return this.finishToken(types$2.regexp, {
          pattern: pattern,
          flags: flags,
          value: value
        });
      };
      pp$9$1.readInt = function (radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber$1(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt$1(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp$9$1.readRadixNumber = function (radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt$1(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart$2(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$2.num, val);
      };
      pp$9$1.readNumber = function (startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, undefined, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt$1(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart$2(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$2.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart$2(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber$1(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$2.num, val);
      };
      pp$9$1.readCodePoint = function () {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };
      function codePointToString$1$1(code) {
        if (code <= 65535) {
          return String.fromCharCode(code);
        }
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      pp$9$1.readString = function (quote) {
        var out = "", chunkStart = ++this.pos;
        for (;;) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else {
            if (isNewLine$2(ch, this.options.ecmaVersion >= 10)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$2.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR$1 = {};
      pp$9$1.tryReadTemplateToken = function () {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR$1) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp$9$1.invalidStringToken = function (position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR$1;
        } else {
          this.raise(position, message);
        }
      };
      pp$9$1.readTmplToken = function () {
        var out = "", chunkStart = this.pos;
        for (;;) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$2.template || this.type === types$2.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$2.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$2.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$2.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine$2(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              out += "\n";
              break;
            default:
              out += String.fromCharCode(ch);
              break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp$9$1.readInvalidTemplateToken = function () {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{") {
              break;
            }
          case "`":
            return this.finishToken(types$2.invalidTemplate, this.input.slice(this.start, this.pos));
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp$9$1.readEscapedChar = function (inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return codePointToString$1$1(this.readCodePoint());
        case 116:
          return "\t";
        case 98:
          return "\b";
        case 118:
          return "\x0B";
        case 102:
          return "\f";
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        case 56:
        case 57:
          if (this.strict) {
            this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
          }
          if (inTemplate) {
            var codePos = this.pos - 1;
            this.invalidStringToken(codePos, "Invalid escape sequence in template string");
            return null;
          }
        default:
          if (ch >= 48 && ch <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.pos += octalStr.length - 1;
            ch = this.input.charCodeAt(this.pos);
            if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
              this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
            }
            return String.fromCharCode(octal);
          }
          if (isNewLine$2(ch)) {
            return "";
          }
          return String.fromCharCode(ch);
        }
      };
      pp$9$1.readHexChar = function (len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n;
      };
      pp$9$1.readWord1 = function () {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar$2(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart$2 : isIdentifierChar$2)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString$1$1(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp$9$1.readWord = function () {
        var word = this.readWord1();
        var type = types$2.name;
        if (this.keywords.test(word)) {
          type = keywords$1$1[word];
        }
        return this.finishToken(type, word);
      };
      var version$2 = "8.0.4";
      Parser$2.acorn = {
        Parser: Parser$2,
        version: version$2,
        defaultOptions: defaultOptions$2,
        Position: Position$2,
        SourceLocation: SourceLocation$2,
        getLineInfo: getLineInfo$2,
        Node: Node$3,
        TokenType: TokenType$2,
        tokTypes: types$2,
        keywordTypes: keywords$1$1,
        TokContext: TokContext$2,
        tokContexts: types$1$1,
        isIdentifierChar: isIdentifierChar$2,
        isIdentifierStart: isIdentifierStart$2,
        Token: Token$2,
        isNewLine: isNewLine$2,
        lineBreak: lineBreak$2,
        lineBreakG: lineBreakG$2,
        nonASCIIwhitespace: nonASCIIwhitespace$2
      };
      function parse$3(input, options) {
        return Parser$2.parse(input, options);
      }
      function parseExpressionAt$1(input, pos, options) {
        return Parser$2.parseExpressionAt(input, pos, options);
      }
      function tokenizer$1(input, options) {
        return Parser$2.tokenizer(input, options);
      }

      var acornDefault = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Node: Node$3,
        Parser: Parser$2,
        Position: Position$2,
        SourceLocation: SourceLocation$2,
        TokContext: TokContext$2,
        Token: Token$2,
        TokenType: TokenType$2,
        defaultOptions: defaultOptions$2,
        getLineInfo: getLineInfo$2,
        isIdentifierChar: isIdentifierChar$2,
        isIdentifierStart: isIdentifierStart$2,
        isNewLine: isNewLine$2,
        keywordTypes: keywords$1$1,
        lineBreak: lineBreak$2,
        lineBreakG: lineBreakG$2,
        nonASCIIwhitespace: nonASCIIwhitespace$2,
        parse: parse$3,
        parseExpressionAt: parseExpressionAt$1,
        tokContexts: types$1$1,
        tokTypes: types$2,
        tokenizer: tokenizer$1,
        version: version$2
      });

      var require$$0 = /*@__PURE__*/getAugmentedNamespace(acornDefault);

      const __varRecorder__$b = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/lib/acorn-decorators.cjs", __contextModule__);
      __varRecorder__$b.acorn = require$$0;
      __varRecorder__$b.getAcorn = Parser => {
        if (Parser.acorn)
          return Parser.acorn;
        if (__varRecorder__$b.acorn.version.indexOf("6.") !== 0 && __varRecorder__$b.acorn.version.indexOf("6.0.") === 0 && __varRecorder__$b.acorn.version.indexOf("7.") !== 0) {
          throw new Error(`acorn-private-class-elements requires acorn@^6.1.0 or acorn@7.0.0, not ${ __varRecorder__$b.acorn.version }`);
        }
        for (let cur = Parser; cur && cur !== __varRecorder__$b.acorn.Parser; cur = Object.getPrototypeOf(cur)) {
          if (cur !== __varRecorder__$b.acorn.Parser) {
            throw new Error("acorn-private-class-elements does not support mixing different acorn copies");
          }
        }
        return __varRecorder__$b.acorn;
      };
      __varRecorder__$b.acornDecorators = function extendParser(Parser) {
        if (Parser.prototype._parseDecorator) {
          return Parser;
        }
        const acorn = __varRecorder__$b.getAcorn(Parser);
        class DecoratorParser extends Parser {
          _parseDecorator() {
            let node = this.startNode();
            this.next();
            node.expression = this.parseMaybeUnary();
            return this.finishNode(node, "Decorator");
          }
          getTokenFromCode(code) {
            if (code === 64) {
              ++this.pos;
              return this.finishToken(this.decoratorIdentifier);
            }
            return super.getTokenFromCode(code);
          }
          parseStatement(declaration, topLevel, exports) {
            let decorators = [];
            switch (this.type) {
            case this.decoratorIdentifier:
              while (this.type === this.decoratorIdentifier) {
                decorators.push(this._parseDecorator());
              }
              if (this.type !== acorn.tokTypes._class) {
                this.raise(this.start, "Leading decorators must be attached to a class declaration");
              }
            case acorn.tokTypes._class:
              if (declaration)
                this.unexpected();
              let node = super.parseStatement(declaration, topLevel, exports);
              node.decorators = decorators;
              if (decorators.length) {
                node.start = node.decorators[0].start;
              }
              return node;
            }
            return super.parseStatement(declaration, topLevel, exports);
          }
          parseClass(node, isStatement) {
            node = super.parseClass(node, isStatement);
            node.decorators = [];
            return node;
          }
          parseClassElement(constructorAllowsSuper) {
            let decorators = [];
            switch (this.type) {
            case this.decoratorIdentifier:
              while (this.type === this.decoratorIdentifier) {
                decorators.push(this._parseDecorator());
              }
              if (this.type !== acorn.tokTypes.name && this.type !== acorn.tokTypes.star) {
                this.raise(this.start, "Inline decorators must be attached to a property declaration");
              }
            default:
              if (this.type !== this.privateIdentifierToken && !Object.values(acorn.tokTypes).includes(this.type))
                break;
              let node = super.parseClassElement(constructorAllowsSuper);
              node.decorators = decorators;
              if (decorators.length) {
                node.start = node.decorators[0].start;
              }
              return node;
            }
            return super.parseClassElement(constructorAllowsSuper);
          }
        }
        DecoratorParser.prototype.decoratorIdentifier = new acorn.TokenType("decorator-Identifier");
        return DecoratorParser;
      };
      var acornDecorators = __varRecorder__$b.acornDecorators;
      var _Decorators = acornDecorators;
      var acornDecorators = __varRecorder__$b.acornDecorators;
      __varRecorder__$b.acornDecorators = acornDecorators;
      __varRecorder__$b.default = acornDecorators;

      var _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      var exports$7 = exports('_', {});
      (function (global, factory) {
        factory(exports$7);
      }(exports$7, function (exports) {
        var astralIdentifierCodes = [
          509,
          0,
          227,
          0,
          150,
          4,
          294,
          9,
          1368,
          2,
          2,
          1,
          6,
          3,
          41,
          2,
          5,
          0,
          166,
          1,
          574,
          3,
          9,
          9,
          370,
          1,
          81,
          2,
          71,
          10,
          50,
          3,
          123,
          2,
          54,
          14,
          32,
          10,
          3,
          1,
          11,
          3,
          46,
          10,
          8,
          0,
          46,
          9,
          7,
          2,
          37,
          13,
          2,
          9,
          6,
          1,
          45,
          0,
          13,
          2,
          49,
          13,
          9,
          3,
          2,
          11,
          83,
          11,
          7,
          0,
          3,
          0,
          158,
          11,
          6,
          9,
          7,
          3,
          56,
          1,
          2,
          6,
          3,
          1,
          3,
          2,
          10,
          0,
          11,
          1,
          3,
          6,
          4,
          4,
          193,
          17,
          10,
          9,
          5,
          0,
          82,
          19,
          13,
          9,
          214,
          6,
          3,
          8,
          28,
          1,
          83,
          16,
          16,
          9,
          82,
          12,
          9,
          9,
          84,
          14,
          5,
          9,
          243,
          14,
          166,
          9,
          71,
          5,
          2,
          1,
          3,
          3,
          2,
          0,
          2,
          1,
          13,
          9,
          120,
          6,
          3,
          6,
          4,
          0,
          29,
          9,
          41,
          6,
          2,
          3,
          9,
          0,
          10,
          10,
          47,
          15,
          406,
          7,
          2,
          7,
          17,
          9,
          57,
          21,
          2,
          13,
          123,
          5,
          4,
          0,
          2,
          1,
          2,
          6,
          2,
          0,
          9,
          9,
          49,
          4,
          2,
          1,
          2,
          4,
          9,
          9,
          330,
          3,
          10,
          1,
          2,
          0,
          49,
          6,
          4,
          4,
          14,
          9,
          5351,
          0,
          7,
          14,
          13835,
          9,
          87,
          9,
          39,
          4,
          60,
          6,
          26,
          9,
          1014,
          0,
          2,
          54,
          8,
          3,
          82,
          0,
          12,
          1,
          19628,
          1,
          4706,
          45,
          3,
          22,
          543,
          4,
          4,
          5,
          9,
          7,
          3,
          6,
          31,
          3,
          149,
          2,
          1418,
          49,
          513,
          54,
          5,
          49,
          9,
          0,
          15,
          0,
          23,
          4,
          2,
          14,
          1361,
          6,
          2,
          16,
          3,
          6,
          2,
          1,
          2,
          4,
          101,
          0,
          161,
          6,
          10,
          9,
          357,
          0,
          62,
          13,
          499,
          13,
          983,
          6,
          110,
          6,
          6,
          9,
          4759,
          9,
          787719,
          239
        ];
        var astralIdentifierStartCodes = [
          0,
          11,
          2,
          25,
          2,
          18,
          2,
          1,
          2,
          14,
          3,
          13,
          35,
          122,
          70,
          52,
          268,
          28,
          4,
          48,
          48,
          31,
          14,
          29,
          6,
          37,
          11,
          29,
          3,
          35,
          5,
          7,
          2,
          4,
          43,
          157,
          19,
          35,
          5,
          35,
          5,
          39,
          9,
          51,
          13,
          10,
          2,
          14,
          2,
          6,
          2,
          1,
          2,
          10,
          2,
          14,
          2,
          6,
          2,
          1,
          68,
          310,
          10,
          21,
          11,
          7,
          25,
          5,
          2,
          41,
          2,
          8,
          70,
          5,
          3,
          0,
          2,
          43,
          2,
          1,
          4,
          0,
          3,
          22,
          11,
          22,
          10,
          30,
          66,
          18,
          2,
          1,
          11,
          21,
          11,
          25,
          71,
          55,
          7,
          1,
          65,
          0,
          16,
          3,
          2,
          2,
          2,
          28,
          43,
          28,
          4,
          28,
          36,
          7,
          2,
          27,
          28,
          53,
          11,
          21,
          11,
          18,
          14,
          17,
          111,
          72,
          56,
          50,
          14,
          50,
          14,
          35,
          349,
          41,
          7,
          1,
          79,
          28,
          11,
          0,
          9,
          21,
          43,
          17,
          47,
          20,
          28,
          22,
          13,
          52,
          58,
          1,
          3,
          0,
          14,
          44,
          33,
          24,
          27,
          35,
          30,
          0,
          3,
          0,
          9,
          34,
          4,
          0,
          13,
          47,
          15,
          3,
          22,
          0,
          2,
          0,
          36,
          17,
          2,
          24,
          20,
          1,
          64,
          6,
          2,
          0,
          2,
          3,
          2,
          14,
          2,
          9,
          8,
          46,
          39,
          7,
          3,
          1,
          3,
          21,
          2,
          6,
          2,
          1,
          2,
          4,
          4,
          0,
          19,
          0,
          13,
          4,
          159,
          52,
          19,
          3,
          21,
          2,
          31,
          47,
          21,
          1,
          2,
          0,
          185,
          46,
          42,
          3,
          37,
          47,
          21,
          0,
          60,
          42,
          14,
          0,
          72,
          26,
          38,
          6,
          186,
          43,
          117,
          63,
          32,
          7,
          3,
          0,
          3,
          7,
          2,
          1,
          2,
          23,
          16,
          0,
          2,
          0,
          95,
          7,
          3,
          38,
          17,
          0,
          2,
          0,
          29,
          0,
          11,
          39,
          8,
          0,
          22,
          0,
          12,
          45,
          20,
          0,
          19,
          72,
          264,
          8,
          2,
          36,
          18,
          0,
          50,
          29,
          113,
          6,
          2,
          1,
          2,
          37,
          22,
          0,
          26,
          5,
          2,
          1,
          2,
          31,
          15,
          0,
          328,
          18,
          16,
          0,
          2,
          12,
          2,
          33,
          125,
          0,
          80,
          921,
          103,
          110,
          18,
          195,
          2637,
          96,
          16,
          1071,
          18,
          5,
          4026,
          582,
          8634,
          568,
          8,
          30,
          18,
          78,
          18,
          29,
          19,
          47,
          17,
          3,
          32,
          20,
          6,
          18,
          689,
          63,
          129,
          74,
          6,
          0,
          67,
          12,
          65,
          1,
          2,
          0,
          29,
          6135,
          9,
          1237,
          43,
          8,
          8936,
          3,
          2,
          6,
          2,
          1,
          2,
          290,
          16,
          0,
          30,
          2,
          3,
          0,
          15,
          3,
          9,
          395,
          2309,
          106,
          6,
          12,
          4,
          8,
          8,
          9,
          5991,
          84,
          2,
          70,
          2,
          1,
          3,
          0,
          3,
          1,
          3,
          3,
          2,
          11,
          2,
          0,
          2,
          6,
          2,
          64,
          2,
          3,
          3,
          7,
          2,
          6,
          2,
          27,
          2,
          3,
          2,
          4,
          2,
          0,
          4,
          6,
          2,
          339,
          3,
          24,
          2,
          24,
          2,
          30,
          2,
          24,
          2,
          30,
          2,
          24,
          2,
          30,
          2,
          24,
          2,
          30,
          2,
          24,
          2,
          7,
          1845,
          30,
          7,
          5,
          262,
          61,
          147,
          44,
          11,
          6,
          17,
          0,
          322,
          29,
          19,
          43,
          485,
          27,
          757,
          6,
          2,
          3,
          2,
          1,
          2,
          14,
          2,
          196,
          60,
          67,
          8,
          0,
          1205,
          3,
          2,
          26,
          2,
          1,
          2,
          0,
          3,
          0,
          2,
          9,
          2,
          3,
          2,
          0,
          2,
          0,
          7,
          0,
          5,
          0,
          2,
          0,
          2,
          0,
          2,
          2,
          2,
          1,
          2,
          0,
          3,
          0,
          2,
          0,
          2,
          0,
          2,
          0,
          2,
          0,
          2,
          1,
          2,
          0,
          3,
          3,
          2,
          6,
          2,
          3,
          2,
          3,
          2,
          0,
          2,
          9,
          2,
          16,
          6,
          2,
          2,
          4,
          2,
          16,
          4421,
          42719,
          33,
          4153,
          7,
          221,
          3,
          5761,
          15,
          7472,
          16,
          621,
          2467,
          541,
          1507,
          4938,
          6,
          4191
        ];
        var nonASCIIidentifierChars = "\xB7-\u0387------------\u07FD-----\u0898-\u089F\u08CA----------\u09FE---------\u0AFA-\u0AFF---\u0B55-------\u0C04\u0C3C---------\u0CF3\u0D00-\u0D3B\u0D3C----\u0D81---------\u0ECE---------------\u1369-\u1371-\u1715----\u180F-----\u19DA------\u1ABF-\u1ACE-------------\u1CF7-------\u30FB---\uA82C---\uA8FF------------------\uFF65";
        var nonASCIIidentifierStartChars = "-------------\u0560-\u0588-\u05EF---------\u0860-\u086A\u0870-\u0887\u0889-\u088E-\u08C9--------\u09FC-------------------------\u0C5D-----\u0CDD\u0D04------------\u0E86-\u0E8C-------------------------------------\u171F------\u1878-----------\u1B4C------\u1C90-\u1CBA\u1CBD-\u1CBF--\u1CFA------------------\u2118-----------------------\u309B----\u312F--\u31BF--\u4DBF----------\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-------\uA8FE-----------------------\uAB69-------------------------";
        var reservedWords = {
          3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
          5: "class enum extends super const export import",
          6: "enum",
          strict: "implements interface let package private protected public static yield",
          strictBind: "eval arguments"
        };
        var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
        var keywords$1 = {
          5: ecma5AndLessKeywords,
          "5module": ecma5AndLessKeywords + " export import",
          6: ecma5AndLessKeywords + " const class extends export import super"
        };
        var keywordRelationalOperator = /^in(stanceof)?$/;
        var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
        var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
        function isInAstralSet(code, set) {
          var pos = 65536;
          for (var i = 0; i < set.length; i += 2) {
            pos += set[i];
            if (pos > code) {
              return false;
            }
            pos += set[i + 1];
            if (pos >= code) {
              return true;
            }
          }
          return false;
        }
        function isIdentifierStart(code, astral) {
          if (code < 65) {
            return code === 36;
          }
          if (code < 91) {
            return true;
          }
          if (code < 97) {
            return code === 95;
          }
          if (code < 123) {
            return true;
          }
          if (code <= 65535) {
            return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
          }
          if (astral === false) {
            return false;
          }
          return isInAstralSet(code, astralIdentifierStartCodes);
        }
        function isIdentifierChar(code, astral) {
          if (code < 48) {
            return code === 36;
          }
          if (code < 58) {
            return true;
          }
          if (code < 65) {
            return false;
          }
          if (code < 91) {
            return true;
          }
          if (code < 97) {
            return code === 95;
          }
          if (code < 123) {
            return true;
          }
          if (code <= 65535) {
            return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
          }
          if (astral === false) {
            return false;
          }
          return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
        }
        var TokenType = function TokenType(label, conf) {
          if (conf === void 0)
            conf = {};
          (this || _global$1).label = label;
          (this || _global$1).keyword = conf.keyword;
          (this || _global$1).beforeExpr = !!conf.beforeExpr;
          (this || _global$1).startsExpr = !!conf.startsExpr;
          (this || _global$1).isLoop = !!conf.isLoop;
          (this || _global$1).isAssign = !!conf.isAssign;
          (this || _global$1).prefix = !!conf.prefix;
          (this || _global$1).postfix = !!conf.postfix;
          (this || _global$1).binop = conf.binop || null;
          (this || _global$1).updateContext = null;
        };
        function binop(name, prec) {
          return new TokenType(name, {
            beforeExpr: true,
            binop: prec
          });
        }
        var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
        var keywords = {};
        function kw(name, options) {
          if (options === void 0)
            options = {};
          options.keyword = name;
          return keywords[name] = new TokenType(name, options);
        }
        var types$1 = {
          num: new TokenType("num", startsExpr),
          regexp: new TokenType("regexp", startsExpr),
          string: new TokenType("string", startsExpr),
          name: new TokenType("name", startsExpr),
          privateId: new TokenType("privateId", startsExpr),
          eof: new TokenType("eof"),
          bracketL: new TokenType("[", {
            beforeExpr: true,
            startsExpr: true
          }),
          bracketR: new TokenType("]"),
          braceL: new TokenType("{", {
            beforeExpr: true,
            startsExpr: true
          }),
          braceR: new TokenType("}"),
          parenL: new TokenType("(", {
            beforeExpr: true,
            startsExpr: true
          }),
          parenR: new TokenType(")"),
          comma: new TokenType(",", beforeExpr),
          semi: new TokenType(";", beforeExpr),
          colon: new TokenType(":", beforeExpr),
          dot: new TokenType("."),
          question: new TokenType("?", beforeExpr),
          questionDot: new TokenType("?."),
          arrow: new TokenType("=>", beforeExpr),
          template: new TokenType("template"),
          invalidTemplate: new TokenType("invalidTemplate"),
          ellipsis: new TokenType("...", beforeExpr),
          backQuote: new TokenType("`", startsExpr),
          dollarBraceL: new TokenType("${", {
            beforeExpr: true,
            startsExpr: true
          }),
          eq: new TokenType("=", {
            beforeExpr: true,
            isAssign: true
          }),
          assign: new TokenType("_=", {
            beforeExpr: true,
            isAssign: true
          }),
          incDec: new TokenType("++/--", {
            prefix: true,
            postfix: true,
            startsExpr: true
          }),
          prefix: new TokenType("!/~", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
          }),
          logicalOR: binop("||", 1),
          logicalAND: binop("&&", 2),
          bitwiseOR: binop("|", 3),
          bitwiseXOR: binop("^", 4),
          bitwiseAND: binop("&", 5),
          equality: binop("==/!=/===/!==", 6),
          relational: binop("</>/<=/>=", 7),
          bitShift: binop("<</>>/>>>", 8),
          plusMin: new TokenType("+/-", {
            beforeExpr: true,
            binop: 9,
            prefix: true,
            startsExpr: true
          }),
          modulo: binop("%", 10),
          star: binop("*", 10),
          slash: binop("/", 10),
          starstar: new TokenType("**", { beforeExpr: true }),
          coalesce: binop("??", 1),
          _break: kw("break"),
          _case: kw("case", beforeExpr),
          _catch: kw("catch"),
          _continue: kw("continue"),
          _debugger: kw("debugger"),
          _default: kw("default", beforeExpr),
          _do: kw("do", {
            isLoop: true,
            beforeExpr: true
          }),
          _else: kw("else", beforeExpr),
          _finally: kw("finally"),
          _for: kw("for", { isLoop: true }),
          _function: kw("function", startsExpr),
          _if: kw("if"),
          _return: kw("return", beforeExpr),
          _switch: kw("switch"),
          _throw: kw("throw", beforeExpr),
          _try: kw("try"),
          _var: kw("var"),
          _const: kw("const"),
          _while: kw("while", { isLoop: true }),
          _with: kw("with"),
          _new: kw("new", {
            beforeExpr: true,
            startsExpr: true
          }),
          _this: kw("this", startsExpr),
          _super: kw("super", startsExpr),
          _class: kw("class", startsExpr),
          _extends: kw("extends", beforeExpr),
          _export: kw("export"),
          _import: kw("import", startsExpr),
          _null: kw("null", startsExpr),
          _true: kw("true", startsExpr),
          _false: kw("false", startsExpr),
          _in: kw("in", {
            beforeExpr: true,
            binop: 7
          }),
          _instanceof: kw("instanceof", {
            beforeExpr: true,
            binop: 7
          }),
          _typeof: kw("typeof", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
          }),
          _void: kw("void", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
          }),
          _delete: kw("delete", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
          })
        };
        var lineBreak = /\r\n?|\n|\u2028|\u2029/;
        var lineBreakG = new RegExp(lineBreak.source, "g");
        function isNewLine(code) {
          return code === 10 || code === 13 || code === 8232 || code === 8233;
        }
        function nextLineBreak(code, from, end) {
          if (end === void 0)
            end = code.length;
          for (var i = from; i < end; i++) {
            var next = code.charCodeAt(i);
            if (isNewLine(next)) {
              return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
            }
          }
          return -1;
        }
        var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
        var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
        var ref = Object.prototype;
        var hasOwnProperty = ref.hasOwnProperty;
        var toString = ref.toString;
        var hasOwn = Object.hasOwn || function (obj, propName) {
          return hasOwnProperty.call(obj, propName);
        };
        var isArray = Array.isArray || function (obj) {
          return toString.call(obj) === "[object Array]";
        };
        var regexpCache = Object.create(null);
        function wordsRegexp(words) {
          return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
        }
        function codePointToString(code) {
          if (code <= 65535) {
            return String.fromCharCode(code);
          }
          code -= 65536;
          return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
        }
        var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
        var Position = function Position(line, col) {
          (this || _global$1).line = line;
          (this || _global$1).column = col;
        };
        Position.prototype.offset = function offset(n) {
          return new Position((this || _global$1).line, (this || _global$1).column + n);
        };
        var SourceLocation = function SourceLocation(p, start, end) {
          (this || _global$1).start = start;
          (this || _global$1).end = end;
          if (p.sourceFile !== null) {
            (this || _global$1).source = p.sourceFile;
          }
        };
        function getLineInfo(input, offset) {
          for (var line = 1, cur = 0;;) {
            var nextBreak = nextLineBreak(input, cur, offset);
            if (nextBreak < 0) {
              return new Position(line, offset - cur);
            }
            ++line;
            cur = nextBreak;
          }
        }
        var defaultOptions = {
          ecmaVersion: null,
          sourceType: "script",
          onInsertedSemicolon: null,
          onTrailingComma: null,
          allowReserved: null,
          allowReturnOutsideFunction: false,
          allowImportExportEverywhere: false,
          allowAwaitOutsideFunction: null,
          allowSuperOutsideMethod: null,
          allowHashBang: false,
          checkPrivateFields: true,
          locations: false,
          onToken: null,
          onComment: null,
          ranges: false,
          program: null,
          sourceFile: null,
          directSourceFile: null,
          preserveParens: false
        };
        var warnedAboutEcmaVersion = false;
        function getOptions(opts) {
          var options = {};
          for (var opt in defaultOptions) {
            options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
          }
          if (options.ecmaVersion === "latest") {
            options.ecmaVersion = 100000000;
          } else if (options.ecmaVersion == null) {
            if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
              warnedAboutEcmaVersion = true;
              console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
            }
            options.ecmaVersion = 11;
          } else if (options.ecmaVersion >= 2015) {
            options.ecmaVersion -= 2009;
          }
          if (options.allowReserved == null) {
            options.allowReserved = options.ecmaVersion < 5;
          }
          if (!opts || opts.allowHashBang == null) {
            options.allowHashBang = options.ecmaVersion >= 14;
          }
          if (isArray(options.onToken)) {
            var tokens = options.onToken;
            options.onToken = function (token) {
              return tokens.push(token);
            };
          }
          if (isArray(options.onComment)) {
            options.onComment = pushComment(options, options.onComment);
          }
          return options;
        }
        function pushComment(options, array) {
          return function (block, text, start, end, startLoc, endLoc) {
            var comment = {
              type: block ? "Block" : "Line",
              value: text,
              start: start,
              end: end
            };
            if (options.locations) {
              comment.loc = new SourceLocation(this || _global$1, startLoc, endLoc);
            }
            if (options.ranges) {
              comment.range = [
                start,
                end
              ];
            }
            array.push(comment);
          };
        }
        var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
        function functionFlags(async, generator) {
          return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
        }
        var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
        var Parser = function Parser(options, input, startPos) {
          (this || _global$1).options = options = getOptions(options);
          (this || _global$1).sourceFile = options.sourceFile;
          (this || _global$1).keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
          var reserved = "";
          if (options.allowReserved !== true) {
            reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
            if (options.sourceType === "module") {
              reserved += " await";
            }
          }
          (this || _global$1).reservedWords = wordsRegexp(reserved);
          var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
          (this || _global$1).reservedWordsStrict = wordsRegexp(reservedStrict);
          (this || _global$1).reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
          (this || _global$1).input = String(input);
          (this || _global$1).containsEsc = false;
          if (startPos) {
            (this || _global$1).pos = startPos;
            (this || _global$1).lineStart = (this || _global$1).input.lastIndexOf("\n", startPos - 1) + 1;
            (this || _global$1).curLine = (this || _global$1).input.slice(0, (this || _global$1).lineStart).split(lineBreak).length;
          } else {
            (this || _global$1).pos = (this || _global$1).lineStart = 0;
            (this || _global$1).curLine = 1;
          }
          (this || _global$1).type = types$1.eof;
          (this || _global$1).value = null;
          (this || _global$1).start = (this || _global$1).end = (this || _global$1).pos;
          (this || _global$1).startLoc = (this || _global$1).endLoc = this.curPosition();
          (this || _global$1).lastTokEndLoc = (this || _global$1).lastTokStartLoc = null;
          (this || _global$1).lastTokStart = (this || _global$1).lastTokEnd = (this || _global$1).pos;
          (this || _global$1).context = this.initialContext();
          (this || _global$1).exprAllowed = true;
          (this || _global$1).inModule = options.sourceType === "module";
          (this || _global$1).strict = (this || _global$1).inModule || this.strictDirective((this || _global$1).pos);
          (this || _global$1).potentialArrowAt = -1;
          (this || _global$1).potentialArrowInForAwait = false;
          (this || _global$1).yieldPos = (this || _global$1).awaitPos = (this || _global$1).awaitIdentPos = 0;
          (this || _global$1).labels = [];
          (this || _global$1).undefinedExports = Object.create(null);
          if ((this || _global$1).pos === 0 && options.allowHashBang && (this || _global$1).input.slice(0, 2) === "#!") {
            this.skipLineComment(2);
          }
          (this || _global$1).scopeStack = [];
          this.enterScope(SCOPE_TOP);
          (this || _global$1).regexpState = null;
          (this || _global$1).privateNameStack = [];
        };
        var prototypeAccessors = {
          inFunction: { configurable: true },
          inGenerator: { configurable: true },
          inAsync: { configurable: true },
          canAwait: { configurable: true },
          allowSuper: { configurable: true },
          allowDirectSuper: { configurable: true },
          treatFunctionsAsVar: { configurable: true },
          allowNewDotTarget: { configurable: true },
          inClassStaticBlock: { configurable: true }
        };
        Parser.prototype.parse = function parse() {
          var node = (this || _global$1).options.program || this.startNode();
          this.nextToken();
          return this.parseTopLevel(node);
        };
        prototypeAccessors.inFunction.get = function () {
          return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
        };
        prototypeAccessors.inGenerator.get = function () {
          return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
        };
        prototypeAccessors.inAsync.get = function () {
          return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
        };
        prototypeAccessors.canAwait.get = function () {
          for (var i = (this || _global$1).scopeStack.length - 1; i >= 0; i--) {
            var scope = (this || _global$1).scopeStack[i];
            if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
              return false;
            }
            if (scope.flags & SCOPE_FUNCTION) {
              return (scope.flags & SCOPE_ASYNC) > 0;
            }
          }
          return (this || _global$1).inModule && (this || _global$1).options.ecmaVersion >= 13 || (this || _global$1).options.allowAwaitOutsideFunction;
        };
        prototypeAccessors.allowSuper.get = function () {
          var ref = this.currentThisScope();
          var flags = ref.flags;
          var inClassFieldInit = ref.inClassFieldInit;
          return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || (this || _global$1).options.allowSuperOutsideMethod;
        };
        prototypeAccessors.allowDirectSuper.get = function () {
          return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
        };
        prototypeAccessors.treatFunctionsAsVar.get = function () {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        };
        prototypeAccessors.allowNewDotTarget.get = function () {
          var ref = this.currentThisScope();
          var flags = ref.flags;
          var inClassFieldInit = ref.inClassFieldInit;
          return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
        };
        prototypeAccessors.inClassStaticBlock.get = function () {
          return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
        };
        Parser.extend = function extend() {
          var plugins = [], len = arguments.length;
          while (len--)
            plugins[len] = arguments[len];
          var cls = this || _global$1;
          for (var i = 0; i < plugins.length; i++) {
            cls = plugins[i](cls);
          }
          return cls;
        };
        Parser.parse = function parse(input, options) {
          return new (this || _global$1)(options, input).parse();
        };
        Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
          var parser = new (this || _global$1)(options, input, pos);
          parser.nextToken();
          return parser.parseExpression();
        };
        Parser.tokenizer = function tokenizer(input, options) {
          return new (this || _global$1)(options, input);
        };
        Object.defineProperties(Parser.prototype, prototypeAccessors);
        var pp$9 = Parser.prototype;
        var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
        pp$9.strictDirective = function (start) {
          if ((this || _global$1).options.ecmaVersion < 5) {
            return false;
          }
          for (;;) {
            skipWhiteSpace.lastIndex = start;
            start += skipWhiteSpace.exec((this || _global$1).input)[0].length;
            var match = literal.exec((this || _global$1).input.slice(start));
            if (!match) {
              return false;
            }
            if ((match[1] || match[2]) === "use strict") {
              skipWhiteSpace.lastIndex = start + match[0].length;
              var spaceAfter = skipWhiteSpace.exec((this || _global$1).input), end = spaceAfter.index + spaceAfter[0].length;
              var next = (this || _global$1).input.charAt(end);
              return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && (this || _global$1).input.charAt(end + 1) === "=");
            }
            start += match[0].length;
            skipWhiteSpace.lastIndex = start;
            start += skipWhiteSpace.exec((this || _global$1).input)[0].length;
            if ((this || _global$1).input[start] === ";") {
              start++;
            }
          }
        };
        pp$9.eat = function (type) {
          if ((this || _global$1).type === type) {
            this.next();
            return true;
          } else {
            return false;
          }
        };
        pp$9.isContextual = function (name) {
          return (this || _global$1).type === types$1.name && (this || _global$1).value === name && !(this || _global$1).containsEsc;
        };
        pp$9.eatContextual = function (name) {
          if (!this.isContextual(name)) {
            return false;
          }
          this.next();
          return true;
        };
        pp$9.expectContextual = function (name) {
          if (!this.eatContextual(name)) {
            this.unexpected();
          }
        };
        pp$9.canInsertSemicolon = function () {
          return (this || _global$1).type === types$1.eof || (this || _global$1).type === types$1.braceR || lineBreak.test((this || _global$1).input.slice((this || _global$1).lastTokEnd, (this || _global$1).start));
        };
        pp$9.insertSemicolon = function () {
          if (this.canInsertSemicolon()) {
            if ((this || _global$1).options.onInsertedSemicolon) {
              (this || _global$1).options.onInsertedSemicolon((this || _global$1).lastTokEnd, (this || _global$1).lastTokEndLoc);
            }
            return true;
          }
        };
        pp$9.semicolon = function () {
          if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
            this.unexpected();
          }
        };
        pp$9.afterTrailingComma = function (tokType, notNext) {
          if ((this || _global$1).type === tokType) {
            if ((this || _global$1).options.onTrailingComma) {
              (this || _global$1).options.onTrailingComma((this || _global$1).lastTokStart, (this || _global$1).lastTokStartLoc);
            }
            if (!notNext) {
              this.next();
            }
            return true;
          }
        };
        pp$9.expect = function (type) {
          this.eat(type) || this.unexpected();
        };
        pp$9.unexpected = function (pos) {
          this.raise(pos != null ? pos : (this || _global$1).start, "Unexpected token");
        };
        var DestructuringErrors = function DestructuringErrors() {
          (this || _global$1).shorthandAssign = (this || _global$1).trailingComma = (this || _global$1).parenthesizedAssign = (this || _global$1).parenthesizedBind = (this || _global$1).doubleProto = -1;
        };
        pp$9.checkPatternErrors = function (refDestructuringErrors, isAssign) {
          if (!refDestructuringErrors) {
            return;
          }
          if (refDestructuringErrors.trailingComma > -1) {
            this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
          }
          var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
          if (parens > -1) {
            this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
          }
        };
        pp$9.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
          if (!refDestructuringErrors) {
            return false;
          }
          var shorthandAssign = refDestructuringErrors.shorthandAssign;
          var doubleProto = refDestructuringErrors.doubleProto;
          if (!andThrow) {
            return shorthandAssign >= 0 || doubleProto >= 0;
          }
          if (shorthandAssign >= 0) {
            this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
          }
          if (doubleProto >= 0) {
            this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
          }
        };
        pp$9.checkYieldAwaitInDefaultParams = function () {
          if ((this || _global$1).yieldPos && (!(this || _global$1).awaitPos || (this || _global$1).yieldPos < (this || _global$1).awaitPos)) {
            this.raise((this || _global$1).yieldPos, "Yield expression cannot be a default value");
          }
          if ((this || _global$1).awaitPos) {
            this.raise((this || _global$1).awaitPos, "Await expression cannot be a default value");
          }
        };
        pp$9.isSimpleAssignTarget = function (expr) {
          if (expr.type === "ParenthesizedExpression") {
            return this.isSimpleAssignTarget(expr.expression);
          }
          return expr.type === "Identifier" || expr.type === "MemberExpression";
        };
        var pp$8 = Parser.prototype;
        pp$8.parseTopLevel = function (node) {
          var exports = Object.create(null);
          if (!node.body) {
            node.body = [];
          }
          while ((this || _global$1).type !== types$1.eof) {
            var stmt = this.parseStatement(null, true, exports);
            node.body.push(stmt);
          }
          if ((this || _global$1).inModule) {
            for (var i = 0, list = Object.keys((this || _global$1).undefinedExports); i < list.length; i += 1) {
              var name = list[i];
              this.raiseRecoverable((this || _global$1).undefinedExports[name].start, "Export '" + name + "' is not defined");
            }
          }
          this.adaptDirectivePrologue(node.body);
          this.next();
          node.sourceType = (this || _global$1).options.sourceType;
          return this.finishNode(node, "Program");
        };
        var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
        pp$8.isLet = function (context) {
          if ((this || _global$1).options.ecmaVersion < 6 || !this.isContextual("let")) {
            return false;
          }
          skipWhiteSpace.lastIndex = (this || _global$1).pos;
          var skip = skipWhiteSpace.exec((this || _global$1).input);
          var next = (this || _global$1).pos + skip[0].length, nextCh = (this || _global$1).input.charCodeAt(next);
          if (nextCh === 91 || nextCh === 92) {
            return true;
          }
          if (context) {
            return false;
          }
          if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          if (isIdentifierStart(nextCh, true)) {
            var pos = next + 1;
            while (isIdentifierChar(nextCh = (this || _global$1).input.charCodeAt(pos), true)) {
              ++pos;
            }
            if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
              return true;
            }
            var ident = (this || _global$1).input.slice(next, pos);
            if (!keywordRelationalOperator.test(ident)) {
              return true;
            }
          }
          return false;
        };
        pp$8.isAsyncFunction = function () {
          if ((this || _global$1).options.ecmaVersion < 8 || !this.isContextual("async")) {
            return false;
          }
          skipWhiteSpace.lastIndex = (this || _global$1).pos;
          var skip = skipWhiteSpace.exec((this || _global$1).input);
          var next = (this || _global$1).pos + skip[0].length, after;
          return !lineBreak.test((this || _global$1).input.slice((this || _global$1).pos, next)) && (this || _global$1).input.slice(next, next + 8) === "function" && (next + 8 === (this || _global$1).input.length || !(isIdentifierChar(after = (this || _global$1).input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
        };
        pp$8.parseStatement = function (context, topLevel, exports) {
          var starttype = (this || _global$1).type, node = this.startNode(), kind;
          if (this.isLet(context)) {
            starttype = types$1._var;
            kind = "let";
          }
          switch (starttype) {
          case types$1._break:
          case types$1._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
          case types$1._debugger:
            return this.parseDebuggerStatement(node);
          case types$1._do:
            return this.parseDoStatement(node);
          case types$1._for:
            return this.parseForStatement(node);
          case types$1._function:
            if (context && ((this || _global$1).strict || context !== "if" && context !== "label") && (this || _global$1).options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node, false, !context);
          case types$1._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node, true);
          case types$1._if:
            return this.parseIfStatement(node);
          case types$1._return:
            return this.parseReturnStatement(node);
          case types$1._switch:
            return this.parseSwitchStatement(node);
          case types$1._throw:
            return this.parseThrowStatement(node);
          case types$1._try:
            return this.parseTryStatement(node);
          case types$1._const:
          case types$1._var:
            kind = kind || (this || _global$1).value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node, kind);
          case types$1._while:
            return this.parseWhileStatement(node);
          case types$1._with:
            return this.parseWithStatement(node);
          case types$1.braceL:
            return this.parseBlock(true, node);
          case types$1.semi:
            return this.parseEmptyStatement(node);
          case types$1._export:
          case types$1._import:
            if ((this || _global$1).options.ecmaVersion > 10 && starttype === types$1._import) {
              skipWhiteSpace.lastIndex = (this || _global$1).pos;
              var skip = skipWhiteSpace.exec((this || _global$1).input);
              var next = (this || _global$1).pos + skip[0].length, nextCh = (this || _global$1).input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node, this.parseExpression());
              }
            }
            if (!(this || _global$1).options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise((this || _global$1).start, "'import' and 'export' may only appear at the top level");
              }
              if (!(this || _global$1).inModule) {
                this.raise((this || _global$1).start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
            var maybeName = (this || _global$1).value, expr = this.parseExpression();
            if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
              return this.parseLabeledStatement(node, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node, expr);
            }
          }
        };
        pp$8.parseBreakContinueStatement = function (node, keyword) {
          var isBreak = keyword === "break";
          this.next();
          if (this.eat(types$1.semi) || this.insertSemicolon()) {
            node.label = null;
          } else if ((this || _global$1).type !== types$1.name) {
            this.unexpected();
          } else {
            node.label = this.parseIdent();
            this.semicolon();
          }
          var i = 0;
          for (; i < (this || _global$1).labels.length; ++i) {
            var lab = (this || _global$1).labels[i];
            if (node.label == null || lab.name === node.label.name) {
              if (lab.kind != null && (isBreak || lab.kind === "loop")) {
                break;
              }
              if (node.label && isBreak) {
                break;
              }
            }
          }
          if (i === (this || _global$1).labels.length) {
            this.raise(node.start, "Unsyntactic " + keyword);
          }
          return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
        };
        pp$8.parseDebuggerStatement = function (node) {
          this.next();
          this.semicolon();
          return this.finishNode(node, "DebuggerStatement");
        };
        pp$8.parseDoStatement = function (node) {
          this.next();
          (this || _global$1).labels.push(loopLabel);
          node.body = this.parseStatement("do");
          (this || _global$1).labels.pop();
          this.expect(types$1._while);
          node.test = this.parseParenExpression();
          if ((this || _global$1).options.ecmaVersion >= 6) {
            this.eat(types$1.semi);
          } else {
            this.semicolon();
          }
          return this.finishNode(node, "DoWhileStatement");
        };
        pp$8.parseForStatement = function (node) {
          this.next();
          var awaitAt = (this || _global$1).options.ecmaVersion >= 9 && (this || _global$1).canAwait && this.eatContextual("await") ? (this || _global$1).lastTokStart : -1;
          (this || _global$1).labels.push(loopLabel);
          this.enterScope(0);
          this.expect(types$1.parenL);
          if ((this || _global$1).type === types$1.semi) {
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, null);
          }
          var isLet = this.isLet();
          if ((this || _global$1).type === types$1._var || (this || _global$1).type === types$1._const || isLet) {
            var init$1 = this.startNode(), kind = isLet ? "let" : (this || _global$1).value;
            this.next();
            this.parseVar(init$1, true, kind);
            this.finishNode(init$1, "VariableDeclaration");
            if (((this || _global$1).type === types$1._in || (this || _global$1).options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
              if ((this || _global$1).options.ecmaVersion >= 9) {
                if ((this || _global$1).type === types$1._in) {
                  if (awaitAt > -1) {
                    this.unexpected(awaitAt);
                  }
                } else {
                  node.await = awaitAt > -1;
                }
              }
              return this.parseForIn(node, init$1);
            }
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, init$1);
          }
          var startsWithLet = this.isContextual("let"), isForOf = false;
          var refDestructuringErrors = new DestructuringErrors();
          var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
          if ((this || _global$1).type === types$1._in || (isForOf = (this || _global$1).options.ecmaVersion >= 6 && this.isContextual("of"))) {
            if ((this || _global$1).options.ecmaVersion >= 9) {
              if ((this || _global$1).type === types$1._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node.await = awaitAt > -1;
              }
            }
            if (startsWithLet && isForOf) {
              this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
            }
            this.toAssignable(init, false, refDestructuringErrors);
            this.checkLValPattern(init);
            return this.parseForIn(node, init);
          } else {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init);
        };
        pp$8.parseFunctionStatement = function (node, isAsync, declarationPosition) {
          this.next();
          return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
        };
        pp$8.parseIfStatement = function (node) {
          this.next();
          node.test = this.parseParenExpression();
          node.consequent = this.parseStatement("if");
          node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
          return this.finishNode(node, "IfStatement");
        };
        pp$8.parseReturnStatement = function (node) {
          if (!(this || _global$1).inFunction && !(this || _global$1).options.allowReturnOutsideFunction) {
            this.raise((this || _global$1).start, "'return' outside of function");
          }
          this.next();
          if (this.eat(types$1.semi) || this.insertSemicolon()) {
            node.argument = null;
          } else {
            node.argument = this.parseExpression();
            this.semicolon();
          }
          return this.finishNode(node, "ReturnStatement");
        };
        pp$8.parseSwitchStatement = function (node) {
          this.next();
          node.discriminant = this.parseParenExpression();
          node.cases = [];
          this.expect(types$1.braceL);
          (this || _global$1).labels.push(switchLabel);
          this.enterScope(0);
          var cur;
          for (var sawDefault = false; (this || _global$1).type !== types$1.braceR;) {
            if ((this || _global$1).type === types$1._case || (this || _global$1).type === types$1._default) {
              var isCase = (this || _global$1).type === types$1._case;
              if (cur) {
                this.finishNode(cur, "SwitchCase");
              }
              node.cases.push(cur = this.startNode());
              cur.consequent = [];
              this.next();
              if (isCase) {
                cur.test = this.parseExpression();
              } else {
                if (sawDefault) {
                  this.raiseRecoverable((this || _global$1).lastTokStart, "Multiple default clauses");
                }
                sawDefault = true;
                cur.test = null;
              }
              this.expect(types$1.colon);
            } else {
              if (!cur) {
                this.unexpected();
              }
              cur.consequent.push(this.parseStatement(null));
            }
          }
          this.exitScope();
          if (cur) {
            this.finishNode(cur, "SwitchCase");
          }
          this.next();
          (this || _global$1).labels.pop();
          return this.finishNode(node, "SwitchStatement");
        };
        pp$8.parseThrowStatement = function (node) {
          this.next();
          if (lineBreak.test((this || _global$1).input.slice((this || _global$1).lastTokEnd, (this || _global$1).start))) {
            this.raise((this || _global$1).lastTokEnd, "Illegal newline after throw");
          }
          node.argument = this.parseExpression();
          this.semicolon();
          return this.finishNode(node, "ThrowStatement");
        };
        var empty$1 = [];
        pp$8.parseCatchClauseParam = function () {
          var param = this.parseBindingAtom();
          var simple = param.type === "Identifier";
          this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
          this.expect(types$1.parenR);
          return param;
        };
        pp$8.parseTryStatement = function (node) {
          this.next();
          node.block = this.parseBlock();
          node.handler = null;
          if ((this || _global$1).type === types$1._catch) {
            var clause = this.startNode();
            this.next();
            if (this.eat(types$1.parenL)) {
              clause.param = this.parseCatchClauseParam();
            } else {
              if ((this || _global$1).options.ecmaVersion < 10) {
                this.unexpected();
              }
              clause.param = null;
              this.enterScope(0);
            }
            clause.body = this.parseBlock(false);
            this.exitScope();
            node.handler = this.finishNode(clause, "CatchClause");
          }
          node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
          if (!node.handler && !node.finalizer) {
            this.raise(node.start, "Missing catch or finally clause");
          }
          return this.finishNode(node, "TryStatement");
        };
        pp$8.parseVarStatement = function (node, kind, allowMissingInitializer) {
          this.next();
          this.parseVar(node, false, kind, allowMissingInitializer);
          this.semicolon();
          return this.finishNode(node, "VariableDeclaration");
        };
        pp$8.parseWhileStatement = function (node) {
          this.next();
          node.test = this.parseParenExpression();
          (this || _global$1).labels.push(loopLabel);
          node.body = this.parseStatement("while");
          (this || _global$1).labels.pop();
          return this.finishNode(node, "WhileStatement");
        };
        pp$8.parseWithStatement = function (node) {
          if ((this || _global$1).strict) {
            this.raise((this || _global$1).start, "'with' in strict mode");
          }
          this.next();
          node.object = this.parseParenExpression();
          node.body = this.parseStatement("with");
          return this.finishNode(node, "WithStatement");
        };
        pp$8.parseEmptyStatement = function (node) {
          this.next();
          return this.finishNode(node, "EmptyStatement");
        };
        pp$8.parseLabeledStatement = function (node, maybeName, expr, context) {
          for (var i$1 = 0, list = (this || _global$1).labels; i$1 < list.length; i$1 += 1) {
            var label = list[i$1];
            if (label.name === maybeName) {
              this.raise(expr.start, "Label '" + maybeName + "' is already declared");
            }
          }
          var kind = (this || _global$1).type.isLoop ? "loop" : (this || _global$1).type === types$1._switch ? "switch" : null;
          for (var i = (this || _global$1).labels.length - 1; i >= 0; i--) {
            var label$1 = (this || _global$1).labels[i];
            if (label$1.statementStart === node.start) {
              label$1.statementStart = (this || _global$1).start;
              label$1.kind = kind;
            } else {
              break;
            }
          }
          (this || _global$1).labels.push({
            name: maybeName,
            kind: kind,
            statementStart: (this || _global$1).start
          });
          node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
          (this || _global$1).labels.pop();
          node.label = expr;
          return this.finishNode(node, "LabeledStatement");
        };
        pp$8.parseExpressionStatement = function (node, expr) {
          node.expression = expr;
          this.semicolon();
          return this.finishNode(node, "ExpressionStatement");
        };
        pp$8.parseBlock = function (createNewLexicalScope, node, exitStrict) {
          if (createNewLexicalScope === void 0)
            createNewLexicalScope = true;
          if (node === void 0)
            node = this.startNode();
          node.body = [];
          this.expect(types$1.braceL);
          if (createNewLexicalScope) {
            this.enterScope(0);
          }
          while ((this || _global$1).type !== types$1.braceR) {
            var stmt = this.parseStatement(null);
            node.body.push(stmt);
          }
          if (exitStrict) {
            (this || _global$1).strict = false;
          }
          this.next();
          if (createNewLexicalScope) {
            this.exitScope();
          }
          return this.finishNode(node, "BlockStatement");
        };
        pp$8.parseFor = function (node, init) {
          node.init = init;
          this.expect(types$1.semi);
          node.test = (this || _global$1).type === types$1.semi ? null : this.parseExpression();
          this.expect(types$1.semi);
          node.update = (this || _global$1).type === types$1.parenR ? null : this.parseExpression();
          this.expect(types$1.parenR);
          node.body = this.parseStatement("for");
          this.exitScope();
          (this || _global$1).labels.pop();
          return this.finishNode(node, "ForStatement");
        };
        pp$8.parseForIn = function (node, init) {
          var isForIn = (this || _global$1).type === types$1._in;
          this.next();
          if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || (this || _global$1).options.ecmaVersion < 8 || (this || _global$1).strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
            this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
          }
          node.left = init;
          node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
          this.expect(types$1.parenR);
          node.body = this.parseStatement("for");
          this.exitScope();
          (this || _global$1).labels.pop();
          return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
        };
        pp$8.parseVar = function (node, isFor, kind, allowMissingInitializer) {
          node.declarations = [];
          node.kind = kind;
          for (;;) {
            var decl = this.startNode();
            this.parseVarId(decl, kind);
            if (this.eat(types$1.eq)) {
              decl.init = this.parseMaybeAssign(isFor);
            } else if (!allowMissingInitializer && kind === "const" && !((this || _global$1).type === types$1._in || (this || _global$1).options.ecmaVersion >= 6 && this.isContextual("of"))) {
              this.unexpected();
            } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && ((this || _global$1).type === types$1._in || this.isContextual("of")))) {
              this.raise((this || _global$1).lastTokEnd, "Complex binding patterns require an initialization value");
            } else {
              decl.init = null;
            }
            node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(types$1.comma)) {
              break;
            }
          }
          return node;
        };
        pp$8.parseVarId = function (decl, kind) {
          decl.id = this.parseBindingAtom();
          this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
        };
        var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
        pp$8.parseFunction = function (node, statement, allowExpressionBody, isAsync, forInit) {
          this.initFunction(node);
          if ((this || _global$1).options.ecmaVersion >= 9 || (this || _global$1).options.ecmaVersion >= 6 && !isAsync) {
            if ((this || _global$1).type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
              this.unexpected();
            }
            node.generator = this.eat(types$1.star);
          }
          if ((this || _global$1).options.ecmaVersion >= 8) {
            node.async = !!isAsync;
          }
          if (statement & FUNC_STATEMENT) {
            node.id = statement & FUNC_NULLABLE_ID && (this || _global$1).type !== types$1.name ? null : this.parseIdent();
            if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
              this.checkLValSimple(node.id, (this || _global$1).strict || node.generator || node.async ? (this || _global$1).treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
            }
          }
          var oldYieldPos = (this || _global$1).yieldPos, oldAwaitPos = (this || _global$1).awaitPos, oldAwaitIdentPos = (this || _global$1).awaitIdentPos;
          (this || _global$1).yieldPos = 0;
          (this || _global$1).awaitPos = 0;
          (this || _global$1).awaitIdentPos = 0;
          this.enterScope(functionFlags(node.async, node.generator));
          if (!(statement & FUNC_STATEMENT)) {
            node.id = (this || _global$1).type === types$1.name ? this.parseIdent() : null;
          }
          this.parseFunctionParams(node);
          this.parseFunctionBody(node, allowExpressionBody, false, forInit);
          (this || _global$1).yieldPos = oldYieldPos;
          (this || _global$1).awaitPos = oldAwaitPos;
          (this || _global$1).awaitIdentPos = oldAwaitIdentPos;
          return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
        };
        pp$8.parseFunctionParams = function (node) {
          this.expect(types$1.parenL);
          node.params = this.parseBindingList(types$1.parenR, false, (this || _global$1).options.ecmaVersion >= 8);
          this.checkYieldAwaitInDefaultParams();
        };
        pp$8.parseClass = function (node, isStatement) {
          this.next();
          var oldStrict = (this || _global$1).strict;
          (this || _global$1).strict = true;
          this.parseClassId(node, isStatement);
          this.parseClassSuper(node);
          var privateNameMap = this.enterClassBody();
          var classBody = this.startNode();
          var hadConstructor = false;
          classBody.body = [];
          this.expect(types$1.braceL);
          while ((this || _global$1).type !== types$1.braceR) {
            var element = this.parseClassElement(node.superClass !== null);
            if (element) {
              classBody.body.push(element);
              if (element.type === "MethodDefinition" && element.kind === "constructor") {
                if (hadConstructor) {
                  this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
                }
                hadConstructor = true;
              } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
                this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
              }
            }
          }
          (this || _global$1).strict = oldStrict;
          this.next();
          node.body = this.finishNode(classBody, "ClassBody");
          this.exitClassBody();
          return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
        };
        pp$8.parseClassElement = function (constructorAllowsSuper) {
          if (this.eat(types$1.semi)) {
            return null;
          }
          var ecmaVersion = (this || _global$1).options.ecmaVersion;
          var node = this.startNode();
          var keyName = "";
          var isGenerator = false;
          var isAsync = false;
          var kind = "method";
          var isStatic = false;
          if (this.eatContextual("static")) {
            if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
              this.parseClassStaticBlock(node);
              return node;
            }
            if (this.isClassElementNameStart() || (this || _global$1).type === types$1.star) {
              isStatic = true;
            } else {
              keyName = "static";
            }
          }
          node.static = isStatic;
          if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
            if ((this.isClassElementNameStart() || (this || _global$1).type === types$1.star) && !this.canInsertSemicolon()) {
              isAsync = true;
            } else {
              keyName = "async";
            }
          }
          if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
            isGenerator = true;
          }
          if (!keyName && !isAsync && !isGenerator) {
            var lastValue = (this || _global$1).value;
            if (this.eatContextual("get") || this.eatContextual("set")) {
              if (this.isClassElementNameStart()) {
                kind = lastValue;
              } else {
                keyName = lastValue;
              }
            }
          }
          if (keyName) {
            node.computed = false;
            node.key = this.startNodeAt((this || _global$1).lastTokStart, (this || _global$1).lastTokStartLoc);
            node.key.name = keyName;
            this.finishNode(node.key, "Identifier");
          } else {
            this.parseClassElementName(node);
          }
          if (ecmaVersion < 13 || (this || _global$1).type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
            var isConstructor = !node.static && checkKeyName(node, "constructor");
            var allowsDirectSuper = isConstructor && constructorAllowsSuper;
            if (isConstructor && kind !== "method") {
              this.raise(node.key.start, "Constructor can't have get/set modifier");
            }
            node.kind = isConstructor ? "constructor" : kind;
            this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
          } else {
            this.parseClassField(node);
          }
          return node;
        };
        pp$8.isClassElementNameStart = function () {
          return (this || _global$1).type === types$1.name || (this || _global$1).type === types$1.privateId || (this || _global$1).type === types$1.num || (this || _global$1).type === types$1.string || (this || _global$1).type === types$1.bracketL || (this || _global$1).type.keyword;
        };
        pp$8.parseClassElementName = function (element) {
          if ((this || _global$1).type === types$1.privateId) {
            if ((this || _global$1).value === "constructor") {
              this.raise((this || _global$1).start, "Classes can't have an element named '#constructor'");
            }
            element.computed = false;
            element.key = this.parsePrivateIdent();
          } else {
            this.parsePropertyName(element);
          }
        };
        pp$8.parseClassMethod = function (method, isGenerator, isAsync, allowsDirectSuper) {
          var key = method.key;
          if (method.kind === "constructor") {
            if (isGenerator) {
              this.raise(key.start, "Constructor can't be a generator");
            }
            if (isAsync) {
              this.raise(key.start, "Constructor can't be an async method");
            }
          } else if (method.static && checkKeyName(method, "prototype")) {
            this.raise(key.start, "Classes may not have a static property named prototype");
          }
          var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
          if (method.kind === "get" && value.params.length !== 0) {
            this.raiseRecoverable(value.start, "getter should have no params");
          }
          if (method.kind === "set" && value.params.length !== 1) {
            this.raiseRecoverable(value.start, "setter should have exactly one param");
          }
          if (method.kind === "set" && value.params[0].type === "RestElement") {
            this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
          }
          return this.finishNode(method, "MethodDefinition");
        };
        pp$8.parseClassField = function (field) {
          if (checkKeyName(field, "constructor")) {
            this.raise(field.key.start, "Classes can't have a field named 'constructor'");
          } else if (field.static && checkKeyName(field, "prototype")) {
            this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
          }
          if (this.eat(types$1.eq)) {
            var scope = this.currentThisScope();
            var inClassFieldInit = scope.inClassFieldInit;
            scope.inClassFieldInit = true;
            field.value = this.parseMaybeAssign();
            scope.inClassFieldInit = inClassFieldInit;
          } else {
            field.value = null;
          }
          this.semicolon();
          return this.finishNode(field, "PropertyDefinition");
        };
        pp$8.parseClassStaticBlock = function (node) {
          node.body = [];
          var oldLabels = (this || _global$1).labels;
          (this || _global$1).labels = [];
          this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
          while ((this || _global$1).type !== types$1.braceR) {
            var stmt = this.parseStatement(null);
            node.body.push(stmt);
          }
          this.next();
          this.exitScope();
          (this || _global$1).labels = oldLabels;
          return this.finishNode(node, "StaticBlock");
        };
        pp$8.parseClassId = function (node, isStatement) {
          if ((this || _global$1).type === types$1.name) {
            node.id = this.parseIdent();
            if (isStatement) {
              this.checkLValSimple(node.id, BIND_LEXICAL, false);
            }
          } else {
            if (isStatement === true) {
              this.unexpected();
            }
            node.id = null;
          }
        };
        pp$8.parseClassSuper = function (node) {
          node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
        };
        pp$8.enterClassBody = function () {
          var element = {
            declared: Object.create(null),
            used: []
          };
          (this || _global$1).privateNameStack.push(element);
          return element.declared;
        };
        pp$8.exitClassBody = function () {
          var ref = (this || _global$1).privateNameStack.pop();
          var declared = ref.declared;
          var used = ref.used;
          if (!(this || _global$1).options.checkPrivateFields) {
            return;
          }
          var len = (this || _global$1).privateNameStack.length;
          var parent = len === 0 ? null : (this || _global$1).privateNameStack[len - 1];
          for (var i = 0; i < used.length; ++i) {
            var id = used[i];
            if (!hasOwn(declared, id.name)) {
              if (parent) {
                parent.used.push(id);
              } else {
                this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
              }
            }
          }
        };
        function isPrivateNameConflicted(privateNameMap, element) {
          var name = element.key.name;
          var curr = privateNameMap[name];
          var next = "true";
          if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
            next = (element.static ? "s" : "i") + element.kind;
          }
          if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
            privateNameMap[name] = "true";
            return false;
          } else if (!curr) {
            privateNameMap[name] = next;
            return false;
          } else {
            return true;
          }
        }
        function checkKeyName(node, name) {
          var computed = node.computed;
          var key = node.key;
          return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
        }
        pp$8.parseExportAllDeclaration = function (node, exports) {
          if ((this || _global$1).options.ecmaVersion >= 11) {
            if (this.eatContextual("as")) {
              node.exported = this.parseModuleExportName();
              this.checkExport(exports, node.exported, (this || _global$1).lastTokStart);
            } else {
              node.exported = null;
            }
          }
          this.expectContextual("from");
          if ((this || _global$1).type !== types$1.string) {
            this.unexpected();
          }
          node.source = this.parseExprAtom();
          this.semicolon();
          return this.finishNode(node, "ExportAllDeclaration");
        };
        pp$8.parseExport = function (node, exports) {
          this.next();
          if (this.eat(types$1.star)) {
            return this.parseExportAllDeclaration(node, exports);
          }
          if (this.eat(types$1._default)) {
            this.checkExport(exports, "default", (this || _global$1).lastTokStart);
            node.declaration = this.parseExportDefaultDeclaration();
            return this.finishNode(node, "ExportDefaultDeclaration");
          }
          if (this.shouldParseExportStatement()) {
            node.declaration = this.parseExportDeclaration(node);
            if (node.declaration.type === "VariableDeclaration") {
              this.checkVariableExport(exports, node.declaration.declarations);
            } else {
              this.checkExport(exports, node.declaration.id, node.declaration.id.start);
            }
            node.specifiers = [];
            node.source = null;
          } else {
            node.declaration = null;
            node.specifiers = this.parseExportSpecifiers(exports);
            if (this.eatContextual("from")) {
              if ((this || _global$1).type !== types$1.string) {
                this.unexpected();
              }
              node.source = this.parseExprAtom();
            } else {
              for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
                var spec = list[i];
                this.checkUnreserved(spec.local);
                this.checkLocalExport(spec.local);
                if (spec.local.type === "Literal") {
                  this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
                }
              }
              node.source = null;
            }
            this.semicolon();
          }
          return this.finishNode(node, "ExportNamedDeclaration");
        };
        pp$8.parseExportDeclaration = function (node) {
          return this.parseStatement(null);
        };
        pp$8.parseExportDefaultDeclaration = function () {
          var isAsync;
          if ((this || _global$1).type === types$1._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) {
              this.next();
            }
            return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
          } else if ((this || _global$1).type === types$1._class) {
            var cNode = this.startNode();
            return this.parseClass(cNode, "nullableID");
          } else {
            var declaration = this.parseMaybeAssign();
            this.semicolon();
            return declaration;
          }
        };
        pp$8.checkExport = function (exports, name, pos) {
          if (!exports) {
            return;
          }
          if (typeof name !== "string") {
            name = name.type === "Identifier" ? name.name : name.value;
          }
          if (hasOwn(exports, name)) {
            this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
          }
          exports[name] = true;
        };
        pp$8.checkPatternExport = function (exports, pat) {
          var type = pat.type;
          if (type === "Identifier") {
            this.checkExport(exports, pat, pat.start);
          } else if (type === "ObjectPattern") {
            for (var i = 0, list = pat.properties; i < list.length; i += 1) {
              var prop = list[i];
              this.checkPatternExport(exports, prop);
            }
          } else if (type === "ArrayPattern") {
            for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
              var elt = list$1[i$1];
              if (elt) {
                this.checkPatternExport(exports, elt);
              }
            }
          } else if (type === "Property") {
            this.checkPatternExport(exports, pat.value);
          } else if (type === "AssignmentPattern") {
            this.checkPatternExport(exports, pat.left);
          } else if (type === "RestElement") {
            this.checkPatternExport(exports, pat.argument);
          }
        };
        pp$8.checkVariableExport = function (exports, decls) {
          if (!exports) {
            return;
          }
          for (var i = 0, list = decls; i < list.length; i += 1) {
            var decl = list[i];
            this.checkPatternExport(exports, decl.id);
          }
        };
        pp$8.shouldParseExportStatement = function () {
          return (this || _global$1).type.keyword === "var" || (this || _global$1).type.keyword === "const" || (this || _global$1).type.keyword === "class" || (this || _global$1).type.keyword === "function" || this.isLet() || this.isAsyncFunction();
        };
        pp$8.parseExportSpecifier = function (exports) {
          var node = this.startNode();
          node.local = this.parseModuleExportName();
          node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
          this.checkExport(exports, node.exported, node.exported.start);
          return this.finishNode(node, "ExportSpecifier");
        };
        pp$8.parseExportSpecifiers = function (exports) {
          var nodes = [], first = true;
          this.expect(types$1.braceL);
          while (!this.eat(types$1.braceR)) {
            if (!first) {
              this.expect(types$1.comma);
              if (this.afterTrailingComma(types$1.braceR)) {
                break;
              }
            } else {
              first = false;
            }
            nodes.push(this.parseExportSpecifier(exports));
          }
          return nodes;
        };
        pp$8.parseImport = function (node) {
          this.next();
          if ((this || _global$1).type === types$1.string) {
            node.specifiers = empty$1;
            node.source = this.parseExprAtom();
          } else {
            node.specifiers = this.parseImportSpecifiers();
            this.expectContextual("from");
            node.source = (this || _global$1).type === types$1.string ? this.parseExprAtom() : this.unexpected();
          }
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        };
        pp$8.parseImportSpecifier = function () {
          var node = this.startNode();
          node.imported = this.parseModuleExportName();
          if (this.eatContextual("as")) {
            node.local = this.parseIdent();
          } else {
            this.checkUnreserved(node.imported);
            node.local = node.imported;
          }
          this.checkLValSimple(node.local, BIND_LEXICAL);
          return this.finishNode(node, "ImportSpecifier");
        };
        pp$8.parseImportDefaultSpecifier = function () {
          var node = this.startNode();
          node.local = this.parseIdent();
          this.checkLValSimple(node.local, BIND_LEXICAL);
          return this.finishNode(node, "ImportDefaultSpecifier");
        };
        pp$8.parseImportNamespaceSpecifier = function () {
          var node = this.startNode();
          this.next();
          this.expectContextual("as");
          node.local = this.parseIdent();
          this.checkLValSimple(node.local, BIND_LEXICAL);
          return this.finishNode(node, "ImportNamespaceSpecifier");
        };
        pp$8.parseImportSpecifiers = function () {
          var nodes = [], first = true;
          if ((this || _global$1).type === types$1.name) {
            nodes.push(this.parseImportDefaultSpecifier());
            if (!this.eat(types$1.comma)) {
              return nodes;
            }
          }
          if ((this || _global$1).type === types$1.star) {
            nodes.push(this.parseImportNamespaceSpecifier());
            return nodes;
          }
          this.expect(types$1.braceL);
          while (!this.eat(types$1.braceR)) {
            if (!first) {
              this.expect(types$1.comma);
              if (this.afterTrailingComma(types$1.braceR)) {
                break;
              }
            } else {
              first = false;
            }
            nodes.push(this.parseImportSpecifier());
          }
          return nodes;
        };
        pp$8.parseModuleExportName = function () {
          if ((this || _global$1).options.ecmaVersion >= 13 && (this || _global$1).type === types$1.string) {
            var stringLiteral = this.parseLiteral((this || _global$1).value);
            if (loneSurrogate.test(stringLiteral.value)) {
              this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
            }
            return stringLiteral;
          }
          return this.parseIdent(true);
        };
        pp$8.adaptDirectivePrologue = function (statements) {
          for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
            statements[i].directive = statements[i].expression.raw.slice(1, -1);
          }
        };
        pp$8.isDirectiveCandidate = function (statement) {
          return (this || _global$1).options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && ((this || _global$1).input[statement.start] === "\"" || (this || _global$1).input[statement.start] === "'");
        };
        var pp$7 = Parser.prototype;
        pp$7.toAssignable = function (node, isBinding, refDestructuringErrors) {
          if ((this || _global$1).options.ecmaVersion >= 6 && node) {
            switch (node.type) {
            case "Identifier":
              if ((this || _global$1).inAsync && node.name === "await") {
                this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i = 0, list = node.properties; i < list.length; i += 1) {
                var prop = list[i];
                this.toAssignable(prop, isBinding);
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node.kind !== "init") {
                this.raise(node.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node.value, isBinding);
              break;
            case "ArrayExpression":
              node.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node.elements, isBinding);
              break;
            case "SpreadElement":
              node.type = "RestElement";
              this.toAssignable(node.argument, isBinding);
              if (node.argument.type === "AssignmentPattern") {
                this.raise(node.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node.start, "Assigning to rvalue");
            }
          } else if (refDestructuringErrors) {
            this.checkPatternErrors(refDestructuringErrors, true);
          }
          return node;
        };
        pp$7.toAssignableList = function (exprList, isBinding) {
          var end = exprList.length;
          for (var i = 0; i < end; i++) {
            var elt = exprList[i];
            if (elt) {
              this.toAssignable(elt, isBinding);
            }
          }
          if (end) {
            var last = exprList[end - 1];
            if ((this || _global$1).options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
              this.unexpected(last.argument.start);
            }
          }
          return exprList;
        };
        pp$7.parseSpread = function (refDestructuringErrors) {
          var node = this.startNode();
          this.next();
          node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          return this.finishNode(node, "SpreadElement");
        };
        pp$7.parseRestBinding = function () {
          var node = this.startNode();
          this.next();
          if ((this || _global$1).options.ecmaVersion === 6 && (this || _global$1).type !== types$1.name) {
            this.unexpected();
          }
          node.argument = this.parseBindingAtom();
          return this.finishNode(node, "RestElement");
        };
        pp$7.parseBindingAtom = function () {
          if ((this || _global$1).options.ecmaVersion >= 6) {
            switch ((this || _global$1).type) {
            case types$1.bracketL:
              var node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(types$1.bracketR, true, true);
              return this.finishNode(node, "ArrayPattern");
            case types$1.braceL:
              return this.parseObj(true);
            }
          }
          return this.parseIdent();
        };
        pp$7.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowModifiers) {
          var elts = [], first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(types$1.comma);
            }
            if (allowEmpty && (this || _global$1).type === types$1.comma) {
              elts.push(null);
            } else if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            } else if ((this || _global$1).type === types$1.ellipsis) {
              var rest = this.parseRestBinding();
              this.parseBindingListItem(rest);
              elts.push(rest);
              if ((this || _global$1).type === types$1.comma) {
                this.raiseRecoverable((this || _global$1).start, "Comma is not permitted after the rest element");
              }
              this.expect(close);
              break;
            } else {
              elts.push(this.parseAssignableListItem(allowModifiers));
            }
          }
          return elts;
        };
        pp$7.parseAssignableListItem = function (allowModifiers) {
          var elem = this.parseMaybeDefault((this || _global$1).start, (this || _global$1).startLoc);
          this.parseBindingListItem(elem);
          return elem;
        };
        pp$7.parseBindingListItem = function (param) {
          return param;
        };
        pp$7.parseMaybeDefault = function (startPos, startLoc, left) {
          left = left || this.parseBindingAtom();
          if ((this || _global$1).options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
            return left;
          }
          var node = this.startNodeAt(startPos, startLoc);
          node.left = left;
          node.right = this.parseMaybeAssign();
          return this.finishNode(node, "AssignmentPattern");
        };
        pp$7.checkLValSimple = function (expr, bindingType, checkClashes) {
          if (bindingType === void 0)
            bindingType = BIND_NONE;
          var isBind = bindingType !== BIND_NONE;
          switch (expr.type) {
          case "Identifier":
            if ((this || _global$1).strict && (this || _global$1).reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (hasOwn(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
          }
        };
        pp$7.checkLValPattern = function (expr, bindingType, checkClashes) {
          if (bindingType === void 0)
            bindingType = BIND_NONE;
          switch (expr.type) {
          case "ObjectPattern":
            for (var i = 0, list = expr.properties; i < list.length; i += 1) {
              var prop = list[i];
              this.checkLValInnerPattern(prop, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
          }
        };
        pp$7.checkLValInnerPattern = function (expr, bindingType, checkClashes) {
          if (bindingType === void 0)
            bindingType = BIND_NONE;
          switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
          }
        };
        var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
          (this || _global$1).token = token;
          (this || _global$1).isExpr = !!isExpr;
          (this || _global$1).preserveSpace = !!preserveSpace;
          (this || _global$1).override = override;
          (this || _global$1).generator = !!generator;
        };
        var types = {
          b_stat: new TokContext("{", false),
          b_expr: new TokContext("{", true),
          b_tmpl: new TokContext("${", false),
          p_stat: new TokContext("(", false),
          p_expr: new TokContext("(", true),
          q_tmpl: new TokContext("`", true, true, function (p) {
            return p.tryReadTemplateToken();
          }),
          f_stat: new TokContext("function", false),
          f_expr: new TokContext("function", true),
          f_expr_gen: new TokContext("function", true, false, null, true),
          f_gen: new TokContext("function", false, false, null, true)
        };
        var pp$6 = Parser.prototype;
        pp$6.initialContext = function () {
          return [types.b_stat];
        };
        pp$6.curContext = function () {
          return (this || _global$1).context[(this || _global$1).context.length - 1];
        };
        pp$6.braceIsBlock = function (prevType) {
          var parent = this.curContext();
          if (parent === types.f_expr || parent === types.f_stat) {
            return true;
          }
          if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
            return !parent.isExpr;
          }
          if (prevType === types$1._return || prevType === types$1.name && (this || _global$1).exprAllowed) {
            return lineBreak.test((this || _global$1).input.slice((this || _global$1).lastTokEnd, (this || _global$1).start));
          }
          if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
            return true;
          }
          if (prevType === types$1.braceL) {
            return parent === types.b_stat;
          }
          if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
            return false;
          }
          return !(this || _global$1).exprAllowed;
        };
        pp$6.inGeneratorContext = function () {
          for (var i = (this || _global$1).context.length - 1; i >= 1; i--) {
            var context = (this || _global$1).context[i];
            if (context.token === "function") {
              return context.generator;
            }
          }
          return false;
        };
        pp$6.updateContext = function (prevType) {
          var update, type = (this || _global$1).type;
          if (type.keyword && prevType === types$1.dot) {
            (this || _global$1).exprAllowed = false;
          } else if (update = type.updateContext) {
            update.call(this || _global$1, prevType);
          } else {
            (this || _global$1).exprAllowed = type.beforeExpr;
          }
        };
        pp$6.overrideContext = function (tokenCtx) {
          if (this.curContext() !== tokenCtx) {
            (this || _global$1).context[(this || _global$1).context.length - 1] = tokenCtx;
          }
        };
        types$1.parenR.updateContext = types$1.braceR.updateContext = function () {
          if ((this || _global$1).context.length === 1) {
            (this || _global$1).exprAllowed = true;
            return;
          }
          var out = (this || _global$1).context.pop();
          if (out === types.b_stat && this.curContext().token === "function") {
            out = (this || _global$1).context.pop();
          }
          (this || _global$1).exprAllowed = !out.isExpr;
        };
        types$1.braceL.updateContext = function (prevType) {
          (this || _global$1).context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
          (this || _global$1).exprAllowed = true;
        };
        types$1.dollarBraceL.updateContext = function () {
          (this || _global$1).context.push(types.b_tmpl);
          (this || _global$1).exprAllowed = true;
        };
        types$1.parenL.updateContext = function (prevType) {
          var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
          (this || _global$1).context.push(statementParens ? types.p_stat : types.p_expr);
          (this || _global$1).exprAllowed = true;
        };
        types$1.incDec.updateContext = function () {
        };
        types$1._function.updateContext = types$1._class.updateContext = function (prevType) {
          if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test((this || _global$1).input.slice((this || _global$1).lastTokEnd, (this || _global$1).start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
            (this || _global$1).context.push(types.f_expr);
          } else {
            (this || _global$1).context.push(types.f_stat);
          }
          (this || _global$1).exprAllowed = false;
        };
        types$1.colon.updateContext = function () {
          if (this.curContext().token === "function") {
            (this || _global$1).context.pop();
          }
          (this || _global$1).exprAllowed = true;
        };
        types$1.backQuote.updateContext = function () {
          if (this.curContext() === types.q_tmpl) {
            (this || _global$1).context.pop();
          } else {
            (this || _global$1).context.push(types.q_tmpl);
          }
          (this || _global$1).exprAllowed = false;
        };
        types$1.star.updateContext = function (prevType) {
          if (prevType === types$1._function) {
            var index = (this || _global$1).context.length - 1;
            if ((this || _global$1).context[index] === types.f_expr) {
              (this || _global$1).context[index] = types.f_expr_gen;
            } else {
              (this || _global$1).context[index] = types.f_gen;
            }
          }
          (this || _global$1).exprAllowed = true;
        };
        types$1.name.updateContext = function (prevType) {
          var allowed = false;
          if ((this || _global$1).options.ecmaVersion >= 6 && prevType !== types$1.dot) {
            if ((this || _global$1).value === "of" && !(this || _global$1).exprAllowed || (this || _global$1).value === "yield" && this.inGeneratorContext()) {
              allowed = true;
            }
          }
          (this || _global$1).exprAllowed = allowed;
        };
        var pp$5 = Parser.prototype;
        pp$5.checkPropClash = function (prop, propHash, refDestructuringErrors) {
          if ((this || _global$1).options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
            return;
          }
          if ((this || _global$1).options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
            return;
          }
          var key = prop.key;
          var name;
          switch (key.type) {
          case "Identifier":
            name = key.name;
            break;
          case "Literal":
            name = String(key.value);
            break;
          default:
            return;
          }
          var kind = prop.kind;
          if ((this || _global$1).options.ecmaVersion >= 6) {
            if (name === "__proto__" && kind === "init") {
              if (propHash.proto) {
                if (refDestructuringErrors) {
                  if (refDestructuringErrors.doubleProto < 0) {
                    refDestructuringErrors.doubleProto = key.start;
                  }
                } else {
                  this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
                }
              }
              propHash.proto = true;
            }
            return;
          }
          name = "$" + name;
          var other = propHash[name];
          if (other) {
            var redefinition;
            if (kind === "init") {
              redefinition = (this || _global$1).strict && other.init || other.get || other.set;
            } else {
              redefinition = other.init || other[kind];
            }
            if (redefinition) {
              this.raiseRecoverable(key.start, "Redefinition of property");
            }
          } else {
            other = propHash[name] = {
              init: false,
              get: false,
              set: false
            };
          }
          other[kind] = true;
        };
        pp$5.parseExpression = function (forInit, refDestructuringErrors) {
          var startPos = (this || _global$1).start, startLoc = (this || _global$1).startLoc;
          var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
          if ((this || _global$1).type === types$1.comma) {
            var node = this.startNodeAt(startPos, startLoc);
            node.expressions = [expr];
            while (this.eat(types$1.comma)) {
              node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
            }
            return this.finishNode(node, "SequenceExpression");
          }
          return expr;
        };
        pp$5.parseMaybeAssign = function (forInit, refDestructuringErrors, afterLeftParse) {
          if (this.isContextual("yield")) {
            if ((this || _global$1).inGenerator) {
              return this.parseYield(forInit);
            } else {
              (this || _global$1).exprAllowed = false;
            }
          }
          var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
          if (refDestructuringErrors) {
            oldParenAssign = refDestructuringErrors.parenthesizedAssign;
            oldTrailingComma = refDestructuringErrors.trailingComma;
            oldDoubleProto = refDestructuringErrors.doubleProto;
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
          } else {
            refDestructuringErrors = new DestructuringErrors();
            ownDestructuringErrors = true;
          }
          var startPos = (this || _global$1).start, startLoc = (this || _global$1).startLoc;
          if ((this || _global$1).type === types$1.parenL || (this || _global$1).type === types$1.name) {
            (this || _global$1).potentialArrowAt = (this || _global$1).start;
            (this || _global$1).potentialArrowInForAwait = forInit === "await";
          }
          var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
          if (afterLeftParse) {
            left = afterLeftParse.call(this || _global$1, left, startPos, startLoc);
          }
          if ((this || _global$1).type.isAssign) {
            var node = this.startNodeAt(startPos, startLoc);
            node.operator = (this || _global$1).value;
            if ((this || _global$1).type === types$1.eq) {
              left = this.toAssignable(left, false, refDestructuringErrors);
            }
            if (!ownDestructuringErrors) {
              refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
            }
            if (refDestructuringErrors.shorthandAssign >= left.start) {
              refDestructuringErrors.shorthandAssign = -1;
            }
            if ((this || _global$1).type === types$1.eq) {
              this.checkLValPattern(left);
            } else {
              this.checkLValSimple(left);
            }
            node.left = left;
            this.next();
            node.right = this.parseMaybeAssign(forInit);
            if (oldDoubleProto > -1) {
              refDestructuringErrors.doubleProto = oldDoubleProto;
            }
            return this.finishNode(node, "AssignmentExpression");
          } else {
            if (ownDestructuringErrors) {
              this.checkExpressionErrors(refDestructuringErrors, true);
            }
          }
          if (oldParenAssign > -1) {
            refDestructuringErrors.parenthesizedAssign = oldParenAssign;
          }
          if (oldTrailingComma > -1) {
            refDestructuringErrors.trailingComma = oldTrailingComma;
          }
          return left;
        };
        pp$5.parseMaybeConditional = function (forInit, refDestructuringErrors) {
          var startPos = (this || _global$1).start, startLoc = (this || _global$1).startLoc;
          var expr = this.parseExprOps(forInit, refDestructuringErrors);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          if (this.eat(types$1.question)) {
            var node = this.startNodeAt(startPos, startLoc);
            node.test = expr;
            node.consequent = this.parseMaybeAssign();
            this.expect(types$1.colon);
            node.alternate = this.parseMaybeAssign(forInit);
            return this.finishNode(node, "ConditionalExpression");
          }
          return expr;
        };
        pp$5.parseExprOps = function (forInit, refDestructuringErrors) {
          var startPos = (this || _global$1).start, startLoc = (this || _global$1).startLoc;
          var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
        };
        pp$5.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, forInit) {
          var prec = (this || _global$1).type.binop;
          if (prec != null && (!forInit || (this || _global$1).type !== types$1._in)) {
            if (prec > minPrec) {
              var logical = (this || _global$1).type === types$1.logicalOR || (this || _global$1).type === types$1.logicalAND;
              var coalesce = (this || _global$1).type === types$1.coalesce;
              if (coalesce) {
                prec = types$1.logicalAND.binop;
              }
              var op = (this || _global$1).value;
              this.next();
              var startPos = (this || _global$1).start, startLoc = (this || _global$1).startLoc;
              var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
              var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
              if (logical && (this || _global$1).type === types$1.coalesce || coalesce && ((this || _global$1).type === types$1.logicalOR || (this || _global$1).type === types$1.logicalAND)) {
                this.raiseRecoverable((this || _global$1).start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
              }
              return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
            }
          }
          return left;
        };
        pp$5.buildBinary = function (startPos, startLoc, left, right, op, logical) {
          if (right.type === "PrivateIdentifier") {
            this.raise(right.start, "Private identifier can only be left side of binary expression");
          }
          var node = this.startNodeAt(startPos, startLoc);
          node.left = left;
          node.operator = op;
          node.right = right;
          return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
        };
        pp$5.parseMaybeUnary = function (refDestructuringErrors, sawUnary, incDec, forInit) {
          var startPos = (this || _global$1).start, startLoc = (this || _global$1).startLoc, expr;
          if (this.isContextual("await") && (this || _global$1).canAwait) {
            expr = this.parseAwait(forInit);
            sawUnary = true;
          } else if ((this || _global$1).type.prefix) {
            var node = this.startNode(), update = (this || _global$1).type === types$1.incDec;
            node.operator = (this || _global$1).value;
            node.prefix = true;
            this.next();
            node.argument = this.parseMaybeUnary(null, true, update, forInit);
            this.checkExpressionErrors(refDestructuringErrors, true);
            if (update) {
              this.checkLValSimple(node.argument);
            } else if ((this || _global$1).strict && node.operator === "delete" && node.argument.type === "Identifier") {
              this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
            } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
              this.raiseRecoverable(node.start, "Private fields can not be deleted");
            } else {
              sawUnary = true;
            }
            expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
          } else if (!sawUnary && (this || _global$1).type === types$1.privateId) {
            if ((forInit || (this || _global$1).privateNameStack.length === 0) && (this || _global$1).options.checkPrivateFields) {
              this.unexpected();
            }
            expr = this.parsePrivateIdent();
            if ((this || _global$1).type !== types$1._in) {
              this.unexpected();
            }
          } else {
            expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
            if (this.checkExpressionErrors(refDestructuringErrors)) {
              return expr;
            }
            while ((this || _global$1).type.postfix && !this.canInsertSemicolon()) {
              var node$1 = this.startNodeAt(startPos, startLoc);
              node$1.operator = (this || _global$1).value;
              node$1.prefix = false;
              node$1.argument = expr;
              this.checkLValSimple(expr);
              this.next();
              expr = this.finishNode(node$1, "UpdateExpression");
            }
          }
          if (!incDec && this.eat(types$1.starstar)) {
            if (sawUnary) {
              this.unexpected((this || _global$1).lastTokStart);
            } else {
              return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
            }
          } else {
            return expr;
          }
        };
        function isPrivateFieldAccess(node) {
          return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
        }
        pp$5.parseExprSubscripts = function (refDestructuringErrors, forInit) {
          var startPos = (this || _global$1).start, startLoc = (this || _global$1).startLoc;
          var expr = this.parseExprAtom(refDestructuringErrors, forInit);
          if (expr.type === "ArrowFunctionExpression" && (this || _global$1).input.slice((this || _global$1).lastTokStart, (this || _global$1).lastTokEnd) !== ")") {
            return expr;
          }
          var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
          if (refDestructuringErrors && result.type === "MemberExpression") {
            if (refDestructuringErrors.parenthesizedAssign >= result.start) {
              refDestructuringErrors.parenthesizedAssign = -1;
            }
            if (refDestructuringErrors.parenthesizedBind >= result.start) {
              refDestructuringErrors.parenthesizedBind = -1;
            }
            if (refDestructuringErrors.trailingComma >= result.start) {
              refDestructuringErrors.trailingComma = -1;
            }
          }
          return result;
        };
        pp$5.parseSubscripts = function (base, startPos, startLoc, noCalls, forInit) {
          var maybeAsyncArrow = (this || _global$1).options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && (this || _global$1).lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && (this || _global$1).potentialArrowAt === base.start;
          var optionalChained = false;
          while (true) {
            var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
            if (element.optional) {
              optionalChained = true;
            }
            if (element === base || element.type === "ArrowFunctionExpression") {
              if (optionalChained) {
                var chainNode = this.startNodeAt(startPos, startLoc);
                chainNode.expression = element;
                element = this.finishNode(chainNode, "ChainExpression");
              }
              return element;
            }
            base = element;
          }
        };
        pp$5.shouldParseAsyncArrow = function () {
          return !this.canInsertSemicolon() && this.eat(types$1.arrow);
        };
        pp$5.parseSubscriptAsyncArrow = function (startPos, startLoc, exprList, forInit) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
        };
        pp$5.parseSubscript = function (base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
          var optionalSupported = (this || _global$1).options.ecmaVersion >= 11;
          var optional = optionalSupported && this.eat(types$1.questionDot);
          if (noCalls && optional) {
            this.raise((this || _global$1).lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
          }
          var computed = this.eat(types$1.bracketL);
          if (computed || optional && (this || _global$1).type !== types$1.parenL && (this || _global$1).type !== types$1.backQuote || this.eat(types$1.dot)) {
            var node = this.startNodeAt(startPos, startLoc);
            node.object = base;
            if (computed) {
              node.property = this.parseExpression();
              this.expect(types$1.bracketR);
            } else if ((this || _global$1).type === types$1.privateId && base.type !== "Super") {
              node.property = this.parsePrivateIdent();
            } else {
              node.property = this.parseIdent((this || _global$1).options.allowReserved !== "never");
            }
            node.computed = !!computed;
            if (optionalSupported) {
              node.optional = optional;
            }
            base = this.finishNode(node, "MemberExpression");
          } else if (!noCalls && this.eat(types$1.parenL)) {
            var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = (this || _global$1).yieldPos, oldAwaitPos = (this || _global$1).awaitPos, oldAwaitIdentPos = (this || _global$1).awaitIdentPos;
            (this || _global$1).yieldPos = 0;
            (this || _global$1).awaitPos = 0;
            (this || _global$1).awaitIdentPos = 0;
            var exprList = this.parseExprList(types$1.parenR, (this || _global$1).options.ecmaVersion >= 8, false, refDestructuringErrors);
            if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
              this.checkPatternErrors(refDestructuringErrors, false);
              this.checkYieldAwaitInDefaultParams();
              if ((this || _global$1).awaitIdentPos > 0) {
                this.raise((this || _global$1).awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
              }
              (this || _global$1).yieldPos = oldYieldPos;
              (this || _global$1).awaitPos = oldAwaitPos;
              (this || _global$1).awaitIdentPos = oldAwaitIdentPos;
              return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
            }
            this.checkExpressionErrors(refDestructuringErrors, true);
            (this || _global$1).yieldPos = oldYieldPos || (this || _global$1).yieldPos;
            (this || _global$1).awaitPos = oldAwaitPos || (this || _global$1).awaitPos;
            (this || _global$1).awaitIdentPos = oldAwaitIdentPos || (this || _global$1).awaitIdentPos;
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.callee = base;
            node$1.arguments = exprList;
            if (optionalSupported) {
              node$1.optional = optional;
            }
            base = this.finishNode(node$1, "CallExpression");
          } else if ((this || _global$1).type === types$1.backQuote) {
            if (optional || optionalChained) {
              this.raise((this || _global$1).start, "Optional chaining cannot appear in the tag of tagged template expressions");
            }
            var node$2 = this.startNodeAt(startPos, startLoc);
            node$2.tag = base;
            node$2.quasi = this.parseTemplate({ isTagged: true });
            base = this.finishNode(node$2, "TaggedTemplateExpression");
          }
          return base;
        };
        pp$5.parseExprAtom = function (refDestructuringErrors, forInit, forNew) {
          if ((this || _global$1).type === types$1.slash) {
            this.readRegexp();
          }
          var node, canBeArrow = (this || _global$1).potentialArrowAt === (this || _global$1).start;
          switch ((this || _global$1).type) {
          case types$1._super:
            if (!(this || _global$1).allowSuper) {
              this.raise((this || _global$1).start, "'super' keyword outside a method");
            }
            node = this.startNode();
            this.next();
            if ((this || _global$1).type === types$1.parenL && !(this || _global$1).allowDirectSuper) {
              this.raise(node.start, "super() call outside constructor of a subclass");
            }
            if ((this || _global$1).type !== types$1.dot && (this || _global$1).type !== types$1.bracketL && (this || _global$1).type !== types$1.parenL) {
              this.unexpected();
            }
            return this.finishNode(node, "Super");
          case types$1._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case types$1.name:
            var startPos = (this || _global$1).start, startLoc = (this || _global$1).startLoc, containsEsc = (this || _global$1).containsEsc;
            var id = this.parseIdent(false);
            if ((this || _global$1).options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
              this.overrideContext(types.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types$1.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
              }
              if ((this || _global$1).options.ecmaVersion >= 8 && id.name === "async" && (this || _global$1).type === types$1.name && !containsEsc && (!(this || _global$1).potentialArrowInForAwait || (this || _global$1).value !== "of" || (this || _global$1).containsEsc)) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
              }
            }
            return id;
          case types$1.regexp:
            var value = (this || _global$1).value;
            node = this.parseLiteral(value.value);
            node.regex = {
              pattern: value.pattern,
              flags: value.flags
            };
            return node;
          case types$1.num:
          case types$1.string:
            return this.parseLiteral((this || _global$1).value);
          case types$1._null:
          case types$1._true:
          case types$1._false:
            node = this.startNode();
            node.value = (this || _global$1).type === types$1._null ? null : (this || _global$1).type === types$1._true;
            node.raw = (this || _global$1).type.keyword;
            this.next();
            return this.finishNode(node, "Literal");
          case types$1.parenL:
            var start = (this || _global$1).start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start;
              }
            }
            return expr;
          case types$1.bracketL:
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node, "ArrayExpression");
          case types$1.braceL:
            this.overrideContext(types.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types$1._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, 0);
          case types$1._class:
            return this.parseClass(this.startNode(), false);
          case types$1._new:
            return this.parseNew();
          case types$1.backQuote:
            return this.parseTemplate();
          case types$1._import:
            if ((this || _global$1).options.ecmaVersion >= 11) {
              return this.parseExprImport(forNew);
            } else {
              return this.unexpected();
            }
          default:
            return this.parseExprAtomDefault();
          }
        };
        pp$5.parseExprAtomDefault = function () {
          this.unexpected();
        };
        pp$5.parseExprImport = function (forNew) {
          var node = this.startNode();
          if ((this || _global$1).containsEsc) {
            this.raiseRecoverable((this || _global$1).start, "Escape sequence in keyword import");
          }
          var meta = this.parseIdent(true);
          if ((this || _global$1).type === types$1.parenL && !forNew) {
            return this.parseDynamicImport(node);
          } else if ((this || _global$1).type === types$1.dot) {
            node.meta = meta;
            return this.parseImportMeta(node);
          } else {
            this.unexpected();
          }
        };
        pp$5.parseDynamicImport = function (node) {
          this.next();
          node.source = this.parseMaybeAssign();
          if (!this.eat(types$1.parenR)) {
            var errorPos = (this || _global$1).start;
            if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
              this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
            } else {
              this.unexpected(errorPos);
            }
          }
          return this.finishNode(node, "ImportExpression");
        };
        pp$5.parseImportMeta = function (node) {
          this.next();
          var containsEsc = (this || _global$1).containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "meta") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
          }
          if ((this || _global$1).options.sourceType !== "module" && !(this || _global$1).options.allowImportExportEverywhere) {
            this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
          }
          return this.finishNode(node, "MetaProperty");
        };
        pp$5.parseLiteral = function (value) {
          var node = this.startNode();
          node.value = value;
          node.raw = (this || _global$1).input.slice((this || _global$1).start, (this || _global$1).end);
          if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
            node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
          }
          this.next();
          return this.finishNode(node, "Literal");
        };
        pp$5.parseParenExpression = function () {
          this.expect(types$1.parenL);
          var val = this.parseExpression();
          this.expect(types$1.parenR);
          return val;
        };
        pp$5.shouldParseArrow = function (exprList) {
          return !this.canInsertSemicolon();
        };
        pp$5.parseParenAndDistinguishExpression = function (canBeArrow, forInit) {
          var startPos = (this || _global$1).start, startLoc = (this || _global$1).startLoc, val, allowTrailingComma = (this || _global$1).options.ecmaVersion >= 8;
          if ((this || _global$1).options.ecmaVersion >= 6) {
            this.next();
            var innerStartPos = (this || _global$1).start, innerStartLoc = (this || _global$1).startLoc;
            var exprList = [], first = true, lastIsComma = false;
            var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = (this || _global$1).yieldPos, oldAwaitPos = (this || _global$1).awaitPos, spreadStart;
            (this || _global$1).yieldPos = 0;
            (this || _global$1).awaitPos = 0;
            while ((this || _global$1).type !== types$1.parenR) {
              first ? first = false : this.expect(types$1.comma);
              if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
                lastIsComma = true;
                break;
              } else if ((this || _global$1).type === types$1.ellipsis) {
                spreadStart = (this || _global$1).start;
                exprList.push(this.parseParenItem(this.parseRestBinding()));
                if ((this || _global$1).type === types$1.comma) {
                  this.raiseRecoverable((this || _global$1).start, "Comma is not permitted after the rest element");
                }
                break;
              } else {
                exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, (this || _global$1).parseParenItem));
              }
            }
            var innerEndPos = (this || _global$1).lastTokEnd, innerEndLoc = (this || _global$1).lastTokEndLoc;
            this.expect(types$1.parenR);
            if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
              this.checkPatternErrors(refDestructuringErrors, false);
              this.checkYieldAwaitInDefaultParams();
              (this || _global$1).yieldPos = oldYieldPos;
              (this || _global$1).awaitPos = oldAwaitPos;
              return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
            }
            if (!exprList.length || lastIsComma) {
              this.unexpected((this || _global$1).lastTokStart);
            }
            if (spreadStart) {
              this.unexpected(spreadStart);
            }
            this.checkExpressionErrors(refDestructuringErrors, true);
            (this || _global$1).yieldPos = oldYieldPos || (this || _global$1).yieldPos;
            (this || _global$1).awaitPos = oldAwaitPos || (this || _global$1).awaitPos;
            if (exprList.length > 1) {
              val = this.startNodeAt(innerStartPos, innerStartLoc);
              val.expressions = exprList;
              this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
            } else {
              val = exprList[0];
            }
          } else {
            val = this.parseParenExpression();
          }
          if ((this || _global$1).options.preserveParens) {
            var par = this.startNodeAt(startPos, startLoc);
            par.expression = val;
            return this.finishNode(par, "ParenthesizedExpression");
          } else {
            return val;
          }
        };
        pp$5.parseParenItem = function (item) {
          return item;
        };
        pp$5.parseParenArrowList = function (startPos, startLoc, exprList, forInit) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
        };
        var empty = [];
        pp$5.parseNew = function () {
          if ((this || _global$1).containsEsc) {
            this.raiseRecoverable((this || _global$1).start, "Escape sequence in keyword new");
          }
          var node = this.startNode();
          this.next();
          if ((this || _global$1).options.ecmaVersion >= 6 && (this || _global$1).type === types$1.dot) {
            var meta = this.startNodeAt(node.start, node.startLoc);
            meta.name = "new";
            node.meta = this.finishNode(meta, "Identifier");
            this.next();
            var containsEsc = (this || _global$1).containsEsc;
            node.property = this.parseIdent(true);
            if (node.property.name !== "target") {
              this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
            }
            if (containsEsc) {
              this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
            }
            if (!(this || _global$1).allowNewDotTarget) {
              this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
            }
            return this.finishNode(node, "MetaProperty");
          }
          var startPos = (this || _global$1).start, startLoc = (this || _global$1).startLoc;
          node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
          if (this.eat(types$1.parenL)) {
            node.arguments = this.parseExprList(types$1.parenR, (this || _global$1).options.ecmaVersion >= 8, false);
          } else {
            node.arguments = empty;
          }
          return this.finishNode(node, "NewExpression");
        };
        pp$5.parseTemplateElement = function (ref) {
          var isTagged = ref.isTagged;
          var elem = this.startNode();
          if ((this || _global$1).type === types$1.invalidTemplate) {
            if (!isTagged) {
              this.raiseRecoverable((this || _global$1).start, "Bad escape sequence in untagged template literal");
            }
            elem.value = {
              raw: (this || _global$1).value,
              cooked: null
            };
          } else {
            elem.value = {
              raw: (this || _global$1).input.slice((this || _global$1).start, (this || _global$1).end).replace(/\r\n?/g, "\n"),
              cooked: (this || _global$1).value
            };
          }
          this.next();
          elem.tail = (this || _global$1).type === types$1.backQuote;
          return this.finishNode(elem, "TemplateElement");
        };
        pp$5.parseTemplate = function (ref) {
          if (ref === void 0)
            ref = {};
          var isTagged = ref.isTagged;
          if (isTagged === void 0)
            isTagged = false;
          var node = this.startNode();
          this.next();
          node.expressions = [];
          var curElt = this.parseTemplateElement({ isTagged: isTagged });
          node.quasis = [curElt];
          while (!curElt.tail) {
            if ((this || _global$1).type === types$1.eof) {
              this.raise((this || _global$1).pos, "Unterminated template literal");
            }
            this.expect(types$1.dollarBraceL);
            node.expressions.push(this.parseExpression());
            this.expect(types$1.braceR);
            node.quasis.push(curElt = this.parseTemplateElement({ isTagged: isTagged }));
          }
          this.next();
          return this.finishNode(node, "TemplateLiteral");
        };
        pp$5.isAsyncProp = function (prop) {
          return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && ((this || _global$1).type === types$1.name || (this || _global$1).type === types$1.num || (this || _global$1).type === types$1.string || (this || _global$1).type === types$1.bracketL || (this || _global$1).type.keyword || (this || _global$1).options.ecmaVersion >= 9 && (this || _global$1).type === types$1.star) && !lineBreak.test((this || _global$1).input.slice((this || _global$1).lastTokEnd, (this || _global$1).start));
        };
        pp$5.parseObj = function (isPattern, refDestructuringErrors) {
          var node = this.startNode(), first = true, propHash = {};
          node.properties = [];
          this.next();
          while (!this.eat(types$1.braceR)) {
            if (!first) {
              this.expect(types$1.comma);
              if ((this || _global$1).options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
                break;
              }
            } else {
              first = false;
            }
            var prop = this.parseProperty(isPattern, refDestructuringErrors);
            if (!isPattern) {
              this.checkPropClash(prop, propHash, refDestructuringErrors);
            }
            node.properties.push(prop);
          }
          return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
        };
        pp$5.parseProperty = function (isPattern, refDestructuringErrors) {
          var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
          if ((this || _global$1).options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
            if (isPattern) {
              prop.argument = this.parseIdent(false);
              if ((this || _global$1).type === types$1.comma) {
                this.raiseRecoverable((this || _global$1).start, "Comma is not permitted after the rest element");
              }
              return this.finishNode(prop, "RestElement");
            }
            prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
            if ((this || _global$1).type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = (this || _global$1).start;
            }
            return this.finishNode(prop, "SpreadElement");
          }
          if ((this || _global$1).options.ecmaVersion >= 6) {
            prop.method = false;
            prop.shorthand = false;
            if (isPattern || refDestructuringErrors) {
              startPos = (this || _global$1).start;
              startLoc = (this || _global$1).startLoc;
            }
            if (!isPattern) {
              isGenerator = this.eat(types$1.star);
            }
          }
          var containsEsc = (this || _global$1).containsEsc;
          this.parsePropertyName(prop);
          if (!isPattern && !containsEsc && (this || _global$1).options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
            isAsync = true;
            isGenerator = (this || _global$1).options.ecmaVersion >= 9 && this.eat(types$1.star);
            this.parsePropertyName(prop);
          } else {
            isAsync = false;
          }
          this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
          return this.finishNode(prop, "Property");
        };
        pp$5.parseGetterSetter = function (prop) {
          prop.kind = prop.key.name;
          this.parsePropertyName(prop);
          prop.value = this.parseMethod(false);
          var paramCount = prop.kind === "get" ? 0 : 1;
          if (prop.value.params.length !== paramCount) {
            var start = prop.value.start;
            if (prop.kind === "get") {
              this.raiseRecoverable(start, "getter should have no params");
            } else {
              this.raiseRecoverable(start, "setter should have exactly one param");
            }
          } else {
            if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
              this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
            }
          }
        };
        pp$5.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
          if ((isGenerator || isAsync) && (this || _global$1).type === types$1.colon) {
            this.unexpected();
          }
          if (this.eat(types$1.colon)) {
            prop.value = isPattern ? this.parseMaybeDefault((this || _global$1).start, (this || _global$1).startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
            prop.kind = "init";
          } else if ((this || _global$1).options.ecmaVersion >= 6 && (this || _global$1).type === types$1.parenL) {
            if (isPattern) {
              this.unexpected();
            }
            prop.kind = "init";
            prop.method = true;
            prop.value = this.parseMethod(isGenerator, isAsync);
          } else if (!isPattern && !containsEsc && (this || _global$1).options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this || _global$1).type !== types$1.comma && (this || _global$1).type !== types$1.braceR && (this || _global$1).type !== types$1.eq) {
            if (isGenerator || isAsync) {
              this.unexpected();
            }
            this.parseGetterSetter(prop);
          } else if ((this || _global$1).options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
            if (isGenerator || isAsync) {
              this.unexpected();
            }
            this.checkUnreserved(prop.key);
            if (prop.key.name === "await" && !(this || _global$1).awaitIdentPos) {
              (this || _global$1).awaitIdentPos = startPos;
            }
            prop.kind = "init";
            if (isPattern) {
              prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
            } else if ((this || _global$1).type === types$1.eq && refDestructuringErrors) {
              if (refDestructuringErrors.shorthandAssign < 0) {
                refDestructuringErrors.shorthandAssign = (this || _global$1).start;
              }
              prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
            } else {
              prop.value = this.copyNode(prop.key);
            }
            prop.shorthand = true;
          } else {
            this.unexpected();
          }
        };
        pp$5.parsePropertyName = function (prop) {
          if ((this || _global$1).options.ecmaVersion >= 6) {
            if (this.eat(types$1.bracketL)) {
              prop.computed = true;
              prop.key = this.parseMaybeAssign();
              this.expect(types$1.bracketR);
              return prop.key;
            } else {
              prop.computed = false;
            }
          }
          return prop.key = (this || _global$1).type === types$1.num || (this || _global$1).type === types$1.string ? this.parseExprAtom() : this.parseIdent((this || _global$1).options.allowReserved !== "never");
        };
        pp$5.initFunction = function (node) {
          node.id = null;
          if ((this || _global$1).options.ecmaVersion >= 6) {
            node.generator = node.expression = false;
          }
          if ((this || _global$1).options.ecmaVersion >= 8) {
            node.async = false;
          }
        };
        pp$5.parseMethod = function (isGenerator, isAsync, allowDirectSuper) {
          var node = this.startNode(), oldYieldPos = (this || _global$1).yieldPos, oldAwaitPos = (this || _global$1).awaitPos, oldAwaitIdentPos = (this || _global$1).awaitIdentPos;
          this.initFunction(node);
          if ((this || _global$1).options.ecmaVersion >= 6) {
            node.generator = isGenerator;
          }
          if ((this || _global$1).options.ecmaVersion >= 8) {
            node.async = !!isAsync;
          }
          (this || _global$1).yieldPos = 0;
          (this || _global$1).awaitPos = 0;
          (this || _global$1).awaitIdentPos = 0;
          this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
          this.expect(types$1.parenL);
          node.params = this.parseBindingList(types$1.parenR, false, (this || _global$1).options.ecmaVersion >= 8);
          this.checkYieldAwaitInDefaultParams();
          this.parseFunctionBody(node, false, true, false);
          (this || _global$1).yieldPos = oldYieldPos;
          (this || _global$1).awaitPos = oldAwaitPos;
          (this || _global$1).awaitIdentPos = oldAwaitIdentPos;
          return this.finishNode(node, "FunctionExpression");
        };
        pp$5.parseArrowExpression = function (node, params, isAsync, forInit) {
          var oldYieldPos = (this || _global$1).yieldPos, oldAwaitPos = (this || _global$1).awaitPos, oldAwaitIdentPos = (this || _global$1).awaitIdentPos;
          this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
          this.initFunction(node);
          if ((this || _global$1).options.ecmaVersion >= 8) {
            node.async = !!isAsync;
          }
          (this || _global$1).yieldPos = 0;
          (this || _global$1).awaitPos = 0;
          (this || _global$1).awaitIdentPos = 0;
          node.params = this.toAssignableList(params, true);
          this.parseFunctionBody(node, true, false, forInit);
          (this || _global$1).yieldPos = oldYieldPos;
          (this || _global$1).awaitPos = oldAwaitPos;
          (this || _global$1).awaitIdentPos = oldAwaitIdentPos;
          return this.finishNode(node, "ArrowFunctionExpression");
        };
        pp$5.parseFunctionBody = function (node, isArrowFunction, isMethod, forInit) {
          var isExpression = isArrowFunction && (this || _global$1).type !== types$1.braceL;
          var oldStrict = (this || _global$1).strict, useStrict = false;
          if (isExpression) {
            node.body = this.parseMaybeAssign(forInit);
            node.expression = true;
            this.checkParams(node, false);
          } else {
            var nonSimple = (this || _global$1).options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
            if (!oldStrict || nonSimple) {
              useStrict = this.strictDirective((this || _global$1).end);
              if (useStrict && nonSimple) {
                this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
              }
            }
            var oldLabels = (this || _global$1).labels;
            (this || _global$1).labels = [];
            if (useStrict) {
              (this || _global$1).strict = true;
            }
            this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
            if ((this || _global$1).strict && node.id) {
              this.checkLValSimple(node.id, BIND_OUTSIDE);
            }
            node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
            node.expression = false;
            this.adaptDirectivePrologue(node.body.body);
            (this || _global$1).labels = oldLabels;
          }
          this.exitScope();
        };
        pp$5.isSimpleParamList = function (params) {
          for (var i = 0, list = params; i < list.length; i += 1) {
            var param = list[i];
            if (param.type !== "Identifier") {
              return false;
            }
          }
          return true;
        };
        pp$5.checkParams = function (node, allowDuplicates) {
          var nameHash = Object.create(null);
          for (var i = 0, list = node.params; i < list.length; i += 1) {
            var param = list[i];
            this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
          }
        };
        pp$5.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
          var elts = [], first = true;
          while (!this.eat(close)) {
            if (!first) {
              this.expect(types$1.comma);
              if (allowTrailingComma && this.afterTrailingComma(close)) {
                break;
              }
            } else {
              first = false;
            }
            var elt = void 0;
            if (allowEmpty && (this || _global$1).type === types$1.comma) {
              elt = null;
            } else if ((this || _global$1).type === types$1.ellipsis) {
              elt = this.parseSpread(refDestructuringErrors);
              if (refDestructuringErrors && (this || _global$1).type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
                refDestructuringErrors.trailingComma = (this || _global$1).start;
              }
            } else {
              elt = this.parseMaybeAssign(false, refDestructuringErrors);
            }
            elts.push(elt);
          }
          return elts;
        };
        pp$5.checkUnreserved = function (ref) {
          var start = ref.start;
          var end = ref.end;
          var name = ref.name;
          if ((this || _global$1).inGenerator && name === "yield") {
            this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
          }
          if ((this || _global$1).inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
          }
          if (this.currentThisScope().inClassFieldInit && name === "arguments") {
            this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
          }
          if ((this || _global$1).inClassStaticBlock && (name === "arguments" || name === "await")) {
            this.raise(start, "Cannot use " + name + " in class static initialization block");
          }
          if ((this || _global$1).keywords.test(name)) {
            this.raise(start, "Unexpected keyword '" + name + "'");
          }
          if ((this || _global$1).options.ecmaVersion < 6 && (this || _global$1).input.slice(start, end).indexOf("\\") !== -1) {
            return;
          }
          var re = (this || _global$1).strict ? (this || _global$1).reservedWordsStrict : (this || _global$1).reservedWords;
          if (re.test(name)) {
            if (!(this || _global$1).inAsync && name === "await") {
              this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
            }
            this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
          }
        };
        pp$5.parseIdent = function (liberal) {
          var node = this.parseIdentNode();
          this.next(!!liberal);
          this.finishNode(node, "Identifier");
          if (!liberal) {
            this.checkUnreserved(node);
            if (node.name === "await" && !(this || _global$1).awaitIdentPos) {
              (this || _global$1).awaitIdentPos = node.start;
            }
          }
          return node;
        };
        pp$5.parseIdentNode = function () {
          var node = this.startNode();
          if ((this || _global$1).type === types$1.name) {
            node.name = (this || _global$1).value;
          } else if ((this || _global$1).type.keyword) {
            node.name = (this || _global$1).type.keyword;
            if ((node.name === "class" || node.name === "function") && ((this || _global$1).lastTokEnd !== (this || _global$1).lastTokStart + 1 || (this || _global$1).input.charCodeAt((this || _global$1).lastTokStart) !== 46)) {
              (this || _global$1).context.pop();
            }
            (this || _global$1).type = types$1.name;
          } else {
            this.unexpected();
          }
          return node;
        };
        pp$5.parsePrivateIdent = function () {
          var node = this.startNode();
          if ((this || _global$1).type === types$1.privateId) {
            node.name = (this || _global$1).value;
          } else {
            this.unexpected();
          }
          this.next();
          this.finishNode(node, "PrivateIdentifier");
          if ((this || _global$1).options.checkPrivateFields) {
            if ((this || _global$1).privateNameStack.length === 0) {
              this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
            } else {
              (this || _global$1).privateNameStack[(this || _global$1).privateNameStack.length - 1].used.push(node);
            }
          }
          return node;
        };
        pp$5.parseYield = function (forInit) {
          if (!(this || _global$1).yieldPos) {
            (this || _global$1).yieldPos = (this || _global$1).start;
          }
          var node = this.startNode();
          this.next();
          if ((this || _global$1).type === types$1.semi || this.canInsertSemicolon() || (this || _global$1).type !== types$1.star && !(this || _global$1).type.startsExpr) {
            node.delegate = false;
            node.argument = null;
          } else {
            node.delegate = this.eat(types$1.star);
            node.argument = this.parseMaybeAssign(forInit);
          }
          return this.finishNode(node, "YieldExpression");
        };
        pp$5.parseAwait = function (forInit) {
          if (!(this || _global$1).awaitPos) {
            (this || _global$1).awaitPos = (this || _global$1).start;
          }
          var node = this.startNode();
          this.next();
          node.argument = this.parseMaybeUnary(null, true, false, forInit);
          return this.finishNode(node, "AwaitExpression");
        };
        var pp$4 = Parser.prototype;
        pp$4.raise = function (pos, message) {
          var loc = getLineInfo((this || _global$1).input, pos);
          message += " (" + loc.line + ":" + loc.column + ")";
          var err = new SyntaxError(message);
          err.pos = pos;
          err.loc = loc;
          err.raisedAt = (this || _global$1).pos;
          throw err;
        };
        pp$4.raiseRecoverable = pp$4.raise;
        pp$4.curPosition = function () {
          if ((this || _global$1).options.locations) {
            return new Position((this || _global$1).curLine, (this || _global$1).pos - (this || _global$1).lineStart);
          }
        };
        var pp$3 = Parser.prototype;
        var Scope = function Scope(flags) {
          (this || _global$1).flags = flags;
          (this || _global$1).var = [];
          (this || _global$1).lexical = [];
          (this || _global$1).functions = [];
          (this || _global$1).inClassFieldInit = false;
        };
        pp$3.enterScope = function (flags) {
          (this || _global$1).scopeStack.push(new Scope(flags));
        };
        pp$3.exitScope = function () {
          (this || _global$1).scopeStack.pop();
        };
        pp$3.treatFunctionsAsVarInScope = function (scope) {
          return scope.flags & SCOPE_FUNCTION || !(this || _global$1).inModule && scope.flags & SCOPE_TOP;
        };
        pp$3.declareName = function (name, bindingType, pos) {
          var redeclared = false;
          if (bindingType === BIND_LEXICAL) {
            var scope = this.currentScope();
            redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
            scope.lexical.push(name);
            if ((this || _global$1).inModule && scope.flags & SCOPE_TOP) {
              delete (this || _global$1).undefinedExports[name];
            }
          } else if (bindingType === BIND_SIMPLE_CATCH) {
            var scope$1 = this.currentScope();
            scope$1.lexical.push(name);
          } else if (bindingType === BIND_FUNCTION) {
            var scope$2 = this.currentScope();
            if ((this || _global$1).treatFunctionsAsVar) {
              redeclared = scope$2.lexical.indexOf(name) > -1;
            } else {
              redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
            }
            scope$2.functions.push(name);
          } else {
            for (var i = (this || _global$1).scopeStack.length - 1; i >= 0; --i) {
              var scope$3 = (this || _global$1).scopeStack[i];
              if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
                redeclared = true;
                break;
              }
              scope$3.var.push(name);
              if ((this || _global$1).inModule && scope$3.flags & SCOPE_TOP) {
                delete (this || _global$1).undefinedExports[name];
              }
              if (scope$3.flags & SCOPE_VAR) {
                break;
              }
            }
          }
          if (redeclared) {
            this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
          }
        };
        pp$3.checkLocalExport = function (id) {
          if ((this || _global$1).scopeStack[0].lexical.indexOf(id.name) === -1 && (this || _global$1).scopeStack[0].var.indexOf(id.name) === -1) {
            (this || _global$1).undefinedExports[id.name] = id;
          }
        };
        pp$3.currentScope = function () {
          return (this || _global$1).scopeStack[(this || _global$1).scopeStack.length - 1];
        };
        pp$3.currentVarScope = function () {
          for (var i = (this || _global$1).scopeStack.length - 1;; i--) {
            var scope = (this || _global$1).scopeStack[i];
            if (scope.flags & SCOPE_VAR) {
              return scope;
            }
          }
        };
        pp$3.currentThisScope = function () {
          for (var i = (this || _global$1).scopeStack.length - 1;; i--) {
            var scope = (this || _global$1).scopeStack[i];
            if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
              return scope;
            }
          }
        };
        var Node = function Node(parser, pos, loc) {
          (this || _global$1).type = "";
          (this || _global$1).start = pos;
          (this || _global$1).end = 0;
          if (parser.options.locations) {
            (this || _global$1).loc = new SourceLocation(parser, loc);
          }
          if (parser.options.directSourceFile) {
            (this || _global$1).sourceFile = parser.options.directSourceFile;
          }
          if (parser.options.ranges) {
            (this || _global$1).range = [
              pos,
              0
            ];
          }
        };
        var pp$2 = Parser.prototype;
        pp$2.startNode = function () {
          return new Node(this || _global$1, (this || _global$1).start, (this || _global$1).startLoc);
        };
        pp$2.startNodeAt = function (pos, loc) {
          return new Node(this || _global$1, pos, loc);
        };
        function finishNodeAt(node, type, pos, loc) {
          node.type = type;
          node.end = pos;
          if ((this || _global$1).options.locations) {
            node.loc.end = loc;
          }
          if ((this || _global$1).options.ranges) {
            node.range[1] = pos;
          }
          return node;
        }
        pp$2.finishNode = function (node, type) {
          return finishNodeAt.call(this || _global$1, node, type, (this || _global$1).lastTokEnd, (this || _global$1).lastTokEndLoc);
        };
        pp$2.finishNodeAt = function (node, type, pos, loc) {
          return finishNodeAt.call(this || _global$1, node, type, pos, loc);
        };
        pp$2.copyNode = function (node) {
          var newNode = new Node(this || _global$1, node.start, (this || _global$1).startLoc);
          for (var prop in node) {
            newNode[prop] = node[prop];
          }
          return newNode;
        };
        var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
        var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
        var ecma11BinaryProperties = ecma10BinaryProperties;
        var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
        var ecma13BinaryProperties = ecma12BinaryProperties;
        var ecma14BinaryProperties = ecma13BinaryProperties;
        var unicodeBinaryProperties = {
          9: ecma9BinaryProperties,
          10: ecma10BinaryProperties,
          11: ecma11BinaryProperties,
          12: ecma12BinaryProperties,
          13: ecma13BinaryProperties,
          14: ecma14BinaryProperties
        };
        var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
        var unicodeBinaryPropertiesOfStrings = {
          9: "",
          10: "",
          11: "",
          12: "",
          13: "",
          14: ecma14BinaryPropertiesOfStrings
        };
        var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
        var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
        var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
        var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
        var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
        var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
        var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
        var unicodeScriptValues = {
          9: ecma9ScriptValues,
          10: ecma10ScriptValues,
          11: ecma11ScriptValues,
          12: ecma12ScriptValues,
          13: ecma13ScriptValues,
          14: ecma14ScriptValues
        };
        var data = {};
        function buildUnicodeData(ecmaVersion) {
          var d = data[ecmaVersion] = {
            binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
            binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
            nonBinary: {
              General_Category: wordsRegexp(unicodeGeneralCategoryValues),
              Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
            }
          };
          d.nonBinary.Script_Extensions = d.nonBinary.Script;
          d.nonBinary.gc = d.nonBinary.General_Category;
          d.nonBinary.sc = d.nonBinary.Script;
          d.nonBinary.scx = d.nonBinary.Script_Extensions;
        }
        for (var i = 0, list = [
              9,
              10,
              11,
              12,
              13,
              14
            ]; i < list.length; i += 1) {
          var ecmaVersion = list[i];
          buildUnicodeData(ecmaVersion);
        }
        var pp$1 = Parser.prototype;
        var RegExpValidationState = function RegExpValidationState(parser) {
          (this || _global$1).parser = parser;
          (this || _global$1).validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
          (this || _global$1).unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
          (this || _global$1).source = "";
          (this || _global$1).flags = "";
          (this || _global$1).start = 0;
          (this || _global$1).switchU = false;
          (this || _global$1).switchV = false;
          (this || _global$1).switchN = false;
          (this || _global$1).pos = 0;
          (this || _global$1).lastIntValue = 0;
          (this || _global$1).lastStringValue = "";
          (this || _global$1).lastAssertionIsQuantifiable = false;
          (this || _global$1).numCapturingParens = 0;
          (this || _global$1).maxBackReference = 0;
          (this || _global$1).groupNames = [];
          (this || _global$1).backReferenceNames = [];
        };
        RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
          var unicodeSets = flags.indexOf("v") !== -1;
          var unicode = flags.indexOf("u") !== -1;
          (this || _global$1).start = start | 0;
          (this || _global$1).source = pattern + "";
          (this || _global$1).flags = flags;
          if (unicodeSets && (this || _global$1).parser.options.ecmaVersion >= 15) {
            (this || _global$1).switchU = true;
            (this || _global$1).switchV = true;
            (this || _global$1).switchN = true;
          } else {
            (this || _global$1).switchU = unicode && (this || _global$1).parser.options.ecmaVersion >= 6;
            (this || _global$1).switchV = false;
            (this || _global$1).switchN = unicode && (this || _global$1).parser.options.ecmaVersion >= 9;
          }
        };
        RegExpValidationState.prototype.raise = function raise(message) {
          (this || _global$1).parser.raiseRecoverable((this || _global$1).start, "Invalid regular expression: /" + (this || _global$1).source + "/: " + message);
        };
        RegExpValidationState.prototype.at = function at(i, forceU) {
          if (forceU === void 0)
            forceU = false;
          var s = (this || _global$1).source;
          var l = s.length;
          if (i >= l) {
            return -1;
          }
          var c = s.charCodeAt(i);
          if (!(forceU || (this || _global$1).switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
            return c;
          }
          var next = s.charCodeAt(i + 1);
          return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
        };
        RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
          if (forceU === void 0)
            forceU = false;
          var s = (this || _global$1).source;
          var l = s.length;
          if (i >= l) {
            return l;
          }
          var c = s.charCodeAt(i), next;
          if (!(forceU || (this || _global$1).switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
            return i + 1;
          }
          return i + 2;
        };
        RegExpValidationState.prototype.current = function current(forceU) {
          if (forceU === void 0)
            forceU = false;
          return this.at((this || _global$1).pos, forceU);
        };
        RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
          if (forceU === void 0)
            forceU = false;
          return this.at(this.nextIndex((this || _global$1).pos, forceU), forceU);
        };
        RegExpValidationState.prototype.advance = function advance(forceU) {
          if (forceU === void 0)
            forceU = false;
          (this || _global$1).pos = this.nextIndex((this || _global$1).pos, forceU);
        };
        RegExpValidationState.prototype.eat = function eat(ch, forceU) {
          if (forceU === void 0)
            forceU = false;
          if (this.current(forceU) === ch) {
            this.advance(forceU);
            return true;
          }
          return false;
        };
        RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
          if (forceU === void 0)
            forceU = false;
          var pos = (this || _global$1).pos;
          for (var i = 0, list = chs; i < list.length; i += 1) {
            var ch = list[i];
            var current = this.at(pos, forceU);
            if (current === -1 || current !== ch) {
              return false;
            }
            pos = this.nextIndex(pos, forceU);
          }
          (this || _global$1).pos = pos;
          return true;
        };
        pp$1.validateRegExpFlags = function (state) {
          var validFlags = state.validFlags;
          var flags = state.flags;
          var u = false;
          var v = false;
          for (var i = 0; i < flags.length; i++) {
            var flag = flags.charAt(i);
            if (validFlags.indexOf(flag) === -1) {
              this.raise(state.start, "Invalid regular expression flag");
            }
            if (flags.indexOf(flag, i + 1) > -1) {
              this.raise(state.start, "Duplicate regular expression flag");
            }
            if (flag === "u") {
              u = true;
            }
            if (flag === "v") {
              v = true;
            }
          }
          if ((this || _global$1).options.ecmaVersion >= 15 && u && v) {
            this.raise(state.start, "Invalid regular expression flag");
          }
        };
        pp$1.validateRegExpPattern = function (state) {
          this.regexp_pattern(state);
          if (!state.switchN && (this || _global$1).options.ecmaVersion >= 9 && state.groupNames.length > 0) {
            state.switchN = true;
            this.regexp_pattern(state);
          }
        };
        pp$1.regexp_pattern = function (state) {
          state.pos = 0;
          state.lastIntValue = 0;
          state.lastStringValue = "";
          state.lastAssertionIsQuantifiable = false;
          state.numCapturingParens = 0;
          state.maxBackReference = 0;
          state.groupNames.length = 0;
          state.backReferenceNames.length = 0;
          this.regexp_disjunction(state);
          if (state.pos !== state.source.length) {
            if (state.eat(41)) {
              state.raise("Unmatched ')'");
            }
            if (state.eat(93) || state.eat(125)) {
              state.raise("Lone quantifier brackets");
            }
          }
          if (state.maxBackReference > state.numCapturingParens) {
            state.raise("Invalid escape");
          }
          for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
            var name = list[i];
            if (state.groupNames.indexOf(name) === -1) {
              state.raise("Invalid named capture referenced");
            }
          }
        };
        pp$1.regexp_disjunction = function (state) {
          this.regexp_alternative(state);
          while (state.eat(124)) {
            this.regexp_alternative(state);
          }
          if (this.regexp_eatQuantifier(state, true)) {
            state.raise("Nothing to repeat");
          }
          if (state.eat(123)) {
            state.raise("Lone quantifier brackets");
          }
        };
        pp$1.regexp_alternative = function (state) {
          while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
          }
        };
        pp$1.regexp_eatTerm = function (state) {
          if (this.regexp_eatAssertion(state)) {
            if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
              if (state.switchU) {
                state.raise("Invalid quantifier");
              }
            }
            return true;
          }
          if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
            this.regexp_eatQuantifier(state);
            return true;
          }
          return false;
        };
        pp$1.regexp_eatAssertion = function (state) {
          var start = state.pos;
          state.lastAssertionIsQuantifiable = false;
          if (state.eat(94) || state.eat(36)) {
            return true;
          }
          if (state.eat(92)) {
            if (state.eat(66) || state.eat(98)) {
              return true;
            }
            state.pos = start;
          }
          if (state.eat(40) && state.eat(63)) {
            var lookbehind = false;
            if ((this || _global$1).options.ecmaVersion >= 9) {
              lookbehind = state.eat(60);
            }
            if (state.eat(61) || state.eat(33)) {
              this.regexp_disjunction(state);
              if (!state.eat(41)) {
                state.raise("Unterminated group");
              }
              state.lastAssertionIsQuantifiable = !lookbehind;
              return true;
            }
          }
          state.pos = start;
          return false;
        };
        pp$1.regexp_eatQuantifier = function (state, noError) {
          if (noError === void 0)
            noError = false;
          if (this.regexp_eatQuantifierPrefix(state, noError)) {
            state.eat(63);
            return true;
          }
          return false;
        };
        pp$1.regexp_eatQuantifierPrefix = function (state, noError) {
          return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
        };
        pp$1.regexp_eatBracedQuantifier = function (state, noError) {
          var start = state.pos;
          if (state.eat(123)) {
            var min = 0, max = -1;
            if (this.regexp_eatDecimalDigits(state)) {
              min = state.lastIntValue;
              if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
                max = state.lastIntValue;
              }
              if (state.eat(125)) {
                if (max !== -1 && max < min && !noError) {
                  state.raise("numbers out of order in {} quantifier");
                }
                return true;
              }
            }
            if (state.switchU && !noError) {
              state.raise("Incomplete quantifier");
            }
            state.pos = start;
          }
          return false;
        };
        pp$1.regexp_eatAtom = function (state) {
          return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
        };
        pp$1.regexp_eatReverseSolidusAtomEscape = function (state) {
          var start = state.pos;
          if (state.eat(92)) {
            if (this.regexp_eatAtomEscape(state)) {
              return true;
            }
            state.pos = start;
          }
          return false;
        };
        pp$1.regexp_eatUncapturingGroup = function (state) {
          var start = state.pos;
          if (state.eat(40)) {
            if (state.eat(63) && state.eat(58)) {
              this.regexp_disjunction(state);
              if (state.eat(41)) {
                return true;
              }
              state.raise("Unterminated group");
            }
            state.pos = start;
          }
          return false;
        };
        pp$1.regexp_eatCapturingGroup = function (state) {
          if (state.eat(40)) {
            if ((this || _global$1).options.ecmaVersion >= 9) {
              this.regexp_groupSpecifier(state);
            } else if (state.current() === 63) {
              state.raise("Invalid group");
            }
            this.regexp_disjunction(state);
            if (state.eat(41)) {
              state.numCapturingParens += 1;
              return true;
            }
            state.raise("Unterminated group");
          }
          return false;
        };
        pp$1.regexp_eatExtendedAtom = function (state) {
          return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
        };
        pp$1.regexp_eatInvalidBracedQuantifier = function (state) {
          if (this.regexp_eatBracedQuantifier(state, true)) {
            state.raise("Nothing to repeat");
          }
          return false;
        };
        pp$1.regexp_eatSyntaxCharacter = function (state) {
          var ch = state.current();
          if (isSyntaxCharacter(ch)) {
            state.lastIntValue = ch;
            state.advance();
            return true;
          }
          return false;
        };
        function isSyntaxCharacter(ch) {
          return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
        }
        pp$1.regexp_eatPatternCharacters = function (state) {
          var start = state.pos;
          var ch = 0;
          while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
            state.advance();
          }
          return state.pos !== start;
        };
        pp$1.regexp_eatExtendedPatternCharacter = function (state) {
          var ch = state.current();
          if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
            state.advance();
            return true;
          }
          return false;
        };
        pp$1.regexp_groupSpecifier = function (state) {
          if (state.eat(63)) {
            if (this.regexp_eatGroupName(state)) {
              if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
                state.raise("Duplicate capture group name");
              }
              state.groupNames.push(state.lastStringValue);
              return;
            }
            state.raise("Invalid group");
          }
        };
        pp$1.regexp_eatGroupName = function (state) {
          state.lastStringValue = "";
          if (state.eat(60)) {
            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
              return true;
            }
            state.raise("Invalid capture group name");
          }
          return false;
        };
        pp$1.regexp_eatRegExpIdentifierName = function (state) {
          state.lastStringValue = "";
          if (this.regexp_eatRegExpIdentifierStart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
            while (this.regexp_eatRegExpIdentifierPart(state)) {
              state.lastStringValue += codePointToString(state.lastIntValue);
            }
            return true;
          }
          return false;
        };
        pp$1.regexp_eatRegExpIdentifierStart = function (state) {
          var start = state.pos;
          var forceU = (this || _global$1).options.ecmaVersion >= 11;
          var ch = state.current(forceU);
          state.advance(forceU);
          if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
            ch = state.lastIntValue;
          }
          if (isRegExpIdentifierStart(ch)) {
            state.lastIntValue = ch;
            return true;
          }
          state.pos = start;
          return false;
        };
        function isRegExpIdentifierStart(ch) {
          return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
        }
        pp$1.regexp_eatRegExpIdentifierPart = function (state) {
          var start = state.pos;
          var forceU = (this || _global$1).options.ecmaVersion >= 11;
          var ch = state.current(forceU);
          state.advance(forceU);
          if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
            ch = state.lastIntValue;
          }
          if (isRegExpIdentifierPart(ch)) {
            state.lastIntValue = ch;
            return true;
          }
          state.pos = start;
          return false;
        };
        function isRegExpIdentifierPart(ch) {
          return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
        }
        pp$1.regexp_eatAtomEscape = function (state) {
          if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
            return true;
          }
          if (state.switchU) {
            if (state.current() === 99) {
              state.raise("Invalid unicode escape");
            }
            state.raise("Invalid escape");
          }
          return false;
        };
        pp$1.regexp_eatBackReference = function (state) {
          var start = state.pos;
          if (this.regexp_eatDecimalEscape(state)) {
            var n = state.lastIntValue;
            if (state.switchU) {
              if (n > state.maxBackReference) {
                state.maxBackReference = n;
              }
              return true;
            }
            if (n <= state.numCapturingParens) {
              return true;
            }
            state.pos = start;
          }
          return false;
        };
        pp$1.regexp_eatKGroupName = function (state) {
          if (state.eat(107)) {
            if (this.regexp_eatGroupName(state)) {
              state.backReferenceNames.push(state.lastStringValue);
              return true;
            }
            state.raise("Invalid named reference");
          }
          return false;
        };
        pp$1.regexp_eatCharacterEscape = function (state) {
          return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
        };
        pp$1.regexp_eatCControlLetter = function (state) {
          var start = state.pos;
          if (state.eat(99)) {
            if (this.regexp_eatControlLetter(state)) {
              return true;
            }
            state.pos = start;
          }
          return false;
        };
        pp$1.regexp_eatZero = function (state) {
          if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
            state.lastIntValue = 0;
            state.advance();
            return true;
          }
          return false;
        };
        pp$1.regexp_eatControlEscape = function (state) {
          var ch = state.current();
          if (ch === 116) {
            state.lastIntValue = 9;
            state.advance();
            return true;
          }
          if (ch === 110) {
            state.lastIntValue = 10;
            state.advance();
            return true;
          }
          if (ch === 118) {
            state.lastIntValue = 11;
            state.advance();
            return true;
          }
          if (ch === 102) {
            state.lastIntValue = 12;
            state.advance();
            return true;
          }
          if (ch === 114) {
            state.lastIntValue = 13;
            state.advance();
            return true;
          }
          return false;
        };
        pp$1.regexp_eatControlLetter = function (state) {
          var ch = state.current();
          if (isControlLetter(ch)) {
            state.lastIntValue = ch % 32;
            state.advance();
            return true;
          }
          return false;
        };
        function isControlLetter(ch) {
          return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
        }
        pp$1.regexp_eatRegExpUnicodeEscapeSequence = function (state, forceU) {
          if (forceU === void 0)
            forceU = false;
          var start = state.pos;
          var switchU = forceU || state.switchU;
          if (state.eat(117)) {
            if (this.regexp_eatFixedHexDigits(state, 4)) {
              var lead = state.lastIntValue;
              if (switchU && lead >= 55296 && lead <= 56319) {
                var leadSurrogateEnd = state.pos;
                if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
                  var trail = state.lastIntValue;
                  if (trail >= 56320 && trail <= 57343) {
                    state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                    return true;
                  }
                }
                state.pos = leadSurrogateEnd;
                state.lastIntValue = lead;
              }
              return true;
            }
            if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
              return true;
            }
            if (switchU) {
              state.raise("Invalid unicode escape");
            }
            state.pos = start;
          }
          return false;
        };
        function isValidUnicode(ch) {
          return ch >= 0 && ch <= 1114111;
        }
        pp$1.regexp_eatIdentityEscape = function (state) {
          if (state.switchU) {
            if (this.regexp_eatSyntaxCharacter(state)) {
              return true;
            }
            if (state.eat(47)) {
              state.lastIntValue = 47;
              return true;
            }
            return false;
          }
          var ch = state.current();
          if (ch !== 99 && (!state.switchN || ch !== 107)) {
            state.lastIntValue = ch;
            state.advance();
            return true;
          }
          return false;
        };
        pp$1.regexp_eatDecimalEscape = function (state) {
          state.lastIntValue = 0;
          var ch = state.current();
          if (ch >= 49 && ch <= 57) {
            do {
              state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
              state.advance();
            } while ((ch = state.current()) >= 48 && ch <= 57);
            return true;
          }
          return false;
        };
        var CharSetNone = 0;
        var CharSetOk = 1;
        var CharSetString = 2;
        pp$1.regexp_eatCharacterClassEscape = function (state) {
          var ch = state.current();
          if (isCharacterClassEscape(ch)) {
            state.lastIntValue = -1;
            state.advance();
            return CharSetOk;
          }
          var negate = false;
          if (state.switchU && (this || _global$1).options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
            state.lastIntValue = -1;
            state.advance();
            var result;
            if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
              if (negate && result === CharSetString) {
                state.raise("Invalid property name");
              }
              return result;
            }
            state.raise("Invalid property name");
          }
          return CharSetNone;
        };
        function isCharacterClassEscape(ch) {
          return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
        }
        pp$1.regexp_eatUnicodePropertyValueExpression = function (state) {
          var start = state.pos;
          if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
            var name = state.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(state)) {
              var value = state.lastStringValue;
              this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
              return CharSetOk;
            }
          }
          state.pos = start;
          if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
            var nameOrValue = state.lastStringValue;
            return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
          }
          return CharSetNone;
        };
        pp$1.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {
          if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
            state.raise("Invalid property name");
          }
          if (!state.unicodeProperties.nonBinary[name].test(value)) {
            state.raise("Invalid property value");
          }
        };
        pp$1.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {
          if (state.unicodeProperties.binary.test(nameOrValue)) {
            return CharSetOk;
          }
          if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
            return CharSetString;
          }
          state.raise("Invalid property name");
        };
        pp$1.regexp_eatUnicodePropertyName = function (state) {
          var ch = 0;
          state.lastStringValue = "";
          while (isUnicodePropertyNameCharacter(ch = state.current())) {
            state.lastStringValue += codePointToString(ch);
            state.advance();
          }
          return state.lastStringValue !== "";
        };
        function isUnicodePropertyNameCharacter(ch) {
          return isControlLetter(ch) || ch === 95;
        }
        pp$1.regexp_eatUnicodePropertyValue = function (state) {
          var ch = 0;
          state.lastStringValue = "";
          while (isUnicodePropertyValueCharacter(ch = state.current())) {
            state.lastStringValue += codePointToString(ch);
            state.advance();
          }
          return state.lastStringValue !== "";
        };
        function isUnicodePropertyValueCharacter(ch) {
          return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
        }
        pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {
          return this.regexp_eatUnicodePropertyValue(state);
        };
        pp$1.regexp_eatCharacterClass = function (state) {
          if (state.eat(91)) {
            var negate = state.eat(94);
            var result = this.regexp_classContents(state);
            if (!state.eat(93)) {
              state.raise("Unterminated character class");
            }
            if (negate && result === CharSetString) {
              state.raise("Negated character class may contain strings");
            }
            return true;
          }
          return false;
        };
        pp$1.regexp_classContents = function (state) {
          if (state.current() === 93) {
            return CharSetOk;
          }
          if (state.switchV) {
            return this.regexp_classSetExpression(state);
          }
          this.regexp_nonEmptyClassRanges(state);
          return CharSetOk;
        };
        pp$1.regexp_nonEmptyClassRanges = function (state) {
          while (this.regexp_eatClassAtom(state)) {
            var left = state.lastIntValue;
            if (state.eat(45) && this.regexp_eatClassAtom(state)) {
              var right = state.lastIntValue;
              if (state.switchU && (left === -1 || right === -1)) {
                state.raise("Invalid character class");
              }
              if (left !== -1 && right !== -1 && left > right) {
                state.raise("Range out of order in character class");
              }
            }
          }
        };
        pp$1.regexp_eatClassAtom = function (state) {
          var start = state.pos;
          if (state.eat(92)) {
            if (this.regexp_eatClassEscape(state)) {
              return true;
            }
            if (state.switchU) {
              var ch$1 = state.current();
              if (ch$1 === 99 || isOctalDigit(ch$1)) {
                state.raise("Invalid class escape");
              }
              state.raise("Invalid escape");
            }
            state.pos = start;
          }
          var ch = state.current();
          if (ch !== 93) {
            state.lastIntValue = ch;
            state.advance();
            return true;
          }
          return false;
        };
        pp$1.regexp_eatClassEscape = function (state) {
          var start = state.pos;
          if (state.eat(98)) {
            state.lastIntValue = 8;
            return true;
          }
          if (state.switchU && state.eat(45)) {
            state.lastIntValue = 45;
            return true;
          }
          if (!state.switchU && state.eat(99)) {
            if (this.regexp_eatClassControlLetter(state)) {
              return true;
            }
            state.pos = start;
          }
          return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
        };
        pp$1.regexp_classSetExpression = function (state) {
          var result = CharSetOk, subResult;
          if (this.regexp_eatClassSetRange(state));
          else if (subResult = this.regexp_eatClassSetOperand(state)) {
            if (subResult === CharSetString) {
              result = CharSetString;
            }
            var start = state.pos;
            while (state.eatChars([
                38,
                38
              ])) {
              if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
                if (subResult !== CharSetString) {
                  result = CharSetOk;
                }
                continue;
              }
              state.raise("Invalid character in character class");
            }
            if (start !== state.pos) {
              return result;
            }
            while (state.eatChars([
                45,
                45
              ])) {
              if (this.regexp_eatClassSetOperand(state)) {
                continue;
              }
              state.raise("Invalid character in character class");
            }
            if (start !== state.pos) {
              return result;
            }
          } else {
            state.raise("Invalid character in character class");
          }
          for (;;) {
            if (this.regexp_eatClassSetRange(state)) {
              continue;
            }
            subResult = this.regexp_eatClassSetOperand(state);
            if (!subResult) {
              return result;
            }
            if (subResult === CharSetString) {
              result = CharSetString;
            }
          }
        };
        pp$1.regexp_eatClassSetRange = function (state) {
          var start = state.pos;
          if (this.regexp_eatClassSetCharacter(state)) {
            var left = state.lastIntValue;
            if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
              var right = state.lastIntValue;
              if (left !== -1 && right !== -1 && left > right) {
                state.raise("Range out of order in character class");
              }
              return true;
            }
            state.pos = start;
          }
          return false;
        };
        pp$1.regexp_eatClassSetOperand = function (state) {
          if (this.regexp_eatClassSetCharacter(state)) {
            return CharSetOk;
          }
          return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
        };
        pp$1.regexp_eatNestedClass = function (state) {
          var start = state.pos;
          if (state.eat(91)) {
            var negate = state.eat(94);
            var result = this.regexp_classContents(state);
            if (state.eat(93)) {
              if (negate && result === CharSetString) {
                state.raise("Negated character class may contain strings");
              }
              return result;
            }
            state.pos = start;
          }
          if (state.eat(92)) {
            var result$1 = this.regexp_eatCharacterClassEscape(state);
            if (result$1) {
              return result$1;
            }
            state.pos = start;
          }
          return null;
        };
        pp$1.regexp_eatClassStringDisjunction = function (state) {
          var start = state.pos;
          if (state.eatChars([
              92,
              113
            ])) {
            if (state.eat(123)) {
              var result = this.regexp_classStringDisjunctionContents(state);
              if (state.eat(125)) {
                return result;
              }
            } else {
              state.raise("Invalid escape");
            }
            state.pos = start;
          }
          return null;
        };
        pp$1.regexp_classStringDisjunctionContents = function (state) {
          var result = this.regexp_classString(state);
          while (state.eat(124)) {
            if (this.regexp_classString(state) === CharSetString) {
              result = CharSetString;
            }
          }
          return result;
        };
        pp$1.regexp_classString = function (state) {
          var count = 0;
          while (this.regexp_eatClassSetCharacter(state)) {
            count++;
          }
          return count === 1 ? CharSetOk : CharSetString;
        };
        pp$1.regexp_eatClassSetCharacter = function (state) {
          var start = state.pos;
          if (state.eat(92)) {
            if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
              return true;
            }
            if (state.eat(98)) {
              state.lastIntValue = 8;
              return true;
            }
            state.pos = start;
            return false;
          }
          var ch = state.current();
          if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
            return false;
          }
          if (isClassSetSyntaxCharacter(ch)) {
            return false;
          }
          state.advance();
          state.lastIntValue = ch;
          return true;
        };
        function isClassSetReservedDoublePunctuatorCharacter(ch) {
          return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
        }
        function isClassSetSyntaxCharacter(ch) {
          return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
        }
        pp$1.regexp_eatClassSetReservedPunctuator = function (state) {
          var ch = state.current();
          if (isClassSetReservedPunctuator(ch)) {
            state.lastIntValue = ch;
            state.advance();
            return true;
          }
          return false;
        };
        function isClassSetReservedPunctuator(ch) {
          return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
        }
        pp$1.regexp_eatClassControlLetter = function (state) {
          var ch = state.current();
          if (isDecimalDigit(ch) || ch === 95) {
            state.lastIntValue = ch % 32;
            state.advance();
            return true;
          }
          return false;
        };
        pp$1.regexp_eatHexEscapeSequence = function (state) {
          var start = state.pos;
          if (state.eat(120)) {
            if (this.regexp_eatFixedHexDigits(state, 2)) {
              return true;
            }
            if (state.switchU) {
              state.raise("Invalid escape");
            }
            state.pos = start;
          }
          return false;
        };
        pp$1.regexp_eatDecimalDigits = function (state) {
          var start = state.pos;
          var ch = 0;
          state.lastIntValue = 0;
          while (isDecimalDigit(ch = state.current())) {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          }
          return state.pos !== start;
        };
        function isDecimalDigit(ch) {
          return ch >= 48 && ch <= 57;
        }
        pp$1.regexp_eatHexDigits = function (state) {
          var start = state.pos;
          var ch = 0;
          state.lastIntValue = 0;
          while (isHexDigit(ch = state.current())) {
            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
            state.advance();
          }
          return state.pos !== start;
        };
        function isHexDigit(ch) {
          return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
        }
        function hexToInt(ch) {
          if (ch >= 65 && ch <= 70) {
            return 10 + (ch - 65);
          }
          if (ch >= 97 && ch <= 102) {
            return 10 + (ch - 97);
          }
          return ch - 48;
        }
        pp$1.regexp_eatLegacyOctalEscapeSequence = function (state) {
          if (this.regexp_eatOctalDigit(state)) {
            var n1 = state.lastIntValue;
            if (this.regexp_eatOctalDigit(state)) {
              var n2 = state.lastIntValue;
              if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
                state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
              } else {
                state.lastIntValue = n1 * 8 + n2;
              }
            } else {
              state.lastIntValue = n1;
            }
            return true;
          }
          return false;
        };
        pp$1.regexp_eatOctalDigit = function (state) {
          var ch = state.current();
          if (isOctalDigit(ch)) {
            state.lastIntValue = ch - 48;
            state.advance();
            return true;
          }
          state.lastIntValue = 0;
          return false;
        };
        function isOctalDigit(ch) {
          return ch >= 48 && ch <= 55;
        }
        pp$1.regexp_eatFixedHexDigits = function (state, length) {
          var start = state.pos;
          state.lastIntValue = 0;
          for (var i = 0; i < length; ++i) {
            var ch = state.current();
            if (!isHexDigit(ch)) {
              state.pos = start;
              return false;
            }
            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
            state.advance();
          }
          return true;
        };
        var Token = function Token(p) {
          (this || _global$1).type = p.type;
          (this || _global$1).value = p.value;
          (this || _global$1).start = p.start;
          (this || _global$1).end = p.end;
          if (p.options.locations) {
            (this || _global$1).loc = new SourceLocation(p, p.startLoc, p.endLoc);
          }
          if (p.options.ranges) {
            (this || _global$1).range = [
              p.start,
              p.end
            ];
          }
        };
        var pp = Parser.prototype;
        pp.next = function (ignoreEscapeSequenceInKeyword) {
          if (!ignoreEscapeSequenceInKeyword && (this || _global$1).type.keyword && (this || _global$1).containsEsc) {
            this.raiseRecoverable((this || _global$1).start, "Escape sequence in keyword " + (this || _global$1).type.keyword);
          }
          if ((this || _global$1).options.onToken) {
            (this || _global$1).options.onToken(new Token(this || _global$1));
          }
          (this || _global$1).lastTokEnd = (this || _global$1).end;
          (this || _global$1).lastTokStart = (this || _global$1).start;
          (this || _global$1).lastTokEndLoc = (this || _global$1).endLoc;
          (this || _global$1).lastTokStartLoc = (this || _global$1).startLoc;
          this.nextToken();
        };
        pp.getToken = function () {
          this.next();
          return new Token(this || _global$1);
        };
        if (typeof Symbol !== "undefined") {
          pp[Symbol.iterator] = function () {
            var this$1$1 = this || _global$1;
            return {
              next: function () {
                var token = this$1$1.getToken();
                return {
                  done: token.type === types$1.eof,
                  value: token
                };
              }
            };
          };
        }
        pp.nextToken = function () {
          var curContext = this.curContext();
          if (!curContext || !curContext.preserveSpace) {
            this.skipSpace();
          }
          (this || _global$1).start = (this || _global$1).pos;
          if ((this || _global$1).options.locations) {
            (this || _global$1).startLoc = this.curPosition();
          }
          if ((this || _global$1).pos >= (this || _global$1).input.length) {
            return this.finishToken(types$1.eof);
          }
          if (curContext.override) {
            return curContext.override(this || _global$1);
          } else {
            this.readToken(this.fullCharCodeAtPos());
          }
        };
        pp.readToken = function (code) {
          if (isIdentifierStart(code, (this || _global$1).options.ecmaVersion >= 6) || code === 92) {
            return this.readWord();
          }
          return this.getTokenFromCode(code);
        };
        pp.fullCharCodeAtPos = function () {
          var code = (this || _global$1).input.charCodeAt((this || _global$1).pos);
          if (code <= 55295 || code >= 56320) {
            return code;
          }
          var next = (this || _global$1).input.charCodeAt((this || _global$1).pos + 1);
          return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
        };
        pp.skipBlockComment = function () {
          var startLoc = (this || _global$1).options.onComment && this.curPosition();
          var start = (this || _global$1).pos, end = (this || _global$1).input.indexOf("*/", (this || _global$1).pos += 2);
          if (end === -1) {
            this.raise((this || _global$1).pos - 2, "Unterminated comment");
          }
          (this || _global$1).pos = end + 2;
          if ((this || _global$1).options.locations) {
            for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak((this || _global$1).input, pos, (this || _global$1).pos)) > -1;) {
              ++(this || _global$1).curLine;
              pos = (this || _global$1).lineStart = nextBreak;
            }
          }
          if ((this || _global$1).options.onComment) {
            (this || _global$1).options.onComment(true, (this || _global$1).input.slice(start + 2, end), start, (this || _global$1).pos, startLoc, this.curPosition());
          }
        };
        pp.skipLineComment = function (startSkip) {
          var start = (this || _global$1).pos;
          var startLoc = (this || _global$1).options.onComment && this.curPosition();
          var ch = (this || _global$1).input.charCodeAt((this || _global$1).pos += startSkip);
          while ((this || _global$1).pos < (this || _global$1).input.length && !isNewLine(ch)) {
            ch = (this || _global$1).input.charCodeAt(++(this || _global$1).pos);
          }
          if ((this || _global$1).options.onComment) {
            (this || _global$1).options.onComment(false, (this || _global$1).input.slice(start + startSkip, (this || _global$1).pos), start, (this || _global$1).pos, startLoc, this.curPosition());
          }
        };
        pp.skipSpace = function () {
          loop:
            while ((this || _global$1).pos < (this || _global$1).input.length) {
              var ch = (this || _global$1).input.charCodeAt((this || _global$1).pos);
              switch (ch) {
              case 32:
              case 160:
                ++(this || _global$1).pos;
                break;
              case 13:
                if ((this || _global$1).input.charCodeAt((this || _global$1).pos + 1) === 10) {
                  ++(this || _global$1).pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++(this || _global$1).pos;
                if ((this || _global$1).options.locations) {
                  ++(this || _global$1).curLine;
                  (this || _global$1).lineStart = (this || _global$1).pos;
                }
                break;
              case 47:
                switch ((this || _global$1).input.charCodeAt((this || _global$1).pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
                }
                break;
              default:
                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                  ++(this || _global$1).pos;
                } else {
                  break loop;
                }
              }
            }
        };
        pp.finishToken = function (type, val) {
          (this || _global$1).end = (this || _global$1).pos;
          if ((this || _global$1).options.locations) {
            (this || _global$1).endLoc = this.curPosition();
          }
          var prevType = (this || _global$1).type;
          (this || _global$1).type = type;
          (this || _global$1).value = val;
          this.updateContext(prevType);
        };
        pp.readToken_dot = function () {
          var next = (this || _global$1).input.charCodeAt((this || _global$1).pos + 1);
          if (next >= 48 && next <= 57) {
            return this.readNumber(true);
          }
          var next2 = (this || _global$1).input.charCodeAt((this || _global$1).pos + 2);
          if ((this || _global$1).options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
            (this || _global$1).pos += 3;
            return this.finishToken(types$1.ellipsis);
          } else {
            ++(this || _global$1).pos;
            return this.finishToken(types$1.dot);
          }
        };
        pp.readToken_slash = function () {
          var next = (this || _global$1).input.charCodeAt((this || _global$1).pos + 1);
          if ((this || _global$1).exprAllowed) {
            ++(this || _global$1).pos;
            return this.readRegexp();
          }
          if (next === 61) {
            return this.finishOp(types$1.assign, 2);
          }
          return this.finishOp(types$1.slash, 1);
        };
        pp.readToken_mult_modulo_exp = function (code) {
          var next = (this || _global$1).input.charCodeAt((this || _global$1).pos + 1);
          var size = 1;
          var tokentype = code === 42 ? types$1.star : types$1.modulo;
          if ((this || _global$1).options.ecmaVersion >= 7 && code === 42 && next === 42) {
            ++size;
            tokentype = types$1.starstar;
            next = (this || _global$1).input.charCodeAt((this || _global$1).pos + 2);
          }
          if (next === 61) {
            return this.finishOp(types$1.assign, size + 1);
          }
          return this.finishOp(tokentype, size);
        };
        pp.readToken_pipe_amp = function (code) {
          var next = (this || _global$1).input.charCodeAt((this || _global$1).pos + 1);
          if (next === code) {
            if ((this || _global$1).options.ecmaVersion >= 12) {
              var next2 = (this || _global$1).input.charCodeAt((this || _global$1).pos + 2);
              if (next2 === 61) {
                return this.finishOp(types$1.assign, 3);
              }
            }
            return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
          }
          if (next === 61) {
            return this.finishOp(types$1.assign, 2);
          }
          return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
        };
        pp.readToken_caret = function () {
          var next = (this || _global$1).input.charCodeAt((this || _global$1).pos + 1);
          if (next === 61) {
            return this.finishOp(types$1.assign, 2);
          }
          return this.finishOp(types$1.bitwiseXOR, 1);
        };
        pp.readToken_plus_min = function (code) {
          var next = (this || _global$1).input.charCodeAt((this || _global$1).pos + 1);
          if (next === code) {
            if (next === 45 && !(this || _global$1).inModule && (this || _global$1).input.charCodeAt((this || _global$1).pos + 2) === 62 && ((this || _global$1).lastTokEnd === 0 || lineBreak.test((this || _global$1).input.slice((this || _global$1).lastTokEnd, (this || _global$1).pos)))) {
              this.skipLineComment(3);
              this.skipSpace();
              return this.nextToken();
            }
            return this.finishOp(types$1.incDec, 2);
          }
          if (next === 61) {
            return this.finishOp(types$1.assign, 2);
          }
          return this.finishOp(types$1.plusMin, 1);
        };
        pp.readToken_lt_gt = function (code) {
          var next = (this || _global$1).input.charCodeAt((this || _global$1).pos + 1);
          var size = 1;
          if (next === code) {
            size = code === 62 && (this || _global$1).input.charCodeAt((this || _global$1).pos + 2) === 62 ? 3 : 2;
            if ((this || _global$1).input.charCodeAt((this || _global$1).pos + size) === 61) {
              return this.finishOp(types$1.assign, size + 1);
            }
            return this.finishOp(types$1.bitShift, size);
          }
          if (next === 33 && code === 60 && !(this || _global$1).inModule && (this || _global$1).input.charCodeAt((this || _global$1).pos + 2) === 45 && (this || _global$1).input.charCodeAt((this || _global$1).pos + 3) === 45) {
            this.skipLineComment(4);
            this.skipSpace();
            return this.nextToken();
          }
          if (next === 61) {
            size = 2;
          }
          return this.finishOp(types$1.relational, size);
        };
        pp.readToken_eq_excl = function (code) {
          var next = (this || _global$1).input.charCodeAt((this || _global$1).pos + 1);
          if (next === 61) {
            return this.finishOp(types$1.equality, (this || _global$1).input.charCodeAt((this || _global$1).pos + 2) === 61 ? 3 : 2);
          }
          if (code === 61 && next === 62 && (this || _global$1).options.ecmaVersion >= 6) {
            (this || _global$1).pos += 2;
            return this.finishToken(types$1.arrow);
          }
          return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
        };
        pp.readToken_question = function () {
          var ecmaVersion = (this || _global$1).options.ecmaVersion;
          if (ecmaVersion >= 11) {
            var next = (this || _global$1).input.charCodeAt((this || _global$1).pos + 1);
            if (next === 46) {
              var next2 = (this || _global$1).input.charCodeAt((this || _global$1).pos + 2);
              if (next2 < 48 || next2 > 57) {
                return this.finishOp(types$1.questionDot, 2);
              }
            }
            if (next === 63) {
              if (ecmaVersion >= 12) {
                var next2$1 = (this || _global$1).input.charCodeAt((this || _global$1).pos + 2);
                if (next2$1 === 61) {
                  return this.finishOp(types$1.assign, 3);
                }
              }
              return this.finishOp(types$1.coalesce, 2);
            }
          }
          return this.finishOp(types$1.question, 1);
        };
        pp.readToken_numberSign = function () {
          var ecmaVersion = (this || _global$1).options.ecmaVersion;
          var code = 35;
          if (ecmaVersion >= 13) {
            ++(this || _global$1).pos;
            code = this.fullCharCodeAtPos();
            if (isIdentifierStart(code, true) || code === 92) {
              return this.finishToken(types$1.privateId, this.readWord1());
            }
          }
          this.raise((this || _global$1).pos, "Unexpected character '" + codePointToString(code) + "'");
        };
        pp.getTokenFromCode = function (code) {
          switch (code) {
          case 46:
            return this.readToken_dot();
          case 40:
            ++(this || _global$1).pos;
            return this.finishToken(types$1.parenL);
          case 41:
            ++(this || _global$1).pos;
            return this.finishToken(types$1.parenR);
          case 59:
            ++(this || _global$1).pos;
            return this.finishToken(types$1.semi);
          case 44:
            ++(this || _global$1).pos;
            return this.finishToken(types$1.comma);
          case 91:
            ++(this || _global$1).pos;
            return this.finishToken(types$1.bracketL);
          case 93:
            ++(this || _global$1).pos;
            return this.finishToken(types$1.bracketR);
          case 123:
            ++(this || _global$1).pos;
            return this.finishToken(types$1.braceL);
          case 125:
            ++(this || _global$1).pos;
            return this.finishToken(types$1.braceR);
          case 58:
            ++(this || _global$1).pos;
            return this.finishToken(types$1.colon);
          case 96:
            if ((this || _global$1).options.ecmaVersion < 6) {
              break;
            }
            ++(this || _global$1).pos;
            return this.finishToken(types$1.backQuote);
          case 48:
            var next = (this || _global$1).input.charCodeAt((this || _global$1).pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if ((this || _global$1).options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          case 34:
          case 39:
            return this.readString(code);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code);
          case 60:
          case 62:
            return this.readToken_lt_gt(code);
          case 61:
          case 33:
            return this.readToken_eq_excl(code);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types$1.prefix, 1);
          case 35:
            return this.readToken_numberSign();
          }
          this.raise((this || _global$1).pos, "Unexpected character '" + codePointToString(code) + "'");
        };
        pp.finishOp = function (type, size) {
          var str = (this || _global$1).input.slice((this || _global$1).pos, (this || _global$1).pos + size);
          (this || _global$1).pos += size;
          return this.finishToken(type, str);
        };
        pp.readRegexp = function () {
          var escaped, inClass, start = (this || _global$1).pos;
          for (;;) {
            if ((this || _global$1).pos >= (this || _global$1).input.length) {
              this.raise(start, "Unterminated regular expression");
            }
            var ch = (this || _global$1).input.charAt((this || _global$1).pos);
            if (lineBreak.test(ch)) {
              this.raise(start, "Unterminated regular expression");
            }
            if (!escaped) {
              if (ch === "[") {
                inClass = true;
              } else if (ch === "]" && inClass) {
                inClass = false;
              } else if (ch === "/" && !inClass) {
                break;
              }
              escaped = ch === "\\";
            } else {
              escaped = false;
            }
            ++(this || _global$1).pos;
          }
          var pattern = (this || _global$1).input.slice(start, (this || _global$1).pos);
          ++(this || _global$1).pos;
          var flagsStart = (this || _global$1).pos;
          var flags = this.readWord1();
          if ((this || _global$1).containsEsc) {
            this.unexpected(flagsStart);
          }
          var state = (this || _global$1).regexpState || ((this || _global$1).regexpState = new RegExpValidationState(this || _global$1));
          state.reset(start, pattern, flags);
          this.validateRegExpFlags(state);
          this.validateRegExpPattern(state);
          var value = null;
          try {
            value = new RegExp(pattern, flags);
          } catch (e) {
          }
          return this.finishToken(types$1.regexp, {
            pattern: pattern,
            flags: flags,
            value: value
          });
        };
        pp.readInt = function (radix, len, maybeLegacyOctalNumericLiteral) {
          var allowSeparators = (this || _global$1).options.ecmaVersion >= 12 && len === undefined;
          var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && (this || _global$1).input.charCodeAt((this || _global$1).pos) === 48;
          var start = (this || _global$1).pos, total = 0, lastCode = 0;
          for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++(this || _global$1).pos) {
            var code = (this || _global$1).input.charCodeAt((this || _global$1).pos), val = void 0;
            if (allowSeparators && code === 95) {
              if (isLegacyOctalNumericLiteral) {
                this.raiseRecoverable((this || _global$1).pos, "Numeric separator is not allowed in legacy octal numeric literals");
              }
              if (lastCode === 95) {
                this.raiseRecoverable((this || _global$1).pos, "Numeric separator must be exactly one underscore");
              }
              if (i === 0) {
                this.raiseRecoverable((this || _global$1).pos, "Numeric separator is not allowed at the first of digits");
              }
              lastCode = code;
              continue;
            }
            if (code >= 97) {
              val = code - 97 + 10;
            } else if (code >= 65) {
              val = code - 65 + 10;
            } else if (code >= 48 && code <= 57) {
              val = code - 48;
            } else {
              val = Infinity;
            }
            if (val >= radix) {
              break;
            }
            lastCode = code;
            total = total * radix + val;
          }
          if (allowSeparators && lastCode === 95) {
            this.raiseRecoverable((this || _global$1).pos - 1, "Numeric separator is not allowed at the last of digits");
          }
          if ((this || _global$1).pos === start || len != null && (this || _global$1).pos - start !== len) {
            return null;
          }
          return total;
        };
        function stringToNumber(str, isLegacyOctalNumericLiteral) {
          if (isLegacyOctalNumericLiteral) {
            return parseInt(str, 8);
          }
          return parseFloat(str.replace(/_/g, ""));
        }
        function stringToBigInt(str) {
          if (typeof BigInt !== "function") {
            return null;
          }
          return BigInt(str.replace(/_/g, ""));
        }
        pp.readRadixNumber = function (radix) {
          var start = (this || _global$1).pos;
          (this || _global$1).pos += 2;
          var val = this.readInt(radix);
          if (val == null) {
            this.raise((this || _global$1).start + 2, "Expected number in radix " + radix);
          }
          if ((this || _global$1).options.ecmaVersion >= 11 && (this || _global$1).input.charCodeAt((this || _global$1).pos) === 110) {
            val = stringToBigInt((this || _global$1).input.slice(start, (this || _global$1).pos));
            ++(this || _global$1).pos;
          } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise((this || _global$1).pos, "Identifier directly after number");
          }
          return this.finishToken(types$1.num, val);
        };
        pp.readNumber = function (startsWithDot) {
          var start = (this || _global$1).pos;
          if (!startsWithDot && this.readInt(10, undefined, true) === null) {
            this.raise(start, "Invalid number");
          }
          var octal = (this || _global$1).pos - start >= 2 && (this || _global$1).input.charCodeAt(start) === 48;
          if (octal && (this || _global$1).strict) {
            this.raise(start, "Invalid number");
          }
          var next = (this || _global$1).input.charCodeAt((this || _global$1).pos);
          if (!octal && !startsWithDot && (this || _global$1).options.ecmaVersion >= 11 && next === 110) {
            var val$1 = stringToBigInt((this || _global$1).input.slice(start, (this || _global$1).pos));
            ++(this || _global$1).pos;
            if (isIdentifierStart(this.fullCharCodeAtPos())) {
              this.raise((this || _global$1).pos, "Identifier directly after number");
            }
            return this.finishToken(types$1.num, val$1);
          }
          if (octal && /[89]/.test((this || _global$1).input.slice(start, (this || _global$1).pos))) {
            octal = false;
          }
          if (next === 46 && !octal) {
            ++(this || _global$1).pos;
            this.readInt(10);
            next = (this || _global$1).input.charCodeAt((this || _global$1).pos);
          }
          if ((next === 69 || next === 101) && !octal) {
            next = (this || _global$1).input.charCodeAt(++(this || _global$1).pos);
            if (next === 43 || next === 45) {
              ++(this || _global$1).pos;
            }
            if (this.readInt(10) === null) {
              this.raise(start, "Invalid number");
            }
          }
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise((this || _global$1).pos, "Identifier directly after number");
          }
          var val = stringToNumber((this || _global$1).input.slice(start, (this || _global$1).pos), octal);
          return this.finishToken(types$1.num, val);
        };
        pp.readCodePoint = function () {
          var ch = (this || _global$1).input.charCodeAt((this || _global$1).pos), code;
          if (ch === 123) {
            if ((this || _global$1).options.ecmaVersion < 6) {
              this.unexpected();
            }
            var codePos = ++(this || _global$1).pos;
            code = this.readHexChar((this || _global$1).input.indexOf("}", (this || _global$1).pos) - (this || _global$1).pos);
            ++(this || _global$1).pos;
            if (code > 1114111) {
              this.invalidStringToken(codePos, "Code point out of bounds");
            }
          } else {
            code = this.readHexChar(4);
          }
          return code;
        };
        pp.readString = function (quote) {
          var out = "", chunkStart = ++(this || _global$1).pos;
          for (;;) {
            if ((this || _global$1).pos >= (this || _global$1).input.length) {
              this.raise((this || _global$1).start, "Unterminated string constant");
            }
            var ch = (this || _global$1).input.charCodeAt((this || _global$1).pos);
            if (ch === quote) {
              break;
            }
            if (ch === 92) {
              out += (this || _global$1).input.slice(chunkStart, (this || _global$1).pos);
              out += this.readEscapedChar(false);
              chunkStart = (this || _global$1).pos;
            } else if (ch === 8232 || ch === 8233) {
              if ((this || _global$1).options.ecmaVersion < 10) {
                this.raise((this || _global$1).start, "Unterminated string constant");
              }
              ++(this || _global$1).pos;
              if ((this || _global$1).options.locations) {
                (this || _global$1).curLine++;
                (this || _global$1).lineStart = (this || _global$1).pos;
              }
            } else {
              if (isNewLine(ch)) {
                this.raise((this || _global$1).start, "Unterminated string constant");
              }
              ++(this || _global$1).pos;
            }
          }
          out += (this || _global$1).input.slice(chunkStart, (this || _global$1).pos++);
          return this.finishToken(types$1.string, out);
        };
        var INVALID_TEMPLATE_ESCAPE_ERROR = {};
        pp.tryReadTemplateToken = function () {
          (this || _global$1).inTemplateElement = true;
          try {
            this.readTmplToken();
          } catch (err) {
            if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
              this.readInvalidTemplateToken();
            } else {
              throw err;
            }
          }
          (this || _global$1).inTemplateElement = false;
        };
        pp.invalidStringToken = function (position, message) {
          if ((this || _global$1).inTemplateElement && (this || _global$1).options.ecmaVersion >= 9) {
            throw INVALID_TEMPLATE_ESCAPE_ERROR;
          } else {
            this.raise(position, message);
          }
        };
        pp.readTmplToken = function () {
          var out = "", chunkStart = (this || _global$1).pos;
          for (;;) {
            if ((this || _global$1).pos >= (this || _global$1).input.length) {
              this.raise((this || _global$1).start, "Unterminated template");
            }
            var ch = (this || _global$1).input.charCodeAt((this || _global$1).pos);
            if (ch === 96 || ch === 36 && (this || _global$1).input.charCodeAt((this || _global$1).pos + 1) === 123) {
              if ((this || _global$1).pos === (this || _global$1).start && ((this || _global$1).type === types$1.template || (this || _global$1).type === types$1.invalidTemplate)) {
                if (ch === 36) {
                  (this || _global$1).pos += 2;
                  return this.finishToken(types$1.dollarBraceL);
                } else {
                  ++(this || _global$1).pos;
                  return this.finishToken(types$1.backQuote);
                }
              }
              out += (this || _global$1).input.slice(chunkStart, (this || _global$1).pos);
              return this.finishToken(types$1.template, out);
            }
            if (ch === 92) {
              out += (this || _global$1).input.slice(chunkStart, (this || _global$1).pos);
              out += this.readEscapedChar(true);
              chunkStart = (this || _global$1).pos;
            } else if (isNewLine(ch)) {
              out += (this || _global$1).input.slice(chunkStart, (this || _global$1).pos);
              ++(this || _global$1).pos;
              switch (ch) {
              case 13:
                if ((this || _global$1).input.charCodeAt((this || _global$1).pos) === 10) {
                  ++(this || _global$1).pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
              }
              if ((this || _global$1).options.locations) {
                ++(this || _global$1).curLine;
                (this || _global$1).lineStart = (this || _global$1).pos;
              }
              chunkStart = (this || _global$1).pos;
            } else {
              ++(this || _global$1).pos;
            }
          }
        };
        pp.readInvalidTemplateToken = function () {
          for (; (this || _global$1).pos < (this || _global$1).input.length; (this || _global$1).pos++) {
            switch ((this || _global$1).input[(this || _global$1).pos]) {
            case "\\":
              ++(this || _global$1).pos;
              break;
            case "$":
              if ((this || _global$1).input[(this || _global$1).pos + 1] !== "{") {
                break;
              }
            case "`":
              return this.finishToken(types$1.invalidTemplate, (this || _global$1).input.slice((this || _global$1).start, (this || _global$1).pos));
            }
          }
          this.raise((this || _global$1).start, "Unterminated template");
        };
        pp.readEscapedChar = function (inTemplate) {
          var ch = (this || _global$1).input.charCodeAt(++(this || _global$1).pos);
          ++(this || _global$1).pos;
          switch (ch) {
          case 110:
            return "\n";
          case 114:
            return "\r";
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          case 117:
            return codePointToString(this.readCodePoint());
          case 116:
            return "\t";
          case 98:
            return "\b";
          case 118:
            return "\x0B";
          case 102:
            return "\f";
          case 13:
            if ((this || _global$1).input.charCodeAt((this || _global$1).pos) === 10) {
              ++(this || _global$1).pos;
            }
          case 10:
            if ((this || _global$1).options.locations) {
              (this || _global$1).lineStart = (this || _global$1).pos;
              ++(this || _global$1).curLine;
            }
            return "";
          case 56:
          case 57:
            if ((this || _global$1).strict) {
              this.invalidStringToken((this || _global$1).pos - 1, "Invalid escape sequence");
            }
            if (inTemplate) {
              var codePos = (this || _global$1).pos - 1;
              this.invalidStringToken(codePos, "Invalid escape sequence in template string");
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = (this || _global$1).input.substr((this || _global$1).pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              (this || _global$1).pos += octalStr.length - 1;
              ch = (this || _global$1).input.charCodeAt((this || _global$1).pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && ((this || _global$1).strict || inTemplate)) {
                this.invalidStringToken((this || _global$1).pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine(ch)) {
              return "";
            }
            return String.fromCharCode(ch);
          }
        };
        pp.readHexChar = function (len) {
          var codePos = (this || _global$1).pos;
          var n = this.readInt(16, len);
          if (n === null) {
            this.invalidStringToken(codePos, "Bad character escape sequence");
          }
          return n;
        };
        pp.readWord1 = function () {
          (this || _global$1).containsEsc = false;
          var word = "", first = true, chunkStart = (this || _global$1).pos;
          var astral = (this || _global$1).options.ecmaVersion >= 6;
          while ((this || _global$1).pos < (this || _global$1).input.length) {
            var ch = this.fullCharCodeAtPos();
            if (isIdentifierChar(ch, astral)) {
              (this || _global$1).pos += ch <= 65535 ? 1 : 2;
            } else if (ch === 92) {
              (this || _global$1).containsEsc = true;
              word += (this || _global$1).input.slice(chunkStart, (this || _global$1).pos);
              var escStart = (this || _global$1).pos;
              if ((this || _global$1).input.charCodeAt(++(this || _global$1).pos) !== 117) {
                this.invalidStringToken((this || _global$1).pos, "Expecting Unicode escape sequence \\uXXXX");
              }
              ++(this || _global$1).pos;
              var esc = this.readCodePoint();
              if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
                this.invalidStringToken(escStart, "Invalid Unicode escape");
              }
              word += codePointToString(esc);
              chunkStart = (this || _global$1).pos;
            } else {
              break;
            }
            first = false;
          }
          return word + (this || _global$1).input.slice(chunkStart, (this || _global$1).pos);
        };
        pp.readWord = function () {
          var word = this.readWord1();
          var type = types$1.name;
          if ((this || _global$1).keywords.test(word)) {
            type = keywords[word];
          }
          return this.finishToken(type, word);
        };
        var version = "8.11.2";
        Parser.acorn = {
          Parser: Parser,
          version: version,
          defaultOptions: defaultOptions,
          Position: Position,
          SourceLocation: SourceLocation,
          getLineInfo: getLineInfo,
          Node: Node,
          TokenType: TokenType,
          tokTypes: types$1,
          keywordTypes: keywords,
          TokContext: TokContext,
          tokContexts: types,
          isIdentifierChar: isIdentifierChar,
          isIdentifierStart: isIdentifierStart,
          Token: Token,
          isNewLine: isNewLine,
          lineBreak: lineBreak,
          lineBreakG: lineBreakG,
          nonASCIIwhitespace: nonASCIIwhitespace
        };
        function parse(input, options) {
          return Parser.parse(input, options);
        }
        function parseExpressionAt(input, pos, options) {
          return Parser.parseExpressionAt(input, pos, options);
        }
        function tokenizer(input, options) {
          return Parser.tokenizer(input, options);
        }
        exports.Node = Node;
        exports.Parser = Parser;
        exports.Position = Position;
        exports.SourceLocation = SourceLocation;
        exports.TokContext = TokContext;
        exports.Token = Token;
        exports.TokenType = TokenType;
        exports.defaultOptions = defaultOptions;
        exports.getLineInfo = getLineInfo;
        exports.isIdentifierChar = isIdentifierChar;
        exports.isIdentifierStart = isIdentifierStart;
        exports.isNewLine = isNewLine;
        exports.keywordTypes = keywords;
        exports.lineBreak = lineBreak;
        exports.lineBreakG = lineBreakG;
        exports.nonASCIIwhitespace = nonASCIIwhitespace;
        exports.parse = parse;
        exports.parseExpressionAt = parseExpressionAt;
        exports.tokContexts = types;
        exports.tokTypes = types$1;
        exports.tokenizer = tokenizer;
        exports.version = version;
      }));
      const Node$2 = exports$7.Node, Parser$1 = exports$7.Parser, Position$1 = exports$7.Position, SourceLocation$1 = exports$7.SourceLocation, TokContext$1 = exports$7.TokContext, Token$1 = exports$7.Token, TokenType$1 = exports$7.TokenType, defaultOptions$1 = exports$7.defaultOptions, getLineInfo$1 = exports$7.getLineInfo, isIdentifierChar$1 = exports$7.isIdentifierChar, isIdentifierStart$1 = exports$7.isIdentifierStart, isNewLine$1 = exports$7.isNewLine, keywordTypes = exports$7.keywordTypes, lineBreak$1 = exports$7.lineBreak, lineBreakG$1 = exports$7.lineBreakG, nonASCIIwhitespace$1 = exports$7.nonASCIIwhitespace, parse$2 = exports$7.parse, parseExpressionAt = exports$7.parseExpressionAt, tokContexts = exports$7.tokContexts, tokTypes = exports$7.tokTypes, tokenizer = exports$7.tokenizer, version$1 = exports$7.version; exports({ $: Node$2, a0: Parser$1, a1: Position$1, a2: SourceLocation$1, a3: TokContext$1, a4: Token$1, a5: TokenType$1, a6: defaultOptions$1, a7: getLineInfo$1, a8: isIdentifierChar$1, a9: isIdentifierStart$1, aa: isNewLine$1, ab: keywordTypes, ac: lineBreak$1, ad: lineBreakG$1, ae: nonASCIIwhitespace$1, af: parse$2, ag: parseExpressionAt, ah: tokContexts, ai: tokTypes, aj: tokenizer, ak: version$1 });

      var exports$6 = {};
      const getPrototype = Object.getPrototypeOf || (o => o.__proto__);
      const getAcorn = Parser => {
        if (Parser.acorn)
          return Parser.acorn;
        const acorn = exports$7;
        if (acorn.version.indexOf("6.") != 0 && acorn.version.indexOf("6.0.") == 0 && acorn.version.indexOf("7.") != 0) {
          throw new Error(`acorn-private-class-elements requires acorn@^6.1.0 or acorn@7.0.0, not ${ acorn.version }`);
        }
        for (let cur = Parser; cur && cur !== acorn.Parser; cur = getPrototype(cur)) {
          if (cur !== acorn.Parser) {
            throw new Error("acorn-private-class-elements does not support mixing different acorn copies");
          }
        }
        return acorn;
      };
      exports$6 = function (Parser) {
        if (Parser.prototype.parsePrivateName) {
          return Parser;
        }
        const acorn = getAcorn(Parser);
        Parser = class extends Parser {
          _branch() {
            this.__branch = this.__branch || new Parser({ ecmaVersion: this.options.ecmaVersion }, this.input);
            this.__branch.end = this.end;
            this.__branch.pos = this.pos;
            this.__branch.type = this.type;
            this.__branch.value = this.value;
            this.__branch.containsEsc = this.containsEsc;
            return this.__branch;
          }
          parsePrivateClassElementName(element) {
            element.computed = false;
            element.key = this.parsePrivateName();
            if (element.key.name == "constructor")
              this.raise(element.key.start, "Classes may not have a private element named constructor");
            const accept = {
              get: "set",
              set: "get"
            }[element.kind];
            const privateBoundNames = this._privateBoundNames;
            if (Object.prototype.hasOwnProperty.call(privateBoundNames, element.key.name) && privateBoundNames[element.key.name] !== accept) {
              this.raise(element.start, "Duplicate private element");
            }
            privateBoundNames[element.key.name] = element.kind || true;
            delete this._unresolvedPrivateNames[element.key.name];
            return element.key;
          }
          parsePrivateName() {
            const node = this.startNode();
            node.name = this.value;
            this.next();
            this.finishNode(node, "PrivateIdentifier");
            if (this.options.allowReserved == "never")
              this.checkUnreserved(node);
            return node;
          }
          getTokenFromCode(code) {
            if (code === 35) {
              ++this.pos;
              const word = this.readWord1();
              return this.finishToken(this.privateIdentifierToken, word);
            }
            return super.getTokenFromCode(code);
          }
          parseClass(node, isStatement) {
            const oldOuterPrivateBoundNames = this._outerPrivateBoundNames;
            this._outerPrivateBoundNames = this._privateBoundNames;
            this._privateBoundNames = Object.create(this._privateBoundNames || null);
            const oldOuterUnresolvedPrivateNames = this._outerUnresolvedPrivateNames;
            this._outerUnresolvedPrivateNames = this._unresolvedPrivateNames;
            this._unresolvedPrivateNames = Object.create(null);
            const _return = super.parseClass(node, isStatement);
            const unresolvedPrivateNames = this._unresolvedPrivateNames;
            this._privateBoundNames = this._outerPrivateBoundNames;
            this._outerPrivateBoundNames = oldOuterPrivateBoundNames;
            this._unresolvedPrivateNames = this._outerUnresolvedPrivateNames;
            this._outerUnresolvedPrivateNames = oldOuterUnresolvedPrivateNames;
            if (!this._unresolvedPrivateNames) {
              const names = Object.keys(unresolvedPrivateNames);
              if (names.length) {
                names.sort((n1, n2) => unresolvedPrivateNames[n1] - unresolvedPrivateNames[n2]);
                this.raise(unresolvedPrivateNames[names[0]], "Usage of undeclared private name");
              }
            } else
              Object.assign(this._unresolvedPrivateNames, unresolvedPrivateNames);
            return _return;
          }
          parseClassSuper(node) {
            const privateBoundNames = this._privateBoundNames;
            this._privateBoundNames = this._outerPrivateBoundNames;
            const unresolvedPrivateNames = this._unresolvedPrivateNames;
            this._unresolvedPrivateNames = this._outerUnresolvedPrivateNames;
            const _return = super.parseClassSuper(node);
            this._privateBoundNames = privateBoundNames;
            this._unresolvedPrivateNames = unresolvedPrivateNames;
            return _return;
          }
          parseSubscript(base, startPos, startLoc, _noCalls, _maybeAsyncArrow, _optionalChained) {
            const optionalSupported = this.options.ecmaVersion >= 11 && acorn.tokTypes.questionDot;
            const branch = this._branch();
            if (!((branch.eat(acorn.tokTypes.dot) || optionalSupported && branch.eat(acorn.tokTypes.questionDot)) && branch.type == this.privateIdentifierToken)) {
              return super.parseSubscript.apply(this, arguments);
            }
            let optional = false;
            if (!this.eat(acorn.tokTypes.dot)) {
              this.expect(acorn.tokTypes.questionDot);
              optional = true;
            }
            let node = this.startNodeAt(startPos, startLoc);
            node.object = base;
            node.computed = false;
            if (optionalSupported) {
              node.optional = optional;
            }
            if (this.type == this.privateIdentifierToken) {
              if (base.type == "Super") {
                this.raise(this.start, "Cannot access private element on super");
              }
              node.property = this.parsePrivateName();
              if (!this._privateBoundNames || !this._privateBoundNames[node.property.name]) {
                if (!this._unresolvedPrivateNames) {
                  this.raise(node.property.start, "Usage of undeclared private name");
                }
                this._unresolvedPrivateNames[node.property.name] = node.property.start;
              }
            } else {
              node.property = this.parseIdent(true);
            }
            return this.finishNode(node, "MemberExpression");
          }
          parseMaybeUnary(refDestructuringErrors, sawUnary) {
            const _return = super.parseMaybeUnary(refDestructuringErrors, sawUnary);
            if (_return.operator == "delete") {
              if (_return.argument.type == "MemberExpression" && _return.argument.property.type == "PrivateIdentifier") {
                this.raise(_return.start, "Private elements may not be deleted");
              }
            }
            return _return;
          }
        };
        Parser.prototype.privateIdentifierToken = new acorn.TokenType("privateIdentifier");
        return Parser;
      };
      var exports$1$5 = exports$6;

      var exports$5 = {};
      const privateClassElements$2 = exports$1$5;
      exports$5 = function (Parser) {
        const acorn = Parser.acorn || exports$7;
        const tt = acorn.tokTypes;
        Parser = privateClassElements$2(Parser);
        return class extends Parser {
          _maybeParseFieldValue(field) {
            if (this.eat(tt.eq)) {
              const oldInFieldValue = this._inFieldValue;
              this._inFieldValue = true;
              if (this.type === tt.name && this.value === "await" && (this.inAsync || this.options.allowAwaitOutsideFunction)) {
                field.value = this.parseAwait();
              } else
                field.value = this.parseExpression();
              this._inFieldValue = oldInFieldValue;
            } else
              field.value = null;
          }
          parseClassElement(_constructorAllowsSuper) {
            if (this.options.ecmaVersion >= 8 && (this.type == tt.name || this.type.keyword || this.type == this.privateIdentifierToken || this.type == tt.bracketL || this.type == tt.string || this.type == tt.num)) {
              const branch = this._branch();
              if (branch.type == tt.bracketL) {
                let count = 0;
                do {
                  if (branch.eat(tt.bracketL))
                    ++count;
                  else if (branch.eat(tt.bracketR))
                    --count;
                  else
                    branch.next();
                } while (count > 0);
              } else
                branch.next(true);
              let isField = branch.type == tt.eq || branch.type == tt.semi;
              if (!isField && branch.canInsertSemicolon()) {
                isField = branch.type != tt.parenL;
              }
              if (isField) {
                const node = this.startNode();
                if (this.type == this.privateIdentifierToken) {
                  this.parsePrivateClassElementName(node);
                } else {
                  this.parsePropertyName(node);
                }
                if (node.key.type === "Identifier" && node.key.name === "constructor" || node.key.type === "Literal" && node.key.value === "constructor") {
                  this.raise(node.key.start, "Classes may not have a field called constructor");
                }
                this.enterScope(64 | 2 | 1);
                this._maybeParseFieldValue(node);
                this.exitScope();
                this.finishNode(node, "PropertyDefinition");
                this.semicolon();
                return node;
              }
            }
            return super.parseClassElement.apply(this, arguments);
          }
          parseIdent(liberal, isBinding) {
            const ident = super.parseIdent(liberal, isBinding);
            if (this._inFieldValue && ident.name == "arguments")
              this.raise(ident.start, "A class field initializer may not contain arguments");
            return ident;
          }
        };
      };
      var exports$1$4 = exports$5;

      var exports$4 = {};
      const privateClassElements$1 = exports$1$5;
      exports$4 = function (Parser) {
        const ExtendedParser = privateClassElements$1(Parser);
        const acorn = Parser.acorn || exports$7;
        const tt = acorn.tokTypes;
        return class extends ExtendedParser {
          _maybeParseFieldValue(field) {
            if (this.eat(tt.eq)) {
              const oldInFieldValue = this._inStaticFieldScope;
              this._inStaticFieldScope = this.currentThisScope();
              field.value = this.parseExpression();
              this._inStaticFieldScope = oldInFieldValue;
            } else
              field.value = null;
          }
          parseClassElement(_constructorAllowsSuper) {
            if (this.options.ecmaVersion < 8 || !this.isContextual("static")) {
              return super.parseClassElement.apply(this, arguments);
            }
            const branch = this._branch();
            branch.next();
            if ([
                tt.name,
                tt.bracketL,
                tt.string,
                tt.num,
                this.privateIdentifierToken
              ].indexOf(branch.type) == -1 && !branch.type.keyword) {
              return super.parseClassElement.apply(this, arguments);
            }
            if (branch.type == tt.bracketL) {
              let count = 0;
              do {
                if (branch.eat(tt.bracketL))
                  ++count;
                else if (branch.eat(tt.bracketR))
                  --count;
                else
                  branch.next();
              } while (count > 0);
            } else
              branch.next();
            if (branch.type != tt.eq && !branch.canInsertSemicolon() && branch.type != tt.semi) {
              return super.parseClassElement.apply(this, arguments);
            }
            const node = this.startNode();
            node.static = this.eatContextual("static");
            if (this.type == this.privateIdentifierToken) {
              this.parsePrivateClassElementName(node);
            } else {
              this.parsePropertyName(node);
            }
            if (node.key.type === "Identifier" && node.key.name === "constructor" || node.key.type === "Literal" && !node.computed && node.key.value === "constructor") {
              this.raise(node.key.start, "Classes may not have a field called constructor");
            }
            if ((node.key.name || node.key.value) === "prototype" && !node.computed) {
              this.raise(node.key.start, "Classes may not have a static property named prototype");
            }
            this.enterScope(64 | 2 | 1);
            this._maybeParseFieldValue(node);
            this.exitScope();
            this.finishNode(node, "PropertyDefinition");
            this.semicolon();
            return node;
          }
          parsePropertyName(prop) {
            if (prop.static && this.type == this.privateIdentifierToken) {
              this.parsePrivateClassElementName(prop);
            } else {
              super.parsePropertyName(prop);
            }
          }
          parseIdent(liberal, isBinding) {
            const ident = super.parseIdent(liberal, isBinding);
            if (this._inStaticFieldScope && this.currentThisScope() === this._inStaticFieldScope && ident.name == "arguments") {
              this.raise(ident.start, "A static class field initializer may not contain arguments");
            }
            return ident;
          }
        };
      };
      var exports$1$3 = exports$4;

      var exports$3 = {};
      var privateClassElements = exports$1$5;
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var privateClassElements__default = _interopDefaultLegacy(privateClassElements);
      function privateMethods(Parser) {
        const ExtendedParser = privateClassElements__default["default"](Parser);
        return class extends ExtendedParser {
          parseClassElement(_constructorAllowsSuper) {
            const oldInClassMemberName = this._inClassMemberName;
            this._inClassMemberName = true;
            const result = super.parseClassElement.apply(this, arguments);
            this._inClassMemberName = oldInClassMemberName;
            return result;
          }
          parsePropertyName(prop) {
            const isPrivate = this.options.ecmaVersion >= 8 && this._inClassMemberName && this.type == this.privateIdentifierToken && !prop.static;
            this._inClassMemberName = false;
            if (!isPrivate)
              return super.parsePropertyName(prop);
            return this.parsePrivateClassElementName(prop);
          }
        };
      }
      exports$3 = privateMethods;
      var exports$1$2 = exports$3;

      function simple(node, visitors, baseVisitor, state, override) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        (function c(node, st, override) {
          var type = override || node.type, found = visitors[type];
          baseVisitor[type](node, st, c);
          if (found) {
            found(node, st);
          }
        }(node, state, override));
      }
      function ancestor(node, visitors, baseVisitor, state, override) {
        var ancestors = [];
        if (!baseVisitor) {
          baseVisitor = base;
        }
        (function c(node, st, override) {
          var type = override || node.type, found = visitors[type];
          var isNew = node !== ancestors[ancestors.length - 1];
          if (isNew) {
            ancestors.push(node);
          }
          baseVisitor[type](node, st, c);
          if (found) {
            found(node, st || ancestors, ancestors);
          }
          if (isNew) {
            ancestors.pop();
          }
        }(node, state, override));
      }
      function recursive(node, state, funcs, baseVisitor, override) {
        var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor;
        (function c(node, st, override) {
          visitor[override || node.type](node, st, c);
        }(node, state, override));
      }
      function makeTest(test) {
        if (typeof test === "string") {
          return function (type) {
            return type === test;
          };
        } else if (!test) {
          return function () {
            return true;
          };
        } else {
          return test;
        }
      }
      var Found = function Found(node, state) {
        this.node = node;
        this.state = state;
      };
      function full(node, callback, baseVisitor, state, override) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        var last;
        (function c(node, st, override) {
          var type = override || node.type;
          baseVisitor[type](node, st, c);
          if (last !== node) {
            callback(node, st, type);
            last = node;
          }
        }(node, state, override));
      }
      function fullAncestor(node, callback, baseVisitor, state) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        var ancestors = [], last;
        (function c(node, st, override) {
          var type = override || node.type;
          var isNew = node !== ancestors[ancestors.length - 1];
          if (isNew) {
            ancestors.push(node);
          }
          baseVisitor[type](node, st, c);
          if (last !== node) {
            callback(node, st || ancestors, ancestors, type);
            last = node;
          }
          if (isNew) {
            ancestors.pop();
          }
        }(node, state));
      }
      function findNodeAt(node, start, end, test, baseVisitor, state) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        test = makeTest(test);
        try {
          (function c(node, st, override) {
            var type = override || node.type;
            if ((start == null || node.start <= start) && (end == null || node.end >= end)) {
              baseVisitor[type](node, st, c);
            }
            if ((start == null || node.start === start) && (end == null || node.end === end) && test(type, node)) {
              throw new Found(node, st);
            }
          }(node, state));
        } catch (e) {
          if (e instanceof Found) {
            return e;
          }
          throw e;
        }
      }
      function findNodeAround(node, pos, test, baseVisitor, state) {
        test = makeTest(test);
        if (!baseVisitor) {
          baseVisitor = base;
        }
        try {
          (function c(node, st, override) {
            var type = override || node.type;
            if (node.start > pos || node.end < pos) {
              return;
            }
            baseVisitor[type](node, st, c);
            if (test(type, node)) {
              throw new Found(node, st);
            }
          }(node, state));
        } catch (e) {
          if (e instanceof Found) {
            return e;
          }
          throw e;
        }
      }
      function findNodeAfter(node, pos, test, baseVisitor, state) {
        test = makeTest(test);
        if (!baseVisitor) {
          baseVisitor = base;
        }
        try {
          (function c(node, st, override) {
            if (node.end < pos) {
              return;
            }
            var type = override || node.type;
            if (node.start >= pos && test(type, node)) {
              throw new Found(node, st);
            }
            baseVisitor[type](node, st, c);
          }(node, state));
        } catch (e) {
          if (e instanceof Found) {
            return e;
          }
          throw e;
        }
      }
      function findNodeBefore(node, pos, test, baseVisitor, state) {
        test = makeTest(test);
        if (!baseVisitor) {
          baseVisitor = base;
        }
        var max;
        (function c(node, st, override) {
          if (node.start > pos) {
            return;
          }
          var type = override || node.type;
          if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) {
            max = new Found(node, st);
          }
          baseVisitor[type](node, st, c);
        }(node, state));
        return max;
      }
      function make(funcs, baseVisitor) {
        var visitor = Object.create(baseVisitor || base);
        for (var type in funcs) {
          visitor[type] = funcs[type];
        }
        return visitor;
      }
      function skipThrough(node, st, c) {
        c(node, st);
      }
      function ignore(_node, _st, _c) {
      }
      var base = exports('X', {});
      base.Program = base.BlockStatement = base.StaticBlock = function (node, st, c) {
        for (var i = 0, list = node.body; i < list.length; i += 1) {
          var stmt = list[i];
          c(stmt, st, "Statement");
        }
      };
      base.Statement = skipThrough;
      base.EmptyStatement = ignore;
      base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function (node, st, c) {
        return c(node.expression, st, "Expression");
      };
      base.IfStatement = function (node, st, c) {
        c(node.test, st, "Expression");
        c(node.consequent, st, "Statement");
        if (node.alternate) {
          c(node.alternate, st, "Statement");
        }
      };
      base.LabeledStatement = function (node, st, c) {
        return c(node.body, st, "Statement");
      };
      base.BreakStatement = base.ContinueStatement = ignore;
      base.WithStatement = function (node, st, c) {
        c(node.object, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.SwitchStatement = function (node, st, c) {
        c(node.discriminant, st, "Expression");
        for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {
          var cs = list$1[i$1];
          if (cs.test) {
            c(cs.test, st, "Expression");
          }
          for (var i = 0, list = cs.consequent; i < list.length; i += 1) {
            var cons = list[i];
            c(cons, st, "Statement");
          }
        }
      };
      base.SwitchCase = function (node, st, c) {
        if (node.test) {
          c(node.test, st, "Expression");
        }
        for (var i = 0, list = node.consequent; i < list.length; i += 1) {
          var cons = list[i];
          c(cons, st, "Statement");
        }
      };
      base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {
        if (node.argument) {
          c(node.argument, st, "Expression");
        }
      };
      base.ThrowStatement = base.SpreadElement = function (node, st, c) {
        return c(node.argument, st, "Expression");
      };
      base.TryStatement = function (node, st, c) {
        c(node.block, st, "Statement");
        if (node.handler) {
          c(node.handler, st);
        }
        if (node.finalizer) {
          c(node.finalizer, st, "Statement");
        }
      };
      base.CatchClause = function (node, st, c) {
        if (node.param) {
          c(node.param, st, "Pattern");
        }
        c(node.body, st, "Statement");
      };
      base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
        c(node.test, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.ForStatement = function (node, st, c) {
        if (node.init) {
          c(node.init, st, "ForInit");
        }
        if (node.test) {
          c(node.test, st, "Expression");
        }
        if (node.update) {
          c(node.update, st, "Expression");
        }
        c(node.body, st, "Statement");
      };
      base.ForInStatement = base.ForOfStatement = function (node, st, c) {
        c(node.left, st, "ForInit");
        c(node.right, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.ForInit = function (node, st, c) {
        if (node.type === "VariableDeclaration") {
          c(node, st);
        } else {
          c(node, st, "Expression");
        }
      };
      base.DebuggerStatement = ignore;
      base.FunctionDeclaration = function (node, st, c) {
        return c(node, st, "Function");
      };
      base.VariableDeclaration = function (node, st, c) {
        for (var i = 0, list = node.declarations; i < list.length; i += 1) {
          var decl = list[i];
          c(decl, st);
        }
      };
      base.VariableDeclarator = function (node, st, c) {
        c(node.id, st, "Pattern");
        if (node.init) {
          c(node.init, st, "Expression");
        }
      };
      base.Function = function (node, st, c) {
        if (node.id) {
          c(node.id, st, "Pattern");
        }
        for (var i = 0, list = node.params; i < list.length; i += 1) {
          var param = list[i];
          c(param, st, "Pattern");
        }
        c(node.body, st, node.expression ? "Expression" : "Statement");
      };
      base.Pattern = function (node, st, c) {
        if (node.type === "Identifier") {
          c(node, st, "VariablePattern");
        } else if (node.type === "MemberExpression") {
          c(node, st, "MemberPattern");
        } else {
          c(node, st);
        }
      };
      base.VariablePattern = ignore;
      base.MemberPattern = skipThrough;
      base.RestElement = function (node, st, c) {
        return c(node.argument, st, "Pattern");
      };
      base.ArrayPattern = function (node, st, c) {
        for (var i = 0, list = node.elements; i < list.length; i += 1) {
          var elt = list[i];
          if (elt) {
            c(elt, st, "Pattern");
          }
        }
      };
      base.ObjectPattern = function (node, st, c) {
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];
          if (prop.type === "Property") {
            if (prop.computed) {
              c(prop.key, st, "Expression");
            }
            c(prop.value, st, "Pattern");
          } else if (prop.type === "RestElement") {
            c(prop.argument, st, "Pattern");
          }
        }
      };
      base.Expression = skipThrough;
      base.ThisExpression = base.Super = base.MetaProperty = ignore;
      base.ArrayExpression = function (node, st, c) {
        for (var i = 0, list = node.elements; i < list.length; i += 1) {
          var elt = list[i];
          if (elt) {
            c(elt, st, "Expression");
          }
        }
      };
      base.ObjectExpression = function (node, st, c) {
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];
          c(prop, st);
        }
      };
      base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
      base.SequenceExpression = function (node, st, c) {
        for (var i = 0, list = node.expressions; i < list.length; i += 1) {
          var expr = list[i];
          c(expr, st, "Expression");
        }
      };
      base.TemplateLiteral = function (node, st, c) {
        for (var i = 0, list = node.quasis; i < list.length; i += 1) {
          var quasi = list[i];
          c(quasi, st);
        }
        for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {
          var expr = list$1[i$1];
          c(expr, st, "Expression");
        }
      };
      base.TemplateElement = ignore;
      base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
        c(node.argument, st, "Expression");
      };
      base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
        c(node.left, st, "Expression");
        c(node.right, st, "Expression");
      };
      base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
        c(node.left, st, "Pattern");
        c(node.right, st, "Expression");
      };
      base.ConditionalExpression = function (node, st, c) {
        c(node.test, st, "Expression");
        c(node.consequent, st, "Expression");
        c(node.alternate, st, "Expression");
      };
      base.NewExpression = base.CallExpression = function (node, st, c) {
        c(node.callee, st, "Expression");
        if (node.arguments) {
          for (var i = 0, list = node.arguments; i < list.length; i += 1) {
            var arg = list[i];
            c(arg, st, "Expression");
          }
        }
      };
      base.MemberExpression = function (node, st, c) {
        c(node.object, st, "Expression");
        if (node.computed) {
          c(node.property, st, "Expression");
        }
      };
      base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
        if (node.declaration) {
          c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
        }
        if (node.source) {
          c(node.source, st, "Expression");
        }
      };
      base.ExportAllDeclaration = function (node, st, c) {
        if (node.exported) {
          c(node.exported, st);
        }
        c(node.source, st, "Expression");
      };
      base.ImportDeclaration = function (node, st, c) {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          var spec = list[i];
          c(spec, st);
        }
        c(node.source, st, "Expression");
      };
      base.ImportExpression = function (node, st, c) {
        c(node.source, st, "Expression");
      };
      base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;
      base.TaggedTemplateExpression = function (node, st, c) {
        c(node.tag, st, "Expression");
        c(node.quasi, st, "Expression");
      };
      base.ClassDeclaration = base.ClassExpression = function (node, st, c) {
        return c(node, st, "Class");
      };
      base.Class = function (node, st, c) {
        if (node.id) {
          c(node.id, st, "Pattern");
        }
        if (node.superClass) {
          c(node.superClass, st, "Expression");
        }
        c(node.body, st);
      };
      base.ClassBody = function (node, st, c) {
        for (var i = 0, list = node.body; i < list.length; i += 1) {
          var elt = list[i];
          c(elt, st);
        }
      };
      base.MethodDefinition = base.PropertyDefinition = base.Property = function (node, st, c) {
        if (node.computed) {
          c(node.key, st, "Expression");
        }
        if (node.value) {
          c(node.value, st, "Expression");
        }
      };

      var walk = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ancestor: ancestor,
        base: base,
        findNodeAfter: findNodeAfter,
        findNodeAround: findNodeAround,
        findNodeAt: findNodeAt,
        findNodeBefore: findNodeBefore,
        full: full,
        fullAncestor: fullAncestor,
        make: make,
        recursive: recursive,
        simple: simple
      });

      var astralIdentifierCodes = [
        509,
        0,
        227,
        0,
        150,
        4,
        294,
        9,
        1368,
        2,
        2,
        1,
        6,
        3,
        41,
        2,
        5,
        0,
        166,
        1,
        574,
        3,
        9,
        9,
        370,
        1,
        81,
        2,
        71,
        10,
        50,
        3,
        123,
        2,
        54,
        14,
        32,
        10,
        3,
        1,
        11,
        3,
        46,
        10,
        8,
        0,
        46,
        9,
        7,
        2,
        37,
        13,
        2,
        9,
        6,
        1,
        45,
        0,
        13,
        2,
        49,
        13,
        9,
        3,
        2,
        11,
        83,
        11,
        7,
        0,
        3,
        0,
        158,
        11,
        6,
        9,
        7,
        3,
        56,
        1,
        2,
        6,
        3,
        1,
        3,
        2,
        10,
        0,
        11,
        1,
        3,
        6,
        4,
        4,
        193,
        17,
        10,
        9,
        5,
        0,
        82,
        19,
        13,
        9,
        214,
        6,
        3,
        8,
        28,
        1,
        83,
        16,
        16,
        9,
        82,
        12,
        9,
        9,
        84,
        14,
        5,
        9,
        243,
        14,
        166,
        9,
        71,
        5,
        2,
        1,
        3,
        3,
        2,
        0,
        2,
        1,
        13,
        9,
        120,
        6,
        3,
        6,
        4,
        0,
        29,
        9,
        41,
        6,
        2,
        3,
        9,
        0,
        10,
        10,
        47,
        15,
        406,
        7,
        2,
        7,
        17,
        9,
        57,
        21,
        2,
        13,
        123,
        5,
        4,
        0,
        2,
        1,
        2,
        6,
        2,
        0,
        9,
        9,
        49,
        4,
        2,
        1,
        2,
        4,
        9,
        9,
        330,
        3,
        10,
        1,
        2,
        0,
        49,
        6,
        4,
        4,
        14,
        9,
        5351,
        0,
        7,
        14,
        13835,
        9,
        87,
        9,
        39,
        4,
        60,
        6,
        26,
        9,
        1014,
        0,
        2,
        54,
        8,
        3,
        82,
        0,
        12,
        1,
        19628,
        1,
        4706,
        45,
        3,
        22,
        543,
        4,
        4,
        5,
        9,
        7,
        3,
        6,
        31,
        3,
        149,
        2,
        1418,
        49,
        513,
        54,
        5,
        49,
        9,
        0,
        15,
        0,
        23,
        4,
        2,
        14,
        1361,
        6,
        2,
        16,
        3,
        6,
        2,
        1,
        2,
        4,
        101,
        0,
        161,
        6,
        10,
        9,
        357,
        0,
        62,
        13,
        499,
        13,
        983,
        6,
        110,
        6,
        6,
        9,
        4759,
        9,
        787719,
        239
      ];
      var astralIdentifierStartCodes = [
        0,
        11,
        2,
        25,
        2,
        18,
        2,
        1,
        2,
        14,
        3,
        13,
        35,
        122,
        70,
        52,
        268,
        28,
        4,
        48,
        48,
        31,
        14,
        29,
        6,
        37,
        11,
        29,
        3,
        35,
        5,
        7,
        2,
        4,
        43,
        157,
        19,
        35,
        5,
        35,
        5,
        39,
        9,
        51,
        13,
        10,
        2,
        14,
        2,
        6,
        2,
        1,
        2,
        10,
        2,
        14,
        2,
        6,
        2,
        1,
        68,
        310,
        10,
        21,
        11,
        7,
        25,
        5,
        2,
        41,
        2,
        8,
        70,
        5,
        3,
        0,
        2,
        43,
        2,
        1,
        4,
        0,
        3,
        22,
        11,
        22,
        10,
        30,
        66,
        18,
        2,
        1,
        11,
        21,
        11,
        25,
        71,
        55,
        7,
        1,
        65,
        0,
        16,
        3,
        2,
        2,
        2,
        28,
        43,
        28,
        4,
        28,
        36,
        7,
        2,
        27,
        28,
        53,
        11,
        21,
        11,
        18,
        14,
        17,
        111,
        72,
        56,
        50,
        14,
        50,
        14,
        35,
        349,
        41,
        7,
        1,
        79,
        28,
        11,
        0,
        9,
        21,
        43,
        17,
        47,
        20,
        28,
        22,
        13,
        52,
        58,
        1,
        3,
        0,
        14,
        44,
        33,
        24,
        27,
        35,
        30,
        0,
        3,
        0,
        9,
        34,
        4,
        0,
        13,
        47,
        15,
        3,
        22,
        0,
        2,
        0,
        36,
        17,
        2,
        24,
        20,
        1,
        64,
        6,
        2,
        0,
        2,
        3,
        2,
        14,
        2,
        9,
        8,
        46,
        39,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        4,
        0,
        19,
        0,
        13,
        4,
        159,
        52,
        19,
        3,
        21,
        2,
        31,
        47,
        21,
        1,
        2,
        0,
        185,
        46,
        42,
        3,
        37,
        47,
        21,
        0,
        60,
        42,
        14,
        0,
        72,
        26,
        38,
        6,
        186,
        43,
        117,
        63,
        32,
        7,
        3,
        0,
        3,
        7,
        2,
        1,
        2,
        23,
        16,
        0,
        2,
        0,
        95,
        7,
        3,
        38,
        17,
        0,
        2,
        0,
        29,
        0,
        11,
        39,
        8,
        0,
        22,
        0,
        12,
        45,
        20,
        0,
        19,
        72,
        264,
        8,
        2,
        36,
        18,
        0,
        50,
        29,
        113,
        6,
        2,
        1,
        2,
        37,
        22,
        0,
        26,
        5,
        2,
        1,
        2,
        31,
        15,
        0,
        328,
        18,
        16,
        0,
        2,
        12,
        2,
        33,
        125,
        0,
        80,
        921,
        103,
        110,
        18,
        195,
        2637,
        96,
        16,
        1071,
        18,
        5,
        4026,
        582,
        8634,
        568,
        8,
        30,
        18,
        78,
        18,
        29,
        19,
        47,
        17,
        3,
        32,
        20,
        6,
        18,
        689,
        63,
        129,
        74,
        6,
        0,
        67,
        12,
        65,
        1,
        2,
        0,
        29,
        6135,
        9,
        1237,
        43,
        8,
        8936,
        3,
        2,
        6,
        2,
        1,
        2,
        290,
        16,
        0,
        30,
        2,
        3,
        0,
        15,
        3,
        9,
        395,
        2309,
        106,
        6,
        12,
        4,
        8,
        8,
        9,
        5991,
        84,
        2,
        70,
        2,
        1,
        3,
        0,
        3,
        1,
        3,
        3,
        2,
        11,
        2,
        0,
        2,
        6,
        2,
        64,
        2,
        3,
        3,
        7,
        2,
        6,
        2,
        27,
        2,
        3,
        2,
        4,
        2,
        0,
        4,
        6,
        2,
        339,
        3,
        24,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        7,
        1845,
        30,
        7,
        5,
        262,
        61,
        147,
        44,
        11,
        6,
        17,
        0,
        322,
        29,
        19,
        43,
        485,
        27,
        757,
        6,
        2,
        3,
        2,
        1,
        2,
        14,
        2,
        196,
        60,
        67,
        8,
        0,
        1205,
        3,
        2,
        26,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        9,
        2,
        3,
        2,
        0,
        2,
        0,
        7,
        0,
        5,
        0,
        2,
        0,
        2,
        0,
        2,
        2,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        1,
        2,
        0,
        3,
        3,
        2,
        6,
        2,
        3,
        2,
        3,
        2,
        0,
        2,
        9,
        2,
        16,
        6,
        2,
        2,
        4,
        2,
        16,
        4421,
        42719,
        33,
        4153,
        7,
        221,
        3,
        5761,
        15,
        7472,
        16,
        621,
        2467,
        541,
        1507,
        4938,
        6,
        4191
      ];
      var nonASCIIidentifierChars = "\xB7-\u0387------------\u07FD-----\u0898-\u089F\u08CA----------\u09FE---------\u0AFA-\u0AFF---\u0B55-------\u0C04\u0C3C---------\u0CF3\u0D00-\u0D3B\u0D3C----\u0D81---------\u0ECE---------------\u1369-\u1371-\u1715----\u180F-----\u19DA------\u1ABF-\u1ACE-------------\u1CF7-------\u30FB---\uA82C---\uA8FF------------------\uFF65";
      var nonASCIIidentifierStartChars = "-------------\u0560-\u0588-\u05EF---------\u0860-\u086A\u0870-\u0887\u0889-\u088E-\u08C9--------\u09FC-------------------------\u0C5D-----\u0CDD\u0D04------------\u0E86-\u0E8C-------------------------------------\u171F------\u1878-----------\u1B4C------\u1C90-\u1CBA\u1CBD-\u1CBF--\u1CFA------------------\u2118-----------------------\u309B----\u312F--\u31BF--\u4DBF----------\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-------\uA8FE-----------------------\uAB69-------------------------";
      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$1 = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };
      var keywordRelationalOperator = /^in(stanceof)?$/;
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      function isInAstralSet(code, set) {
        var pos = 65536;
        for (var i = 0; i < set.length; i += 2) {
          pos += set[i];
          if (pos > code) {
            return false;
          }
          pos += set[i + 1];
          if (pos >= code) {
            return true;
          }
        }
        return false;
      }
      function isIdentifierStart(code, astral) {
        if (code < 65) {
          return code === 36;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code, astral) {
        if (code < 48) {
          return code === 36;
        }
        if (code < 58) {
          return true;
        }
        if (code < 65) {
          return false;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var TokenType = function TokenType(label, conf) {
        if (conf === void 0)
          conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop(name, prec) {
        return new TokenType(name, {
          beforeExpr: true,
          binop: prec
        });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
      var keywords = {};
      function kw(name, options) {
        if (options === void 0)
          options = {};
        options.keyword = name;
        return keywords[name] = new TokenType(name, options);
      }
      var types$1 = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        bracketL: new TokenType("[", {
          beforeExpr: true,
          startsExpr: true
        }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", {
          beforeExpr: true,
          startsExpr: true
        }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", {
          beforeExpr: true,
          startsExpr: true
        }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", {
          beforeExpr: true,
          startsExpr: true
        }),
        eq: new TokenType("=", {
          beforeExpr: true,
          isAssign: true
        }),
        assign: new TokenType("_=", {
          beforeExpr: true,
          isAssign: true
        }),
        incDec: new TokenType("++/--", {
          prefix: true,
          postfix: true,
          startsExpr: true
        }),
        prefix: new TokenType("!/~", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", {
          beforeExpr: true,
          binop: 9,
          prefix: true,
          startsExpr: true
        }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", {
          isLoop: true,
          beforeExpr: true
        }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", {
          beforeExpr: true,
          startsExpr: true
        }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", {
          beforeExpr: true,
          binop: 7
        }),
        _instanceof: kw("instanceof", {
          beforeExpr: true,
          binop: 7
        }),
        _typeof: kw("typeof", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        _void: kw("void", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        _delete: kw("delete", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        })
      };
      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        return code === 10 || code === 13 || code === 8232 || code === 8233;
      }
      function nextLineBreak(code, from, end) {
        if (end === void 0)
          end = code.length;
        for (var i = from; i < end; i++) {
          var next = code.charCodeAt(i);
          if (isNewLine(next)) {
            return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
          }
        }
        return -1;
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref = Object.prototype;
      var hasOwnProperty = ref.hasOwnProperty;
      var toString = ref.toString;
      var hasOwn = Object.hasOwn || function (obj, propName) {
        return hasOwnProperty.call(obj, propName);
      };
      var isArray = Array.isArray || function (obj) {
        return toString.call(obj) === "[object Array]";
      };
      var regexpCache = Object.create(null);
      function wordsRegexp(words) {
        return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
      }
      function codePointToString(code) {
        if (code <= 65535) {
          return String.fromCharCode(code);
        }
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
      var Position = function Position(line, col) {
        this.line = line;
        this.column = col;
      };
      Position.prototype.offset = function offset(n) {
        return new Position(this.line, this.column + n);
      };
      var SourceLocation = function SourceLocation(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0;;) {
          var nextBreak = nextLineBreak(input, cur, offset);
          if (nextBreak < 0) {
            return new Position(line, offset - cur);
          }
          ++line;
          cur = nextBreak;
        }
      }
      var defaultOptions = {
        ecmaVersion: null,
        sourceType: "script",
        onInsertedSemicolon: null,
        onTrailingComma: null,
        allowReserved: null,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowAwaitOutsideFunction: null,
        allowSuperOutsideMethod: null,
        allowHashBang: false,
        checkPrivateFields: true,
        locations: false,
        onToken: null,
        onComment: null,
        ranges: false,
        program: null,
        sourceFile: null,
        directSourceFile: null,
        preserveParens: false
      };
      var warnedAboutEcmaVersion = false;
      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions) {
          options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 100000000;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
          options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function (token) {
            return tokens.push(token);
          };
        }
        if (isArray(options.onComment)) {
          options.onComment = pushComment(options, options.onComment);
        }
        return options;
      }
      function pushComment(options, array) {
        return function (block, text, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start: start,
            end: end
          };
          if (options.locations) {
            comment.loc = new SourceLocation(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [
              start,
              end
            ];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
      var Parser = function Parser(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$1.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors = {
        inFunction: { configurable: true },
        inGenerator: { configurable: true },
        inAsync: { configurable: true },
        canAwait: { configurable: true },
        allowSuper: { configurable: true },
        allowDirectSuper: { configurable: true },
        treatFunctionsAsVar: { configurable: true },
        allowNewDotTarget: { configurable: true },
        inClassStaticBlock: { configurable: true }
      };
      Parser.prototype.parse = function parse() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
      prototypeAccessors.inFunction.get = function () {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      };
      prototypeAccessors.inGenerator.get = function () {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.inAsync.get = function () {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.canAwait.get = function () {
        for (var i = this.scopeStack.length - 1; i >= 0; i--) {
          var scope = this.scopeStack[i];
          if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
            return false;
          }
          if (scope.flags & SCOPE_FUNCTION) {
            return (scope.flags & SCOPE_ASYNC) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors.allowSuper.get = function () {
        var ref = this.currentThisScope();
        var flags = ref.flags;
        var inClassFieldInit = ref.inClassFieldInit;
        return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors.allowDirectSuper.get = function () {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      };
      prototypeAccessors.treatFunctionsAsVar.get = function () {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors.allowNewDotTarget.get = function () {
        var ref = this.currentThisScope();
        var flags = ref.flags;
        var inClassFieldInit = ref.inClassFieldInit;
        return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
      };
      prototypeAccessors.inClassStaticBlock.get = function () {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
      };
      Parser.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--)
          plugins[len] = arguments[len];
        var cls = this;
        for (var i = 0; i < plugins.length; i++) {
          cls = plugins[i](cls);
        }
        return cls;
      };
      Parser.parse = function parse(input, options) {
        return new this(options, input).parse();
      };
      Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser.tokenizer = function tokenizer(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser.prototype, prototypeAccessors);
      var pp$9 = Parser.prototype;
      var literal$1 = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
      pp$9.strictDirective = function (start) {
        if (this.options.ecmaVersion < 5) {
          return false;
        }
        for (;;) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal$1.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp$9.eat = function (type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$9.isContextual = function (name) {
        return this.type === types$1.name && this.value === name && !this.containsEsc;
      };
      pp$9.eatContextual = function (name) {
        if (!this.isContextual(name)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$9.expectContextual = function (name) {
        if (!this.eatContextual(name)) {
          this.unexpected();
        }
      };
      pp$9.canInsertSemicolon = function () {
        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$9.insertSemicolon = function () {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$9.semicolon = function () {
        if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$9.afterTrailingComma = function (tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$9.expect = function (type) {
        this.eat(type) || this.unexpected();
      };
      pp$9.unexpected = function (pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      var DestructuringErrors = function DestructuringErrors() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      pp$9.checkPatternErrors = function (refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      };
      pp$9.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$9.checkYieldAwaitInDefaultParams = function () {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$9.isSimpleAssignTarget = function (expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$8 = Parser.prototype;
      pp$8.parseTopLevel = function (node) {
        var exports = Object.create(null);
        if (!node.body) {
          node.body = [];
        }
        while (this.type !== types$1.eof) {
          var stmt = this.parseStatement(null, true, exports);
          node.body.push(stmt);
        }
        if (this.inModule) {
          for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
            var name = list[i];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$8.isLet = function (context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (isIdentifierStart(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$8.isAsyncFunction = function () {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$8.parseStatement = function (context, topLevel, exports) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$1._var;
          kind = "let";
        }
        switch (starttype) {
        case types$1._break:
        case types$1._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);
        case types$1._debugger:
          return this.parseDebuggerStatement(node);
        case types$1._do:
          return this.parseDoStatement(node);
        case types$1._for:
          return this.parseForStatement(node);
        case types$1._function:
          if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
            this.unexpected();
          }
          return this.parseFunctionStatement(node, false, !context);
        case types$1._class:
          if (context) {
            this.unexpected();
          }
          return this.parseClass(node, true);
        case types$1._if:
          return this.parseIfStatement(node);
        case types$1._return:
          return this.parseReturnStatement(node);
        case types$1._switch:
          return this.parseSwitchStatement(node);
        case types$1._throw:
          return this.parseThrowStatement(node);
        case types$1._try:
          return this.parseTryStatement(node);
        case types$1._const:
        case types$1._var:
          kind = kind || this.value;
          if (context && kind !== "var") {
            this.unexpected();
          }
          return this.parseVarStatement(node, kind);
        case types$1._while:
          return this.parseWhileStatement(node);
        case types$1._with:
          return this.parseWithStatement(node);
        case types$1.braceL:
          return this.parseBlock(true, node);
        case types$1.semi:
          return this.parseEmptyStatement(node);
        case types$1._export:
        case types$1._import:
          if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
            skipWhiteSpace.lastIndex = this.pos;
            var skip = skipWhiteSpace.exec(this.input);
            var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
            if (nextCh === 40 || nextCh === 46) {
              return this.parseExpressionStatement(node, this.parseExpression());
            }
          }
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) {
              this.raise(this.start, "'import' and 'export' may only appear at the top level");
            }
            if (!this.inModule) {
              this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
          }
          return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);
        default:
          if (this.isAsyncFunction()) {
            if (context) {
              this.unexpected();
            }
            this.next();
            return this.parseFunctionStatement(node, true, !context);
          }
          var maybeName = this.value, expr = this.parseExpression();
          if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
            return this.parseLabeledStatement(node, maybeName, expr, context);
          } else {
            return this.parseExpressionStatement(node, expr);
          }
        }
      };
      pp$8.parseBreakContinueStatement = function (node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.label = null;
        } else if (this.type !== types$1.name) {
          this.unexpected();
        } else {
          node.label = this.parseIdent();
          this.semicolon();
        }
        var i = 0;
        for (; i < this.labels.length; ++i) {
          var lab = this.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node.label && isBreak) {
              break;
            }
          }
        }
        if (i === this.labels.length) {
          this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$8.parseDebuggerStatement = function (node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };
      pp$8.parseDoStatement = function (node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$1._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$1.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
      };
      pp$8.parseForStatement = function (node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types$1.parenL);
        if (this.type === types$1.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types$1._var || this.type === types$1._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types$1._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node.await = awaitAt > -1;
              }
            }
            return this.parseForIn(node, init$1);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init$1);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var refDestructuringErrors = new DestructuringErrors();
        var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLValPattern(init);
          return this.parseForIn(node, init);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      };
      pp$8.parseFunctionStatement = function (node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      };
      pp$8.parseIfStatement = function (node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };
      pp$8.parseReturnStatement = function (node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };
      pp$8.parseSwitchStatement = function (node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types$1.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types$1.braceR;) {
          if (this.type === types$1._case || this.type === types$1._default) {
            var isCase = this.type === types$1._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$1.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };
      pp$8.parseThrowStatement = function (node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };
      var empty$1 = [];
      pp$8.parseCatchClauseParam = function () {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types$1.parenR);
        return param;
      };
      pp$8.parseTryStatement = function (node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types$1._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$1.parenL)) {
            clause.param = this.parseCatchClauseParam();
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
      };
      pp$8.parseVarStatement = function (node, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };
      pp$8.parseWhileStatement = function (node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };
      pp$8.parseWithStatement = function (node) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
      };
      pp$8.parseEmptyStatement = function (node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };
      pp$8.parseLabeledStatement = function (node, maybeName, expr, context) {
        for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
          var label = list[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
        for (var i = this.labels.length - 1; i >= 0; i--) {
          var label$1 = this.labels[i];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({
          name: maybeName,
          kind: kind,
          statementStart: this.start
        });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };
      pp$8.parseExpressionStatement = function (node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };
      pp$8.parseBlock = function (createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0)
          createNewLexicalScope = true;
        if (node === void 0)
          node = this.startNode();
        node.body = [];
        this.expect(types$1.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
      };
      pp$8.parseFor = function (node, init) {
        node.init = init;
        this.expect(types$1.semi);
        node.test = this.type === types$1.semi ? null : this.parseExpression();
        this.expect(types$1.semi);
        node.update = this.type === types$1.parenR ? null : this.parseExpression();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };
      pp$8.parseForIn = function (node, init) {
        var isForIn = this.type === types$1._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$8.parseVar = function (node, isFor, kind, allowMissingInitializer) {
        node.declarations = [];
        node.kind = kind;
        for (;;) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$1.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$1.comma)) {
            break;
          }
        }
        return node;
      };
      pp$8.parseVarId = function (decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$8.parseFunction = function (node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node.generator = this.eat(types$1.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node.id = this.type === types$1.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$8.parseFunctionParams = function (node) {
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$8.parseClass = function (node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$1.braceL);
        while (this.type !== types$1.braceR) {
          var element = this.parseClassElement(node.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) {
                this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
              this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$8.parseClassElement = function (constructorAllowsSuper) {
        if (this.eat(types$1.semi)) {
          return null;
        }
        var ecmaVersion = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
            this.parseClassStaticBlock(node);
            return node;
          }
          if (this.isClassElementNameStart() || this.type === types$1.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node.computed = false;
          node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node.key.name = keyName;
          this.finishNode(node.key, "Identifier");
        } else {
          this.parseClassElementName(node);
        }
        if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node.static && checkKeyName(node, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node.key.start, "Constructor can't have get/set modifier");
          }
          node.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node);
        }
        return node;
      };
      pp$8.isClassElementNameStart = function () {
        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
      };
      pp$8.parseClassElementName = function (element) {
        if (this.type === types$1.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element.computed = false;
          element.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element);
        }
      };
      pp$8.parseClassMethod = function (method, isGenerator, isAsync, allowsDirectSuper) {
        var key = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName(method, "prototype")) {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value.params.length !== 0) {
          this.raiseRecoverable(value.start, "getter should have no params");
        }
        if (method.kind === "set" && value.params.length !== 1) {
          this.raiseRecoverable(value.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value.params[0].type === "RestElement") {
          this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$8.parseClassField = function (field) {
        if (checkKeyName(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$1.eq)) {
          var scope = this.currentThisScope();
          var inClassFieldInit = scope.inClassFieldInit;
          scope.inClassFieldInit = true;
          field.value = this.parseMaybeAssign();
          scope.inClassFieldInit = inClassFieldInit;
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$8.parseClassStaticBlock = function (node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
      };
      pp$8.parseClassId = function (node, isStatement) {
        if (this.type === types$1.name) {
          node.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node.id, BIND_LEXICAL, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node.id = null;
        }
      };
      pp$8.parseClassSuper = function (node) {
        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
      };
      pp$8.enterClassBody = function () {
        var element = {
          declared: Object.create(null),
          used: []
        };
        this.privateNameStack.push(element);
        return element.declared;
      };
      pp$8.exitClassBody = function () {
        var ref = this.privateNameStack.pop();
        var declared = ref.declared;
        var used = ref.used;
        if (!this.options.checkPrivateFields) {
          return;
        }
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i = 0; i < used.length; ++i) {
          var id = used[i];
          if (!hasOwn(declared, id.name)) {
            if (parent) {
              parent.used.push(id);
            } else {
              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted(privateNameMap, element) {
        var name = element.key.name;
        var curr = privateNameMap[name];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
          next = (element.static ? "s" : "i") + element.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName(node, name) {
        var computed = node.computed;
        var key = node.key;
        return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
      }
      pp$8.parseExportAllDeclaration = function (node, exports) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports, node.exported, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      };
      pp$8.parseExport = function (node, exports) {
        this.next();
        if (this.eat(types$1.star)) {
          return this.parseExportAllDeclaration(node, exports);
        }
        if (this.eat(types$1._default)) {
          this.checkExport(exports, "default", this.lastTokStart);
          node.declaration = this.parseExportDefaultDeclaration();
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseExportDeclaration(node);
          if (node.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports, node.declaration.declarations);
          } else {
            this.checkExport(exports, node.declaration.id, node.declaration.id.start);
          }
          node.specifiers = [];
          node.source = null;
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports);
          if (this.eatContextual("from")) {
            if (this.type !== types$1.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
          } else {
            for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
              var spec = list[i];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
              if (spec.local.type === "Literal") {
                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
            }
            node.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      pp$8.parseExportDeclaration = function (node) {
        return this.parseStatement(null);
      };
      pp$8.parseExportDefaultDeclaration = function () {
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
          var cNode = this.startNode();
          return this.parseClass(cNode, "nullableID");
        } else {
          var declaration = this.parseMaybeAssign();
          this.semicolon();
          return declaration;
        }
      };
      pp$8.checkExport = function (exports, name, pos) {
        if (!exports) {
          return;
        }
        if (typeof name !== "string") {
          name = name.type === "Identifier" ? name.name : name.value;
        }
        if (hasOwn(exports, name)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
        }
        exports[name] = true;
      };
      pp$8.checkPatternExport = function (exports, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports, pat, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i = 0, list = pat.properties; i < list.length; i += 1) {
            var prop = list[i];
            this.checkPatternExport(exports, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports, pat.argument);
        }
      };
      pp$8.checkVariableExport = function (exports, decls) {
        if (!exports) {
          return;
        }
        for (var i = 0, list = decls; i < list.length; i += 1) {
          var decl = list[i];
          this.checkPatternExport(exports, decl.id);
        }
      };
      pp$8.shouldParseExportStatement = function () {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$8.parseExportSpecifier = function (exports) {
        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
        this.checkExport(exports, node.exported, node.exported.start);
        return this.finishNode(node, "ExportSpecifier");
      };
      pp$8.parseExportSpecifiers = function (exports) {
        var nodes = [], first = true;
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseExportSpecifier(exports));
        }
        return nodes;
      };
      pp$8.parseImport = function (node) {
        this.next();
        if (this.type === types$1.string) {
          node.specifiers = empty$1;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      pp$8.parseImportSpecifier = function () {
        var node = this.startNode();
        node.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node.local = this.parseIdent();
        } else {
          this.checkUnreserved(node.imported);
          node.local = node.imported;
        }
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportSpecifier");
      };
      pp$8.parseImportDefaultSpecifier = function () {
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportDefaultSpecifier");
      };
      pp$8.parseImportNamespaceSpecifier = function () {
        var node = this.startNode();
        this.next();
        this.expectContextual("as");
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportNamespaceSpecifier");
      };
      pp$8.parseImportSpecifiers = function () {
        var nodes = [], first = true;
        if (this.type === types$1.name) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(types$1.comma)) {
            return nodes;
          }
        }
        if (this.type === types$1.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      };
      pp$8.parseModuleExportName = function () {
        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
          var stringLiteral = this.parseLiteral(this.value);
          if (loneSurrogate.test(stringLiteral.value)) {
            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
          }
          return stringLiteral;
        }
        return this.parseIdent(true);
      };
      pp$8.adaptDirectivePrologue = function (statements) {
        for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
          statements[i].directive = statements[i].expression.raw.slice(1, -1);
        }
      };
      pp$8.isDirectiveCandidate = function (statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === "\"" || this.input[statement.start] === "'");
      };
      var pp$7 = Parser.prototype;
      pp$7.toAssignable = function (node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
          case "Identifier":
            if (this.inAsync && node.name === "await") {
              this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
            }
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            for (var i = 0, list = node.properties; i < list.length; i += 1) {
              var prop = list[i];
              this.toAssignable(prop, isBinding);
              if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                this.raise(prop.argument.start, "Unexpected token");
              }
            }
            break;
          case "Property":
            if (node.kind !== "init") {
              this.raise(node.key.start, "Object pattern can't contain getter or setter");
            }
            this.toAssignable(node.value, isBinding);
            break;
          case "ArrayExpression":
            node.type = "ArrayPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            this.toAssignableList(node.elements, isBinding);
            break;
          case "SpreadElement":
            node.type = "RestElement";
            this.toAssignable(node.argument, isBinding);
            if (node.argument.type === "AssignmentPattern") {
              this.raise(node.argument.start, "Rest elements cannot have a default value");
            }
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isBinding);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isBinding, refDestructuringErrors);
            break;
          case "ChainExpression":
            this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!isBinding) {
              break;
            }
          default:
            this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
      };
      pp$7.toAssignableList = function (exprList, isBinding) {
        var end = exprList.length;
        for (var i = 0; i < end; i++) {
          var elt = exprList[i];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$7.parseSpread = function (refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
      };
      pp$7.parseRestBinding = function () {
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
          this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };
      pp$7.parseBindingAtom = function () {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
          case types$1.bracketL:
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types$1.bracketR, true, true);
            return this.finishNode(node, "ArrayPattern");
          case types$1.braceL:
            return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$7.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
          }
          if (allowEmpty && this.type === types$1.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types$1.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            elts.push(this.parseAssignableListItem(allowModifiers));
          }
        }
        return elts;
      };
      pp$7.parseAssignableListItem = function (allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
      };
      pp$7.parseBindingListItem = function (param) {
        return param;
      };
      pp$7.parseMaybeDefault = function (startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
          return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };
      pp$7.checkLValSimple = function (expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch (expr.type) {
        case "Identifier":
          if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
            this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          }
          if (isBind) {
            if (bindingType === BIND_LEXICAL && expr.name === "let") {
              this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
            }
            if (checkClashes) {
              if (hasOwn(checkClashes, expr.name)) {
                this.raiseRecoverable(expr.start, "Argument name clash");
              }
              checkClashes[expr.name] = true;
            }
            if (bindingType !== BIND_OUTSIDE) {
              this.declareName(expr.name, bindingType, expr.start);
            }
          }
          break;
        case "ChainExpression":
          this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding member expression");
          }
          break;
        case "ParenthesizedExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding parenthesized expression");
          }
          return this.checkLValSimple(expr.expression, bindingType, checkClashes);
        default:
          this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$7.checkLValPattern = function (expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
        case "ObjectPattern":
          for (var i = 0, list = expr.properties; i < list.length; i += 1) {
            var prop = list[i];
            this.checkLValInnerPattern(prop, bindingType, checkClashes);
          }
          break;
        case "ArrayPattern":
          for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
            var elem = list$1[i$1];
            if (elem) {
              this.checkLValInnerPattern(elem, bindingType, checkClashes);
            }
          }
          break;
        default:
          this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$7.checkLValInnerPattern = function (expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
        case "Property":
          this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
          break;
        case "AssignmentPattern":
          this.checkLValPattern(expr.left, bindingType, checkClashes);
          break;
        case "RestElement":
          this.checkLValPattern(expr.argument, bindingType, checkClashes);
          break;
        default:
          this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function (p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };
      var pp$6 = Parser.prototype;
      pp$6.initialContext = function () {
        return [types.b_stat];
      };
      pp$6.curContext = function () {
        return this.context[this.context.length - 1];
      };
      pp$6.braceIsBlock = function (prevType) {
        var parent = this.curContext();
        if (parent === types.f_expr || parent === types.f_stat) {
          return true;
        }
        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
          return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
          return true;
        }
        if (prevType === types$1.braceL) {
          return parent === types.b_stat;
        }
        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$6.inGeneratorContext = function () {
        for (var i = this.context.length - 1; i >= 1; i--) {
          var context = this.context[i];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$6.updateContext = function (prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types$1.dot) {
          this.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      pp$6.overrideContext = function (tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types$1.parenR.updateContext = types$1.braceR.updateContext = function () {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$1.braceL.updateContext = function (prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
        this.exprAllowed = true;
      };
      types$1.dollarBraceL.updateContext = function () {
        this.context.push(types.b_tmpl);
        this.exprAllowed = true;
      };
      types$1.parenL.updateContext = function (prevType) {
        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
        this.context.push(statementParens ? types.p_stat : types.p_expr);
        this.exprAllowed = true;
      };
      types$1.incDec.updateContext = function () {
      };
      types$1._function.updateContext = types$1._class.updateContext = function (prevType) {
        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
          this.context.push(types.f_expr);
        } else {
          this.context.push(types.f_stat);
        }
        this.exprAllowed = false;
      };
      types$1.colon.updateContext = function () {
        if (this.curContext().token === "function") {
          this.context.pop();
        }
        this.exprAllowed = true;
      };
      types$1.backQuote.updateContext = function () {
        if (this.curContext() === types.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$1.star.updateContext = function (prevType) {
        if (prevType === types$1._function) {
          var index = this.context.length - 1;
          if (this.context[index] === types.f_expr) {
            this.context[index] = types.f_expr_gen;
          } else {
            this.context[index] = types.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$1.name.updateContext = function (prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$5 = Parser.prototype;
      pp$5.checkPropClash = function (prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key = prop.key;
        var name;
        switch (key.type) {
        case "Identifier":
          name = key.name;
          break;
        case "Literal":
          name = String(key.value);
          break;
        default:
          return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$5.parseExpression = function (forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$1.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types$1.comma)) {
            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      pp$5.parseMaybeAssign = function (forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$1.parenL || this.type === types$1.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === types$1.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$1.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) {
            refDestructuringErrors.doubleProto = oldDoubleProto;
          }
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$5.parseMaybeConditional = function (forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$1.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types$1.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      pp$5.parseExprOps = function (forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$5.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$1._in)) {
          if (prec > minPrec) {
            var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
            var coalesce = this.type === types$1.coalesce;
            if (coalesce) {
              prec = types$1.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$5.buildBinary = function (startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
          this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$5.parseMaybeUnary = function (refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update = this.type === types$1.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true, update, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node.argument);
          } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
          } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$1.privateId) {
          if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
            this.unexpected();
          }
          expr = this.parsePrivateIdent();
          if (this.type !== types$1._in) {
            this.unexpected();
          }
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types$1.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isPrivateFieldAccess(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
      }
      pp$5.parseExprSubscripts = function (refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$5.parseSubscripts = function (base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while (true) {
          var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element.optional) {
            optionalChained = true;
          }
          if (element === base || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element;
              element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base = element;
        }
      };
      pp$5.shouldParseAsyncArrow = function () {
        return !this.canInsertSemicolon() && this.eat(types$1.arrow);
      };
      pp$5.parseSubscriptAsyncArrow = function (startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
      };
      pp$5.parseSubscript = function (base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$1.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$1.bracketL);
        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(types$1.bracketR);
          } else if (this.type === types$1.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types$1.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$1.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
      };
      pp$5.parseExprAtom = function (refDestructuringErrors, forInit, forNew) {
        if (this.type === types$1.slash) {
          this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
        case types$1._super:
          if (!this.allowSuper) {
            this.raise(this.start, "'super' keyword outside a method");
          }
          node = this.startNode();
          this.next();
          if (this.type === types$1.parenL && !this.allowDirectSuper) {
            this.raise(node.start, "super() call outside constructor of a subclass");
          }
          if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
            this.unexpected();
          }
          return this.finishNode(node, "Super");
        case types$1._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");
        case types$1.name:
          var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          var id = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
            this.overrideContext(types.f_expr);
            return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(types$1.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
            }
            if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
              id = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                this.unexpected();
              }
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
            }
          }
          return id;
        case types$1.regexp:
          var value = this.value;
          node = this.parseLiteral(value.value);
          node.regex = {
            pattern: value.pattern,
            flags: value.flags
          };
          return node;
        case types$1.num:
        case types$1.string:
          return this.parseLiteral(this.value);
        case types$1._null:
        case types$1._true:
        case types$1._false:
          node = this.startNode();
          node.value = this.type === types$1._null ? null : this.type === types$1._true;
          node.raw = this.type.keyword;
          this.next();
          return this.finishNode(node, "Literal");
        case types$1.parenL:
          var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
          if (refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
              refDestructuringErrors.parenthesizedAssign = start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = start;
            }
          }
          return expr;
        case types$1.bracketL:
          node = this.startNode();
          this.next();
          node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
          return this.finishNode(node, "ArrayExpression");
        case types$1.braceL:
          this.overrideContext(types.b_expr);
          return this.parseObj(false, refDestructuringErrors);
        case types$1._function:
          node = this.startNode();
          this.next();
          return this.parseFunction(node, 0);
        case types$1._class:
          return this.parseClass(this.startNode(), false);
        case types$1._new:
          return this.parseNew();
        case types$1.backQuote:
          return this.parseTemplate();
        case types$1._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport(forNew);
          } else {
            return this.unexpected();
          }
        default:
          return this.parseExprAtomDefault();
        }
      };
      pp$5.parseExprAtomDefault = function () {
        this.unexpected();
      };
      pp$5.parseExprImport = function (forNew) {
        var node = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        var meta = this.parseIdent(true);
        if (this.type === types$1.parenL && !forNew) {
          return this.parseDynamicImport(node);
        } else if (this.type === types$1.dot) {
          node.meta = meta;
          return this.parseImportMeta(node);
        } else {
          this.unexpected();
        }
      };
      pp$5.parseDynamicImport = function (node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          var errorPos = this.start;
          if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node, "ImportExpression");
      };
      pp$5.parseImportMeta = function (node) {
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
      };
      pp$5.parseLiteral = function (value) {
        var node = this.startNode();
        node.value = value;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      };
      pp$5.parseParenExpression = function () {
        this.expect(types$1.parenL);
        var val = this.parseExpression();
        this.expect(types$1.parenR);
        return val;
      };
      pp$5.shouldParseArrow = function (exprList) {
        return !this.canInsertSemicolon();
      };
      pp$5.parseParenAndDistinguishExpression = function (canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$1.parenR) {
            first ? first = false : this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$1.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$1.comma) {
                this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types$1.parenR);
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$5.parseParenItem = function (item) {
        return item;
      };
      pp$5.parseParenArrowList = function (startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
      };
      var empty$2 = [];
      pp$5.parseNew = function () {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
          var meta = this.startNodeAt(node.start, node.startLoc);
          meta.name = "new";
          node.meta = this.finishNode(meta, "Identifier");
          this.next();
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$1.parenL)) {
          node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = empty$2;
        }
        return this.finishNode(node, "NewExpression");
      };
      pp$5.parseTemplateElement = function (ref) {
        var isTagged = ref.isTagged;
        var elem = this.startNode();
        if (this.type === types$1.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value,
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$1.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$5.parseTemplate = function (ref) {
        if (ref === void 0)
          ref = {};
        var isTagged = ref.isTagged;
        if (isTagged === void 0)
          isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged: isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$1.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$1.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types$1.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged: isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };
      pp$5.isAsyncProp = function (prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$5.parseObj = function (isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$5.parseProperty = function (isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$1.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
          this.parsePropertyName(prop);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$5.parseGetterSetter = function (prop) {
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      };
      pp$5.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$1.colon) {
          this.unexpected();
        }
        if (this.eat(types$1.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.kind = "init";
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.parseGetterSetter(prop);
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          prop.kind = "init";
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types$1.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$5.parsePropertyName = function (prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$1.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types$1.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$5.initFunction = function (node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      pp$5.parseMethod = function (isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
      };
      pp$5.parseArrowExpression = function (node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      pp$5.parseFunctionBody = function (node, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$1.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node.body = this.parseMaybeAssign(forInit);
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          if (this.strict && node.id) {
            this.checkLValSimple(node.id, BIND_OUTSIDE);
          }
          node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$5.isSimpleParamList = function (params) {
        for (var i = 0, list = params; i < list.length; i += 1) {
          var param = list[i];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$5.checkParams = function (node, allowDuplicates) {
        var nameHash = Object.create(null);
        for (var i = 0, list = node.params; i < list.length; i += 1) {
          var param = list[i];
          this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };
      pp$5.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$1.comma) {
            elt = null;
          } else if (this.type === types$1.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$5.checkUnreserved = function (ref) {
        var start = ref.start;
        var end = ref.end;
        var name = ref.name;
        if (this.inGenerator && name === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (this.currentThisScope().inClassFieldInit && name === "arguments") {
          this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
          this.raise(start, "Cannot use " + name + " in class static initialization block");
        }
        if (this.keywords.test(name)) {
          this.raise(start, "Unexpected keyword '" + name + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
          if (!this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
      };
      pp$5.parseIdent = function (liberal) {
        var node = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node.start;
          }
        }
        return node;
      };
      pp$5.parseIdentNode = function () {
        var node = this.startNode();
        if (this.type === types$1.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;
          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
          this.type = types$1.name;
        } else {
          this.unexpected();
        }
        return node;
      };
      pp$5.parsePrivateIdent = function () {
        var node = this.startNode();
        if (this.type === types$1.privateId) {
          node.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        if (this.options.checkPrivateFields) {
          if (this.privateNameStack.length === 0) {
            this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
          } else {
            this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
          }
        }
        return node;
      };
      pp$5.parseYield = function (forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types$1.star);
          node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
      };
      pp$5.parseAwait = function (forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
      };
      var pp$4 = Parser.prototype;
      pp$4.raise = function (pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$4.raiseRecoverable = pp$4.raise;
      pp$4.curPosition = function () {
        if (this.options.locations) {
          return new Position(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$3 = Parser.prototype;
      var Scope = function Scope(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
        this.inClassFieldInit = false;
      };
      pp$3.enterScope = function (flags) {
        this.scopeStack.push(new Scope(flags));
      };
      pp$3.exitScope = function () {
        this.scopeStack.pop();
      };
      pp$3.treatFunctionsAsVarInScope = function (scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
      };
      pp$3.declareName = function (name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
          scope.lexical.push(name);
          if (this.inModule && scope.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
          }
          scope$2.functions.push(name);
        } else {
          for (var i = this.scopeStack.length - 1; i >= 0; --i) {
            var scope$3 = this.scopeStack[i];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP) {
              delete this.undefinedExports[name];
            }
            if (scope$3.flags & SCOPE_VAR) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
        }
      };
      pp$3.checkLocalExport = function (id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$3.currentScope = function () {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$3.currentVarScope = function () {
        for (var i = this.scopeStack.length - 1;; i--) {
          var scope = this.scopeStack[i];
          if (scope.flags & SCOPE_VAR) {
            return scope;
          }
        }
      };
      pp$3.currentThisScope = function () {
        for (var i = this.scopeStack.length - 1;; i--) {
          var scope = this.scopeStack[i];
          if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
            return scope;
          }
        }
      };
      var Node$1 = function Node(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [
            pos,
            0
          ];
        }
      };
      var pp$2 = Parser.prototype;
      pp$2.startNode = function () {
        return new Node$1(this, this.start, this.startLoc);
      };
      pp$2.startNodeAt = function (pos, loc) {
        return new Node$1(this, pos, loc);
      };
      function finishNodeAt(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations) {
          node.loc.end = loc;
        }
        if (this.options.ranges) {
          node.range[1] = pos;
        }
        return node;
      }
      pp$2.finishNode = function (node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$2.finishNodeAt = function (node, type, pos, loc) {
        return finishNodeAt.call(this, node, type, pos, loc);
      };
      pp$2.copyNode = function (node) {
        var newNode = new Node$1(this, node.start, this.startLoc);
        for (var prop in node) {
          newNode[prop] = node[prop];
        }
        return newNode;
      };
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
      var ecma13BinaryProperties = ecma12BinaryProperties;
      var ecma14BinaryProperties = ecma13BinaryProperties;
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties,
        13: ecma13BinaryProperties,
        14: ecma14BinaryProperties
      };
      var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
      var unicodeBinaryPropertiesOfStrings = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings
      };
      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
      var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues,
        13: ecma13ScriptValues,
        14: ecma14ScriptValues
      };
      var data = {};
      function buildUnicodeData(ecmaVersion) {
        var d = data[ecmaVersion] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
          binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      for (var i = 0, list = [
            9,
            10,
            11,
            12,
            13,
            14
          ]; i < list.length; i += 1) {
        var ecmaVersion = list[i];
        buildUnicodeData(ecmaVersion);
      }
      var pp$1 = Parser.prototype;
      var RegExpValidationState = function RegExpValidationState(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = [];
        this.backReferenceNames = [];
      };
      RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicodeSets = flags.indexOf("v") !== -1;
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
          this.switchU = true;
          this.switchV = true;
          this.switchN = true;
        } else {
          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
          this.switchV = false;
          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        }
      };
      RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState.prototype.at = function at(i, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) {
          return -1;
        }
        var c = s.charCodeAt(i);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) {
          return l;
        }
        var c = s.charCodeAt(i), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
          return i + 1;
        }
        return i + 2;
      };
      RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0)
          forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0)
          forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
        if (forceU === void 0)
          forceU = false;
        var pos = this.pos;
        for (var i = 0, list = chs; i < list.length; i += 1) {
          var ch = list[i];
          var current = this.at(pos, forceU);
          if (current === -1 || current !== ch) {
            return false;
          }
          pos = this.nextIndex(pos, forceU);
        }
        this.pos = pos;
        return true;
      };
      pp$1.validateRegExpFlags = function (state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        var u = false;
        var v = false;
        for (var i = 0; i < flags.length; i++) {
          var flag = flags.charAt(i);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
          if (flag === "u") {
            u = true;
          }
          if (flag === "v") {
            v = true;
          }
        }
        if (this.options.ecmaVersion >= 15 && u && v) {
          this.raise(state.start, "Invalid regular expression flag");
        }
      };
      pp$1.validateRegExpPattern = function (state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$1.regexp_pattern = function (state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames.length = 0;
        state.backReferenceNames.length = 0;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(41)) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(93) || state.eat(125)) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
          var name = list[i];
          if (state.groupNames.indexOf(name) === -1) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$1.regexp_disjunction = function (state) {
        this.regexp_alternative(state);
        while (state.eat(124)) {
          this.regexp_alternative(state);
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(123)) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$1.regexp_alternative = function (state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$1.regexp_eatTerm = function (state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$1.regexp_eatAssertion = function (state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(94) || state.eat(36)) {
          return true;
        }
        if (state.eat(92)) {
          if (state.eat(66) || state.eat(98)) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(40) && state.eat(63)) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(60);
          }
          if (state.eat(61) || state.eat(33)) {
            this.regexp_disjunction(state);
            if (!state.eat(41)) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$1.regexp_eatQuantifier = function (state, noError) {
        if (noError === void 0)
          noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(63);
          return true;
        }
        return false;
      };
      pp$1.regexp_eatQuantifierPrefix = function (state, noError) {
        return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$1.regexp_eatBracedQuantifier = function (state, noError) {
        var start = state.pos;
        if (state.eat(123)) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(125)) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatAtom = function (state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$1.regexp_eatReverseSolidusAtomEscape = function (state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatUncapturingGroup = function (state) {
        var start = state.pos;
        if (state.eat(40)) {
          if (state.eat(63) && state.eat(58)) {
            this.regexp_disjunction(state);
            if (state.eat(41)) {
              return true;
            }
            state.raise("Unterminated group");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatCapturingGroup = function (state) {
        if (state.eat(40)) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$1.regexp_eatExtendedAtom = function (state) {
        return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$1.regexp_eatInvalidBracedQuantifier = function (state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$1.regexp_eatSyntaxCharacter = function (state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatPatternCharacters = function (state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$1.regexp_eatExtendedPatternCharacter = function (state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_groupSpecifier = function (state) {
        if (state.eat(63)) {
          if (this.regexp_eatGroupName(state)) {
            if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
              state.raise("Duplicate capture group name");
            }
            state.groupNames.push(state.lastStringValue);
            return;
          }
          state.raise("Invalid group");
        }
      };
      pp$1.regexp_eatGroupName = function (state) {
        state.lastStringValue = "";
        if (state.eat(60)) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierName = function (state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierStart = function (state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$1.regexp_eatRegExpIdentifierPart = function (state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$1.regexp_eatAtomEscape = function (state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$1.regexp_eatBackReference = function (state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n = state.lastIntValue;
          if (state.switchU) {
            if (n > state.maxBackReference) {
              state.maxBackReference = n;
            }
            return true;
          }
          if (n <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatKGroupName = function (state) {
        if (state.eat(107)) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$1.regexp_eatCharacterEscape = function (state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$1.regexp_eatCControlLetter = function (state) {
        var start = state.pos;
        if (state.eat(99)) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatZero = function (state) {
        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlEscape = function (state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlLetter = function (state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$1.regexp_eatRegExpUnicodeEscapeSequence = function (state, forceU) {
        if (forceU === void 0)
          forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(117)) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$1.regexp_eatIdentityEscape = function (state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(47)) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatDecimalEscape = function (state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      var CharSetNone = 0;
      var CharSetOk = 1;
      var CharSetString = 2;
      pp$1.regexp_eatCharacterClassEscape = function (state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return CharSetOk;
        }
        var negate = false;
        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          var result;
          if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
            if (negate && result === CharSetString) {
              state.raise("Invalid property name");
            }
            return result;
          }
          state.raise("Invalid property name");
        }
        return CharSetNone;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$1.regexp_eatUnicodePropertyValueExpression = function (state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
          var name = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
            return CharSetOk;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        }
        return CharSetNone;
      };
      pp$1.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {
        if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name].test(value)) {
          state.raise("Invalid property value");
        }
      };
      pp$1.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {
        if (state.unicodeProperties.binary.test(nameOrValue)) {
          return CharSetOk;
        }
        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
          return CharSetString;
        }
        state.raise("Invalid property name");
      };
      pp$1.regexp_eatUnicodePropertyName = function (state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$1.regexp_eatUnicodePropertyValue = function (state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$1.regexp_eatCharacterClass = function (state) {
        if (state.eat(91)) {
          var negate = state.eat(94);
          var result = this.regexp_classContents(state);
          if (!state.eat(93)) {
            state.raise("Unterminated character class");
          }
          if (negate && result === CharSetString) {
            state.raise("Negated character class may contain strings");
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_classContents = function (state) {
        if (state.current() === 93) {
          return CharSetOk;
        }
        if (state.switchV) {
          return this.regexp_classSetExpression(state);
        }
        this.regexp_nonEmptyClassRanges(state);
        return CharSetOk;
      };
      pp$1.regexp_nonEmptyClassRanges = function (state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(45) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$1.regexp_eatClassAtom = function (state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatClassEscape = function (state) {
        var start = state.pos;
        if (state.eat(98)) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(45)) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(99)) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$1.regexp_classSetExpression = function (state) {
        var result = CharSetOk, subResult;
        if (this.regexp_eatClassSetRange(state));
        else if (subResult = this.regexp_eatClassSetOperand(state)) {
          if (subResult === CharSetString) {
            result = CharSetString;
          }
          var start = state.pos;
          while (state.eatChars([
              38,
              38
            ])) {
            if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
              if (subResult !== CharSetString) {
                result = CharSetOk;
              }
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
          while (state.eatChars([
              45,
              45
            ])) {
            if (this.regexp_eatClassSetOperand(state)) {
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
        } else {
          state.raise("Invalid character in character class");
        }
        for (;;) {
          if (this.regexp_eatClassSetRange(state)) {
            continue;
          }
          subResult = this.regexp_eatClassSetOperand(state);
          if (!subResult) {
            return result;
          }
          if (subResult === CharSetString) {
            result = CharSetString;
          }
        }
      };
      pp$1.regexp_eatClassSetRange = function (state) {
        var start = state.pos;
        if (this.regexp_eatClassSetCharacter(state)) {
          var left = state.lastIntValue;
          if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
            var right = state.lastIntValue;
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatClassSetOperand = function (state) {
        if (this.regexp_eatClassSetCharacter(state)) {
          return CharSetOk;
        }
        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
      };
      pp$1.regexp_eatNestedClass = function (state) {
        var start = state.pos;
        if (state.eat(91)) {
          var negate = state.eat(94);
          var result = this.regexp_classContents(state);
          if (state.eat(93)) {
            if (negate && result === CharSetString) {
              state.raise("Negated character class may contain strings");
            }
            return result;
          }
          state.pos = start;
        }
        if (state.eat(92)) {
          var result$1 = this.regexp_eatCharacterClassEscape(state);
          if (result$1) {
            return result$1;
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_eatClassStringDisjunction = function (state) {
        var start = state.pos;
        if (state.eatChars([
            92,
            113
          ])) {
          if (state.eat(123)) {
            var result = this.regexp_classStringDisjunctionContents(state);
            if (state.eat(125)) {
              return result;
            }
          } else {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_classStringDisjunctionContents = function (state) {
        var result = this.regexp_classString(state);
        while (state.eat(124)) {
          if (this.regexp_classString(state) === CharSetString) {
            result = CharSetString;
          }
        }
        return result;
      };
      pp$1.regexp_classString = function (state) {
        var count = 0;
        while (this.regexp_eatClassSetCharacter(state)) {
          count++;
        }
        return count === 1 ? CharSetOk : CharSetString;
      };
      pp$1.regexp_eatClassSetCharacter = function (state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
            return true;
          }
          if (state.eat(98)) {
            state.lastIntValue = 8;
            return true;
          }
          state.pos = start;
          return false;
        }
        var ch = state.current();
        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
          return false;
        }
        if (isClassSetSyntaxCharacter(ch)) {
          return false;
        }
        state.advance();
        state.lastIntValue = ch;
        return true;
      };
      function isClassSetReservedDoublePunctuatorCharacter(ch) {
        return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
      }
      function isClassSetSyntaxCharacter(ch) {
        return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatClassSetReservedPunctuator = function (state) {
        var ch = state.current();
        if (isClassSetReservedPunctuator(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isClassSetReservedPunctuator(ch) {
        return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
      }
      pp$1.regexp_eatClassControlLetter = function (state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatHexEscapeSequence = function (state) {
        var start = state.pos;
        if (state.eat(120)) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatDecimalDigits = function (state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$1.regexp_eatHexDigits = function (state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$1.regexp_eatLegacyOctalEscapeSequence = function (state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatOctalDigit = function (state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$1.regexp_eatFixedHexDigits = function (state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i = 0; i < length; ++i) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true;
      };
      var Token = function Token(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [
            p.start,
            p.end
          ];
        }
      };
      var pp = Parser.prototype;
      pp.next = function (ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp.getToken = function () {
        this.next();
        return new Token(this);
      };
      if (typeof Symbol !== "undefined") {
        pp[Symbol.iterator] = function () {
          var this$1$1 = this;
          return {
            next: function () {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$1.eof,
                value: token
              };
            }
          };
        };
      }
      pp.nextToken = function () {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$1.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp.readToken = function (code) {
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code);
      };
      pp.fullCharCodeAtPos = function () {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 56320) {
          return code;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
      };
      pp.skipBlockComment = function () {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp.skipLineComment = function (startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp.skipSpace = function () {
        loop:
          while (this.pos < this.input.length) {
            var ch = this.input.charCodeAt(this.pos);
            switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;
              case 47:
                this.skipLineComment(2);
                break;
              default:
                break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
            }
          }
      };
      pp.finishToken = function (type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp.readToken_dot = function () {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$1.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$1.dot);
        }
      };
      pp.readToken_slash = function () {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.slash, 1);
      };
      pp.readToken_mult_modulo_exp = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types$1.star : types$1.modulo;
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types$1.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp.readToken_pipe_amp = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
      };
      pp.readToken_caret = function () {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.bitwiseXOR, 1);
      };
      pp.readToken_plus_min = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$1.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.plusMin, 1);
      };
      pp.readToken_lt_gt = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types$1.assign, size + 1);
          }
          return this.finishOp(types$1.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types$1.relational, size);
      };
      pp.readToken_eq_excl = function (code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$1.arrow);
        }
        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
      };
      pp.readToken_question = function () {
        var ecmaVersion = this.options.ecmaVersion;
        if (ecmaVersion >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$1.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$1.assign, 3);
              }
            }
            return this.finishOp(types$1.coalesce, 2);
          }
        }
        return this.finishOp(types$1.question, 1);
      };
      pp.readToken_numberSign = function () {
        var ecmaVersion = this.options.ecmaVersion;
        var code = 35;
        if (ecmaVersion >= 13) {
          ++this.pos;
          code = this.fullCharCodeAtPos();
          if (isIdentifierStart(code, true) || code === 92) {
            return this.finishToken(types$1.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.getTokenFromCode = function (code) {
        switch (code) {
        case 46:
          return this.readToken_dot();
        case 40:
          ++this.pos;
          return this.finishToken(types$1.parenL);
        case 41:
          ++this.pos;
          return this.finishToken(types$1.parenR);
        case 59:
          ++this.pos;
          return this.finishToken(types$1.semi);
        case 44:
          ++this.pos;
          return this.finishToken(types$1.comma);
        case 91:
          ++this.pos;
          return this.finishToken(types$1.bracketL);
        case 93:
          ++this.pos;
          return this.finishToken(types$1.bracketR);
        case 123:
          ++this.pos;
          return this.finishToken(types$1.braceL);
        case 125:
          ++this.pos;
          return this.finishToken(types$1.braceR);
        case 58:
          ++this.pos;
          return this.finishToken(types$1.colon);
        case 96:
          if (this.options.ecmaVersion < 6) {
            break;
          }
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        case 48:
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) {
            return this.readRadixNumber(16);
          }
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) {
              return this.readRadixNumber(8);
            }
            if (next === 98 || next === 66) {
              return this.readRadixNumber(2);
            }
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(code);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(code);
        case 124:
        case 38:
          return this.readToken_pipe_amp(code);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(code);
        case 60:
        case 62:
          return this.readToken_lt_gt(code);
        case 61:
        case 33:
          return this.readToken_eq_excl(code);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(types$1.prefix, 1);
        case 35:
          return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.finishOp = function (type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };
      pp.readRegexp = function () {
        var escaped, inClass, start = this.pos;
        for (;;) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value = null;
        try {
          value = new RegExp(pattern, flags);
        } catch (e) {
        }
        return this.finishToken(types$1.regexp, {
          pattern: pattern,
          flags: flags,
          value: value
        });
      };
      pp.readInt = function (radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp.readRadixNumber = function (radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val);
      };
      pp.readNumber = function (startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, undefined, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$1.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$1.num, val);
      };
      pp.readCodePoint = function () {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };
      pp.readString = function (quote) {
        var out = "", chunkStart = ++this.pos;
        for (;;) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$1.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp.tryReadTemplateToken = function () {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp.invalidStringToken = function (position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
          this.raise(position, message);
        }
      };
      pp.readTmplToken = function () {
        var out = "", chunkStart = this.pos;
        for (;;) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$1.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$1.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$1.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              out += "\n";
              break;
            default:
              out += String.fromCharCode(ch);
              break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp.readInvalidTemplateToken = function () {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{") {
              break;
            }
          case "`":
            return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp.readEscapedChar = function (inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return codePointToString(this.readCodePoint());
        case 116:
          return "\t";
        case 98:
          return "\b";
        case 118:
          return "\x0B";
        case 102:
          return "\f";
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        case 56:
        case 57:
          if (this.strict) {
            this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
          }
          if (inTemplate) {
            var codePos = this.pos - 1;
            this.invalidStringToken(codePos, "Invalid escape sequence in template string");
          }
        default:
          if (ch >= 48 && ch <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.pos += octalStr.length - 1;
            ch = this.input.charCodeAt(this.pos);
            if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
              this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
            }
            return String.fromCharCode(octal);
          }
          if (isNewLine(ch)) {
            return "";
          }
          return String.fromCharCode(ch);
        }
      };
      pp.readHexChar = function (len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n;
      };
      pp.readWord1 = function () {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp.readWord = function () {
        var word = this.readWord1();
        var type = types$1.name;
        if (this.keywords.test(word)) {
          type = keywords[word];
        }
        return this.finishToken(type, word);
      };
      var version = "8.11.2";
      Parser.acorn = {
        Parser: Parser,
        version: version,
        defaultOptions: defaultOptions,
        Position: Position,
        SourceLocation: SourceLocation,
        getLineInfo: getLineInfo,
        Node: Node$1,
        TokenType: TokenType,
        tokTypes: types$1,
        keywordTypes: keywords,
        TokContext: TokContext,
        tokContexts: types,
        isIdentifierChar: isIdentifierChar,
        isIdentifierStart: isIdentifierStart,
        Token: Token,
        isNewLine: isNewLine,
        lineBreak: lineBreak,
        lineBreakG: lineBreakG,
        nonASCIIwhitespace: nonASCIIwhitespace
      };

      var dummyValue = "\u2716";
      function isDummy(node) {
        return node.name === dummyValue;
      }
      function noop() {
      }
      var LooseParser = function LooseParser(input, options) {
        if (options === void 0)
          options = {};
        this.toks = this.constructor.BaseParser.tokenizer(input, options);
        this.options = this.toks.options;
        this.input = this.toks.input;
        this.tok = this.last = {
          type: types$1.eof,
          start: 0,
          end: 0
        };
        this.tok.validateRegExpFlags = noop;
        this.tok.validateRegExpPattern = noop;
        if (this.options.locations) {
          var here = this.toks.curPosition();
          this.tok.loc = new SourceLocation(this.toks, here, here);
        }
        this.ahead = [];
        this.context = [];
        this.curIndent = 0;
        this.curLineStart = 0;
        this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
        this.inAsync = false;
        this.inGenerator = false;
        this.inFunction = false;
      };
      LooseParser.prototype.startNode = function startNode() {
        return new Node$1(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null);
      };
      LooseParser.prototype.storeCurrentPos = function storeCurrentPos() {
        return this.options.locations ? [
          this.tok.start,
          this.tok.loc.start
        ] : this.tok.start;
      };
      LooseParser.prototype.startNodeAt = function startNodeAt(pos) {
        if (this.options.locations) {
          return new Node$1(this.toks, pos[0], pos[1]);
        } else {
          return new Node$1(this.toks, pos);
        }
      };
      LooseParser.prototype.finishNode = function finishNode(node, type) {
        node.type = type;
        node.end = this.last.end;
        if (this.options.locations) {
          node.loc.end = this.last.loc.end;
        }
        if (this.options.ranges) {
          node.range[1] = this.last.end;
        }
        return node;
      };
      LooseParser.prototype.dummyNode = function dummyNode(type) {
        var dummy = this.startNode();
        dummy.type = type;
        dummy.end = dummy.start;
        if (this.options.locations) {
          dummy.loc.end = dummy.loc.start;
        }
        if (this.options.ranges) {
          dummy.range[1] = dummy.start;
        }
        this.last = {
          type: types$1.name,
          start: dummy.start,
          end: dummy.start,
          loc: dummy.loc
        };
        return dummy;
      };
      LooseParser.prototype.dummyIdent = function dummyIdent() {
        var dummy = this.dummyNode("Identifier");
        dummy.name = dummyValue;
        return dummy;
      };
      LooseParser.prototype.dummyString = function dummyString() {
        var dummy = this.dummyNode("Literal");
        dummy.value = dummy.raw = dummyValue;
        return dummy;
      };
      LooseParser.prototype.eat = function eat(type) {
        if (this.tok.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      LooseParser.prototype.isContextual = function isContextual(name) {
        return this.tok.type === types$1.name && this.tok.value === name;
      };
      LooseParser.prototype.eatContextual = function eatContextual(name) {
        return this.tok.value === name && this.eat(types$1.name);
      };
      LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon() {
        return this.tok.type === types$1.eof || this.tok.type === types$1.braceR || lineBreak.test(this.input.slice(this.last.end, this.tok.start));
      };
      LooseParser.prototype.semicolon = function semicolon() {
        return this.eat(types$1.semi);
      };
      LooseParser.prototype.expect = function expect(type) {
        if (this.eat(type)) {
          return true;
        }
        for (var i = 1; i <= 2; i++) {
          if (this.lookAhead(i).type === type) {
            for (var j = 0; j < i; j++) {
              this.next();
            }
            return true;
          }
        }
      };
      LooseParser.prototype.pushCx = function pushCx() {
        this.context.push(this.curIndent);
      };
      LooseParser.prototype.popCx = function popCx() {
        this.curIndent = this.context.pop();
      };
      LooseParser.prototype.lineEnd = function lineEnd(pos) {
        while (pos < this.input.length && !isNewLine(this.input.charCodeAt(pos))) {
          ++pos;
        }
        return pos;
      };
      LooseParser.prototype.indentationAfter = function indentationAfter(pos) {
        for (var count = 0;; ++pos) {
          var ch = this.input.charCodeAt(pos);
          if (ch === 32) {
            ++count;
          } else if (ch === 9) {
            count += this.options.tabSize;
          } else {
            return count;
          }
        }
      };
      LooseParser.prototype.closes = function closes(closeTok, indent, line, blockHeuristic) {
        if (this.tok.type === closeTok || this.tok.type === types$1.eof) {
          return true;
        }
        return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() && (!blockHeuristic || this.nextLineStart >= this.input.length || this.indentationAfter(this.nextLineStart) < indent);
      };
      LooseParser.prototype.tokenStartsLine = function tokenStartsLine() {
        for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {
          var ch = this.input.charCodeAt(p);
          if (ch !== 9 && ch !== 32) {
            return false;
          }
        }
        return true;
      };
      LooseParser.prototype.extend = function extend(name, f) {
        this[name] = f(this[name]);
      };
      LooseParser.prototype.parse = function parse() {
        this.next();
        return this.parseTopLevel();
      };
      LooseParser.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--)
          plugins[len] = arguments[len];
        var cls = this;
        for (var i = 0; i < plugins.length; i++) {
          cls = plugins[i](cls);
        }
        return cls;
      };
      LooseParser.parse = function parse(input, options) {
        return new this(input, options).parse();
      };
      LooseParser.BaseParser = Parser;
      var lp$2 = LooseParser.prototype;
      function isSpace(ch) {
        return ch < 14 && ch > 8 || ch === 32 || ch === 160 || isNewLine(ch);
      }
      lp$2.next = function () {
        this.last = this.tok;
        if (this.ahead.length) {
          this.tok = this.ahead.shift();
        } else {
          this.tok = this.readToken();
        }
        if (this.tok.start >= this.nextLineStart) {
          while (this.tok.start >= this.nextLineStart) {
            this.curLineStart = this.nextLineStart;
            this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
          }
          this.curIndent = this.indentationAfter(this.curLineStart);
        }
      };
      lp$2.readToken = function () {
        for (;;) {
          try {
            this.toks.next();
            if (this.toks.type === types$1.dot && this.input.substr(this.toks.end, 1) === "." && this.options.ecmaVersion >= 6) {
              this.toks.end++;
              this.toks.type = types$1.ellipsis;
            }
            return new Token(this.toks);
          } catch (e) {
            if (!(e instanceof SyntaxError)) {
              throw e;
            }
            var msg = e.message, pos = e.raisedAt, replace = true;
            if (/unterminated/i.test(msg)) {
              pos = this.lineEnd(e.pos + 1);
              if (/string/.test(msg)) {
                replace = {
                  start: e.pos,
                  end: pos,
                  type: types$1.string,
                  value: this.input.slice(e.pos + 1, pos)
                };
              } else if (/regular expr/i.test(msg)) {
                var re = this.input.slice(e.pos, pos);
                try {
                  re = new RegExp(re);
                } catch (e$1) {
                }
                replace = {
                  start: e.pos,
                  end: pos,
                  type: types$1.regexp,
                  value: re
                };
              } else if (/template/.test(msg)) {
                replace = {
                  start: e.pos,
                  end: pos,
                  type: types$1.template,
                  value: this.input.slice(e.pos, pos)
                };
              } else {
                replace = false;
              }
            } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {
              while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) {
                ++pos;
              }
            } else if (/character escape|expected hexadecimal/i.test(msg)) {
              while (pos < this.input.length) {
                var ch = this.input.charCodeAt(pos++);
                if (ch === 34 || ch === 39 || isNewLine(ch)) {
                  break;
                }
              }
            } else if (/unexpected character/i.test(msg)) {
              pos++;
              replace = false;
            } else if (/regular expression/i.test(msg)) {
              replace = true;
            } else {
              throw e;
            }
            this.resetTo(pos);
            if (replace === true) {
              replace = {
                start: pos,
                end: pos,
                type: types$1.name,
                value: dummyValue
              };
            }
            if (replace) {
              if (this.options.locations) {
                replace.loc = new SourceLocation(this.toks, getLineInfo(this.input, replace.start), getLineInfo(this.input, replace.end));
              }
              return replace;
            }
          }
        }
      };
      lp$2.resetTo = function (pos) {
        this.toks.pos = pos;
        var ch = this.input.charAt(pos - 1);
        this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\-~!|&%^<>]/.test(ch) || /[enwfd]/.test(ch) && /\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));
        if (this.options.locations) {
          this.toks.curLine = 1;
          this.toks.lineStart = lineBreakG.lastIndex = 0;
          var match;
          while ((match = lineBreakG.exec(this.input)) && match.index < pos) {
            ++this.toks.curLine;
            this.toks.lineStart = match.index + match[0].length;
          }
        }
      };
      lp$2.lookAhead = function (n) {
        while (n > this.ahead.length) {
          this.ahead.push(this.readToken());
        }
        return this.ahead[n - 1];
      };
      var lp$1 = LooseParser.prototype;
      lp$1.parseTopLevel = function () {
        var node = this.startNodeAt(this.options.locations ? [
          0,
          getLineInfo(this.input, 0)
        ] : 0);
        node.body = [];
        while (this.tok.type !== types$1.eof) {
          node.body.push(this.parseStatement());
        }
        this.toks.adaptDirectivePrologue(node.body);
        this.last = this.tok;
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      lp$1.parseStatement = function () {
        var starttype = this.tok.type, node = this.startNode(), kind;
        if (this.toks.isLet()) {
          starttype = types$1._var;
          kind = "let";
        }
        switch (starttype) {
        case types$1._break:
        case types$1._continue:
          this.next();
          var isBreak = starttype === types$1._break;
          if (this.semicolon() || this.canInsertSemicolon()) {
            node.label = null;
          } else {
            node.label = this.tok.type === types$1.name ? this.parseIdent() : null;
            this.semicolon();
          }
          return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
        case types$1._debugger:
          this.next();
          this.semicolon();
          return this.finishNode(node, "DebuggerStatement");
        case types$1._do:
          this.next();
          node.body = this.parseStatement();
          node.test = this.eat(types$1._while) ? this.parseParenExpression() : this.dummyIdent();
          this.semicolon();
          return this.finishNode(node, "DoWhileStatement");
        case types$1._for:
          this.next();
          var isAwait = this.options.ecmaVersion >= 9 && this.eatContextual("await");
          this.pushCx();
          this.expect(types$1.parenL);
          if (this.tok.type === types$1.semi) {
            return this.parseFor(node, null);
          }
          var isLet = this.toks.isLet();
          if (isLet || this.tok.type === types$1._var || this.tok.type === types$1._const) {
            var init$1 = this.parseVar(this.startNode(), true, isLet ? "let" : this.tok.value);
            if (init$1.declarations.length === 1 && (this.tok.type === types$1._in || this.isContextual("of"))) {
              if (this.options.ecmaVersion >= 9 && this.tok.type !== types$1._in) {
                node.await = isAwait;
              }
              return this.parseForIn(node, init$1);
            }
            return this.parseFor(node, init$1);
          }
          var init = this.parseExpression(true);
          if (this.tok.type === types$1._in || this.isContextual("of")) {
            if (this.options.ecmaVersion >= 9 && this.tok.type !== types$1._in) {
              node.await = isAwait;
            }
            return this.parseForIn(node, this.toAssignable(init));
          }
          return this.parseFor(node, init);
        case types$1._function:
          this.next();
          return this.parseFunction(node, true);
        case types$1._if:
          this.next();
          node.test = this.parseParenExpression();
          node.consequent = this.parseStatement();
          node.alternate = this.eat(types$1._else) ? this.parseStatement() : null;
          return this.finishNode(node, "IfStatement");
        case types$1._return:
          this.next();
          if (this.eat(types$1.semi) || this.canInsertSemicolon()) {
            node.argument = null;
          } else {
            node.argument = this.parseExpression();
            this.semicolon();
          }
          return this.finishNode(node, "ReturnStatement");
        case types$1._switch:
          var blockIndent = this.curIndent, line = this.curLineStart;
          this.next();
          node.discriminant = this.parseParenExpression();
          node.cases = [];
          this.pushCx();
          this.expect(types$1.braceL);
          var cur;
          while (!this.closes(types$1.braceR, blockIndent, line, true)) {
            if (this.tok.type === types$1._case || this.tok.type === types$1._default) {
              var isCase = this.tok.type === types$1._case;
              if (cur) {
                this.finishNode(cur, "SwitchCase");
              }
              node.cases.push(cur = this.startNode());
              cur.consequent = [];
              this.next();
              if (isCase) {
                cur.test = this.parseExpression();
              } else {
                cur.test = null;
              }
              this.expect(types$1.colon);
            } else {
              if (!cur) {
                node.cases.push(cur = this.startNode());
                cur.consequent = [];
                cur.test = null;
              }
              cur.consequent.push(this.parseStatement());
            }
          }
          if (cur) {
            this.finishNode(cur, "SwitchCase");
          }
          this.popCx();
          this.eat(types$1.braceR);
          return this.finishNode(node, "SwitchStatement");
        case types$1._throw:
          this.next();
          node.argument = this.parseExpression();
          this.semicolon();
          return this.finishNode(node, "ThrowStatement");
        case types$1._try:
          this.next();
          node.block = this.parseBlock();
          node.handler = null;
          if (this.tok.type === types$1._catch) {
            var clause = this.startNode();
            this.next();
            if (this.eat(types$1.parenL)) {
              clause.param = this.toAssignable(this.parseExprAtom(), true);
              this.expect(types$1.parenR);
            } else {
              clause.param = null;
            }
            clause.body = this.parseBlock();
            node.handler = this.finishNode(clause, "CatchClause");
          }
          node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
          if (!node.handler && !node.finalizer) {
            return node.block;
          }
          return this.finishNode(node, "TryStatement");
        case types$1._var:
        case types$1._const:
          return this.parseVar(node, false, kind || this.tok.value);
        case types$1._while:
          this.next();
          node.test = this.parseParenExpression();
          node.body = this.parseStatement();
          return this.finishNode(node, "WhileStatement");
        case types$1._with:
          this.next();
          node.object = this.parseParenExpression();
          node.body = this.parseStatement();
          return this.finishNode(node, "WithStatement");
        case types$1.braceL:
          return this.parseBlock();
        case types$1.semi:
          this.next();
          return this.finishNode(node, "EmptyStatement");
        case types$1._class:
          return this.parseClass(true);
        case types$1._import:
          if (this.options.ecmaVersion > 10) {
            var nextType = this.lookAhead(1).type;
            if (nextType === types$1.parenL || nextType === types$1.dot) {
              node.expression = this.parseExpression();
              this.semicolon();
              return this.finishNode(node, "ExpressionStatement");
            }
          }
          return this.parseImport();
        case types$1._export:
          return this.parseExport();
        default:
          if (this.toks.isAsyncFunction()) {
            this.next();
            this.next();
            return this.parseFunction(node, true, true);
          }
          var expr = this.parseExpression();
          if (isDummy(expr)) {
            this.next();
            if (this.tok.type === types$1.eof) {
              return this.finishNode(node, "EmptyStatement");
            }
            return this.parseStatement();
          } else if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
            node.body = this.parseStatement();
            node.label = expr;
            return this.finishNode(node, "LabeledStatement");
          } else {
            node.expression = expr;
            this.semicolon();
            return this.finishNode(node, "ExpressionStatement");
          }
        }
      };
      lp$1.parseBlock = function () {
        var node = this.startNode();
        this.pushCx();
        this.expect(types$1.braceL);
        var blockIndent = this.curIndent, line = this.curLineStart;
        node.body = [];
        while (!this.closes(types$1.braceR, blockIndent, line, true)) {
          node.body.push(this.parseStatement());
        }
        this.popCx();
        this.eat(types$1.braceR);
        return this.finishNode(node, "BlockStatement");
      };
      lp$1.parseFor = function (node, init) {
        node.init = init;
        node.test = node.update = null;
        if (this.eat(types$1.semi) && this.tok.type !== types$1.semi) {
          node.test = this.parseExpression();
        }
        if (this.eat(types$1.semi) && this.tok.type !== types$1.parenR) {
          node.update = this.parseExpression();
        }
        this.popCx();
        this.expect(types$1.parenR);
        node.body = this.parseStatement();
        return this.finishNode(node, "ForStatement");
      };
      lp$1.parseForIn = function (node, init) {
        var type = this.tok.type === types$1._in ? "ForInStatement" : "ForOfStatement";
        this.next();
        node.left = init;
        node.right = this.parseExpression();
        this.popCx();
        this.expect(types$1.parenR);
        node.body = this.parseStatement();
        return this.finishNode(node, type);
      };
      lp$1.parseVar = function (node, noIn, kind) {
        node.kind = kind;
        this.next();
        node.declarations = [];
        do {
          var decl = this.startNode();
          decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();
          decl.init = this.eat(types$1.eq) ? this.parseMaybeAssign(noIn) : null;
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        } while (this.eat(types$1.comma));
        if (!node.declarations.length) {
          var decl$1 = this.startNode();
          decl$1.id = this.dummyIdent();
          node.declarations.push(this.finishNode(decl$1, "VariableDeclarator"));
        }
        if (!noIn) {
          this.semicolon();
        }
        return this.finishNode(node, "VariableDeclaration");
      };
      lp$1.parseClass = function (isStatement) {
        var node = this.startNode();
        this.next();
        if (this.tok.type === types$1.name) {
          node.id = this.parseIdent();
        } else if (isStatement === true) {
          node.id = this.dummyIdent();
        } else {
          node.id = null;
        }
        node.superClass = this.eat(types$1._extends) ? this.parseExpression() : null;
        node.body = this.startNode();
        node.body.body = [];
        this.pushCx();
        var indent = this.curIndent + 1, line = this.curLineStart;
        this.eat(types$1.braceL);
        if (this.curIndent + 1 < indent) {
          indent = this.curIndent;
          line = this.curLineStart;
        }
        while (!this.closes(types$1.braceR, indent, line)) {
          var element = this.parseClassElement();
          if (element) {
            node.body.body.push(element);
          }
        }
        this.popCx();
        if (!this.eat(types$1.braceR)) {
          this.last.end = this.tok.start;
          if (this.options.locations) {
            this.last.loc.end = this.tok.loc.start;
          }
        }
        this.semicolon();
        this.finishNode(node.body, "ClassBody");
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      lp$1.parseClassElement = function () {
        if (this.eat(types$1.semi)) {
          return null;
        }
        var ref = this.options;
        var ecmaVersion = ref.ecmaVersion;
        var locations = ref.locations;
        var indent = this.curIndent;
        var line = this.curLineStart;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
            this.parseClassStaticBlock(node);
            return node;
          }
          if (this.isClassElementNameStart() || this.toks.type === types$1.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.toks.type === types$1.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName) {
          isGenerator = this.eat(types$1.star);
          var lastValue = this.toks.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node.computed = false;
          node.key = this.startNodeAt(locations ? [
            this.toks.lastTokStart,
            this.toks.lastTokStartLoc
          ] : this.toks.lastTokStart);
          node.key.name = keyName;
          this.finishNode(node.key, "Identifier");
        } else {
          this.parseClassElementName(node);
          if (isDummy(node.key)) {
            if (isDummy(this.parseMaybeAssign())) {
              this.next();
            }
            this.eat(types$1.comma);
            return null;
          }
        }
        if (ecmaVersion < 13 || this.toks.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node.computed && !node.static && !isGenerator && !isAsync && kind === "method" && (node.key.type === "Identifier" && node.key.name === "constructor" || node.key.type === "Literal" && node.key.value === "constructor");
          node.kind = isConstructor ? "constructor" : kind;
          node.value = this.parseMethod(isGenerator, isAsync);
          this.finishNode(node, "MethodDefinition");
        } else {
          if (this.eat(types$1.eq)) {
            if (this.curLineStart !== line && this.curIndent <= indent && this.tokenStartsLine()) {
              node.value = null;
            } else {
              var oldInAsync = this.inAsync;
              var oldInGenerator = this.inGenerator;
              this.inAsync = false;
              this.inGenerator = false;
              node.value = this.parseMaybeAssign();
              this.inAsync = oldInAsync;
              this.inGenerator = oldInGenerator;
            }
          } else {
            node.value = null;
          }
          this.semicolon();
          this.finishNode(node, "PropertyDefinition");
        }
        return node;
      };
      lp$1.parseClassStaticBlock = function (node) {
        var blockIndent = this.curIndent, line = this.curLineStart;
        node.body = [];
        this.pushCx();
        while (!this.closes(types$1.braceR, blockIndent, line, true)) {
          node.body.push(this.parseStatement());
        }
        this.popCx();
        this.eat(types$1.braceR);
        return this.finishNode(node, "StaticBlock");
      };
      lp$1.isClassElementNameStart = function () {
        return this.toks.isClassElementNameStart();
      };
      lp$1.parseClassElementName = function (element) {
        if (this.toks.type === types$1.privateId) {
          element.computed = false;
          element.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element);
        }
      };
      lp$1.parseFunction = function (node, isStatement, isAsync) {
        var oldInAsync = this.inAsync, oldInGenerator = this.inGenerator, oldInFunction = this.inFunction;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = this.eat(types$1.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (this.tok.type === types$1.name) {
          node.id = this.parseIdent();
        } else if (isStatement === true) {
          node.id = this.dummyIdent();
        }
        this.inAsync = node.async;
        this.inGenerator = node.generator;
        this.inFunction = true;
        node.params = this.parseFunctionParams();
        node.body = this.parseBlock();
        this.toks.adaptDirectivePrologue(node.body.body);
        this.inAsync = oldInAsync;
        this.inGenerator = oldInGenerator;
        this.inFunction = oldInFunction;
        return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      };
      lp$1.parseExport = function () {
        var node = this.startNode();
        this.next();
        if (this.eat(types$1.star)) {
          if (this.options.ecmaVersion >= 11) {
            if (this.eatContextual("as")) {
              node.exported = this.parseExprAtom();
            } else {
              node.exported = null;
            }
          }
          node.source = this.eatContextual("from") ? this.parseExprAtom() : this.dummyString();
          this.semicolon();
          return this.finishNode(node, "ExportAllDeclaration");
        }
        if (this.eat(types$1._default)) {
          var isAsync;
          if (this.tok.type === types$1._function || (isAsync = this.toks.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) {
              this.next();
            }
            node.declaration = this.parseFunction(fNode, "nullableID", isAsync);
          } else if (this.tok.type === types$1._class) {
            node.declaration = this.parseClass("nullableID");
          } else {
            node.declaration = this.parseMaybeAssign();
            this.semicolon();
          }
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {
          node.declaration = this.parseStatement();
          node.specifiers = [];
          node.source = null;
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifierList();
          node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      lp$1.parseImport = function () {
        var node = this.startNode();
        this.next();
        if (this.tok.type === types$1.string) {
          node.specifiers = [];
          node.source = this.parseExprAtom();
        } else {
          var elt;
          if (this.tok.type === types$1.name && this.tok.value !== "from") {
            elt = this.startNode();
            elt.local = this.parseIdent();
            this.finishNode(elt, "ImportDefaultSpecifier");
            this.eat(types$1.comma);
          }
          node.specifiers = this.parseImportSpecifiers();
          node.source = this.eatContextual("from") && this.tok.type === types$1.string ? this.parseExprAtom() : this.dummyString();
          if (elt) {
            node.specifiers.unshift(elt);
          }
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      lp$1.parseImportSpecifiers = function () {
        var elts = [];
        if (this.tok.type === types$1.star) {
          var elt = this.startNode();
          this.next();
          elt.local = this.eatContextual("as") ? this.parseIdent() : this.dummyIdent();
          elts.push(this.finishNode(elt, "ImportNamespaceSpecifier"));
        } else {
          var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;
          this.pushCx();
          this.eat(types$1.braceL);
          if (this.curLineStart > continuedLine) {
            continuedLine = this.curLineStart;
          }
          while (!this.closes(types$1.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
            var elt$1 = this.startNode();
            if (this.eat(types$1.star)) {
              elt$1.local = this.eatContextual("as") ? this.parseModuleExportName() : this.dummyIdent();
              this.finishNode(elt$1, "ImportNamespaceSpecifier");
            } else {
              if (this.isContextual("from")) {
                break;
              }
              elt$1.imported = this.parseModuleExportName();
              if (isDummy(elt$1.imported)) {
                break;
              }
              elt$1.local = this.eatContextual("as") ? this.parseModuleExportName() : elt$1.imported;
              this.finishNode(elt$1, "ImportSpecifier");
            }
            elts.push(elt$1);
            this.eat(types$1.comma);
          }
          this.eat(types$1.braceR);
          this.popCx();
        }
        return elts;
      };
      lp$1.parseExportSpecifierList = function () {
        var elts = [];
        var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;
        this.pushCx();
        this.eat(types$1.braceL);
        if (this.curLineStart > continuedLine) {
          continuedLine = this.curLineStart;
        }
        while (!this.closes(types$1.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
          if (this.isContextual("from")) {
            break;
          }
          var elt = this.startNode();
          elt.local = this.parseModuleExportName();
          if (isDummy(elt.local)) {
            break;
          }
          elt.exported = this.eatContextual("as") ? this.parseModuleExportName() : elt.local;
          this.finishNode(elt, "ExportSpecifier");
          elts.push(elt);
          this.eat(types$1.comma);
        }
        this.eat(types$1.braceR);
        this.popCx();
        return elts;
      };
      lp$1.parseModuleExportName = function () {
        return this.options.ecmaVersion >= 13 && this.tok.type === types$1.string ? this.parseExprAtom() : this.parseIdent();
      };
      var lp = LooseParser.prototype;
      lp.checkLVal = function (expr) {
        if (!expr) {
          return expr;
        }
        switch (expr.type) {
        case "Identifier":
        case "MemberExpression":
          return expr;
        case "ParenthesizedExpression":
          expr.expression = this.checkLVal(expr.expression);
          return expr;
        default:
          return this.dummyIdent();
        }
      };
      lp.parseExpression = function (noIn) {
        var start = this.storeCurrentPos();
        var expr = this.parseMaybeAssign(noIn);
        if (this.tok.type === types$1.comma) {
          var node = this.startNodeAt(start);
          node.expressions = [expr];
          while (this.eat(types$1.comma)) {
            node.expressions.push(this.parseMaybeAssign(noIn));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      lp.parseParenExpression = function () {
        this.pushCx();
        this.expect(types$1.parenL);
        var val = this.parseExpression();
        this.popCx();
        this.expect(types$1.parenR);
        return val;
      };
      lp.parseMaybeAssign = function (noIn) {
        if (this.inGenerator && this.toks.isContextual("yield")) {
          var node = this.startNode();
          this.next();
          if (this.semicolon() || this.canInsertSemicolon() || this.tok.type !== types$1.star && !this.tok.type.startsExpr) {
            node.delegate = false;
            node.argument = null;
          } else {
            node.delegate = this.eat(types$1.star);
            node.argument = this.parseMaybeAssign();
          }
          return this.finishNode(node, "YieldExpression");
        }
        var start = this.storeCurrentPos();
        var left = this.parseMaybeConditional(noIn);
        if (this.tok.type.isAssign) {
          var node$1 = this.startNodeAt(start);
          node$1.operator = this.tok.value;
          node$1.left = this.tok.type === types$1.eq ? this.toAssignable(left) : this.checkLVal(left);
          this.next();
          node$1.right = this.parseMaybeAssign(noIn);
          return this.finishNode(node$1, "AssignmentExpression");
        }
        return left;
      };
      lp.parseMaybeConditional = function (noIn) {
        var start = this.storeCurrentPos();
        var expr = this.parseExprOps(noIn);
        if (this.eat(types$1.question)) {
          var node = this.startNodeAt(start);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          node.alternate = this.expect(types$1.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      lp.parseExprOps = function (noIn) {
        var start = this.storeCurrentPos();
        var indent = this.curIndent, line = this.curLineStart;
        return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line);
      };
      lp.parseExprOp = function (left, start, minPrec, noIn, indent, line) {
        if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {
          return left;
        }
        var prec = this.tok.type.binop;
        if (prec != null && (!noIn || this.tok.type !== types$1._in)) {
          if (prec > minPrec) {
            var node = this.startNodeAt(start);
            node.left = left;
            node.operator = this.tok.value;
            this.next();
            if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {
              node.right = this.dummyIdent();
            } else {
              var rightStart = this.storeCurrentPos();
              node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);
            }
            this.finishNode(node, /&&|\|\||\?\?/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
            return this.parseExprOp(node, start, minPrec, noIn, indent, line);
          }
        }
        return left;
      };
      lp.parseMaybeUnary = function (sawUnary) {
        var start = this.storeCurrentPos(), expr;
        if (this.options.ecmaVersion >= 8 && this.toks.isContextual("await") && (this.inAsync || this.toks.inModule && this.options.ecmaVersion >= 13 || !this.inFunction && this.options.allowAwaitOutsideFunction)) {
          expr = this.parseAwait();
          sawUnary = true;
        } else if (this.tok.type.prefix) {
          var node = this.startNode(), update = this.tok.type === types$1.incDec;
          if (!update) {
            sawUnary = true;
          }
          node.operator = this.tok.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(true);
          if (update) {
            node.argument = this.checkLVal(node.argument);
          }
          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else if (this.tok.type === types$1.ellipsis) {
          var node$1 = this.startNode();
          this.next();
          node$1.argument = this.parseMaybeUnary(sawUnary);
          expr = this.finishNode(node$1, "SpreadElement");
        } else if (!sawUnary && this.tok.type === types$1.privateId) {
          expr = this.parsePrivateIdent();
        } else {
          expr = this.parseExprSubscripts();
          while (this.tok.type.postfix && !this.canInsertSemicolon()) {
            var node$2 = this.startNodeAt(start);
            node$2.operator = this.tok.value;
            node$2.prefix = false;
            node$2.argument = this.checkLVal(expr);
            this.next();
            expr = this.finishNode(node$2, "UpdateExpression");
          }
        }
        if (!sawUnary && this.eat(types$1.starstar)) {
          var node$3 = this.startNodeAt(start);
          node$3.operator = "**";
          node$3.left = expr;
          node$3.right = this.parseMaybeUnary(false);
          return this.finishNode(node$3, "BinaryExpression");
        }
        return expr;
      };
      lp.parseExprSubscripts = function () {
        var start = this.storeCurrentPos();
        return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart);
      };
      lp.parseSubscripts = function (base, start, noCalls, startIndent, line) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optionalChained = false;
        for (;;) {
          if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {
            if (this.tok.type === types$1.dot && this.curIndent === startIndent) {
              --startIndent;
            } else {
              break;
            }
          }
          var maybeAsyncArrow = base.type === "Identifier" && base.name === "async" && !this.canInsertSemicolon();
          var optional = optionalSupported && this.eat(types$1.questionDot);
          if (optional) {
            optionalChained = true;
          }
          if (optional && this.tok.type !== types$1.parenL && this.tok.type !== types$1.bracketL && this.tok.type !== types$1.backQuote || this.eat(types$1.dot)) {
            var node = this.startNodeAt(start);
            node.object = base;
            if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {
              node.property = this.dummyIdent();
            } else {
              node.property = this.parsePropertyAccessor() || this.dummyIdent();
            }
            node.computed = false;
            if (optionalSupported) {
              node.optional = optional;
            }
            base = this.finishNode(node, "MemberExpression");
          } else if (this.tok.type === types$1.bracketL) {
            this.pushCx();
            this.next();
            var node$1 = this.startNodeAt(start);
            node$1.object = base;
            node$1.property = this.parseExpression();
            node$1.computed = true;
            if (optionalSupported) {
              node$1.optional = optional;
            }
            this.popCx();
            this.expect(types$1.bracketR);
            base = this.finishNode(node$1, "MemberExpression");
          } else if (!noCalls && this.tok.type === types$1.parenL) {
            var exprList = this.parseExprList(types$1.parenR);
            if (maybeAsyncArrow && this.eat(types$1.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(start), exprList, true);
            }
            var node$2 = this.startNodeAt(start);
            node$2.callee = base;
            node$2.arguments = exprList;
            if (optionalSupported) {
              node$2.optional = optional;
            }
            base = this.finishNode(node$2, "CallExpression");
          } else if (this.tok.type === types$1.backQuote) {
            var node$3 = this.startNodeAt(start);
            node$3.tag = base;
            node$3.quasi = this.parseTemplate();
            base = this.finishNode(node$3, "TaggedTemplateExpression");
          } else {
            break;
          }
        }
        if (optionalChained) {
          var chainNode = this.startNodeAt(start);
          chainNode.expression = base;
          base = this.finishNode(chainNode, "ChainExpression");
        }
        return base;
      };
      lp.parseExprAtom = function () {
        var node;
        switch (this.tok.type) {
        case types$1._this:
        case types$1._super:
          var type = this.tok.type === types$1._this ? "ThisExpression" : "Super";
          node = this.startNode();
          this.next();
          return this.finishNode(node, type);
        case types$1.name:
          var start = this.storeCurrentPos();
          var id = this.parseIdent();
          var isAsync = false;
          if (id.name === "async" && !this.canInsertSemicolon()) {
            if (this.eat(types$1._function)) {
              this.toks.overrideContext(types.f_expr);
              return this.parseFunction(this.startNodeAt(start), false, true);
            }
            if (this.tok.type === types$1.name) {
              id = this.parseIdent();
              isAsync = true;
            }
          }
          return this.eat(types$1.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id;
        case types$1.regexp:
          node = this.startNode();
          var val = this.tok.value;
          node.regex = {
            pattern: val.pattern,
            flags: val.flags
          };
          node.value = val.value;
          node.raw = this.input.slice(this.tok.start, this.tok.end);
          this.next();
          return this.finishNode(node, "Literal");
        case types$1.num:
        case types$1.string:
          node = this.startNode();
          node.value = this.tok.value;
          node.raw = this.input.slice(this.tok.start, this.tok.end);
          if (this.tok.type === types$1.num && node.raw.charCodeAt(node.raw.length - 1) === 110) {
            node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
          }
          this.next();
          return this.finishNode(node, "Literal");
        case types$1._null:
        case types$1._true:
        case types$1._false:
          node = this.startNode();
          node.value = this.tok.type === types$1._null ? null : this.tok.type === types$1._true;
          node.raw = this.tok.type.keyword;
          this.next();
          return this.finishNode(node, "Literal");
        case types$1.parenL:
          var parenStart = this.storeCurrentPos();
          this.next();
          var inner = this.parseExpression();
          this.expect(types$1.parenR);
          if (this.eat(types$1.arrow)) {
            var params = inner.expressions || [inner];
            if (params.length && isDummy(params[params.length - 1])) {
              params.pop();
            }
            return this.parseArrowExpression(this.startNodeAt(parenStart), params);
          }
          if (this.options.preserveParens) {
            var par = this.startNodeAt(parenStart);
            par.expression = inner;
            inner = this.finishNode(par, "ParenthesizedExpression");
          }
          return inner;
        case types$1.bracketL:
          node = this.startNode();
          node.elements = this.parseExprList(types$1.bracketR, true);
          return this.finishNode(node, "ArrayExpression");
        case types$1.braceL:
          this.toks.overrideContext(types.b_expr);
          return this.parseObj();
        case types$1._class:
          return this.parseClass(false);
        case types$1._function:
          node = this.startNode();
          this.next();
          return this.parseFunction(node, false);
        case types$1._new:
          return this.parseNew();
        case types$1.backQuote:
          return this.parseTemplate();
        case types$1._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport();
          } else {
            return this.dummyIdent();
          }
        default:
          return this.dummyIdent();
        }
      };
      lp.parseExprImport = function () {
        var node = this.startNode();
        var meta = this.parseIdent(true);
        switch (this.tok.type) {
        case types$1.parenL:
          return this.parseDynamicImport(node);
        case types$1.dot:
          node.meta = meta;
          return this.parseImportMeta(node);
        default:
          node.name = "import";
          return this.finishNode(node, "Identifier");
        }
      };
      lp.parseDynamicImport = function (node) {
        node.source = this.parseExprList(types$1.parenR)[0] || this.dummyString();
        return this.finishNode(node, "ImportExpression");
      };
      lp.parseImportMeta = function (node) {
        this.next();
        node.property = this.parseIdent(true);
        return this.finishNode(node, "MetaProperty");
      };
      lp.parseNew = function () {
        var node = this.startNode(), startIndent = this.curIndent, line = this.curLineStart;
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
          node.meta = meta;
          node.property = this.parseIdent(true);
          return this.finishNode(node, "MetaProperty");
        }
        var start = this.storeCurrentPos();
        node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);
        if (this.tok.type === types$1.parenL) {
          node.arguments = this.parseExprList(types$1.parenR);
        } else {
          node.arguments = [];
        }
        return this.finishNode(node, "NewExpression");
      };
      lp.parseTemplateElement = function () {
        var elem = this.startNode();
        if (this.tok.type === types$1.invalidTemplate) {
          elem.value = {
            raw: this.tok.value,
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.tok.start, this.tok.end).replace(/\r\n?/g, "\n"),
            cooked: this.tok.value
          };
        }
        this.next();
        elem.tail = this.tok.type === types$1.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      lp.parseTemplate = function () {
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement();
        node.quasis = [curElt];
        while (!curElt.tail) {
          this.next();
          node.expressions.push(this.parseExpression());
          if (this.expect(types$1.braceR)) {
            curElt = this.parseTemplateElement();
          } else {
            curElt = this.startNode();
            curElt.value = {
              cooked: "",
              raw: ""
            };
            curElt.tail = true;
            this.finishNode(curElt, "TemplateElement");
          }
          node.quasis.push(curElt);
        }
        this.expect(types$1.backQuote);
        return this.finishNode(node, "TemplateLiteral");
      };
      lp.parseObj = function () {
        var node = this.startNode();
        node.properties = [];
        this.pushCx();
        var indent = this.curIndent + 1, line = this.curLineStart;
        this.eat(types$1.braceL);
        if (this.curIndent + 1 < indent) {
          indent = this.curIndent;
          line = this.curLineStart;
        }
        while (!this.closes(types$1.braceR, indent, line)) {
          var prop = this.startNode(), isGenerator = void 0, isAsync = void 0, start = void 0;
          if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
            prop.argument = this.parseMaybeAssign();
            node.properties.push(this.finishNode(prop, "SpreadElement"));
            this.eat(types$1.comma);
            continue;
          }
          if (this.options.ecmaVersion >= 6) {
            start = this.storeCurrentPos();
            prop.method = false;
            prop.shorthand = false;
            isGenerator = this.eat(types$1.star);
          }
          this.parsePropertyName(prop);
          if (this.toks.isAsyncProp(prop)) {
            isAsync = true;
            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
            this.parsePropertyName(prop);
          } else {
            isAsync = false;
          }
          if (isDummy(prop.key)) {
            if (isDummy(this.parseMaybeAssign())) {
              this.next();
            }
            this.eat(types$1.comma);
            continue;
          }
          if (this.eat(types$1.colon)) {
            prop.kind = "init";
            prop.value = this.parseMaybeAssign();
          } else if (this.options.ecmaVersion >= 6 && (this.tok.type === types$1.parenL || this.tok.type === types$1.braceL)) {
            prop.kind = "init";
            prop.method = true;
            prop.value = this.parseMethod(isGenerator, isAsync);
          } else if (this.options.ecmaVersion >= 5 && prop.key.type === "Identifier" && !prop.computed && (prop.key.name === "get" || prop.key.name === "set") && (this.tok.type !== types$1.comma && this.tok.type !== types$1.braceR && this.tok.type !== types$1.eq)) {
            prop.kind = prop.key.name;
            this.parsePropertyName(prop);
            prop.value = this.parseMethod(false);
          } else {
            prop.kind = "init";
            if (this.options.ecmaVersion >= 6) {
              if (this.eat(types$1.eq)) {
                var assign = this.startNodeAt(start);
                assign.operator = "=";
                assign.left = prop.key;
                assign.right = this.parseMaybeAssign();
                prop.value = this.finishNode(assign, "AssignmentExpression");
              } else {
                prop.value = prop.key;
              }
            } else {
              prop.value = this.dummyIdent();
            }
            prop.shorthand = true;
          }
          node.properties.push(this.finishNode(prop, "Property"));
          this.eat(types$1.comma);
        }
        this.popCx();
        if (!this.eat(types$1.braceR)) {
          this.last.end = this.tok.start;
          if (this.options.locations) {
            this.last.loc.end = this.tok.loc.start;
          }
        }
        return this.finishNode(node, "ObjectExpression");
      };
      lp.parsePropertyName = function (prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$1.bracketL)) {
            prop.computed = true;
            prop.key = this.parseExpression();
            this.expect(types$1.bracketR);
            return;
          } else {
            prop.computed = false;
          }
        }
        var key = this.tok.type === types$1.num || this.tok.type === types$1.string ? this.parseExprAtom() : this.parseIdent();
        prop.key = key || this.dummyIdent();
      };
      lp.parsePropertyAccessor = function () {
        if (this.tok.type === types$1.name || this.tok.type.keyword) {
          return this.parseIdent();
        }
        if (this.tok.type === types$1.privateId) {
          return this.parsePrivateIdent();
        }
      };
      lp.parseIdent = function () {
        var name = this.tok.type === types$1.name ? this.tok.value : this.tok.type.keyword;
        if (!name) {
          return this.dummyIdent();
        }
        var node = this.startNode();
        this.next();
        node.name = name;
        return this.finishNode(node, "Identifier");
      };
      lp.parsePrivateIdent = function () {
        var node = this.startNode();
        node.name = this.tok.value;
        this.next();
        return this.finishNode(node, "PrivateIdentifier");
      };
      lp.initFunction = function (node) {
        node.id = null;
        node.params = [];
        if (this.options.ecmaVersion >= 6) {
          node.generator = false;
          node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      lp.toAssignable = function (node, binding) {
        if (!node || node.type === "Identifier" || node.type === "MemberExpression" && !binding);
        else if (node.type === "ParenthesizedExpression") {
          this.toAssignable(node.expression, binding);
        } else if (this.options.ecmaVersion < 6) {
          return this.dummyIdent();
        } else if (node.type === "ObjectExpression") {
          node.type = "ObjectPattern";
          for (var i = 0, list = node.properties; i < list.length; i += 1) {
            var prop = list[i];
            this.toAssignable(prop, binding);
          }
        } else if (node.type === "ArrayExpression") {
          node.type = "ArrayPattern";
          this.toAssignableList(node.elements, binding);
        } else if (node.type === "Property") {
          this.toAssignable(node.value, binding);
        } else if (node.type === "SpreadElement") {
          node.type = "RestElement";
          this.toAssignable(node.argument, binding);
        } else if (node.type === "AssignmentExpression") {
          node.type = "AssignmentPattern";
          delete node.operator;
        } else {
          return this.dummyIdent();
        }
        return node;
      };
      lp.toAssignableList = function (exprList, binding) {
        for (var i = 0, list = exprList; i < list.length; i += 1) {
          var expr = list[i];
          this.toAssignable(expr, binding);
        }
        return exprList;
      };
      lp.parseFunctionParams = function (params) {
        params = this.parseExprList(types$1.parenR);
        return this.toAssignableList(params, true);
      };
      lp.parseMethod = function (isGenerator, isAsync) {
        var node = this.startNode(), oldInAsync = this.inAsync, oldInGenerator = this.inGenerator, oldInFunction = this.inFunction;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = !!isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.inAsync = node.async;
        this.inGenerator = node.generator;
        this.inFunction = true;
        node.params = this.parseFunctionParams();
        node.body = this.parseBlock();
        this.toks.adaptDirectivePrologue(node.body.body);
        this.inAsync = oldInAsync;
        this.inGenerator = oldInGenerator;
        this.inFunction = oldInFunction;
        return this.finishNode(node, "FunctionExpression");
      };
      lp.parseArrowExpression = function (node, params, isAsync) {
        var oldInAsync = this.inAsync, oldInGenerator = this.inGenerator, oldInFunction = this.inFunction;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.inAsync = node.async;
        this.inGenerator = false;
        this.inFunction = true;
        node.params = this.toAssignableList(params, true);
        node.expression = this.tok.type !== types$1.braceL;
        if (node.expression) {
          node.body = this.parseMaybeAssign();
        } else {
          node.body = this.parseBlock();
          this.toks.adaptDirectivePrologue(node.body.body);
        }
        this.inAsync = oldInAsync;
        this.inGenerator = oldInGenerator;
        this.inFunction = oldInFunction;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      lp.parseExprList = function (close, allowEmpty) {
        this.pushCx();
        var indent = this.curIndent, line = this.curLineStart, elts = [];
        this.next();
        while (!this.closes(close, indent + 1, line)) {
          if (this.eat(types$1.comma)) {
            elts.push(allowEmpty ? null : this.dummyIdent());
            continue;
          }
          var elt = this.parseMaybeAssign();
          if (isDummy(elt)) {
            if (this.closes(close, indent, line)) {
              break;
            }
            this.next();
          } else {
            elts.push(elt);
          }
          this.eat(types$1.comma);
        }
        this.popCx();
        if (!this.eat(close)) {
          this.last.end = this.tok.start;
          if (this.options.locations) {
            this.last.loc.end = this.tok.loc.start;
          }
        }
        return elts;
      };
      lp.parseAwait = function () {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary();
        return this.finishNode(node, "AwaitExpression");
      };
      defaultOptions.tabSize = 4;
      function parse$1(input, options) {
        return LooseParser.parse(input, options);
      }

      var loose = /*#__PURE__*/Object.freeze({
        __proto__: null,
        LooseParser: LooseParser,
        isDummy: isDummy,
        parse: parse$1
      });

      var __varRecorder__$a = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/lib/acorn-extension.js", __contextModule__);

      var __moduleMeta__$a = {
        pathInPackage: function pathInPackage() {
          return "./lib/acorn-extension.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ast",
            version: "0.11.3"
          };
        }
      };

      var forEachNode = __varRecorder__$a["lively.ast/lib/acorn-extension.js__define__"]("forEachNode", "function", function (parsed, func, state, options) {
        options = options || {};
        var traversal = options.traversal || "preorder";
        var visitors = clone(options.visitors ? options.visitors : make(__varRecorder__$a.custom.visitors.withMemberExpression));
        var iterator = traversal === "preorder" ? function (orig, type, node, depth, cont) {
          func(node, state, depth, type);
          return orig(node, depth + 1, cont);
        } : function (orig, type, node, depth, cont) {
          var result = orig(node, depth + 1, cont);
          func(node, state, depth, type);
          return result;
        };
        Object.keys(visitors).forEach(function (type) {
          var orig = visitors[type];

          visitors[type] = function (node, depth, cont) {
            return iterator(orig, type, node, depth, cont);
          };
        });
        recursive(parsed, 0, null, visitors);
        return parsed;
      }, __moduleMeta__$a);

      __varRecorder__$a.forEachNode = forEachNode;

      var matchNodes = __varRecorder__$a["lively.ast/lib/acorn-extension.js__define__"]("matchNodes", "function", function (parsed, visitor, state, options) {
        function visit(node, state, depth, type) {
          if (visitor[node.type]) visitor[node.type](node, state, depth, type);
        }

        return __varRecorder__$a.forEachNode(parsed, visit, state, options);
      }, __moduleMeta__$a);

      __varRecorder__$a.matchNodes = matchNodes;

      var findNodesIncluding = __varRecorder__$a["lively.ast/lib/acorn-extension.js__define__"]("findNodesIncluding", "function", function (parsed, pos, test, base$1) {
        var nodes = [];
        base$1 = base$1 || make(__varRecorder__$a.custom.visitors.withMemberExpression);
        Object.keys(base).forEach(function (name) {
          var orig = base$1[name];

          base$1[name] = function (node, state, cont) {
            pushIfNotIncluded(nodes, node);
            return orig(node, state, cont);
          };
        });

        base$1.Property = function (node, st, c) {
          pushIfNotIncluded(nodes, node);
          c(node.key, st, "Expression");
          c(node.value, st, "Expression");
        };

        base$1.LabeledStatement = function (node, st, c) {
          node.label && c(node.label, st, "Expression");
          c(node.body, st, "Statement");
        };

        findNodeAround(parsed, pos, test, base$1);
        return nodes;
      }, __moduleMeta__$a);

      __varRecorder__$a.findNodesIncluding = findNodesIncluding;

      var withParentInfo = __varRecorder__$a["lively.ast/lib/acorn-extension.js__define__"]("withParentInfo", "function", function (parsed, iterator, options) {
        options = options || {};

        function makeScope(parentScope) {
          var scope = {
            id: newUUID(),
            parentScope: parentScope,
            containingScopes: []
          };
          parentScope && parentScope.containingScopes.push(scope);
          return scope;
        }

        var visitors = make({
          Function: function Function(node, st, c) {
            if (st && st.scope) st.scope = makeScope(st.scope);
            c(node.body, st, "ScopeBody");
          },
          VariableDeclarator: function VariableDeclarator(node, st, c) {
            node.init && c(node.init, st, "Expression");
          },
          VariableDeclaration: function VariableDeclaration(node, st, c) {
            for (var i = 0; i < node.declarations.length; ++i) {
              var decl = node.declarations[i];
              if (decl) c(decl, st, "VariableDeclarator");
            }
          },
          ObjectExpression: function ObjectExpression(node, st, c) {
            for (var i = 0; i < node.properties.length; ++i) {
              var prop = node.properties[i];
              c(prop.key, st, "Expression");
              c(prop.value, st, "Expression");
            }
          },
          MemberExpression: function MemberExpression(node, st, c) {
            c(node.object, st, "Expression");
            c(node.property, st, "Expression");
          }
        }, base);
        var lastActiveProp;
        var getters = [];

        __varRecorder__$a.forEachNode(parsed, function (node) {
          withoutAll(Object.keys(node), ["end", "start", "type", "source", "raw"]).forEach(function (propName) {
            if (node.__lookupGetter__(propName)) return;
            var val = node[propName];

            node.__defineGetter__(propName, function () {
              lastActiveProp = propName;
              return val;
            });

            getters.push([node, propName, node[propName]]);
          });
        }, null, {
          visitors: visitors
        });

        var result = [];
        Object.keys(visitors).forEach(function (type) {
          var orig = visitors[type];

          visitors[type] = function (node, state, cont) {
            if (type === node.type || options.visitAllNodes) {
              result.push(iterator.call(null, node, {
                scope: state.scope,
                depth: state.depth,
                parent: state.parent,
                type: type,
                propertyInParent: lastActiveProp
              }));
              return orig(node, {
                scope: state.scope,
                parent: node,
                depth: state.depth + 1
              }, cont);
            } else {
              return orig(node, state, cont);
            }
          };
        });
        recursive(parsed, {
          scope: makeScope(),
          parent: null,
          propertyInParent: "",
          depth: 0
        }, null, visitors);
        getters.forEach(function (nodeNameVal) {
          delete nodeNameVal[0][nodeNameVal[1]];
          nodeNameVal[0][nodeNameVal[1]] = nodeNameVal[2];
        });
        return result;
      }, __moduleMeta__$a);

      __varRecorder__$a.withParentInfo = withParentInfo;

      var copy = __varRecorder__$a["lively.ast/lib/acorn-extension.js__define__"]("copy", "function", function (ast, override) {
        var visitors = extend({
          Program: function Program(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "Program",
              body: n.body.map(c),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          FunctionDeclaration: function FunctionDeclaration(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "FunctionDeclaration",
              id: c(n.id),
              params: n.params.map(c),
              body: c(n.body),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          BlockStatement: function BlockStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "BlockStatement",
              body: n.body.map(c),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          ExpressionStatement: function ExpressionStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "ExpressionStatement",
              expression: c(n.expression),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          CallExpression: function CallExpression(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "CallExpression",
              callee: c(n.callee),
              arguments: n.arguments.map(c),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          MemberExpression: function MemberExpression(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "MemberExpression",
              object: c(n.object),
              property: c(n.property),
              computed: n.computed,
              source: n.source,
              astIndex: n.astIndex
            };
          },
          NewExpression: function NewExpression(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "NewExpression",
              callee: c(n.callee),
              arguments: n.arguments.map(c),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          VariableDeclaration: function VariableDeclaration(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "VariableDeclaration",
              declarations: n.declarations.map(c),
              kind: n.kind,
              source: n.source,
              astIndex: n.astIndex
            };
          },
          VariableDeclarator: function VariableDeclarator(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "VariableDeclarator",
              id: c(n.id),
              init: c(n.init),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          FunctionExpression: function FunctionExpression(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "FunctionExpression",
              id: c(n.id),
              params: n.params.map(c),
              body: c(n.body),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          IfStatement: function IfStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "IfStatement",
              test: c(n.test),
              consequent: c(n.consequent),
              alternate: c(n.alternate),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          ConditionalExpression: function ConditionalExpression(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "ConditionalExpression",
              test: c(n.test),
              consequent: c(n.consequent),
              alternate: c(n.alternate),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          SwitchStatement: function SwitchStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "SwitchStatement",
              discriminant: c(n.discriminant),
              cases: n.cases.map(c),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          SwitchCase: function SwitchCase(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "SwitchCase",
              test: c(n.test),
              consequent: n.consequent.map(c),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          BreakStatement: function BreakStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "BreakStatement",
              label: n.label,
              source: n.source,
              astIndex: n.astIndex
            };
          },
          ContinueStatement: function ContinueStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "ContinueStatement",
              label: n.label,
              source: n.source,
              astIndex: n.astIndex
            };
          },
          TryStatement: function TryStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "TryStatement",
              block: c(n.block),
              handler: c(n.handler),
              finalizer: c(n.finalizer),
              guardedHandlers: n.guardedHandlers.map(c),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          CatchClause: function CatchClause(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "CatchClause",
              param: c(n.param),
              guard: c(n.guard),
              body: c(n.body),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          ThrowStatement: function ThrowStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "ThrowStatement",
              argument: c(n.argument),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          ForStatement: function ForStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "ForStatement",
              init: c(n.init),
              test: c(n.test),
              update: c(n.update),
              body: c(n.body),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          ForInStatement: function ForInStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "ForInStatement",
              left: c(n.left),
              right: c(n.right),
              body: c(n.body),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          WhileStatement: function WhileStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "WhileStatement",
              test: c(n.test),
              body: c(n.body),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          DoWhileStatement: function DoWhileStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "DoWhileStatement",
              test: c(n.test),
              body: c(n.body),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          WithStatement: function WithStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "WithStatement",
              object: c(n.object),
              body: c(n.body),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          UnaryExpression: function UnaryExpression(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "UnaryExpression",
              argument: c(n.argument),
              operator: n.operator,
              prefix: n.prefix,
              source: n.source,
              astIndex: n.astIndex
            };
          },
          BinaryExpression: function BinaryExpression(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "BinaryExpression",
              left: c(n.left),
              operator: n.operator,
              right: c(n.right),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          LogicalExpression: function LogicalExpression(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "LogicalExpression",
              left: c(n.left),
              operator: n.operator,
              right: c(n.right),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          AssignmentExpression: function AssignmentExpression(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "AssignmentExpression",
              left: c(n.left),
              operator: n.operator,
              right: c(n.right),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          UpdateExpression: function UpdateExpression(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "UpdateExpression",
              argument: c(n.argument),
              operator: n.operator,
              prefix: n.prefix,
              source: n.source,
              astIndex: n.astIndex
            };
          },
          ReturnStatement: function ReturnStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "ReturnStatement",
              argument: c(n.argument),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          Identifier: function Identifier(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "Identifier",
              name: n.name,
              source: n.source,
              astIndex: n.astIndex
            };
          },
          Literal: function Literal(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "Literal",
              value: n.value,
              raw: n.raw,
              source: n.source,
              astIndex: n.astIndex
            };
          },
          ObjectExpression: function ObjectExpression(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "ObjectExpression",
              properties: n.properties.map(function (prop) {
                return {
                  key: c(prop.key),
                  value: c(prop.value),
                  kind: prop.kind
                };
              }),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          ArrayExpression: function ArrayExpression(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "ArrayExpression",
              elements: n.elements.map(c),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          SequenceExpression: function SequenceExpression(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "SequenceExpression",
              expressions: n.expressions.map(c),
              source: n.source,
              astIndex: n.astIndex
            };
          },
          EmptyStatement: function EmptyStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "EmptyStatement",
              source: n.source,
              astIndex: n.astIndex
            };
          },
          ThisExpression: function ThisExpression(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "ThisExpression",
              source: n.source,
              astIndex: n.astIndex
            };
          },
          DebuggerStatement: function DebuggerStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "DebuggerStatement",
              source: n.source,
              astIndex: n.astIndex
            };
          },
          LabeledStatement: function LabeledStatement(n, c) {
            return {
              start: n.start,
              end: n.end,
              type: "LabeledStatement",
              label: n.label,
              body: c(n.body),
              source: n.source,
              astIndex: n.astIndex
            };
          }
        }, override || {});

        function c(node) {
          if (node === null) return null;
          return visitors[node.type](node, c);
        }

        return c(ast);
      }, __moduleMeta__$a);

      __varRecorder__$a.copy = copy;

      var findSiblings = __varRecorder__$a["lively.ast/lib/acorn-extension.js__define__"]("findSiblings", "function", function (parsed, node, beforeOrAfter) {
        if (!node) return [];

        var nodes = __varRecorder__$a.findNodesIncluding(parsed, node.start);

        var idx = nodes.indexOf(node);
        var parents = nodes.slice(0, idx);
        var parentWithBody = parents.reverse().find(function (p) {
          return Array.isArray(p.body);
        });
        var siblingsWithNode = parentWithBody.body;
        if (!beforeOrAfter) return without(siblingsWithNode, node);
        var nodeIdxInSiblings = siblingsWithNode.indexOf(node);
        return beforeOrAfter === "before" ? siblingsWithNode.slice(0, nodeIdxInSiblings) : siblingsWithNode.slice(nodeIdxInSiblings + 1);
      }, __moduleMeta__$a);

      __varRecorder__$a.findSiblings = findSiblings;

      var findNodeByAstIndex = __varRecorder__$a["lively.ast/lib/acorn-extension.js__define__"]("findNodeByAstIndex", "function", function (parsed, astIndexToFind, addIndex) {
        addIndex = addIndex == null ? true : !!addIndex;
        if (!parsed.astIndex && addIndex) __varRecorder__$a.addAstIndex(parsed);
        var found = null;
        withMozillaAstDo(parsed, null, function (next, node, state) {
          if (found) return;
          var idx = node.astIndex;
          if (idx < astIndexToFind) return;

          if (node.astIndex === astIndexToFind) {
            found = node;
            return;
          }

          next();
        });
        return found;
      }, __moduleMeta__$a);

      __varRecorder__$a.findNodeByAstIndex = findNodeByAstIndex;

      var findStatementOfNode = __varRecorder__$a["lively.ast/lib/acorn-extension.js__define__"]("findStatementOfNode", "function", function (options, parsed, target) {
        if (!target) {
          target = parsed;
          parsed = options;
          options = null;
        }

        if (!options) options = {};
        if (!parsed.astIndex) __varRecorder__$a.addAstIndex(parsed);
        var found;
        var targetReached = false;
        var statements = ["EmptyStatement", "BlockStatement", "ExpressionStatement", "IfStatement", "LabeledStatement", "BreakStatement", "ContinueStatement", "WithStatement", "SwitchStatement", "ReturnStatement", "ThrowStatement", "TryStatement", "WhileStatement", "DoWhileStatement", "ForStatement", "ForInStatement", "DebuggerStatement", "FunctionDeclaration", "VariableDeclaration", "ClassDeclaration"];
        withMozillaAstDo(parsed, {}, function (next, node, state, path) {
          if (targetReached || node.astIndex < target.astIndex) return;

          if (node === target || node.astIndex === target.astIndex) {
            targetReached = true;

            if (options.asPath) {
              found = path;
            } else {
              var p = Path(path);

              do {
                found = p.get(parsed);
                p = p.slice(0, p.size() - 1);
              } while (statements.indexOf(found.type) == -1 && p.size() > 0);
            }
          }

          !targetReached && next();
        });
        return found;
      }, __moduleMeta__$a);

      __varRecorder__$a.findStatementOfNode = findStatementOfNode;

      var addAstIndex = __varRecorder__$a["lively.ast/lib/acorn-extension.js__define__"]("addAstIndex", "function", function (parsed) {
        withMozillaAstDo(parsed, {
          index: 0
        }, function (next, node, state) {
          next();
          node.astIndex = state.index++;
        });
        return parsed;
      }, __moduleMeta__$a);

      __varRecorder__$a.addAstIndex = addAstIndex;
      __varRecorder__$a.isNode = typeof System !== "undefined" ? System.get("@system-env").node : false;
      __varRecorder__$a.Decorators = __varRecorder__$a.Decorators || undefined;
      __varRecorder__$a.ClassFields = __varRecorder__$a.ClassFields || undefined;
      __varRecorder__$a.StaticClassFeatures = __varRecorder__$a.StaticClassFeatures || undefined;
      __varRecorder__$a.PrivateMethods = __varRecorder__$a.PrivateMethods || undefined;

      if (__varRecorder__$a.isNode) {
        __varRecorder__$a.Decorators = exports$1$4 ? _Decorators : System._nodeRequire("lively.ast/lib/acorn-decorators.cjs");
        __varRecorder__$a.ClassFields = exports$1$4 || System._nodeRequire("acorn-class-fields");
        __varRecorder__$a.StaticClassFeatures = exports$1$3 || System._nodeRequire("acorn-static-class-features");
        __varRecorder__$a.PrivateMethods = exports$1$2 || System._nodeRequire("acorn-private-methods");
      } else {
        __varRecorder__$a.Decorators = _Decorators;
        __varRecorder__$a.ClassFields = exports$1$4;
        __varRecorder__$a.StaticClassFeatures = exports$1$3;
        __varRecorder__$a.PrivateMethods = exports$1$2;
      }

      __varRecorder__$a.custom = {};
      __varRecorder__$a.custom.forEachNode = __varRecorder__$a.forEachNode;
      __varRecorder__$a.custom.matchNodes = __varRecorder__$a.matchNodes;
      __varRecorder__$a.custom.findNodesIncluding = __varRecorder__$a.findNodesIncluding;
      __varRecorder__$a.custom.withParentInfo = __varRecorder__$a.withParentInfo;
      __varRecorder__$a.custom.copy = __varRecorder__$a.copy;
      __varRecorder__$a.custom.findSiblings = __varRecorder__$a.findSiblings;
      __varRecorder__$a.custom.findNodeByAstIndex = __varRecorder__$a.findNodeByAstIndex;
      __varRecorder__$a.custom.findStatementOfNode = __varRecorder__$a.findStatementOfNode;
      __varRecorder__$a.custom.addAstIndex = __varRecorder__$a.addAstIndex;
      __varRecorder__$a.Parser = Parser$2.extend(__varRecorder__$a.ClassFields, __varRecorder__$a.StaticClassFeatures, __varRecorder__$a.PrivateMethods, __varRecorder__$a.Decorators);
      __varRecorder__$a.acorn = {};
      Object.assign(__varRecorder__$a.acorn, acornDefault);
      __varRecorder__$a.acorn.Parser = __varRecorder__$a.Parser;

      __varRecorder__$a.acorn.parse = function (source, opts) {
        return __varRecorder__$a.Parser.parse(source, opts);
      };

      var acorn = __varRecorder__$a.acorn;
      var custom = exports('L', __varRecorder__$a.custom);
      __varRecorder__$a.walk = walk;
      __varRecorder__$a.loose = loose;
      __varRecorder__$a.acorn = acorn;
      __varRecorder__$a.custom = custom;
      __varRecorder__$a.findStatementOfNode = findStatementOfNode;
      __varRecorder__$a.addAstIndex = addAstIndex;
      __varRecorder__$a.findNodesIncluding = findNodesIncluding;
      __varRecorder__$a.findSiblings = findSiblings;
      __varRecorder__$a.findNodeByAstIndex = findNodeByAstIndex;
      __varRecorder__$a.copy = copy;
      __varRecorder__$a.custom.visitors = {
        stopAtFunctions: make(Object.assign({
          Function: function Function() {}
        }, base)),
        withMemberExpression: make({
          MemberExpression: function MemberExpression(node, st, c) {
            c(node.object, st, "Expression");
            c(node.property, st, "Expression");
          }
        }, base)
      };

      var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      var exports$2 = {};
      (function (f) {
        exports$2 = f();
      }(function () {
        return function () {
          function r(e, n, t) {
            function o(i, f) {
              if (!n[i]) {
                if (!e[i]) {
                  var c = null;
                  if (!f && c)
                    return c(i, !0);
                  if (u)
                    return u(i, !0);
                  var a = new Error("Cannot find module '" + i + "'");
                  throw a.code = "MODULE_NOT_FOUND", a;
                }
                var p = n[i] = { exports: {} };
                e[i][0].call(p.exports, function (r) {
                  var n = e[i][1][r];
                  return o(n || r);
                }, p, p.exports, r, e, n, t);
              }
              return n[i].exports;
            }
            for (var u = null, i = 0; i < t.length; i++)
              o(t[i]);
            return o;
          }
          return r;
        }()({
          1: [
            function (_dereq_, module, exports) {
              (function (global) {
                (function () {
                  !function (e) {
                    if ("object" == typeof exports && "undefined" != typeof module)
                      module.exports = e();
                    else {
                      ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this || _global).ASTY = e();
                    }
                  }(function () {
                    return function () {
                      return function e(t, n, r) {
                        function o(a, u) {
                          if (!n[a]) {
                            if (!t[a]) {
                              var f = "function" == typeof _dereq_ && _dereq_;
                              if (!u && f)
                                return f(a, !0);
                              if (i)
                                return i(a, !0);
                              var c = new Error("Cannot find module '" + a + "'");
                              throw c.code = "MODULE_NOT_FOUND", c;
                            }
                            var l = n[a] = { exports: {} };
                            t[a][0].call(l.exports, function (e) {
                              return o(t[a][1][e] || e);
                            }, l, l.exports, e, t, n, r);
                          }
                          return n[a].exports;
                        }
                        for (var i = "function" == typeof _dereq_ && _dereq_, a = 0; a < r.length; a++)
                          o(r[a]);
                        return o;
                      };
                    }()({
                      1: [
                        function (e, t, n) {
                          function r(e) {
                            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                              return typeof e;
                            } : function (e) {
                              return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                            })(e);
                          }
                          function o(e, t) {
                            for (var n = 0; n < t.length; n++) {
                              var r = t[n];
                              r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
                            }
                          }
                          Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
                          var i = (function () {
                            function e() {
                              !function (e, t) {
                                if (!(e instanceof t))
                                  throw new TypeError("Cannot call a class as a function");
                              }(this || _global, e);
                            }
                            return function (e, t, n) {
                              t && o(e.prototype, t), n && o(e, n);
                            }(e, [
                              {
                                key: "init",
                                value: function (e, t, n, o) {
                                  if (arguments.length < 2)
                                    throw new Error("init: invalid number of arguments");
                                  if ((this || _global).ctx = e, (this || _global).ASTy = !0, (this || _global).T = t, (this || _global).L = {
                                      L: 0,
                                      C: 0,
                                      O: 0
                                    }, (this || _global).A = {}, (this || _global).C = [], (this || _global).P = null, "object" === r(n))
                                    for (var i in n)
                                      Object.prototype.hasOwnProperty.call(n, i) && this.set(i, n[i]);
                                  return "object" === r(o) && o instanceof Array && this.add(o), this || _global;
                                }
                              },
                              {
                                key: "create",
                                value: function (e, t, n) {
                                  return (this || _global).ctx.create(e, t, n);
                                }
                              },
                              {
                                key: "type",
                                value: function (e) {
                                  if (0 === arguments.length)
                                    return (this || _global).T;
                                  if (1 === arguments.length)
                                    return (this || _global).T = e, this || _global;
                                  throw new Error("type: invalid number of arguments");
                                }
                              },
                              {
                                key: "pos",
                                value: function (e, t, n) {
                                  if (0 === arguments.length)
                                    return {
                                      line: (this || _global).L.L,
                                      column: (this || _global).L.C,
                                      offset: (this || _global).L.O
                                    };
                                  if (arguments.length <= 3)
                                    return (this || _global).L.L = e || 0, (this || _global).L.C = t || 0, (this || _global).L.O = n || 0, this || _global;
                                  throw new Error("pos: invalid number of arguments");
                                }
                              },
                              {
                                key: "set",
                                value: function () {
                                  for (var e = this || _global, t = arguments.length, n = new Array(t), o = 0; o < t; o++)
                                    n[o] = arguments[o];
                                  if (1 === n.length && "object" === r(n[0]))
                                    Object.keys(n[0]).forEach(function (t) {
                                      void 0 !== n[0][t] ? e.A[t] = n[0][t] : delete e.A[t];
                                    });
                                  else {
                                    if (2 !== n.length)
                                      throw new Error("set: invalid number of arguments");
                                    void 0 !== n[1] ? (this || _global).A[n[0]] = n[1] : delete (this || _global).A[n[0]];
                                  }
                                  return this || _global;
                                }
                              },
                              {
                                key: "unset",
                                value: function () {
                                  for (var e = this || _global, t = arguments.length, n = new Array(t), o = 0; o < t; o++)
                                    n[o] = arguments[o];
                                  if (1 === n.length && "object" === r(n[0]) && n[0] instanceof Array)
                                    n[0].forEach(function (t) {
                                      delete e.A[t];
                                    });
                                  else {
                                    if (1 !== n.length)
                                      throw new Error("unset: invalid number of arguments");
                                    delete (this || _global).A[n[0]];
                                  }
                                  return this || _global;
                                }
                              },
                              {
                                key: "get",
                                value: function () {
                                  for (var e = this || _global, t = arguments.length, n = new Array(t), o = 0; o < t; o++)
                                    n[o] = arguments[o];
                                  if (1 !== n.length)
                                    throw new Error("get: invalid number of arguments");
                                  if ("object" === r(n[0]) && n[0] instanceof Array)
                                    return n[0].map(function (t) {
                                      if ("string" != typeof t)
                                        throw new Error("get: invalid key argument");
                                      return e.A[t];
                                    });
                                  var i = n[0];
                                  if ("string" != typeof i)
                                    throw new Error("get: invalid key argument");
                                  return (this || _global).A[i];
                                }
                              },
                              {
                                key: "attrs",
                                value: function () {
                                  return Object.keys((this || _global).A);
                                }
                              },
                              {
                                key: "nth",
                                value: function () {
                                  if (null === (this || _global).P)
                                    return 1;
                                  var e = (this || _global).P.C.indexOf(this || _global);
                                  if (e < 0)
                                    throw new Error("nth: internal error -- node not in childs of its parent");
                                  return e;
                                }
                              },
                              {
                                key: "ins",
                                value: function (e) {
                                  for (var t = this || _global, n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
                                    o[i - 1] = arguments[i];
                                  if (0 === o.length)
                                    throw new Error("ins: invalid number of arguments");
                                  if (e < 0 && (e = (this || _global).C.length + 1 - e), !(e >= 0 && e <= (this || _global).C.length))
                                    throw new Error("ins: invalid position");
                                  var a = function (n) {
                                    if (!t.ctx.isA(n))
                                      throw new Error("ins: invalid AST node argument");
                                    t.C.splice(e++, 0, n), n.P = t;
                                  };
                                  return o.forEach(function (e) {
                                    "object" === r(e) && e instanceof Array ? e.forEach(function (e) {
                                      a(e);
                                    }) : null !== e && a(e);
                                  }), this || _global;
                                }
                              },
                              {
                                key: "add",
                                value: function () {
                                  for (var e = this || _global, t = arguments.length, n = new Array(t), o = 0; o < t; o++)
                                    n[o] = arguments[o];
                                  if (0 === n.length)
                                    throw new Error("add: invalid number of arguments");
                                  var i = function (t) {
                                    if (!e.ctx.isA(t))
                                      throw new Error("add: invalid AST node argument");
                                    e.C.push(t), t.P = e;
                                  };
                                  return n.forEach(function (e) {
                                    "object" === r(e) && e instanceof Array ? e.forEach(function (e) {
                                      i(e);
                                    }) : null !== e && i(e);
                                  }), this || _global;
                                }
                              },
                              {
                                key: "del",
                                value: function () {
                                  for (var e = this || _global, t = arguments.length, n = new Array(t), r = 0; r < t; r++)
                                    n[r] = arguments[r];
                                  if (0 === n.length)
                                    throw new Error("del: invalid number of arguments");
                                  return n.forEach(function (t) {
                                    if (!e.ctx.isA(t))
                                      throw new Error("del: invalid AST node argument");
                                    for (var n = !1, r = 0; r < e.C.length; r++)
                                      if (e.C[r] === t) {
                                        e.C.splice(r, 1), t.P = null, n = !0;
                                        break;
                                      }
                                    if (!n)
                                      throw new Error("del: AST node not found in childs");
                                  }), this || _global;
                                }
                              },
                              {
                                key: "childs",
                                value: function () {
                                  if (arguments.length > 2)
                                    throw new Error("childs: invalid number of arguments");
                                  if (2 === arguments.length && "number" == typeof (arguments.length <= 0 ? void 0 : arguments[0]) && "number" == typeof (arguments.length <= 1 ? void 0 : arguments[1]))
                                    return (this || _global).C.slice(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1]);
                                  if (1 === arguments.length && "number" == typeof (arguments.length <= 0 ? void 0 : arguments[0]))
                                    return (this || _global).C.slice(arguments.length <= 0 ? void 0 : arguments[0]);
                                  if (0 === arguments.length)
                                    return (this || _global).C;
                                  throw new Error("childs: invalid type of arguments");
                                }
                              },
                              {
                                key: "child",
                                value: function (e) {
                                  if ("number" != typeof e)
                                    throw new Error("child: invalid argument");
                                  return e < (this || _global).C.length ? (this || _global).C[e] : null;
                                }
                              },
                              {
                                key: "parent",
                                value: function () {
                                  return (this || _global).P;
                                }
                              },
                              {
                                key: "serialize",
                                value: function () {
                                  return (this || _global).ctx.__serialize(this || _global);
                                }
                              }
                            ]), e;
                          }());
                          n.default = i;
                        },
                        {}
                      ],
                      2: [
                        function (e, t, n) {
                          function r(e) {
                            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                              return typeof e;
                            } : function (e) {
                              return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                            })(e);
                          }
                          function o(e, t) {
                            for (var n = 0; n < t.length; n++) {
                              var r = t[n];
                              r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
                            }
                          }
                          Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
                          var i = {
                              mid: {
                                unicode: String.fromCharCode(9500),
                                ascii: "+"
                              },
                              last: {
                                unicode: String.fromCharCode(9492),
                                ascii: "+"
                              },
                              down: {
                                unicode: String.fromCharCode(9474),
                                ascii: "|"
                              },
                              left: {
                                unicode: String.fromCharCode(9472),
                                ascii: "-"
                              }
                            }, a = (function () {
                              function e() {
                                !function (e, t) {
                                  if (!(e instanceof t))
                                    throw new TypeError("Cannot call a class as a function");
                                }(this || _global, e);
                              }
                              return function (e, t, n) {
                                t && o(e.prototype, t), n && o(e, n);
                              }(e, [{
                                  key: "dump",
                                  value: function () {
                                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1 / 0, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function (e, t) {
                                        return t;
                                      }, n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], o = "", a = this || _global;
                                    return this.walk(function (u, f) {
                                      if (!(f > e)) {
                                        if (f > 0) {
                                          var c = function (e) {
                                              var t = 0, n = 0;
                                              return null !== e.P && (t = e.P.C.indexOf(e), n = e.P.C.length - 1), {
                                                nth: t,
                                                max: n
                                              };
                                            }, l = c(u), s = l.nth, h = l.max, d = " ";
                                          d = n ? "".concat(i.left.unicode).concat(i.left.unicode).concat(d) : "".concat(i.left.ascii).concat(i.left.ascii).concat(d), d = s < h ? "".concat(n ? i.mid.unicode : i.mid.ascii).concat(d) : "".concat(n ? i.last.unicode : i.last.ascii).concat(d);
                                          for (var y = u.P; null !== y && y !== a; y = y.P)
                                            if (null !== y.P) {
                                              var v = c(y);
                                              d = v.nth < v.max ? "".concat(n ? i.down.unicode : i.down.ascii, "   ").concat(d) : "    ".concat(d);
                                            }
                                          o += t("tree", d);
                                        }
                                        o += t("type", u.T) + " ";
                                        var p = Object.keys(u.A).filter(function (e) {
                                          return !e.match(/^__/);
                                        });
                                        if (p.length > 0) {
                                          o += t("parenthesis", "(");
                                          var b = !0;
                                          p.forEach(function (e) {
                                            b ? b = !1 : o += t("comma", ",") + " ", o += t("key", e) + t("colon", ":") + " ";
                                            var n = u.A[e];
                                            switch (r(n)) {
                                            case "boolean":
                                            case "number":
                                              o += t("value", n.toString());
                                              break;
                                            case "string":
                                              var i = function (e) {
                                                return e.charCodeAt(0).toString(16).toUpperCase();
                                              };
                                              o += t("value", "\"" + n.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (e) {
                                                return "\\x0" + i(e);
                                              }).replace(/[\x10-\x1F\x80-\xFF]/g, function (e) {
                                                return "\\x" + i(e);
                                              }).replace(/[\u0100-\u0FFF]/g, function (e) {
                                                return "\\u0" + i(e);
                                              }).replace(/[\u1000-\uFFFF]/g, function (e) {
                                                return "\\u" + i(e);
                                              }) + "\"");
                                              break;
                                            case "object":
                                              n instanceof RegExp ? o += t("value", "/" + n.source + "/") : o += t("value", JSON.stringify(n));
                                              break;
                                            default:
                                              o += t("value", JSON.stringify(n));
                                            }
                                          }), o += t("parenthesis", ")") + " ";
                                        }
                                        o += t("position", t("bracket", "[") + t("line", u.L.L) + t("slash", ",") + t("column", u.L.C) + t("bracket", "]")), o += "\n";
                                      }
                                    }, "downward"), o;
                                  }
                                }]), e;
                            }());
                          n.default = a;
                        },
                        {}
                      ],
                      3: [
                        function (e, t, n) {
                          function r(e, t) {
                            for (var n = 0; n < t.length; n++) {
                              var r = t[n];
                              r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
                            }
                          }
                          Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
                          var o = (function () {
                            function e() {
                              !function (e, t) {
                                if (!(e instanceof t))
                                  throw new TypeError("Cannot call a class as a function");
                              }(this || _global, e);
                            }
                            return function (e, t, n) {
                              t && r(e.prototype, t), n && r(e, n);
                            }(e, [{
                                key: "merge",
                                value: function (e) {
                                  var t = this || _global, n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                                  if (null === e)
                                    return this || _global;
                                  if (!(this || _global).ctx.isA(e))
                                    throw new Error("merge: invalid AST node argument");
                                  if (n) {
                                    var o = e.pos();
                                    this.pos(o.line, o.column, o.offset);
                                  }
                                  e.attrs().forEach(function (n) {
                                    var o = void 0 !== r[n] ? r[n] : n;
                                    null !== o && t.set(o, e.get(n));
                                  }), e.childs().forEach(function (n) {
                                    e.del(n), t.add(n);
                                  });
                                  var i = e.parent();
                                  return null !== i && i.del(e), this || _global;
                                }
                              }]), e;
                          }());
                          n.default = o;
                        },
                        {}
                      ],
                      4: [
                        function (e, t, n) {
                          function r(e) {
                            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                              return typeof e;
                            } : function (e) {
                              return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                            })(e);
                          }
                          function o(e, t) {
                            for (var n = 0; n < t.length; n++) {
                              var r = t[n];
                              r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
                            }
                          }
                          Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
                          var i = (function () {
                            function e() {
                              !function (e, t) {
                                if (!(e instanceof t))
                                  throw new TypeError("Cannot call a class as a function");
                              }(this || _global, e);
                            }
                            return function (e, t, n) {
                              t && o(e.prototype, t), n && o(e, n);
                            }(e, null, [
                              {
                                key: "serialize",
                                value: function (e, t) {
                                  if (!e.isA(t))
                                    throw new Error("serialize: not an ASTy node");
                                  return JSON.stringify({
                                    ASTy: function e(t) {
                                      var n = {
                                          T: t.T,
                                          L: {
                                            L: t.L.L,
                                            C: t.L.C,
                                            O: t.L.O
                                          }
                                        }, o = Object.keys(t.A);
                                      return o.length > 0 && (n.A = {}, o.forEach(function (e) {
                                        var o = t.A[e];
                                        switch (r(o)) {
                                        case "boolean":
                                        case "number":
                                        case "string":
                                          n.A[e] = o;
                                          break;
                                        default:
                                          n.A[e] = JSON.parse(JSON.stringify(o));
                                        }
                                      })), t.C.length > 0 && (n.C = t.C.map(function (t) {
                                        return e(t);
                                      })), n;
                                    }(t)
                                  });
                                }
                              },
                              {
                                key: "unserialize",
                                value: function (e, t) {
                                  var n = JSON.parse(t);
                                  if ("object" !== r(n) || "object" !== r(n.ASTy))
                                    throw new Error("unserialize: not an ASTy JSON export");
                                  return function t(n) {
                                    var o = e.create(n.T);
                                    return o.pos(n.L.L, n.L.C, n.L.O), "object" === r(n.A) && Object.keys(n.A).forEach(function (e) {
                                      var t = n.A[e];
                                      switch (r(t)) {
                                      case "boolean":
                                      case "number":
                                      case "string":
                                        o.set(e, t);
                                        break;
                                      default:
                                        o.set(e, JSON.parse(JSON.stringify(t)));
                                      }
                                    }), "object" === r(n.C) && n.C instanceof Array && o.add(n.C.map(function (e) {
                                      return t(e);
                                    })), o;
                                  }(n.ASTy);
                                }
                              }
                            ]), e;
                          }());
                          n.default = i;
                        },
                        {}
                      ],
                      5: [
                        function (e, t, n) {
                          Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
                          var r = {
                            major: 1,
                            minor: 8,
                            micro: 13,
                            date: 20210107
                          };
                          n.default = r;
                        },
                        {}
                      ],
                      6: [
                        function (e, t, n) {
                          function r(e, t) {
                            for (var n = 0; n < t.length; n++) {
                              var r = t[n];
                              r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
                            }
                          }
                          Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
                          var o = (function () {
                            function e() {
                              !function (e, t) {
                                if (!(e instanceof t))
                                  throw new TypeError("Cannot call a class as a function");
                              }(this || _global, e);
                            }
                            return function (e, t, n) {
                              t && r(e.prototype, t), n && r(e, n);
                            }(e, [{
                                key: "walk",
                                value: function (e) {
                                  var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "downward";
                                  return function n(r, o, i) {
                                    "downward" !== t && "both" !== t || e(r, o, i, "downward"), r.C.forEach(function (e) {
                                      n(e, o + 1, r);
                                    }), "upward" !== t && "both" !== t || e(r, o, i, "upward");
                                  }(this || _global, 0, null), this || _global;
                                }
                              }]), e;
                          }());
                          n.default = o;
                        },
                        {}
                      ],
                      7: [
                        function (e, t, n) {
                          var r = c(e("./asty-base.js")), o = c(e("./asty-merge.js")), i = c(e("./asty-walk.js")), a = c(e("./asty-dump.js")), u = c(e("./asty-serialize.js")), f = c(e("./asty-version.js"));
                          function c(e) {
                            return e && e.__esModule ? e : { default: e };
                          }
                          function l(e) {
                            return (l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                              return typeof e;
                            } : function (e) {
                              return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                            })(e);
                          }
                          function s(e, t) {
                            if (!(e instanceof t))
                              throw new TypeError("Cannot call a class as a function");
                          }
                          function h(e, t) {
                            for (var n = 0; n < t.length; n++) {
                              var r = t[n];
                              r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
                            }
                          }
                          var d = (function () {
                            function e() {
                              var t = this || _global;
                              return s(this || _global, e), (this || _global).ASTYNode = function e() {
                                s(this || _global, e);
                              }, [
                                [
                                  r.default,
                                  "init",
                                  "create",
                                  "type",
                                  "pos",
                                  "set",
                                  "unset",
                                  "get",
                                  "attrs",
                                  "nth",
                                  "ins",
                                  "add",
                                  "del",
                                  "childs",
                                  "child",
                                  "parent",
                                  "serialize"
                                ],
                                [
                                  o.default,
                                  "merge"
                                ],
                                [
                                  i.default,
                                  "walk"
                                ],
                                [
                                  a.default,
                                  "dump"
                                ]
                              ].forEach(function (e) {
                                var n = e[0].prototype;
                                e.slice(1).forEach(function (e) {
                                  t.ASTYNode.prototype[e] = n[e];
                                });
                              }), this || _global;
                            }
                            return function (e, t, n) {
                              t && h(e.prototype, t), n && h(e, n);
                            }(e, [
                              {
                                key: "version",
                                value: function () {
                                  return f.default;
                                }
                              },
                              {
                                key: "extend",
                                value: function (e) {
                                  for (var t in e)
                                    Object.prototype.hasOwnProperty.call(e, t) && ((this || _global).ASTYNode.prototype[t] = e[t]);
                                  return this || _global;
                                }
                              },
                              {
                                key: "create",
                                value: function (e, t, n) {
                                  return new (this || _global).ASTYNode().init(this || _global, e, t, n);
                                }
                              },
                              {
                                key: "isA",
                                value: function (e) {
                                  return "object" === l(e) && e instanceof (this || _global).ASTYNode && "boolean" == typeof e.ASTy && !0 === e.ASTy;
                                }
                              },
                              {
                                key: "__serialize",
                                value: function (t) {
                                  return e.serialize(t);
                                }
                              }
                            ], [
                              {
                                key: "serialize",
                                value: function (e) {
                                  return u.default.serialize(e.ctx, e);
                                }
                              },
                              {
                                key: "unserialize",
                                value: function (e) {
                                  return u.default.unserialize(new (this || _global)(), e);
                                }
                              }
                            ]), e;
                          }());
                          t.exports = d;
                        },
                        {
                          "./asty-base.js": 1,
                          "./asty-dump.js": 2,
                          "./asty-merge.js": 3,
                          "./asty-serialize.js": 4,
                          "./asty-version.js": 5,
                          "./asty-walk.js": 6
                        }
                      ]
                    }, {}, [
                      1,
                      2,
                      3,
                      4,
                      5,
                      6,
                      7
                    ])(7);
                  });
                }.call(this || _global));
              }.call(this || _global, typeof _global !== "undefined" ? _global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}));
            },
            {}
          ],
          2: [
            function (_dereq_, module, exports) {
              (function (global) {
                (function () {
                  !function (e) {
                    if ("object" == typeof exports && "undefined" != typeof module)
                      module.exports = e();
                    else {
                      ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this || _global).CacheLRU = e();
                    }
                  }(function () {
                    return function () {
                      return function e(t, i, n) {
                        function r(u, s) {
                          if (!i[u]) {
                            if (!t[u]) {
                              var l = "function" == typeof _dereq_ && _dereq_;
                              if (!s && l)
                                return l(u, !0);
                              if (o)
                                return o(u, !0);
                              var h = new Error("Cannot find module '" + u + "'");
                              throw h.code = "MODULE_NOT_FOUND", h;
                            }
                            var a = i[u] = { exports: {} };
                            t[u][0].call(a.exports, function (e) {
                              return r(t[u][1][e] || e);
                            }, a, a.exports, e, t, i, n);
                          }
                          return i[u].exports;
                        }
                        for (var o = "function" == typeof _dereq_ && _dereq_, u = 0; u < n.length; u++)
                          r(n[u]);
                        return r;
                      };
                    }()({
                      1: [
                        function (e, t, i) {
                          function n(e, t) {
                            for (var i = 0; i < t.length; i++) {
                              var n = t[i];
                              n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
                            }
                          }
                          var r = (function () {
                            function e() {
                              return function (e, t) {
                                if (!(e instanceof t))
                                  throw new TypeError("Cannot call a class as a function");
                              }(this || _global, e), (this || _global)._index = {}, (this || _global)._LRU = { newer: null }, (this || _global)._MRU = { older: null }, (this || _global)._LRU.newer = (this || _global)._MRU, (this || _global)._MRU.older = (this || _global)._LRU, (this || _global)._cur = 0, (this || _global)._max = 1 / 0, (this || _global)._dispose = function () {
                              }, this || _global;
                            }
                            return function (e, t, i) {
                              t && n(e.prototype, t), i && n(e, i);
                            }(e, [
                              {
                                key: "limit",
                                value: function (e) {
                                  var t = (this || _global)._max;
                                  return arguments.length > 0 && ((this || _global)._max = e, this._purge()), t;
                                }
                              },
                              {
                                key: "dispose",
                                value: function (e) {
                                  return (this || _global)._dispose = e, this || _global;
                                }
                              },
                              {
                                key: "length",
                                value: function () {
                                  return (this || _global)._cur;
                                }
                              },
                              {
                                key: "keys",
                                value: function () {
                                  return this.each(function (e, t) {
                                    this.push(t);
                                  }, []);
                                }
                              },
                              {
                                key: "values",
                                value: function () {
                                  return this.each(function (e) {
                                    this.push(e);
                                  }, []);
                                }
                              },
                              {
                                key: "each",
                                value: function (e, t) {
                                  arguments < 2 && (t = this || _global);
                                  for (var i = 0, n = (this || _global)._MRU.older; n !== (this || _global)._LRU;)
                                    e.call(t, n.val, n.key, i++), n = n.older;
                                  return t;
                                }
                              },
                              {
                                key: "has",
                                value: function (e) {
                                  var t = (this || _global)._index[e];
                                  return void 0 !== t && t.expires >= Date.now();
                                }
                              },
                              {
                                key: "peek",
                                value: function (e) {
                                  var t = (this || _global)._index[e];
                                  if (void 0 !== t) {
                                    if (!(t.expires < Date.now()))
                                      return t.val;
                                    this.del(t.key);
                                  }
                                }
                              },
                              {
                                key: "touch",
                                value: function (e) {
                                  var t = (this || _global)._index[e];
                                  if (void 0 === t)
                                    throw new Error("touch: no such item");
                                  return this._promote(t), this || _global;
                                }
                              },
                              {
                                key: "get",
                                value: function (e) {
                                  var t = (this || _global)._index[e];
                                  if (void 0 !== t) {
                                    if (!(t.expires < Date.now()))
                                      return this._promote(t), t.val;
                                    this.del(t.key);
                                  }
                                }
                              },
                              {
                                key: "set",
                                value: function (e, t, i) {
                                  arguments.length < 3 && (i = 1 / 0), i += Date.now();
                                  var n = (this || _global)._index[e];
                                  if (void 0 === n)
                                    n = {
                                      older: null,
                                      newer: null,
                                      key: e,
                                      val: t,
                                      expires: i
                                    }, (this || _global)._index[e] = n, this._attach(n), (this || _global)._cur++, this._purge();
                                  else {
                                    var r = n.val;
                                    n.val = t, this._promote(n), (this || _global)._dispose.call(void 0, n.key, r, "set");
                                  }
                                  return this || _global;
                                }
                              },
                              {
                                key: "del",
                                value: function (e) {
                                  var t = (this || _global)._index[e];
                                  if (void 0 === t)
                                    throw new Error("del: no such item");
                                  return delete (this || _global)._index[e], this._detach(t), (this || _global)._cur--, (this || _global)._dispose.call(void 0, e, t.val, "del"), this || _global;
                                }
                              },
                              {
                                key: "clear",
                                value: function () {
                                  for (; (this || _global)._cur > 0;)
                                    this.del((this || _global)._LRU.newer.key);
                                  return this || _global;
                                }
                              },
                              {
                                key: "_purge",
                                value: function () {
                                  for (; (this || _global)._cur > (this || _global)._max;)
                                    this.del((this || _global)._LRU.newer.key);
                                }
                              },
                              {
                                key: "_promote",
                                value: function (e) {
                                  this._detach(e), this._attach(e);
                                }
                              },
                              {
                                key: "_detach",
                                value: function (e) {
                                  e.older.newer = e.newer, e.newer.older = e.older, e.older = null, e.newer = null;
                                }
                              },
                              {
                                key: "_attach",
                                value: function (e) {
                                  e.older = (this || _global)._MRU.older, e.newer = (this || _global)._MRU, e.newer.older = e, e.older.newer = e;
                                }
                              }
                            ]), e;
                          }());
                          t.exports = r;
                        },
                        {}
                      ]
                    }, {}, [1])(1);
                  });
                }.call(this || _global));
              }.call(this || _global, typeof _global !== "undefined" ? _global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}));
            },
            {}
          ],
          3: [
            function (_dereq_, module, exports) {
              (function (global) {
                (function () {
                  !function (e, n, r) {
                    "object" == typeof module && "object" == typeof module.exports ? module.exports = r() : e.PEGUtil = r();
                  }("undefined" != typeof global ? global : "undefined" != typeof window ? window : this || _global, 0, function () {
                    var e = {
                        makeAST: function (e, n) {
                          return function () {
                            return n.util.__makeAST.call(null, e().start.line, e().start.column, e().start.offset, arguments);
                          };
                        },
                        makeUnroll: function (e, n) {
                          return function (r, t, o) {
                            if ("object" != typeof t || !(t instanceof Array))
                              throw new n.util.__SyntaxError("unroll: invalid list argument for unrolling", typeof t, "Array", e());
                            if (void 0 !== o) {
                              "number" == typeof o && (o = [o]);
                              var l = [];
                              null !== r && l.push(r);
                              for (var a = 0; a < t.length; a++)
                                for (var i = 0; i < o.length; i++)
                                  l.push(t[a][o[i]]);
                              return l;
                            }
                            return null !== r && t.unshift(r), t;
                          };
                        }
                      }, n = function (e, n) {
                        var r = e.length, t = n - 20;
                        t < 0 && (t = 0);
                        var o = n + 20;
                        o > r && (o = r);
                        var l = function (e) {
                            return e.charCodeAt(0).toString(16).toUpperCase();
                          }, a = function (e, n, r) {
                            return e.substr(n, r).replace(/\\/g, "\\\\").replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (e) {
                              return "\\x0" + l(e);
                            }).replace(/[\x10-\x1F\x80-\xFF]/g, function (e) {
                              return "\\x" + l(e);
                            }).replace(/[\u0100-\u0FFF]/g, function (e) {
                              return "\\u0" + l(e);
                            }).replace(/[\u1000-\uFFFF]/g, function (e) {
                              return "\\u" + l(e);
                            });
                          };
                        return {
                          prolog: a(e, t, n - t),
                          token: a(e, n, 1),
                          epilog: a(e, n + 1, o - (n + 1))
                        };
                      };
                    return e.parse = function (r, t, o) {
                      if ("object" != typeof r)
                        throw new Error("invalid parser object (not an object)");
                      if ("function" != typeof r.parse)
                        throw new Error("invalid parser object (no \"parse\" function)");
                      if ("string" != typeof t)
                        throw new Error("invalid input text (not a string)");
                      if (void 0 !== o && "object" != typeof o)
                        throw new Error("invalid options (not an object)");
                      void 0 === o && (o = {});
                      var l = {
                        ast: null,
                        error: null
                      };
                      try {
                        var a;
                        a = "function" == typeof o.makeAST ? o.makeAST : function (e, n) {
                          return {
                            line: e().start.line,
                            column: e().start.column,
                            offset: e().start.offset,
                            args: n
                          };
                        }, o.util = {
                          makeUnroll: e.makeUnroll,
                          makeAST: e.makeAST,
                          __makeAST: a,
                          __SyntaxError: r.SyntaxError
                        }, l.ast = r.parse(t, o), l.error = null;
                      } catch (e) {
                        if (l.ast = null, e instanceof r.SyntaxError) {
                          var i = function (e, n) {
                            return void 0 !== e ? e : n;
                          };
                          l.error = {
                            line: i(e.location.start.line, 0),
                            column: i(e.location.start.column, 0),
                            message: e.message,
                            found: i(e.found, ""),
                            expected: i(e.expected, ""),
                            location: n(t, i(e.location.start.offset, 0))
                          };
                        } else
                          l.error = {
                            line: 0,
                            column: 0,
                            message: e.message,
                            found: "",
                            expected: "",
                            location: n("", 0)
                          };
                      }
                      return l;
                    }, e.errorMessage = function (e, n) {
                      for (var r = e.location, t = "line " + e.line + " (column " + e.column + "): ", o = "", l = 0; l < t.length + r.prolog.length; l++)
                        o += "-";
                      return t + r.prolog + r.token + r.epilog + "\n" + o + "^\n" + e.message + (n ? "" : "\n");
                    }, e;
                  });
                }.call(this || _global));
              }.call(this || _global, typeof _global !== "undefined" ? _global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}));
            },
            {}
          ],
          4: [
            function (_dereq_, module, exports) {
              function _typeof(e) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                  return typeof e;
                } : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                })(e);
              }
              function _classCallCheck(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(e, t) {
                for (var n = 0; n < t.length; n++) {
                  var o = t[n];
                  o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
                }
              }
              function _createClass(e, t, n) {
                return t && _defineProperties(e.prototype, t), n && _defineProperties(e, n), e;
              }
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var ASTQAdapterASTY = (function () {
                function e() {
                  _classCallCheck(this || _global, e);
                }
                return _createClass(e, null, [
                  {
                    key: "taste",
                    value: function (e) {
                      return "object" === _typeof(e) && null !== e && "boolean" == typeof e.ASTy;
                    }
                  },
                  {
                    key: "getParentNode",
                    value: function (e) {
                      return e.parent();
                    }
                  },
                  {
                    key: "getChildNodes",
                    value: function (e) {
                      return e.childs();
                    }
                  },
                  {
                    key: "getNodeType",
                    value: function (e) {
                      return e.type();
                    }
                  },
                  {
                    key: "getNodeAttrNames",
                    value: function (e) {
                      return e.attrs();
                    }
                  },
                  {
                    key: "getNodeAttrValue",
                    value: function (e, t) {
                      return e.get(t);
                    }
                  }
                ]), e;
              }());
              exports.default = ASTQAdapterASTY;
            },
            {}
          ],
          5: [
            function (_dereq_, module, exports) {
              function _typeof(e) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                  return typeof e;
                } : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                })(e);
              }
              function _classCallCheck(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(e, t) {
                for (var o = 0; o < t.length; o++) {
                  var n = t[o];
                  n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
                }
              }
              function _createClass(e, t, o) {
                return t && _defineProperties(e.prototype, t), o && _defineProperties(e, o), e;
              }
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var ASTQAdapterCheerio = (function () {
                function e() {
                  _classCallCheck(this || _global, e);
                }
                return _createClass(e, null, [
                  {
                    key: "taste",
                    value: function (e) {
                      return "object" === _typeof(e) && null !== e && !("object" === ("undefined" == typeof Node ? "undefined" : _typeof(Node)) && e instanceof Node) && "string" == typeof e.tagName && "" !== e.tagName;
                    }
                  },
                  {
                    key: "getParentNode",
                    value: function (e) {
                      return e.parentNode;
                    }
                  },
                  {
                    key: "getChildNodes",
                    value: function (e) {
                      return "object" === _typeof(e.childNodes) && e.childNodes instanceof Array ? e.childNodes : [];
                    }
                  },
                  {
                    key: "getNodeType",
                    value: function (e) {
                      return e.tagName || "#".concat(e.type || "unknown");
                    }
                  },
                  {
                    key: "getNodeAttrNames",
                    value: function (e) {
                      var t = ["value"];
                      return "object" === _typeof(e.attribs) && (t = t.concat(Object.keys(e.attribs))), t;
                    }
                  },
                  {
                    key: "getNodeAttrValue",
                    value: function (e, t) {
                      var o;
                      return "value" === t ? o = e.nodeValue : "object" === _typeof(e.attribs) && (o = e.attribs[t]), o;
                    }
                  }
                ]), e;
              }());
              exports.default = ASTQAdapterCheerio;
            },
            {}
          ],
          6: [
            function (_dereq_, module, exports) {
              function _typeof(e) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                  return typeof e;
                } : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                })(e);
              }
              function _classCallCheck(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(e, t) {
                for (var o = 0; o < t.length; o++) {
                  var r = t[o];
                  r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
                }
              }
              function _createClass(e, t, o) {
                return t && _defineProperties(e.prototype, t), o && _defineProperties(e, o), e;
              }
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var ASTQAdapterGraphQL = (function () {
                function e() {
                  _classCallCheck(this || _global, e);
                }
                return _createClass(e, null, [
                  {
                    key: "taste",
                    value: function (e) {
                      return "object" === _typeof(e) && null !== e && "string" == typeof e.kind && "" !== e.kind;
                    }
                  },
                  {
                    key: "getParentNode",
                    value: function (e, t) {
                      throw new Error("GraphQL AST does not support parent node traversal");
                    }
                  },
                  {
                    key: "getChildNodes",
                    value: function (e, t) {
                      var o = this || _global, r = [], n = function (e, t) {
                          Object.prototype.hasOwnProperty.call(e, t) && o.taste(e[t]) ? r.push(e[t]) : Object.prototype.hasOwnProperty.call(e, t) && "object" === _typeof(e[t]) && e[t] instanceof Array && e[t].forEach(function (e) {
                            o.taste(e) && r.push(e);
                          });
                        };
                      if ("*" === t)
                        for (var a in e)
                          n(e, a);
                      else
                        void 0 !== e[t] && n(e, t);
                      return r;
                    }
                  },
                  {
                    key: "getNodeType",
                    value: function (e) {
                      return e.kind;
                    }
                  },
                  {
                    key: "getNodeAttrNames",
                    value: function (e) {
                      var t = [];
                      for (var o in e)
                        Object.prototype.hasOwnProperty.call(e, o) && "object" !== _typeof(e[o]) && "kind" !== o && "loc" !== o && t.push(o);
                      return t;
                    }
                  },
                  {
                    key: "getNodeAttrValue",
                    value: function (e, t) {
                      return Object.prototype.hasOwnProperty.call(e, t) && "object" !== _typeof(e[t]) && "kind" !== t && "loc" !== t ? e[t] : void 0;
                    }
                  }
                ]), e;
              }());
              exports.default = ASTQAdapterGraphQL;
            },
            {}
          ],
          7: [
            function (_dereq_, module, exports) {
              function _typeof(e) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                  return typeof e;
                } : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                })(e);
              }
              function _classCallCheck(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(e, t) {
                for (var o = 0; o < t.length; o++) {
                  var n = t[o];
                  n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
                }
              }
              function _createClass(e, t, o) {
                return t && _defineProperties(e.prototype, t), o && _defineProperties(e, o), e;
              }
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var ASTQAdapterJSON = (function () {
                function e() {
                  _classCallCheck(this || _global, e);
                }
                return _createClass(e, null, [
                  {
                    key: "taste",
                    value: function (e) {
                      return "object" === _typeof(e) && null !== e;
                    }
                  },
                  {
                    key: "getParentNode",
                    value: function (e, t) {
                      throw new Error("JSON does not support parent node traversal");
                    }
                  },
                  {
                    key: "getChildNodes",
                    value: function (e, t) {
                      var o = this || _global, n = [], r = function (e, t) {
                          Object.prototype.hasOwnProperty.call(e, t) && o.taste(e[t]) ? n.push(e[t]) : Object.prototype.hasOwnProperty.call(e, t) && "object" === _typeof(e[t]) && e[t] instanceof Array && e[t].forEach(function (e) {
                            o.taste(e) && n.push(e);
                          });
                        };
                      if ("*" === t)
                        for (var a in e)
                          r(e, a);
                      else
                        void 0 !== e[t] && r(e, t);
                      return n;
                    }
                  },
                  {
                    key: "getNodeType",
                    value: function (e) {
                      return null === e ? "Null" : e instanceof Boolean ? "Boolean" : e instanceof Number ? "Number" : e instanceof String ? "String" : "object" === _typeof(e) ? e instanceof Array ? "Array" : "function" == typeof e.constructor && "string" == typeof e.constructor.name ? e.constructor.name : "Object" : "Unknown";
                    }
                  },
                  {
                    key: "getNodeAttrNames",
                    value: function (e) {
                      var t = [];
                      for (var o in e)
                        Object.prototype.hasOwnProperty.call(e, o) && "object" !== _typeof(e[o]) && t.push(o);
                      return t;
                    }
                  },
                  {
                    key: "getNodeAttrValue",
                    value: function (e, t) {
                      return Object.prototype.hasOwnProperty.call(e, t) && "object" !== _typeof(e[t]) ? e[t] : void 0;
                    }
                  }
                ]), e;
              }());
              exports.default = ASTQAdapterJSON;
            },
            {}
          ],
          8: [
            function (_dereq_, module, exports) {
              function _typeof(e) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                  return typeof e;
                } : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                })(e);
              }
              function _classCallCheck(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(e, t) {
                for (var o = 0; o < t.length; o++) {
                  var r = t[o];
                  r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
                }
              }
              function _createClass(e, t, o) {
                return t && _defineProperties(e.prototype, t), o && _defineProperties(e, o), e;
              }
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var ASTQAdapterMozAST = (function () {
                function e() {
                  _classCallCheck(this || _global, e);
                }
                return _createClass(e, null, [
                  {
                    key: "taste",
                    value: function (e) {
                      return "object" === _typeof(e) && null !== e && "string" == typeof e.type && "" !== e.type;
                    }
                  },
                  {
                    key: "getParentNode",
                    value: function (e, t) {
                      if ("*" !== t && "parent" !== t)
                        throw new Error("no such axis named \"" + t + "\" for walking to parent nodes");
                      if (void 0 !== e.parent)
                        return e.parent;
                      throw new Error("Your Mozilla SpiderMonkey AST does not support parent node traversal");
                    }
                  },
                  {
                    key: "getChildNodes",
                    value: function (e, t) {
                      var o = this || _global, r = [], n = function (e, t) {
                          Object.prototype.hasOwnProperty.call(e, t) && o.taste(e[t]) ? r.push(e[t]) : Object.prototype.hasOwnProperty.call(e, t) && "object" === _typeof(e[t]) && e[t] instanceof Array && e[t].forEach(function (e) {
                            o.taste(e) && r.push(e);
                          });
                        };
                      if ("*" === t)
                        for (var a in e)
                          n(e, a);
                      else
                        void 0 !== e[t] && n(e, t);
                      return r;
                    }
                  },
                  {
                    key: "getNodeType",
                    value: function (e) {
                      return e.type;
                    }
                  },
                  {
                    key: "getNodeAttrNames",
                    value: function (e) {
                      var t = [];
                      for (var o in e)
                        Object.prototype.hasOwnProperty.call(e, o) && "object" !== _typeof(e[o]) && "type" !== o && "loc" !== o && t.push(o);
                      return t;
                    }
                  },
                  {
                    key: "getNodeAttrValue",
                    value: function (e, t) {
                      return Object.prototype.hasOwnProperty.call(e, t) && "object" !== _typeof(e[t]) && "type" !== t && "loc" !== t ? e[t] : void 0;
                    }
                  }
                ]), e;
              }());
              exports.default = ASTQAdapterMozAST;
            },
            {}
          ],
          9: [
            function (_dereq_, module, exports) {
              function _typeof(e) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                  return typeof e;
                } : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                })(e);
              }
              function _classCallCheck(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(e, t) {
                for (var n = 0; n < t.length; n++) {
                  var o = t[n];
                  o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
                }
              }
              function _createClass(e, t, n) {
                return t && _defineProperties(e.prototype, t), n && _defineProperties(e, n), e;
              }
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var ASTQAdapterParse5 = (function () {
                function e() {
                  _classCallCheck(this || _global, e);
                }
                return _createClass(e, null, [
                  {
                    key: "taste",
                    value: function (e) {
                      return "object" === _typeof(e) && null !== e && !("object" === ("undefined" == typeof Node ? "undefined" : _typeof(Node)) && e instanceof Node) && "string" == typeof e.nodeName && "" !== e.nodeName;
                    }
                  },
                  {
                    key: "getParentNode",
                    value: function (e) {
                      return e.parentNode;
                    }
                  },
                  {
                    key: "getChildNodes",
                    value: function (e) {
                      return "object" === _typeof(e.childNodes) && e.childNodes instanceof Array ? e.childNodes : [];
                    }
                  },
                  {
                    key: "getNodeType",
                    value: function (e) {
                      return e.nodeName;
                    }
                  },
                  {
                    key: "getNodeAttrNames",
                    value: function (e) {
                      var t = ["value"];
                      return "object" === _typeof(e.attrs) && e.attrs instanceof Array && (t = t.concat(e.attrs.map(function (e) {
                        return e.name;
                      }))), t;
                    }
                  },
                  {
                    key: "getNodeAttrValue",
                    value: function (e, t) {
                      var n;
                      if ("value" === t)
                        n = e.value;
                      else if ("object" === _typeof(e.attrs) && e.attrs instanceof Array) {
                        var o = e.attrs.filter(function (e) {
                          return e.name === t;
                        }).map(function (e) {
                          return e.value;
                        });
                        1 === o.length && (n = o[0]);
                      }
                      return n;
                    }
                  }
                ]), e;
              }());
              exports.default = ASTQAdapterParse5;
            },
            {}
          ],
          10: [
            function (_dereq_, module, exports) {
              function _typeof(e) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                  return typeof e;
                } : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                })(e);
              }
              function _classCallCheck(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(e, t) {
                for (var o = 0; o < t.length; o++) {
                  var r = t[o];
                  r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
                }
              }
              function _createClass(e, t, o) {
                return t && _defineProperties(e.prototype, t), o && _defineProperties(e, o), e;
              }
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var ASTQAdapterUniST = (function () {
                function e() {
                  _classCallCheck(this || _global, e);
                }
                return _createClass(e, null, [
                  {
                    key: "taste",
                    value: function (e) {
                      return "object" === _typeof(e) && null !== e && "string" == typeof e.type && "" !== e.type;
                    }
                  },
                  {
                    key: "getParentNode",
                    value: function (e) {
                      if ("object" === _typeof(e.parent) && null !== e.parent)
                        return e.parent;
                      throw new Error("Your UniST AST does not support parent node traversal");
                    }
                  },
                  {
                    key: "getChildNodes",
                    value: function (e) {
                      return "object" === _typeof(e.children) && e.children instanceof Array ? e.children : [];
                    }
                  },
                  {
                    key: "getNodeType",
                    value: function (e) {
                      return e.type;
                    }
                  },
                  {
                    key: "getNodeAttrNames",
                    value: function (e) {
                      var t = [];
                      for (var o in e)
                        Object.prototype.hasOwnProperty.call(e, o) && "type" !== o && "data" !== o && "position" !== o && "children" !== o && "object" !== _typeof(e[o]) && t.push(o);
                      return t;
                    }
                  },
                  {
                    key: "getNodeAttrValue",
                    value: function (e, t) {
                      return Object.prototype.hasOwnProperty.call(e, t) && "type" !== t && "data" !== t && "position" !== t && "children" !== t && "object" !== _typeof(e[t]) ? e[t] : void 0;
                    }
                  }
                ]), e;
              }());
              exports.default = ASTQAdapterUniST;
            },
            {}
          ],
          11: [
            function (_dereq_, module, exports) {
              function _typeof(e) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                  return typeof e;
                } : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                })(e);
              }
              function _classCallCheck(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(e, t) {
                for (var o = 0; o < t.length; o++) {
                  var n = t[o];
                  n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
                }
              }
              function _createClass(e, t, o) {
                return t && _defineProperties(e.prototype, t), o && _defineProperties(e, o), e;
              }
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var ASTQAdapterXMLDOM = (function () {
                function e() {
                  _classCallCheck(this || _global, e);
                }
                return _createClass(e, null, [
                  {
                    key: "taste",
                    value: function (e) {
                      return "object" === ("undefined" == typeof Node ? "undefined" : _typeof(Node)) && null !== e && e instanceof Node && "object" === _typeof(e) && "number" == typeof e.nodeType && "string" == typeof e.nodeName;
                    }
                  },
                  {
                    key: "getParentNode",
                    value: function (e) {
                      return e.parentNode;
                    }
                  },
                  {
                    key: "getChildNodes",
                    value: function (e) {
                      return "object" === _typeof(e.childNodes) && null !== e.childNodes && e.hasChildNodes() ? Array.prototype.slice.call(e.childNodes, 0) : [];
                    }
                  },
                  {
                    key: "getNodeType",
                    value: function (e) {
                      return "string" == typeof e.nodeName ? e.nodeName : "unknown";
                    }
                  },
                  {
                    key: "getNodeAttrNames",
                    value: function (e) {
                      return "object" === _typeof(e.attributes) && null !== e.attributes && e.hasAttributes() ? Array.prototype.slice.call(e.attributes, 0).map(function (e) {
                        return e.nodeName;
                      }) : [];
                    }
                  },
                  {
                    key: "getNodeAttrValue",
                    value: function (e, t) {
                      return "object" === _typeof(e.attributes) && null !== e.attributes && e.hasAttributes() ? e.getAttribute(t) : void 0;
                    }
                  }
                ]), e;
              }());
              exports.default = ASTQAdapterXMLDOM;
            },
            {}
          ],
          12: [
            function (_dereq_, module, exports) {
              function _classCallCheck(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(e, t) {
                for (var r = 0; r < t.length; r++) {
                  var a = t[r];
                  a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);
                }
              }
              function _createClass(e, t, r) {
                return t && _defineProperties(e.prototype, t), r && _defineProperties(e, r), e;
              }
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var ASTQAdapter = (function () {
                function e() {
                  return _classCallCheck(this || _global, e), (this || _global)._adapters = [], this || _global;
                }
                return _createClass(e, [
                  {
                    key: "register",
                    value: function (e) {
                      var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                      return (this || _global)._adapters.unshift({
                        adapter: e,
                        force: t
                      }), this || _global;
                    }
                  },
                  {
                    key: "unregister",
                    value: function (e) {
                      if (void 0 === e)
                        (this || _global)._adapters = [];
                      else {
                        for (var t = [], r = 0; r < (this || _global)._adapters.length; r++)
                          (this || _global)._adapters[r].adapter !== e && t.push((this || _global)._adapters[r]);
                        (this || _global)._adapters = t;
                      }
                      return this || _global;
                    }
                  },
                  {
                    key: "select",
                    value: function (e) {
                      for (var t = 0; t < (this || _global)._adapters.length; t++)
                        if ((this || _global)._adapters[t].force || (this || _global)._adapters[t].adapter.taste(e))
                          return (this || _global)._adapters[t].adapter;
                    }
                  }
                ]), e;
              }());
              exports.default = ASTQAdapter;
            },
            {}
          ],
          13: [
            function (_dereq_, module, exports) {
              function _typeof(t) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                  return typeof t;
                } : function (t) {
                  return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                })(t);
              }
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var _pos = function (t, n) {
                  var e = t.getParentNode(n, "*");
                  if (null === e)
                    return 1;
                  for (var r = t.getChildNodes(e, "*"), o = 0; o < r.length; o++)
                    if (r[o] === n)
                      return o + 1;
                  throw new Error("cannot find myself");
                }, parents = function (t, n) {
                  for (var e = []; null !== (n = t.getParentNode(n, "*"));)
                    e.push(n);
                  return e;
                }, stdfuncs = {
                  type: function (t, n) {
                    return t.getNodeType(n);
                  },
                  attrs: function (t, n, e) {
                    return void 0 === e && (e = " "), e + t.getNodeAttrNames(n).join(e) + e;
                  },
                  depth: function (t, n) {
                    for (var e = 1, r = n; null !== (r = t.getParentNode(r, "*"));)
                      e++;
                    return e;
                  },
                  pos: function (t, n) {
                    return _pos(t, n);
                  },
                  nth: function (t, n, e) {
                    e = parseInt(e, 10);
                    var r = t.getParentNode(n, "*");
                    if (null !== r) {
                      var o = t.getChildNodes(r, "*");
                      e < 0 && (e = o.length - (e + 1));
                      for (var u = 0; u < o.length; u++)
                        if (o[u] === n)
                          return u + 1 === e;
                      return !1;
                    }
                    return 1 === e;
                  },
                  first: function (t, n) {
                    return stdfuncs.nth(t, n, 1);
                  },
                  last: function (t, n) {
                    return stdfuncs.nth(t, n, -1);
                  },
                  count: function (t, n, e) {
                    return "object" === _typeof(e) && e instanceof Array ? e.length : "object" === _typeof(e) ? Object.keys(e).length : "string" == typeof e ? e.length : String(e).length;
                  },
                  below: function (t, n, e) {
                    if (!t.taste(e))
                      throw new Error("invalid argument to function \"below\" (node expected)");
                    for (var r = n; null !== (r = t.getParentNode(r, "*"));)
                      if (r === e)
                        return !0;
                    return !1;
                  },
                  follows: function (t, n, e) {
                    if (!t.taste(e))
                      throw new Error("invalid argument to function \"follows\" (node expected)");
                    if (n === e)
                      return !1;
                    var r, o = [n].concat(parents(t, n)).reverse(), u = [e].concat(parents(t, e)).reverse(), f = Math.min(o.length, u.length);
                    for (r = 0; r < f && o[r] === u[r]; r++);
                    if (0 === r)
                      throw new Error("internal error: root nodes have to be same same");
                    return r === f ? u.length < o.length : _pos(t, o[r]) > _pos(t, u[r]);
                  },
                  in: function (t, n, e) {
                    if (!("object" === _typeof(e) && e instanceof Array))
                      throw new Error("invalid argument to function \"in\" (array expected)");
                    for (var r = 0; r < e.length; r++)
                      if (e[r] === n)
                        return !0;
                    return !1;
                  },
                  substr: function (t, n, e, r, o) {
                    return String(e).substr(r, o);
                  },
                  index: function (t, n, e, r, o) {
                    return String(e).indexOf(r, o);
                  },
                  trim: function (t, n, e) {
                    return String(e).trim();
                  },
                  lc: function (t, n, e) {
                    return String(e).toLowerCase();
                  },
                  uc: function (t, n, e) {
                    return String(e).toUpperCase();
                  }
                }, _default = stdfuncs;
              exports.default = _default;
            },
            {}
          ],
          14: [
            function (_dereq_, module, exports) {
              function _classCallCheck(e, n) {
                if (!(e instanceof n))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(e, n) {
                for (var r = 0; r < n.length; r++) {
                  var t = n[r];
                  t.enumerable = t.enumerable || !1, t.configurable = !0, "value" in t && (t.writable = !0), Object.defineProperty(e, t.key, t);
                }
              }
              function _createClass(e, n, r) {
                return n && _defineProperties(e.prototype, n), r && _defineProperties(e, r), e;
              }
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var ASTQFuncs = (function () {
                function e() {
                  return _classCallCheck(this || _global, e), (this || _global)._funcs = {}, this || _global;
                }
                return _createClass(e, [
                  {
                    key: "register",
                    value: function (e, n) {
                      (this || _global)._funcs[e] = n;
                    }
                  },
                  {
                    key: "run",
                    value: function (e, n) {
                      var r = (this || _global)._funcs[e];
                      if ("function" != typeof r)
                        throw new Error("invalid function \"" + e + "\"");
                      return r.apply(null, n);
                    }
                  }
                ]), e;
              }());
              exports.default = ASTQFuncs;
            },
            {}
          ],
          15: [
            function (_dereq_, module, exports) {
              function _typeof(e) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                  return typeof e;
                } : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                })(e);
              }
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var _astqUtil = _interopRequireDefault(_dereq_("./astq-util.js")), _astqQueryTrace = _interopRequireDefault(_dereq_("./astq-query-trace.js"));
              function _interopRequireDefault(e) {
                return e && e.__esModule ? e : { default: e };
              }
              function _classCallCheck(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(e, t) {
                for (var r = 0; r < t.length; r++) {
                  var a = t[r];
                  a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);
                }
              }
              function _createClass(e, t, r) {
                return t && _defineProperties(e.prototype, t), r && _defineProperties(e, r), e;
              }
              function _inherits(e, t) {
                if ("function" != typeof t && null !== t)
                  throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                  constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                  }
                }), t && _setPrototypeOf(e, t);
              }
              function _setPrototypeOf(e, t) {
                return (_setPrototypeOf = Object.setPrototypeOf || function (e, t) {
                  return e.__proto__ = t, e;
                })(e, t);
              }
              function _createSuper(e) {
                var t = _isNativeReflectConstruct();
                return function () {
                  var r, a = _getPrototypeOf(e);
                  if (t) {
                    var i = _getPrototypeOf(this || _global).constructor;
                    r = Reflect.construct(a, arguments, i);
                  } else
                    r = a.apply(this || _global, arguments);
                  return _possibleConstructorReturn(this || _global, r);
                };
              }
              function _possibleConstructorReturn(e, t) {
                return !t || "object" !== _typeof(t) && "function" != typeof t ? _assertThisInitialized(e) : t;
              }
              function _assertThisInitialized(e) {
                if (void 0 === e)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e;
              }
              function _isNativeReflectConstruct() {
                if ("undefined" == typeof Reflect || !Reflect.construct)
                  return !1;
                if (Reflect.construct.sham)
                  return !1;
                if ("function" == typeof Proxy)
                  return !0;
                try {
                  return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                  })), !0;
                } catch (e) {
                  return !1;
                }
              }
              function _getPrototypeOf(e) {
                return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
                  return e.__proto__ || Object.getPrototypeOf(e);
                })(e);
              }
              var ASTQQueryExec = function (e) {
                _inherits(r, _astqQueryTrace["default"]);
                var t = _createSuper(r);
                function r(e, a, i, n) {
                  var c;
                  return _classCallCheck(this || _global, r), (c = t.call(this || _global)).adapter = e, c.params = a, c.funcs = i, c.trace = n, c;
                }
                return _createClass(r, [
                  {
                    key: "execQuery",
                    value: function (e, t) {
                      var r = this || _global;
                      this.traceBegin(e, t);
                      var a = [];
                      return e.childs().forEach(function (e) {
                        a = a.concat(r.execPath(e, t));
                      }), this.traceEnd(e, t, a), a;
                    }
                  },
                  {
                    key: "execPath",
                    value: function (e, t) {
                      var r = this || _global;
                      this.traceBegin(e, t);
                      var a = [t], i = [], n = !1;
                      return e.childs().forEach(function (e) {
                        var t = [];
                        a.forEach(function (a) {
                          t = t.concat(r.execStep(e, a));
                        }), a = t, e.get("isResult") && (n = !0, i = i.concat(a));
                      }), this.traceEnd(e, t, a), n ? i : a;
                    }
                  },
                  {
                    key: "execStep",
                    value: function (e, t) {
                      var r = this || _global;
                      this.traceBegin(e, t);
                      var a = e.childs(), i = null, n = null, c = null, s = 0;
                      if (s < a.length && "Axis" === a[s].type() && (i = a[s++]), s < a.length && "Match" === a[s].type() && (n = a[s++]), s < a.length && "Filter" === a[s].type() && (c = a[s++]), null === n)
                        throw new Error("no matching part in query step");
                      var l = [], u = n.get("id"), o = function (e) {
                          var t = r.adapter.getNodeType(e);
                          if ("*" === u || u === t) {
                            var a = !0;
                            null !== c && (r.execFilter(c, e) || (a = !1)), a && l.push(e);
                          }
                        };
                      if (null !== i) {
                        var h = i.get("op"), f = i.get("type");
                        if ("/" === h)
                          (this || _global).adapter.getChildNodes(t, f).forEach(function (e) {
                            return o(e);
                          });
                        else if ("//" === h) {
                          (this || _global).adapter.getChildNodes(t, f).forEach(function (e) {
                            return function e(t) {
                              o(t), r.adapter.getChildNodes(t, f).forEach(function (t) {
                                return e(t);
                              });
                            }(e);
                          });
                        } else if ("./" === h)
                          o(t), (this || _global).adapter.getChildNodes(t, f).forEach(function (e) {
                            return o(e);
                          });
                        else if (".//" === h) {
                          o(t);
                          (this || _global).adapter.getChildNodes(t, f).forEach(function (e) {
                            return function e(t) {
                              o(t), r.adapter.getChildNodes(t, f).forEach(function (t) {
                                return e(t);
                              });
                            }(e);
                          });
                        } else if ("-/" === h) {
                          var d = (this || _global).adapter.getParentNode(t, "*");
                          if (null !== d) {
                            for (var p = (this || _global).adapter.getChildNodes(d, f), x = null, g = 0; g < p.length && p[g] !== t; g++)
                              x = p[g];
                            null !== x && o(x);
                          }
                        } else if ("-//" === h) {
                          var y = (this || _global).adapter.getParentNode(t, "*");
                          if (null !== y) {
                            for (var v = (this || _global).adapter.getChildNodes(y, f), E = 0; E < v.length && v[E] !== t; E++);
                            for (E--; E >= 0; E--)
                              o(v[E]);
                          }
                        } else if ("+/" === h) {
                          var _ = (this || _global).adapter.getParentNode(t, "*");
                          if (null !== _) {
                            var b, k = (this || _global).adapter.getChildNodes(_, f);
                            for (b = 0; b < k.length && k[b] !== t; b++);
                            b < k.length && o(k[++b]);
                          }
                        } else if ("+//" === h) {
                          var m = (this || _global).adapter.getParentNode(t, "*");
                          if (null !== m) {
                            var q, U = (this || _global).adapter.getChildNodes(m, f);
                            for (q = 0; q < U.length && U[q] !== t; q++);
                            if (q < U.length)
                              for (q++; q < U.length; q++)
                                o(U[q]);
                          }
                        } else if ("~/" === h) {
                          var C = (this || _global).adapter.getParentNode(t, "*");
                          if (null !== C) {
                            var P, N = (this || _global).adapter.getChildNodes(C, f);
                            for (P = 0; P < N.length && N[P] !== t; P++);
                            P > 0 && o(N[P - 1]), P < N.length - 1 && o(N[P + 1]);
                          }
                        } else if ("~//" === h) {
                          var B = (this || _global).adapter.getParentNode(t, "*");
                          if (null !== B)
                            for (var w = (this || _global).adapter.getChildNodes(B, f), R = 0; R < w.length; R++)
                              w[R] !== t && o(w[R]);
                        } else if ("../" === h) {
                          var O = (this || _global).adapter.getParentNode(t, f);
                          null !== O && o(O);
                        } else if ("..//" === h)
                          for (var S = t;;) {
                            var L = (this || _global).adapter.getParentNode(S, f);
                            if (null === L)
                              break;
                            o(L), S = L;
                          }
                        else if ("<//" === h) {
                          for (var T = {
                              sentinel: t,
                              take: !0
                            };;) {
                            var j = (this || _global).adapter.getParentNode(t, "*");
                            if (null === j)
                              break;
                            t = j;
                          }
                          t !== T.sentinel && (o(t), (this || _global).adapter.getChildNodes(t, f).forEach(function (e) {
                            return function e(t) {
                              t === T.sentinel && (T.take = !1), T.take && o(t), T.take && r.adapter.getChildNodes(t, f).forEach(function (t) {
                                return e(t);
                              });
                            }(e);
                          })), l = l.reverse();
                        } else if (">//" === h) {
                          for (var A = {
                              sentinel: t,
                              take: !1
                            };;) {
                            var Q = (this || _global).adapter.getParentNode(t, "*");
                            if (null === Q)
                              break;
                            t = Q;
                          }
                          (this || _global).adapter.getChildNodes(t, f).forEach(function (e) {
                            return function e(t) {
                              A.take && o(t), t === A.sentinel && (A.take = !0), r.adapter.getChildNodes(t, f).forEach(function (t) {
                                return e(t);
                              });
                            }(e);
                          });
                        }
                      } else
                        o(t);
                      return this.traceEnd(e, t, l), l;
                    }
                  },
                  {
                    key: "execFilter",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r = e.childs()[0], a = this.execExpr(r, t);
                      return a = _astqUtil.default.truthy(a), this.traceEnd(e, t, a), a;
                    }
                  },
                  {
                    key: "execExpr",
                    value: function (e, t) {
                      switch (e.type()) {
                      case "ConditionalBinary":
                        return this.execExprConditionalBinary(e, t);
                      case "ConditionalTernary":
                        return this.execExprConditionalTernary(e, t);
                      case "Logical":
                        return this.execExprLogical(e, t);
                      case "Bitwise":
                        return this.execExprBitwise(e, t);
                      case "Relational":
                        return this.execExprRelational(e, t);
                      case "Arithmetical":
                        return this.execExprArithmetical(e, t);
                      case "Unary":
                        return this.execExprUnary(e, t);
                      case "FuncCall":
                        return this.execExprFuncCall(e, t);
                      case "Attribute":
                        return this.execExprAttribute(e, t);
                      case "Param":
                        return this.execExprParam(e, t);
                      case "LiteralString":
                        return this.execExprLiteralString(e, t);
                      case "LiteralRegExp":
                        return this.execExprLiteralRegExp(e, t);
                      case "LiteralNumber":
                        return this.execExprLiteralNumber(e, t);
                      case "LiteralValue":
                        return this.execExprLiteralValue(e, t);
                      case "Path":
                        return this.execExprPath(e, t);
                      }
                    }
                  },
                  {
                    key: "execExprConditionalBinary",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r = this.execExpr(e.childs()[0], t);
                      return _astqUtil.default.truthy(r) || (r = this.execExpr(e.childs()[1], t)), this.traceEnd(e, t, r), r;
                    }
                  },
                  {
                    key: "execExprConditionalTernary",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r = this.execExpr(e.childs()[0], t);
                      return r = _astqUtil.default.truthy(r) ? this.execExpr(e.childs()[1], t) : this.execExpr(e.childs()[2], t), this.traceEnd(e, t, r), r;
                    }
                  },
                  {
                    key: "execExprLogical",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r = !1;
                      switch (e.get("op")) {
                      case "&&":
                        (r = _astqUtil.default.truthy(this.execExpr(e.childs()[0], t))) && (r = r && _astqUtil.default.truthy(this.execExpr(e.childs()[1], t)));
                        break;
                      case "||":
                        (r = _astqUtil.default.truthy(this.execExpr(e.childs()[0], t))) || (r = r || _astqUtil.default.truthy(this.execExpr(e.childs()[1], t)));
                      }
                      return this.traceEnd(e, t, r), r;
                    }
                  },
                  {
                    key: "execExprBitwise",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r, a = _astqUtil.default.coerce(this.execExpr(e.childs()[0], t), "number"), i = _astqUtil.default.coerce(this.execExpr(e.childs()[1], t), "number");
                      switch (e.get("op")) {
                      case "&":
                        r = a & i;
                        break;
                      case "|":
                        r = a | i;
                        break;
                      case "<<":
                        r = a << i;
                        break;
                      case ">>":
                        r = a >> i;
                      }
                      return this.traceEnd(e, t, r), r;
                    }
                  },
                  {
                    key: "execExprRelational",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r, a = this.execExpr(e.childs()[0], t), i = this.execExpr(e.childs()[1], t);
                      switch (e.get("op")) {
                      case "==":
                        r = a === i;
                        break;
                      case "!=":
                        r = a !== i;
                        break;
                      case "<=":
                        r = _astqUtil.default.coerce(a, "number") <= _astqUtil.default.coerce(i, "number");
                        break;
                      case ">=":
                        r = _astqUtil.default.coerce(a, "number") >= _astqUtil.default.coerce(i, "number");
                        break;
                      case "<":
                        r = _astqUtil.default.coerce(a, "number") < _astqUtil.default.coerce(i, "number");
                        break;
                      case ">":
                        r = _astqUtil.default.coerce(a, "number") > _astqUtil.default.coerce(i, "number");
                        break;
                      case "=~":
                        r = null !== _astqUtil.default.coerce(a, "string").match(_astqUtil.default.coerce(i, "regexp"));
                        break;
                      case "!~":
                        r = null === _astqUtil.default.coerce(a, "string").match(_astqUtil.default.coerce(i, "regexp"));
                      }
                      return this.traceEnd(e, t, r), r;
                    }
                  },
                  {
                    key: "execExprArithmetical",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r, a = this.execExpr(e.childs()[0], t), i = this.execExpr(e.childs()[1], t);
                      switch (e.get("op")) {
                      case "+":
                        r = "string" == typeof a ? a + _astqUtil.default.coerce(i, "string") : _astqUtil.default.coerce(a, "number") + _astqUtil.default.coerce(i, "number");
                        break;
                      case "-":
                        r = _astqUtil.default.coerce(a, "number") + _astqUtil.default.coerce(i, "number");
                        break;
                      case "*":
                        r = _astqUtil.default.coerce(a, "number") * _astqUtil.default.coerce(i, "number");
                        break;
                      case "/":
                        r = _astqUtil.default.coerce(a, "number") / _astqUtil.default.coerce(i, "number");
                        break;
                      case "%":
                        r = _astqUtil.default.coerce(a, "number") % _astqUtil.default.coerce(i, "number");
                        break;
                      case "**":
                        r = Math.pow(_astqUtil.default.coerce(a, "number"), _astqUtil.default.coerce(i, "number"));
                      }
                      return this.traceEnd(e, t, r), r;
                    }
                  },
                  {
                    key: "execExprUnary",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r, a = this.execExpr(e.childs()[0], t);
                      switch (e.get("op")) {
                      case "!":
                        r = !_astqUtil.default.coerce(a, "boolean");
                        break;
                      case "~":
                        r = ~_astqUtil.default.coerce(a, "number");
                      }
                      return this.traceEnd(e, t, r), r;
                    }
                  },
                  {
                    key: "execExprFuncCall",
                    value: function (e, t) {
                      var r = this || _global;
                      this.traceBegin(e, t);
                      var a = e.get("id"), i = [
                          (this || _global).adapter,
                          t
                        ];
                      e.childs().forEach(function (e) {
                        i.push(r.execExpr(e, t));
                      });
                      var n = (this || _global).funcs.run(a, i);
                      return this.traceEnd(e, t, n), n;
                    }
                  },
                  {
                    key: "execExprAttribute",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r = e.get("id"), a = (this || _global).adapter.getNodeAttrValue(t, r);
                      return this.traceEnd(e, t, a), a;
                    }
                  },
                  {
                    key: "execExprParam",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r = e.get("id");
                      if (void 0 === (this || _global).params[r])
                        throw new Error("invalid parameter \"" + r + "\"");
                      var a = (this || _global).params[r];
                      return this.traceEnd(e, t, a), a;
                    }
                  },
                  {
                    key: "execExprLiteralString",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r = e.get("value");
                      return this.traceEnd(e, t, r), r;
                    }
                  },
                  {
                    key: "execExprLiteralRegExp",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r = e.get("value");
                      return this.traceEnd(e, t, r), r;
                    }
                  },
                  {
                    key: "execExprLiteralNumber",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r = e.get("value");
                      return this.traceEnd(e, t, r), r;
                    }
                  },
                  {
                    key: "execExprLiteralValue",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r = e.get("value");
                      return this.traceEnd(e, t, r), r;
                    }
                  },
                  {
                    key: "execExprPath",
                    value: function (e, t) {
                      this.traceBegin(e, t);
                      var r = this.execPath(e, t);
                      return this.traceEnd(e, t, r), r;
                    }
                  }
                ]), r;
              }();
              exports.default = ASTQQueryExec;
            },
            {
              "./astq-query-trace.js": 16,
              "./astq-util.js": 18
            }
          ],
          16: [
            function (_dereq_, module, exports) {
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var _astqUtil = _interopRequireDefault(_dereq_("./astq-util.js"));
              function _interopRequireDefault(e) {
                return e && e.__esModule ? e : { default: e };
              }
              function _typeof(e) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                  return typeof e;
                } : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                })(e);
              }
              function _classCallCheck(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(e, t) {
                for (var r = 0; r < t.length; r++) {
                  var o = t[r];
                  o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
                }
              }
              function _createClass(e, t, r) {
                return t && _defineProperties(e.prototype, t), r && _defineProperties(e, r), e;
              }
              var ASTQQueryTrace = (function () {
                function e() {
                  _classCallCheck(this || _global, e);
                }
                return _createClass(e, [
                  {
                    key: "prefixOf",
                    value: function (e, t) {
                      for (var r = 0, o = e; null !== (o = o.parent());)
                        r++;
                      var a = _astqUtil.default.pad("", 4 * r);
                      for (r = 0, o = t; null !== (o = (this || _global).adapter.getParentNode(o, "*"));)
                        r++;
                      return {
                        prefix1: a,
                        prefix2: _astqUtil.default.pad("", 4 * r)
                      };
                    }
                  },
                  {
                    key: "traceBegin",
                    value: function (e, t) {
                      if ((this || _global).trace) {
                        var r = this.prefixOf(e, t), o = r.prefix1, a = r.prefix2;
                        console.log("ASTQ: execute: | " + _astqUtil.default.pad(o + e.type() + " (", -60) + " | " + a + (this || _global).adapter.getNodeType(t));
                      }
                    }
                  },
                  {
                    key: "traceEnd",
                    value: function (e, t, r) {
                      var o = this || _global;
                      if ((this || _global).trace) {
                        var a, n = this.prefixOf(e, t), i = n.prefix1, f = n.prefix2;
                        void 0 === r ? a = "undefined" : "object" === _typeof(r) && r instanceof Array ? (a = "[", r.forEach(function (e) {
                          a += "node(" + o.adapter.getNodeType(e) + "),";
                        }), a = a.replace(/,$/, "") + "]") : a = _typeof(r) + "(" + r + ")", a.length > 60 && (a = a.substr(0, 60) + "..."), console.log("ASTQ: execute: | " + _astqUtil.default.pad(i + "): " + a, -60) + " | " + f + (this || _global).adapter.getNodeType(t));
                      }
                    }
                  }
                ]), e;
              }());
              exports.default = ASTQQueryTrace;
            },
            { "./astq-util.js": 18 }
          ],
          17: [
            function (_dereq_, module, exports) {
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var _asty = _interopRequireDefault(_dereq_("asty")), _pegjsUtil = _interopRequireDefault(_dereq_("pegjs-util")), _astqQueryExec = _interopRequireDefault(_dereq_("./astq-query-exec.js"));
              function _interopRequireDefault(t) {
                return t && t.__esModule ? t : { default: t };
              }
              function _classCallCheck(t, r) {
                if (!(t instanceof r))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(t, r) {
                for (var e = 0; e < r.length; e++) {
                  var n = r[e];
                  n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
                }
              }
              function _createClass(t, r, e) {
                return r && _defineProperties(t.prototype, r), e && _defineProperties(t, e), t;
              }
              var ASTQQueryParse = (function () {
                  function t(r, e, n, u) {
                    (this || _global).message = r, (this || _global).expected = e, (this || _global).found = n, (this || _global).location = u, (this || _global).name = "SyntaxError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this || _global, t);
                  }
                  return function (t, r) {
                    function e() {
                      (this || _global).constructor = t;
                    }
                    e.prototype = r.prototype, t.prototype = new e();
                  }(t, Error), t.buildMessage = function (t, r) {
                    var e = {
                      literal: function (t) {
                        return "\"" + u(t.text) + "\"";
                      },
                      class: function (t) {
                        var r, e = "";
                        for (r = 0; r < t.parts.length; r++)
                          e += t.parts[r] instanceof Array ? s(t.parts[r][0]) + "-" + s(t.parts[r][1]) : s(t.parts[r]);
                        return "[" + (t.inverted ? "^" : "") + e + "]";
                      },
                      any: function (t) {
                        return "any character";
                      },
                      end: function (t) {
                        return "end of input";
                      },
                      other: function (t) {
                        return t.description;
                      }
                    };
                    function n(t) {
                      return t.charCodeAt(0).toString(16).toUpperCase();
                    }
                    function u(t) {
                      return t.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (t) {
                        return "\\x0" + n(t);
                      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (t) {
                        return "\\x" + n(t);
                      });
                    }
                    function s(t) {
                      return t.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (t) {
                        return "\\x0" + n(t);
                      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (t) {
                        return "\\x" + n(t);
                      });
                    }
                    return "Expected " + function (t) {
                      var r, n, u, s = new Array(t.length);
                      for (r = 0; r < t.length; r++)
                        s[r] = (u = t[r], e[u.type](u));
                      if (s.sort(), s.length > 0) {
                        for (r = 1, n = 1; r < s.length; r++)
                          s[r - 1] !== s[r] && (s[n] = s[r], n++);
                        s.length = n;
                      }
                      switch (s.length) {
                      case 1:
                        return s[0];
                      case 2:
                        return s[0] + " or " + s[1];
                      default:
                        return s.slice(0, -1).join(", ") + ", or " + s[s.length - 1];
                      }
                    }(t) + " but " + function (t) {
                      return t ? "\"" + u(t) + "\"" : "end of input";
                    }(r) + " found.";
                  }, {
                    SyntaxError: t,
                    parse: function (r, e) {
                      e = void 0 !== e ? e : {};
                      var n, u = {}, s = { query: Dn }, a = Dn, o = function (t) {
                          return t;
                        }, i = ",", c = Nn(",", !1), l = function (t, r) {
                          return pu("Query").add(du(t, r, 3));
                        }, f = function (t, r) {
                          return pu("Path").add(du(t, r, 1));
                        }, h = "!", A = Nn("!", !1), d = function (t, r, e, n) {
                          return pu("Step").add(t, r, n).set(null !== e ? { isResult: !0 } : {});
                        }, p = Mn("axis"), x = "//", b = Nn("//", !1), g = "/", v = Nn("/", !1), P = "-//", C = Nn("-//", !1), y = "-/", m = Nn("-/", !1), _ = "+//", S = Nn("+//", !1), w = "+/", q = Nn("+/", !1), Q = "~//", E = Nn("~//", !1), R = "~/", T = Nn("~/", !1), F = "..//", L = Nn("..//", !1), k = "../", N = Nn("../", !1), j = ".//", M = Nn(".//", !1), I = "./", U = Nn("./", !1), V = "<//", z = Nn("<//", !1), D = ">//", Z = Nn(">//", !1), O = function (t, r) {
                          return pu("Axis").set({
                            op: t,
                            type: null !== r ? r : "*"
                          });
                        }, B = ":", $ = Nn(":", !1), G = function (t) {
                          return t.get("id");
                        }, H = function (t) {
                          return t.get("value");
                        }, J = function (t) {
                          return pu("Match").merge(t);
                        }, K = function (t) {
                          return pu("Match").set({ id: t.get("value") });
                        }, W = "*", X = Nn("*", !1), Y = function () {
                          return pu("Match").set({ id: "*" });
                        }, tt = "[", rt = Nn("[", !1), et = "]", nt = Nn("]", !1), ut = function (t) {
                          return pu("Filter").add(t);
                        }, st = "?:", at = Nn("?:", !1), ot = function (t, r) {
                          return pu("ConditionalBinary").add(t, r);
                        }, it = "?", ct = Nn("?", !1), lt = function (t, r, e) {
                          return pu("ConditionalTernary").add(t, r, e);
                        }, ft = "||", ht = Nn("||", !1), At = function (t, r, e) {
                          return pu("Logical").set({ op: r }).add(t, e);
                        }, dt = "&&", pt = Nn("&&", !1), xt = "|", bt = Nn("|", !1), gt = function (t, r, e) {
                          return pu("Bitwise").set({ op: r }).add(t, e);
                        }, vt = "^", Pt = Nn("^", !1), Ct = "&", yt = Nn("&", !1), mt = "==", _t = Nn("==", !1), St = "!=", wt = Nn("!=", !1), qt = "<=", Qt = Nn("<=", !1), Et = ">=", Rt = Nn(">=", !1), Tt = "<", Ft = Nn("<", !1), Lt = ">", kt = Nn(">", !1), Nt = "=~", jt = Nn("=~", !1), Mt = "!~", It = Nn("!~", !1), Ut = function (t, r, e) {
                          return pu("Relational").set({ op: r }).add(t, e);
                        }, Vt = "<<", zt = Nn("<<", !1), Dt = ">>", Zt = Nn(">>", !1), Ot = "+", Bt = Nn("+", !1), $t = "-", Gt = Nn("-", !1), Ht = function (t, r, e) {
                          return pu("Arithmetical").set({ op: r }).add(t, e);
                        }, Jt = "**", Kt = Nn("**", !1), Wt = "%", Xt = Nn("%", !1), Yt = "~", tr = Nn("~", !1), rr = function (t, r) {
                          return pu("Unary").set({ op: t }).add(r);
                        }, er = "(", nr = Nn("(", !1), ur = ")", sr = Nn(")", !1), ar = function (t, r) {
                          return pu("FuncCall").merge(t).add(r);
                        }, or = function (t, r) {
                          return du(t, r, 3);
                        }, ir = Mn("node attribute"), cr = "@", lr = Nn("@", !1), fr = function (t) {
                          return pu("Attribute").merge(t);
                        }, hr = function (t) {
                          return pu("Attribute").set({ id: t.get("value") });
                        }, Ar = Mn("query parameter reference"), dr = "{", pr = Nn("{", !1), xr = "}", br = Nn("}", !1), gr = function (t) {
                          return pu("Param").merge(t);
                        }, vr = function (t) {
                          return t;
                        }, Pr = Mn("identifier"), Cr = /^[a-zA-Z_]/, yr = jn([
                          [
                            "a",
                            "z"
                          ],
                          [
                            "A",
                            "Z"
                          ],
                          "_"
                        ], !1, !1), mr = /^[a-zA-Z0-9_\-]/, _r = jn([
                          [
                            "a",
                            "z"
                          ],
                          [
                            "A",
                            "Z"
                          ],
                          [
                            "0",
                            "9"
                          ],
                          "_",
                          "-"
                        ], !1, !1), Sr = function (t) {
                          return pu("Identifier").set({ id: t });
                        }, wr = Mn("quoted string literal"), qr = "\"", Qr = Nn("\"", !1), Er = /^[^"]/, Rr = jn(["\""], !0, !1), Tr = function (t) {
                          return pu("LiteralString").set({ value: t.join("") });
                        }, Fr = "'", Lr = Nn("'", !1), kr = /^[^']/, Nr = jn(["'"], !0, !1), jr = Mn("escaped double-quoted-string character"), Mr = "\\\\", Ir = Nn("\\\\", !1), Ur = function () {
                          return "\\";
                        }, Vr = "\\\"", zr = Nn("\\\"", !1), Dr = function () {
                          return "\"";
                        }, Zr = "\\b", Or = Nn("\\b", !1), Br = function () {
                          return "\b";
                        }, $r = "\\v", Gr = Nn("\\v", !1), Hr = function () {
                          return "\x0B";
                        }, Jr = "\\f", Kr = Nn("\\f", !1), Wr = function () {
                          return "\f";
                        }, Xr = "\\t", Yr = Nn("\\t", !1), te = function () {
                          return "\t";
                        }, re = "\\r", ee = Nn("\\r", !1), ne = function () {
                          return "\r";
                        }, ue = "\\n", se = Nn("\\n", !1), ae = function () {
                          return "\n";
                        }, oe = "\\e", ie = Nn("\\e", !1), ce = function () {
                          return "\x1B";
                        }, le = "\\x", fe = Nn("\\x", !1), he = /^[0-9a-fA-F]/, Ae = jn([
                          [
                            "0",
                            "9"
                          ],
                          [
                            "a",
                            "f"
                          ],
                          [
                            "A",
                            "F"
                          ]
                        ], !1, !1), de = function (t) {
                          return String.fromCharCode(parseInt(t, 16));
                        }, pe = "\\u", xe = Nn("\\u", !1), be = Mn("escaped single-quoted-string character"), ge = "\\'", ve = Nn("\\'", !1), Pe = function () {
                          return "'";
                        }, Ce = Mn("regular expression literal"), ye = "`", me = Nn("`", !1), _e = "\\`", Se = Nn("\\`", !1), we = /^[^`]/, qe = jn(["`"], !0, !1), Qe = function (r) {
                          var e;
                          try {
                            e = new RegExp(r.replace(/\\`/g, "`"));
                          } catch (r) {
                            !function (r, e) {
                              throw e = void 0 !== e ? e : Un(Qn, qn), function (r, e) {
                                return new t(r, null, null, e);
                              }(r, e);
                            }(r.message);
                          }
                          return pu("LiteralRegExp").set({ value: e });
                        }, Ee = Mn("numeric literal"), Re = /^[+\-]/, Te = jn([
                          "+",
                          "-"
                        ], !1, !1), Fe = "0b", Le = Nn("0b", !1), ke = /^[01]/, Ne = jn([
                          "0",
                          "1"
                        ], !1, !1), je = function (t, r) {
                          return pu("LiteralNumber").set({ value: parseInt(t + r, 2) });
                        }, Me = "0o", Ie = Nn("0o", !1), Ue = /^[0-7]/, Ve = jn([[
                            "0",
                            "7"
                          ]], !1, !1), ze = function (t, r) {
                          return pu("LiteralNumber").set({ value: parseInt(t + r, 8) });
                        }, De = "0x", Ze = Nn("0x", !1), Oe = function (t, r) {
                          return pu("LiteralNumber").set({ value: parseInt(t + r, 16) });
                        }, Be = /^[0-9]/, $e = jn([[
                            "0",
                            "9"
                          ]], !1, !1), Ge = ".", He = Nn(".", !1), Je = /^[eE]/, Ke = jn([
                          "e",
                          "E"
                        ], !1, !1), We = function (t) {
                          return pu("LiteralNumber").set({ value: parseFloat(t) });
                        }, Xe = function (t) {
                          return pu("LiteralNumber").set({ value: parseInt(t, 10) });
                        }, Ye = Mn("global value"), tn = "true", rn = Nn("true", !1), en = function () {
                          return pu("LiteralValue").set({ value: !0 });
                        }, nn = "false", un = Nn("false", !1), sn = function () {
                          return pu("LiteralValue").set({ value: !1 });
                        }, an = "null", on = Nn("null", !1), cn = function () {
                          return pu("LiteralValue").set({ value: null });
                        }, ln = "NaN", fn = Nn("NaN", !1), hn = function () {
                          return pu("LiteralValue").set({ value: NaN });
                        }, An = "undefined", dn = Nn("undefined", !1), pn = function () {
                          return pu("LiteralValue").set({ value: void 0 });
                        }, xn = Mn("optional blank"), bn = Mn("multi-line comment"), gn = "/*", vn = Nn("/*", !1), Pn = "*/", Cn = Nn("*/", !1), yn = { type: "any" }, mn = Mn("any whitespaces"), _n = /^[ \t\r\n]/, Sn = jn([
                          " ",
                          "\t",
                          "\r",
                          "\n"
                        ], !1, !1), wn = Mn("end of file"), qn = 0, Qn = 0, En = [{
                            line: 1,
                            column: 1
                          }], Rn = 0, Tn = [], Fn = 0, Ln = {};
                      if ("startRule" in e) {
                        if (!(e.startRule in s))
                          throw new Error("Can't start parsing from rule \"" + e.startRule + "\".");
                        a = s[e.startRule];
                      }
                      function kn() {
                        return Un(Qn, qn);
                      }
                      function Nn(t, r) {
                        return {
                          type: "literal",
                          text: t,
                          ignoreCase: r
                        };
                      }
                      function jn(t, r, e) {
                        return {
                          type: "class",
                          parts: t,
                          inverted: r,
                          ignoreCase: e
                        };
                      }
                      function Mn(t) {
                        return {
                          type: "other",
                          description: t
                        };
                      }
                      function In(t) {
                        var e, n = En[t];
                        if (n)
                          return n;
                        for (e = t - 1; !En[e];)
                          e--;
                        for (n = {
                            line: (n = En[e]).line,
                            column: n.column
                          }; e < t;)
                          10 === r.charCodeAt(e) ? (n.line++, n.column = 1) : n.column++, e++;
                        return En[t] = n, n;
                      }
                      function Un(t, r) {
                        var e = In(t), n = In(r);
                        return {
                          start: {
                            offset: t,
                            line: e.line,
                            column: e.column
                          },
                          end: {
                            offset: r,
                            line: n.line,
                            column: n.column
                          }
                        };
                      }
                      function Vn(t) {
                        qn < Rn || (qn > Rn && (Rn = qn, Tn = []), Tn.push(t));
                      }
                      function zn(r, e, n) {
                        return new t(t.buildMessage(r, e), r, e, n);
                      }
                      function Dn() {
                        var t, e, n = 38 * qn + 0, s = Ln[n];
                        return s ? (qn = s.nextPos, s.result) : (t = qn, fu() !== u && (e = (function () {
                          var t, e, n, s, a, o, f, h, A = 38 * qn + 1, d = Ln[A];
                          if (d)
                            return qn = d.nextPos, d.result;
                          if (t = qn, (e = Zn()) !== u) {
                            for (n = [], s = qn, (a = fu()) !== u ? (44 === r.charCodeAt(qn) ? (o = i, qn++) : (o = u, 0 === Fn && Vn(c)), o !== u && (f = fu()) !== u && (h = Zn()) !== u ? s = a = [
                                a,
                                o,
                                f,
                                h
                              ] : (qn = s, s = u)) : (qn = s, s = u); s !== u;)
                              n.push(s), s = qn, (a = fu()) !== u ? (44 === r.charCodeAt(qn) ? (o = i, qn++) : (o = u, 0 === Fn && Vn(c)), o !== u && (f = fu()) !== u && (h = Zn()) !== u ? s = a = [
                                a,
                                o,
                                f,
                                h
                              ] : (qn = s, s = u)) : (qn = s, s = u);
                            n !== u ? (Qn = t, e = l(e, n), t = e) : (qn = t, t = u);
                          } else
                            qn = t, t = u;
                          return Ln[A] = {
                            nextPos: qn,
                            result: t
                          }, t;
                        }())) !== u && fu() !== u && (function () {
                          var t, e, n = 38 * qn + 37, s = Ln[n];
                          return s ? (qn = s.nextPos, s.result) : (Fn++, t = qn, Fn++, r.length > qn ? (e = r.charAt(qn), qn++) : (e = u, 0 === Fn && Vn(yn)), Fn--, e === u ? t = void 0 : (qn = t, t = u), Fn--, t === u && (e = u, 0 === Fn && Vn(wn)), Ln[n] = {
                            nextPos: qn,
                            result: t
                          }, t);
                        }()) !== u ? (Qn = t, t = o(e)) : (qn = t, t = u), Ln[n] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function Zn() {
                        var t, e, n, s, a, o, i = 38 * qn + 2, c = Ln[i];
                        if (c)
                          return qn = c.nextPos, c.result;
                        if (t = qn, (e = (function () {
                            var t, e, n, s, a, o = 38 * qn + 3, i = Ln[o];
                            return i ? (qn = i.nextPos, i.result) : (t = qn, (e = Bn()) === u && (e = null), e !== u && fu() !== u && (n = $n()) !== u && fu() !== u ? (33 === r.charCodeAt(qn) ? (s = h, qn++) : (s = u, 0 === Fn && Vn(A)), s === u && (s = null), s !== u && fu() !== u ? ((a = Gn()) === u && (a = null), a !== u ? (Qn = t, e = d(e, n, s, a), t = e) : (qn = t, t = u)) : (qn = t, t = u)) : (qn = t, t = u), Ln[o] = {
                              nextPos: qn,
                              result: t
                            }, t);
                          }())) !== u) {
                          for (n = [], s = qn, (a = fu()) !== u && (o = On()) !== u ? s = a = [
                              a,
                              o
                            ] : (qn = s, s = u); s !== u;)
                            n.push(s), s = qn, (a = fu()) !== u && (o = On()) !== u ? s = a = [
                              a,
                              o
                            ] : (qn = s, s = u);
                          n !== u ? (Qn = t, t = e = f(e, n)) : (qn = t, t = u);
                        } else
                          qn = t, t = u;
                        return Ln[i] = {
                          nextPos: qn,
                          result: t
                        }, t;
                      }
                      function On() {
                        var t, e, n, s, a, o = 38 * qn + 4, i = Ln[o];
                        return i ? (qn = i.nextPos, i.result) : (t = qn, (e = Bn()) !== u && fu() !== u && (n = $n()) !== u && fu() !== u ? (33 === r.charCodeAt(qn) ? (s = h, qn++) : (s = u, 0 === Fn && Vn(A)), s === u && (s = null), s !== u && fu() !== u ? ((a = Gn()) === u && (a = null), a !== u ? (Qn = t, t = e = d(e, n, s, a)) : (qn = t, t = u)) : (qn = t, t = u)) : (qn = t, t = u), Ln[o] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function Bn() {
                        var t, e, n, s = 38 * qn + 5, a = Ln[s];
                        return a ? (qn = a.nextPos, a.result) : (Fn++, t = qn, e = qn, r.substr(qn, 2) === x ? (n = x, qn += 2) : (n = u, 0 === Fn && Vn(b)), n === u && (47 === r.charCodeAt(qn) ? (n = g, qn++) : (n = u, 0 === Fn && Vn(v)), n === u && (r.substr(qn, 3) === P ? (n = P, qn += 3) : (n = u, 0 === Fn && Vn(C)), n === u && (r.substr(qn, 2) === y ? (n = y, qn += 2) : (n = u, 0 === Fn && Vn(m)), n === u && (r.substr(qn, 3) === _ ? (n = _, qn += 3) : (n = u, 0 === Fn && Vn(S)), n === u && (r.substr(qn, 2) === w ? (n = w, qn += 2) : (n = u, 0 === Fn && Vn(q)), n === u && (r.substr(qn, 3) === Q ? (n = Q, qn += 3) : (n = u, 0 === Fn && Vn(E)), n === u && (r.substr(qn, 2) === R ? (n = R, qn += 2) : (n = u, 0 === Fn && Vn(T)), n === u && (r.substr(qn, 4) === F ? (n = F, qn += 4) : (n = u, 0 === Fn && Vn(L)), n === u && (r.substr(qn, 3) === k ? (n = k, qn += 3) : (n = u, 0 === Fn && Vn(N)), n === u && (r.substr(qn, 3) === j ? (n = j, qn += 3) : (n = u, 0 === Fn && Vn(M)), n === u && (r.substr(qn, 2) === I ? (n = I, qn += 2) : (n = u, 0 === Fn && Vn(U)), n === u && (r.substr(qn, 3) === V ? (n = V, qn += 3) : (n = u, 0 === Fn && Vn(z)), n === u && (r.substr(qn, 3) === D ? (n = D, qn += 3) : (n = u, 0 === Fn && Vn(Z))))))))))))))), (e = n !== u ? r.substring(e, qn) : n) !== u ? ((n = (function () {
                          var t, e, n, s = 38 * qn + 6, a = Ln[s];
                          return a ? (qn = a.nextPos, a.result) : (t = qn, 58 === r.charCodeAt(qn) ? (e = B, qn++) : (e = u, 0 === Fn && Vn($)), e !== u && (n = au()) !== u ? (Qn = t, e = G(n), t = e) : (qn = t, t = u), t === u && (t = qn, 58 === r.charCodeAt(qn) ? (e = B, qn++) : (e = u, 0 === Fn && Vn($)), e !== u && (n = ou()) !== u ? (Qn = t, e = H(n), t = e) : (qn = t, t = u)), Ln[s] = {
                            nextPos: qn,
                            result: t
                          }, t);
                        }())) === u && (n = null), n !== u ? (Qn = t, t = e = O(e, n)) : (qn = t, t = u)) : (qn = t, t = u), Fn--, t === u && (e = u, 0 === Fn && Vn(p)), Ln[s] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function $n() {
                        var t, e, n = 38 * qn + 7, s = Ln[n];
                        return s ? (qn = s.nextPos, s.result) : (t = qn, (e = au()) !== u && (Qn = t, e = J(e)), (t = e) === u && (t = qn, (e = ou()) !== u && (Qn = t, e = K(e)), (t = e) === u && (t = qn, 42 === r.charCodeAt(qn) ? (e = W, qn++) : (e = u, 0 === Fn && Vn(X)), e !== u && (Qn = t, e = Y()), t = e)), Ln[n] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function Gn() {
                        var t, e, n, s, a = 38 * qn + 8, o = Ln[a];
                        return o ? (qn = o.nextPos, o.result) : (t = qn, 91 === r.charCodeAt(qn) ? (e = tt, qn++) : (e = u, 0 === Fn && Vn(rt)), e !== u && fu() !== u && (n = Hn()) !== u && fu() !== u ? (93 === r.charCodeAt(qn) ? (s = et, qn++) : (s = u, 0 === Fn && Vn(nt)), s !== u ? (Qn = t, t = e = ut(n)) : (qn = t, t = u)) : (qn = t, t = u), Ln[a] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function Hn() {
                        var t, e, n, s, a, o, i = 38 * qn + 9, c = Ln[i];
                        return c ? (qn = c.nextPos, c.result) : (t = qn, (e = Jn()) !== u && fu() !== u ? (r.substr(qn, 2) === st ? (n = st, qn += 2) : (n = u, 0 === Fn && Vn(at)), n !== u && fu() !== u && (s = Hn()) !== u ? (Qn = t, t = e = ot(e, s)) : (qn = t, t = u)) : (qn = t, t = u), t === u && (t = qn, (e = Jn()) !== u && fu() !== u ? (63 === r.charCodeAt(qn) ? (n = it, qn++) : (n = u, 0 === Fn && Vn(ct)), n !== u && fu() !== u && (s = Hn()) !== u && fu() !== u ? (58 === r.charCodeAt(qn) ? (a = B, qn++) : (a = u, 0 === Fn && Vn($)), a !== u && fu() !== u && (o = Hn()) !== u ? (Qn = t, t = e = lt(e, s, o)) : (qn = t, t = u)) : (qn = t, t = u)) : (qn = t, t = u), t === u && (t = Jn())), Ln[i] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function Jn() {
                        var t, e, n, s, a, o = 38 * qn + 10, i = Ln[o];
                        return i ? (qn = i.nextPos, i.result) : (t = qn, (e = Kn()) !== u && fu() !== u ? (n = qn, r.substr(qn, 2) === ft ? (s = ft, qn += 2) : (s = u, 0 === Fn && Vn(ht)), (n = s !== u ? r.substring(n, qn) : s) !== u && (s = fu()) !== u && (a = Jn()) !== u ? (Qn = t, t = e = At(e, n, a)) : (qn = t, t = u)) : (qn = t, t = u), t === u && (t = Kn()), Ln[o] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function Kn() {
                        var t, e, n, s, a, o = 38 * qn + 11, i = Ln[o];
                        return i ? (qn = i.nextPos, i.result) : (t = qn, (e = Wn()) !== u && fu() !== u ? (n = qn, r.substr(qn, 2) === dt ? (s = dt, qn += 2) : (s = u, 0 === Fn && Vn(pt)), (n = s !== u ? r.substring(n, qn) : s) !== u && (s = fu()) !== u && (a = Kn()) !== u ? (Qn = t, t = e = At(e, n, a)) : (qn = t, t = u)) : (qn = t, t = u), t === u && (t = Wn()), Ln[o] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function Wn() {
                        var t, e, n, s, a, o = 38 * qn + 12, i = Ln[o];
                        return i ? (qn = i.nextPos, i.result) : (t = qn, (e = Xn()) !== u && fu() !== u ? (n = qn, 124 === r.charCodeAt(qn) ? (s = xt, qn++) : (s = u, 0 === Fn && Vn(bt)), (n = s !== u ? r.substring(n, qn) : s) !== u && (s = fu()) !== u && (a = Wn()) !== u ? (Qn = t, t = e = gt(e, n, a)) : (qn = t, t = u)) : (qn = t, t = u), t === u && (t = Xn()), Ln[o] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function Xn() {
                        var t, e, n, s, a, o = 38 * qn + 13, i = Ln[o];
                        return i ? (qn = i.nextPos, i.result) : (t = qn, (e = Yn()) !== u && fu() !== u ? (n = qn, 94 === r.charCodeAt(qn) ? (s = vt, qn++) : (s = u, 0 === Fn && Vn(Pt)), (n = s !== u ? r.substring(n, qn) : s) !== u && (s = fu()) !== u && (a = Xn()) !== u ? (Qn = t, t = e = gt(e, n, a)) : (qn = t, t = u)) : (qn = t, t = u), t === u && (t = Yn()), Ln[o] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function Yn() {
                        var t, e, n, s, a, o = 38 * qn + 14, i = Ln[o];
                        return i ? (qn = i.nextPos, i.result) : (t = qn, (e = tu()) !== u && fu() !== u ? (n = qn, 38 === r.charCodeAt(qn) ? (s = Ct, qn++) : (s = u, 0 === Fn && Vn(yt)), (n = s !== u ? r.substring(n, qn) : s) !== u && (s = fu()) !== u && (a = Yn()) !== u ? (Qn = t, t = e = gt(e, n, a)) : (qn = t, t = u)) : (qn = t, t = u), t === u && (t = tu()), Ln[o] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function tu() {
                        var t, e, n, s, a, o = 38 * qn + 15, i = Ln[o];
                        return i ? (qn = i.nextPos, i.result) : (t = qn, (e = ru()) !== u && fu() !== u ? (n = qn, r.substr(qn, 2) === mt ? (s = mt, qn += 2) : (s = u, 0 === Fn && Vn(_t)), s === u && (r.substr(qn, 2) === St ? (s = St, qn += 2) : (s = u, 0 === Fn && Vn(wt)), s === u && (r.substr(qn, 2) === qt ? (s = qt, qn += 2) : (s = u, 0 === Fn && Vn(Qt)), s === u && (r.substr(qn, 2) === Et ? (s = Et, qn += 2) : (s = u, 0 === Fn && Vn(Rt)), s === u && (60 === r.charCodeAt(qn) ? (s = Tt, qn++) : (s = u, 0 === Fn && Vn(Ft)), s === u && (62 === r.charCodeAt(qn) ? (s = Lt, qn++) : (s = u, 0 === Fn && Vn(kt)), s === u && (r.substr(qn, 2) === Nt ? (s = Nt, qn += 2) : (s = u, 0 === Fn && Vn(jt)), s === u && (r.substr(qn, 2) === Mt ? (s = Mt, qn += 2) : (s = u, 0 === Fn && Vn(It))))))))), (n = s !== u ? r.substring(n, qn) : s) !== u && (s = fu()) !== u && (a = tu()) !== u ? (Qn = t, t = e = Ut(e, n, a)) : (qn = t, t = u)) : (qn = t, t = u), t === u && (t = ru()), Ln[o] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function ru() {
                        var t, e, n, s, a, o = 38 * qn + 16, i = Ln[o];
                        return i ? (qn = i.nextPos, i.result) : (t = qn, (e = eu()) !== u && fu() !== u ? (n = qn, r.substr(qn, 2) === Vt ? (s = Vt, qn += 2) : (s = u, 0 === Fn && Vn(zt)), s === u && (r.substr(qn, 2) === Dt ? (s = Dt, qn += 2) : (s = u, 0 === Fn && Vn(Zt))), (n = s !== u ? r.substring(n, qn) : s) !== u && (s = fu()) !== u && (a = ru()) !== u ? (Qn = t, t = e = gt(e, n, a)) : (qn = t, t = u)) : (qn = t, t = u), t === u && (t = eu()), Ln[o] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function eu() {
                        var t, e, n, s, a, o = 38 * qn + 17, i = Ln[o];
                        return i ? (qn = i.nextPos, i.result) : (t = qn, (e = nu()) !== u && fu() !== u ? (n = qn, 43 === r.charCodeAt(qn) ? (s = Ot, qn++) : (s = u, 0 === Fn && Vn(Bt)), s === u && (45 === r.charCodeAt(qn) ? (s = $t, qn++) : (s = u, 0 === Fn && Vn(Gt))), (n = s !== u ? r.substring(n, qn) : s) !== u && (s = fu()) !== u && (a = eu()) !== u ? (Qn = t, t = e = Ht(e, n, a)) : (qn = t, t = u)) : (qn = t, t = u), t === u && (t = nu()), Ln[o] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function nu() {
                        var t, e, n, s, a, o = 38 * qn + 18, i = Ln[o];
                        return i ? (qn = i.nextPos, i.result) : (t = qn, (e = uu()) !== u && fu() !== u ? (n = qn, r.substr(qn, 2) === Jt ? (s = Jt, qn += 2) : (s = u, 0 === Fn && Vn(Kt)), s === u && (42 === r.charCodeAt(qn) ? (s = W, qn++) : (s = u, 0 === Fn && Vn(X)), s === u && (47 === r.charCodeAt(qn) ? (s = g, qn++) : (s = u, 0 === Fn && Vn(v)), s === u && (37 === r.charCodeAt(qn) ? (s = Wt, qn++) : (s = u, 0 === Fn && Vn(Xt))))), (n = s !== u ? r.substring(n, qn) : s) !== u && (s = fu()) !== u && (a = nu()) !== u ? (Qn = t, t = e = Ht(e, n, a)) : (qn = t, t = u)) : (qn = t, t = u), t === u && (t = uu()), Ln[o] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function uu() {
                        var t, e, n, s = 38 * qn + 19, a = Ln[s];
                        return a ? (qn = a.nextPos, a.result) : (t = qn, e = qn, 33 === r.charCodeAt(qn) ? (n = h, qn++) : (n = u, 0 === Fn && Vn(A)), n === u && (126 === r.charCodeAt(qn) ? (n = Yt, qn++) : (n = u, 0 === Fn && Vn(tr))), (e = n !== u ? r.substring(e, qn) : n) !== u && (n = su()) !== u ? (Qn = t, t = e = rr(e, n)) : (qn = t, t = u), t === u && (t = su()), Ln[s] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function su() {
                        var t, e = 38 * qn + 20, n = Ln[e];
                        return n ? (qn = n.nextPos, n.result) : ((t = (function () {
                          var t, e, n, s, a, o = 38 * qn + 21, l = Ln[o];
                          return l ? (qn = l.nextPos, l.result) : (t = qn, (e = au()) !== u && fu() !== u ? (40 === r.charCodeAt(qn) ? (n = er, qn++) : (n = u, 0 === Fn && Vn(nr)), n !== u && fu() !== u ? ((s = (function () {
                            var t, e, n, s, a, o, l, f, h = 38 * qn + 22, A = Ln[h];
                            if (A)
                              return qn = A.nextPos, A.result;
                            if (t = qn, (e = Hn()) !== u) {
                              for (n = [], s = qn, (a = fu()) !== u ? (44 === r.charCodeAt(qn) ? (o = i, qn++) : (o = u, 0 === Fn && Vn(c)), o !== u && (l = fu()) !== u && (f = Hn()) !== u ? s = a = [
                                  a,
                                  o,
                                  l,
                                  f
                                ] : (qn = s, s = u)) : (qn = s, s = u); s !== u;)
                                n.push(s), s = qn, (a = fu()) !== u ? (44 === r.charCodeAt(qn) ? (o = i, qn++) : (o = u, 0 === Fn && Vn(c)), o !== u && (l = fu()) !== u && (f = Hn()) !== u ? s = a = [
                                  a,
                                  o,
                                  l,
                                  f
                                ] : (qn = s, s = u)) : (qn = s, s = u);
                              n !== u ? (Qn = t, e = or(e, n), t = e) : (qn = t, t = u);
                            } else
                              qn = t, t = u;
                            return Ln[h] = {
                              nextPos: qn,
                              result: t
                            }, t;
                          }())) === u && (s = null), s !== u && fu() !== u ? (41 === r.charCodeAt(qn) ? (a = ur, qn++) : (a = u, 0 === Fn && Vn(sr)), a !== u ? (Qn = t, e = ar(e, s), t = e) : (qn = t, t = u)) : (qn = t, t = u)) : (qn = t, t = u)) : (qn = t, t = u), Ln[o] = {
                            nextPos: qn,
                            result: t
                          }, t);
                        }())) === u && (t = (function () {
                          var t, e, n, s = 38 * qn + 23, a = Ln[s];
                          return a ? (qn = a.nextPos, a.result) : (Fn++, t = qn, 64 === r.charCodeAt(qn) ? (e = cr, qn++) : (e = u, 0 === Fn && Vn(lr)), e !== u && (n = au()) !== u ? (Qn = t, e = fr(n), t = e) : (qn = t, t = u), t === u && (t = qn, 64 === r.charCodeAt(qn) ? (e = cr, qn++) : (e = u, 0 === Fn && Vn(lr)), e !== u && (n = ou()) !== u ? (Qn = t, e = hr(n), t = e) : (qn = t, t = u)), Fn--, t === u && (e = u, 0 === Fn && Vn(ir)), Ln[s] = {
                            nextPos: qn,
                            result: t
                          }, t);
                        }())) === u && (t = (function () {
                          var t, e, n, s, a = 38 * qn + 24, o = Ln[a];
                          return o ? (qn = o.nextPos, o.result) : (Fn++, t = qn, 123 === r.charCodeAt(qn) ? (e = dr, qn++) : (e = u, 0 === Fn && Vn(pr)), e !== u && fu() !== u && (n = au()) !== u && fu() !== u ? (125 === r.charCodeAt(qn) ? (s = xr, qn++) : (s = u, 0 === Fn && Vn(br)), s !== u ? (Qn = t, e = gr(n), t = e) : (qn = t, t = u)) : (qn = t, t = u), Fn--, t === u && (e = u, 0 === Fn && Vn(Ar)), Ln[a] = {
                            nextPos: qn,
                            result: t
                          }, t);
                        }())) === u && (t = (function () {
                          var t, e = 38 * qn + 25, n = Ln[e];
                          return n ? (qn = n.nextPos, n.result) : ((t = ou()) === u && (t = (function () {
                            var t, e, n, s, a, o = 38 * qn + 31, i = Ln[o];
                            if (i)
                              return qn = i.nextPos, i.result;
                            if (Fn++, t = qn, 96 === r.charCodeAt(qn) ? (e = ye, qn++) : (e = u, 0 === Fn && Vn(me)), e !== u) {
                              for (n = qn, s = [], r.substr(qn, 2) === _e ? (a = _e, qn += 2) : (a = u, 0 === Fn && Vn(Se)), a === u && (we.test(r.charAt(qn)) ? (a = r.charAt(qn), qn++) : (a = u, 0 === Fn && Vn(qe))); a !== u;)
                                s.push(a), r.substr(qn, 2) === _e ? (a = _e, qn += 2) : (a = u, 0 === Fn && Vn(Se)), a === u && (we.test(r.charAt(qn)) ? (a = r.charAt(qn), qn++) : (a = u, 0 === Fn && Vn(qe)));
                              (n = s !== u ? r.substring(n, qn) : s) !== u ? (96 === r.charCodeAt(qn) ? (s = ye, qn++) : (s = u, 0 === Fn && Vn(me)), s !== u ? (Qn = t, e = Qe(n), t = e) : (qn = t, t = u)) : (qn = t, t = u);
                            } else
                              qn = t, t = u;
                            return Fn--, t === u && (e = u, 0 === Fn && Vn(Ce)), Ln[o] = {
                              nextPos: qn,
                              result: t
                            }, t;
                          }())) === u && (t = (function () {
                            var t, e, n, s, a, o, i, c, l, f, h, A, d = 38 * qn + 32, p = Ln[d];
                            if (p)
                              return qn = p.nextPos, p.result;
                            if (Fn++, t = qn, e = qn, Re.test(r.charAt(qn)) ? (n = r.charAt(qn), qn++) : (n = u, 0 === Fn && Vn(Te)), n === u && (n = null), (e = n !== u ? r.substring(e, qn) : n) !== u) {
                              if (r.substr(qn, 2) === Fe ? (n = Fe, qn += 2) : (n = u, 0 === Fn && Vn(Le)), n !== u) {
                                if (s = qn, a = [], ke.test(r.charAt(qn)) ? (o = r.charAt(qn), qn++) : (o = u, 0 === Fn && Vn(Ne)), o !== u)
                                  for (; o !== u;)
                                    a.push(o), ke.test(r.charAt(qn)) ? (o = r.charAt(qn), qn++) : (o = u, 0 === Fn && Vn(Ne));
                                else
                                  a = u;
                                (s = a !== u ? r.substring(s, qn) : a) !== u ? (Qn = t, e = je(e, s), t = e) : (qn = t, t = u);
                              } else
                                qn = t, t = u;
                            } else
                              qn = t, t = u;
                            if (t === u) {
                              if (t = qn, e = qn, Re.test(r.charAt(qn)) ? (n = r.charAt(qn), qn++) : (n = u, 0 === Fn && Vn(Te)), n === u && (n = null), (e = n !== u ? r.substring(e, qn) : n) !== u) {
                                if (r.substr(qn, 2) === Me ? (n = Me, qn += 2) : (n = u, 0 === Fn && Vn(Ie)), n !== u) {
                                  if (s = qn, a = [], Ue.test(r.charAt(qn)) ? (o = r.charAt(qn), qn++) : (o = u, 0 === Fn && Vn(Ve)), o !== u)
                                    for (; o !== u;)
                                      a.push(o), Ue.test(r.charAt(qn)) ? (o = r.charAt(qn), qn++) : (o = u, 0 === Fn && Vn(Ve));
                                  else
                                    a = u;
                                  (s = a !== u ? r.substring(s, qn) : a) !== u ? (Qn = t, e = ze(e, s), t = e) : (qn = t, t = u);
                                } else
                                  qn = t, t = u;
                              } else
                                qn = t, t = u;
                              if (t === u) {
                                if (t = qn, e = qn, Re.test(r.charAt(qn)) ? (n = r.charAt(qn), qn++) : (n = u, 0 === Fn && Vn(Te)), n === u && (n = null), (e = n !== u ? r.substring(e, qn) : n) !== u) {
                                  if (r.substr(qn, 2) === De ? (n = De, qn += 2) : (n = u, 0 === Fn && Vn(Ze)), n !== u) {
                                    if (s = qn, a = [], he.test(r.charAt(qn)) ? (o = r.charAt(qn), qn++) : (o = u, 0 === Fn && Vn(Ae)), o !== u)
                                      for (; o !== u;)
                                        a.push(o), he.test(r.charAt(qn)) ? (o = r.charAt(qn), qn++) : (o = u, 0 === Fn && Vn(Ae));
                                    else
                                      a = u;
                                    (s = a !== u ? r.substring(s, qn) : a) !== u ? (Qn = t, e = Oe(e, s), t = e) : (qn = t, t = u);
                                  } else
                                    qn = t, t = u;
                                } else
                                  qn = t, t = u;
                                if (t === u) {
                                  if (t = qn, e = qn, n = qn, Re.test(r.charAt(qn)) ? (s = r.charAt(qn), qn++) : (s = u, 0 === Fn && Vn(Te)), s === u && (s = null), s !== u) {
                                    for (a = [], Be.test(r.charAt(qn)) ? (o = r.charAt(qn), qn++) : (o = u, 0 === Fn && Vn($e)); o !== u;)
                                      a.push(o), Be.test(r.charAt(qn)) ? (o = r.charAt(qn), qn++) : (o = u, 0 === Fn && Vn($e));
                                    if (a !== u) {
                                      if (46 === r.charCodeAt(qn) ? (o = Ge, qn++) : (o = u, 0 === Fn && Vn(He)), o !== u) {
                                        if (i = [], Be.test(r.charAt(qn)) ? (c = r.charAt(qn), qn++) : (c = u, 0 === Fn && Vn($e)), c !== u)
                                          for (; c !== u;)
                                            i.push(c), Be.test(r.charAt(qn)) ? (c = r.charAt(qn), qn++) : (c = u, 0 === Fn && Vn($e));
                                        else
                                          i = u;
                                        if (i !== u) {
                                          if (c = qn, Je.test(r.charAt(qn)) ? (l = r.charAt(qn), qn++) : (l = u, 0 === Fn && Vn(Ke)), l !== u) {
                                            if (Re.test(r.charAt(qn)) ? (f = r.charAt(qn), qn++) : (f = u, 0 === Fn && Vn(Te)), f === u && (f = null), f !== u) {
                                              if (h = [], Be.test(r.charAt(qn)) ? (A = r.charAt(qn), qn++) : (A = u, 0 === Fn && Vn($e)), A !== u)
                                                for (; A !== u;)
                                                  h.push(A), Be.test(r.charAt(qn)) ? (A = r.charAt(qn), qn++) : (A = u, 0 === Fn && Vn($e));
                                              else
                                                h = u;
                                              h !== u ? c = l = [
                                                l,
                                                f,
                                                h
                                              ] : (qn = c, c = u);
                                            } else
                                              qn = c, c = u;
                                          } else
                                            qn = c, c = u;
                                          c === u && (c = null), c !== u ? n = s = [
                                            s,
                                            a,
                                            o,
                                            i,
                                            c
                                          ] : (qn = n, n = u);
                                        } else
                                          qn = n, n = u;
                                      } else
                                        qn = n, n = u;
                                    } else
                                      qn = n, n = u;
                                  } else
                                    qn = n, n = u;
                                  if ((e = n !== u ? r.substring(e, qn) : n) !== u && (Qn = t, e = We(e)), (t = e) === u) {
                                    if (t = qn, e = qn, n = qn, Re.test(r.charAt(qn)) ? (s = r.charAt(qn), qn++) : (s = u, 0 === Fn && Vn(Te)), s === u && (s = null), s !== u) {
                                      if (a = [], Be.test(r.charAt(qn)) ? (o = r.charAt(qn), qn++) : (o = u, 0 === Fn && Vn($e)), o !== u)
                                        for (; o !== u;)
                                          a.push(o), Be.test(r.charAt(qn)) ? (o = r.charAt(qn), qn++) : (o = u, 0 === Fn && Vn($e));
                                      else
                                        a = u;
                                      a !== u ? n = s = [
                                        s,
                                        a
                                      ] : (qn = n, n = u);
                                    } else
                                      qn = n, n = u;
                                    (e = n !== u ? r.substring(e, qn) : n) !== u && (Qn = t, e = Xe(e)), t = e;
                                  }
                                }
                              }
                            }
                            return Fn--, t === u && (e = u, 0 === Fn && Vn(Ee)), Ln[d] = {
                              nextPos: qn,
                              result: t
                            }, t;
                          }())) === u && (t = lu()), Ln[e] = {
                            nextPos: qn,
                            result: t
                          }, t);
                        }())) === u && (t = (function () {
                          var t, e, n, s, a = 38 * qn + 26, o = Ln[a];
                          return o ? (qn = o.nextPos, o.result) : (t = qn, 40 === r.charCodeAt(qn) ? (e = er, qn++) : (e = u, 0 === Fn && Vn(nr)), e !== u && fu() !== u && (n = Hn()) !== u && fu() !== u ? (41 === r.charCodeAt(qn) ? (s = ur, qn++) : (s = u, 0 === Fn && Vn(sr)), s !== u ? (Qn = t, e = vr(n), t = e) : (qn = t, t = u)) : (qn = t, t = u), Ln[a] = {
                            nextPos: qn,
                            result: t
                          }, t);
                        }())) === u && (t = Zn()), Ln[e] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function au() {
                        var t, e, n, s, a, o, i, c = 38 * qn + 27, l = Ln[c];
                        if (l)
                          return qn = l.nextPos, l.result;
                        if (Fn++, t = qn, e = qn, n = qn, s = qn, Fn++, a = lu(), Fn--, a === u ? s = void 0 : (qn = s, s = u), s !== u) {
                          if (Cr.test(r.charAt(qn)) ? (a = r.charAt(qn), qn++) : (a = u, 0 === Fn && Vn(yr)), a !== u) {
                            for (o = [], mr.test(r.charAt(qn)) ? (i = r.charAt(qn), qn++) : (i = u, 0 === Fn && Vn(_r)); i !== u;)
                              o.push(i), mr.test(r.charAt(qn)) ? (i = r.charAt(qn), qn++) : (i = u, 0 === Fn && Vn(_r));
                            o !== u ? n = s = [
                              s,
                              a,
                              o
                            ] : (qn = n, n = u);
                          } else
                            qn = n, n = u;
                        } else
                          qn = n, n = u;
                        return (e = n !== u ? r.substring(e, qn) : n) !== u && (Qn = t, e = Sr(e)), Fn--, (t = e) === u && (e = u, 0 === Fn && Vn(Pr)), Ln[c] = {
                          nextPos: qn,
                          result: t
                        }, t;
                      }
                      function ou() {
                        var t, e, n, s, a = 38 * qn + 28, o = Ln[a];
                        if (o)
                          return qn = o.nextPos, o.result;
                        if (Fn++, t = qn, 34 === r.charCodeAt(qn) ? (e = qr, qn++) : (e = u, 0 === Fn && Vn(Qr)), e !== u) {
                          for (n = [], (s = iu()) === u && (Er.test(r.charAt(qn)) ? (s = r.charAt(qn), qn++) : (s = u, 0 === Fn && Vn(Rr))); s !== u;)
                            n.push(s), (s = iu()) === u && (Er.test(r.charAt(qn)) ? (s = r.charAt(qn), qn++) : (s = u, 0 === Fn && Vn(Rr)));
                          n !== u ? (34 === r.charCodeAt(qn) ? (s = qr, qn++) : (s = u, 0 === Fn && Vn(Qr)), s !== u ? (Qn = t, t = e = Tr(n)) : (qn = t, t = u)) : (qn = t, t = u);
                        } else
                          qn = t, t = u;
                        if (t === u)
                          if (t = qn, 39 === r.charCodeAt(qn) ? (e = Fr, qn++) : (e = u, 0 === Fn && Vn(Lr)), e !== u) {
                            for (n = [], (s = cu()) === u && (kr.test(r.charAt(qn)) ? (s = r.charAt(qn), qn++) : (s = u, 0 === Fn && Vn(Nr))); s !== u;)
                              n.push(s), (s = cu()) === u && (kr.test(r.charAt(qn)) ? (s = r.charAt(qn), qn++) : (s = u, 0 === Fn && Vn(Nr)));
                            n !== u ? (39 === r.charCodeAt(qn) ? (s = Fr, qn++) : (s = u, 0 === Fn && Vn(Lr)), s !== u ? (Qn = t, t = e = Tr(n)) : (qn = t, t = u)) : (qn = t, t = u);
                          } else
                            qn = t, t = u;
                        return Fn--, t === u && (e = u, 0 === Fn && Vn(wr)), Ln[a] = {
                          nextPos: qn,
                          result: t
                        }, t;
                      }
                      function iu() {
                        var t, e, n, s, a, o, i, c, l = 38 * qn + 29, f = Ln[l];
                        return f ? (qn = f.nextPos, f.result) : (Fn++, t = qn, r.substr(qn, 2) === Mr ? (e = Mr, qn += 2) : (e = u, 0 === Fn && Vn(Ir)), e !== u && (Qn = t, e = Ur()), (t = e) === u && (t = qn, r.substr(qn, 2) === Vr ? (e = Vr, qn += 2) : (e = u, 0 === Fn && Vn(zr)), e !== u && (Qn = t, e = Dr()), (t = e) === u && (t = qn, r.substr(qn, 2) === Zr ? (e = Zr, qn += 2) : (e = u, 0 === Fn && Vn(Or)), e !== u && (Qn = t, e = Br()), (t = e) === u && (t = qn, r.substr(qn, 2) === $r ? (e = $r, qn += 2) : (e = u, 0 === Fn && Vn(Gr)), e !== u && (Qn = t, e = Hr()), (t = e) === u && (t = qn, r.substr(qn, 2) === Jr ? (e = Jr, qn += 2) : (e = u, 0 === Fn && Vn(Kr)), e !== u && (Qn = t, e = Wr()), (t = e) === u && (t = qn, r.substr(qn, 2) === Xr ? (e = Xr, qn += 2) : (e = u, 0 === Fn && Vn(Yr)), e !== u && (Qn = t, e = te()), (t = e) === u && (t = qn, r.substr(qn, 2) === re ? (e = re, qn += 2) : (e = u, 0 === Fn && Vn(ee)), e !== u && (Qn = t, e = ne()), (t = e) === u && (t = qn, r.substr(qn, 2) === ue ? (e = ue, qn += 2) : (e = u, 0 === Fn && Vn(se)), e !== u && (Qn = t, e = ae()), (t = e) === u && (t = qn, r.substr(qn, 2) === oe ? (e = oe, qn += 2) : (e = u, 0 === Fn && Vn(ie)), e !== u && (Qn = t, e = ce()), (t = e) === u && (t = qn, r.substr(qn, 2) === le ? (e = le, qn += 2) : (e = u, 0 === Fn && Vn(fe)), e !== u ? (n = qn, s = qn, he.test(r.charAt(qn)) ? (a = r.charAt(qn), qn++) : (a = u, 0 === Fn && Vn(Ae)), a !== u ? (he.test(r.charAt(qn)) ? (o = r.charAt(qn), qn++) : (o = u, 0 === Fn && Vn(Ae)), o !== u ? s = a = [
                          a,
                          o
                        ] : (qn = s, s = u)) : (qn = s, s = u), (n = s !== u ? r.substring(n, qn) : s) !== u ? (Qn = t, t = e = de(n)) : (qn = t, t = u)) : (qn = t, t = u), t === u && (t = qn, r.substr(qn, 2) === pe ? (e = pe, qn += 2) : (e = u, 0 === Fn && Vn(xe)), e !== u ? (n = qn, s = qn, he.test(r.charAt(qn)) ? (a = r.charAt(qn), qn++) : (a = u, 0 === Fn && Vn(Ae)), a !== u ? (he.test(r.charAt(qn)) ? (o = r.charAt(qn), qn++) : (o = u, 0 === Fn && Vn(Ae)), o !== u ? (he.test(r.charAt(qn)) ? (i = r.charAt(qn), qn++) : (i = u, 0 === Fn && Vn(Ae)), i !== u ? (he.test(r.charAt(qn)) ? (c = r.charAt(qn), qn++) : (c = u, 0 === Fn && Vn(Ae)), c !== u ? s = a = [
                          a,
                          o,
                          i,
                          c
                        ] : (qn = s, s = u)) : (qn = s, s = u)) : (qn = s, s = u)) : (qn = s, s = u), (n = s !== u ? r.substring(n, qn) : s) !== u ? (Qn = t, t = e = de(n)) : (qn = t, t = u)) : (qn = t, t = u))))))))))), Fn--, t === u && (e = u, 0 === Fn && Vn(jr)), Ln[l] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function cu() {
                        var t, e, n = 38 * qn + 30, s = Ln[n];
                        return s ? (qn = s.nextPos, s.result) : (Fn++, t = qn, r.substr(qn, 2) === ge ? (e = ge, qn += 2) : (e = u, 0 === Fn && Vn(ve)), e !== u && (Qn = t, e = Pe()), Fn--, (t = e) === u && (e = u, 0 === Fn && Vn(be)), Ln[n] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function lu() {
                        var t, e, n = 38 * qn + 33, s = Ln[n];
                        return s ? (qn = s.nextPos, s.result) : (Fn++, t = qn, r.substr(qn, 4) === tn ? (e = tn, qn += 4) : (e = u, 0 === Fn && Vn(rn)), e !== u && (Qn = t, e = en()), (t = e) === u && (t = qn, r.substr(qn, 5) === nn ? (e = nn, qn += 5) : (e = u, 0 === Fn && Vn(un)), e !== u && (Qn = t, e = sn()), (t = e) === u && (t = qn, r.substr(qn, 4) === an ? (e = an, qn += 4) : (e = u, 0 === Fn && Vn(on)), e !== u && (Qn = t, e = cn()), (t = e) === u && (t = qn, r.substr(qn, 3) === ln ? (e = ln, qn += 3) : (e = u, 0 === Fn && Vn(fn)), e !== u && (Qn = t, e = hn()), (t = e) === u && (t = qn, r.substr(qn, 9) === An ? (e = An, qn += 9) : (e = u, 0 === Fn && Vn(dn)), e !== u && (Qn = t, e = pn()), t = e)))), Fn--, t === u && (e = u, 0 === Fn && Vn(Ye)), Ln[n] = {
                          nextPos: qn,
                          result: t
                        }, t);
                      }
                      function fu() {
                        var t, r, e = 38 * qn + 34, n = Ln[e];
                        if (n)
                          return qn = n.nextPos, n.result;
                        for (Fn++, t = [], (r = hu()) === u && (r = Au()); r !== u;)
                          t.push(r), (r = hu()) === u && (r = Au());
                        return Fn--, t === u && (r = u, 0 === Fn && Vn(xn)), Ln[e] = {
                          nextPos: qn,
                          result: t
                        }, t;
                      }
                      function hu() {
                        var t, e, n, s, a, o, i = 38 * qn + 35, c = Ln[i];
                        if (c)
                          return qn = c.nextPos, c.result;
                        if (Fn++, t = qn, r.substr(qn, 2) === gn ? (e = gn, qn += 2) : (e = u, 0 === Fn && Vn(vn)), e !== u) {
                          for (n = [], s = qn, a = qn, Fn++, r.substr(qn, 2) === Pn ? (o = Pn, qn += 2) : (o = u, 0 === Fn && Vn(Cn)), Fn--, o === u ? a = void 0 : (qn = a, a = u), a !== u ? (r.length > qn ? (o = r.charAt(qn), qn++) : (o = u, 0 === Fn && Vn(yn)), o !== u ? s = a = [
                              a,
                              o
                            ] : (qn = s, s = u)) : (qn = s, s = u); s !== u;)
                            n.push(s), s = qn, a = qn, Fn++, r.substr(qn, 2) === Pn ? (o = Pn, qn += 2) : (o = u, 0 === Fn && Vn(Cn)), Fn--, o === u ? a = void 0 : (qn = a, a = u), a !== u ? (r.length > qn ? (o = r.charAt(qn), qn++) : (o = u, 0 === Fn && Vn(yn)), o !== u ? s = a = [
                              a,
                              o
                            ] : (qn = s, s = u)) : (qn = s, s = u);
                          n !== u ? (r.substr(qn, 2) === Pn ? (s = Pn, qn += 2) : (s = u, 0 === Fn && Vn(Cn)), s !== u ? t = e = [
                            e,
                            n,
                            s
                          ] : (qn = t, t = u)) : (qn = t, t = u);
                        } else
                          qn = t, t = u;
                        return Fn--, t === u && (e = u, 0 === Fn && Vn(bn)), Ln[i] = {
                          nextPos: qn,
                          result: t
                        }, t;
                      }
                      function Au() {
                        var t, e, n = 38 * qn + 36, s = Ln[n];
                        if (s)
                          return qn = s.nextPos, s.result;
                        if (Fn++, t = [], _n.test(r.charAt(qn)) ? (e = r.charAt(qn), qn++) : (e = u, 0 === Fn && Vn(Sn)), e !== u)
                          for (; e !== u;)
                            t.push(e), _n.test(r.charAt(qn)) ? (e = r.charAt(qn), qn++) : (e = u, 0 === Fn && Vn(Sn));
                        else
                          t = u;
                        return Fn--, t === u && (e = u, 0 === Fn && Vn(mn)), Ln[n] = {
                          nextPos: qn,
                          result: t
                        }, t;
                      }
                      var du = e.util.makeUnroll(kn, e), pu = e.util.makeAST(kn, e);
                      if ((n = a()) !== u && qn === r.length)
                        return n;
                      throw n !== u && qn < r.length && Vn({ type: "end" }), zn(Tn, Rn < r.length ? r.charAt(Rn) : null, Rn < r.length ? Un(Rn, Rn + 1) : Un(Rn, Rn));
                    }
                  };
                }()), ASTQQuery = (function () {
                  function t(r) {
                    _classCallCheck(this || _global, t), (this || _global).asty = new _asty.default(), (this || _global).ast = null, r && this.compile(r);
                  }
                  return _createClass(t, [
                    {
                      key: "compile",
                      value: function (t, r) {
                        var e = this || _global;
                        r && console.log("ASTQ: compile: +-------------------------------------------------------------------------------------------------------\nASTQ: compile: | " + t);
                        var n = _pegjsUtil.default.parse(ASTQQueryParse, t, {
                          startRule: "query",
                          makeAST: function (t, r, n, u) {
                            return e.asty.create.apply(e.asty, u).pos(t, r, n);
                          }
                        });
                        if (null !== n.error)
                          throw new Error("ASTQ: compile: query parsing failed:\n" + _pegjsUtil.default.errorMessage(n.error, !0).replace(/^/gm, "ERROR: "));
                        return (this || _global).ast = n.ast, r && console.log("ASTQ: compile: +-------------------------------------------------------------------------------------------------------\n" + this.dump().replace(/\n$/, "").replace(/^/gm, "ASTQ: compile: | ")), this || _global;
                      }
                    },
                    {
                      key: "dump",
                      value: function () {
                        return (this || _global).ast.dump();
                      }
                    },
                    {
                      key: "execute",
                      value: function (t, r, e, n, u) {
                        return u && console.log("ASTQ: execute: +-------------------------------------------------------------------------------------------------------"), new _astqQueryExec.default(r, e, n, u).execQuery((this || _global).ast, t);
                      }
                    }
                  ]), t;
                }());
              exports.default = ASTQQuery;
            },
            {
              "./astq-query-exec.js": 15,
              "asty": 1,
              "pegjs-util": 3
            }
          ],
          18: [
            function (_dereq_, module, exports) {
              function _typeof(e) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                  return typeof e;
                } : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                })(e);
              }
              function _classCallCheck(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(e, t) {
                for (var r = 0; r < t.length; r++) {
                  var n = t[r];
                  n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
                }
              }
              function _createClass(e, t, r) {
                return t && _defineProperties(e.prototype, t), r && _defineProperties(e, r), e;
              }
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var ASTQUtil = (function () {
                function e() {
                  _classCallCheck(this || _global, e);
                }
                return _createClass(e, null, [
                  {
                    key: "pad",
                    value: function (e, t) {
                      var r = t < 0 ? -t : t;
                      if (e.length > r)
                        e = e.substr(0, r);
                      else {
                        var n = Array(r + 1 - e.length).join(" ");
                        e = t < 0 ? e + n : n + e;
                      }
                      return e;
                    }
                  },
                  {
                    key: "truthy",
                    value: function (e) {
                      var t;
                      switch (_typeof(e)) {
                      case "boolean":
                        t = e;
                        break;
                      case "number":
                        t = 0 !== e && !isNaN(e);
                        break;
                      case "string":
                        t = "" !== e;
                        break;
                      case "object":
                        t = !1, null !== e && (t = !0, e instanceof Array && (t = e.length > 0));
                        break;
                      default:
                        t = !1;
                      }
                      return t;
                    }
                  },
                  {
                    key: "coerce",
                    value: function (e, t) {
                      if (_typeof(e) !== t)
                        try {
                          switch (t) {
                          case "boolean":
                            "boolean" != typeof e && (e = Boolean(e));
                            break;
                          case "number":
                            "number" != typeof e && (e = Number(e));
                            break;
                          case "string":
                            "string" != typeof e && (e = String(e));
                            break;
                          case "regexp":
                            "object" === _typeof(e) && e instanceof RegExp || (e = new RegExp(e));
                          }
                        } catch (e) {
                          throw new Error("cannot coerce value into type " + t);
                        }
                      return e;
                    }
                  }
                ]), e;
              }());
              exports.default = ASTQUtil;
            },
            {}
          ],
          19: [
            function (_dereq_, module, exports) {
              Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0;
              var version = {
                  major: 2,
                  minor: 7,
                  micro: 5,
                  date: 20210107
                }, _default = version;
              exports.default = _default;
            },
            {}
          ],
          20: [
            function (_dereq_, module, exports) {
              var _cacheLru = _interopRequireDefault(_dereq_("cache-lru")), _astqAdapter = _interopRequireDefault(_dereq_("./astq-adapter.js")), _astqAdapterXmldom = _interopRequireDefault(_dereq_("./astq-adapter-xmldom.js")), _astqAdapterParse = _interopRequireDefault(_dereq_("./astq-adapter-parse5.js")), _astqAdapterMozast = _interopRequireDefault(_dereq_("./astq-adapter-mozast.js")), _astqAdapterGraphql = _interopRequireDefault(_dereq_("./astq-adapter-graphql.js")), _astqAdapterJson = _interopRequireDefault(_dereq_("./astq-adapter-json.js")), _astqAdapterCheerio = _interopRequireDefault(_dereq_("./astq-adapter-cheerio.js")), _astqAdapterUnist = _interopRequireDefault(_dereq_("./astq-adapter-unist.js")), _astqAdapterAsty = _interopRequireDefault(_dereq_("./astq-adapter-asty.js")), _astqFuncs = _interopRequireDefault(_dereq_("./astq-funcs.js")), _astqFuncsStd = _interopRequireDefault(_dereq_("./astq-funcs-std.js")), _astqQuery = _interopRequireDefault(_dereq_("./astq-query.js")), _astqVersion = _interopRequireDefault(_dereq_("./astq-version.js"));
              function _interopRequireDefault(e) {
                return e && e.__esModule ? e : { default: e };
              }
              function _typeof(e) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                  return typeof e;
                } : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                })(e);
              }
              function _classCallCheck(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              function _defineProperties(e, t) {
                for (var r = 0; r < t.length; r++) {
                  var a = t[r];
                  a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);
                }
              }
              function _createClass(e, t, r) {
                return t && _defineProperties(e.prototype, t), r && _defineProperties(e, r), e;
              }
              var ASTQ = (function () {
                function e() {
                  for (var t in (_classCallCheck(this || _global, e), (this || _global)._adapter = new _astqAdapter.default().register(_astqAdapterXmldom.default, !1).register(_astqAdapterParse.default, !1).register(_astqAdapterMozast.default, !1).register(_astqAdapterGraphql.default, !1).register(_astqAdapterJson.default, !1).register(_astqAdapterCheerio.default, !1).register(_astqAdapterUnist.default, !1).register(_astqAdapterAsty.default, !1), (this || _global)._funcs = new _astqFuncs.default(), _astqFuncsStd.default))
                    this.func(t, _astqFuncsStd.default[t]);
                  (this || _global)._cache = new _cacheLru.default();
                }
                return _createClass(e, [
                  {
                    key: "version",
                    value: function () {
                      return _astqVersion.default;
                    }
                  },
                  {
                    key: "adapter",
                    value: function (e) {
                      var t = this || _global, r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                      if (arguments.length < 1 || arguments.length > 2)
                        throw new Error("ASTQ#adapter: invalid number of arguments");
                      if ((this || _global)._adapter.unregister(), "object" === _typeof(e) && e instanceof Array || (e = [e]), e.length > 1 && r)
                        throw new Error("ASTQ#adapter: you can force just a single adapter to not taste the AST node");
                      return e.forEach(function (e) {
                        if ("string" == typeof e)
                          if ("mozast" === e)
                            e = _astqAdapterMozast.default;
                          else if ("graphql" === e)
                            e = _astqAdapterGraphql.default;
                          else if ("xmldom" === e)
                            e = _astqAdapterXmldom.default;
                          else if ("parse5" === e)
                            e = _astqAdapterParse.default;
                          else if ("json" === e)
                            e = _astqAdapterJson.default;
                          else if ("cheerio" === e)
                            e = _astqAdapterCheerio.default;
                          else if ("unist" === e)
                            e = _astqAdapterUnist.default;
                          else {
                            if ("asty" !== e)
                              throw new Error("ASTQ#adapter: unknown built-in adapter");
                            e = _astqAdapterAsty.default;
                          }
                        t._adapter.register(e, r);
                      }), this || _global;
                    }
                  },
                  {
                    key: "func",
                    value: function (e, t) {
                      if (2 !== arguments.length)
                        throw new Error("ASTQ#func: invalid number of arguments");
                      return (this || _global)._funcs.register(e, t), this || _global;
                    }
                  },
                  {
                    key: "cache",
                    value: function (e) {
                      if (1 !== arguments.length)
                        throw new Error("ASTQ#cache: invalid number of arguments");
                      return (this || _global)._cache.limit(e), this || _global;
                    }
                  },
                  {
                    key: "compile",
                    value: function (e, t) {
                      if (arguments.length < 1)
                        throw new Error("ASTQ#compile: too less arguments");
                      if (arguments.length > 2)
                        throw new Error("ASTQ#compile: too many arguments");
                      void 0 === t && (t = !1);
                      var r = (this || _global)._cache.get(e);
                      return void 0 === r && ((r = new _astqQuery.default()).compile(e, t), (this || _global)._cache.set(e, r)), r;
                    }
                  },
                  {
                    key: "execute",
                    value: function (e, t, r, a) {
                      if (arguments.length < 2)
                        throw new Error("ASTQ#execute: too less arguments");
                      if (arguments.length > 4)
                        throw new Error("ASTQ#execute: too many arguments");
                      void 0 === r && (r = {}), void 0 === a && (a = !1);
                      var s = (this || _global)._adapter.select(e);
                      if (void 0 === s)
                        throw new Error("ASTQ#execute: no suitable adapter found for node");
                      return t.execute(e, s, r, (this || _global)._funcs, a);
                    }
                  },
                  {
                    key: "query",
                    value: function (e, t, r, a) {
                      if (arguments.length < 2)
                        throw new Error("ASTQ#query: too less arguments");
                      if (arguments.length > 4)
                        throw new Error("ASTQ#query: too many arguments");
                      return void 0 === r && (r = {}), void 0 === a && (a = !1), this.execute(e, this.compile(t, a), r, a);
                    }
                  }
                ]), e;
              }());
              module.exports = ASTQ;
            },
            {
              "./astq-adapter-asty.js": 4,
              "./astq-adapter-cheerio.js": 5,
              "./astq-adapter-graphql.js": 6,
              "./astq-adapter-json.js": 7,
              "./astq-adapter-mozast.js": 8,
              "./astq-adapter-parse5.js": 9,
              "./astq-adapter-unist.js": 10,
              "./astq-adapter-xmldom.js": 11,
              "./astq-adapter.js": 12,
              "./astq-funcs-std.js": 13,
              "./astq-funcs.js": 14,
              "./astq-query.js": 17,
              "./astq-version.js": 19,
              "cache-lru": 2
            }
          ]
        }, {}, [
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20
        ])(20);
      }));
      var exports$1$1 = exports$2;
      exports$2.__esModule;

      var __varRecorder__$9 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/lib/query.js", __contextModule__);

      var __moduleMeta__$9 = {
        pathInPackage: function pathInPackage() {
          return "./lib/query.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ast",
            version: "0.11.3"
          };
        }
      };

      var scopes = exports('B', __varRecorder__$9["lively.ast/lib/query.js__define__"]("scopes", "function", function (parsed) {
        var vis = new ScopeVisitor();
        var scope = vis.newScope(parsed, null);
        vis.accept(parsed, scope, []);
        return scope;
      }, __moduleMeta__$9));

      __varRecorder__$9.scopes = scopes;

      var nodesAtIndex = exports('H', __varRecorder__$9["lively.ast/lib/query.js__define__"]("nodesAtIndex", "function", function (parsed, index) {
        return withMozillaAstDo(parsed, [], function (next, node, found) {
          if (node.start <= index && index <= node.end) {
            found.push(node);
            next();
          }

          return found;
        });
      }, __moduleMeta__$9));

      __varRecorder__$9.nodesAtIndex = nodesAtIndex;

      var scopesAtIndex = __varRecorder__$9["lively.ast/lib/query.js__define__"]("scopesAtIndex", "function", function (parsed, index) {
        return filter(__varRecorder__$9.scopes(parsed), function (scope) {
          var n = scope.node;
          var start = n.start;
          var end = n.end;

          if (n.type === "FunctionDeclaration") {
            start = n.params.length ? n.params[0].start : n.body.start;
            end = n.body.end;
          }

          return start <= index && index <= end;
        }, function (s) {
          return s.subScopes;
        });
      }, __moduleMeta__$9);

      __varRecorder__$9.scopesAtIndex = scopesAtIndex;

      var scopeAtIndex = exports('P', __varRecorder__$9["lively.ast/lib/query.js__define__"]("scopeAtIndex", "function", function (parsed, index) {
        return last(__varRecorder__$9.scopesAtIndex(parsed, index));
      }, __moduleMeta__$9));

      __varRecorder__$9.scopeAtIndex = scopeAtIndex;

      var scopesAtPos = __varRecorder__$9["lively.ast/lib/query.js__define__"]("scopesAtPos", "function", function (pos, parsed) {
        return __varRecorder__$9.nodesAt(pos, parsed).filter(function (node) {
          return node.type === "Program" || node.type === "FunctionDeclaration" || node.type === "FunctionExpression";
        });
      }, __moduleMeta__$9);

      __varRecorder__$9.scopesAtPos = scopesAtPos;

      var nodesInScopeOf = exports('Z', __varRecorder__$9["lively.ast/lib/query.js__define__"]("nodesInScopeOf", "function", function (node) {
        return withMozillaAstDo(node, {
          root: node,
          result: []
        }, function (next, node, state) {
          state.result.push(node);
          if (node !== state.root && (node.type === "Program" || node.type === "FunctionDeclaration" || node.type === "FunctionExpression")) return state;
          next();
          return state;
        }).result;
      }, __moduleMeta__$9));

      __varRecorder__$9.nodesInScopeOf = nodesInScopeOf;

      var declarationsOfScope = exports('K', __varRecorder__$9["lively.ast/lib/query.js__define__"]("declarationsOfScope", "function", function (scope, includeOuter) {
        var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

        if (includeOuter && scope.node.id && scope.node.id.name) {
          result.push(scope.node.id);
        }

        __varRecorder__$9.helpers.declIds(scope.params, result);

        for (var i = 0; i < scope.funcDecls.length; i++) {
          var id = scope.funcDecls[i].id;
          if (id) result.push(id);
        }

        __varRecorder__$9.helpers.varDeclIds(scope, result);

        result.push.apply(result, _toConsumableArray(scope.catches));

        for (var _i = 0; _i < scope.classDecls.length; _i++) {
          var _id = scope.classDecls[_i].id;
          if (_id) result.push(_id);
        }

        result.push.apply(result, _toConsumableArray(scope.importSpecifiers));
        return compact(result);
      }, __moduleMeta__$9));

      __varRecorder__$9.declarationsOfScope = declarationsOfScope;

      var declarationsWithIdsOfScope = __varRecorder__$9["lively.ast/lib/query.js__define__"]("declarationsWithIdsOfScope", "function", function (scope) {
        var bareIds = compact(__varRecorder__$9.helpers.declIds(scope.params).concat(scope.catches));
        var declNodes = [].concat(_toConsumableArray(scope.node.id && scope.node.id.name ? [scope.node] : []), _toConsumableArray(scope.funcDecls.filter(function (ea) {
          return ea.id;
        })), _toConsumableArray(scope.classDecls.filter(function (ea) {
          return ea.id;
        })));
        return bareIds.map(function (ea) {
          return [ea, ea];
        }).concat(declNodes.map(function (ea) {
          return [ea, ea.id];
        })).concat(__varRecorder__$9.helpers.varDecls(scope)).concat(scope.importSpecifiers.map(function (im) {
          return [__varRecorder__$9.statementOf(scope.node, im), im];
        }));
      }, __moduleMeta__$9);

      __varRecorder__$9.declarationsWithIdsOfScope = declarationsWithIdsOfScope;

      var _declaredVarNames = __varRecorder__$9["lively.ast/lib/query.js__define__"]("_declaredVarNames", "function", function (scope, useComments) {
        var result = [];

        var _iterator = _createForOfIteratorHelper(__varRecorder__$9.declarationsOfScope(scope, true)),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var decl = _step.value;
            result.push(decl.name);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (useComments) {
          __varRecorder__$9._findJsLintGlobalDeclarations(scope.node.type === "Program" ? scope.node : scope.node.body, result);
        }

        return result;
      }, __moduleMeta__$9);

      __varRecorder__$9._declaredVarNames = _declaredVarNames;

      var _findJsLintGlobalDeclarations = __varRecorder__$9["lively.ast/lib/query.js__define__"]("_findJsLintGlobalDeclarations", "function", function (node) {
        var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        if (!node || !node.comments) return result;

        var _iterator2 = _createForOfIteratorHelper(node.comments),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var comment = _step2.value;
            var text = comment.text.trim();
            if (!text.startsWith("global")) continue;

            var _iterator3 = _createForOfIteratorHelper(text.replace(__varRecorder__$9.globalDeclRe, "").split(",")),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var globalDecl = _step3.value;
                result.push(globalDecl.trim());
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return result;
      }, __moduleMeta__$9);

      __varRecorder__$9._findJsLintGlobalDeclarations = _findJsLintGlobalDeclarations;

      var resolveReference = __varRecorder__$9["lively.ast/lib/query.js__define__"]("resolveReference", "function", function (ref, scopePath) {
        if (scopePath.length === 0) return [null, null];

        var _scopePath = _toArray(scopePath),
            scope = _scopePath[0],
            outer = _scopePath.slice(1);

        var decls = scope.decls || __varRecorder__$9.declarationsWithIdsOfScope(scope);

        scope.decls = decls;
        var decl = decls.find(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2);
              _ref2[0];
              var id = _ref2[1];

          return id.name === ref;
        });
        return decl || resolveReference(ref, outer);
      }, __moduleMeta__$9);

      __varRecorder__$9.resolveReference = resolveReference;

      var resolveReferences = exports('A', __varRecorder__$9["lively.ast/lib/query.js__define__"]("resolveReferences", "function", function (scope) {
        function rec(scope, outerScopes) {
          var path = [scope].concat(outerScopes);
          scope.refs.forEach(function (ref) {
            var _varRecorder__$resol = __varRecorder__$9.resolveReference(ref.name, path),
                _varRecorder__$resol2 = _slicedToArray(_varRecorder__$resol, 2),
                decl = _varRecorder__$resol2[0],
                id = _varRecorder__$resol2[1];

            map.set(ref, {
              decl: decl,
              declId: id,
              ref: ref
            });
          });
          scope.subScopes.forEach(function (s) {
            return rec(s, path);
          });
        }

        if (scope.referencesResolvedSafely) return scope;
        var map = scope.resolvedRefMap || (scope.resolvedRefMap = new Map());
        rec(scope, []);
        scope.referencesResolvedSafely = true;
        return scope;
      }, __moduleMeta__$9));

      __varRecorder__$9.resolveReferences = resolveReferences;

      var refWithDeclAt = exports('G', __varRecorder__$9["lively.ast/lib/query.js__define__"]("refWithDeclAt", "function", function (pos, scope) {
        var _iterator4 = _createForOfIteratorHelper(scope.resolvedRefMap.values()),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var ref = _step4.value;
            var _ref$ref = ref.ref,
                start = _ref$ref.start,
                end = _ref$ref.end;
            if (start <= pos && pos <= end) return ref;
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }, __moduleMeta__$9));

      __varRecorder__$9.refWithDeclAt = refWithDeclAt;

      var topLevelDeclsAndRefs = exports('t', __varRecorder__$9["lively.ast/lib/query.js__define__"]("topLevelDeclsAndRefs", "function", function (parsed, options) {
        options = options || {};
        options.withComments = true;
        if (typeof parsed === "string") parsed = parse(parsed, options);

        var scope = __varRecorder__$9.scopes(parsed);

        var useComments = !!options.jslintGlobalComment;

        var declared = __varRecorder__$9._declaredVarNames(scope, useComments);

        var refs = scope.refs.concat(scope.subScopes.map(findUndeclaredReferences).flat());
        var undeclared = withoutAll(refs.map(function (ea) {
          return ea.name;
        }), declared);
        return {
          scope: scope,
          varDecls: scope.varDecls,
          funcDecls: scope.funcDecls.filter(function (ea) {
            return ea.id;
          }),
          classDecls: scope.classDecls.filter(function (ea) {
            return ea.id;
          }),
          declaredNames: declared,
          undeclaredNames: undeclared,
          refs: refs,
          thisRefs: scope.thisRefs
        };

        function findUndeclaredReferences(scope) {
          var names = __varRecorder__$9._declaredVarNames(scope, useComments);

          return scope.subScopes.map(findUndeclaredReferences).reduce(function (refs, ea) {
            return refs.concat(ea);
          }, scope.refs).filter(function (ref) {
            return names.indexOf(ref.name) === -1;
          });
        }
      }, __moduleMeta__$9));

      __varRecorder__$9.topLevelDeclsAndRefs = topLevelDeclsAndRefs;

      var findGlobalVarRefs = exports('D', __varRecorder__$9["lively.ast/lib/query.js__define__"]("findGlobalVarRefs", "function", function (parsed, options) {
        var topLevel = __varRecorder__$9.topLevelDeclsAndRefs(parsed, options);

        var noGlobals = topLevel.declaredNames.concat(__varRecorder__$9.knownGlobals);
        return topLevel.refs.filter(function (ea) {
          return noGlobals.indexOf(ea.name) === -1;
        });
      }, __moduleMeta__$9));

      __varRecorder__$9.findGlobalVarRefs = findGlobalVarRefs;

      var findNodesIncludingLines = __varRecorder__$9["lively.ast/lib/query.js__define__"]("findNodesIncludingLines", "function", function (parsed, code, lines, options) {
        if (!code && !parsed) throw new Error("Need at least ast or code");
        code = code || stringify(parsed);
        parsed = parsed && parsed.loc ? parsed : parse(code, {
          locations: true
        });
        return withMozillaAstDo(parsed, [], function (next, node, found) {
          if (lines.every(function (line) {
            return between(line, node.loc.start.line, node.loc.end.line);
          })) {
            pushIfNotIncluded(found, node);
            next();
          }

          return found;
        });
      }, __moduleMeta__$9);

      __varRecorder__$9.findNodesIncludingLines = findNodesIncludingLines;

      var __varDeclIdsFor = __varRecorder__$9["lively.ast/lib/query.js__define__"]("__varDeclIdsFor", "function", function (scope, name) {
        var result = [];

        var _iterator5 = _createForOfIteratorHelper(scope.params),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var ea = _step5.value;
            if (ea.name === name) result.push(ea);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        var _iterator6 = _createForOfIteratorHelper(scope.funcDecls),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var ea = _step6.value;
            if (ea.id && ea.id.name === name) result.push(ea.id);
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        var _iterator7 = _createForOfIteratorHelper(scope.classDecls),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var ea = _step7.value;
            if (ea.id && ea.id.name === name) result.push(ea.id);
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }

        var _iterator8 = _createForOfIteratorHelper(scope.importSpecifiers),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var ea = _step8.value;
            if (ea.name === name) result.push(ea);
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }

        var _iterator9 = _createForOfIteratorHelper(__varRecorder__$9.helpers.varDeclIds(scope)),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var ea = _step9.value;
            if (ea.name === name) result.push(ea);
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }

        return result;
      }, __moduleMeta__$9);

      __varRecorder__$9.__varDeclIdsFor = __varDeclIdsFor;

      var findReferencesAndDeclsInScope = exports('S', __varRecorder__$9["lively.ast/lib/query.js__define__"]("findReferencesAndDeclsInScope", "function", function (scope, name) {
        var _result$decls;

        var startingScope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var result = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
          refs: [],
          decls: []
        };

        if (name === "this") {
          var _result$refs;

          (_result$refs = result.refs).push.apply(_result$refs, _toConsumableArray(scope.thisRefs));

          return result;
        }

        var decls = __varRecorder__$9.__varDeclIdsFor(scope, name);

        if (!startingScope && decls.length) return result;

        var _iterator10 = _createForOfIteratorHelper(scope.refs),
            _step10;

        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            var ref = _step10.value;
            if (ref.name === name) result.refs.push(ref);
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }

        (_result$decls = result.decls).push.apply(_result$decls, _toConsumableArray(decls));

        var _iterator11 = _createForOfIteratorHelper(scope.subScopes),
            _step11;

        try {
          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            var subScope = _step11.value;
            findReferencesAndDeclsInScope(subScope, name, false, result);
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }

        return result;
      }, __moduleMeta__$9));

      __varRecorder__$9.findReferencesAndDeclsInScope = findReferencesAndDeclsInScope;

      var findDeclarationClosestToIndex = exports('O', __varRecorder__$9["lively.ast/lib/query.js__define__"]("findDeclarationClosestToIndex", "function", function (parsed, name, index) {
        var found = null;

        __varRecorder__$9.scopesAtIndex(parsed, index).reverse().find(function (scope) {
          var decls = __varRecorder__$9.declarationsOfScope(scope, true);

          var idx = pluck(decls, "name").indexOf(name);
          if (idx === -1) return false;
          found = decls[idx];
          return true;
        });

        return found;
      }, __moduleMeta__$9));

      __varRecorder__$9.findDeclarationClosestToIndex = findDeclarationClosestToIndex;

      var nodesAt$1 = exports('N', __varRecorder__$9["lively.ast/lib/query.js__define__"]("nodesAt", "function", function (pos, ast) {
        ast = typeof ast === "string" ? parse(ast) : ast;
        return custom.findNodesIncluding(ast, pos);
      }, __moduleMeta__$9));

      __varRecorder__$9.nodesAt = nodesAt$1;

      var statementOf = __varRecorder__$9["lively.ast/lib/query.js__define__"]("statementOf", "function", function (parsed, node, options) {
        var nodes = __varRecorder__$9.nodesAt(node.start + 1, parsed);

        var found = nodes.reverse().find(function (node) {
          return __varRecorder__$9._stmtTypes.includes(node.type);
        });

        if (options && options.asPath) {
          var v = new Visitor();
          var foundPath;
          v.accept = wrap(v.accept, function (proceed, node, state, path) {
            if (node === found) {
              foundPath = path;
              throw new Error("stop search");
            }

            return proceed(node, state, path);
          });

          try {
            v.accept(parsed, {}, []);
          } catch (e) {}

          return foundPath;
        }

        return found;
      }, __moduleMeta__$9);

      __varRecorder__$9.statementOf = statementOf;

      var imports = exports('F', __varRecorder__$9["lively.ast/lib/query.js__define__"]("imports", "function", function (scope) {
        var imports = [];
        var stmts = scope.node.body || [];

        for (var i = 0; i < stmts.length; i++) {
          var stmt = stmts[i];
          if (stmt.type !== "ImportDeclaration") continue;

          if (stmt.specifiers.length === 0) {
            imports.push({
              local: null,
              imported: null,
              fromModule: stmt.source.value,
              node: stmt
            });
            continue;
          }

          var from = stmt.source ? stmt.source.value : "unknown module";
          imports.push.apply(imports, _toConsumableArray(stmt.specifiers.map(function (importSpec) {
            var imported;
            if (importSpec.type === "ImportNamespaceSpecifier") imported = "*";else if (importSpec.type === "ImportDefaultSpecifier") imported = "default";else if (importSpec.type === "ImportSpecifier") imported = importSpec.imported.name;else imported = null;
            return {
              local: importSpec.local ? importSpec.local.name : null,
              imported: imported,
              fromModule: from,
              node: stmt
            };
          })));
        }

        return imports;
      }, __moduleMeta__$9));

      __varRecorder__$9.imports = imports;

      var exports$1 = exports('U', __varRecorder__$9["lively.ast/lib/query.js__define__"]("exports", "function", function (scope) {
        var resolve = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (resolve) __varRecorder__$9.resolveReferences(scope);
        var exports = [];

        var _iterator12 = _createForOfIteratorHelper(scope.exportDecls),
            _step12;

        try {
          var _loop = function _loop() {
            var node = _step12.value;
            exportsStmt = __varRecorder__$9.statementOf(scope.node, node);
            if (!exportsStmt) return "continue";
            from = exportsStmt.source ? exportsStmt.source.value : null;

            if (exportsStmt.type === "ExportAllDeclaration") {
              exports.push({
                local: null,
                exported: "*",
                imported: "*",
                fromModule: from,
                node: node,
                type: "all"
              });
              return "continue";
            }

            if (exportsStmt.type === "ExportDefaultDeclaration") {
              if (__varRecorder__$9.helpers.isDeclaration(exportsStmt.declaration)) {
                exports.push({
                  local: exportsStmt.declaration.id ? exportsStmt.declaration.id.name : null,
                  exported: "default",
                  type: exportsStmt.declaration.type === "FunctionDeclaration" ? "function" : exportsStmt.declaration.type === "ClassDeclaration" ? "class" : null,
                  fromModule: null,
                  node: node,
                  decl: exportsStmt.declaration,
                  declId: exportsStmt.declaration.id
                });
                return "continue";
              }

              if (exportsStmt.declaration.type === "Identifier") {
                var _ref3 = scope.resolvedRefMap.get(exportsStmt.declaration) || {},
                    decl = _ref3.decl,
                    declId = _ref3.declId;

                exports.push({
                  local: exportsStmt.declaration.name,
                  exported: "default",
                  fromModule: null,
                  node: node,
                  type: "id",
                  decl: decl,
                  declId: declId
                });
                return "continue";
              }

              exports.push({
                local: null,
                exported: "default",
                fromModule: null,
                node: node,
                type: "expr",
                decl: exportsStmt.declaration,
                declId: exportsStmt.declaration
              });
              return "continue";
            }

            if (exportsStmt.specifiers && exportsStmt.specifiers.length) {
              exports.push.apply(exports, _toConsumableArray(exportsStmt.specifiers.map(function (exportSpec) {
                var decl, declId;

                if (from) {
                  decl = node;
                  declId = exportSpec.exported;
                } else if (exportSpec.local) {
                  var resolved = scope.resolvedRefMap.get(exportSpec.local);
                  decl = resolved ? resolved.decl : null;
                  declId = resolved ? resolved.declId : null;
                }

                return {
                  local: !from && exportSpec.local ? exportSpec.local.name : null,
                  exported: exportSpec.exported ? exportSpec.exported.name : null,
                  imported: from && exportSpec.local ? exportSpec.local.name : null,
                  fromModule: from || null,
                  type: "id",
                  node: exportSpec,
                  decl: decl,
                  declId: declId
                };
              })));
              return "continue";
            }

            if (exportsStmt.declaration && exportsStmt.declaration.declarations) {
              exports.push.apply(exports, _toConsumableArray(exportsStmt.declaration.declarations.map(function (decl) {
                return {
                  local: decl.id ? decl.id.name : "default",
                  exported: decl.id ? decl.id.name : "default",
                  type: exportsStmt.declaration.kind,
                  fromModule: null,
                  node: node,
                  decl: decl,
                  declId: decl.id
                };
              })));
              return "continue";
            }

            if (exportsStmt.declaration) {
              exports.push({
                local: exportsStmt.declaration.id ? exportsStmt.declaration.id.name : "default",
                exported: exportsStmt.declaration.id ? exportsStmt.declaration.id.name : "default",
                type: exportsStmt.declaration.type === "FunctionDeclaration" ? "function" : exportsStmt.declaration.type === "ClassDeclaration" ? "class" : null,
                fromModule: null,
                node: node,
                decl: exportsStmt.declaration,
                declId: exportsStmt.declaration.id
              });
              return "continue";
            }
          };

          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var exportsStmt;
            var from;

            var _ret = _loop();

            if (_ret === "continue") continue;
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }

        return uniqBy(exports, function (a, b) {
          return a.local === b.local && a.exported === b.exported && a.fromModule === b.fromModule;
        });
      }, __moduleMeta__$9));

      __varRecorder__$9.exports = exports$1;

      var queryNodes = exports('u', __varRecorder__$9["lively.ast/lib/query.js__define__"]("queryNodes", "function", function (node, query) {
        var compiled = __varRecorder__$9.queryCache.get(query);

        if (!compiled) {
          compiled = __varRecorder__$9.astq.compile(query);

          __varRecorder__$9.queryCache.set(query, compiled);
        }

        return __varRecorder__$9.astq.execute(node, compiled);
      }, __moduleMeta__$9));

      __varRecorder__$9.queryNodes = queryNodes;
      __varRecorder__$9.ASTQ = exports$1$1 || System._nodeRequire("astq");
      __varRecorder__$9.helpers = {
        declIds: function declIds(nodes) {
          var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (!node) continue;else if (node.type === "Identifier") result.push(node);else if (node.type === "RestElement") result.push(node.argument);else if (node.type === "AssignmentPattern") __varRecorder__$9.helpers.declIds([node.left], result);else if (node.type === "ObjectPattern") {
              for (var j = 0; j < node.properties.length; j++) {
                var prop = node.properties[j];

                __varRecorder__$9.helpers.declIds([prop.value || prop], result);
              }
            } else if (node.type === "ArrayPattern") {
              __varRecorder__$9.helpers.declIds(node.elements, result);
            }
          }

          return result;
        },
        varDecls: function varDecls(scope) {
          var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

          var _iterator13 = _createForOfIteratorHelper(scope.varDecls),
              _step13;

          try {
            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
              var varDecl = _step13.value;

              var _iterator14 = _createForOfIteratorHelper(varDecl.declarations),
                  _step14;

              try {
                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                  var decl = _step14.value;

                  var _iterator15 = _createForOfIteratorHelper(__varRecorder__$9.helpers.declIds([decl.id])),
                      _step15;

                  try {
                    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                      var id = _step15.value;
                      result.push([decl, id]);
                    }
                  } catch (err) {
                    _iterator15.e(err);
                  } finally {
                    _iterator15.f();
                  }
                }
              } catch (err) {
                _iterator14.e(err);
              } finally {
                _iterator14.f();
              }
            }
          } catch (err) {
            _iterator13.e(err);
          } finally {
            _iterator13.f();
          }

          return result;
        },
        varDeclIds: function varDeclIds(scope) {
          var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

          var _iterator16 = _createForOfIteratorHelper(scope.varDecls),
              _step16;

          try {
            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
              var varDecl = _step16.value;

              var _iterator17 = _createForOfIteratorHelper(varDecl.declarations),
                  _step17;

              try {
                for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                  var decl = _step17.value;

                  __varRecorder__$9.helpers.declIds([decl.id], result);
                }
              } catch (err) {
                _iterator17.e(err);
              } finally {
                _iterator17.f();
              }
            }
          } catch (err) {
            _iterator16.e(err);
          } finally {
            _iterator16.f();
          }

          return result;
        },
        objPropertiesAsList: function objPropertiesAsList(objExpr, path, onlyLeafs) {
          var result = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

          var _iterator18 = _createForOfIteratorHelper(objExpr.properties),
              _step18;

          try {
            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
              var prop = _step18.value;
              var key = prop.key.name;
              var thisNode = {
                key: path.concat([key]),
                value: prop.value
              };

              switch (prop.value.type) {
                case "ArrayExpression":
                case "ArrayPattern":
                  if (!onlyLeafs) result.push(thisNode);

                  for (var i = 0; i < prop.value.elements.length; i++) {
                    var el = prop.value.elements[i];

                    __varRecorder__$9.helpers.objPropertiesAsList(el, path.concat([key, i]), onlyLeafs, result);
                  }

                  break;

                case "ObjectExpression":
                case "ObjectPattern":
                  if (!onlyLeafs) result.push(thisNode);

                  __varRecorder__$9.helpers.objPropertiesAsList(prop.value, path.concat([key]), onlyLeafs, result);

                  break;

                case "AssignmentPattern":
                  if (!onlyLeafs) result.push(thisNode);

                  __varRecorder__$9.helpers.objPropertiesAsList(prop.left, path.concat([key]), onlyLeafs, result);

                  break;

                default:
                  result.push(thisNode);
              }
            }
          } catch (err) {
            _iterator18.e(err);
          } finally {
            _iterator18.f();
          }

          return result;
        },
        isDeclaration: function isDeclaration(node) {
          return node.type === "FunctionDeclaration" || node.type === "VariableDeclaration" || node.type === "ClassDeclaration";
        }
      };
      __varRecorder__$9.knownGlobals = ["closed", "true", "false", "null", "undefined", "arguments", "Object", "Function", "Array", "Number", "parseFloat", "parseInt", "Infinity", "NaN", "Boolean", "String", "Symbol", "Date", "Promise", "RegExp", "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError", "JSON", "Math", "console", "ArrayBuffer", "Uint8Array", "Int8Array", "Uint16Array", "Int16Array", "Uint32Array", "Int32Array", "Float32Array", "Float64Array", "Uint8ClampedArray", "DataView", "Map", "Set", "WeakMap", "WeakSet", "Proxy", "Reflect", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "unescape", "eval", "isFinite", "isNaN", "Intl", "navigator", "window", "document", "Blob", "setTimeout", "clearTimeout", "setInterval", "clearInterval", "requestAnimationFrame", "cancelAnimationFrame", "btoa", "atob", "sessionStorage", "localStorage", "$world", "lively", "System", "customElements", "performance", "addEventListener", "closed"];
      __varRecorder__$9.globalDeclRe = /^\s*global\s*/;
      __varRecorder__$9._stmtTypes = ["EmptyStatement", "BlockStatement", "ExpressionStatement", "IfStatement", "BreakStatement", "ContinueStatement", "WithStatement", "ReturnStatement", "ThrowStatement", "TryStatement", "WhileStatement", "DoWhileStatement", "ForStatement", "ForInStatement", "ForOfStatement", "DebuggerStatement", "FunctionDeclaration", "VariableDeclaration", "ClassDeclaration", "ImportDeclaration", "ImportDeclaration", "ExportNamedDeclaration", "ExportDefaultDeclaration", "ExportAllDeclaration"];
      __varRecorder__$9.astq = new __varRecorder__$9.ASTQ();

      __varRecorder__$9.astq.adapter("mozast");

      __varRecorder__$9.queryCache = new Map();
      var helpers = __varRecorder__$9.helpers;
      var knownGlobals = exports('E', __varRecorder__$9.knownGlobals);
      __varRecorder__$9.helpers = helpers;
      __varRecorder__$9.knownGlobals = knownGlobals;
      __varRecorder__$9.scopes = scopes;
      __varRecorder__$9.nodesAtIndex = nodesAtIndex;
      __varRecorder__$9.scopesAtIndex = scopesAtIndex;
      __varRecorder__$9.scopeAtIndex = scopeAtIndex;
      __varRecorder__$9.scopesAtPos = scopesAtPos;
      __varRecorder__$9.nodesInScopeOf = nodesInScopeOf;
      __varRecorder__$9.declarationsOfScope = declarationsOfScope;
      __varRecorder__$9._declaredVarNames = _declaredVarNames;
      __varRecorder__$9._findJsLintGlobalDeclarations = _findJsLintGlobalDeclarations;
      __varRecorder__$9.topLevelDeclsAndRefs = topLevelDeclsAndRefs;
      __varRecorder__$9.findGlobalVarRefs = findGlobalVarRefs;
      __varRecorder__$9.findNodesIncludingLines = findNodesIncludingLines;
      __varRecorder__$9.findReferencesAndDeclsInScope = findReferencesAndDeclsInScope;
      __varRecorder__$9.findDeclarationClosestToIndex = findDeclarationClosestToIndex;
      __varRecorder__$9.nodesAt = nodesAt$1;
      __varRecorder__$9.statementOf = statementOf;
      __varRecorder__$9.resolveReferences = resolveReferences;
      __varRecorder__$9.refWithDeclAt = refWithDeclAt;
      __varRecorder__$9.imports = imports;
      __varRecorder__$9.exports = exports$1;
      __varRecorder__$9.queryNodes = queryNodes;

      var query = /*#__PURE__*/Object.freeze({
        __proto__: null,
        helpers: helpers,
        knownGlobals: knownGlobals,
        scopes: scopes,
        nodesAtIndex: nodesAtIndex,
        scopesAtIndex: scopesAtIndex,
        scopeAtIndex: scopeAtIndex,
        scopesAtPos: scopesAtPos,
        nodesInScopeOf: nodesInScopeOf,
        declarationsOfScope: declarationsOfScope,
        _declaredVarNames: _declaredVarNames,
        _findJsLintGlobalDeclarations: _findJsLintGlobalDeclarations,
        topLevelDeclsAndRefs: topLevelDeclsAndRefs,
        findGlobalVarRefs: findGlobalVarRefs,
        findNodesIncludingLines: findNodesIncludingLines,
        findReferencesAndDeclsInScope: findReferencesAndDeclsInScope,
        findDeclarationClosestToIndex: findDeclarationClosestToIndex,
        nodesAt: nodesAt$1,
        statementOf: statementOf,
        resolveReferences: resolveReferences,
        refWithDeclAt: refWithDeclAt,
        imports: imports,
        exports: exports$1,
        queryNodes: queryNodes
      });
      exports('q', query);

      var __varRecorder__$8 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/lib/visitors.js", __contextModule__);

      var __moduleMeta__$8 = {
        pathInPackage: function pathInPackage() {
          return "./lib/visitors.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ast",
            version: "0.11.3"
          };
        }
      };

      var topLevelFuncDecls = __varRecorder__$8["lively.ast/lib/visitors.js__define__"]("topLevelFuncDecls", "function", function (parsed) {
        return __varRecorder__$8.FindToplevelFuncDeclVisitor.run(parsed);
      }, __moduleMeta__$8);

      __varRecorder__$8.topLevelFuncDecls = topLevelFuncDecls;

      var blockInliner = __varRecorder__$8["lively.ast/lib/visitors.js__define__"]("blockInliner", "function", function (node) {
        if (Array.isArray(node.body)) {
          for (var i = node.body.length - 1; i >= 0; i--) {
            var stmt = node.body[i];

            if (stmt.type === "BlockStatement" && stmt[__varRecorder__$8.canBeInlinedSym]) {
              node.body.splice.apply(node.body, [i, 1].concat(stmt.body));
            }
          }
        }

        return node;
      }, __moduleMeta__$8);

      __varRecorder__$8.blockInliner = blockInliner;

      var block$1 = __varRecorder__$8["lively.ast/lib/visitors.js__define__"]("block", "function", function (nodes) {
        return {
          type: "BlockStatement",
          body: nodes
        };
      }, __moduleMeta__$8);

      __varRecorder__$8.block = block$1;

      var AllNodesVisitor = /*#__PURE__*/function (_Visitor) {
        _inherits(AllNodesVisitor, _Visitor);

        var _super = _createSuper(AllNodesVisitor);

        function AllNodesVisitor() {
          _classCallCheck(this, AllNodesVisitor);

          return _super.apply(this, arguments);
        }

        _createClass(AllNodesVisitor, [{
          key: "accept",
          value: function accept(node, state, path) {
            this.doFunc(node, state, path);
            return _get(_getPrototypeOf(AllNodesVisitor.prototype), "accept", this).call(this, node, state, path);
          }
        }], [{
          key: "run",
          value: function run(parsed, doFunc, state) {
            var v = new this();
            v.doFunc = doFunc;
            v.accept(parsed, state, []);
            return state;
          }
        }]);

        return AllNodesVisitor;
      }(Visitor);

      __varRecorder__$8.AllNodesVisitor = AllNodesVisitor;

      var FindToplevelFuncDeclVisitor = /*#__PURE__*/function (_Visitor2) {
        _inherits(FindToplevelFuncDeclVisitor, _Visitor2);

        var _super2 = _createSuper(FindToplevelFuncDeclVisitor);

        function FindToplevelFuncDeclVisitor() {
          _classCallCheck(this, FindToplevelFuncDeclVisitor);

          return _super2.apply(this, arguments);
        }

        _createClass(FindToplevelFuncDeclVisitor, [{
          key: "accept",
          value: function accept(node, funcDecls, path) {
            switch (node.type) {
              case "ArrowFunctionExpression":
                return node;

              case "FunctionExpression":
                return node;

              case "FunctionDeclaration":
                funcDecls.unshift({
                  node: node,
                  path: path
                });
                return node;

              default:
                return _get(_getPrototypeOf(FindToplevelFuncDeclVisitor.prototype), "accept", this).call(this, node, funcDecls, path);
            }
          }
        }], [{
          key: "run",
          value: function run(parsed) {
            var state = [];
            new this().accept(parsed, state, []);
            return state;
          }
        }]);

        return FindToplevelFuncDeclVisitor;
      }(Visitor);

      __varRecorder__$8.FindToplevelFuncDeclVisitor = FindToplevelFuncDeclVisitor;
      __varRecorder__$8.canBeInlinedSym = Symbol("canBeInlined");

      var ReplaceManyVisitor = exports('k', /*#__PURE__*/function (_Visitor3) {
        _inherits(ReplaceManyVisitor, _Visitor3);

        var _super3 = _createSuper(ReplaceManyVisitor);

        function ReplaceManyVisitor() {
          _classCallCheck(this, ReplaceManyVisitor);

          return _super3.apply(this, arguments);
        }

        _createClass(ReplaceManyVisitor, [{
          key: "accept",
          value: function accept(node, state, path) {
            var replaced = this.replacer(_get(_getPrototypeOf(ReplaceManyVisitor.prototype), "accept", this).call(this, node, state, path));
            return !Array.isArray(replaced) ? replaced : replaced.length === 1 ? replaced[0] : Object.assign(__varRecorder__$8.block(replaced), _defineProperty({}, __varRecorder__$8.canBeInlinedSym, true));
          }
        }, {
          key: "visitBlockStatement",
          value: function visitBlockStatement(node, state, path) {
            return __varRecorder__$8.blockInliner(_get(_getPrototypeOf(ReplaceManyVisitor.prototype), "visitBlockStatement", this).call(this, node, state, path));
          }
        }, {
          key: "visitProgram",
          value: function visitProgram(node, state, path) {
            return __varRecorder__$8.blockInliner(_get(_getPrototypeOf(ReplaceManyVisitor.prototype), "visitProgram", this).call(this, node, state, path));
          }
        }], [{
          key: "run",
          value: function run(parsed, replacer) {
            var v = new this();
            v.replacer = replacer;
            return v.accept(parsed, null, []);
          }
        }]);

        return ReplaceManyVisitor;
      }(Visitor));

      __varRecorder__$8.ReplaceManyVisitor = ReplaceManyVisitor;

      var ReplaceVisitor = exports('R', /*#__PURE__*/function (_Visitor4) {
        _inherits(ReplaceVisitor, _Visitor4);

        var _super4 = _createSuper(ReplaceVisitor);

        function ReplaceVisitor() {
          _classCallCheck(this, ReplaceVisitor);

          return _super4.apply(this, arguments);
        }

        _createClass(ReplaceVisitor, [{
          key: "accept",
          value: function accept(node, state, path) {
            return this.replacer(_get(_getPrototypeOf(ReplaceVisitor.prototype), "accept", this).call(this, node, state, path), path);
          }
        }], [{
          key: "run",
          value: function run(parsed, replacer) {
            var v = new this();
            v.replacer = replacer;
            return v.accept(parsed, null, []);
          }
        }]);

        return ReplaceVisitor;
      }(Visitor));

      __varRecorder__$8.ReplaceVisitor = ReplaceVisitor;
      var QueryReplaceManyVisitor = exports('Q', /*#__PURE__*/function (_varRecorder__$Repla) {
        _inherits(QueryReplaceManyVisitor, _varRecorder__$Repla);

        var _super5 = _createSuper(QueryReplaceManyVisitor);

        function QueryReplaceManyVisitor() {
          _classCallCheck(this, QueryReplaceManyVisitor);

          return _super5.apply(this, arguments);
        }

        _createClass(QueryReplaceManyVisitor, null, [{
          key: "run",
          value: function run(parsed, query, replacer) {
            var matchingNodes = queryNodes(parsed, query);

            var filteredReplacer = function filteredReplacer(node) {
              if (matchingNodes.includes(node)) return replacer(node);else return node;
            };

            return _get(_getPrototypeOf(QueryReplaceManyVisitor), "run", this).call(this, parsed, filteredReplacer);
          }
        }]);

        return QueryReplaceManyVisitor;
      }(__varRecorder__$8.ReplaceManyVisitor));
      __varRecorder__$8.QueryReplaceManyVisitor = QueryReplaceManyVisitor;
      __varRecorder__$8.AllNodesVisitor = AllNodesVisitor;
      __varRecorder__$8.FindToplevelFuncDeclVisitor = FindToplevelFuncDeclVisitor;
      __varRecorder__$8.ReplaceVisitor = ReplaceVisitor;
      __varRecorder__$8.ReplaceManyVisitor = ReplaceManyVisitor;
      __varRecorder__$8.topLevelFuncDecls = topLevelFuncDecls;

      var __varRecorder__$7 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/lib/parser.js", __contextModule__);

      var __moduleMeta__$7 = {
        pathInPackage: function pathInPackage() {
          return "./lib/parser.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ast",
            version: "0.11.3"
          };
        }
      };

      var addSource = __varRecorder__$7["lively.ast/lib/parser.js__define__"]("addSource", "function", function (parsed, source) {
        if (typeof parsed === "string") {
          source = parsed;
          parsed = __varRecorder__$7.parse(parsed);
        }

        source && AllNodesVisitor.run(parsed, function (node, state, path) {
          return !node.source && (node.source = source.slice(node.start, node.end));
        });
        return parsed;
      }, __moduleMeta__$7);

      __varRecorder__$7.addSource = addSource;

      var nodesAt = __varRecorder__$7["lively.ast/lib/parser.js__define__"]("nodesAt", "function", function (pos, ast) {
        ast = typeof ast === "string" ? this.parse(ast) : ast;
        return findNodesIncluding(ast, pos);
      }, __moduleMeta__$7);

      __varRecorder__$7.nodesAt = nodesAt;

      var parseFunction = exports('r', __varRecorder__$7["lively.ast/lib/parser.js__define__"]("parseFunction", "function", function (source) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var src = "(" + source + ")";
        var offset = -1;

        var parsed = __varRecorder__$7.parse(src, options);

        AllNodesVisitor.run(parsed, function (node, state, path) {
          if (node._positionFixed) return;
          node._positionFixed = true;

          if (node.start || node.start === 0) {
            node.start += offset;
            node.end += offset;
          }

          if (options.addSource && !node.source) {
            node.source = source.slice(node.start, node.end);
          }
        });
        return parsed.body[0].expression;
      }, __moduleMeta__$7));

      __varRecorder__$7.parseFunction = parseFunction;

      var fuzzyParse = exports('C', __varRecorder__$7["lively.ast/lib/parser.js__define__"]("fuzzyParse", "function", function (source, options) {
        options = options || {};
        options.ecmaVersion = options.ecmaVersion || 12;
        options.sourceType = options.sourceType || "module";
        options.plugins = options.plugins || {};
        var comments = [];

        if (options.withComments) {
          options.onComment = function (isBlock, text) {
            return comments.push({
              isBlock: isBlock,
              text: text
            });
          };
        }

        options.plugins.jsx = options.plugins.hasOwnProperty("jsx") ? options.plugins.jsx : true;
        options.plugins.asyncawait = options.plugins.hasOwnProperty("asyncawait") ? options.plugins.asyncawait : {
          inAsyncFunction: true
        };
        options.plugins.objectSpread = options.plugins.hasOwnProperty("objectSpread") ? options.plugins.objectSpread : true;
        var ast, safeSource, err;

        if (options.type === "LabeledStatement") {
          safeSource = "$={" + source + "}";
        }

        try {
          ast = __varRecorder__$7.parse(safeSource || source, options);
          if (safeSource) ast = null;else if (options.addSource) __varRecorder__$7.addSource(ast, source);
        } catch (e) {
          err = e;
        }

        if (err && err.raisedAt !== undefined) {
          if (safeSource) {
            err.pos -= 3;
            err.raisedAt -= 3;
            err.loc.column -= 3;
          }

          var parseErrorSource = "";
          parseErrorSource += source.slice(err.raisedAt - 20, err.raisedAt);
          parseErrorSource += "<-error->";
          parseErrorSource += source.slice(err.raisedAt, err.raisedAt + 20);
          options.verbose && console.log("parse error: " + parseErrorSource);
          err.parseErrorSource = parseErrorSource;
        } else if (err && options.verbose) {
          console.log("" + err + err.stack);
        }

        if (!ast) {
          ast = parse$1(source, options);
          if (options.addSource) __varRecorder__$7.addSource(ast, source);
          ast.isFuzzy = true;
          ast.parseError = err;
        }

        if (options.withComments) ast.comments = comments;
        return ast;
      }, __moduleMeta__$7));

      __varRecorder__$7.fuzzyParse = fuzzyParse;

      var acornParseAsyncAware = __varRecorder__$7["lively.ast/lib/parser.js__define__"]("acornParseAsyncAware", "function", function (source, options) {
        var asyncSource = "async () => {\n".concat(source, "\n}");
        var offset = "async () => {\n".length;

        if (options.onComment) {
          var orig = options.onComment;

          options.onComment = function (isBlock, text, start, end, line, column) {
            start -= offset;
            end -= offset;
            return orig.call(this, isBlock, text, start, end, line, column);
          };
        }

        var parsed = acorn.parse(asyncSource, options);

        if (parsed.loc) {
          var SourceLocation = parsed.loc.constructor;
        }

        parsed = {
          body: parsed.body[0].expression.body.body,
          sourceType: "module",
          type: "Program"
        };
        AllNodesVisitor.run(parsed, function (node, state, path) {
          if (node._positionFixed) return;
          node._positionFixed = true;

          if (node.start || node.start === 0) {
            node.start -= offset;
            node.end -= offset;
          }

          if (node.loc && SourceLocation) {
            var _node$loc = node.loc,
                _node$loc$start = _node$loc.start,
                sc = _node$loc$start.column,
                sl = _node$loc$start.line,
                _node$loc$end = _node$loc.end,
                ec = _node$loc$end.column,
                el = _node$loc$end.line;
            node.loc = new SourceLocation(options, {
              column: sc,
              line: sl - 1
            }, {
              column: ec,
              line: el - 1
            });
          }

          if (options.addSource && !node.source) {
            node.source = source.slice(node.start, node.end);
          }
        });
        parsed.start = parsed.body[0].start;
        parsed.end = last(parsed.body).end;
        if (options.addSource) parsed.source = source;

        if (parsed.body[0].loc && SourceLocation) {
          parsed.loc = new SourceLocation(options, parsed.body[0].loc.start, last(parsed.body).loc.end);
        }

        return parsed;
      }, __moduleMeta__$7);

      __varRecorder__$7.acornParseAsyncAware = acornParseAsyncAware;

      var parse = exports('p', __varRecorder__$7["lively.ast/lib/parser.js__define__"]("parse", "function", function (source, options) {
        options = options || {};
        options.ecmaVersion = options.ecmaVersion || 12;
        options.allowAwaitOutsideFunction = true;
        options.sourceType = options.sourceType || "module";

        if (!options.hasOwnProperty("allowImportExportEverywhere")) {
          options.allowImportExportEverywhere = true;
        }

        options.plugins = options.plugins || {};
        options.plugins.jsx = options.plugins.hasOwnProperty("jsx") ? options.plugins.jsx : true;
        options.plugins.asyncawait = options.plugins.hasOwnProperty("asyncawait") ? options.plugins.asyncawait : {
          inAsyncFunction: true
        };
        options.plugins.objectSpread = options.plugins.hasOwnProperty("objectSpread") ? options.plugins.objectSpread : true;

        if (options.withComments) {
          delete options.withComments;
          var comments = [];

          options.onComment = function (isBlock, text, start, end, line, column) {
            comments.push({
              isBlock: isBlock,
              text: text,
              node: null,
              start: start,
              end: end,
              line: line,
              column: column
            });
          };
        }

        try {
          var parsed = acorn.parse(source, options);
        } catch (err) {
          if (typeof SyntaxError !== "undefined" && err instanceof SyntaxError && err.loc) {
            var lines = source.split("\n");
            var message = err.message,
                _err$loc = err.loc,
                row = _err$loc.line,
                column = _err$loc.column,
                pos = err.pos;
            var line = lines[row - 1];
            var newMessage = "Syntax error at line ".concat(row, " column ").concat(column, " (index ").concat(pos, ") \"").concat(message, "\"\nsource: ").concat(line.slice(0, column), "<--SyntaxError-->").concat(line.slice(column));
            var betterErr = new SyntaxError(newMessage);
            betterErr.loc = {
              line: row,
              column: column
            };
            betterErr.pos = pos;
            throw betterErr;
          } else throw err;
        }

        if (options.addSource) __varRecorder__$7.addSource(parsed, source);
        if (options.addAstIndex && !parsed.hasOwnProperty("astIndex")) addAstIndex(parsed);
        if (parsed && comments) attachCommentsToAST({
          ast: parsed,
          comments: comments,
          nodesWithComments: []
        });
        return parsed;

        function attachCommentsToAST(commentData) {
          commentData = mergeComments(assignCommentsToBlockNodes(commentData));
          parsed.allComments = commentData.comments;
        }

        function assignCommentsToBlockNodes(commentData) {
          comments.forEach(function (comment) {
            var node = __varRecorder__$7.nodesAt(comment.start, parsed).reverse().find(function (node) {
              return node.type === "BlockStatement" || node.type === "Program";
            });

            if (!node) node = parsed;
            if (!node.comments) node.comments = [];
            node.comments.push(comment);
            commentData.nodesWithComments.push(node);
          });
          return commentData;
        }

        function mergeComments(commentData) {
          commentData.nodesWithComments.forEach(function (blockNode) {
            clone$1(blockNode.comments).reduce(function (coalesceData, comment) {
              if (comment.isBlock) {
                coalesceData.lastComment = null;
                return coalesceData;
              }

              if (!coalesceData.lastComment) {
                coalesceData.lastComment = comment;
                return coalesceData;
              }

              var last = coalesceData.lastComment;
              var nodeInbetween = blockNode.body.find(function (node) {
                return node.start >= last.end && node.end <= comment.start;
              });

              if (nodeInbetween) {
                coalesceData.lastComment = comment;
                return coalesceData;
              }

              var codeInBetween = source.slice(last.end, comment.start);

              if (/[\n\r][\n\r]+/.test(codeInBetween)) {
                coalesceData.lastComment = comment;
                return coalesceData;
              }

              last.text += "\n" + comment.text;
              last.end = comment.end;
              remove(blockNode.comments, comment);
              remove(commentData.comments, comment);
              return coalesceData;
            }, {
              lastComment: null
            });
          });
          return commentData;
        }
      }, __moduleMeta__$7));

      __varRecorder__$7.parse = parse;
      __varRecorder__$7.walk = walk;
      __varRecorder__$7.parse = parse;
      __varRecorder__$7.parseFunction = parseFunction;
      __varRecorder__$7.fuzzyParse = fuzzyParse;
      __varRecorder__$7.addSource = addSource;
      custom.addSource = __varRecorder__$7.addSource;

      var __varRecorder__$6 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/lib/mozilla-ast-visitor-interface.js", __contextModule__);

      var __moduleMeta__$6 = {
        pathInPackage: function pathInPackage() {
          return "./lib/mozilla-ast-visitor-interface.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ast",
            version: "0.11.3"
          };
        }
      };

      var withMozillaAstDo = __varRecorder__$6["lively.ast/lib/mozilla-ast-visitor-interface.js__define__"]("withMozillaAstDo", "function", function (parsed, state, func) {
        var vis = new Visitor();
        var origAccept = vis.accept;

        vis.accept = function (node, st, path) {
          var next = function next() {
            origAccept.call(vis, node, st, path);
          };

          state = func(next, node, st, path);
          return node;
        };

        vis.accept(parsed, state, []);
        return state;
      }, __moduleMeta__$6);

      __varRecorder__$6.withMozillaAstDo = withMozillaAstDo;

      var printAst = __varRecorder__$6["lively.ast/lib/mozilla-ast-visitor-interface.js__define__"]("printAst", "function", function (astOrSource, options) {
        options = options || {};
        var printSource = options.printSource || false;
        var printPositions = options.printPositions || false;
        var printIndex = options.printIndex || false;
        var source;
        var parsed;
        var tree = [];

        if (typeof astOrSource === "string") {
          source = astOrSource;
          parsed = parse(astOrSource);
        } else {
          parsed = astOrSource;
          source = options.source || parsed.source;
        }

        if (printSource && !parsed.source) {
          if (!source) {
            source = stringify(parsed);
            parsed = parse(source);
          }

          addSource(parsed, source);
        }

        function printFunc(ea) {
          var line = ea.path + ":" + ea.node.type;
          var additional = [];

          if (printIndex) {
            additional.push(ea.index);
          }

          if (printPositions) {
            additional.push(ea.node.start + "-" + ea.node.end);
          }

          if (printSource) {
            var src = ea.node.source || source.slice(ea.node.start, ea.node.end);
            var printed = print(src.truncate(60).replace(/\n/g, "").replace(/\s+/g, " "));
            additional.push(printed);
          }

          if (additional.length) {
            line += "(" + additional.join(",") + ")";
          }

          return line;
        }

        new PrinterVisitor().accept(parsed, {
          index: 0,
          tree: tree
        }, []);
        return printTree(tree[0], printFunc, function (ea) {
          return ea.children;
        }, "  ");
      }, __moduleMeta__$6);

      __varRecorder__$6.printAst = printAst;

      var compareAst = __varRecorder__$6["lively.ast/lib/mozilla-ast-visitor-interface.js__define__"]("compareAst", "function", function (node1, node2) {
        if (!node1 || !node2) throw new Error("node" + (node1 ? "1" : "2") + " not defined");
        var state = {
          completePath: [],
          comparisons: {
            errors: []
          }
        };
        new ComparisonVisitor().accept(node1, node2, state, []);
        return !state.comparisons.errors.length ? null : state.comparisons.errors.pluck("msg");
      }, __moduleMeta__$6);

      __varRecorder__$6.compareAst = compareAst;

      var pathToNode = __varRecorder__$6["lively.ast/lib/mozilla-ast-visitor-interface.js__define__"]("pathToNode", "function", function (parsed, index, options) {
        if (!parsed.astIndex) addAstIndex(parsed);
        var vis = new Visitor();
        var found = null;
        (vis.accept = function (node, pathToHere, state, path) {
          if (found) return;
          var fullPath = pathToHere.concat(path);

          if (node.astIndex === index) {
            var pathString = fullPath.map(function (ea) {
              return typeof ea === "string" ? "." + ea : "[" + ea + "]";
            }).join("");
            found = {
              pathString: pathString,
              path: fullPath,
              node: node
            };
          }

          return this["visit" + node.type](node, fullPath, state, path);
        }).call(vis, parsed, [], {}, []);
        return found;
      }, __moduleMeta__$6);

      __varRecorder__$6.pathToNode = pathToNode;

      var rematchAstWithSource = __varRecorder__$6["lively.ast/lib/mozilla-ast-visitor-interface.js__define__"]("rematchAstWithSource", "function", function (parsed, source, addLocations, subTreePath) {
        addLocations = !!addLocations;
        var parsed2 = parse(source, addLocations ? {
          locations: true
        } : undefined);
        var visitor = new Visitor();
        if (subTreePath) parsed2 = Path(subTreePath).get(parsed2);

        visitor.accept = function (node, state, path) {
          path = path || [];
          var node2 = path.reduce(function (node, pathElem) {
            return node[pathElem];
          }, parsed);
          node2.start = node.start;
          node2.end = node.end;
          if (addLocations) node2.loc = node.loc;
          return this["visit" + node.type](node, state, path);
        };

        visitor.accept(parsed2);
      }, __moduleMeta__$6);

      __varRecorder__$6.rematchAstWithSource = rematchAstWithSource;
      __varRecorder__$6.BaseVisitor = Visitor;
      __varRecorder__$6.withMozillaAstDo = withMozillaAstDo;
      __varRecorder__$6.printAst = printAst;
      __varRecorder__$6.compareAst = compareAst;
      __varRecorder__$6.pathToNode = pathToNode;
      __varRecorder__$6.rematchAstWithSource = rematchAstWithSource;

      var __varRecorder__$5 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/lib/nodes.js", __contextModule__);

      var __moduleMeta__$5 = {
        pathInPackage: function pathInPackage() {
          return "./lib/nodes.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ast",
            version: "0.11.3"
          };
        }
      };

      var isIdentifier = __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("isIdentifier", "function", function (string) {
        return __varRecorder__$5.identifierRe.test(string) && string.indexOf("-") === -1;
      }, __moduleMeta__$5);

      __varRecorder__$5.isIdentifier = isIdentifier;

      var id = exports('i', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("id", "function", function (name) {
        return name === "this" ? {
          type: "ThisExpression"
        } : {
          name: String(name),
          type: "Identifier"
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.id = id;

      var literal = exports('l', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("literal", "function", function (value) {
        return {
          type: "Literal",
          value: value
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.literal = literal;

      var exprStmt = exports('e', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("exprStmt", "function", function (expression) {
        return {
          type: "ExpressionStatement",
          expression: expression
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.exprStmt = exprStmt;

      var sqncExpr = exports('a', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("sqncExpr", "function", function () {
        for (var _len = arguments.length, expressions = new Array(_len), _key = 0; _key < _len; _key++) {
          expressions[_key] = arguments[_key];
        }

        return {
          type: "SequenceExpression",
          expressions: expressions
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.sqncExpr = sqncExpr;

      var returnStmt = __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("returnStmt", "function", function (expr) {
        return {
          type: "ReturnStatement",
          argument: expr
        };
      }, __moduleMeta__$5);

      __varRecorder__$5.returnStmt = returnStmt;

      var empty = __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("empty", "function", function () {
        return {
          type: "EmptyStatement"
        };
      }, __moduleMeta__$5);

      __varRecorder__$5.empty = empty;

      var binaryExpr = exports('h', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("binaryExpr", "function", function (left, op, right) {
        return {
          left: left,
          right: right,
          operator: op,
          type: "BinaryExpression"
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.binaryExpr = binaryExpr;

      var funcExpr = exports('b', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("funcExpr", "function", function (_ref) {
        var arrow = _ref.arrow,
            funcId = _ref.id,
            expression = _ref.expression,
            generator = _ref.generator,
            isAsync = _ref.isAsync;
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        params = params.map(function (ea) {
          return typeof ea === "string" ? __varRecorder__$5.id(ea) : ea;
        });

        for (var _len2 = arguments.length, statements = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          statements[_key2 - 2] = arguments[_key2];
        }

        return {
          type: (arrow ? "Arrow" : "") + "FunctionExpression",
          id: funcId ? typeof funcId === "string" ? __varRecorder__$5.id(funcId) : funcId : undefined,
          params: params,
          body: expression && statements.length === 1 ? statements[0] : {
            body: statements,
            type: "BlockStatement"
          },
          expression: expression || false,
          generator: generator || false,
          async: isAsync
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.funcExpr = funcExpr;

      var funcCall = exports('f', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("funcCall", "function", function (callee) {
        if (typeof callee === "string") callee = __varRecorder__$5.id(callee);

        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }

        return {
          type: "CallExpression",
          callee: callee,
          arguments: args
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.funcCall = funcCall;

      var varDecl = exports('v', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("varDecl", "function", function (id, init, kind) {
        if (typeof id === "string") id = {
          name: id,
          type: "Identifier"
        };
        return {
          type: "VariableDeclaration",
          kind: kind || "var",
          declarations: [{
            type: "VariableDeclarator",
            id: id,
            init: init
          }]
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.varDecl = varDecl;

      var member = exports('m', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("member", "function", function (obj, prop, computed) {
        if (typeof obj === "string") obj = __varRecorder__$5.id(obj);

        if (typeof prop === "string") {
          if (!computed && !__varRecorder__$5.isIdentifier(prop)) computed = true;
          prop = computed ? __varRecorder__$5.literal(prop) : __varRecorder__$5.id(prop);
        } else if (typeof prop === "number") {
          prop = __varRecorder__$5.literal(prop);
          computed = true;
        } else if (prop.type === "Literal") {
          computed = true;
        }

        return {
          type: "MemberExpression",
          computed: !!computed,
          object: obj,
          property: prop
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.member = member;

      var memberChain = __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("memberChain", "function", function (first) {
        for (var _len4 = arguments.length, rest = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          rest[_key4 - 1] = arguments[_key4];
        }

        return rest.reduce(function (memberExpr, key) {
          return __varRecorder__$5.member(memberExpr, key);
        }, _typeof(first) === "object" ? first : __varRecorder__$5.id(first));
      }, __moduleMeta__$5);

      __varRecorder__$5.memberChain = memberChain;

      var assign = exports('j', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("assign", "function", function (left, right) {
        return {
          type: "AssignmentExpression",
          operator: "=",
          right: right ? typeof right === "string" ? __varRecorder__$5.id(right) : right : __varRecorder__$5.id("undefined"),
          left: typeof left === "string" ? __varRecorder__$5.id(left) : left
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.assign = assign;

      var block = exports('d', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("block", "function", function () {
        for (var _len5 = arguments.length, body = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          body[_key5] = arguments[_key5];
        }

        return {
          body: Array.isArray(body[0]) ? body[0] : body,
          type: "BlockStatement"
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.block = block;

      var program = __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("program", "function", function () {
        return Object.assign(__varRecorder__$5.block.apply(__varRecorder__$5, arguments), {
          sourceType: "module",
          type: "Program"
        });
      }, __moduleMeta__$5);

      __varRecorder__$5.program = program;

      var tryStmt = __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("tryStmt", "function", function (exName, handlerBody, finalizerBody) {
        for (var _len6 = arguments.length, body = new Array(_len6 > 3 ? _len6 - 3 : 0), _key6 = 3; _key6 < _len6; _key6++) {
          body[_key6 - 3] = arguments[_key6];
        }

        if (!Array.isArray(finalizerBody)) {
          body.unshift(finalizerBody);
          finalizerBody = null;
        }

        return {
          block: __varRecorder__$5.block(body),
          finalizer: finalizerBody ? __varRecorder__$5.block(finalizerBody) : null,
          handler: {
            body: __varRecorder__$5.block(handlerBody),
            param: __varRecorder__$5.id(exName),
            type: "CatchClause"
          },
          type: "TryStatement"
        };
      }, __moduleMeta__$5);

      __varRecorder__$5.tryStmt = tryStmt;

      var prop = __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("prop", "function", function (key, value) {
        return {
          type: "Property",
          key: key,
          computed: key.type !== "Identifier",
          shorthand: false,
          value: value
        };
      }, __moduleMeta__$5);

      __varRecorder__$5.prop = prop;

      var objectLiteral = exports('o', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("objectLiteral", "function", function (keysAndValues) {
        var props = [];

        for (var i = 0; i < keysAndValues.length; i += 2) {
          var key = keysAndValues[i];
          if (typeof key === "string") key = __varRecorder__$5.id(key);
          props.push(__varRecorder__$5.prop(key, keysAndValues[i + 1]));
        }

        return {
          properties: props,
          type: "ObjectExpression"
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.objectLiteral = objectLiteral;

      var ifStmt = exports('g', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("ifStmt", "function", function (test) {
        var consequent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : __varRecorder__$5.block();
        var alternate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __varRecorder__$5.block();
        return {
          consequent: consequent,
          alternate: alternate,
          test: test,
          type: "IfStatement"
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.ifStmt = ifStmt;

      var forIn = exports('c', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("forIn", "function", function (varDeclOrName, objExprOrName, body) {
        return {
          type: "ForInStatement",
          left: typeof varDeclOrName === "string" ? __varRecorder__$5.varDecl(varDeclOrName) : varDeclOrName,
          right: typeof objExprOrName === "string" ? __varRecorder__$5.id(objExprOrName) : objExprOrName,
          body: body
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.forIn = forIn;

      var conditional = __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("conditional", "function", function (test) {
        var consequent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : __varRecorder__$5.id("undefined");
        var alternate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __varRecorder__$5.id("undefined");
        return {
          consequent: consequent,
          alternate: alternate,
          test: test,
          type: "ConditionalExpression"
        };
      }, __moduleMeta__$5);

      __varRecorder__$5.conditional = conditional;

      var logical = exports('w', __varRecorder__$5["lively.ast/lib/nodes.js__define__"]("logical", "function", function (op, left, right) {
        return {
          operator: op,
          left: left,
          right: right,
          type: "LogicalExpression"
        };
      }, __moduleMeta__$5));

      __varRecorder__$5.logical = logical;
      __varRecorder__$5.identifierRe = /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
      __varRecorder__$5.isIdentifier = isIdentifier;
      __varRecorder__$5.id = id;
      __varRecorder__$5.literal = literal;
      __varRecorder__$5.objectLiteral = objectLiteral;
      __varRecorder__$5.prop = prop;
      __varRecorder__$5.exprStmt = exprStmt;
      __varRecorder__$5.returnStmt = returnStmt;
      __varRecorder__$5.empty = empty;
      __varRecorder__$5.sqncExpr = sqncExpr;
      __varRecorder__$5.binaryExpr = binaryExpr;
      __varRecorder__$5.funcExpr = funcExpr;
      __varRecorder__$5.funcCall = funcCall;
      __varRecorder__$5.varDecl = varDecl;
      __varRecorder__$5.member = member;
      __varRecorder__$5.memberChain = memberChain;
      __varRecorder__$5.assign = assign;
      __varRecorder__$5.block = block;
      __varRecorder__$5.program = program;
      __varRecorder__$5.tryStmt = tryStmt;
      __varRecorder__$5.ifStmt = ifStmt;
      __varRecorder__$5.forIn = forIn;
      __varRecorder__$5.conditional = conditional;
      __varRecorder__$5.logical = logical;

      var nodes = /*#__PURE__*/Object.freeze({
        __proto__: null,
        isIdentifier: isIdentifier,
        id: id,
        literal: literal,
        objectLiteral: objectLiteral,
        prop: prop,
        exprStmt: exprStmt,
        returnStmt: returnStmt,
        empty: empty,
        sqncExpr: sqncExpr,
        binaryExpr: binaryExpr,
        funcExpr: funcExpr,
        funcCall: funcCall,
        varDecl: varDecl,
        member: member,
        memberChain: memberChain,
        assign: assign,
        block: block,
        program: program,
        tryStmt: tryStmt,
        ifStmt: ifStmt,
        forIn: forIn,
        conditional: conditional,
        logical: logical
      });
      exports('n', nodes);

      var __varRecorder__$4 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/lib/object-spread-transform.js", __contextModule__);

      var __moduleMeta__$4 = {
        pathInPackage: function pathInPackage() {
          return "./lib/object-spread-transform.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ast",
            version: "0.11.3"
          };
        }
      };

      var objectSpreadTransform = exports('y', __varRecorder__$4["lively.ast/lib/object-spread-transform.js__define__"]("objectSpreadTransform", "function", function (parsed) {
        return new __varRecorder__$4.ObjectSpreadTransformer().accept(parsed, {}, []);
      }, __moduleMeta__$4));

      __varRecorder__$4.objectSpreadTransform = objectSpreadTransform;

      var ObjectSpreadTransformer = /*#__PURE__*/function (_Visitor) {
        _inherits(ObjectSpreadTransformer, _Visitor);

        var _super = _createSuper(ObjectSpreadTransformer);

        function ObjectSpreadTransformer() {
          _classCallCheck(this, ObjectSpreadTransformer);

          return _super.apply(this, arguments);
        }

        _createClass(ObjectSpreadTransformer, [{
          key: "accept",
          value: function accept(node, state, path) {
            if (node.type === "ObjectExpression") {
              node = this.transformSpreadElement(node);
            }

            return _get(_getPrototypeOf(ObjectSpreadTransformer.prototype), "accept", this).call(this, node, state, path);
          }
        }, {
          key: "transformSpreadElement",
          value: function transformSpreadElement(node) {
            var currentGroup = [];
            var propGroups = [currentGroup];
            node.properties.forEach(function (prop) {
              if (prop.type !== "SpreadElement") {
                prop.shorthand = false;
                currentGroup.push(prop);
              } else {
                propGroups.push(prop);
                currentGroup = [];
                propGroups.push(currentGroup);
              }
            });
            if (propGroups.length === 1) return node;
            if (!currentGroup.length) propGroups.pop();
            return funcCall.apply(void 0, [member("Object", "assign")].concat(_toConsumableArray(propGroups.map(function (group) {
              return group.type === "SpreadElement" ? group.argument : {
                properties: group,
                type: "ObjectExpression"
              };
            }))));
          }
        }]);

        return ObjectSpreadTransformer;
      }(Visitor);

      __varRecorder__$4.ObjectSpreadTransformer = ObjectSpreadTransformer;
      __varRecorder__$4["default"] = objectSpreadTransform;

      var __varRecorder__$3 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/lib/transform.js", __contextModule__);

      var __moduleMeta__$3 = {
        pathInPackage: function pathInPackage() {
          return "./lib/transform.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ast",
            version: "0.11.3"
          };
        }
      };

      var _node2string = __varRecorder__$3["lively.ast/lib/transform.js__define__"]("_node2string", "function", function (node) {
        return node.source || stringify(node);
      }, __moduleMeta__$3);

      __varRecorder__$3._node2string = _node2string;

      var _findIndentAt = __varRecorder__$3["lively.ast/lib/transform.js__define__"]("_findIndentAt", "function", function (s, pos) {
        var bol = peekLeft(s, pos, /\s+$/);
        var indent = typeof bol === "number" ? s.slice(bol, pos) : "";
        if (indent[0] === "\n") indent = indent.slice(1);
        return indent;
      }, __moduleMeta__$3);

      __varRecorder__$3._findIndentAt = _findIndentAt;

      var _applyChanges = __varRecorder__$3["lively.ast/lib/transform.js__define__"]("_applyChanges", "function", function (changes, source) {
        for (var i = 0; i < changes.length; i++) {
          var change = changes[i];

          if (change.type === "del") {
            source = source.slice(0, change.pos) + source.slice(change.pos + change.length);
          } else if (change.type === "add") {
            source = source.slice(0, change.pos) + change.string + source.slice(change.pos);
          } else {
            throw new Error("Unexpected change " + inspect(change));
          }
        }

        return source;
      }, __moduleMeta__$3);

      __varRecorder__$3._applyChanges = _applyChanges;

      var _compareNodesForReplacement = __varRecorder__$3["lively.ast/lib/transform.js__define__"]("_compareNodesForReplacement", "function", function (nodeA, nodeB) {
        if (nodeA.start === nodeB.start && nodeA.end === nodeB.end) return 0;
        if (nodeA.end <= nodeB.start) return -1;
        if (nodeA.start >= nodeB.end) return 1;
        if (nodeA.start <= nodeB.start && nodeA.end >= nodeB.end) return 1;
        if (nodeB.start <= nodeA.start && nodeB.end >= nodeA.end) return -1;
        throw new Error("Comparing nodes");
      }, __moduleMeta__$3);

      __varRecorder__$3._compareNodesForReplacement = _compareNodesForReplacement;

      var replaceNode = __varRecorder__$3["lively.ast/lib/transform.js__define__"]("replaceNode", "function", function (target, replacementFunc, sourceOrChanges) {
        var sourceChanges = _typeof(sourceOrChanges) === "object" ? sourceOrChanges : {
          changes: [],
          source: sourceOrChanges
        };
        var insideChangedBefore = false;
        var pos = sourceChanges.changes.reduce(function (pos, change) {
          if (pos.end < change.pos) return pos;
          var isInFront = change.pos < pos.start;
          insideChangedBefore = insideChangedBefore || change.pos >= pos.start && change.pos <= pos.end;

          if (change.type === "add") {
            return {
              start: isInFront ? pos.start + change.string.length : pos.start,
              end: pos.end + change.string.length
            };
          }

          if (change.type === "del") {
            return {
              start: isInFront ? pos.start - change.length : pos.start,
              end: pos.end - change.length
            };
          }

          throw new Error("Cannot deal with change " + inspect(change));
        }, {
          start: target.start,
          end: target.end
        });
        var source = sourceChanges.source;
        var replacement = replacementFunc(target, source.slice(pos.start, pos.end), insideChangedBefore);
        var replacementSource = typeof replacement === "string" ? replacement : Array.isArray(replacement) ? replacement.map(__varRecorder__$3._node2string).join("\n" + __varRecorder__$3._findIndentAt(source, pos.start)) : replacementSource = __varRecorder__$3._node2string(replacement);
        var changes = [{
          type: "del",
          pos: pos.start,
          length: pos.end - pos.start
        }, {
          type: "add",
          pos: pos.start,
          string: replacementSource
        }];
        return {
          changes: sourceChanges.changes.concat(changes),
          source: __varRecorder__$3._applyChanges(changes, source)
        };
      }, __moduleMeta__$3);

      __varRecorder__$3.replaceNode = replaceNode;

      var replaceNodes = __varRecorder__$3["lively.ast/lib/transform.js__define__"]("replaceNodes", "function", function (targetAndReplacementFuncs, sourceOrChanges) {
        var sorted = targetAndReplacementFuncs.sort(function (a, b) {
          return __varRecorder__$3._compareNodesForReplacement(a.target, b.target);
        });
        var sourceChanges = _typeof(sourceOrChanges) === "object" ? sourceOrChanges : {
          changes: [],
          source: sourceOrChanges
        };

        for (var i = 0; i < sorted.length; i++) {
          var _sorted$i = sorted[i],
              target = _sorted$i.target,
              replacementFunc = _sorted$i.replacementFunc;
          sourceChanges = __varRecorder__$3.replaceNode(target, replacementFunc, sourceChanges);
        }

        return sourceChanges;
      }, __moduleMeta__$3);

      __varRecorder__$3.replaceNodes = replaceNodes;

      var replace = __varRecorder__$3["lively.ast/lib/transform.js__define__"]("replace", "function", function (astOrSource, targetNode, replacementFunc, options) {
        var parsed = _typeof(astOrSource) === "object" ? astOrSource : null;
        var source = typeof astOrSource === "string" ? astOrSource : parsed.source || __varRecorder__$3._node2string(parsed);
        return __varRecorder__$3.replaceNode(targetNode, replacementFunc, source);
      }, __moduleMeta__$3);

      __varRecorder__$3.replace = replace;

      var __findVarDecls = __varRecorder__$3["lively.ast/lib/transform.js__define__"]("__findVarDecls", "function", function (scope) {
        var varDecls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        varDecls.push.apply(varDecls, _toConsumableArray(scope.varDecls));

        var _iterator = _createForOfIteratorHelper(scope.subScopes),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var subScope = _step.value;

            __findVarDecls(subScope, varDecls);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return varDecls;
      }, __moduleMeta__$3);

      __varRecorder__$3.__findVarDecls = __findVarDecls;

      var oneDeclaratorPerVarDecl = __varRecorder__$3["lively.ast/lib/transform.js__define__"]("oneDeclaratorPerVarDecl", "function", function (astOrSource) {
        var parsed = _typeof(astOrSource) === "object" ? astOrSource : parse(astOrSource);
        var source = typeof astOrSource === "string" ? astOrSource : parsed.source || __varRecorder__$3._node2string(parsed);
        var scope = scopes(parsed);

        var varDecls = __varRecorder__$3.__findVarDecls(scope);

        var targetsAndReplacements = [];

        var _iterator2 = _createForOfIteratorHelper(varDecls),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var decl = _step2.value;
            targetsAndReplacements.push({
              target: decl,
              replacementFunc: function replacementFunc(declNode, s, wasChanged) {
                if (wasChanged) {
                  declNode = parse(s).body[0];
                }

                return declNode.declarations.map(function (ea) {
                  return {
                    type: "VariableDeclaration",
                    kind: "var",
                    declarations: [ea]
                  };
                });
              }
            });
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return __varRecorder__$3.replaceNodes(targetsAndReplacements, source);
      }, __moduleMeta__$3);

      __varRecorder__$3.oneDeclaratorPerVarDecl = oneDeclaratorPerVarDecl;

      var oneDeclaratorForVarsInDestructoring = __varRecorder__$3["lively.ast/lib/transform.js__define__"]("oneDeclaratorForVarsInDestructoring", "function", function (astOrSource) {
        var parsed = _typeof(astOrSource) === "object" ? astOrSource : parse(astOrSource);
        var source = typeof astOrSource === "string" ? astOrSource : parsed.source || __varRecorder__$3._node2string(parsed);
        var scope = scopes(parsed);

        var varDecls = __varRecorder__$3.__findVarDecls(scope);

        var targetsAndReplacements = [];

        var _iterator3 = _createForOfIteratorHelper(varDecls),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var decl = _step3.value;
            targetsAndReplacements.push({
              target: decl,
              replacementFunc: function replacementFunc(declNode, s, wasChanged) {
                if (wasChanged) {
                  declNode = parse(s).body[0];
                }

                var nodes = [];

                var _iterator4 = _createForOfIteratorHelper(declNode.declarations),
                    _step4;

                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    var _decl = _step4.value;
                    var extractedId = {
                      type: "Identifier",
                      name: "__temp"
                    };
                    var extractedInit = {
                      type: "VariableDeclaration",
                      kind: "var",
                      declarations: [{
                        type: "VariableDeclarator",
                        id: extractedId,
                        init: _decl.init
                      }]
                    };
                    nodes.push(extractedInit);

                    var _iterator5 = _createForOfIteratorHelper(helpers.objPropertiesAsList(_decl.id, [], false)),
                        _step5;

                    try {
                      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                        var keyPath = _step5.value.key;
                        nodes.push(varDecl(keyPath[keyPath.length - 2], memberChain.apply(void 0, [extractedId.name].concat(_toConsumableArray(keyPath))), "var"));
                      }
                    } catch (err) {
                      _iterator5.e(err);
                    } finally {
                      _iterator5.f();
                    }
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }

                return nodes;
              }
            });
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return __varRecorder__$3.replaceNodes(targetsAndReplacements, source);
      }, __moduleMeta__$3);

      __varRecorder__$3.oneDeclaratorForVarsInDestructoring = oneDeclaratorForVarsInDestructoring;

      var returnLastStatement = __varRecorder__$3["lively.ast/lib/transform.js__define__"]("returnLastStatement", "function", function (source, opts) {
        opts = opts || {};
        var parsed = parse(source, opts);
        var last$1 = last(parsed.body);

        if (last$1.type !== "ExpressionStatement") {
          return opts.asAST ? parsed : source;
        }

        parsed.body.splice(parsed.body.length - 1, 1, returnStmt(last$1.expression));
        return opts.asAST ? parsed : stringify(parsed);
      }, __moduleMeta__$3);

      __varRecorder__$3.returnLastStatement = returnLastStatement;

      var wrapInFunction = exports('J', __varRecorder__$3["lively.ast/lib/transform.js__define__"]("wrapInFunction", "function", function (code, opts) {
        opts = opts || {};

        var transformed = __varRecorder__$3.returnLastStatement(code, opts);

        return opts.asAST ? program(funcExpr.apply(void 0, [{
          id: opts.id || undefined
        }, []].concat(_toConsumableArray(transformed.body)))) : "function".concat(opts.id ? " " + opts.id : "", "() {\n").concat(transformed, "\n}");
      }, __moduleMeta__$3));

      __varRecorder__$3.wrapInFunction = wrapInFunction;

      var wrapInStartEndCall = exports('z', __varRecorder__$3["lively.ast/lib/transform.js__define__"]("wrapInStartEndCall", "function", function (parsed, options) {
        if (typeof parsed === "string") parsed = parse(parsed);
        options = options || {};
        var isProgram = parsed.type === "Program";
        var startFuncNode = options.startFuncNode || id("__start_execution");
        var endFuncNode = options.endFuncNode || id("__end_execution");
        var funcDecls = topLevelFuncDecls(parsed);
        var innerBody = parsed.body;
        var outerBody = [];
        funcDecls.forEach(function (_ref) {
          var node = _ref.node,
              path = _ref.path;
          Path(path).set(parsed, exprStmt(node.id));
          outerBody.push(node);
        });
        innerBody.unshift(exprStmt(funcCall(startFuncNode)));
        var last$1 = last(innerBody);

        if (last$1.type === "ExpressionStatement") {
          innerBody.pop();
          innerBody.push(exprStmt(funcCall(endFuncNode, id("null"), last$1.expression)));
        } else if (last$1.type === "VariableDeclaration" && last(last$1.declarations).id.type === "Identifier") {
          innerBody.push(exprStmt(funcCall(endFuncNode, id("null"), last(last$1.declarations).id)));
        } else {
          innerBody.push(exprStmt(funcCall(endFuncNode, id("null"), id("undefined"))));
        }

        outerBody.push(tryStmt.apply(void 0, ["err", [exprStmt(funcCall(endFuncNode, id("err"), id("undefined")))]].concat(_toConsumableArray(innerBody))));
        return isProgram ? program.apply(void 0, outerBody) : block.apply(void 0, outerBody);
      }, __moduleMeta__$3));

      __varRecorder__$3.wrapInStartEndCall = wrapInStartEndCall;

      var transformSingleExpression = exports('x', __varRecorder__$3["lively.ast/lib/transform.js__define__"]("transformSingleExpression", "function", function (code) {
        if (!__varRecorder__$3.isProbablySingleExpressionRe.test(code) || code.split("\n").length > 30) return code;

        try {
          var parsed = fuzzyParse(code);

          if (parsed.body.length === 1 && (parsed.body[0].type === "FunctionDeclaration" || parsed.body[0].type === "BlockStatement" && parsed.body[0].body[0].type === "LabeledStatement")) {
            code = "(" + code.replace(/;\s*$/, "") + ")";
          }
        } catch (e) {
          if (typeof $world !== "undefined") $world.logError(e);else console.error("Eval preprocess error: %s", e.stack || e);
        }

        return code;
      }, __moduleMeta__$3));

      __varRecorder__$3.transformSingleExpression = transformSingleExpression;
      __varRecorder__$3.isProbablySingleExpressionRe = /^\s*(\{|function\s*\()/;
      __varRecorder__$3.replaceNode = replaceNode;
      __varRecorder__$3.replaceNodes = replaceNodes;
      __varRecorder__$3.replace = replace;
      __varRecorder__$3._compareNodesForReplacement = _compareNodesForReplacement;
      __varRecorder__$3.oneDeclaratorPerVarDecl = oneDeclaratorPerVarDecl;
      __varRecorder__$3.oneDeclaratorForVarsInDestructoring = oneDeclaratorForVarsInDestructoring;
      __varRecorder__$3.returnLastStatement = returnLastStatement;
      __varRecorder__$3.wrapInFunction = wrapInFunction;
      __varRecorder__$3.wrapInStartEndCall = wrapInStartEndCall;
      __varRecorder__$3.transformSingleExpression = transformSingleExpression;
      __varRecorder__$3.objectSpreadTransform = objectSpreadTransform;

      var transform = /*#__PURE__*/Object.freeze({
        __proto__: null,
        replaceNode: replaceNode,
        replaceNodes: replaceNodes,
        replace: replace,
        _compareNodesForReplacement: _compareNodesForReplacement,
        oneDeclaratorPerVarDecl: oneDeclaratorPerVarDecl,
        oneDeclaratorForVarsInDestructoring: oneDeclaratorForVarsInDestructoring,
        returnLastStatement: returnLastStatement,
        wrapInFunction: wrapInFunction,
        wrapInStartEndCall: wrapInStartEndCall,
        transformSingleExpression: transformSingleExpression,
        objectSpreadTransform: objectSpreadTransform
      });

      var __varRecorder__$2 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/lib/comments.js", __contextModule__);

      var __moduleMeta__$2 = {
        pathInPackage: function pathInPackage() {
          return "./lib/comments.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ast",
            version: "0.11.3"
          };
        }
      };

      var getCommentPrecedingNode = __varRecorder__$2["lively.ast/lib/comments.js__define__"]("getCommentPrecedingNode", "function", function (parsed, node) {
        var statementPath = statementOf(parsed, node, {
          asPath: true
        });
        var blockPath = statementPath.slice(0, -2);
        var block = Path(blockPath).get(parsed);
        return !block.comments || !block.comments.length ? null : chain(__varRecorder__$2.extractComments(parsed)).reversed().find(function (ea) {
          return ea.followingNode === node;
        }).value();
      }, __moduleMeta__$2);

      __varRecorder__$2.getCommentPrecedingNode = getCommentPrecedingNode;

      var extractComments = __varRecorder__$2["lively.ast/lib/comments.js__define__"]("extractComments", "function", function (astOrCode, optCode) {
        var parsed = typeof astOrCode === "string" ? parse(astOrCode, {
          withComments: true
        }) : astOrCode;
        var code = optCode || (typeof astOrCode === "string" ? astOrCode : stringify(astOrCode));
        var parsedComments = sortBy(commentsWithPathsAndNodes(parsed), function (c) {
          return c.comment.start;
        });
        return parsedComments.map(function (c, i) {
          if (isInObjectMethod(c)) {
            return merge([c, c.comment, {
              type: "method",
              comment: c.comment.text
            }, methodAttributesOf(c)]);
          }

          if (isInComputedMethod(c)) {
            return merge([c, c.comment, {
              type: "method",
              comment: c.comment.text
            }, computedMethodAttributesOf(c)]);
          }

          if (isInFunctionStatement(c)) {
            return merge([c, c.comment, {
              type: "function",
              comment: c.comment.text
            }, functionAttributesOf(c)]);
          }

          if (isInAssignedMethod(c)) {
            return merge([c, c.comment, {
              type: "method",
              comment: c.comment.text
            }, methodAttributesOfAssignment(c)]);
          }

          var followingNode = followingNodeOf(c);
          if (!followingNode) return merge([c, c.comment, {
            followingNode: followingNode
          }, unknownComment(c)]);
          var followingComment = parsedComments[i + 1];

          if (followingComment && followingComment.comment.start <= followingNode.start) {
            return merge([c, c.comment, {
              followingNode: followingNode
            }, unknownComment(c)]);
          }

          if (isSingleObjVarDeclaration(followingNode)) {
            return merge([c, c.comment, {
              followingNode: followingNode
            }, {
              type: "object",
              comment: c.comment.text
            }, objAttributesOf(followingNode)]);
          }

          if (isSingleVarDeclaration(followingNode)) {
            return merge([c, c.comment, {
              followingNode: followingNode
            }, {
              type: "var",
              comment: c.comment.text
            }, objAttributesOf(followingNode)]);
          }

          return merge([c, c.comment, {
            followingNode: followingNode
          }, unknownComment(c)]);
        });

        function commentsWithPathsAndNodes(parsed) {
          var comments = [];
          var v = new Visitor();
          v.accept = wrap(v.accept, function (proceed, node, state, path) {
            if (node.comments) {
              pushAll(comments, node.comments.map(function (comment) {
                return {
                  path: path,
                  comment: comment,
                  node: node
                };
              }));
            }

            return proceed(node, state, path);
          });
          v.accept(parsed, comments, []);
          return comments;
        }

        function followingNodeOf(comment) {
          return comment.node.body.find(function (node) {
            return node.start > comment.comment.end;
          });
        }

        function unknownComment(comment) {
          return {
            type: "unknown",
            comment: comment.comment.text
          };
        }

        function isInFunctionStatement(comment) {
          var node = Path(comment.path.slice(0, -1)).get(parsed);
          return node && node.type === "FunctionDeclaration";
        }

        function functionAttributesOf(comment) {
          var funcNode = Path(comment.path.slice(0, -1)).get(parsed);
          var name = funcNode.id ? funcNode.id.name : "<error: no name for function>";
          return {
            name: name,
            args: pluck(funcNode.params, "name")
          };
        }

        function isInObjectMethod(comment) {
          return equals(comment.path.slice(-2), ["value", "body"]);
        }

        function isInAssignedMethod(comment) {
          return equals(comment.path.slice(-2), ["right", "body"]);
        }

        function methodAttributesOf(comment) {
          var methodNode = Path(comment.path.slice(0, -2)).get(parsed);
          var name = methodNode.key ? methodNode.key.name : "<error: no name for method>";
          var p = comment.path.slice();
          var objectName = "<error: no object found for method>";

          while (p.length && last(p) !== "init") {
            p.pop();
          }

          if (p.length) {
            objectName = Path(p.slice(0, -1).concat(["id", "name"])).get(parsed);
          }

          if (startsWith(objectName, "<error")) {
            p = comment.path.slice();

            while (p.length && last(p) !== "right") {
              p.pop();
            }

            if (p.length) {
              var assignNode = Path(p.slice(0, -1).concat(["left"])).get(parsed);
              objectName = code.slice(assignNode.start, assignNode.end);
            }
          }

          if (startsWith(objectName, "<error")) {
            p = comment.path.slice();
            var callExpr = Path(p.slice(0, -6)).get(parsed);
            var isCall = callExpr && callExpr.type === "CallExpression";
            var firstArg = isCall && callExpr.arguments[0];
            if (firstArg) objectName = code.slice(firstArg.start, firstArg.end);
          }

          return {
            name: name,
            args: pluck(methodNode.value.params, "name"),
            objectName: objectName
          };
        }

        function methodAttributesOfAssignment(comment) {
          var node = Path(comment.path.slice(0, -1)).get(parsed);
          if (node.type !== "FunctionExpression" && node.type !== "FunctionDeclaration") return {};
          var statement = statementOf(parsed, node);
          if (statement.type !== "ExpressionStatement" || statement.expression.type !== "AssignmentExpression") return {};
          var objName = code.slice(statement.expression.left.object.start, statement.expression.left.object.end);
          var methodName = code.slice(statement.expression.left.property.start, statement.expression.left.property.end);
          return {
            name: methodName,
            objectName: objName,
            args: pluck(node.params, "name")
          };
        }

        function isInComputedMethod(comment) {
          var path = comment.path.slice(-5);
          removeAt(path, 1);
          return equals(path, ["properties", "value", "callee", "body"]);
        }

        function computedMethodAttributesOf(comment) {
          var name, args, pathToProp;
          pathToProp = comment.path.slice(0, -3);
          var propertyNode = Path(pathToProp).get(parsed);

          if (propertyNode && propertyNode.type === "Property") {
            args = pluck(propertyNode.value.callee.params, "name");
            name = propertyNode.key ? propertyNode.key.name : "<error: no name for method>";
          }

          if (!name) {
            pathToProp = comment.path.slice(0, -2);
            propertyNode = Path(pathToProp).get(parsed);

            if (propertyNode && propertyNode.type === "Property") {
              args = pluck(propertyNode.value.params, "name");
              name = propertyNode.key ? propertyNode.key.name : "<error: no name for method>";
            }
          }

          if (!name) {
            name = "<error: no name for method>";
            args = [];
            pathToProp = comment.path;
          }

          var p = clone$1(pathToProp);
          var objectName = "<error: no object found for method>";

          while (p.length && last(p) !== "init") {
            p.pop();
          }

          if (p.length) {
            objectName = Path(p.slice(0, -1).concat(["id", "name"])).get(parsed);
          }

          if (startsWith(objectName, "<error")) {
            var p = clone$1(pathToProp);

            while (p.length && last(p) !== "right") {
              p.pop();
            }

            if (p.length) {
              var assignNode = Path(p.slice(0, -1).concat(["left"])).get(parsed);
              objectName = code.slice(assignNode.start, assignNode.end);
            }
          }

          if (startsWith(objectName, "<error")) {
            var p = clone$1(pathToProp);
            var callExpr = Path(p.slice(0, -4)).get(parsed);
            var isCall = callExpr && callExpr.type === "CallExpression";
            var firstArg = isCall && callExpr.arguments[0];
            if (firstArg) objectName = code.slice(firstArg.start, firstArg.end);
          }

          return {
            name: name,
            args: args,
            objectName: objectName
          };
        }

        function isSingleObjVarDeclaration(node) {
          return isSingleVarDeclaration(node) && (node.declarations[0].init.type === "ObjectExpression" || isObjectAssignment(node.declarations[0].init));
        }

        function isSingleVarDeclaration(node) {
          return node && node.type === "VariableDeclaration" && node.declarations.length === 1;
        }

        function objAttributesOf(node) {
          return {
            name: node.declarations[0].id.name
          };
        }

        function isObjectAssignment(node) {
          if (node.type !== "AssignmentExpression") return false;
          if (node.right.type === "ObjectExpression") return true;
          if (node.right.type === "AssignmentExpression") return isObjectAssignment(node.right);
          return false;
        }
      }, __moduleMeta__$2);

      __varRecorder__$2.extractComments = extractComments;
      __varRecorder__$2.getCommentPrecedingNode = getCommentPrecedingNode;
      __varRecorder__$2.extractComments = extractComments;

      var comments = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getCommentPrecedingNode: getCommentPrecedingNode,
        extractComments: extractComments
      });

      var __varRecorder__$1 = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/lib/code-categorizer.js", __contextModule__);

      var __moduleMeta__$1 = {
        pathInPackage: function pathInPackage() {
          return "./lib/code-categorizer.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ast",
            version: "0.11.3"
          };
        }
      };

      var findDecls = exports('Y', __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("findDecls", "function", function (parsed, options) {
        options = options || merge({
          hideOneLiners: false
        }, options);

        if (typeof parsed === "string") {
          parsed = parse(parsed, {
            addSource: true
          });
        }

        var topLevelNodes = parsed.type === "Program" ? parsed.body : parsed.body.body;
        var defs = [];

        var _iterator = _createForOfIteratorHelper(topLevelNodes),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var node = _step.value;
            node = __varRecorder__$1.unwrapExport(node);

            var found = __varRecorder__$1.functionWrapper(node, options) || __varRecorder__$1.varDefs(node) || __varRecorder__$1.funcDef(node) || __varRecorder__$1.es6ClassDef(node) || __varRecorder__$1.someObjectExpressionCall(node) || __varRecorder__$1.describe(node);

            if (!found) continue;

            if (options.hideOneLiners) {
              if (parsed.loc) {
                found = found.filter(function (def) {
                  return !def.node.loc || def.node.loc.start.line !== def.node.loc.end.line;
                });
              } else if (parsed.source) {
                var filtered = [];

                var _iterator2 = _createForOfIteratorHelper(found),
                    _step2;

                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    var def = _step2.value;
                    if (def.parent && filtered.includes(def.parent) || (def.node.source || "").includes("\n")) filtered.push(def);
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }

                found = filtered;
              }
            }

            defs.push.apply(defs, _toConsumableArray(found));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return defs;
      }, __moduleMeta__$1));

      __varRecorder__$1.findDecls = findDecls;

      var es6ClassDef = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("es6ClassDef", "function", function (node) {
        var _def$children;

        if (node.type !== "ClassDeclaration") return null;
        var def = {
          type: "class-decl",
          name: node.id.name,
          node: node,
          children: []
        };

        (_def$children = def.children).push.apply(_def$children, _toConsumableArray(compact(node.body.body.map(function (node, i) {
          return __varRecorder__$1.es6ClassMethod(node, def, i);
        }))));

        return [def].concat(_toConsumableArray(def.children));
      }, __moduleMeta__$1);

      __varRecorder__$1.es6ClassDef = es6ClassDef;

      var es6ClassMethod = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("es6ClassMethod", "function", function (node, parent, i) {
        if (node.type !== "MethodDefinition") return null;
        var type;
        if (node.kind === "constructor") type = "class-constructor";else if (node.kind === "method") type = node["static"] ? "class-class-method" : "class-instance-method";else if (node.kind === "get") type = node["static"] ? "class-class-getter" : "class-instance-getter";else if (node.kind === "set") type = node["static"] ? "class-class-setter" : "class-instance-setter";
        if (type === "class-instance-getter" && node.key.name === "commands") return __varRecorder__$1.parseCommandsMethod(node, parent, type);
        if (type === "class-class-getter" && node.key.name === "properties") return __varRecorder__$1.parsePropertiesMethod(node, parent, type);
        return type ? {
          type: type,
          parent: parent,
          node: node,
          name: node.key.name
        } : null;
      }, __moduleMeta__$1);

      __varRecorder__$1.es6ClassMethod = es6ClassMethod;

      var parsePropertiesMethod = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("parsePropertiesMethod", "function", function (node, parent, type) {
        var propertiesNode = {
          type: type,
          parent: parent,
          node: node,
          name: node.key.name
        };

        try {
          var children = [];
          propertiesNode.node.value.body.body[0].argument.properties.forEach(function (property) {
            children.push({
              type: property.type,
              parent: propertiesNode,
              node: property,
              name: property.key ? property.key.name : property.argument.arguments[0].value
            });
          });
          propertiesNode.children = children;
        } finally {
          return propertiesNode;
        }
      }, __moduleMeta__$1);

      __varRecorder__$1.parsePropertiesMethod = parsePropertiesMethod;

      var parseCommandsMethod = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("parseCommandsMethod", "function", function (node, parent, type) {
        var commandsNode = {
          type: type,
          parent: parent,
          node: node,
          name: node.key.name
        };

        try {
          var children = [];

          if (commandsNode.node.value.body.body) {
            var commands = commandsNode.node.value.body.body[0].argument.elements;

            if (commands) {
              commands.forEach(function (command) {
                children.push({
                  type: command.type,
                  parent: commandsNode,
                  node: command,
                  name: command.properties[0].value.value
                });
              });
              commandsNode.children = children;
            }
          }
        } finally {
          return commandsNode;
        }
      }, __moduleMeta__$1);

      __varRecorder__$1.parseCommandsMethod = parseCommandsMethod;

      var varDefs = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("varDefs", "function", function (varDeclNode) {
        if (varDeclNode.type !== "VariableDeclaration") return null;
        var result = [];

        var _iterator3 = _createForOfIteratorHelper(__varRecorder__$1.withVarDeclIds(varDeclNode)),
            _step3;

        try {
          var _loop = function _loop() {
            var _step3$value = _step3.value,
                id = _step3$value.id,
                node = _step3$value.node;
            var def = {
              name: id.name,
              node: node,
              type: "var-decl"
            };
            result.push(def);
            if (!def.node.init) return "continue";
            var initNode = def.node.init;

            while (initNode.type === "AssignmentExpression") {
              initNode = initNode.right;
            }

            if (initNode.type === "ObjectExpression") {
              def.type = "object-decl";
              def.children = __varRecorder__$1.objectKeyValsAsDefs(initNode).map(function (ea) {
                return Object.assign({}, ea, {
                  type: "object-" + ea.type,
                  parent: def
                });
              });
              result.push.apply(result, _toConsumableArray(def.children));
              return "continue";
            }

            if (initNode.type === "ArrayExpression") {
              def.type = "array-decl";

              try {
                def.children = __varRecorder__$1.arrayEntriesAsDefs(initNode).map(function (ea) {
                  return Object.assign({}, ea, {
                    type: "object-" + ea.type,
                    parent: def
                  });
                });
                result.push.apply(result, _toConsumableArray(def.children));
              } finally {
                return "continue";
              }
            }

            var objDefs = __varRecorder__$1.someObjectExpressionCall(initNode, def);

            if (objDefs) {
              def.children = objDefs.map(function (d) {
                return Object.assign({}, d, {
                  parent: def
                });
              });
              result.push.apply(result, _toConsumableArray(def.children));
            }
          };

          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _ret = _loop();

            if (_ret === "continue") continue;
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return result;
      }, __moduleMeta__$1);

      __varRecorder__$1.varDefs = varDefs;

      var funcDef = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("funcDef", "function", function (node) {
        if (node.type !== "FunctionStatement" && node.type !== "FunctionDeclaration") return null;
        if (!node.id) return null;
        return [{
          name: node.id.name,
          node: node,
          type: "function-decl"
        }];
      }, __moduleMeta__$1);

      __varRecorder__$1.funcDef = funcDef;

      var someObjectExpressionCall = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("someObjectExpressionCall", "function", function (node, parentDef) {
        if (node.type === "ExpressionStatement") node = node.expression;
        if (node.type !== "CallExpression") return null;
        var objArg = node.arguments.find(function (a) {
          return a.type === "ObjectExpression";
        });
        if (!objArg) return null;
        return __varRecorder__$1.objectKeyValsAsDefs(objArg, parentDef);
      }, __moduleMeta__$1);

      __varRecorder__$1.someObjectExpressionCall = someObjectExpressionCall;

      var parseDescribeBlock = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("parseDescribeBlock", "function", function (parent) {
        var parseInSuits = ["describe", "xdescribe", "it", "xit", "after", "afterEach", "before", "beforeEach"];
        var nodes = [];
        parent.expression.arguments[1].body.body.forEach(function (subnode) {
          if (subnode.type !== "ExpressionStatement" || !subnode.expression.callee) return null;
          var type = subnode.expression.callee.name;
          if (!parseInSuits.includes(type)) return;
          var name = subnode.expression.arguments[0].value || subnode.expression.callee.name;
          var parsedSubNode = {
            name: name,
            node: subnode,
            type: type,
            parent: parent
          };

          if (subnode.expression.callee.name === "describe" || subnode.expression.callee.name === "xdescribe") {
            parsedSubNode.children = parseDescribeBlock(subnode);
          }

          nodes.push(parsedSubNode);
        });
        return nodes;
      }, __moduleMeta__$1);

      __varRecorder__$1.parseDescribeBlock = parseDescribeBlock;

      var describe = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("describe", "function", function (node) {
        if (node.type !== "ExpressionStatement") return null;
        if (node.expression && Path("expression.callee.name").get(node) !== "describe" && Path("expression.callee.name").get(node) !== "xdescribe") return null;
        var parsedNode = {
          name: node.expression.arguments[0].value,
          node: node,
          type: node.expression.callee.name
        };
        parsedNode.children = __varRecorder__$1.parseDescribeBlock(node);
        return [parsedNode];
      }, __moduleMeta__$1);

      __varRecorder__$1.describe = describe;

      var functionWrapper = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("functionWrapper", "function", function (node, options) {
        if (!__varRecorder__$1.isFunctionWrapper(node)) return null;
        var decls;
        var argFunc = Path("expression.arguments.0").get(node);

        if (argFunc && argFunc.type === "FunctionExpression" && lines(argFunc.source || "").length > 5) {
          decls = __varRecorder__$1.findDecls(argFunc, options);
        } else {
          decls = __varRecorder__$1.findDecls(Path("expression.callee").get(node), options);
        }

        var parent = {
          node: node,
          name: Path("expression.callee.id.name").get(node)
        };
        decls.forEach(function (decl) {
          return decl.parent || (decl.parent = parent);
        });
        return decls;
      }, __moduleMeta__$1);

      __varRecorder__$1.functionWrapper = functionWrapper;

      var unwrapExport = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("unwrapExport", "function", function (node) {
        return (node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration") && node.declaration ? node.declaration : node;
      }, __moduleMeta__$1);

      __varRecorder__$1.unwrapExport = unwrapExport;

      var objectKeyValsAsDefs = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("objectKeyValsAsDefs", "function", function (objectExpression, parent) {
        return objectExpression.properties.map(function (node) {
          return {
            name: node.key.name || node.key.value,
            type: node.value.type === "FunctionExpression" ? "method" : "property",
            node: node,
            parent: parent
          };
        });
      }, __moduleMeta__$1);

      __varRecorder__$1.objectKeyValsAsDefs = objectKeyValsAsDefs;

      var arrayEntriesAsDefs = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("arrayEntriesAsDefs", "function", function (arrayExpression, parent) {
        return arrayExpression.elements.map(function (node) {
          return {
            name: node.value || node.properties[0].value.value,
            type: node.type,
            node: node,
            parent: parent
          };
        });
      }, __moduleMeta__$1);

      __varRecorder__$1.arrayEntriesAsDefs = arrayEntriesAsDefs;

      var isFunctionWrapper = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("isFunctionWrapper", "function", function (node) {
        return Path("expression.type").get(node) === "CallExpression" && Path("expression.callee.type").get(node) === "FunctionExpression";
      }, __moduleMeta__$1);

      __varRecorder__$1.isFunctionWrapper = isFunctionWrapper;

      var declIds = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("declIds", "function", function (idNodes) {
        return idNodes.flatMap(function (ea) {
          if (!ea) return [];
          if (ea.type === "Identifier") return [ea];
          if (ea.type === "RestElement") return [ea.argument];

          if (ea.type === "ObjectPattern") {
            return declIds(pluck(ea.properties, "value"));
          }

          if (ea.type === "ArrayPattern") {
            return declIds(ea.elements);
          }

          return [];
        });
      }, __moduleMeta__$1);

      __varRecorder__$1.declIds = declIds;

      var withVarDeclIds = __varRecorder__$1["lively.ast/lib/code-categorizer.js__define__"]("withVarDeclIds", "function", function (varNode) {
        return varNode.declarations.map(function (declNode) {
          if (!declNode.source && declNode.init) {
            declNode.source = declNode.id.name + " = " + declNode.init.source;
          }

          return {
            node: declNode,
            id: declNode.id
          };
        });
      }, __moduleMeta__$1);

      __varRecorder__$1.withVarDeclIds = withVarDeclIds;
      __varRecorder__$1.findDecls = findDecls;

      var categorizer = /*#__PURE__*/Object.freeze({
        __proto__: null,
        findDecls: findDecls
      });

      var __varRecorder__ = (lively.FreezerRuntime || lively.frozenModules).recorderFor("lively.ast/index.js", __contextModule__);

      var __moduleMeta__ = {
        pathInPackage: function pathInPackage() {
          return "./index.js";
        },
        unsubscribeFromToplevelDefinitionChanges: function unsubscribeFromToplevelDefinitionChanges() {
          return function () {};
        },
        subscribeToToplevelDefinitionChanges: function subscribeToToplevelDefinitionChanges() {
          return function () {};
        },
        "package": function _package() {
          return {
            name: "lively.ast",
            version: "0.11.3"
          };
        }
      };

      var isValidIdentifier = exports('I', __varRecorder__["lively.ast/index.js__define__"]("isValidIdentifier", "function", function (string) {
        return __varRecorder__.isValidIdentifierRe.test(string);
      }, __moduleMeta__));

      __varRecorder__.isValidIdentifier = isValidIdentifier;
      __varRecorder__.BaseVisitor = Visitor;
      __varRecorder__.withMozillaAstDo = withMozillaAstDo;
      __varRecorder__.printAst = printAst;
      __varRecorder__.compareAst = compareAst;
      __varRecorder__.pathToNode = pathToNode;
      __varRecorder__.rematchAstWithSource = rematchAstWithSource;
      __varRecorder__.ReplaceManyVisitor = ReplaceManyVisitor;
      __varRecorder__.ReplaceVisitor = ReplaceVisitor;
      __varRecorder__.AllNodesVisitor = AllNodesVisitor;
      __varRecorder__.parse = parse;
      __varRecorder__.parseFunction = parseFunction;
      __varRecorder__.fuzzyParse = fuzzyParse;
      __varRecorder__.escodegen = es;
      __varRecorder__.acorn = acorn;
      __varRecorder__.walk = walk;
      __varRecorder__.query = query;
      __varRecorder__.transform = transform;
      __varRecorder__.comments = comments;
      __varRecorder__.categorizer = categorizer;
      __varRecorder__.stringify = stringify;
      __varRecorder__.nodes = nodes;
      __varRecorder__.custom = custom;
      __varRecorder__.isValidIdentifierRe = /^(?!(?:do|if|in|for|let|new|try|var|case|default|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/;
      __varRecorder__.isValidIdentifier = isValidIdentifier;
      __varRecorder__.Node = parse("").constructor;
      Object.defineProperty(__varRecorder__.Node.prototype, "__serialize__", {
        configurable: true,
        value: function value() {
          return {
            __expr__: "(" + JSON.stringify(this) + ")"
          };
        }
      });

      var parser = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BaseVisitor: Visitor,
        withMozillaAstDo: withMozillaAstDo,
        printAst: printAst,
        compareAst: compareAst,
        pathToNode: pathToNode,
        rematchAstWithSource: rematchAstWithSource,
        ReplaceManyVisitor: ReplaceManyVisitor,
        ReplaceVisitor: ReplaceVisitor,
        AllNodesVisitor: AllNodesVisitor,
        parse: parse,
        parseFunction: parseFunction,
        fuzzyParse: fuzzyParse,
        escodegen: es,
        acorn: acorn,
        walk: walk,
        query: query,
        transform: transform,
        comments: comments,
        categorizer: categorizer,
        stringify: stringify,
        nodes: nodes,
        custom: custom,
        isValidIdentifier: isValidIdentifier
      });
      exports('T', parser);

    })
  };
}));
